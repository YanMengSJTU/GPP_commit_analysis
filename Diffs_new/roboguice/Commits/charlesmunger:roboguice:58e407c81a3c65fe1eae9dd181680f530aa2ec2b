diff --git a/roboguice/pom.xml b/roboguice/pom.xml
index 1ee0ee837..b0f5cc356 100644
--- a/roboguice/pom.xml
+++ b/roboguice/pom.xml
@@ -106,13 +106,13 @@
         <dependency>
             <groupId>com.google.android</groupId>
             <artifactId>android</artifactId>
-            <version>2.1.2</version>
+            <version>4.1.1.4</version>
             <scope>provided</scope>
         </dependency>
         <dependency>
             <groupId>com.google.android</groupId>
             <artifactId>android-test</artifactId>
-            <version>2.1.2</version>
+            <version>4.1.1.4</version>
             <scope>provided</scope>
         </dependency>
         <dependency>
diff --git a/roboguice/src/main/java/roboguice/config/DefaultRoboModule.java b/roboguice/src/main/java/roboguice/config/DefaultRoboModule.java
index 810318021..716a7d475 100644
--- a/roboguice/src/main/java/roboguice/config/DefaultRoboModule.java
+++ b/roboguice/src/main/java/roboguice/config/DefaultRoboModule.java
@@ -174,12 +174,13 @@ protected void configure() {
 
         requestStaticInjection(Ln.class);
 
+        System.out.println("hasSupport = "+FragmentUtil.hasSupport+ " hasNative = " +FragmentUtil.hasNative);
         // Compatibility library bindings
         if(FragmentUtil.hasSupport) {
-            bind(FragmentUtil.supportFrag.fragmentManagerType()).toProvider(roboguice.support.fragment.FragmentManagerProvider.class);
+            bind(FragmentUtil.supportFrag.fragmentManagerType()).toProvider(FragmentUtil.supportFrag.fragmentManagerProviderType());
         }
         if(FragmentUtil.hasNative) {
-        	bind(FragmentUtil.nativeFrag.fragmentManagerType()).toProvider(roboguice.provided.fragment.FragmentManagerProvider.class);
+        	bind(FragmentUtil.nativeFrag.fragmentManagerType()).toProvider(FragmentUtil.nativeFrag.fragmentManagerProviderType());
         }
 
 
diff --git a/roboguice/src/main/java/roboguice/inject/ViewListener.java b/roboguice/src/main/java/roboguice/inject/ViewListener.java
index 018a573f0..e89d4b9e1 100644
--- a/roboguice/src/main/java/roboguice/inject/ViewListener.java
+++ b/roboguice/src/main/java/roboguice/inject/ViewListener.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 import android.view.View;
 import roboguice.provided.fragment.FragmentUtil;
+import roboguice.provided.fragment.FragmentUtil.f;
 
 import com.google.inject.MembersInjector;
 import com.google.inject.Provider;
@@ -47,43 +48,49 @@
                     if (Modifier.isStatic(field.getModifiers()))
                         throw new UnsupportedOperationException("Views may not be statically injected");
                     else if (!View.class.isAssignableFrom(field.getType()))
-                        throw new UnsupportedOperationException("You may only use @InjectView on fields descended from type View");
+                    	throw new UnsupportedOperationException("You may only use @InjectView on fields descended from type View");
                     else if (Context.class.isAssignableFrom(field.getDeclaringClass()) && !Activity.class.isAssignableFrom(field.getDeclaringClass()))
-                        throw new UnsupportedOperationException("You may only use @InjectView in Activity contexts");
-                    else
-                        typeEncounter.register(new ViewMembersInjector<I>(field, field.getAnnotation(InjectView.class), typeEncounter, null));
+                    	throw new UnsupportedOperationException("You may only use @InjectView in Activity contexts");
+                    else {
+                    	final f utils = FragmentUtil.hasSupport 
+                    			&& (FragmentUtil.supportActivity.isAssignableFrom(field.getDeclaringClass()) 
+                    					|| FragmentUtil.supportFrag.fragmentType().isAssignableFrom(field.getDeclaringClass()))
+                    					? FragmentUtil.supportFrag : FragmentUtil.nativeFrag;
+
+                    	typeEncounter.register(new ViewMembersInjector<I>(
+                    			field, field.getAnnotation(InjectView.class),
+                    			typeEncounter, utils));
+                    }
 
                 else if (field.isAnnotationPresent(InjectFragment.class))
                     if (!FragmentUtil.hasNative && !FragmentUtil.hasSupport) {
                         throw new RuntimeException(new ClassNotFoundException("No fragment classes were available"));
-                    }
-
-                if (Modifier.isStatic(field.getModifiers())) {
-                    throw new UnsupportedOperationException("Fragments may not be statically injected");
-
-                } else {
-                    final boolean assignableFromNative = FragmentUtil.hasNative && FragmentUtil.nativeFrag.fragmentType().isAssignableFrom(field.getType());
-                    final boolean assignableFromSupport = FragmentUtil.hasSupport && FragmentUtil.supportFrag.fragmentType().isAssignableFrom(field.getType());
-                    final boolean isSupportActivity = FragmentUtil.hasSupport && FragmentUtil.supportActivity.isAssignableFrom(field.getDeclaringClass());
-                    final boolean isNativeActivity = !isSupportActivity && Activity.class.isAssignableFrom(field.getDeclaringClass());
-
-                    if ((isNativeActivity && assignableFromNative) || (isSupportActivity && assignableFromSupport)) {
-                        typeEncounter.register(new ViewMembersInjector<I>(field, field.getAnnotation(InjectFragment.class), typeEncounter, isNativeActivity ? FragmentUtil.nativeFrag:FragmentUtil.supportFrag));
-                    }
-                    // Error messages - these filters are comprehensive. The
-                    // final else block will never execute.
-                    else if (isNativeActivity && !assignableFromNative) {
-                        throw new UnsupportedOperationException(
-                                "You may only use @InjectFragment in native activities if fields are descended from type android.app.Fragment");
-                    } else if (!isSupportActivity && !isNativeActivity) {
-                        throw new UnsupportedOperationException("You may only use @InjectFragment in Activity contexts");
-                    } else if (isSupportActivity && !assignableFromSupport) {
-                        throw new UnsupportedOperationException(
-                                "You may only use @InjectFragment in support activities if fields are descended from type android.support.v4.app.Fragment");
-                    } else {
-                        throw new RuntimeException("This should never happen.");
-                    }
-                }
+                    } else if (Modifier.isStatic(field.getModifiers())) {
+                    	throw new UnsupportedOperationException("Fragments may not be statically injected");
+
+	                } else {
+	                    final boolean assignableFromNative = FragmentUtil.hasNative && FragmentUtil.nativeFrag.fragmentType().isAssignableFrom(field.getType());
+	                    final boolean assignableFromSupport = FragmentUtil.hasSupport && FragmentUtil.supportFrag.fragmentType().isAssignableFrom(field.getType());
+	                    final boolean isSupportActivity = FragmentUtil.hasSupport && FragmentUtil.supportActivity.isAssignableFrom(field.getDeclaringClass());
+	                    final boolean isNativeActivity = !isSupportActivity && Activity.class.isAssignableFrom(field.getDeclaringClass());
+	
+	                    if ((isNativeActivity && assignableFromNative) || (isSupportActivity && assignableFromSupport)) {
+	                        typeEncounter.register(new ViewMembersInjector<I>(field, field.getAnnotation(InjectFragment.class), typeEncounter, isNativeActivity ? FragmentUtil.nativeFrag:FragmentUtil.supportFrag));
+	                    }
+	                    // Error messages - these filters are comprehensive. The
+	                    // final else block will never execute.
+	                    else if (isNativeActivity && !assignableFromNative) {
+	                        throw new UnsupportedOperationException(
+	                                "You may only use @InjectFragment in native activities if fields are descended from type android.app.Fragment");
+	                    } else if (!isSupportActivity && !isNativeActivity) {
+	                        throw new UnsupportedOperationException("You may only use @InjectFragment in Activity contexts");
+	                    } else if (isSupportActivity && !assignableFromSupport) {
+	                        throw new UnsupportedOperationException(
+	                                "You may only use @InjectFragment in support activities if fields are descended from type android.support.v4.app.Fragment");
+	                    } else {
+	                        throw new RuntimeException("This should never happen.");
+	                    }
+	                }
             }
     }
 
@@ -180,7 +187,6 @@ protected void reallyInjectMemberViews(Object activityOrFragment) {
                 else
                     view = fragUtils !=null && fragUtils.fragmentType().isInstance(activityOrFragment) ? (fragUtils.getView(activityOrFragment)).findViewWithTag(injectView.tag()) : ((Activity)activityOrFragment).getWindow().getDecorView().findViewWithTag(injectView.tag());
 
-
                 if (view == null && Nullable.notNullable(field))
                     throw new NullPointerException(String.format("Can't inject null value into %s.%s when field is not @Nullable", field.getDeclaringClass(), field.getName()));
 
diff --git a/roboguice/src/main/java/roboguice/provided/fragment/FragmentUtil.java b/roboguice/src/main/java/roboguice/provided/fragment/FragmentUtil.java
index e2c0b1cf5..7eb278b2a 100644
--- a/roboguice/src/main/java/roboguice/provided/fragment/FragmentUtil.java
+++ b/roboguice/src/main/java/roboguice/provided/fragment/FragmentUtil.java
@@ -1,5 +1,7 @@
 package roboguice.provided.fragment;
 
+import com.google.inject.Provider;
+
 import android.view.View;
 
 public class FragmentUtil {
@@ -18,20 +20,21 @@
         public fragType findFragmentByTag(fragManagerType fm, String tag);
         public Class fragmentType();
         public Class fragmentManagerType();
+        public Class<Provider<fragManagerType>> fragmentManagerProviderType();
     }
     
     
     static {
         try {
             nativeFrag = (f) Class.forName("roboguice.provided.fragment.NativeFragmentUtil").newInstance();
-            hasNative = true;
-        } catch (Exception e) {}
+            hasNative = nativeFrag != null;
+        } catch (Throwable e) {}
         
         try {
-            supportFrag = (f) Class.forName("roboguice.support.SupportFragmentUtil").newInstance();
+            supportFrag = (f) Class.forName("roboguice.support.fragment.SupportFragmentUtil").newInstance();
             supportActivity = Class.forName(SUPPORT_PACKAGE+"FragmentActivity");
-            hasSupport = true;
-        } catch (Exception e) {}
+            hasSupport = supportFrag != null && supportActivity != null;
+        } catch (Throwable e) {}
         
     }
 }
diff --git a/roboguice/src/main/java/roboguice/provided/fragment/NativeFragmentUtil.java b/roboguice/src/main/java/roboguice/provided/fragment/NativeFragmentUtil.java
index 483c97dae..baef867a1 100644
--- a/roboguice/src/main/java/roboguice/provided/fragment/NativeFragmentUtil.java
+++ b/roboguice/src/main/java/roboguice/provided/fragment/NativeFragmentUtil.java
@@ -1,14 +1,25 @@
 package roboguice.provided.fragment;
 
+import roboguice.provided.fragment.FragmentUtil.f;
+
 import android.annotation.TargetApi;
 import android.app.Fragment;
 import android.app.FragmentManager;
 import android.view.View;
-
-import roboguice.provided.fragment.FragmentUtil.f;
 @TargetApi(13)
 public class NativeFragmentUtil implements f<Fragment,FragmentManager> {
-
+	//Incredible hack required to ensure that classes are loaded at construction time
+	//I.E. so that it fails fast if they're not found. TODO fix this
+	
+	//I thought about just depending on the API level, but that broke Robolectric.
+	private final Class frag;
+	private final Class fragM;
+	
+	public NativeFragmentUtil() throws ClassNotFoundException {
+		frag = Class.forName(Fragment.class.getName());
+		fragM = Class.forName(FragmentManager.class.getName());
+	}
+	
     @Override
     public View getView(Fragment frag) {
         return frag.getView();
@@ -33,4 +44,10 @@ public Fragment findFragmentByTag(FragmentManager fm, String tag) {
     public Class<FragmentManager> fragmentManagerType() {
         return FragmentManager.class;
     }
+
+	@Override
+	public Class fragmentManagerProviderType() {
+		return FragmentManagerProvider.class;
+	}
+
 }
diff --git a/roboguice/src/main/java/roboguice/support/fragment/SupportFragmentUtil.java b/roboguice/src/main/java/roboguice/support/fragment/SupportFragmentUtil.java
index ff407ff84..49ba5769e 100644
--- a/roboguice/src/main/java/roboguice/support/fragment/SupportFragmentUtil.java
+++ b/roboguice/src/main/java/roboguice/support/fragment/SupportFragmentUtil.java
@@ -7,7 +7,16 @@
 import android.view.View;
 
 public class SupportFragmentUtil implements f<Fragment, FragmentManager>{
-
+	// Incredible hack required to ensure that classes are loaded at construction time
+	// I.E. so that it fails fast if they're not found. TODO fix this
+	private final Class frag;
+	private final Class fragM;
+
+	public SupportFragmentUtil() throws ClassNotFoundException {
+		frag = Class.forName(Fragment.class.getName());
+		fragM = Class.forName(FragmentManager.class.getName());
+	}
+	
     @Override
     public View getView(Fragment frag) {
         return frag.getView();
@@ -33,4 +42,9 @@ public Fragment findFragmentByTag(FragmentManager fm, String tag) {
         return FragmentManager.class;
     }
 
+	@Override
+	public Class fragmentManagerProviderType() {
+		return FragmentManagerProvider.class;
+	}
+
 }
