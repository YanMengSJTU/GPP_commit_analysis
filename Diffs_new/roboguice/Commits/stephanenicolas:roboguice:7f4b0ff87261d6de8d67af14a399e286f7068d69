diff --git a/afterburner/src/main/java/afterburner/PostProcessor.java b/afterburner/src/main/java/afterburner/PostProcessor.java
index faf86f342..b3167b085 100644
--- a/afterburner/src/main/java/afterburner/PostProcessor.java
+++ b/afterburner/src/main/java/afterburner/PostProcessor.java
@@ -5,14 +5,18 @@
 import java.util.List;
 
 import javassist.CannotCompileException;
+import javassist.ClassPool;
 import javassist.CtClass;
 import javassist.CtField;
 import javassist.CtMethod;
+import javassist.CtNewMethod;
+import javassist.NotFoundException;
 import javassist.expr.ExprEditor;
 import javassist.expr.MethodCall;
 import roboguice.inject.ContentView;
 import roboguice.inject.InjectFragment;
 import roboguice.inject.InjectView;
+import android.app.Activity;
 
 import com.github.drochetti.javassist.maven.ClassTransformer;
 
@@ -21,36 +25,86 @@
     @Override
     protected void applyTransformations(final CtClass classToTransform) throws Exception {
         // Actually you must test if it exists, but it's just an example...
+        System.out.println("Analysing "+classToTransform);
+        injectStuffInClass(classToTransform);
+    }
 
-        CtMethod onCreateMethod = classToTransform.getDeclaredMethod("onCreate");
-        onCreateMethod.instrument( new ExprEditor() {
-            @Override
-            public void edit(MethodCall m) throws CannotCompileException {
-                System.out.println("method call "+m.getMethodName());
-                if( m.getMethodName().equals("onCreate") ) {
-                    int layoutId = -1;
-                    try {
-                        layoutId = ((ContentView)m.getEnclosingClass().getAnnotation(ContentView.class)).value();
-                    } catch (ClassNotFoundException e) {
-                        e.printStackTrace();
-                    }
-                    List<CtField> views = getAllInjectedFieldsForAnnotation(m.getEnclosingClass(), InjectView.class);
-                    List<CtField> fragments = getAllInjectedFieldsForAnnotation(m.getEnclosingClass(), InjectFragment.class);
-                    String fieldsNameList = extractAllNames(views);
-                    System.out.println("super.onCreate call "+m.getMethodName());
-                    String string = "$_ = $proceed($$);\n"+
-                            "System.out.println(\"Injectable fields in : "+m.getEnclosingClass().getName()+"\");\n"+
-                            "System.out.println(\"fields : "+fieldsNameList+"\");\n"+
-                            "setContentView("+layoutId+");\n"+
-                            injectFragmentStatements(fragments);
-                    System.out.println("Injected : " + string);
-                    m.replace(string );
-                }
+    private void injectStuffInClass(final CtClass classToTransform) throws NotFoundException, ClassNotFoundException, CannotCompileException {
+        boolean isActivity = classToTransform.subclassOf(ClassPool.getDefault().get(Activity.class.getName()));
+        boolean hasAfterBurner = checkIfAfterBurnerAlreadyActive(classToTransform);
+        if( isActivity && !hasAfterBurner ) {
+            int layoutId = getLayoutId(classToTransform);
+            final List<CtField> views = getAllInjectedFieldsForAnnotation(classToTransform, InjectView.class);
+            final List<CtField> fragments = getAllInjectedFieldsForAnnotation(classToTransform, InjectFragment.class);
+            if( views.isEmpty() && fragments.isEmpty() ) {
+                return;
+            }
+            CtMethod onCreateMethod = extractOnCreateMethod(classToTransform);
+            if( onCreateMethod != null ) {
+                DetectMethodCallEditor dectedSetContentViewEditor = new DetectMethodCallEditor(classToTransform, "setContentView");
+                onCreateMethod.instrument(dectedSetContentViewEditor);
+                boolean isCallingSetContentView = dectedSetContentViewEditor.isCallingMethod();
+                InjectorEditor injectorEditor = new InjectorEditor(classToTransform, fragments, views, layoutId, isCallingSetContentView);
+                onCreateMethod.instrument( injectorEditor);
+            } else {
+                classToTransform.addMethod( CtNewMethod.make(createOnCreateBody(classToTransform, views, fragments, layoutId)
+                                , classToTransform));
             }
+            classToTransform.detach();
+            injectStuffInClass( classToTransform.getSuperclass() );
+        } else {
+            //must be thrown, otherwise, breaks bytecode
+            throw new RuntimeException("Not an activity");
+        }
+    }
+
+    private String createOnCreateBody(CtClass classToTransform, List<CtField> views, List<CtField> fragments, int layoutId) {
+        return "public void onCreate(android.os.Bundle bundle) { \n"
+                + "super.onCreate(bundle);\n"
+                + createInjectedBody(classToTransform, views, fragments, layoutId, false)
+                + "}";
 
+    }
+
+    private CtMethod extractOnCreateMethod(final CtClass classToTransform) {
+        CtMethod onCreateMethod = null;
+        try {
+            onCreateMethod = classToTransform.getDeclaredMethod("onCreate");
+        } catch (Exception e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        return onCreateMethod;
+    }
 
-        });
-        classToTransform.detach();
+    private int getLayoutId(final CtClass classToTransform) {
+        int layoutId = -1;
+        try {
+            layoutId = ((ContentView)classToTransform.getAnnotation(ContentView.class)).value();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return layoutId;
+    }
+
+    private boolean checkIfAfterBurnerAlreadyActive(final CtClass classToTransform) {
+        boolean hasAfterBurner = false;
+        try {
+            classToTransform.getDeclaredField("afterBurnerActive");
+            hasAfterBurner = true;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return hasAfterBurner;
+    }
+
+    private void markAfterBurnerActiveInClass(final CtClass classToTransform) throws CannotCompileException {
+        classToTransform.addField(new CtField(CtClass.booleanType,"afterBurnerActive", classToTransform));
+    }
+
+
+    private String injectContentView(int layoutId) {
+        return "setContentView("+layoutId+");\n";
     }
 
     private String injectFragmentStatements(List<CtField> fragments) {
@@ -71,17 +125,23 @@ private String injectFragmentStatements(List<CtField> fragments) {
         }
         return buffer.toString();
     }
-    private String extractAllNames(List<CtField> fields) {
+
+    private String injectViewStatements(List<CtField> views) {
         StringBuffer buffer = new StringBuffer();
-        buffer.append('[');
-        for (CtField field : fields) {
-            buffer.append(field.getName());
-            buffer.append(',');
-        }
-        if( buffer.length() > 1 ) {
-            buffer.deleteCharAt(buffer.length()-1);
+        try {
+            for( CtField field : views ) {
+                int id;
+                id = ((InjectFragment)field.getAnnotation(InjectFragment.class)).value();
+                buffer.append( field.getName() );
+                buffer.append( " = " );
+                buffer.append( '(' );
+                buffer.append( field.getType().getName() );
+                buffer.append( ')' );
+                buffer.append( "findViewById("+id+");\n" );
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
         }
-        buffer.append(']');
         return buffer.toString();
     }
 
@@ -98,4 +158,78 @@ private String extractAllNames(List<CtField> fields) {
         return result;
     }
 
+    private String createInjectedBody(CtClass classToTransform, List<CtField> views, List<CtField> fragments, int layoutId, boolean isCallingSetContentView) {
+        StringBuffer buffer = new StringBuffer();
+        String message = String.format("Class %s has been enhanced.", classToTransform.getName());
+        buffer.append("android.util.Log.d(\"RoboGuice post-processor\",\""+message+"\");\n");
+
+        if( layoutId != -1 && !isCallingSetContentView ) { 
+            buffer.append(injectContentView(layoutId));
+        }
+        if( !views.isEmpty() ) {
+            buffer.append(injectViewStatements(views));
+        }
+        if( !fragments.isEmpty() ) {
+            buffer.append(injectFragmentStatements(fragments));
+        }
+        String string = buffer.toString();
+        return string;
+    }
+
+
+    private final class InjectorEditor extends ExprEditor {
+        private final CtClass classToTransform;
+        private final List<CtField> fragments;
+        private final List<CtField> views;
+        private final int layoutId;
+        private boolean isCallingSetContentView;
+
+        private InjectorEditor(CtClass classToTransform, List<CtField> fragments, List<CtField> views, int layoutId, boolean isCallingSetContentView) {
+            this.classToTransform = classToTransform;
+            this.fragments = fragments;
+            this.views = views;
+            this.layoutId = layoutId;
+            this.isCallingSetContentView = isCallingSetContentView;
+        }
+
+        @Override
+        public void edit(MethodCall m) throws CannotCompileException {
+            System.out.println("method call "+m.getMethodName());
+            String insertionMethod = isCallingSetContentView ? "setContentView" : "onCreate";
+            if( m.getMethodName().equals(insertionMethod) ) {
+                System.out.println("insertion method "+m.getMethodName());
+
+                String string = "$_ = $proceed($$);\n"+createInjectedBody(m.getEnclosingClass(), views, fragments, layoutId, isCallingSetContentView );
+                System.out.println("Injected : " + string);
+
+                m.replace(string );
+                //mark class to avoid duplicate
+                markAfterBurnerActiveInClass(classToTransform);
+            }
+        }
+
+    }
+
+    private final class DetectMethodCallEditor extends ExprEditor {
+
+        private String methodName;
+        private boolean isCallingMethod;
+
+        private DetectMethodCallEditor(CtClass classToTransform, String methodName ) {
+            this.methodName = methodName;
+        }
+
+        @Override
+        public void edit(MethodCall m) throws CannotCompileException {
+            if( m.getMethodName().equals(methodName) ) {
+                this.isCallingMethod = true;
+            }
+        }
+
+        public boolean isCallingMethod() {
+            return isCallingMethod;
+        }
+
+    }
+
 }
diff --git a/roboguice/.project b/roboguice/.project
index 4f4df3951..e4bd6967d 100644
--- a/roboguice/.project
+++ b/roboguice/.project
@@ -11,12 +11,12 @@
 			</arguments>
 		</buildCommand>
 		<buildCommand>
-			<name>org.eclipse.m2e.core.maven2Builder</name>
+			<name>net.sf.eclipsecs.core.CheckstyleBuilder</name>
 			<arguments>
 			</arguments>
 		</buildCommand>
 		<buildCommand>
-			<name>net.sf.eclipsecs.core.CheckstyleBuilder</name>
+			<name>org.eclipse.m2e.core.maven2Builder</name>
 			<arguments>
 			</arguments>
 		</buildCommand>
