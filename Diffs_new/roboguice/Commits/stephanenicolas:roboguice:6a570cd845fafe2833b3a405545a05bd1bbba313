diff --git a/astroboy/AndroidManifest.xml b/astroboy/AndroidManifest.xml
index 8e146d02d..d417c7ef7 100644
--- a/astroboy/AndroidManifest.xml
+++ b/astroboy/AndroidManifest.xml
@@ -1,7 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="org.roboguice.astroboy" android:versionCode="1" android:versionName="0.1-SNAPSHOT">
+          package="org.roboguice.astroboy" android:versionCode="1" android:versionName="0.1-SNAPSHOT" >
 
+    <uses-sdk android:minSdkVersion="3" android:targetSdkVersion="17"/>
     <application android:icon="@drawable/icon" android:label="Astroboy Master Console">
 
         <activity android:name=".activity.AstroboyMasterConsole">
diff --git a/astroboy/pom.xml b/astroboy/pom.xml
index 1c6edc56e..fcacc3221 100644
--- a/astroboy/pom.xml
+++ b/astroboy/pom.xml
@@ -28,6 +28,12 @@
 			<artifactId>support-v4</artifactId>
 			<version>r7</version>
 		</dependency>
+		<!-- http://code.google.com/p/google-guice/wiki/UseNullable -->
+		<dependency>
+			<groupId>com.google.code.findbugs</groupId>
+			<artifactId>jsr305</artifactId>
+			<version>1.3.9</version>
+		</dependency>
 		
 
 		<!-- TEST DEPENDENCIES -->
diff --git a/astroboy/res/layout-land/main.xml b/astroboy/res/layout-land/main.xml
new file mode 100644
index 000000000..6de3d4046
--- /dev/null
+++ b/astroboy/res/layout-land/main.xml
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    android:orientation="horizontal" >
+
+    <LinearLayout
+        android:layout_width="0dp"
+        android:layout_height="fill_parent"
+        android:layout_weight="1"
+        android:orientation="vertical" >
+
+        <TextView
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="20dp"
+            android:text="Welcome back, Doctor Tenma." />
+
+        <TextView
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:text="Send a remote command to Astroboy:" />
+
+        <EditText
+            android:id="@+id/say_text"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:hint="Say Something" />
+
+        <Button
+            android:id="@+id/brush_teeth"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:text="Brush Teeth" />
+
+        <Button
+            android:id="@+id/fight_evil"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:tag="fightevil"
+            android:text="Fight Forces of Evil" />
+
+        <Button
+            android:id="@+id/self_destruct"
+            android:layout_width="fill_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"
+            android:text="Self Destruct" />
+    </LinearLayout>
+
+    <LinearLayout
+        android:id="@+id/fragment_container"
+        android:layout_width="0dp"
+        android:layout_height="fill_parent"
+        android:layout_weight="1"
+        android:orientation="vertical" >
+
+    </LinearLayout>
+
+</LinearLayout>
\ No newline at end of file
diff --git a/astroboy/src/main/java/org/roboguice/astroboy/activity/AstroboyMasterConsole.java b/astroboy/src/main/java/org/roboguice/astroboy/activity/AstroboyMasterConsole.java
index 7a4f0edc0..ce5f1e502 100644
--- a/astroboy/src/main/java/org/roboguice/astroboy/activity/AstroboyMasterConsole.java
+++ b/astroboy/src/main/java/org/roboguice/astroboy/activity/AstroboyMasterConsole.java
@@ -1,46 +1,63 @@
 package org.roboguice.astroboy.activity;
 
+import javax.annotation.Nullable;
+
 import org.roboguice.astroboy.R;
 import org.roboguice.astroboy.controller.AstroboyRemoteControl;
-import roboguice.activity.RoboActivity;
+import org.roboguice.astroboy.fragment.FightForcesOfEvilFragment;
+import org.roboguice.astroboy.fragment.FightForcesOfEvilFragment.ForceOfEvilFoughtEvent;
+
+import roboguice.activity.RoboFragmentActivity;
+import roboguice.event.EventManager;
+import roboguice.event.EventProducer;
+import roboguice.event.Observes;
 import roboguice.inject.ContentView;
 import roboguice.inject.InjectView;
-
 import android.content.Intent;
 import android.os.Bundle;
 import android.os.Vibrator;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentTransaction;
 import android.view.KeyEvent;
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.widget.Button;
 import android.widget.EditText;
+import android.widget.LinearLayout;
 import android.widget.TextView;
 import android.widget.TextView.OnEditorActionListener;
 
 import com.google.inject.Inject;
 
-
 /**
- * This activity uses an AstroboyRemoteControl to control Astroboy remotely!
- *
- * What you'll learn in this class:
- *   - How to use @InjectView as a typesafe version of findViewById()
- *   - How to inject plain old java objects as well (POJOs)
- *   - When injection happens
- *   - Some basics about injection, including when injection results in a call to
- *     an object's default constructor, versus when it does something "special"
- *     like call getSystemService()
+ * This activity uses an AstroboyRemoteControl to control Astroboy remotely! What you'll learn in
+ * this class: - How to use @InjectView as a typesafe version of findViewById() - How to inject
+ * plain old java objects as well (POJOs) - When injection happens - Some basics about injection,
+ * including when injection results in a call to an object's default constructor, versus when it
+ * does something "special" like call getSystemService()
  */
 @ContentView(R.layout.main)
-public class AstroboyMasterConsole extends RoboActivity {
+public class AstroboyMasterConsole extends RoboFragmentActivity {
+
+    protected static final String FIGHT_FORCES_OF_EVIL_FRAGMENT_TAG = "FIGHT_FORCES_OF_EVIL_FRAGMENT_TAG";
 
     // Various views that we inject into the activity.
     // Equivalent to calling findViewById() in your onCreate(), except more succinct
-    @InjectView(R.id.self_destruct) Button selfDestructButton;
-    @InjectView(R.id.say_text)      EditText sayText;
-    @InjectView(R.id.brush_teeth)   Button brushTeethButton;
-    @InjectView(tag="fightevil")    Button fightEvilButton;     // we can also use tags if we want
-
+    @InjectView(R.id.self_destruct)
+    Button selfDestructButton;
+    @InjectView(R.id.say_text)
+    EditText sayText;
+    @InjectView(R.id.brush_teeth)
+    Button brushTeethButton;
+    @InjectView(tag = "fightevil")
+    Button fightEvilButton; // we can also use tags if we want
+
+    @Nullable
+    @InjectView(R.id.fragment_container)
+    LinearLayout fragmentContainer;
+
+    @Inject
+    EventManager eventManager; // only necessary to send events, not to receive them.
 
     // Standard Guice injection of Plain Old Java Objects (POJOs)
     // Guice will find or create the appropriate instance of AstroboyRemoteControl for us
@@ -48,34 +65,44 @@
     // will create a new instance for us using AstroboyRemoteControl's default constructor.
     // Contrast this with Vibrator, which is an Android service that is pre-bound by RoboGuice.
     // Injecting a Vibrator will return a new instance of a Vibrator obtained by calling
-    // context.getSystemService(VIBRATOR_SERVICE).  This is configured in DefaultRoboModule, which is
+    // context.getSystemService(VIBRATOR_SERVICE). This is configured in DefaultRoboModule, which is
     // used by default to configure every RoboGuice injector.
-    @Inject AstroboyRemoteControl remoteControl;
-    @Inject Vibrator vibrator;
-
+    @Inject
+    AstroboyRemoteControl remoteControl;
+    @Inject
+    Vibrator vibrator;
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState); // @Inject, @InjectResource, and @InjectExtra injection happens during super.onCreate()
+        super.onCreate(savedInstanceState); // @Inject, @InjectResource, and @InjectExtra injection
+        // happens during super.onCreate()
 
         sayText.setOnEditorActionListener(new OnEditorActionListener() {
             public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
 
                 // Have the remoteControl tell Astroboy to say something
-                remoteControl.say(textView.getText().toString());
+                String message = textView.getText().toString();
+                remoteControl.say(message);
                 textView.setText(null);
+
+                AstroSpeechEvent event = new AstroSpeechEvent(message);
+                eventManager.fire(event);
+                eventManager.registerProducer(AstroSpeechEvent.class, new AstroSpeechEventProducer(event));
                 return true;
             }
         });
 
-        brushTeethButton.setOnClickListener( new OnClickListener() {
+        brushTeethButton.setOnClickListener(new OnClickListener() {
             public void onClick(View view) {
+                detachFightForcesOfEvilFragment();
+
                 remoteControl.brushTeeth();
             }
         });
 
-        selfDestructButton.setOnClickListener( new OnClickListener() {
+        selfDestructButton.setOnClickListener(new OnClickListener() {
             public void onClick(View view) {
+                detachFightForcesOfEvilFragment();
 
                 // Self destruct the remoteControl
                 vibrator.vibrate(2000);
@@ -84,16 +111,59 @@ public void onClick(View view) {
         });
 
         // Fighting the forces of evil deserves its own activity
-        fightEvilButton.setOnClickListener( new OnClickListener() {
+        fightEvilButton.setOnClickListener(new OnClickListener() {
             public void onClick(View view) {
-                startActivity(new Intent(AstroboyMasterConsole.this, FightForcesOfEvilActivity.class));
+                boolean hasFragmentContainer = fragmentContainer != null;
+                if (hasFragmentContainer) {
+                    Fragment fightForcesOfEvilFragment = getSupportFragmentManager().findFragmentByTag(FIGHT_FORCES_OF_EVIL_FRAGMENT_TAG);
+                    if (fightForcesOfEvilFragment == null) {
+                        Fragment fragment = new FightForcesOfEvilFragment();
+                        FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
+                        ft.add(R.id.fragment_container, fragment, FIGHT_FORCES_OF_EVIL_FRAGMENT_TAG);
+                        ft.commit();
+                    }
+                } else {
+                    startActivity(new Intent(AstroboyMasterConsole.this, FightForcesOfEvilActivity.class));
+                }
             }
         });
 
     }
 
-}
+    public void handleForceOfEvilFoughtEvent(@Observes ForceOfEvilFoughtEvent event) {
+        detachFightForcesOfEvilFragment();
+    }
 
+    private void detachFightForcesOfEvilFragment() {
+        Fragment fightForcesOfEvilFragment = getSupportFragmentManager().findFragmentByTag(FIGHT_FORCES_OF_EVIL_FRAGMENT_TAG);
+        if (fightForcesOfEvilFragment != null) {
+            FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
+            ft.remove(fightForcesOfEvilFragment);
+            ft.commit();
+        }
+    }
 
+    public class AstroSpeechEvent {
+        private String message;
 
+        private AstroSpeechEvent(String message) {
+            this.message = message;
+        }
+
+        public String getMessage() {
+            return message;
+        }
+    }
 
+    private class AstroSpeechEventProducer implements EventProducer<AstroSpeechEvent> {
+        private AstroSpeechEvent event;
+
+        private AstroSpeechEventProducer(AstroSpeechEvent event) {
+            this.event = event;
+        }
+
+        public AstroSpeechEvent onEventRequested() {
+            return event;
+        }
+    }
+}
diff --git a/astroboy/src/main/java/org/roboguice/astroboy/fragment/FightForcesOfEvilFragment.java b/astroboy/src/main/java/org/roboguice/astroboy/fragment/FightForcesOfEvilFragment.java
index 18d599264..35c4b3297 100644
--- a/astroboy/src/main/java/org/roboguice/astroboy/fragment/FightForcesOfEvilFragment.java
+++ b/astroboy/src/main/java/org/roboguice/astroboy/fragment/FightForcesOfEvilFragment.java
@@ -5,8 +5,11 @@
 import javax.inject.Inject;
 
 import org.roboguice.astroboy.R;
+import org.roboguice.astroboy.activity.AstroboyMasterConsole.AstroSpeechEvent;
 import org.roboguice.astroboy.controller.Astroboy;
 
+import roboguice.event.EventManager;
+import roboguice.event.Observes;
 import roboguice.fragment.RoboFragment;
 import roboguice.inject.InjectResource;
 import roboguice.inject.InjectView;
@@ -15,6 +18,7 @@
 import android.os.Bundle;
 import android.view.LayoutInflater;
 import android.view.View;
+import android.view.View.OnClickListener;
 import android.view.ViewGroup;
 import android.view.animation.Animation;
 import android.widget.TextView;
@@ -25,6 +29,9 @@
  */
 public class FightForcesOfEvilFragment extends RoboFragment {
 
+    @Inject
+    EventManager eventManager; // only necessary to send events, not to receive them.
+
     @InjectView(R.id.expletive)
     TextView expletiveText;
 
@@ -48,6 +55,12 @@ public void onViewCreated(View view, Bundle savedInstanceState) {
         expletiveText.setAnimation(expletiveAnimation);
         expletiveAnimation.start();
 
+        expletiveText.setOnClickListener(new OnClickListener() {
+            public void onClick(View v) {
+                eventManager.fire(new ForceOfEvilFoughtEvent());
+            }
+        });
+
         // Throw some punches
         for (int i = 0; i < 10; ++i) {
             new AsyncPunch(getActivity()) {
@@ -63,6 +76,10 @@ protected void onSuccess(String expletive) throws Exception {
 
     }
 
+    public void handleAstroSpeechEvent(@Observes AstroSpeechEvent event) {
+        expletiveText.setText(event.getMessage());
+    }
+
     // This class will call Astroboy.punch() in the background
     public static class AsyncPunch extends RoboAsyncTask<String> {
 
@@ -80,8 +97,14 @@ public AsyncPunch(Context context) {
         }
 
         public String call() throws Exception {
-            Thread.sleep(random.nextInt(5 * 1000));
+            // we are sure to see each explective at least one second
+            Thread.sleep(1000 + random.nextInt(5 * 1000));
             return astroboy.punch();
         }
     }
+
+    public class ForceOfEvilFoughtEvent {
+
+    }
+
 }
diff --git a/roboguice/src/main/java/roboguice/event/EventManager.java b/roboguice/src/main/java/roboguice/event/EventManager.java
index 99bfd1421..39b9a2c41 100644
--- a/roboguice/src/main/java/roboguice/event/EventManager.java
+++ b/roboguice/src/main/java/roboguice/event/EventManager.java
@@ -1,79 +1,126 @@
 package roboguice.event;
 
+import java.lang.reflect.Method;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
 import roboguice.event.eventListener.ObserverMethodListener;
 import roboguice.inject.ContextSingleton;
 
-import android.content.Context;
-
 import com.google.inject.Inject;
 
-import java.lang.reflect.Method;
-import java.util.*;
-import java.util.Map.Entry;
+import android.content.Context;
+import android.os.Handler;
 
 /**
  * Manager class handling the following:
- *
- *   Registration of event observing methods:
- *      registerObserver()
- *      unregisterObserver()
- *      clear()
- *   Raising Events:
- *      fire()
- *      notifyWithResult()
- *
+ * 
+ * Registration of event observing methods: registerObserver()
+ * unregisterObserver() clear() Raising Events: fire() notifyWithResult()
+ * 
  * @author Adam Tybor
  * @author John Ericksen
  */
 @ContextSingleton
 public class EventManager {
-    @Inject protected Context context;
+    @Inject
+    protected Context context;
+
+    protected Map<Class<?>, Set<EventListener<?>>> registrations = new HashMap<Class<?>, Set<EventListener<?>>>(); // synchronized
+                                                                                                                   // set
+    protected Map<Class<?>, EventProducer<?>> productions = new HashMap<Class<?>, EventProducer<?>>(); // synchronized
 
-    protected Map<Class<?>, Set<EventListener<?>>> registrations = new HashMap<Class<?>, Set<EventListener<?>>>(); // synchronized set
+    // set
 
     /**
      * Register the given EventListener to the contest and event class.
-     *
-     * @param event observed
-     * @param listener to be triggered
-     * @param <T> event type
+     * 
+     * @param event
+     *            observed
+     * @param listener
+     *            to be triggered
+     * @param <T>
+     *            event type
      */
-    public <T> void registerObserver( Class<T> event, EventListener listener ) {
+    public <T> void registerObserver(final Class<T> event, final EventListener listener) {
         Set<EventListener<?>> observers = registrations.get(event);
         if (observers == null) {
             observers = Collections.synchronizedSet(new LinkedHashSet<EventListener<?>>());
             registrations.put(event, observers);
         }
 
+        if (productions.get(event) != null) {
+            // we post a message that will be executed asap bu the main thread
+            // of this event manager's context
+            new Handler(context.getMainLooper()).post(new Runnable() {
+                @Override
+                public void run() {
+                    listener.onEvent(productions.get(event).onEventRequested());
+                }
+            });
+        }
+
         observers.add(listener);
 
     }
 
     /**
      * Registers given method with provided context and event.
-     *
-     * @param instance to be called
-     * @param method to be called
-     * @param event observed
+     * 
+     * @param instance
+     *            to be called
+     * @param method
+     *            to be called
+     * @param event
+     *            observed
      */
     public <T> void registerObserver(Object instance, Method method, Class<T> event) {
         registerObserver(event, new ObserverMethodListener<T>(instance, method));
     }
 
+    /**
+     * Register the given EventListener to the contest and event class.
+     * 
+     * @param event
+     *            observed
+     * @param listener
+     *            to be triggered
+     * @param <T>
+     *            event type
+     */
+    public <T> void registerProducer(Class<T> event, EventProducer producer) {
+        EventProducer previousProducer = productions.get(event);
+        if (previousProducer != null) {
+            throw new RuntimeException("A producer is already registered for event type " + event.getSimpleName() + " :" + previousProducer);
+        }
+        productions.put(event, producer);
+    }
+
     /**
      * Unregisters the provided event listener from the given event
-     *
-     * @param event observed
-     * @param listener to be unregistered
-     * @param <T> event type
+     * 
+     * @param event
+     *            observed
+     * @param listener
+     *            to be unregistered
+     * @param <T>
+     *            event type
      */
-    public <T> void unregisterObserver(Class<T> event, EventListener<T> listener ) {
+    public <T> void unregisterObserver(Class<T> event, EventListener<T> listener) {
 
         final Set<EventListener<?>> observers = registrations.get(event);
-        if (observers == null) return;
+        if (observers == null) {
+            return;
+        }
 
-        // As documented in http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
-        //noinspection SynchronizationOnLocalVariableOrMethodParameter
+        // As documented in
+        // http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
+        // noinspection SynchronizationOnLocalVariableOrMethodParameter
         synchronized (observers) {
             for (Iterator<EventListener<?>> iterator = observers.iterator(); iterator.hasNext();) {
                 final EventListener registeredListener = iterator.next();
@@ -86,23 +133,29 @@
     }
 
     /**
-     * Unregister all methods observing the given event from the provided context.
-     *
-     * @param instance to be unregistered
-     * @param event observed
+     * Unregister all methods observing the given event from the provided
+     * context.
+     * 
+     * @param instance
+     *            to be unregistered
+     * @param event
+     *            observed
      */
     public <T> void unregisterObserver(Object instance, Class<T> event) {
 
         final Set<EventListener<?>> observers = registrations.get(event);
-        if (observers == null) return;
+        if (observers == null) {
+            return;
+        }
 
-        // As documented in http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
-        //noinspection SynchronizationOnLocalVariableOrMethodParameter
+        // As documented in
+        // http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
+        // noinspection SynchronizationOnLocalVariableOrMethodParameter
         synchronized (observers) {
             for (Iterator<EventListener<?>> iterator = observers.iterator(); iterator.hasNext();) {
                 final EventListener listener = iterator.next();
-                if( listener instanceof ObserverMethodListener ) {
-                    final ObserverMethodListener observer = ((ObserverMethodListener)listener);
+                if (listener instanceof ObserverMethodListener) {
+                    final ObserverMethodListener observer = (ObserverMethodListener) listener;
                     if (observer.getInstance() == instance) {
                         iterator.remove();
                         break;
@@ -113,30 +166,36 @@
     }
 
     /**
-     * Raises the event's class' event on the given context.  This event object is passed (if configured) to the
-     * registered observer's method.
-     *
-     * @param event observed
+     * Raises the event's class' event on the given context. This event object
+     * is passed (if configured) to the registered observer's method.
+     * 
+     * @param event
+     *            observed
      */
     public void fire(Object event) {
 
         final Set<EventListener<?>> observers = registrations.get(event.getClass());
-        if (observers == null) return;
+        if (observers == null) {
+            return;
+        }
 
-        // As documented in http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
-        //noinspection SynchronizationOnLocalVariableOrMethodParameter
+        // As documented in
+        // http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
+        // noinspection SynchronizationOnLocalVariableOrMethodParameter
         synchronized (observers) {
-            for (EventListener observer : observers)
+            for (EventListener observer : observers) {
                 observer.onEvent(event);
+            }
         }
 
     }
-    
-    
+
     public void destroy() {
-        for( Entry<Class<?>, Set<EventListener<?>>> e : registrations.entrySet() )
+        for (Entry<Class<?>, Set<EventListener<?>>> e : registrations.entrySet()) {
             e.getValue().clear();
+        }
         registrations.clear();
+        productions.clear();
     }
 
 }
diff --git a/roboguice/src/main/java/roboguice/event/EventProducer.java b/roboguice/src/main/java/roboguice/event/EventProducer.java
new file mode 100644
index 000000000..8852d776b
--- /dev/null
+++ b/roboguice/src/main/java/roboguice/event/EventProducer.java
@@ -0,0 +1,18 @@
+package roboguice.event;
+
+/**
+ * Interface for registering functionality with the EventManager.
+ * 
+ * @author Mike Burton
+ * 
+ * @param <T>
+ */
+public interface EventProducer<T> {
+
+    /**
+     * Method called when event T is requested.
+     * 
+     * @return event produced.
+     */
+    public T onEventRequested();
+}
diff --git a/roboguice/src/main/java/roboguice/event/Produces.java b/roboguice/src/main/java/roboguice/event/Produces.java
new file mode 100644
index 000000000..d5a8cda06
--- /dev/null
+++ b/roboguice/src/main/java/roboguice/event/Produces.java
@@ -0,0 +1,16 @@
+package roboguice.event;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * //TODO
+ */
+@Retention(RUNTIME)
+@Target({ ElementType.PARAMETER })
+public @interface Produces {
+    EventThread value() default EventThread.CURRENT;
+}
