diff --git a/roboguice/src/main/java/roboguice/android/DroidGuice.java b/roboguice/src/main/java/roboguice/android/DroidGuice.java
index f3c7a30e7..45530b961 100644
--- a/roboguice/src/main/java/roboguice/android/DroidGuice.java
+++ b/roboguice/src/main/java/roboguice/android/DroidGuice.java
@@ -30,10 +30,9 @@
  * BUG hashmap should also key off of stage and modules list
  */
 
-public class DroidGuice extends RoboGuice<Application, Context, AndroidDefaultRoboModule, AndroidResourceListener> {
+public final class DroidGuice extends RoboGuice<Integer, Application, Context, AndroidDefaultRoboModule, AndroidResourceListener> {
     
     protected static WeakHashMap<Application,ViewListener> viewListeners = new WeakHashMap<Application, ViewListener>();
-    protected static int modulesResourceId = 0;
     
     private static DroidGuice guice = null;
     
@@ -50,14 +49,6 @@ public static DroidGuice instance()
     private DroidGuice() {
     }
 
-    /**
-     * Allows the user to override the "roboguice_modules" resource name with some other identifier.
-     * This is a static value.
-     */
-    public void setModulesResourceId(int modulesResourceId) {
-        DroidGuice.modulesResourceId = modulesResourceId;
-    }
-
     @Override
     protected List<Module> baseModules(Application application) {
         
diff --git a/roboguice/src/main/java/roboguice/android/config/AndroidDefaultRoboModule.java b/roboguice/src/main/java/roboguice/android/config/AndroidDefaultRoboModule.java
index 24d30da5c..cba5551f9 100644
--- a/roboguice/src/main/java/roboguice/android/config/AndroidDefaultRoboModule.java
+++ b/roboguice/src/main/java/roboguice/android/config/AndroidDefaultRoboModule.java
@@ -3,14 +3,42 @@
 import roboguice.android.activity.RoboActivity;
 import roboguice.android.event.ObservesTypeListener;
 import roboguice.android.event.eventListener.factory.EventListenerThreadingDecorator;
-import roboguice.android.inject.*;
+import roboguice.android.inject.AccountManagerProvider;
+import roboguice.android.inject.AndroidResourceListener;
+import roboguice.android.inject.AssetManagerProvider;
+import roboguice.android.inject.ContentResolverProvider;
+import roboguice.android.inject.ContextScope;
+import roboguice.android.inject.ContextScopedSystemServiceProvider;
+import roboguice.android.inject.ExtrasListener;
+import roboguice.android.inject.FragmentManagerProvider;
+import roboguice.android.inject.HandlerProvider;
+import roboguice.android.inject.NullProvider;
+import roboguice.android.inject.PreferenceListener;
+import roboguice.android.inject.ResourcesProvider;
+import roboguice.android.inject.SharedPreferencesProvider;
+import roboguice.android.inject.SystemServiceProvider;
+import roboguice.android.inject.ViewListener;
 import roboguice.android.service.RoboService;
+import roboguice.base.config.DefaultRoboModule;
 import roboguice.base.event.EventManager;
 import roboguice.base.inject.ContextSingleton;
 import roboguice.base.util.Strings;
 import roboguice.base.util.logging.Ln;
 
-import android.app.*;
+import com.google.inject.Key;
+import com.google.inject.Provider;
+import com.google.inject.TypeLiteral;
+import com.google.inject.matcher.Matchers;
+import com.google.inject.name.Names;
+
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.app.AlarmManager;
+import android.app.Application;
+import android.app.KeyguardManager;
+import android.app.NotificationManager;
+import android.app.SearchManager;
+import android.app.Service;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.SharedPreferences;
@@ -34,13 +62,6 @@
 import android.view.WindowManager;
 import android.view.inputmethod.InputMethodManager;
 
-import com.google.inject.AbstractModule;
-import com.google.inject.Key;
-import com.google.inject.Provider;
-import com.google.inject.TypeLiteral;
-import com.google.inject.matcher.Matchers;
-import com.google.inject.name.Names;
-
 /**
  * A Module that provides bindings and configuration to use Guice on Android.
  * Used by {@link roboguice.android.DroidGuice}.
@@ -57,11 +78,14 @@
  *
  * @author Mike Burton
  */
-public class AndroidDefaultRoboModule extends AbstractModule {
+public class AndroidDefaultRoboModule extends DefaultRoboModule<AndroidResourceListener> {
+    @SuppressWarnings("rawtypes")
     protected static final Class fragmentManagerClass;
+    @SuppressWarnings("rawtypes")
     protected static final Class accountManagerClass;
 
     static {
+        @SuppressWarnings("rawtypes")
         Class c = null;
         try {
             c = Class.forName("android.support.v4.app.FragmentManager");
@@ -70,6 +94,7 @@
     }
 
     static {
+        @SuppressWarnings("rawtypes")
         Class c = null;
         try {
             c = Class.forName("android.accounts.AccountManager");
@@ -80,17 +105,15 @@
 
     protected Application application;
     protected ContextScope contextScope;
-    protected AndroidResourceListener resourceListener;
     protected ViewListener viewListener;
 
 
     public AndroidDefaultRoboModule(final Application application, ContextScope contextScope, ViewListener viewListener, AndroidResourceListener resourceListener) {
-
-
+        
+        super(resourceListener);
         this.application = application;
         this.contextScope = contextScope;
         this.viewListener = viewListener;
-        this.resourceListener = resourceListener;
     }
 
     /**
diff --git a/roboguice/src/main/java/roboguice/base/RoboGuice.java b/roboguice/src/main/java/roboguice/base/RoboGuice.java
index ccd595a29..b1daac551 100644
--- a/roboguice/src/main/java/roboguice/base/RoboGuice.java
+++ b/roboguice/src/main/java/roboguice/base/RoboGuice.java
@@ -3,7 +3,7 @@
 import java.util.List;
 import java.util.WeakHashMap;
 
-import roboguice.android.config.AndroidDefaultRoboModule;
+import roboguice.base.config.DefaultRoboModule;
 import roboguice.base.event.EventManager;
 import roboguice.base.inject.ResourceListener;
 
@@ -23,14 +23,17 @@
  * -->
  * TODO Description
  * 
+ * @param <I> Id to identify the DefaultModuleId
  * @param <S> Object which a main {@link Injector} is scoped to
  * @param <O> Object which multiple {@link Injector}s are scoped bye
- * @param <R> Specific {@link AndroidDefaultRoboModule} impl
+ * @param <R> Specific {@link DefaultRoboModule} impl
  * @param <L> Specific {@link ResourceListener} impl
  */
-public abstract class RoboGuice<S, O, R extends AndroidDefaultRoboModule, L extends ResourceListener>{
+public abstract class RoboGuice<I, S, O, R extends DefaultRoboModule<L>, L extends ResourceListener>{
     public static Stage DEFAULT_STAGE = Stage.PRODUCTION;
     
+    protected I modulesResourceId;
+    
     protected WeakHashMap<S,Injector> injectors = new WeakHashMap<S,Injector>();
     protected WeakHashMap<S,L> resourceListeners = new WeakHashMap<S,L>();
     
@@ -39,6 +42,14 @@
         return injectors;
     }
     
+    /**
+     * Allows the user to override the "roboguice_modules" resource name with some other identifier.
+     * This is a static value.
+     */
+    public void setModulesResourceId(I modulesResourceId) {
+        this.modulesResourceId = modulesResourceId;
+    }
+    
     /**
      * Return the cached Injector instance for this application, or create a new one if necessary.
      */
@@ -96,13 +107,13 @@ public Void visit(StaticInjectionRequest element) {
     /**
      * Return the cached Injector instance for this application, or create a new one if necessary.
      */
-    public Injector setScopedInjector(S application, Stage stage) {
+    public Injector setScopedInjector(S scopedObject, Stage stage) {
 
         synchronized (RoboGuice.class) {
             
-            List<Module> modules = baseModules(application);
-            final Injector rtrn = setScopedInjector(application, stage, modules.toArray(new Module[modules.size()]));
-            injectors.put(application,rtrn);
+            List<Module> modules = baseModules(scopedObject);
+            final Injector rtrn = setScopedInjector(scopedObject, stage, modules.toArray(new Module[modules.size()]));
+            injectors.put(scopedObject,rtrn);
             return rtrn;
         }
     }
@@ -115,20 +126,20 @@ public Injector setScopedInjector(S application, Stage stage) {
         return s;
     }
     
-    protected abstract List<Module> baseModules( S application );
+    protected abstract List<Module> baseModules( S scopeObject );
     
     public void destroyInjector(O context) {
         final Injector injector = getInjector(context);
         injector.getInstance(EventManager.class).destroy();
         injectors.remove(context);
     }
-    
+        
     public Injector getInjector( O context )
     {
         return Guice.createInjector(DEFAULT_STAGE);
     }
     
-    public abstract AndroidDefaultRoboModule newDefaultRoboModule( S app );
+    public abstract R newDefaultRoboModule( S scopeObject );
     
     protected abstract L getResourceListener( S scopedObject );
 }
diff --git a/roboguice/src/main/java/roboguice/base/config/DefaultRoboModule.java b/roboguice/src/main/java/roboguice/base/config/DefaultRoboModule.java
new file mode 100644
index 000000000..8b660c47a
--- /dev/null
+++ b/roboguice/src/main/java/roboguice/base/config/DefaultRoboModule.java
@@ -0,0 +1,15 @@
+package roboguice.base.config;
+
+import roboguice.base.inject.ResourceListener;
+
+import com.google.inject.AbstractModule;
+
+public abstract class DefaultRoboModule<L extends ResourceListener> extends AbstractModule {
+
+    protected L resourceListener;
+    
+    public DefaultRoboModule( L listener )
+    {
+        this.resourceListener = listener;
+    }
+}
diff --git a/roboguice/src/main/java/roboguice/base/inject/ResourceListener.java b/roboguice/src/main/java/roboguice/base/inject/ResourceListener.java
index 4c2b13d07..50ed9a9a9 100644
--- a/roboguice/src/main/java/roboguice/base/inject/ResourceListener.java
+++ b/roboguice/src/main/java/roboguice/base/inject/ResourceListener.java
@@ -51,7 +51,7 @@ public ResourceMemberInjector(Field field, InjectResource annotation) {
             this.annotation = annotation;
         }
 
-        public void injectMembers(T instance) {
+        public void injectMembers( T instance ) {
 
             Object value = null;
 
diff --git a/roboguice/src/main/java/roboguice/java/JavaGuice.java b/roboguice/src/main/java/roboguice/java/JavaGuice.java
new file mode 100644
index 000000000..0e2c42b4b
--- /dev/null
+++ b/roboguice/src/main/java/roboguice/java/JavaGuice.java
@@ -0,0 +1,112 @@
+package roboguice.java;
+
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Properties;
+
+import roboguice.base.RoboGuice;
+import roboguice.base.util.logging.Ln;
+import roboguice.java.config.JavaDefaultRoboModule;
+import roboguice.java.inject.JavaResourceListener;
+
+import com.google.inject.Injector;
+import com.google.inject.Module;
+
+public final class JavaGuice extends RoboGuice<String, String, String, JavaDefaultRoboModule, JavaResourceListener> {
+
+    private static JavaGuice guice = null;
+    
+    public static JavaGuice instance()
+    {
+        if ( guice == null )
+        {
+            guice = new JavaGuice();
+        }
+        
+        return guice;
+    }
+    
+    private JavaGuice() {
+    }
+    
+    @Override
+    protected List<Module> baseModules(String scopeObject) 
+    {
+        Properties property = new Properties();
+        
+        InputStream in = JavaResourceListener.class.getClassLoader().getResourceAsStream( scopeObject );
+        try
+        {//and load the property file 
+            if ( in != null )
+            {
+                property.load( in );
+            } 
+            else
+            {
+                Ln.w( "Could not find [%s] resource - can not inject any resources in specified file.", scopeObject );
+            }
+        }
+        catch ( Exception e )
+        {
+            Ln.e( e, "Error loading property file [%s]", scopeObject );
+        }
+        finally
+        {
+            try
+            {
+                in.close();
+            }
+            catch ( Exception ex )
+            {
+                // ignore
+            }
+        }
+        
+        final String[] moduleNames = property.get(modulesResourceId) != null ? (String[]) property.get(modulesResourceId) : new String[]{};
+        final ArrayList<Module> modules = new ArrayList<Module>();
+        final JavaDefaultRoboModule defaultRoboModule = newDefaultRoboModule( scopeObject );
+
+        modules.add(defaultRoboModule);
+
+        try {
+            for (String name : moduleNames) {
+                final Class<? extends Module> clazz = Class.forName(name).asSubclass(Module.class);
+                
+                modules.add( clazz.newInstance() );
+            }
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+        
+        return modules;
+    }
+
+    @Override
+    public Injector getInjector(String context) {
+        return getScopedInjector( context );
+    }
+    
+    @Override
+    public JavaDefaultRoboModule newDefaultRoboModule( String scopeObject ) {
+        return new JavaDefaultRoboModule( getResourceListener(scopeObject) );
+    }
+
+    @Override
+    protected JavaResourceListener getResourceListener(String scopeObject) {
+        
+        JavaResourceListener resourceListener = resourceListeners.get(scopeObject);
+        if( resourceListener==null ) {
+            synchronized (RoboGuice.class) {
+                if( resourceListener==null ) {
+                    resourceListener = new JavaResourceListener( );
+                    resourceListeners.put(scopeObject,resourceListener);
+                }
+            }
+        }
+        
+        return resourceListener;
+    }
+
+
+}
\ No newline at end of file
diff --git a/roboguice/src/main/java/roboguice/java/config/JavaDefaultRoboModule.java b/roboguice/src/main/java/roboguice/java/config/JavaDefaultRoboModule.java
new file mode 100644
index 000000000..3cca577d0
--- /dev/null
+++ b/roboguice/src/main/java/roboguice/java/config/JavaDefaultRoboModule.java
@@ -0,0 +1,17 @@
+package roboguice.java.config;
+
+import roboguice.base.config.DefaultRoboModule;
+import roboguice.java.inject.JavaResourceListener;
+
+public class JavaDefaultRoboModule extends DefaultRoboModule<JavaResourceListener> {
+
+    public JavaDefaultRoboModule(JavaResourceListener listener) {
+        super(listener);
+    }
+
+    @Override
+    protected void configure() {
+        //FIXME What to bind. Hrmm...
+    }
+
+}
diff --git a/roboguice/src/main/java/roboguice/java/inject/JavaResourceListener.java b/roboguice/src/main/java/roboguice/java/inject/JavaResourceListener.java
new file mode 100644
index 000000000..dbbb9bf8a
--- /dev/null
+++ b/roboguice/src/main/java/roboguice/java/inject/JavaResourceListener.java
@@ -0,0 +1,257 @@
+package roboguice.java.inject;
+
+import java.io.File;
+import java.io.FilenameFilter;
+import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
+import roboguice.base.inject.InjectResource;
+import roboguice.base.inject.ResourceListener;
+import roboguice.base.util.logging.Ln;
+
+import com.google.inject.TypeLiteral;
+
+public class JavaResourceListener extends ResourceListener {
+
+    private List<String> resourcePaths;
+    
+    /* Key represents an entry in a resourcePath
+    *  Value -
+    *           Key     - path to properties file
+    *           Value   - properties object 
+    */      
+    private static final Map<String, HashMap<String,Properties>> properties = Collections.synchronizedMap( new HashMap<String, HashMap<String,Properties>>());
+    
+    public JavaResourceListener ( String... resourcePaths )
+    {
+        //Creating new list so that paths can be modified
+        this.resourcePaths = resourcePaths != null && resourcePaths.length > 0 ?
+                                Collections.synchronizedList( new ArrayList<String>( Arrays.asList( resourcePaths ) ) ) :
+                                Collections.synchronizedList( new ArrayList<String>() ) ;
+    }
+    
+    @Override
+    protected <I> ResourceMemberInjector<I> newResourceMember( TypeLiteral<I> typeLiteral, Field field ) {
+        return new JavaMemberResourceInjector<I>(field, field.getAnnotation(InjectResource.class), resourcePaths );
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    @Override
+    protected ResourceMemberInjector newResourceMember( Field field ) {
+        return new JavaMemberResourceInjector( field, field.getAnnotation(InjectResource.class), resourcePaths );
+    }
+    
+    public JavaResourceListener addResourcePath( String... paths )
+    {
+        if ( paths != null && paths.length > 0 )
+        {
+            resourcePaths.addAll( resourcePaths );
+            //don't add resource paths to map yet
+            //Lazy init in JavaMemberResourceInjector
+        }
+        
+        return this;
+    }
+    
+    public JavaResourceListener removeResourcePath( String... paths )
+    {
+        if ( paths != null && paths.length > 0 )
+        {
+            resourcePaths.removeAll(resourcePaths);
+            /*
+             * Returns a Set view of the keys contained in this map. The set is backed by the map, so changes 
+             * to the map are reflected in the set, and vice-versa. If the map is modified while an iteration 
+             * over the set is in progress (except through the iterator's own remove operation), the results of 
+             * the iteration are undefined. The set supports element removal, which removes the corresponding mapping 
+             * from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations.
+             *  It does not support the add or addAll operations.
+             */
+            properties.keySet().removeAll(resourcePaths); 
+        }
+        
+        return this;
+    }
+    
+    public JavaResourceListener removeAllPaths()
+    {
+        resourcePaths.clear();
+        return this;
+    }
+    
+    protected static class JavaMemberResourceInjector<T> extends ResourceMemberInjector<T>
+    {
+        private List<String> resourcePaths;
+        
+        public JavaMemberResourceInjector(Field field, InjectResource annotation, List<String> resourcePaths ) {
+            super(field, annotation);
+            this.resourcePaths = resourcePaths;
+        }
+
+        @Override
+        protected Object getValue() {
+            
+            Object val = null;
+            //Check cache first
+            for ( String resourcePath : properties.keySet() )
+            {//for every resource path
+                
+                Map<String, Properties> props = properties.get( resourcePath );
+                for ( String propertyFile : props.keySet() )
+                {//for each property file 
+                    
+                    //get property
+                    val = props.get(propertyFile).getProperty( annotation.name() );
+                    
+                    if ( val != null )
+                    {//return if found
+                        
+                        return val;
+                    }
+                }
+                
+            }
+            
+            //No properties found in cache
+            //Start loading properties
+            
+            for ( String resourcePath : resourcePaths )
+            {
+                File file = new File(resourcePath);
+                
+                if ( file.exists() )
+                {
+                    if ( file.isDirectory() )
+                    {// if directory
+                        
+                        //get all property files
+                        Collection<File> allProperties =
+                                listFiles(
+                                       file,
+                                        new FilenameFilter() {
+                                            
+                                            @Override
+                                            public boolean accept(File dir, String filename) {
+                                                return filename.endsWith(".properties");
+                                            }
+                                        }
+                                );
+                        
+                        for (File propertyFile : allProperties) 
+                        {//for each property file found
+                            
+                            Properties prop = loadProperty(resourcePath, propertyFile);
+                            
+                            val = prop.get( annotation.name() );
+                            
+                            if ( val != null )
+                            {// if you found the value stop searching and loading the files
+                                return val;
+                            }
+                            
+                        }
+                    }
+                    else if ( file.getAbsolutePath().endsWith(".properties") )
+                    {
+                        Properties prop = loadProperty(resourcePath, file);
+                        
+                        val = prop.get(annotation.name() );
+                        
+                        if ( val != null )
+                        {
+                            return val;
+                        }
+                    }
+                    
+                }
+                else
+                {
+                    Ln.w("Can not find resource path - %s", resourcePath );
+                }
+            }
+            
+            return val;
+        }
+
+        private Properties loadProperty(String resourcePath, File propertyFile) {
+            
+            Properties property = new Properties();
+            
+            InputStream in = JavaResourceListener.class.getClassLoader().getResourceAsStream( propertyFile.getAbsolutePath() );
+            try
+            {//and load the property file 
+                if ( in != null )
+                {
+                    property.load( in );
+                    
+                    //get the current cache map for resource path
+                    HashMap<String, Properties> props = properties.get( resourcePath );
+                    
+                    if ( props == null )
+                    {//create a new map to put inside cache
+                        props = new HashMap<String, Properties>();
+                    }
+                    
+                    //put the new property inside the resource path cache map
+                    props.put(propertyFile.getAbsolutePath(), property);
+                    //put resource path cache map into main cache
+                    properties.put(resourcePath, props);
+                } 
+                else
+                {
+                    Ln.w( "Could not find [%s] resource - can not inject any resources in specified file.", propertyFile );
+                }
+            }
+            catch ( Exception e )
+            {
+                Ln.e( e, "Error loading property file [%s]", propertyFile );
+            }
+            finally
+            {
+                try
+                {
+                    in.close();
+                }
+                catch ( Exception ex )
+                {
+                    // ignore
+                }
+            }
+            
+            return property;
+        }
+        
+        private Collection<File> listFiles( File directory, FilenameFilter fileFilter ) {
+            //Find files
+            Collection<File> files = new java.util.LinkedList<File>();
+            innerListFiles(files, directory, fileFilter, false);
+            return files;
+        }
+
+        private void innerListFiles(Collection<File> files, File directory, FilenameFilter filter, boolean includeSubDirectories) {
+            File[] found = directory.listFiles(filter);
+            
+            if (found != null) {
+                for (File file : found) {
+                    if (file.isDirectory()) {
+                        if (includeSubDirectories) {
+                            files.add(file);
+                        }
+                        innerListFiles(files, file, filter, includeSubDirectories);
+                    } else {
+                        files.add(file);
+                    }
+                }
+            }
+        }
+        
+    }
+
+}
