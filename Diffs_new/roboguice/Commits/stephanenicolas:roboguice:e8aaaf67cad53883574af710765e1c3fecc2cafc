diff --git a/afterburner/pom.xml b/afterburner/pom.xml
index d008310d7..b716b599b 100644
--- a/afterburner/pom.xml
+++ b/afterburner/pom.xml
@@ -37,6 +37,11 @@
 			<artifactId>javassist-maven-plugin</artifactId>
 			<version>1.0.1-SNAPSHOT</version>
 		</dependency>
+		<dependency>
+			<groupId>org.roboguice</groupId>
+			<artifactId>roboguice</artifactId>
+			<version>3.0-alpha-SNAPSHOT</version>
+		</dependency>
 		<dependency>
 			<groupId>junit</groupId>
 			<artifactId>junit</artifactId>
@@ -49,13 +54,11 @@
 			<groupId>com.google.android</groupId>
 			<artifactId>android</artifactId>
 			<version>${android-platform.version}</version>
-			<scope>provided</scope>
 		</dependency>
 		<dependency>
 			<groupId>com.google.android.maps</groupId>
 			<artifactId>maps</artifactId>
 			<version>${android-map.version}</version>
-			<scope>provided</scope>
 			<optional>true</optional>
 		</dependency>
 		<dependency>
diff --git a/afterburner/src/main/java/afterburner/PostProcessor.java b/afterburner/src/main/java/afterburner/PostProcessor.java
index b19a2cffc..faf86f342 100644
--- a/afterburner/src/main/java/afterburner/PostProcessor.java
+++ b/afterburner/src/main/java/afterburner/PostProcessor.java
@@ -1,30 +1,101 @@
 package afterburner;
 
+import java.lang.annotation.Annotation;
+import java.util.ArrayList;
+import java.util.List;
+
+import javassist.CannotCompileException;
 import javassist.CtClass;
+import javassist.CtField;
 import javassist.CtMethod;
-import javassist.CtNewMethod;
+import javassist.expr.ExprEditor;
+import javassist.expr.MethodCall;
+import roboguice.inject.ContentView;
+import roboguice.inject.InjectFragment;
+import roboguice.inject.InjectView;
 
 import com.github.drochetti.javassist.maven.ClassTransformer;
 
 public class PostProcessor extends ClassTransformer {
 
-    private String appendValue = "steff";
-
     @Override
-    protected void applyTransformations(CtClass classToTransform) throws Exception {
+    protected void applyTransformations(final CtClass classToTransform) throws Exception {
         // Actually you must test if it exists, but it's just an example...
-        CtMethod toStringMethod;
+
+        CtMethod onCreateMethod = classToTransform.getDeclaredMethod("onCreate");
+        onCreateMethod.instrument( new ExprEditor() {
+            @Override
+            public void edit(MethodCall m) throws CannotCompileException {
+                System.out.println("method call "+m.getMethodName());
+                if( m.getMethodName().equals("onCreate") ) {
+                    int layoutId = -1;
+                    try {
+                        layoutId = ((ContentView)m.getEnclosingClass().getAnnotation(ContentView.class)).value();
+                    } catch (ClassNotFoundException e) {
+                        e.printStackTrace();
+                    }
+                    List<CtField> views = getAllInjectedFieldsForAnnotation(m.getEnclosingClass(), InjectView.class);
+                    List<CtField> fragments = getAllInjectedFieldsForAnnotation(m.getEnclosingClass(), InjectFragment.class);
+                    String fieldsNameList = extractAllNames(views);
+                    System.out.println("super.onCreate call "+m.getMethodName());
+                    String string = "$_ = $proceed($$);\n"+
+                            "System.out.println(\"Injectable fields in : "+m.getEnclosingClass().getName()+"\");\n"+
+                            "System.out.println(\"fields : "+fieldsNameList+"\");\n"+
+                            "setContentView("+layoutId+");\n"+
+                            injectFragmentStatements(fragments);
+                    System.out.println("Injected : " + string);
+                    m.replace(string );
+                }
+            }
+
+
+        });
+        classToTransform.detach();
+    }
+
+    private String injectFragmentStatements(List<CtField> fragments) {
+        StringBuffer buffer = new StringBuffer();
         try {
-            toStringMethod = classToTransform.getDeclaredMethod("toString");
-            classToTransform.removeMethod(toStringMethod);
+            for( CtField field : fragments ) {
+                int id;
+                id = ((InjectFragment)field.getAnnotation(InjectFragment.class)).value();
+                buffer.append( field.getName() );
+                buffer.append( " = " );
+                buffer.append( '(' );
+                buffer.append( field.getType().getName() );
+                buffer.append( ')' );
+                buffer.append( "getFragmentManager().findFragmentById("+id+");\n" );
+            }
         } catch (Exception e) {
             e.printStackTrace();
         }
+        return buffer.toString();
+    }
+    private String extractAllNames(List<CtField> fields) {
+        StringBuffer buffer = new StringBuffer();
+        buffer.append('[');
+        for (CtField field : fields) {
+            buffer.append(field.getName());
+            buffer.append(',');
+        }
+        if( buffer.length() > 1 ) {
+            buffer.deleteCharAt(buffer.length()-1);
+        }
+        buffer.append(']');
+        return buffer.toString();
+    }
 
-        CtMethod hackedToStringMethod = CtNewMethod.make(
-                "public String toString() { return \"toString() hacked by Javassist"+(this.appendValue  != null ? this.appendValue:"")+"\"; }",
-                classToTransform);
-        classToTransform.addMethod(hackedToStringMethod);
+    private List<CtField> getAllInjectedFieldsForAnnotation(CtClass clazz, Class<? extends Annotation> annotationClazz) {
+        List<CtField> result = new ArrayList<CtField>();
+        CtField[] allFields = clazz.getDeclaredFields();
+        System.out.println("Scanning fields in "+clazz.getName());
+        for (CtField field : allFields) {
+            System.out.println("Discovered field "+field.getName());
+            if( field.hasAnnotation(annotationClazz) ) {
+                result.add(field);
+            }
+        }
+        return result;
     }
 
 }
