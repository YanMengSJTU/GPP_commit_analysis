diff --git a/roboguice/src/main/java/roboguice/RoboGuice.java b/roboguice/src/main/java/roboguice/RoboGuice.java
index 692c495a3..4f57e4990 100644
--- a/roboguice/src/main/java/roboguice/RoboGuice.java
+++ b/roboguice/src/main/java/roboguice/RoboGuice.java
@@ -7,6 +7,7 @@
 import roboguice.event.EventManager;
 import roboguice.inject.ContextScope;
 import roboguice.inject.ContextScopedRoboInjector;
+import roboguice.inject.FragmentScopedRoboInjector;
 import roboguice.inject.ResourceListener;
 import roboguice.inject.RoboInjector;
 import roboguice.inject.ViewListener;
@@ -18,6 +19,7 @@
 import com.google.inject.Stage;
 
 import android.app.Application;
+import android.app.Fragment;
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
@@ -137,6 +139,19 @@ public static RoboInjector getInjector(Context context) {
         return new ContextScopedRoboInjector(context, getBaseApplicationInjector(application));
     }
 
+    public static RoboInjector getInjector(Object fragment) {
+        Context context;
+        if( fragment instanceof Fragment ) {
+            context = ((Fragment) fragment).getActivity();
+        } else if( fragment instanceof android.support.v4.app.Fragment ) {
+            context = ((android.support.v4.app.Fragment) fragment).getActivity();
+        } else {
+            throw new IllegalArgumentException(String.format("%s does not appear to belong to a RoboGuice context (instanceof RoboContext)",fragment));
+        }
+
+        return new FragmentScopedRoboInjector(fragment, getInjector(context));
+    }
+
     /**
      * A shortcut for RoboGuice.getInjector(context).injectMembers(o);
      */
diff --git a/roboguice/src/main/java/roboguice/config/DefaultRoboModule.java b/roboguice/src/main/java/roboguice/config/DefaultRoboModule.java
index 43972690a..41430cf94 100644
--- a/roboguice/src/main/java/roboguice/config/DefaultRoboModule.java
+++ b/roboguice/src/main/java/roboguice/config/DefaultRoboModule.java
@@ -131,6 +131,7 @@ protected void configure() {
         // ContextSingleton bindings
         bindScope(ContextSingleton.class, contextScope);
         bind(ContextScope.class).toInstance(contextScope);
+        bind(FragmentScope.class).toProvider(FragmentScopeProvider.class);
         bind(AssetManager.class).toProvider(AssetManagerProvider.class);
         bind(Context.class).toProvider(NullProvider.<Context>instance()).in(ContextSingleton.class);
         bind(Activity.class).toProvider(NullProvider.<Activity>instance()).in(ContextSingleton.class);
diff --git a/roboguice/src/main/java/roboguice/fragment/provided/RoboFragment.java b/roboguice/src/main/java/roboguice/fragment/provided/RoboFragment.java
index 9a1bf753a..9c5e5b78e 100644
--- a/roboguice/src/main/java/roboguice/fragment/provided/RoboFragment.java
+++ b/roboguice/src/main/java/roboguice/fragment/provided/RoboFragment.java
@@ -1,6 +1,12 @@
 package roboguice.fragment.provided;
 
+import java.util.HashMap;
+import java.util.Map;
+
+import com.google.inject.Key;
+
 import roboguice.RoboGuice;
+import roboguice.util.RoboContext;
 
 import android.annotation.TargetApi;
 import android.app.Fragment;
@@ -14,16 +20,24 @@
  * @author Charles Munger
  */
 @TargetApi(Build.VERSION_CODES.HONEYCOMB) 
-public abstract class RoboFragment extends Fragment {
+public abstract class RoboFragment extends Fragment implements RoboContext {
+    protected HashMap<Key<?>,Object> scopedObjects = new HashMap<Key<?>, Object>();
+
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        RoboGuice.getInjector(getActivity()).injectMembersWithoutViews(this);
+        RoboGuice.getInjector(this).injectMembersWithoutViews(this);
     }
 
     @Override
     public void onViewCreated(View view, Bundle savedInstanceState) {
         super.onViewCreated(view, savedInstanceState);
-        RoboGuice.getInjector(getActivity()).injectViewMembers(this);
+        RoboGuice.getInjector(this).injectViewMembers(this);
     }
+
+    @Override
+    public Map<Key<?>, Object> getScopedObjectMap() {
+        return scopedObjects;
+    }
+
 }
diff --git a/roboguice/src/main/java/roboguice/inject/FragmentScope.java b/roboguice/src/main/java/roboguice/inject/FragmentScope.java
new file mode 100644
index 000000000..f5302f0ea
--- /dev/null
+++ b/roboguice/src/main/java/roboguice/inject/FragmentScope.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2009 Michael Burton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ */
+package roboguice.inject;
+
+import java.lang.ref.WeakReference;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Stack;
+
+import roboguice.util.RoboContext;
+
+import com.google.inject.Key;
+import com.google.inject.Provider;
+import com.google.inject.Scope;
+
+import android.app.Application;
+import android.content.Context;
+import android.content.ContextWrapper;
+
+/**
+ * Scopes the injector based on the current fragment. As requested by issue #XXX
+ *
+ * Any usage of this class must call #enter(Context) before performing any operations with the
+ * injector, and do so within a synchronized block on the FragmentScope.class, eg:
+ * <pre>
+ * synchronized(FragmentScope.class) {
+ *     scope.enter(fragment);
+ *
+ *     // do something, eg.
+ *     // injector.injectMembers(this);
+ * }
+ * </pre>
+ * If you're using FragmentScopedRoboInjector (which is the RoboGuice default), this is done for you automatically.
+ *
+ * If you're trying to use a Provider, you must either use FragmentScopedProvider instead, or do your own synchronization
+ * and scope.enter() call.
+ *
+ * @see FragmentScopedRoboInjector
+ * @author SNI
+ */
+public class FragmentScope implements Scope {
+    //Object is used here to accomodate both native and support Fragment 
+    protected ThreadLocal<Stack<WeakReference<Context>>> contextThreadLocal = new ThreadLocal<Stack<WeakReference<Context>>>();
+    protected Map<Key<?>,Object> applicationScopedObjects = new HashMap<Key<?>, Object>();
+    protected Application application;
+
+    public FragmentScope(Application application) {
+        this.application = application;
+        enter(application);
+    }
+
+    /**
+     * You MUST perform any injector operations inside a synchronized(FragmentScope.class) block that starts with
+     * scope.enter(context) if working in a multithreaded environment
+     *
+     * @see FragmentScope
+     * @see FragmentScopedRoboInjector
+     * @see FragmentScopedProvider
+     * @param context the context to enter
+     */
+    public void enter(Context context) {
+
+        // BUG synchronizing on FragmentScope.class may be overly conservative
+        synchronized (FragmentScope.class) {
+
+            final Stack<WeakReference<Context>> stack = getContextStack();
+            final Map<Key<?>,Object> map = getScopedObjectMap(context);
+
+            // Mark this thread as for this context
+            stack.push(new WeakReference<Context>(context));
+
+            // Add the context to the scope for key Context, Activity, etc.
+            Class<?> c = context.getClass();
+            do {
+                map.put(Key.get(c), context);
+                c = c.getSuperclass();
+            } while( c!=Object.class );
+        }
+    }
+
+    public void exit(Context context) {
+        synchronized (FragmentScope.class) {
+            final Stack<WeakReference<Context>> stack = getContextStack();
+            final Object c = stack.pop().get();
+            if( c!=null && c!=context )
+                throw new IllegalArgumentException(String.format("Scope for %s must be opened before it can be closed",context));
+        }
+    }
+
+    public <T> Provider<T> scope(final Key<T> key, final Provider<T> unscoped) {
+        return new Provider<T>() {
+            public T get() {
+                synchronized (FragmentScope.class) {
+                    final Stack<WeakReference<Context>> stack = getContextStack();
+                    final Context context = stack.peek().get(); // The context should never be finalized as long as the provider is still in memory
+                    final Map<Key<?>, Object> objectsForScope = getScopedObjectMap(context);
+                    if( objectsForScope==null )
+                        return null;  // May want to consider throwing an exception here (if provider is used after onDestroy())
+
+                    @SuppressWarnings({"unchecked"}) T current = (T) objectsForScope.get(key);
+                    if (current==null && !objectsForScope.containsKey(key)) {
+                        current = unscoped.get();
+                        objectsForScope.put(key, current);
+                    }
+
+                    return current;
+                }
+            }
+        };
+
+    }
+
+
+    public Stack<WeakReference<Context>> getContextStack() {
+        Stack<WeakReference<Context>> stack = contextThreadLocal.get();
+        if( stack==null ) {
+            stack = new Stack<WeakReference<Context>>();
+            contextThreadLocal.set(stack);
+        }
+        return stack;
+    }
+
+    protected Map<Key<?>,Object> getScopedObjectMap(final Context origContext) {
+        Context context = origContext;
+        while( !(context instanceof RoboContext) && !(context instanceof Application) && context instanceof ContextWrapper )
+            context = ((ContextWrapper)context).getBaseContext();
+
+        // Special case for application so that users don't have to manually set up application subclasses
+        if( context instanceof Application )
+            return applicationScopedObjects;
+
+
+        if( !(context instanceof RoboContext) )
+            throw new IllegalArgumentException(String.format("%s does not appear to belong to a RoboGuice context (instanceof RoboContext)",origContext));
+
+        return ((RoboContext)context).getScopedObjectMap();
+    }
+}
diff --git a/roboguice/src/main/java/roboguice/inject/FragmentScopeProvider.java b/roboguice/src/main/java/roboguice/inject/FragmentScopeProvider.java
new file mode 100644
index 000000000..c1753628c
--- /dev/null
+++ b/roboguice/src/main/java/roboguice/inject/FragmentScopeProvider.java
@@ -0,0 +1,14 @@
+package roboguice.inject;
+
+import com.google.inject.Inject;
+import com.google.inject.Provider;
+
+import android.app.Application;
+
+public class FragmentScopeProvider implements Provider<FragmentScope> {
+    @Inject protected Application application;
+
+    public FragmentScope get() {
+        return new FragmentScope(application);
+    }
+}
diff --git a/roboguice/src/main/java/roboguice/inject/FragmentScopedRoboInjector.java b/roboguice/src/main/java/roboguice/inject/FragmentScopedRoboInjector.java
new file mode 100644
index 000000000..f70452f22
--- /dev/null
+++ b/roboguice/src/main/java/roboguice/inject/FragmentScopedRoboInjector.java
@@ -0,0 +1,292 @@
+package roboguice.inject;
+
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import roboguice.inject.ViewListener.ViewMembersInjector;
+
+import com.google.inject.Binding;
+import com.google.inject.Injector;
+import com.google.inject.Key;
+import com.google.inject.MembersInjector;
+import com.google.inject.Module;
+import com.google.inject.Provider;
+import com.google.inject.Scope;
+import com.google.inject.TypeLiteral;
+import com.google.inject.spi.TypeConverterBinding;
+
+import android.app.Activity;
+import android.app.Fragment;
+import android.content.Context;
+
+public class FragmentScopedRoboInjector implements RoboInjector {
+    protected Injector delegate;
+    protected Context context;
+    protected FragmentScope scope;
+
+    public FragmentScopedRoboInjector(Object fragment, Injector activityInjector) {
+        this.delegate = activityInjector;
+        this.context = getContext(fragment);
+        this.scope = delegate.getInstance(FragmentScope.class);
+    }
+    
+    private Context getContext(Object fragment) {
+        Context context;
+        if( fragment instanceof Fragment ) {
+            context = ((Fragment) fragment).getActivity();
+        } else if( fragment instanceof android.support.v4.app.Fragment ) {
+            context = ((android.support.v4.app.Fragment) fragment).getActivity();
+        } else {
+            throw new IllegalArgumentException(String.format("%s does not appear to belong to a RoboGuice context (instanceof RoboContext)",fragment));
+        }
+        return context;
+    }
+
+    @Override
+    public Injector createChildInjector(Iterable<? extends Module> modules) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.createChildInjector(modules);
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public Injector createChildInjector(Module... modules) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.createChildInjector(modules);
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public <T> List<Binding<T>> findBindingsByType(TypeLiteral<T> type) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.findBindingsByType(type);
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public Map<Key<?>, Binding<?>> getAllBindings() {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getAllBindings();
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public <T> Binding<T> getBinding(Key<T> key) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getBinding(key);
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public <T> Binding<T> getBinding(Class<T> type) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getBinding(type);
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public Map<Key<?>, Binding<?>> getBindings() {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getBindings();
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public <T> Binding<T> getExistingBinding(Key<T> key) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getExistingBinding(key);
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public <T> T getInstance(Key<T> key) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getInstance(key);
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public <T> T getInstance(Class<T> type) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getInstance(type);
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public <T> MembersInjector<T> getMembersInjector(Class<T> type) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getMembersInjector(type);
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public <T> MembersInjector<T> getMembersInjector(TypeLiteral<T> typeLiteral) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getMembersInjector(typeLiteral);
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public Injector getParent() {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getParent();
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public <T> Provider<T> getProvider(Key<T> key) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getProvider(key);
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public <T> Provider<T> getProvider(Class<T> type) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getProvider(type);
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public Map<Class<? extends Annotation>, Scope> getScopeBindings() {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getScopeBindings();
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public Set<TypeConverterBinding> getTypeConverterBindings() {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                return delegate.getTypeConverterBindings();
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public void injectMembers(Object instance) {
+        injectMembersWithoutViews(instance);
+    }
+
+    public void injectMembersWithoutViews( Object instance ) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                delegate.injectMembers(instance);
+            }finally {
+                scope.exit(context);
+            }
+        }
+    }
+
+    @Override
+    public void injectViewMembers(Activity activity) {
+        throw new UnsupportedOperationException("It is not possible to use a fragment injector to inject views into an activity. Use the activity injector.");
+    }
+
+    @Override
+    public void injectViewMembers(android.support.v4.app.Fragment fragment) {
+        injectViews(fragment);
+    }
+
+    @Override
+    public void injectViewMembers(Fragment fragment) {
+        injectViews(fragment);
+    }
+
+    private void injectViews(Object fragment) {
+        synchronized (FragmentScope.class) {
+            scope.enter(context);
+            try {
+                ViewMembersInjector.injectViews(fragment);
+            } finally {
+                scope.exit(context);
+            }
+        }
+    }
+}
diff --git a/roboguice/src/test/java/roboguice/view/ViewInjectionTest.java b/roboguice/src/test/java/roboguice/view/ViewInjectionTest.java
index 40731ef30..ab6bbb528 100644
--- a/roboguice/src/test/java/roboguice/view/ViewInjectionTest.java
+++ b/roboguice/src/test/java/roboguice/view/ViewInjectionTest.java
@@ -81,7 +81,6 @@ public void shouldNotHoldReferencesToContext() {
 
 
 
-    @Ignore("getWindow().getDecoreView() doesn't seem to return the root view in robolectric?")
     @Test
     public void shouldBeAbleToInjectReferencesToTaggedViews() {
         final D activity = Robolectric.buildActivity(D.class).create().get();
