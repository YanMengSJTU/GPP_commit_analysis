diff --git a/roboguice/src/main/java/roboguice/android/util/logging/AndroidBaseConfig.java b/roboguice/src/main/java/roboguice/android/util/logging/AndroidBaseConfig.java
index 1296b178c..bd2a53a43 100644
--- a/roboguice/src/main/java/roboguice/android/util/logging/AndroidBaseConfig.java
+++ b/roboguice/src/main/java/roboguice/android/util/logging/AndroidBaseConfig.java
@@ -21,7 +21,7 @@ public AndroidBaseConfig(Application context) {
             packageName = context.getPackageName();
             final int flags = context.getPackageManager().getApplicationInfo(packageName, 0).flags;
             minimumLogLevel = (flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0 ? LogLevel.VERBOSE : LogLevel.INFO;
-            scope = packageName.toUpperCase();
+            scope = packageName;
 
             Ln.d("Configuring Logging, minimum log level is %s", Ln.logLevelToString(minimumLogLevel.logLevel()) );
 
diff --git a/roboguice/src/main/java/roboguice/base/GuiceDebug.java b/roboguice/src/main/java/roboguice/base/GuiceDebug.java
new file mode 100644
index 000000000..5dfc8c6e7
--- /dev/null
+++ b/roboguice/src/main/java/roboguice/base/GuiceDebug.java
@@ -0,0 +1,59 @@
+package roboguice.base;
+
+import java.util.logging.Formatter;
+import java.util.logging.Handler;
+import java.util.logging.Level;
+import java.util.logging.LogRecord;
+import java.util.logging.Logger;
+import java.util.logging.StreamHandler;
+
+
+/**
+* Enable or disable Guice debug output
+* on the console.
+*/
+public class GuiceDebug {
+    private static Handler handler;
+    private static boolean enabled;
+    
+    protected static StreamHandler handler() {
+        StreamHandler streamHandler = new StreamHandler(System.out, new Formatter() {
+            public String format(LogRecord record) {
+                return String.format("[Guice %s] %s%n",
+                                  record.getLevel().getName(),
+                                  record.getMessage());
+            }
+        });
+        
+        streamHandler.setLevel(Level.ALL);
+        
+        return streamHandler;
+    }
+
+    private GuiceDebug() {}
+
+    public static Logger getLogger() {
+        return Logger.getLogger("com.google.inject");
+    }
+
+    public static void enable() {
+        if ( !enabled )
+        {
+            Logger guiceLogger = getLogger();
+            guiceLogger.addHandler(GuiceDebug.handler = handler());
+            guiceLogger.setLevel(Level.ALL);
+            
+            enabled = true;
+        }
+    }
+
+    public static void disable() {
+        enabled = false;
+        
+        Logger guiceLogger = getLogger();
+        guiceLogger.setLevel(Level.OFF);
+        guiceLogger.removeHandler(GuiceDebug.handler);
+        
+        GuiceDebug.handler = null;
+    }
+}
\ No newline at end of file
diff --git a/roboguice/src/main/java/roboguice/base/RoboGuice.java b/roboguice/src/main/java/roboguice/base/RoboGuice.java
index 3b7c57c4d..fa3e26385 100644
--- a/roboguice/src/main/java/roboguice/base/RoboGuice.java
+++ b/roboguice/src/main/java/roboguice/base/RoboGuice.java
@@ -1,29 +1,25 @@
 package roboguice.base;
 
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.security.InvalidParameterException;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
 import java.util.WeakHashMap;
 
 import roboguice.base.config.DefaultRoboModule;
 import roboguice.base.event.EventManager;
 import roboguice.base.inject.ResourceListener;
+import roboguice.base.inject.ResourceListener.RequestStaticResourceInjection;
+import roboguice.base.util.logging.Ln;
 
 import com.google.inject.Guice;
 import com.google.inject.Injector;
 import com.google.inject.Module;
 import com.google.inject.Stage;
-import com.google.inject.spi.DefaultElementVisitor;
-import com.google.inject.spi.Element;
-import com.google.inject.spi.Elements;
-import com.google.inject.spi.StaticInjectionRequest;
 
 import edu.emory.mathcs.backport.java.util.Arrays;
-import edu.emory.mathcs.backport.java.util.Collections;
 
 /**
  * 
@@ -127,10 +123,6 @@ public Injector getScopedInjector(S scopedObject ) {
         }
     }
     
-    //FIXME: Remove hack once fixes are in place
-    @SuppressWarnings("unchecked")
-    private static Set<Class<?>> inspectedTypesForResourceInjection = Collections.synchronizedSet( new HashSet<Class<?>>() );
-    
     /**
      * Return the cached Injector instance for this application, or create a new one if necessary.
      * If specifying your own modules, you must include a DefaultRoboModule for most things to work properly.
@@ -152,52 +144,16 @@ public Injector setScopedInjector(final S scopedObject, Stage stage, Module... m
         // Do a little rewriting on the modules first to
         // add static resource injection
         
-        System.out.println("Modules: " + modules.length);
-        System.out.println(" - " + Arrays.asList( modules ));
-        
-        System.out.println("Getting elements...");
-        
-        /*
-         * FIXME: According to https://code.google.com/p/roboguice/issues/detail?id=196
-         * This triggers .configure() on all modules, which will be triggered again below when calling .createInjector()
-         * This also increases depending on the number of modules available, so we might want to save the second, third trip, etc.
-         * by recording these elements internally on the AbstractModule and then when asking it to be configured again, 
-         * we just pull the already configured elements and avoid calling .configure() over and over for an already configured module for a given injector.
-         */
-        List<Element> moduleElements = Elements.getElements(modules);
-        
-        System.out.println("Elements: " + moduleElements.size());
+        Ln.v("Modules: %s", modules.length);
+        Ln.v(" - %s", Arrays.asList( modules ));
+        Ln.v("Stage: %s", stage );
         
-        /*
-         */
-        for (Element element : moduleElements) {
-            System.out.println("- " + element);
+        if ( stage == Stage.DEVELOPMENT )
+        {
+            GuiceDebug.enable();
         }
         
-        for(Element element : moduleElements) {
-            element.acceptVisitor(new DefaultElementVisitor<Void>() {
-                @Override
-                public Void visit(StaticInjectionRequest element) {
-                    
-                    Class<?> typeToInject = element.getType();
-                    
-                    if ( !inspectedTypesForResourceInjection.contains( typeToInject ) )
-                    {
-                        System.out.println("** StaticInjectionRequest: " + element + " - " + typeToInject);
-                        
-                        /*
-                         * FIXME: This causes us to reflectively scan every field in every class added to the static injection list to try and see if there's any with the InjectResource annotation, which can be costly.
-                         * Let's keep a separately list of StaticResourceInjectionRequests that are created by calling requestStaticResourceInjection, with only the guys we know have resources to be injected.
-                         */
-                        getResourceListener(scopedObject).requestStaticInjection(typeToInject);
-                        
-                        inspectedTypesForResourceInjection.add( typeToInject );
-                    }
-                    
-                    return null;
-                }
-            });
-        }
+        requestStaticResourceInjection(scopedObject, modules);
         
         synchronized (RoboGuice.class) {
             final Injector rtrn = Guice.createInjector(stage, modules);
@@ -205,6 +161,51 @@ public Void visit(StaticInjectionRequest element) {
             return rtrn;
         }
     }
+
+    /**
+     * Checking if module requests static resource injection for particular types
+     */
+    @SuppressWarnings("rawtypes")
+    protected void requestStaticResourceInjection(final S scopedObject, Module... modules) {
+        
+        for (Module module : modules) 
+        {
+            Class<? extends Module> moduleClass = module.getClass();
+            
+            if ( isAnnotationPresent( moduleClass, RequestStaticResourceInjection.class) )
+            {
+                RequestStaticResourceInjection requestStaticResourceInjection = getAnnotation(moduleClass, RequestStaticResourceInjection.class);
+                
+                Class[] classesToStaticallyInjectResources = requestStaticResourceInjection.value();
+                
+                Ln.v( "Static injection of resources for: " + Arrays.asList(classesToStaticallyInjectResources) );
+                
+                getResourceListener( scopedObject ).requestStaticInjection( classesToStaticallyInjectResources );
+            }
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    protected boolean isAnnotationPresent(Class<? extends Module> moduleClass, Class<? extends Annotation> annotationClass) {
+        return 
+               moduleClass.isAnnotationPresent( annotationClass ) || 
+               isModule( moduleClass ) &&
+               isAnnotationPresent( (Class<? extends Module>) moduleClass.getSuperclass(), annotationClass);
+    }
+
+    protected boolean isModule(Class<? extends Module> moduleClass) {
+        return moduleClass.getSuperclass() != null &&
+           Module.class.isAssignableFrom( moduleClass.getSuperclass() );
+    }
+    
+    @SuppressWarnings("unchecked")
+    protected <T extends Annotation> T getAnnotation(Class<? extends Module> moduleClass, Class<T> annotationClass) {
+        return moduleClass.getAnnotation(annotationClass) != null ?
+                moduleClass.getAnnotation(annotationClass) :
+                  isModule( moduleClass ) ?
+                     getAnnotation( (Class<? extends Module>) moduleClass.getSuperclass(), annotationClass ) :
+                     null;
+    }
     
     /**
      * Return the cached Injector instance for this application, or create a new one if necessary.
diff --git a/roboguice/src/main/java/roboguice/base/inject/ResourceListener.java b/roboguice/src/main/java/roboguice/base/inject/ResourceListener.java
index 9e54a393c..46a2d5449 100644
--- a/roboguice/src/main/java/roboguice/base/inject/ResourceListener.java
+++ b/roboguice/src/main/java/roboguice/base/inject/ResourceListener.java
@@ -1,5 +1,10 @@
 package roboguice.base.inject;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 
@@ -110,4 +115,12 @@ else if ( field.getType().equals(double.class) || field.getType().equals(Double.
         protected abstract Object getValue();
         
     }
+    
+    @Retention(RUNTIME)
+    @Target( { ElementType.TYPE })
+    @SuppressWarnings("rawtypes")
+    public @interface RequestStaticResourceInjection {
+        Class[] value();
+    }
+
 }
diff --git a/roboguice/src/main/java/roboguice/base/util/logging/BaseConfig.java b/roboguice/src/main/java/roboguice/base/util/logging/BaseConfig.java
index 60d121f30..98110366e 100644
--- a/roboguice/src/main/java/roboguice/base/util/logging/BaseConfig.java
+++ b/roboguice/src/main/java/roboguice/base/util/logging/BaseConfig.java
@@ -12,7 +12,7 @@
     public BaseConfig() {
         try {
             packageName = BaseConfig.class.getPackage().getName();
-            scope = packageName.toUpperCase();
+            scope = packageName;
 
             //can't really log with Ln just yet as building BaseConfig is done while initializing Ln and BaseConfig is not initialized as an instance in Ln (so Ln.* would all fail)
             //Ln.d("Configuring Logging, minimum log level is %s", Ln.logLevelToString(minimumLogLevel.logLevel()) );
diff --git a/roboguice/src/main/java/roboguice/base/util/logging/Print.java b/roboguice/src/main/java/roboguice/base/util/logging/Print.java
index e35efce8f..0c8ad317d 100644
--- a/roboguice/src/main/java/roboguice/base/util/logging/Print.java
+++ b/roboguice/src/main/java/roboguice/base/util/logging/Print.java
@@ -1,8 +1,13 @@
 package roboguice.base.util.logging;
 
+import org.apache.maven.artifact.ant.shaded.StringUtils;
+
 import com.google.inject.Inject;
 
 public class Print {
+    
+    protected static final int LOG_CALLER_DEPTH = 5;
+
     /**
      * config is initially set to BaseConfig() with sensible defaults, then replaced
      * by BaseConfig(ContextSingleton) during guice static injection pass.
@@ -11,23 +16,39 @@
     
     @Inject protected static Writer writer = new Writer();
      
-    public int println(LogLevel priority, String msg )
+    public int println(LogLevel priority, String msg)
     {
-        return writer.write(priority, getScope( 5 ), processMessage(msg) );
+        return writer.write(priority, getScope( LOG_CALLER_DEPTH ), processMessage(msg) );
     }
 
     protected String processMessage(String msg) {
-        if( config.getLoggingLevel().logLevel() <= LogLevel.DEBUG.logLevel() )
-            msg = String.format("%s %s", Thread.currentThread().getName(), msg);
         return msg;
     }
 
-    protected static String getScope(int skipDepth) {
+    protected String getScope(int skipDepth) {
         if( config.getLoggingLevel().logLevel() <= LogLevel.DEBUG.logLevel() ) {
-            final StackTraceElement trace = Thread.currentThread().getStackTrace()[skipDepth];
-            return config.scope() + "/" + trace.getFileName() + ":" + trace.getLineNumber();
+            return debugScope(skipDepth);
         }
 
         return config.scope();
     }
+
+    protected String debugScope(int skipDepth) {
+        final StackTraceElement trace = Thread.currentThread().getStackTrace()[skipDepth];
+        
+        return 
+           String
+               .format(
+                   "%s%s%s:%d [%s]", 
+                   config.scope(), 
+                   scopeSeparator(), 
+                   trace.getFileName(), 
+                   trace.getLineNumber(), 
+                   Thread.currentThread().getName()
+               );
+    }
+
+    protected String scopeSeparator() {
+        return !StringUtils.isEmpty( config.scope() ) ? "/" : "";
+    }
 }
diff --git a/roboguice/src/main/java/roboguice/base/util/logging/Writer.java b/roboguice/src/main/java/roboguice/base/util/logging/Writer.java
index a1f77c2a6..8d3cff090 100644
--- a/roboguice/src/main/java/roboguice/base/util/logging/Writer.java
+++ b/roboguice/src/main/java/roboguice/base/util/logging/Writer.java
@@ -1,5 +1,7 @@
 package roboguice.base.util.logging;
 
+import java.util.Calendar;
+
 import com.google.inject.Inject;
 
 public class Writer 
@@ -9,7 +11,10 @@
     
     public int write(LogLevel priority, String tag, String msg )
     {
-        System.out.println(String.format("%s - %s | %s", priority, tag, msg));
-        return 0;
+        String log = String.format("%s %s %s %s", Calendar.getInstance().getTime(), priority, tag, msg);
+        
+        System.out.println(log);
+        
+        return log.length();
     }
 }
diff --git a/roboguice/src/main/java/roboguice/java/util/logging/JavaBaseConfig.java b/roboguice/src/main/java/roboguice/java/util/logging/JavaBaseConfig.java
index 8a78f4104..e912e8e43 100644
--- a/roboguice/src/main/java/roboguice/java/util/logging/JavaBaseConfig.java
+++ b/roboguice/src/main/java/roboguice/java/util/logging/JavaBaseConfig.java
@@ -1,6 +1,5 @@
 package roboguice.java.util.logging;
 
-import org.apache.log4j.BasicConfigurator;
 import org.apache.log4j.Level;
 
 import roboguice.base.util.logging.BaseConfig;
@@ -10,7 +9,8 @@
 
     public JavaBaseConfig()
     {
-        BasicConfigurator.configure();
+        //BasicConfigurator.configure();
+        //will read from log4j.properties automatically
         
         minimumLogLevel = JavaLogLevel.ALL.getLogLevel();
     }
diff --git a/roboguice/src/main/java/roboguice/java/util/logging/JavaWriter.java b/roboguice/src/main/java/roboguice/java/util/logging/JavaWriter.java
index 16dfc73d7..9dcd92c23 100644
--- a/roboguice/src/main/java/roboguice/java/util/logging/JavaWriter.java
+++ b/roboguice/src/main/java/roboguice/java/util/logging/JavaWriter.java
@@ -1,5 +1,6 @@
 package roboguice.java.util.logging;
 
+import org.apache.log4j.Level;
 import org.apache.log4j.Logger;
 
 import roboguice.base.util.logging.LogLevel;
@@ -10,10 +11,22 @@
 
     @Override
     public int write( LogLevel priority, String tag, String msg ) {
-        Logger logger = Logger.getLogger(tag);
-        logger.setLevel( JavaLogLevel.from( config.getLoggingLevel() ).javaLevel() );
         
-        logger.log(JavaLogLevel.from(priority).javaLevel(), msg);
+        logger(tag).log(level(priority), msg);
+        
         return 0;
     }
+
+    protected Logger logger(String tag) {
+        Logger logger = Logger.getLogger( tag );
+        
+        logger.setLevel( level( config.getLoggingLevel() ) );
+        
+        return logger;
+    }
+    
+    protected Level level(LogLevel priority) {
+        return JavaLogLevel.from( priority ).javaLevel();
+    }
+
 }
diff --git a/roboguice/src/test/java/roboguice/android/activity/ActivityInjectionTest.java b/roboguice/src/test/java/roboguice/android/activity/ActivityInjectionTest.java
index 07a198316..b5ad4c38a 100644
--- a/roboguice/src/test/java/roboguice/android/activity/ActivityInjectionTest.java
+++ b/roboguice/src/test/java/roboguice/android/activity/ActivityInjectionTest.java
@@ -30,7 +30,10 @@
 import roboguice.android.inject.InjectPreference;
 import roboguice.android.inject.InjectView;
 import roboguice.android.test.RobolectricRoboTestRunner;
+import roboguice.base.RoboGuice;
+import roboguice.base.RoboGuice.RoboGuiceType;
 import roboguice.base.inject.InjectResource;
+import roboguice.base.inject.ResourceListener.RequestStaticResourceInjection;
 
 import com.google.inject.ConfigurationException;
 import com.google.inject.Inject;
@@ -50,16 +53,19 @@
 import android.widget.TextView;
 
 @RunWith(RobolectricRoboTestRunner.class)
+@SuppressWarnings("unchecked")
 public class ActivityInjectionTest {
 
     protected DummyActivity activity;
 
     @Before
     public void setup() {
-        DroidGuice.instance().setScopedInjector(Robolectric.application, Stage.DEVELOPMENT, DroidGuice.instance().newDefaultRoboModule(Robolectric.application), new ModuleA());
+    	RoboGuice.type = RoboGuiceType.ANDROID;
+        RoboGuice.instance().setScopedInjector(Robolectric.application, Stage.DEVELOPMENT, RoboGuice.instance().newDefaultRoboModule(Robolectric.application), new ModuleA());
+        
         activity = new DummyActivity();
         activity.setIntent( new Intent(Robolectric.application,DummyActivity.class).putExtra("foobar","goober") );
-        activity.onCreate(null);
+        activity.onCreate(new Bundle());
     }
 
     @Test
@@ -100,7 +106,7 @@ public void shouldInjectActivityAndRoboActivity() {
 
     @Test(expected = ConfigurationException.class)
     public void shouldNotStaticallyInjectViews() {
-        DroidGuice.instance().setScopedInjector(Robolectric.application, Stage.DEVELOPMENT, DroidGuice.instance().newDefaultRoboModule(Robolectric.application), new ModuleB());
+        RoboGuice.instance().setScopedInjector(Robolectric.application, Stage.DEVELOPMENT, RoboGuice.instance().newDefaultRoboModule(Robolectric.application), new ModuleB());
         final B b = new B();
         b.onCreate(null);
     }
@@ -219,6 +225,7 @@ protected LinearLayout addIncludedView(int includedRootId, int stringResId) {
         }
     }
 
+    @RequestStaticResourceInjection( A.class )
     public static class ModuleA extends com.google.inject.AbstractModule {
         @Override
         protected void configure() {
