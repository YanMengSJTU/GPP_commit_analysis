diff --git a/1 b/1
new file mode 100644
index 000000000..55636a547
--- /dev/null
+++ b/1
@@ -0,0 +1,30 @@
+[INFO] Scanning for projects...
+[WARNING] 
+[WARNING] Some problems were encountered while building the effective model for org.roboguice:roboguice:jar:3.0-alpha-SNAPSHOT
+[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-pmd-plugin is missing. @ line 161, column 12
+[WARNING] 
+[WARNING] Some problems were encountered while building the effective model for org.roboguice:afterburner:jar:3.0-alpha-SNAPSHOT
+[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-pmd-plugin is missing. @ line 153, column 12
+[WARNING] 
+[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
+[WARNING] 
+[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
+[WARNING] 
+[INFO]                                                                         
+[INFO] ------------------------------------------------------------------------
+[INFO] Building RoboGuice 3.0-alpha-SNAPSHOT
+[INFO] ------------------------------------------------------------------------
+[INFO] ------------------------------------------------------------------------
+[INFO] BUILD FAILURE
+[INFO] ------------------------------------------------------------------------
+[INFO] Total time: 0.964s
+[INFO] Finished at: Fri May 09 22:28:26 CEST 2014
+[INFO] Final Memory: 14M/132M
+[INFO] ------------------------------------------------------------------------
+[ERROR] Unknown lifecycle phase "2". You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]
+[ERROR] 
+[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
+[ERROR] Re-run Maven using the -X switch to enable full debug logging.
+[ERROR] 
+[ERROR] For more information about the errors and possible solutions, please read the following articles:
+[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/LifecyclePhaseNotFoundException
diff --git a/afterburner/pom.xml b/afterburner/pom.xml
index b716b599b..e21ce6440 100644
--- a/afterburner/pom.xml
+++ b/afterburner/pom.xml
@@ -55,17 +55,10 @@
 			<artifactId>android</artifactId>
 			<version>${android-platform.version}</version>
 		</dependency>
-		<dependency>
-			<groupId>com.google.android.maps</groupId>
-			<artifactId>maps</artifactId>
-			<version>${android-map.version}</version>
-			<optional>true</optional>
-		</dependency>
 		<dependency>
 			<groupId>android.support</groupId>
 			<artifactId>compatibility-v4</artifactId>
 			<version>${android-support-v4.version}</version>
-			<optional>true</optional>
 		</dependency>
 		<dependency>
 			<groupId>android.support</groupId>
@@ -73,14 +66,6 @@
 			<version>${android-appcompat-v7.version}</version>
 			<optional>true</optional>
 		</dependency>
-		<dependency>
-			<groupId>com.actionbarsherlock</groupId>
-			<artifactId>actionbarsherlock</artifactId>
-			<version>${actionbarsherlock.version}</version>
-			<type>jar</type>
-			<scope>provided</scope>
-			<optional>true</optional>
-		</dependency>
 		<dependency>
 			<groupId>com.google.code.findbugs</groupId>
 			<artifactId>jsr305</artifactId>
diff --git a/afterburner/src/main/java/afterburner/PostProcessor.java b/afterburner/src/main/java/afterburner/PostProcessor.java
index bd8178cf7..08eba221e 100644
--- a/afterburner/src/main/java/afterburner/PostProcessor.java
+++ b/afterburner/src/main/java/afterburner/PostProcessor.java
@@ -18,6 +18,8 @@
 import roboguice.inject.InjectView;
 import android.app.Activity;
 import android.app.Fragment;
+import android.os.Bundle;
+import android.view.View;
 
 import com.github.drochetti.javassist.maven.ClassTransformer;
 
@@ -26,40 +28,66 @@
     @Override
     protected boolean filter(CtClass candidateClass) throws Exception {
         boolean isActivity = candidateClass.subclassOf(ClassPool.getDefault().get(Activity.class.getName()));
+        boolean isFragment = candidateClass.subclassOf(ClassPool.getDefault().get(Fragment.class.getName()));
+        boolean isSupportFragment = candidateClass.subclassOf(ClassPool.getDefault().get(android.support.v4.app.Fragment.class.getName()));
         boolean hasAfterBurner = checkIfAfterBurnerAlreadyActive(candidateClass);
-        return isActivity && !hasAfterBurner;
-    }    
+        return !hasAfterBurner && (isActivity || isFragment || isSupportFragment);
+    }
 
     @Override
     protected void applyTransformations(final CtClass classToTransform) throws Exception {
         // Actually you must test if it exists, but it's just an example...
-        getLogger().debug("Analysing "+classToTransform);
-        injectStuffInClass(classToTransform);
+        getLogger().debug("Analysing " + classToTransform);
+        boolean isActivity = classToTransform.subclassOf(ClassPool.getDefault().get(Activity.class.getName()));
+        boolean isFragment = classToTransform.subclassOf(ClassPool.getDefault().get(Fragment.class.getName()));
+        boolean isSupportFragment = classToTransform.subclassOf(ClassPool.getDefault().get(android.support.v4.app.Fragment.class.getName()));
+        if (isActivity) {
+            injectStuffInActivity(classToTransform);
+        } else if (isFragment || isSupportFragment) {
+            injectStuffInFragment(classToTransform);
+        }
     }
 
-    private void injectStuffInClass(final CtClass classToTransform) throws NotFoundException, ClassNotFoundException, CannotCompileException {
+    private void injectStuffInActivity(final CtClass classToTransform) throws NotFoundException, ClassNotFoundException, CannotCompileException {
         int layoutId = getLayoutId(classToTransform);
         final List<CtField> views = getAllInjectedFieldsForAnnotation(classToTransform, InjectView.class);
         final List<CtField> fragments = getAllInjectedFieldsForAnnotation(classToTransform, InjectFragment.class);
-        if( views.isEmpty() && fragments.isEmpty() ) {
+        if (views.isEmpty() && fragments.isEmpty()) {
             return;
         }
-        CtMethod onCreateMethod = extractOnCreateMethod(classToTransform);
-        if( onCreateMethod != null ) {
+        CtMethod onCreateMethod = extractExistingMethod(classToTransform, "onCreate");
+        if (onCreateMethod != null) {
             boolean isCallingSetContentView = checkIfMethodIsInvoked(classToTransform, onCreateMethod, "setContentView");
             String insertionMethod = "onCreate";
-            if( isCallingSetContentView ) {
+            if (isCallingSetContentView) {
                 layoutId = -1;
                 insertionMethod = "setContentView";
             }
             InjectorEditor injectorEditor = new InjectorEditor(classToTransform, fragments, views, layoutId, insertionMethod);
-            onCreateMethod.instrument( injectorEditor);
+            onCreateMethod.instrument(injectorEditor);
         } else {
-            classToTransform.addMethod( CtNewMethod.make(createOnCreateBody(classToTransform, views, fragments, layoutId)
-                    , classToTransform));
+            classToTransform.addMethod(CtNewMethod.make(createOnCreateBody(classToTransform, views, fragments, layoutId), classToTransform));
         }
         classToTransform.detach();
-        injectStuffInClass( classToTransform.getSuperclass() );
+        injectStuffInActivity(classToTransform.getSuperclass());
+    }
+
+    private void injectStuffInFragment(final CtClass classToTransform) throws NotFoundException, ClassNotFoundException, CannotCompileException {
+        final List<CtField> views = getAllInjectedFieldsForAnnotation(classToTransform, InjectView.class);
+        final List<CtField> fragments = getAllInjectedFieldsForAnnotation(classToTransform, InjectFragment.class);
+        if (views.isEmpty() && fragments.isEmpty()) {
+            return;
+        }
+        CtMethod onViewCreatedMethod = extractExistingMethod(classToTransform, "onViewCreated");
+        System.out.println("onViewCreatedMethod : " + onViewCreatedMethod);
+        if (onViewCreatedMethod != null) {
+            InjectorEditor injectorEditor = new InjectorEditor(classToTransform, fragments, views, -1, "onViewCreated");
+            onViewCreatedMethod.instrument(injectorEditor);
+        } else {
+            classToTransform.addMethod(CtNewMethod.make(createOnViewCreatedBody(classToTransform, views, fragments), classToTransform));
+        }
+        classToTransform.detach();
+        injectStuffInActivity(classToTransform.getSuperclass());
     }
 
     private boolean checkIfMethodIsInvoked(final CtClass clazz, CtMethod withinMethod, String invokedMEthod) throws CannotCompileException {
@@ -70,16 +98,16 @@ private boolean checkIfMethodIsInvoked(final CtClass clazz, CtMethod withinMetho
     }
 
     private String createOnCreateBody(CtClass clazz, List<CtField> views, List<CtField> fragments, int layoutId) throws ClassNotFoundException, NotFoundException {
-        return "public void onCreate(android.os.Bundle bundle) { \n"
-                + "super.onCreate(bundle);\n"
-                + createInjectedBody(clazz, views, fragments, layoutId)
-                + "}";
+        return "public void onCreate(android.os.Bundle savedInstanceState) { \n" + "super.onCreate(savedInstanceState);\n" + createInjectedBody(clazz, views, fragments, layoutId) + "}";
+    }
 
+    private String createOnViewCreatedBody(CtClass clazz, List<CtField> views, List<CtField> fragments) throws ClassNotFoundException, NotFoundException {
+        return "public void onViewCreated(android.view.View view, android.os.Bundle savedInstanceState) { \n" + "super.onViewCreated(view, savedInstanceState);\n" + createInjectedBody(clazz, views, fragments, -1) + "}";
     }
 
-    private CtMethod extractOnCreateMethod(final CtClass classToTransform) {
+    private CtMethod extractExistingMethod(final CtClass classToTransform, String methodName) {
         try {
-            return classToTransform.getDeclaredMethod("onCreate");
+            return classToTransform.getDeclaredMethod(methodName);
         } catch (Exception e) {
             return null;
         }
@@ -87,7 +115,7 @@ private CtMethod extractOnCreateMethod(final CtClass classToTransform) {
 
     private int getLayoutId(final CtClass classToTransform) {
         try {
-            return ((ContentView)classToTransform.getAnnotation(ContentView.class)).value();
+            return ((ContentView) classToTransform.getAnnotation(ContentView.class)).value();
         } catch (Exception e) {
             return -1;
         }
@@ -103,50 +131,48 @@ private boolean checkIfAfterBurnerAlreadyActive(final CtClass classToTransform)
     }
 
     private void markAfterBurnerActiveInClass(final CtClass classToTransform) throws CannotCompileException {
-        classToTransform.addField(new CtField(CtClass.booleanType,"afterBurnerActive", classToTransform));
+        classToTransform.addField(new CtField(CtClass.booleanType, "afterBurnerActive", classToTransform));
     }
 
-
     private String injectContentView(int layoutId) {
-        return "setContentView("+layoutId+");\n";
+        return "setContentView(" + layoutId + ");\n";
     }
 
-    private String injectFragmentStatements(List<CtField> fragments) throws ClassNotFoundException, NotFoundException {
+    private String injectFragmentStatements(CtClass classToTransform, List<CtField> fragments) throws ClassNotFoundException, NotFoundException {
         StringBuffer buffer = new StringBuffer();
-        for( CtField field : fragments ) {
-            int id = ((InjectFragment)field.getAnnotation(InjectFragment.class)).value();
-            String tag = ((InjectFragment)field.getAnnotation(InjectFragment.class)).tag();
+        for (CtField field : fragments) {
+            int id = ((InjectFragment) field.getAnnotation(InjectFragment.class)).value();
+            String tag = ((InjectFragment) field.getAnnotation(InjectFragment.class)).tag();
             boolean isUsingId = id != -1;
-            buffer.append( field.getName() );
-            buffer.append( " = " );
-            buffer.append( '(' );
+            buffer.append(field.getName());
+            buffer.append(" = ");
+            buffer.append('(');
             CtClass fragmentType = field.getType();
-            buffer.append( fragmentType.getName() );
-            buffer.append( ')' );
+            buffer.append(fragmentType.getName());
+            buffer.append(')');
             boolean isUsingSupport = !fragmentType.subclassOf(ClassPool.getDefault().get(Fragment.class.getName()));
             String getFragmentManagerString = isUsingSupport ? "getSupportFragmentManager()" : "getFragmentManager()";
-            String getFragmentString = isUsingId ? ".findFragmentById("+id+")" : ".findFragmentByTag("+tag+")";
-            buffer.append( getFragmentManagerString+getFragmentString+";\n" );
+            String getFragmentString = isUsingId ? ".findFragmentById(" + id + ")" : ".findFragmentByTag(" + tag + ")";
+            buffer.append(getFragmentManagerString + getFragmentString + ";\n");
         }
         return buffer.toString();
     }
 
-    private String injectViewStatements(List<CtField> views) throws ClassNotFoundException, NotFoundException {
+    private String injectViewStatements(CtClass classToTransform, List<CtField> viewsToInject, String root) throws ClassNotFoundException, NotFoundException {
         StringBuffer buffer = new StringBuffer();
-        for( CtField field : views ) {
-            int id;
-            id = ((InjectView)field.getAnnotation(InjectView.class)).value();
-            String tag = ((InjectView)field.getAnnotation(InjectView.class)).tag();
+        for (CtField field : viewsToInject) {
+            int id = ((InjectView) field.getAnnotation(InjectView.class)).value();
+            String tag = ((InjectView) field.getAnnotation(InjectView.class)).tag();
             boolean isUsingId = id != -1;
 
-            buffer.append( field.getName() );
-            buffer.append( " = " );
-            buffer.append( '(' );
-            buffer.append( field.getType().getName() );
-            buffer.append( ')' );
+            buffer.append(field.getName());
+            buffer.append(" = ");
+            buffer.append('(');
+            buffer.append(field.getType().getName());
+            buffer.append(')');
 
-            String findViewString = isUsingId ? "findViewById("+id+")" : "findViewByTag("+tag+")";
-            buffer.append( findViewString+";\n" );
+            String findViewString = isUsingId ? "findViewById(" + id + ")" : "findViewByTag(" + tag + ")";
+            buffer.append(root + "." + findViewString + ";\n");
         }
         return buffer.toString();
     }
@@ -154,35 +180,44 @@ private String injectViewStatements(List<CtField> views) throws ClassNotFoundExc
     private List<CtField> getAllInjectedFieldsForAnnotation(CtClass clazz, Class<? extends Annotation> annotationClazz) {
         List<CtField> result = new ArrayList<CtField>();
         CtField[] allFields = clazz.getDeclaredFields();
-        getLogger().debug("Scanning fields in "+clazz.getName());
+        getLogger().debug("Scanning fields in " + clazz.getName());
         for (CtField field : allFields) {
-            getLogger().debug("Discovered field "+field.getName());
-            if( field.hasAnnotation(annotationClazz) ) {
+            getLogger().debug("Discovered field " + field.getName());
+            if (field.hasAnnotation(annotationClazz)) {
                 result.add(field);
             }
         }
         return result;
     }
 
-    private String createInjectedBody(CtClass classToTransform, List<CtField> views, List<CtField> fragments, int layoutId) throws ClassNotFoundException, NotFoundException {
+    private String createInjectedBody(CtClass clazz, List<CtField> views, List<CtField> fragments, int layoutId) throws ClassNotFoundException, NotFoundException {
+        boolean isActivity = clazz.subclassOf(ClassPool.getDefault().get(Activity.class.getName()));
+        boolean isFragment = clazz.subclassOf(ClassPool.getDefault().get(Fragment.class.getName()));
+        boolean isSupportFragment = clazz.subclassOf(ClassPool.getDefault().get(android.support.v4.app.Fragment.class.getName()));
+
         StringBuffer buffer = new StringBuffer();
-        String message = String.format("Class %s has been enhanced.", classToTransform.getName());
-        buffer.append("android.util.Log.d(\"RoboGuice post-processor\",\""+message+"\");\n");
+        String message = String.format("Class %s has been enhanced.", clazz.getName());
+        buffer.append("android.util.Log.d(\"RoboGuice post-processor\",\"" + message + "\");\n");
 
-        if( layoutId != -1 ) { 
+        if (layoutId != -1) {
             buffer.append(injectContentView(layoutId));
         }
-        if( !views.isEmpty() ) {
-            buffer.append(injectViewStatements(views));
+        if (!views.isEmpty()) {
+            if( isActivity ) {
+                buffer.append(injectViewStatements(clazz, views, "this"));
+            } else if( isFragment || isSupportFragment ){
+                buffer.append(injectViewStatements(clazz, views, "$1"));
+            }
         }
-        if( !fragments.isEmpty() ) {
-            buffer.append(injectFragmentStatements(fragments));
+        if (!fragments.isEmpty()) {
+            if( isActivity ) {
+                buffer.append(injectFragmentStatements(clazz, fragments));
+            }
         }
         String string = buffer.toString();
         return string;
     }
 
-
     private final class InjectorEditor extends ExprEditor {
         private final CtClass classToTransform;
         private final List<CtField> fragments;
@@ -201,23 +236,23 @@ private InjectorEditor(CtClass classToTransform, List<CtField> fragments, List<C
         @Override
         public void edit(MethodCall m) throws CannotCompileException {
             try {
-                getLogger().debug("method call "+m.getMethodName());
-                if( m.getMethodName().equals(insertionMethod) ) {
-                    getLogger().debug("insertion method "+m.getMethodName());
+                getLogger().debug("method call " + m.getMethodName());
+                if (m.getMethodName().equals(insertionMethod)) {
+                    getLogger().debug("insertion method " + m.getMethodName());
 
                     String string;
-                    string = "$_ = $proceed($$);\n"+createInjectedBody(m.getEnclosingClass(), views, fragments, layoutId );
+                    string = "$_ = $proceed($$);\n" + createInjectedBody(m.getEnclosingClass(), views, fragments, layoutId);
                     getLogger().debug("Injected : " + string);
 
-                    m.replace(string );
-                    //mark class to avoid duplicate
+                    m.replace(string);
+                    // mark class to avoid duplicate
                     markAfterBurnerActiveInClass(classToTransform);
                     getLogger().info("Class {} has been enhanced.", classToTransform.getName());
                 }
             } catch (ClassNotFoundException e) {
-                throw new CannotCompileException("Class not found during class transformation",e);
+                throw new CannotCompileException("Class not found during class transformation", e);
             } catch (NotFoundException e) {
-                throw new CannotCompileException("Annotation not found during class transformation",e);
+                throw new CannotCompileException("Annotation not found during class transformation", e);
             }
         }
 
@@ -228,13 +263,13 @@ public void edit(MethodCall m) throws CannotCompileException {
         private String methodName;
         private boolean isCallingMethod;
 
-        private DetectMethodCallEditor(CtClass classToTransform, String methodName ) {
+        private DetectMethodCallEditor(CtClass classToTransform, String methodName) {
             this.methodName = methodName;
         }
 
         @Override
         public void edit(MethodCall m) throws CannotCompileException {
-            if( m.getMethodName().equals(methodName) ) {
+            if (m.getMethodName().equals(methodName)) {
                 this.isCallingMethod = true;
             }
         }
