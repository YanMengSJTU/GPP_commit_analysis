diff --git a/additional-tests/pom.xml b/additional-tests/pom.xml
index 1d779ded2..c5510aff5 100644
--- a/additional-tests/pom.xml
+++ b/additional-tests/pom.xml
@@ -40,6 +40,11 @@
 			<optional>true</optional>
 			<scope>provided</scope>
 		</dependency>
+    <dependency>
+      <groupId>org.reflection_no_reflection</groupId>
+      <artifactId>generator</artifactId>
+      <version>1.0.0-SNAPSHOT</version>
+    </dependency>
 		<dependency>
 			<groupId>org.roboguice</groupId>
 			<artifactId>roboguice</artifactId>
diff --git a/astroboy/pom.xml b/astroboy/pom.xml
index 6448a81db..55f25c8e1 100644
--- a/astroboy/pom.xml
+++ b/astroboy/pom.xml
@@ -16,7 +16,12 @@
 			<groupId>org.roboguice</groupId>
 			<artifactId>roboblender</artifactId>
 			<version>${project.version}</version>
-			<optional>true</optional>
+			<scope>provided</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.reflection_no_reflection</groupId>
+			<artifactId>generator</artifactId>
+			<version>1.0.0-SNAPSHOT</version>
 			<scope>provided</scope>
 		</dependency>
 		<!-- TEST DEPENDENCIES -->
@@ -44,7 +49,22 @@
 			<groupId>org.roboguice</groupId>
 			<artifactId>roboguice</artifactId>
 			<version>${project.version}</version>
-		</dependency>
+      <exclusions>
+        <exclusion>  <!-- declare the exclusion here -->
+          <groupId>com.google.inject</groupId>
+          <artifactId>guice</artifactId>
+        </exclusion>
+        <exclusion>  <!-- declare the exclusion here -->
+          <groupId>findbugs</groupId>
+          <artifactId>annotations</artifactId>
+        </exclusion>
+      </exclusions>
+    </dependency>
+    <dependency>
+      <groupId>com.jakewharton</groupId>
+      <artifactId>butterknife</artifactId>
+      <version>7.0.1</version>
+    </dependency>
 
 		<!-- TEST DEPENDENCIES -->
 		<dependency>
@@ -83,7 +103,16 @@
 				<configuration>
 					<source>${java.version}</source>
 					<target>${java.version}</target>
-				</configuration>
+          <compilerArgs>
+            <arg>-AtargetAnnotatedClasses=javax.inject.Inject,com.google.inject.Inject</arg>
+            <arg>-AmaxLevel=1</arg>
+            <arg>-AtargetPackageName=org.reflection_no_reflection.generator.sample.gen</arg>
+            <arg>-Aintrospector.includes=org.roboguice.astroboy.*</arg>
+            <arg>-Aintrospector.excludes=java\\..*,javax.inject.Inject</arg>
+            <arg>-Amodule.enabled=false</arg>
+            <arg>-Aannotation.enabled=false</arg>
+          </compilerArgs>
+        </configuration>
 			</plugin>
 		</plugins>
 
diff --git a/astroboy/src/main/java/org/roboguice/astroboy/activity/A.java b/astroboy/src/main/java/org/roboguice/astroboy/activity/A.java
new file mode 100644
index 000000000..6fbcfd568
--- /dev/null
+++ b/astroboy/src/main/java/org/roboguice/astroboy/activity/A.java
@@ -0,0 +1,10 @@
+package org.roboguice.astroboy.activity;
+
+import com.google.inject.Inject;
+
+/**
+* Created by administrateur on 15-07-21.
+*/
+class A {
+    @Inject B b;
+}
diff --git a/astroboy/src/main/java/org/roboguice/astroboy/activity/AstroboyMasterConsole.java b/astroboy/src/main/java/org/roboguice/astroboy/activity/AstroboyMasterConsole.java
index 9e6365777..4ea8e790a 100644
--- a/astroboy/src/main/java/org/roboguice/astroboy/activity/AstroboyMasterConsole.java
+++ b/astroboy/src/main/java/org/roboguice/astroboy/activity/AstroboyMasterConsole.java
@@ -1,11 +1,11 @@
 package org.roboguice.astroboy.activity;
 
+import android.app.Activity;
+import butterknife.Bind;
+import butterknife.ButterKnife;
 import org.roboguice.astroboy.R;
 import org.roboguice.astroboy.controller.AstroboyRemoteControl;
 
-import roboguice.activity.RoboActivity;
-import roboguice.inject.ContentView;
-import roboguice.inject.InjectView;
 import android.content.Intent;
 import android.os.Bundle;
 import android.os.Vibrator;
@@ -18,6 +18,7 @@
 import android.widget.TextView.OnEditorActionListener;
 
 import com.google.inject.Inject;
+import roboguice.RoboGuice;
 
 /**
  * This activity uses an AstroboyRemoteControl to control Astroboy remotely!
@@ -30,15 +31,14 @@
  *     an object's default constructor, versus when it does something "special"
  *     like call getSystemService()
  */
-@ContentView(R.layout.main)
-public class AstroboyMasterConsole extends RoboActivity {
+public class AstroboyMasterConsole extends Activity {
 
     // Various views that we inject into the activity.
     // Equivalent to calling findViewById() in your onCreate(), except more succinct
-    @InjectView(R.id.self_destruct) Button selfDestructButton;
-    @InjectView(R.id.say_text)      EditText sayText;
-    @InjectView(R.id.brush_teeth)   Button brushTeethButton;
-    @InjectView(tag="fightevil")    Button fightEvilButton;     // we can also use tags if we want
+    @Bind(R.id.self_destruct) Button selfDestructButton;
+    @Bind(R.id.say_text)      EditText sayText;
+    @Bind(R.id.brush_teeth)   Button brushTeethButton;
+    @Bind(R.id.fight_evil)    Button fightEvilButton;     // we can also use tags if we want
 
 
     // Standard Guice injection of Plain Old Java Objects (POJOs)
@@ -52,11 +52,20 @@
     @Inject AstroboyRemoteControl remoteControl;
     @Inject Vibrator vibrator;
 
-
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState); // @Inject, @InjectResource, and @InjectExtra injection happens during super.onCreate()
 
+        setContentView(R.layout.main);
+        ButterKnife.bind(this);
+        RoboGuice.getInjector(this).injectMembers(this);
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < 100; i++) {
+            RoboGuice.getInjector(this).getInstance(A.class);
+        }
+        long end = System.currentTimeMillis();
+        System.out.println("100 iterations of A creation in (ms)" + (end-start));
+
         sayText.setOnEditorActionListener(new OnEditorActionListener() {
             public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
 
diff --git a/astroboy/src/main/java/org/roboguice/astroboy/activity/AsyncPunch.java b/astroboy/src/main/java/org/roboguice/astroboy/activity/AsyncPunch.java
new file mode 100644
index 000000000..8d31ceb0f
--- /dev/null
+++ b/astroboy/src/main/java/org/roboguice/astroboy/activity/AsyncPunch.java
@@ -0,0 +1,29 @@
+package org.roboguice.astroboy.activity;
+
+import android.content.Context;
+import java.util.Random;
+import javax.inject.Inject;
+import org.roboguice.astroboy.controller.Astroboy;
+import roboguice.util.RoboAsyncTask;
+
+/**
+* Created by administrateur on 15-07-20.
+*/ // This class will call Astroboy.punch() in the background
+public class AsyncPunch extends RoboAsyncTask<String> {
+
+    // Because Astroboy is a @Singleton, this will be the same
+    // instance that we inject elsewhere in our app.
+    // Random of course will be a new instance of java.util.Random, since
+    // we haven't specified any special binding instructions anywhere
+    @Inject Astroboy astroboy;
+    @Inject Random random;
+
+    public AsyncPunch(Context context) {
+        super(context);
+    }
+
+    public String call() throws Exception {
+        Thread.sleep(random.nextInt(5*1000));
+        return astroboy.punch();
+    }
+}
diff --git a/astroboy/src/main/java/org/roboguice/astroboy/activity/B.java b/astroboy/src/main/java/org/roboguice/astroboy/activity/B.java
new file mode 100644
index 000000000..ed24eb681
--- /dev/null
+++ b/astroboy/src/main/java/org/roboguice/astroboy/activity/B.java
@@ -0,0 +1,7 @@
+package org.roboguice.astroboy.activity;
+
+/**
+* Created by administrateur on 15-07-21.
+*/
+class B {
+}
diff --git a/astroboy/src/main/java/org/roboguice/astroboy/activity/FightForcesOfEvilActivity.java b/astroboy/src/main/java/org/roboguice/astroboy/activity/FightForcesOfEvilActivity.java
index 11225de66..204e5a4da 100644
--- a/astroboy/src/main/java/org/roboguice/astroboy/activity/FightForcesOfEvilActivity.java
+++ b/astroboy/src/main/java/org/roboguice/astroboy/activity/FightForcesOfEvilActivity.java
@@ -1,17 +1,13 @@
 package org.roboguice.astroboy.activity;
 
-import java.util.Random;
-
-import javax.inject.Inject;
+import android.app.Activity;
+import android.view.animation.AnimationUtils;
+import butterknife.Bind;
+import butterknife.ButterKnife;
 
 import org.roboguice.astroboy.R;
-import org.roboguice.astroboy.controller.Astroboy;
 
-import roboguice.activity.RoboActivity;
-import roboguice.inject.InjectResource;
-import roboguice.inject.InjectView;
-import roboguice.util.RoboAsyncTask;
-import android.content.Context;
+import roboguice.RoboGuice;
 import android.os.Bundle;
 import android.view.animation.Animation;
 import android.widget.TextView;
@@ -22,12 +18,11 @@
  *     - How to use RoboAsyncTask to do background tasks with injection
  *     - What it means to be a @Singleton
  */
-public class FightForcesOfEvilActivity extends RoboActivity {
+public class FightForcesOfEvilActivity extends Activity {
 
-    @InjectView(R.id.expletive) TextView expletiveText;
+    @Bind(R.id.expletive) TextView expletiveText;
 
-    // You can also inject resources such as Strings, Drawables, and Animations
-    @InjectResource(R.anim.expletive_animation) Animation expletiveAnimation;
+    Animation expletiveAnimation;
 
     // AstroboyRemoteControl is annotated as @ContextSingleton, so the instance
     // we get in FightForcesOfEvilActivity will be a different instance than
@@ -39,6 +34,8 @@ protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.fight_evil);
 
+        ButterKnife.bind(this);
+        expletiveAnimation = AnimationUtils.loadAnimation(this, R.anim.expletive_animation);
         expletiveText.setAnimation(expletiveAnimation);
         expletiveAnimation.start();
 
@@ -56,25 +53,9 @@ protected void onSuccess(String expletive) throws Exception {
 
     }
 
-
-
-    // This class will call Astroboy.punch() in the background
-    public static class AsyncPunch extends RoboAsyncTask<String> {
-
-        // Because Astroboy is a @Singleton, this will be the same
-        // instance that we inject elsewhere in our app.
-        // Random of course will be a new instance of java.util.Random, since
-        // we haven't specified any special binding instructions anywhere
-        @Inject Astroboy astroboy;
-        @Inject Random random;
-
-        public AsyncPunch(Context context) {
-            super(context);
-        }
-
-        public String call() throws Exception {
-            Thread.sleep(random.nextInt(5*1000));
-            return astroboy.punch();
-        }
+    @Override
+    protected void onDestroy() {
+        RoboGuice.destroyInjector(this);
+        super.onDestroy();
     }
 }
diff --git a/astroboy/src/main/java/org/roboguice/astroboy/view/CustomView.java b/astroboy/src/main/java/org/roboguice/astroboy/view/CustomView.java
index 4edfed2ef..076c34d1e 100644
--- a/astroboy/src/main/java/org/roboguice/astroboy/view/CustomView.java
+++ b/astroboy/src/main/java/org/roboguice/astroboy/view/CustomView.java
@@ -1,8 +1,9 @@
 package org.roboguice.astroboy.view;
 
+import butterknife.Bind;
+import butterknife.ButterKnife;
 import org.roboguice.astroboy.R;
 
-import roboguice.inject.InjectView;
 import android.content.Context;
 import android.util.AttributeSet;
 import android.view.LayoutInflater;
@@ -13,10 +14,8 @@
 
 public class CustomView extends LinearLayout {
 
-    @InjectView(R.id.close_tv)
-    private Button buttonCloseTv;
-    @InjectView(R.id.tv_status)
-    private TextView textviewStatus;
+    @Bind(R.id.close_tv) Button buttonCloseTv;
+    @Bind(R.id.tv_status) TextView textviewStatus;
 
     public CustomView(Context context, AttributeSet attrs) {
         super(context, attrs);
@@ -30,6 +29,7 @@ public CustomView(Context context) {
 
     public void initializeView(Context context) {
         LayoutInflater.from(context).inflate(R.layout.view_custom, this, true);
+        ButterKnife.bind(this);
     }
 
     @Override
diff --git a/astroboy/src/test/java/org/roboguice/astroboy/controller/Astroboy1Test.java b/astroboy/src/test/java/org/roboguice/astroboy/controller/Astroboy1Test.java
index 83a87f043..dba1d2366 100644
--- a/astroboy/src/test/java/org/roboguice/astroboy/controller/Astroboy1Test.java
+++ b/astroboy/src/test/java/org/roboguice/astroboy/controller/Astroboy1Test.java
@@ -2,6 +2,7 @@
 
 import static org.junit.Assert.assertTrue;
 
+import android.app.Activity;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -9,7 +10,6 @@
 import org.robolectric.RobolectricTestRunner;
 
 import roboguice.RoboGuice;
-import roboguice.activity.TestRoboActivity;
 import android.content.Context;
 
 /**
@@ -28,7 +28,7 @@
     @Before
     public void setup() {
        RoboGuice.setUseAnnotationDatabases(false);
-       context = Robolectric.buildActivity(TestRoboActivity.class).create().get();
+       context = Robolectric.buildActivity(Activity.class).create().get();
        astroboy = RoboGuice.getInjector(context).getInstance(Astroboy.class);
     }
 
diff --git a/astroboy/src/test/java/org/roboguice/astroboy/controller/Astroboy2Test.java b/astroboy/src/test/java/org/roboguice/astroboy/controller/Astroboy2Test.java
index 54b5d89b5..949e35dca 100644
--- a/astroboy/src/test/java/org/roboguice/astroboy/controller/Astroboy2Test.java
+++ b/astroboy/src/test/java/org/roboguice/astroboy/controller/Astroboy2Test.java
@@ -5,12 +5,12 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import android.app.Activity;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import roboguice.RoboGuice;
-import roboguice.activity.TestRoboActivity;
 import android.app.Application;
 import android.content.Context;
 import android.os.Vibrator;
@@ -24,7 +24,7 @@
  */
 public class Astroboy2Test {
     protected Application application = mock(Application.class, RETURNS_DEEP_STUBS);
-    protected Context context = mock(TestRoboActivity.class, RETURNS_DEEP_STUBS);
+    protected Context context = mock(Activity.class, RETURNS_DEEP_STUBS);
     protected Vibrator vibratorMock = mock(Vibrator.class);
 
     @Before
diff --git a/guice/blender/src/com/google/inject/blender/GuiceAnnotationProcessor.java b/guice/blender/src/com/google/inject/blender/GuiceAnnotationProcessor.java
index 4f8e461eb..c1658e4d5 100644
--- a/guice/blender/src/com/google/inject/blender/GuiceAnnotationProcessor.java
+++ b/guice/blender/src/com/google/inject/blender/GuiceAnnotationProcessor.java
@@ -76,7 +76,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
         // Not sure why, but sometimes we're getting called with an empty list of annotations.
         if(annotations.isEmpty())
-            return true;
+            return false;
 
         for( TypeElement annotation : annotations ) {
             String annotationClassName = getTypeName(annotation);
@@ -123,10 +123,10 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
             annotationDatabaseGenerator.generateAnnotationDatabase(jfo);
         } catch (IOException e) {
             e.printStackTrace();
-            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());
+            //processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());
         }
 
-        return true;
+        return false;
     }
 
     protected AnnotationDatabaseGenerator createAnnotationDatabaseGenerator() {
diff --git a/guice/core/pom.xml b/guice/core/pom.xml
index f1accb26d..76c7eb6be 100644
--- a/guice/core/pom.xml
+++ b/guice/core/pom.xml
@@ -14,6 +14,11 @@
   <name>Google Guice - Core Library</name>
 
   <dependencies>
+    <dependency>
+      <groupId>org.reflection_no_reflection</groupId>
+      <artifactId>generator</artifactId>
+      <version>1.0.0-SNAPSHOT</version>
+    </dependency>
     <dependency>
       <groupId>javax.inject</groupId>
       <artifactId>javax.inject</artifactId>
diff --git a/guice/core/src/com/google/inject/internal/SingleFieldInjector.java b/guice/core/src/com/google/inject/internal/SingleFieldInjector.java
index 52be1f45b..9f16f134f 100644
--- a/guice/core/src/com/google/inject/internal/SingleFieldInjector.java
+++ b/guice/core/src/com/google/inject/internal/SingleFieldInjector.java
@@ -21,6 +21,9 @@
 import com.google.inject.spi.InjectionPoint;
 
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import org.reflection_no_reflection.runtime.BaseReflector;
 
 /**
  * Sets an injectable field.
@@ -52,7 +55,16 @@ public void inject(Errors errors, InternalContext context, Object o) {
     Dependency previous = context.pushDependency(dependency, binding.getSource());
     try {
       Object value = binding.getInternalFactory().get(errors, context, dependency, false);
-      field.set(o, value);
+        BaseReflector reflector = injectionPoint.getReflector();
+        if(reflector!=null) {
+            if (!field.getType().isPrimitive()) {
+                reflector.setObjectField(o, field.getName(), value);
+            }
+            System.out.println("field set via reflector");
+        } else {
+            System.out.println("falling back on reflection");
+            field.set(o, value);
+        }
     } catch (ErrorsException e) {
       errors.withSource(injectionPoint).merge(e.getErrors());
     } catch (IllegalAccessException e) {
diff --git a/guice/core/src/com/google/inject/spi/InjectionPoint.java b/guice/core/src/com/google/inject/spi/InjectionPoint.java
index 7361d99ba..36d3892b0 100644
--- a/guice/core/src/com/google/inject/spi/InjectionPoint.java
+++ b/guice/core/src/com/google/inject/spi/InjectionPoint.java
@@ -50,6 +50,7 @@
 import com.google.inject.internal.ErrorsException;
 import com.google.inject.internal.Nullability;
 import com.google.inject.internal.util.Classes;
+import org.reflection_no_reflection.runtime.BaseReflector;
 
 /**
  * A constructor, field or method that can receive injections. Typically this is a member with the
@@ -68,27 +69,31 @@
     private final Member member;
     private final TypeLiteral<?> declaringType;
     private final ImmutableList<Dependency<?>> dependencies;
+    private final BaseReflector reflector;
 
 
-    InjectionPoint(TypeLiteral<?> declaringType, Method method, boolean optional) {
+    InjectionPoint(TypeLiteral<?> declaringType, Method method, boolean optional, BaseReflector reflector) {
         member = method;
         this.declaringType = declaringType;
         this.optional = optional;
         dependencies = forMember(method, declaringType, method.getParameterAnnotations());
+        this.reflector = reflector;
     }
 
-    InjectionPoint(TypeLiteral<?> declaringType, Constructor<?> constructor) {
+    InjectionPoint(TypeLiteral<?> declaringType, Constructor<?> constructor, BaseReflector reflector) {
         member = constructor;
         this.declaringType = declaringType;
         optional = false;
         dependencies = forMember(
                 constructor, declaringType, constructor.getParameterAnnotations());
+        this.reflector = reflector;
     }
 
-    InjectionPoint(TypeLiteral<?> declaringType, Field field, boolean optional) {
+    InjectionPoint(TypeLiteral<?> declaringType, Field field, boolean optional, BaseReflector reflector) {
         member = field;
         this.declaringType = declaringType;
         this.optional = optional;
+        this.reflector = reflector;
 
         Annotation[] annotations = field.getAnnotations();
 
@@ -107,6 +112,7 @@
                 newDependency(key, Nullability.allowsNull(annotations), -1));
     }
 
+
     private ImmutableList<Dependency<?>> forMember(Member member, TypeLiteral<?> type,
             Annotation[][] paramterAnnotations) {
         Errors errors = new Errors(member);
@@ -210,7 +216,20 @@ public boolean isToolable() {
      * @since 3.0
      */
     public static <T> InjectionPoint forConstructor(Constructor<T> constructor) {
-        return new InjectionPoint(TypeLiteral.get(constructor.getDeclaringClass()), constructor);
+        TypeLiteral<T> declaringType = TypeLiteral.get(constructor.getDeclaringClass());
+        return new InjectionPoint(declaringType, constructor, initReflector(declaringType));
+    }
+
+    private static BaseReflector initReflector(TypeLiteral<?> declaringType) {
+        try {
+            Class c = declaringType.getRawType();
+            Class reflectorClass = Class.forName(c.getName()+"$$Reflector");
+            return (BaseReflector) reflectorClass.newInstance();
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.out.println("Reflector could not be created for type " + declaringType);
+            return null;
+        }
     }
 
     /**
@@ -229,7 +248,7 @@ public boolean isToolable() {
             .throwConfigurationExceptionIfErrorsExist();
         }
 
-        return new InjectionPoint(type, constructor);
+        return new InjectionPoint(type, constructor,initReflector(type));
     }
 
     /**
@@ -277,7 +296,7 @@ public static InjectionPoint forConstructorOf(TypeLiteral<?> type) {
         errors.throwConfigurationExceptionIfErrorsExist();
 
         if (injectableConstructor != null) {
-            return new InjectionPoint(type, injectableConstructor);
+            return new InjectionPoint(type, injectableConstructor, initReflector(type));
         }
 
         // If no annotated constructor is found, look for a no-arg constructor instead.
@@ -292,7 +311,7 @@ public static InjectionPoint forConstructorOf(TypeLiteral<?> type) {
             }
 
             checkForMisplacedBindingAnnotations(noArgConstructor, errors);
-            return new InjectionPoint(type, noArgConstructor);
+            return new InjectionPoint(type, noArgConstructor, initReflector(type));
         } catch (NoSuchMethodException e) {
             errors.missingConstructor(rawType);
             throw new ConfigurationException(errors.getMessages());
@@ -416,6 +435,10 @@ private static boolean checkForMisplacedBindingAnnotations(Member member, Errors
         return true;
     }
 
+    public BaseReflector getReflector() {
+        return reflector;
+    }
+
     /**
      * Node in the doubly-linked list of injectable members (fields and methods).
      */
@@ -425,10 +448,12 @@ private static boolean checkForMisplacedBindingAnnotations(Member member, Errors
         final boolean jsr330;
         InjectableMember previous;
         InjectableMember next;
+        final BaseReflector reflector;
 
 
-        InjectableMember(TypeLiteral<?> declaringType, Annotation atInject) {
+        InjectableMember(TypeLiteral<?> declaringType, Annotation atInject, BaseReflector reflector) {
             this.declaringType = declaringType;
+            this.reflector = reflector;
 
             if (atInject.annotationType() == javax.inject.Inject.class) {
                 optional = false;
@@ -446,14 +471,14 @@ private static boolean checkForMisplacedBindingAnnotations(Member member, Errors
     static class InjectableField extends InjectableMember {
         final Field field;
         InjectableField(TypeLiteral<?> declaringType, Field field,
-                Annotation atInject) {
-            super(declaringType, atInject);
+                Annotation atInject, BaseReflector reflector) {
+            super(declaringType, atInject, reflector);
             this.field = field;
         }
 
         @Override
         InjectionPoint toInjectionPoint() {
-            return new InjectionPoint(declaringType, field, optional);
+            return new InjectionPoint(declaringType, field, optional, initReflector(declaringType));
         }
     }
 
@@ -466,14 +491,14 @@ InjectionPoint toInjectionPoint() {
          */
         boolean overrodeGuiceInject;
         InjectableMethod(TypeLiteral<?> declaringType, Method method,
-                Annotation atInject) {
-            super(declaringType, atInject);
+                Annotation atInject, BaseReflector reflector) {
+            super(declaringType, atInject, reflector);
             this.method = method;
         }
 
         @Override
         InjectionPoint toInjectionPoint() {
-            return new InjectionPoint(declaringType, method, optional);
+            return new InjectionPoint(declaringType, method, optional, reflector);
         }
 
         public boolean isFinal() {
@@ -730,6 +755,7 @@ private static void computeInjectableMembers(final TypeLiteral<?> type,
         }
 
         Set<Field> allFields = filter.getAllFields(Inject.class.getName(), rawType);
+        BaseReflector reflector = initReflector(type);
         if( allFields != null ) {
         	for( Field field : allFields ) {
         		//System.out.printf("Field %s is injectable in class %s ",field.getName(),rawType.getName());
@@ -737,7 +763,7 @@ private static void computeInjectableMembers(final TypeLiteral<?> type,
         			Annotation atInject = getAtInject(field);
         			if (atInject != null) {
         				//System.out.printf("Field %s is gonna be injected in class %s ",field.getName(),rawType.getName());
-        				InjectableField injectableField = new InjectableField(type, field, atInject);
+        				InjectableField injectableField = new InjectableField(type, field, atInject, reflector);
         				if (injectableField.jsr330 && Modifier.isFinal(field.getModifiers())) {
         					errors.cannotInjectFinalField(field);
         				}
@@ -754,7 +780,7 @@ private static void computeInjectableMembers(final TypeLiteral<?> type,
                     Annotation atInject = getAtInject(method);
                     if (atInject != null) {
                         InjectableMethod injectableMethod = new InjectableMethod(
-                                type, method, atInject);
+                                type, method, atInject, reflector);
                         if (checkForMisplacedBindingAnnotations(method, errors)
                                 || !isValidMethod(injectableMethod, errors)) {
                         	boolean removed = overrideIndex.removeIfOverriddenBy(method, false, injectableMethod);
diff --git a/guice/core/test/com/google/inject/spi/InjectionPointTest.java b/guice/core/test/com/google/inject/spi/InjectionPointTest.java
index 9a98de383..0a188fa3a 100644
--- a/guice/core/test/com/google/inject/spi/InjectionPointTest.java
+++ b/guice/core/test/com/google/inject/spi/InjectionPointTest.java
@@ -60,11 +60,11 @@ public void testFieldInjectionPoint() throws NoSuchFieldException, IOException,
     TypeLiteral<?> typeLiteral = TypeLiteral.get(getClass());
     Field fooField = getClass().getField("foo");
 
-    InjectionPoint injectionPoint = new InjectionPoint(typeLiteral, fooField, false);
+    InjectionPoint injectionPoint = new InjectionPoint(typeLiteral, fooField, false, null);
     assertSame(fooField, injectionPoint.getMember());
     assertFalse(injectionPoint.isOptional());
     assertEquals(getClass().getName() + ".foo", injectionPoint.toString());
-    assertEqualsBothWays(injectionPoint, new InjectionPoint(typeLiteral, fooField, false));
+    assertEqualsBothWays(injectionPoint, new InjectionPoint(typeLiteral, fooField, false, null));
     assertNotSerializable(injectionPoint);
 
     Dependency<?> dependency = getOnlyElement(injectionPoint.getDependencies());
@@ -76,18 +76,18 @@ public void testFieldInjectionPoint() throws NoSuchFieldException, IOException,
     assertFalse(dependency.isNullable());
     assertNotSerializable(dependency);
     assertEqualsBothWays(dependency,
-        getOnlyElement(new InjectionPoint(typeLiteral, fooField, false).getDependencies()));
+        getOnlyElement(new InjectionPoint(typeLiteral, fooField, false, null).getDependencies()));
   }
 
   public void testMethodInjectionPoint() throws Exception {
     TypeLiteral<?> typeLiteral = TypeLiteral.get(getClass());
 
     Method barMethod = getClass().getMethod("bar", String.class);
-    InjectionPoint injectionPoint = new InjectionPoint(typeLiteral, barMethod, false);
+    InjectionPoint injectionPoint = new InjectionPoint(typeLiteral, barMethod, false, null);
     assertSame(barMethod, injectionPoint.getMember());
     assertFalse(injectionPoint.isOptional());
     assertEquals(getClass().getName() + ".bar()", injectionPoint.toString());
-    assertEqualsBothWays(injectionPoint, new InjectionPoint(typeLiteral, barMethod, false));
+    assertEqualsBothWays(injectionPoint, new InjectionPoint(typeLiteral, barMethod, false, null));
     assertNotSerializable(injectionPoint);
 
     Dependency<?> dependency = getOnlyElement(injectionPoint.getDependencies());
@@ -99,7 +99,7 @@ public void testMethodInjectionPoint() throws Exception {
     assertFalse(dependency.isNullable());
     assertNotSerializable(dependency);
     assertEqualsBothWays(dependency,
-        getOnlyElement(new InjectionPoint(typeLiteral, barMethod, false).getDependencies()));
+        getOnlyElement(new InjectionPoint(typeLiteral, barMethod, false, null).getDependencies()));
   }
 
   public void testConstructorInjectionPoint() throws NoSuchMethodException, IOException,
@@ -107,11 +107,11 @@ public void testConstructorInjectionPoint() throws NoSuchMethodException, IOExce
     TypeLiteral<?> typeLiteral = TypeLiteral.get(Constructable.class);
 
     Constructor<?> constructor = Constructable.class.getConstructor(String.class);
-    InjectionPoint injectionPoint = new InjectionPoint(typeLiteral, constructor);
+    InjectionPoint injectionPoint = new InjectionPoint(typeLiteral, constructor, null);
     assertSame(constructor, injectionPoint.getMember());
     assertFalse(injectionPoint.isOptional());
     assertEquals(Constructable.class.getName() + ".<init>()", injectionPoint.toString());
-    assertEqualsBothWays(injectionPoint, new InjectionPoint(typeLiteral, constructor));
+    assertEqualsBothWays(injectionPoint, new InjectionPoint(typeLiteral, constructor, null));
     assertNotSerializable(injectionPoint);
 
     Dependency<?> dependency = getOnlyElement(injectionPoint.getDependencies());
@@ -123,7 +123,7 @@ public void testConstructorInjectionPoint() throws NoSuchMethodException, IOExce
     assertFalse(dependency.isNullable());
     assertNotSerializable(dependency);
     assertEqualsBothWays(dependency,
-        getOnlyElement(new InjectionPoint(typeLiteral, constructor).getDependencies()));
+        getOnlyElement(new InjectionPoint(typeLiteral, constructor, null).getDependencies()));
   }
 
   public void testUnattachedDependency() throws IOException {
@@ -175,8 +175,8 @@ public void testAddForInstanceMethodsAndFields() throws Exception {
 
     TypeLiteral<HasInjections> type = TypeLiteral.get(HasInjections.class);
     assertEquals(ImmutableSet.of(
-        new InjectionPoint(type, instanceMethod, false),
-        new InjectionPoint(type, instanceField, false)),
+        new InjectionPoint(type, instanceMethod, false, null),
+        new InjectionPoint(type, instanceField, false, null)),
         InjectionPoint.forInstanceMethodsAndFields(HasInjections.class));
   }
 
@@ -187,8 +187,8 @@ public void testAddForStaticMethodsAndFields() throws Exception {
     Set<InjectionPoint> injectionPoints = InjectionPoint.forStaticMethodsAndFields(
         HasInjections.class);
     assertEquals(ImmutableSet.of(
-        new InjectionPoint(TypeLiteral.get(HasInjections.class), staticMethod, false),
-        new InjectionPoint(TypeLiteral.get(HasInjections.class), staticField, false)),
+        new InjectionPoint(TypeLiteral.get(HasInjections.class), staticMethod, false, null),
+        new InjectionPoint(TypeLiteral.get(HasInjections.class), staticField, false, null)),
         injectionPoints);
   }
 
diff --git a/pom.xml b/pom.xml
index cf8fc1137..046762b88 100644
--- a/pom.xml
+++ b/pom.xml
@@ -33,7 +33,7 @@
 
 	<properties>
 		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-		<java.version>1.6</java.version>
+		<java.version>1.7</java.version>
 
 		<!-- PLUGINS -->
 		<android-maven-plugin.version>3.8.2</android-maven-plugin.version>
@@ -334,7 +334,7 @@
 				<module>roboblender</module>
 				<module>roboguice</module>
 				<module>additional-tests</module>
-				<!-- <module>astroboy</module> -->
+				<module>astroboy</module>
 			</modules>
 		</profile>
 	</profiles>
diff --git a/roboblender/src/main/java/roboguice/roboblender/ReflectorAnnotationProcessor.java b/roboblender/src/main/java/roboguice/roboblender/ReflectorAnnotationProcessor.java
new file mode 100644
index 000000000..5ed58b2a6
--- /dev/null
+++ b/roboblender/src/main/java/roboguice/roboblender/ReflectorAnnotationProcessor.java
@@ -0,0 +1,40 @@
+package roboguice.roboblender;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+import javax.annotation.processing.Completion;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+
+public class ReflectorAnnotationProcessor implements Processor {
+    @Override public Set<String> getSupportedOptions() {
+        return new HashSet<String>();
+    }
+
+    @Override public Set<String> getSupportedAnnotationTypes() {
+        return new HashSet<String>(Arrays.asList("com.google.inject.Inject", "javax.inject.Inject"));
+    }
+
+    @Override public SourceVersion getSupportedSourceVersion() {
+        return SourceVersion.latestSupported().latest();
+    }
+
+    @Override public void init(ProcessingEnvironment processingEnv) {
+        System.out.println("Inside Reflector");
+    }
+
+    @Override public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+        return false;
+    }
+
+    @Override public Iterable<? extends Completion> getCompletions(Element element, AnnotationMirror annotation, ExecutableElement member, String userText) {
+        return null;
+    }
+}
