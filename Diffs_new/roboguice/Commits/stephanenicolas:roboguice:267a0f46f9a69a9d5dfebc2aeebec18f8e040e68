diff --git a/astroboy/default.properties b/astroboy/default.properties
deleted file mode 100644
index 423f744df..000000000
--- a/astroboy/default.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-# File used by Eclipse to determine the target system
-# Project target.
-target=android-9
\ No newline at end of file
diff --git a/astroboy/project.properties b/astroboy/project.properties
new file mode 100644
index 000000000..a3ee5ab64
--- /dev/null
+++ b/astroboy/project.properties
@@ -0,0 +1,14 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-17
diff --git a/astroboy/src/main/java/org/roboguice/astroboy/activity/AstroboyMasterConsole.java b/astroboy/src/main/java/org/roboguice/astroboy/activity/AstroboyMasterConsole.java
index 3e49b9b42..bffbd6750 100644
--- a/astroboy/src/main/java/org/roboguice/astroboy/activity/AstroboyMasterConsole.java
+++ b/astroboy/src/main/java/org/roboguice/astroboy/activity/AstroboyMasterConsole.java
@@ -140,6 +140,7 @@ private void detachFightForcesOfEvilFragment() {
         Fragment fightForcesOfEvilFragment = getSupportFragmentManager().findFragmentByTag(FIGHT_FORCES_OF_EVIL_FRAGMENT_TAG);
         if (fightForcesOfEvilFragment != null) {
             FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
+            ft.hide(fightForcesOfEvilFragment);
             ft.remove(fightForcesOfEvilFragment);
             ft.commit();
         }
diff --git a/astroboy/src/main/java/org/roboguice/astroboy/fragment/FightForcesOfEvilFragment.java b/astroboy/src/main/java/org/roboguice/astroboy/fragment/FightForcesOfEvilFragment.java
index 7ef845242..0887afcd6 100644
--- a/astroboy/src/main/java/org/roboguice/astroboy/fragment/FightForcesOfEvilFragment.java
+++ b/astroboy/src/main/java/org/roboguice/astroboy/fragment/FightForcesOfEvilFragment.java
@@ -77,15 +77,21 @@ protected void onSuccess(String expletive) throws Exception {
 
             }.execute();
         }
+    }
 
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        eventManager.unregisterObserver(this, AstroSpeechEvent.class);
     }
 
-    public void handleAstroSpeechEvent(final @Observes AstroSpeechEvent event) {
+    public void handleAstroSpeechEvent(final @Observes(stickyEventsCount = 2) AstroSpeechEvent event) {
         handler.postDelayed(new Runnable() {
             public void run() {
                 expletiveText.setText(event.getMessage());
+                System.out.println(event.getMessage());
             }
-        }, 10000);
+        }, 5000);
     }
 
     // This class will call Astroboy.punch() in the background
@@ -106,7 +112,7 @@ public AsyncPunch(Context context) {
 
         public String call() throws Exception {
             // we are sure to see each explective at least one second
-            Thread.sleep(random.nextInt(2 * 1000));
+            Thread.sleep(200 + random.nextInt(500));
             return astroboy.punch();
         }
     }
diff --git a/roboguice/src/main/java/roboguice/event/EventManager.java b/roboguice/src/main/java/roboguice/event/EventManager.java
index 5a43d72c1..fece57d80 100644
--- a/roboguice/src/main/java/roboguice/event/EventManager.java
+++ b/roboguice/src/main/java/roboguice/event/EventManager.java
@@ -1,10 +1,13 @@
 package roboguice.event;
 
 import java.lang.reflect.Method;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.ListIterator;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -34,7 +37,7 @@
     protected Map<Class<?>, Set<EventListener<?>>> registrations = new HashMap<Class<?>, Set<EventListener<?>>>(); // synchronized
     // set
     protected Map<Class<?>, EventProducer<?>> productions = new HashMap<Class<?>, EventProducer<?>>(); // synchronized
-    protected Map<Class<?>, Object> stickyEvents = new HashMap<Class<?>, Object>(); // synchronized
+    protected Map<Class<?>, List<Object>> stickyEvents = new HashMap<Class<?>, List<Object>>(); // synchronized
 
     // set
 
@@ -48,7 +51,7 @@
      * @param <T>
      *            event type
      */
-    public <T> void registerObserver(final Class<T> event, final EventListener listener) {
+    public <T> void registerObserver(final Class<T> event, final EventListener listener, int stickyEventsCountRequested) {
         Set<EventListener<?>> observers = registrations.get(event);
         if (observers == null) {
             observers = Collections.synchronizedSet(new LinkedHashSet<EventListener<?>>());
@@ -56,29 +59,33 @@
         }
 
         if (stickyEvents.get(event) != null) {
-            // we post a message that will be executed asap bu the main thread
-            // of this event manager's context
-            new Handler(context.getMainLooper()).post(new Runnable() {
-                @Override
-                public void run() {
-                    listener.onEvent(stickyEvents.get(event));
-                }
-            });
+            boolean allEvents = stickyEventsCountRequested == Observes.ALL_EVENTS;
+            List<Object> eventsList = stickyEvents.get(event);
+            int stickyEventsToTriggerCount = allEvents ? 0 : Math.max(0, eventsList.size() - stickyEventsCountRequested);
+            ListIterator<Object> listIterator = eventsList.listIterator(stickyEventsToTriggerCount);
+            while (listIterator.hasNext()) {
+                fireStickyEvent(listIterator.next(), listener);
+                System.out.println(event);
+            }
         } else if (productions.get(event) != null) {
-            // we post a message that will be executed asap bu the main thread
-            // of this event manager's context
-            new Handler(context.getMainLooper()).post(new Runnable() {
-                @Override
-                public void run() {
-                    listener.onEvent(productions.get(event).onEventRequested());
-                }
-            });
+            fireStickyEvent(productions.get(event).onEventRequested(), listener);
         }
 
         observers.add(listener);
 
     }
 
+    private <T> void fireStickyEvent(final Object event, final EventListener listener) {
+        // we post a message that will be executed asap bu the main thread
+        // of this event manager's context
+        new Handler(context.getMainLooper()).post(new Runnable() {
+            @Override
+            public void run() {
+                listener.onEvent(event);
+            }
+        });
+    }
+
     /**
      * Registers given method with provided context and event.
      * 
@@ -89,8 +96,8 @@ public void run() {
      * @param event
      *            observed
      */
-    public <T> void registerObserver(Object instance, Method method, Class<T> event) {
-        registerObserver(event, new ObserverMethodListener<T>(instance, method));
+    public <T> void registerObserver(Object instance, Method method, Class<T> event, int stickyEventsCount) {
+        registerObserver(event, new ObserverMethodListener<T>(instance, method), stickyEventsCount);
     }
 
     /**
@@ -175,6 +182,14 @@ public void run() {
         }
     }
 
+    public <T> void unregisterProducer(Class<T> event) {
+        productions.remove(event);
+    }
+
+    public <T> void clearStickyEvents(Class<T> event) {
+        stickyEvents.remove(event);
+    }
+
     /**
      * Raises the event's class' event on the given context. This event object
      * is passed (if configured) to the registered observer's method.
@@ -185,6 +200,16 @@ public void run() {
     public void fire(Object event) {
 
         final Set<EventListener<?>> observers = registrations.get(event.getClass());
+
+        if (event.getClass().isAnnotationPresent(StickyEvent.class)) {
+            List<Object> stickyEventsList = stickyEvents.get(event.getClass());
+            if (stickyEventsList == null) {
+                stickyEventsList = new ArrayList<Object>();
+                stickyEvents.put(event.getClass(), stickyEventsList);
+            }
+            stickyEventsList.add(event);
+        }
+
         if (observers == null) {
             return;
         }
@@ -198,10 +223,6 @@ public void fire(Object event) {
             }
         }
 
-        if (event.getClass().isAnnotationPresent(StickyEvent.class)) {
-            stickyEvents.put(event.getClass(), event);
-        }
-
     }
 
     public void destroy() {
@@ -210,6 +231,11 @@ public void destroy() {
         }
         registrations.clear();
         productions.clear();
+
+        for (Entry<Class<?>, List<Object>> e : stickyEvents.entrySet()) {
+            e.getValue().clear();
+        }
+        stickyEvents.clear();
     }
 
 }
diff --git a/roboguice/src/main/java/roboguice/event/Observes.java b/roboguice/src/main/java/roboguice/event/Observes.java
index f64e82e36..2a0971dfb 100644
--- a/roboguice/src/main/java/roboguice/event/Observes.java
+++ b/roboguice/src/main/java/roboguice/event/Observes.java
@@ -1,35 +1,42 @@
 package roboguice.event;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
- * Parameter annotation to bind a given method and parameter to an event raised through the
- * EventManager.fire() method.
- *
- * Please note that a runtime exception will be thrown if more than one parameter is annotated or more than one parameter
- * exists in the method definition.
- *
+ * Parameter annotation to bind a given method and parameter to an event raised
+ * through the EventManager.fire() method.
+ * 
+ * Please note that a runtime exception will be thrown if more than one
+ * parameter is annotated or more than one parameter exists in the method
+ * definition.
+ * 
  * Example of proper use:
- *
- * ContextEvent<EventParameter> event = new ContextEvent<EventParameter>(EventParameter.class, new EventParameter("data"));
- *
+ * 
+ * ContextEvent<EventParameter> event = new
+ * ContextEvent<EventParameter>(EventParameter.class, new
+ * EventParameter("data"));
+ * 
  * eventManager.fire(context, event);
- *
+ * 
  * triggers:
- *
- * public void handleEvent(@Observes EventParameter event){
- *     String data = event.getData() // "data"
- * }
- *
+ * 
+ * public void handleEvent(@Observes EventParameter event){ String data =
+ * event.getData() // "data" }
+ * 
  * @author Adam Tybor
  * @author John Ericksen
  */
 @Retention(RUNTIME)
-@Target( { ElementType.PARAMETER })
+@Target({ ElementType.PARAMETER })
 public @interface Observes {
+    int ALL_EVENTS = -1;
+    int NO_EVENTS = 0;
+
     EventThread value() default EventThread.CURRENT;
+
+    int stickyEventsCount() default 1;
 }
diff --git a/roboguice/src/main/java/roboguice/event/ObservesTypeListener.java b/roboguice/src/main/java/roboguice/event/ObservesTypeListener.java
index d576c47b2..31a98a8a4 100644
--- a/roboguice/src/main/java/roboguice/event/ObservesTypeListener.java
+++ b/roboguice/src/main/java/roboguice/event/ObservesTypeListener.java
@@ -1,5 +1,8 @@
 package roboguice.event;
 
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+
 import roboguice.event.eventListener.ObserverMethodListener;
 import roboguice.event.eventListener.factory.EventListenerThreadingDecorator;
 
@@ -9,13 +12,10 @@
 import com.google.inject.spi.TypeEncounter;
 import com.google.inject.spi.TypeListener;
 
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-
 /**
  * Guice driven type listener which scans for the @Observes annotations.
  * Registers these methods with the EventManager.
- *
+ * 
  * @author Adam Tybor
  * @author John Ericksen
  */
@@ -28,60 +28,68 @@ public ObservesTypeListener(Provider<EventManager> eventManagerProvider, EventLi
         this.observerThreadingDecorator = observerThreadingDecorator;
     }
 
+    @Override
     public <I> void hear(TypeLiteral<I> iTypeLiteral, TypeEncounter<I> iTypeEncounter) {
-        for( Class<?> c = iTypeLiteral.getRawType(); c!=Object.class ; c = c.getSuperclass() ) {
-            for (Method method : c.getDeclaredMethods())
+        for (Class<?> c = iTypeLiteral.getRawType(); c != Object.class; c = c.getSuperclass()) {
+            for (Method method : c.getDeclaredMethods()) {
                 findContextObserver(method, iTypeEncounter);
+            }
 
-            for( Class<?> interfaceClass : c.getInterfaces())
-                for (Method method : interfaceClass.getDeclaredMethods())
+            for (Class<?> interfaceClass : c.getInterfaces()) {
+                for (Method method : interfaceClass.getDeclaredMethods()) {
                     findContextObserver(method, iTypeEncounter);
+                }
+            }
 
-            
         }
     }
 
     protected <I> void findContextObserver(Method method, TypeEncounter<I> iTypeEncounter) {
         final Annotation[][] parameterAnnotations = method.getParameterAnnotations();
-        for(int i = 0; i < parameterAnnotations.length; i++){
+        for (int i = 0; i < parameterAnnotations.length; i++) {
             final Annotation[] annotationArray = parameterAnnotations[i];
             final Class<?>[] parameterTypes = method.getParameterTypes();
             final Class<?> parameterType = parameterTypes[i];
 
-            for(Annotation annotation : annotationArray)
-                if(annotation.annotationType().equals(Observes.class))
-                    registerContextObserver(iTypeEncounter, method, parameterType, ((Observes)annotation).value());
+            for (Annotation annotation : annotationArray) {
+                if (annotation.annotationType().equals(Observes.class)) {
+                    registerContextObserver(iTypeEncounter, method, parameterType, ((Observes) annotation).value(), ((Observes) annotation).stickyEventsCount());
+                }
+            }
         }
     }
 
     /**
      * Error checks the observed method and registers method with typeEncounter
-     *
+     * 
      * @param iTypeEncounter
      * @param method
      * @param parameterType
      * @param threadType
      * @param <I, T>
      */
-    protected <I, T> void registerContextObserver(TypeEncounter<I> iTypeEncounter, Method method, Class<T> parameterType, EventThread threadType) {
+    protected <I, T> void registerContextObserver(TypeEncounter<I> iTypeEncounter, Method method, Class<T> parameterType, EventThread threadType,
+            int stickyEventsCount) {
         checkMethodParameters(method);
-        iTypeEncounter.register(new ContextObserverMethodInjector<I, T>(eventManagerProvider, observerThreadingDecorator, method, parameterType,threadType));
+        iTypeEncounter.register(new ContextObserverMethodInjector<I, T>(eventManagerProvider, observerThreadingDecorator, method, parameterType, threadType,
+                stickyEventsCount));
     }
 
     /**
-     * Error checking method, verifies that the method has the correct number of parameters.
-     *
+     * Error checking method, verifies that the method has the correct number of
+     * parameters.
+     * 
      * @param method
      */
     protected void checkMethodParameters(Method method) {
-        if(method.getParameterTypes().length > 1)
-            throw new RuntimeException("Annotation @Observes must only annotate one parameter," +
-                    " which must be the only parameter in the listener method.");
+        if (method.getParameterTypes().length > 1) {
+            throw new RuntimeException("Annotation @Observes must only annotate one parameter," + " which must be the only parameter in the listener method.");
+        }
     }
 
     /**
      * Injection listener to handle the observation manager registration.
-     *
+     * 
      * @param <I>
      */
     public static class ContextObserverMethodInjector<I, T> implements InjectionListener<I> {
@@ -90,19 +98,22 @@ protected void checkMethodParameters(Method method) {
         protected Method method;
         protected Class<T> event;
         protected EventThread threadType;
+        protected int stickyEventsCount;
 
-        public ContextObserverMethodInjector(Provider<EventManager> eventManagerProvider,
-                                             EventListenerThreadingDecorator observerThreadingDecorator,  Method method,
-                                             Class<T> event, EventThread threadType) {
+        public ContextObserverMethodInjector(Provider<EventManager> eventManagerProvider, EventListenerThreadingDecorator observerThreadingDecorator,
+                Method method, Class<T> event, EventThread threadType, int stickyEventsCount) {
             this.observerThreadingDecorator = observerThreadingDecorator;
             this.eventManagerProvider = eventManagerProvider;
             this.method = method;
             this.event = event;
             this.threadType = threadType;
+            this.stickyEventsCount = stickyEventsCount;
         }
 
+        @Override
         public void afterInjection(I i) {
-            eventManagerProvider.get().registerObserver( event, observerThreadingDecorator.decorate(threadType, new ObserverMethodListener<T>(i, method)));
+            eventManagerProvider.get().registerObserver(event, observerThreadingDecorator.decorate(threadType, new ObserverMethodListener<T>(i, method)),
+                    stickyEventsCount);
         }
     }
 }
diff --git a/roboguice/src/test/java/roboguice/event/EventManagerTest.java b/roboguice/src/test/java/roboguice/event/EventManagerTest.java
index 0f5f5c89f..d4c7770b9 100644
--- a/roboguice/src/test/java/roboguice/event/EventManagerTest.java
+++ b/roboguice/src/test/java/roboguice/event/EventManagerTest.java
@@ -1,15 +1,16 @@
 package roboguice.event;
 
+import java.lang.reflect.Method;
+import java.util.List;
+
 import org.junit.Before;
 import org.junit.Test;
-import roboguice.event.eventListener.ObserverMethodListener;
 
-import java.lang.reflect.Method;
-import java.util.List;
+import roboguice.event.eventListener.ObserverMethodListener;
 
 /**
  * Test class verifying eventManager functionality
- *
+ * 
  * @author John Ericksen
  */
 public class EventManagerTest {
@@ -31,12 +32,12 @@ public void setup() throws NoSuchMethodException {
     }
 
     @Test
-    public void testRegistrationLifeCycle(){
-        for(Method method : eventOneMethods){
-            eventManager.registerObserver(EventOne.class, new ObserverMethodListener(tester, method));
+    public void testRegistrationLifeCycle() {
+        for (Method method : eventOneMethods) {
+            eventManager.registerObserver(EventOne.class, new ObserverMethodListener(tester, method), 1);
         }
-        for(Method method : eventTwoMethods){
-            eventManager.registerObserver(EventTwo.class, new ObserverMethodListener(tester, method));
+        for (Method method : eventTwoMethods) {
+            eventManager.registerObserver(EventTwo.class, new ObserverMethodListener(tester, method), 1);
         }
 
         eventManager.fire(event);
@@ -44,11 +45,11 @@ public void testRegistrationLifeCycle(){
         tester.verifyCallCount(eventOneMethods, EventOne.class, 1);
         tester.verifyCallCount(eventTwoMethods, EventTwo.class, 0);
 
-        //reset
+        // reset
         tester.reset();
 
         eventManager.unregisterObserver(tester, EventOne.class);
-        eventManager.unregisterObserver( tester, EventTwo.class);
+        eventManager.unregisterObserver(tester, EventTwo.class);
 
         eventManager.fire(event);
 
