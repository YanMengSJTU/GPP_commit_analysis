diff --git a/roboguice/src/main/java/roboguice/RoboGuice.java b/roboguice/src/main/java/roboguice/RoboGuice.java
index 24bf6a368..c7cbf88a0 100644
--- a/roboguice/src/main/java/roboguice/RoboGuice.java
+++ b/roboguice/src/main/java/roboguice/RoboGuice.java
@@ -29,7 +29,6 @@
  * 
  * BUG hashmap should also key off of stage and modules list
  */
-@SuppressWarnings({"ALL"})
 public class RoboGuice {
     public static Stage DEFAULT_STAGE = Stage.PRODUCTION;
 
diff --git a/roboguice/src/main/java/roboguice/config/DefaultRoboModule.java b/roboguice/src/main/java/roboguice/config/DefaultRoboModule.java
index 9cfb01c1e..c5a067ac3 100644
--- a/roboguice/src/main/java/roboguice/config/DefaultRoboModule.java
+++ b/roboguice/src/main/java/roboguice/config/DefaultRoboModule.java
@@ -56,10 +56,11 @@
  * @author Mike Burton
  */
 public class DefaultRoboModule extends AbstractModule {
-    protected static final Class accountManagerClass;
+    @SuppressWarnings("rawtypes")
+	protected static final Class accountManagerClass;
 
     static {
-        Class c = null;
+        Class<?> c = null;
         try {
             c = Class.forName("android.accounts.AccountManager");
         } catch( Throwable ignored ) {}
@@ -174,7 +175,12 @@ protected void configure() {
 
         requestStaticInjection(Ln.class);
 
-        // Compatibility library bindings
+        bindDynamicBindings();
+    }
+
+    @SuppressWarnings("unchecked")
+	private void bindDynamicBindings() {
+		// Compatibility library bindings
         if(FragmentUtil.hasSupport) {
             bind(FragmentUtil.supportFrag.fragmentManagerType()).toProvider(FragmentUtil.supportFrag.fragmentManagerProviderType());
         }
@@ -186,8 +192,6 @@ protected void configure() {
         if( VERSION.SDK_INT>=5 ) {
             bind(accountManagerClass).toProvider(AccountManagerProvider.class);
         }
-
-
-    }
+	}
 
 }
diff --git a/roboguice/src/main/java/roboguice/event/EventManager.java b/roboguice/src/main/java/roboguice/event/EventManager.java
index 99bfd1421..456dfe608 100644
--- a/roboguice/src/main/java/roboguice/event/EventManager.java
+++ b/roboguice/src/main/java/roboguice/event/EventManager.java
@@ -1,142 +1,142 @@
-package roboguice.event;
-
-import roboguice.event.eventListener.ObserverMethodListener;
-import roboguice.inject.ContextSingleton;
-
-import android.content.Context;
-
-import com.google.inject.Inject;
-
-import java.lang.reflect.Method;
-import java.util.*;
-import java.util.Map.Entry;
-
-/**
- * Manager class handling the following:
- *
- *   Registration of event observing methods:
- *      registerObserver()
- *      unregisterObserver()
- *      clear()
- *   Raising Events:
- *      fire()
- *      notifyWithResult()
- *
- * @author Adam Tybor
- * @author John Ericksen
- */
-@ContextSingleton
-public class EventManager {
-    @Inject protected Context context;
-
-    protected Map<Class<?>, Set<EventListener<?>>> registrations = new HashMap<Class<?>, Set<EventListener<?>>>(); // synchronized set
-
-    /**
-     * Register the given EventListener to the contest and event class.
-     *
-     * @param event observed
-     * @param listener to be triggered
-     * @param <T> event type
-     */
-    public <T> void registerObserver( Class<T> event, EventListener listener ) {
-        Set<EventListener<?>> observers = registrations.get(event);
-        if (observers == null) {
-            observers = Collections.synchronizedSet(new LinkedHashSet<EventListener<?>>());
-            registrations.put(event, observers);
-        }
-
-        observers.add(listener);
-
-    }
-
-    /**
-     * Registers given method with provided context and event.
-     *
-     * @param instance to be called
-     * @param method to be called
-     * @param event observed
-     */
-    public <T> void registerObserver(Object instance, Method method, Class<T> event) {
-        registerObserver(event, new ObserverMethodListener<T>(instance, method));
-    }
-
-    /**
-     * Unregisters the provided event listener from the given event
-     *
-     * @param event observed
-     * @param listener to be unregistered
-     * @param <T> event type
-     */
-    public <T> void unregisterObserver(Class<T> event, EventListener<T> listener ) {
-
-        final Set<EventListener<?>> observers = registrations.get(event);
-        if (observers == null) return;
-
-        // As documented in http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
-        //noinspection SynchronizationOnLocalVariableOrMethodParameter
-        synchronized (observers) {
-            for (Iterator<EventListener<?>> iterator = observers.iterator(); iterator.hasNext();) {
-                final EventListener registeredListener = iterator.next();
-                if (registeredListener == listener) {
-                    iterator.remove();
-                    break;
-                }
-            }
-        }
-    }
-
-    /**
-     * Unregister all methods observing the given event from the provided context.
-     *
-     * @param instance to be unregistered
-     * @param event observed
-     */
-    public <T> void unregisterObserver(Object instance, Class<T> event) {
-
-        final Set<EventListener<?>> observers = registrations.get(event);
-        if (observers == null) return;
-
-        // As documented in http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
-        //noinspection SynchronizationOnLocalVariableOrMethodParameter
-        synchronized (observers) {
-            for (Iterator<EventListener<?>> iterator = observers.iterator(); iterator.hasNext();) {
-                final EventListener listener = iterator.next();
-                if( listener instanceof ObserverMethodListener ) {
-                    final ObserverMethodListener observer = ((ObserverMethodListener)listener);
-                    if (observer.getInstance() == instance) {
-                        iterator.remove();
-                        break;
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * Raises the event's class' event on the given context.  This event object is passed (if configured) to the
-     * registered observer's method.
-     *
-     * @param event observed
-     */
-    public void fire(Object event) {
-
-        final Set<EventListener<?>> observers = registrations.get(event.getClass());
-        if (observers == null) return;
-
-        // As documented in http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
-        //noinspection SynchronizationOnLocalVariableOrMethodParameter
-        synchronized (observers) {
-            for (EventListener observer : observers)
-                observer.onEvent(event);
-        }
-
-    }
-    
-    
-    public void destroy() {
-        for( Entry<Class<?>, Set<EventListener<?>>> e : registrations.entrySet() )
-            e.getValue().clear();
-        registrations.clear();
-    }
-
-}
+package roboguice.event;
+
+import roboguice.event.eventListener.ObserverMethodListener;
+import roboguice.inject.ContextSingleton;
+
+import android.content.Context;
+
+import com.google.inject.Inject;
+
+import java.lang.reflect.Method;
+import java.util.*;
+import java.util.Map.Entry;
+
+/**
+ * Manager class handling the following:
+ *
+ *   Registration of event observing methods:
+ *      registerObserver()
+ *      unregisterObserver()
+ *      clear()
+ *   Raising Events:
+ *      fire()
+ *      notifyWithResult()
+ *
+ * @author Adam Tybor
+ * @author John Ericksen
+ */
+@ContextSingleton
+public class EventManager {
+    @Inject protected Context context;
+
+    protected Map<Class<?>, Set<EventListener<?>>> registrations = new HashMap<Class<?>, Set<EventListener<?>>>(); // synchronized set
+
+    /**
+     * Register the given EventListener to the contest and event class.
+     *
+     * @param event observed
+     * @param listener to be triggered
+     * @param <T> event type
+     */
+    public <T> void registerObserver( Class<T> event, EventListener<T> listener ) {
+        Set<EventListener<?>> observers = registrations.get(event);
+        if (observers == null) {
+            observers = Collections.synchronizedSet(new LinkedHashSet<EventListener<?>>());
+            registrations.put(event, observers);
+        }
+
+        observers.add(listener);
+
+    }
+
+    /**
+     * Registers given method with provided context and event.
+     *
+     * @param instance to be called
+     * @param method to be called
+     * @param event observed
+     */
+    public <T> void registerObserver(Object instance, Method method, Class<T> event) {
+        registerObserver(event, new ObserverMethodListener<T>(instance, method));
+    }
+
+    /**
+     * Unregisters the provided event listener from the given event
+     *
+     * @param event observed
+     * @param listener to be unregistered
+     * @param <T> event type
+     */
+    public <T> void unregisterObserver(Class<T> event, EventListener<T> listener ) {
+
+        final Set<EventListener<?>> observers = registrations.get(event);
+        if (observers == null) return;
+
+        // As documented in http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
+        //noinspection SynchronizationOnLocalVariableOrMethodParameter
+        synchronized (observers) {
+            for (Iterator<EventListener<?>> iterator = observers.iterator(); iterator.hasNext();) {
+                final EventListener<?> registeredListener = iterator.next();
+                if (registeredListener == listener) {
+                    iterator.remove();
+                    break;
+                }
+            }
+        }
+    }
+
+    /**
+     * Unregister all methods observing the given event from the provided context.
+     *
+     * @param instance to be unregistered
+     * @param event observed
+     */
+    public <T> void unregisterObserver(Object instance, Class<T> event) {
+
+        final Set<EventListener<?>> observers = registrations.get(event);
+        if (observers == null) return;
+
+        // As documented in http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
+        //noinspection SynchronizationOnLocalVariableOrMethodParameter
+        synchronized (observers) {
+            for (Iterator<EventListener<?>> iterator = observers.iterator(); iterator.hasNext();) {
+                final EventListener<?> listener = iterator.next();
+                if( listener instanceof ObserverMethodListener ) {
+                    final ObserverMethodListener<?> observer = ((ObserverMethodListener<?>)listener);
+                    if (observer.getInstance() == instance) {
+                        iterator.remove();
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Raises the event's class' event on the given context.  This event object is passed (if configured) to the
+     * registered observer's method.
+     *
+     * @param event observed
+     */
+    public void fire(Object event) {
+
+        final Set<EventListener<?>> observers = registrations.get(event.getClass());
+        if (observers == null) return;
+
+        // As documented in http://docs.oracle.com/javase/1.4.2/docs/api/java/util/Collections.html#synchronizedSet(java.util.Set)
+        //noinspection SynchronizationOnLocalVariableOrMethodParameter
+        synchronized (observers) {
+            for (EventListener observer : observers)
+                observer.onEvent(event);
+        }
+
+    }
+    
+    
+    public void destroy() {
+        for( Entry<Class<?>, Set<EventListener<?>>> e : registrations.entrySet() )
+            e.getValue().clear();
+        registrations.clear();
+    }
+
+}
diff --git a/roboguice/src/main/java/roboguice/event/eventListener/ObserverMethodListener.java b/roboguice/src/main/java/roboguice/event/eventListener/ObserverMethodListener.java
index f19a2a8ea..22c11e439 100644
--- a/roboguice/src/main/java/roboguice/event/eventListener/ObserverMethodListener.java
+++ b/roboguice/src/main/java/roboguice/event/eventListener/ObserverMethodListener.java
@@ -46,7 +46,7 @@ public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
 
-        ObserverMethodListener that = (ObserverMethodListener) o;
+        ObserverMethodListener<?> that = (ObserverMethodListener<?>) o;
 
         if (descriptor != null ? !descriptor.equals(that.descriptor) : that.descriptor != null) return false;
         return !(instance != null ? !instance.equals(that.instance) : that.instance != null);
diff --git a/roboguice/src/main/java/roboguice/event/eventListener/javaassist/RuntimeSupport.java b/roboguice/src/main/java/roboguice/event/eventListener/javaassist/RuntimeSupport.java
index 16738f86a..85f9289b9 100644
--- a/roboguice/src/main/java/roboguice/event/eventListener/javaassist/RuntimeSupport.java
+++ b/roboguice/src/main/java/roboguice/event/eventListener/javaassist/RuntimeSupport.java
@@ -29,7 +29,7 @@
      * Makes a descriptor for a given method.
      */
     public static String makeDescriptor(Method m) {
-        Class[] params = m.getParameterTypes();
+        Class<?>[] params = m.getParameterTypes();
         return makeDescriptor(params, m.getReturnType());
     }
 
@@ -39,7 +39,7 @@ public static String makeDescriptor(Method m) {
      * @param params    parameter types.
      * @param retType   return type.
      */
-    public static String makeDescriptor(Class[] params, Class retType) {
+    public static String makeDescriptor(Class<?>[] params, Class<?> retType) {
         StringBuffer sbuf = new StringBuffer();
         sbuf.append('(');
         for (int i = 0; i < params.length; i++)
@@ -52,7 +52,7 @@ public static String makeDescriptor(Class[] params, Class retType) {
         return sbuf.toString();
     }
 
-    private static void makeDesc(StringBuffer sbuf, Class type) {
+    private static void makeDesc(StringBuffer sbuf, Class<?> type) {
         if (type.isArray()) {
             sbuf.append('[');
             makeDesc(sbuf, type.getComponentType());
diff --git a/roboguice/src/main/java/roboguice/event/javaassist/RuntimeSupport.java b/roboguice/src/main/java/roboguice/event/javaassist/RuntimeSupport.java
index 8aa88f995..b2267bb4b 100644
--- a/roboguice/src/main/java/roboguice/event/javaassist/RuntimeSupport.java
+++ b/roboguice/src/main/java/roboguice/event/javaassist/RuntimeSupport.java
@@ -29,7 +29,7 @@
      * Makes a descriptor for a given method.
      */
     public static String makeDescriptor(Method m) {
-        Class[] params = m.getParameterTypes();
+        Class<?>[] params = m.getParameterTypes();
         return makeDescriptor(params, m.getReturnType());
     }
 
@@ -39,7 +39,7 @@ public static String makeDescriptor(Method m) {
      * @param params    parameter types.
      * @param retType   return type.
      */
-    public static String makeDescriptor(Class[] params, Class retType) {
+    public static String makeDescriptor(Class<?>[] params, Class<?> retType) {
         StringBuffer sbuf = new StringBuffer();
         sbuf.append('(');
         for (int i = 0; i < params.length; i++)
@@ -50,7 +50,7 @@ public static String makeDescriptor(Class[] params, Class retType) {
         return sbuf.toString();
     }
 
-    private static void makeDesc(StringBuffer sbuf, Class type) {
+    private static void makeDesc(StringBuffer sbuf, Class<?> type) {
         if (type.isArray()) {
             sbuf.append('[');
             makeDesc(sbuf, type.getComponentType());
diff --git a/roboguice/src/main/java/roboguice/fragment/FragmentUtil.java b/roboguice/src/main/java/roboguice/fragment/FragmentUtil.java
index d3e2276f5..95341bcf2 100644
--- a/roboguice/src/main/java/roboguice/fragment/FragmentUtil.java
+++ b/roboguice/src/main/java/roboguice/fragment/FragmentUtil.java
@@ -2,15 +2,17 @@
 
 import com.google.inject.Provider;
 
+import android.app.Activity;
 import android.view.View;
 
+@SuppressWarnings({ "unchecked", "rawtypes" }) //Need an unchecked conversion 
 public class FragmentUtil {
     public static final String SUPPORT_PACKAGE = "android.support.v4.app.";
     public static final String NATIVE_PACKAGE = "android.app.";
     
     public static f nativeFrag = null;
     public static f supportFrag = null;
-    public static Class supportActivity = null;
+    public static Class<? extends Activity> supportActivity = null;
     public static boolean hasNative = false;
     public static boolean hasSupport = false;
     
@@ -18,8 +20,8 @@
         public View getView(fragType frag);
         public fragType findFragmentById(fragManagerType fm, int id);
         public fragType findFragmentByTag(fragManagerType fm, String tag);
-        public Class fragmentType();
-        public Class fragmentManagerType();
+        public Class<fragType> fragmentType();
+        public Class<fragManagerType> fragmentManagerType();
         public Class<Provider<fragManagerType>> fragmentManagerProviderType();
     }
     
@@ -32,7 +34,7 @@
         
         try {
             supportFrag = (f) Class.forName("roboguice.fragment.support.SupportFragmentUtil").newInstance();
-            supportActivity = Class.forName(SUPPORT_PACKAGE+"FragmentActivity");
+            supportActivity = (Class<? extends Activity>) Class.forName(SUPPORT_PACKAGE+"FragmentActivity");
             hasSupport = supportFrag != null && supportActivity != null;
         } catch (Throwable e) {}
         
diff --git a/roboguice/src/main/java/roboguice/fragment/provided/NativeFragmentUtil.java b/roboguice/src/main/java/roboguice/fragment/provided/NativeFragmentUtil.java
index 19119f21c..8dc8db687 100644
--- a/roboguice/src/main/java/roboguice/fragment/provided/NativeFragmentUtil.java
+++ b/roboguice/src/main/java/roboguice/fragment/provided/NativeFragmentUtil.java
@@ -48,6 +48,7 @@ public Fragment findFragmentByTag(FragmentManager fm, String tag) {
         return FragmentManager.class;
     }
 
+	@SuppressWarnings("rawtypes") //not technically a Class<Provider<FragmentManager>>
 	@Override
 	public Class fragmentManagerProviderType() {
 		return FragmentManagerProvider.class;
diff --git a/roboguice/src/main/java/roboguice/fragment/support/SupportFragmentUtil.java b/roboguice/src/main/java/roboguice/fragment/support/SupportFragmentUtil.java
index c0a353bff..78ba54476 100644
--- a/roboguice/src/main/java/roboguice/fragment/support/SupportFragmentUtil.java
+++ b/roboguice/src/main/java/roboguice/fragment/support/SupportFragmentUtil.java
@@ -46,6 +46,7 @@ public Fragment findFragmentByTag(FragmentManager fm, String tag) {
         return FragmentManager.class;
     }
 
+	@SuppressWarnings("rawtypes")
 	@Override
 	public Class fragmentManagerProviderType() {
 		return FragmentManagerProvider.class;
diff --git a/roboguice/src/main/java/roboguice/inject/ExtrasListener.java b/roboguice/src/main/java/roboguice/inject/ExtrasListener.java
index 615d69063..dfb36bff5 100644
--- a/roboguice/src/main/java/roboguice/inject/ExtrasListener.java
+++ b/roboguice/src/main/java/roboguice/inject/ExtrasListener.java
@@ -125,7 +125,7 @@ public void injectMembers(T instance) {
             }
         }
 
-        @SuppressWarnings("unchecked")
+        @SuppressWarnings({ "unchecked", "rawtypes" })
         protected Object convert(Field field, Object value, Injector injector) {
 
             // Don't try to convert null or primitives
diff --git a/roboguice/src/main/java/roboguice/inject/ViewListener.java b/roboguice/src/main/java/roboguice/inject/ViewListener.java
index 704dd0a37..e02e1a6a0 100644
--- a/roboguice/src/main/java/roboguice/inject/ViewListener.java
+++ b/roboguice/src/main/java/roboguice/inject/ViewListener.java
@@ -53,7 +53,7 @@ else if (!View.class.isAssignableFrom(field.getType()))
                     else if (Context.class.isAssignableFrom(field.getDeclaringClass()) && !Activity.class.isAssignableFrom(field.getDeclaringClass()))
                     	throw new UnsupportedOperationException("You may only use @InjectView in Activity contexts");
                     else {
-                    	final f utils = FragmentUtil.hasSupport 
+                    	final f<?,?> utils = FragmentUtil.hasSupport 
                     			&& (FragmentUtil.supportActivity.isAssignableFrom(field.getDeclaringClass()) 
                     					|| FragmentUtil.supportFrag.fragmentType().isAssignableFrom(field.getDeclaringClass()))
                     					? FragmentUtil.supportFrag : FragmentUtil.nativeFrag;
@@ -105,12 +105,14 @@ else if (isNativeActivity && !assignableFromNative) {
         protected Field field;
         protected Annotation annotation;
         protected WeakReference<T> instanceRef;
-        protected FragmentUtil.f fragUtils;
-        protected Provider fragManager;
+        @SuppressWarnings("rawtypes")
+		protected FragmentUtil.f fragUtils;
+        @SuppressWarnings("rawtypes")
+		protected Provider fragManager;
         protected Provider<Activity> activityProvider;
         
 
-        public ViewMembersInjector(Field field, Annotation annotation, TypeEncounter<T> typeEncounter, FragmentUtil.f utils) {
+        public ViewMembersInjector(Field field, Annotation annotation, TypeEncounter<T> typeEncounter, FragmentUtil.f<?,?> utils) {
             this.field = field;
             this.annotation = annotation;
             this.activityProvider = typeEncounter.getProvider(Activity.class);
diff --git a/roboguice/src/main/java/roboguice/util/SafeAsyncTask.java b/roboguice/src/main/java/roboguice/util/SafeAsyncTask.java
index 7e966509f..deeccbc35 100644
--- a/roboguice/src/main/java/roboguice/util/SafeAsyncTask.java
+++ b/roboguice/src/main/java/roboguice/util/SafeAsyncTask.java
@@ -261,7 +261,7 @@ public Object call() throws Exception {
          * @param c the callable to post
          * @throws Exception on error
          */
-        protected void postToUiThreadAndWait( final Callable c ) throws Exception {
+        protected void postToUiThreadAndWait( final Callable<?> c ) throws Exception {
             final CountDownLatch latch = new CountDownLatch(1);
             final Exception[] exceptions = new Exception[1];
 
