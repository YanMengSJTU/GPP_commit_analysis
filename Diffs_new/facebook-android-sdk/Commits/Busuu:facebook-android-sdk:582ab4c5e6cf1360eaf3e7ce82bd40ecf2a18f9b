diff --git a/facebook/src/com/facebook/model/GraphObject.java b/facebook/src/com/facebook/model/GraphObject.java
index 7231ea547..fb6c9fe2e 100644
--- a/facebook/src/com/facebook/model/GraphObject.java
+++ b/facebook/src/com/facebook/model/GraphObject.java
@@ -47,40 +47,40 @@
      * @return a new instance of the GraphObject-derived-type that references the same underlying data
      */
     public <T extends GraphObject> T cast(Class<T> graphObjectClass);
-
+    
     /**
      * Returns a Java Collections map of names and properties.  Modifying the returned map modifies the
      * inner JSON representation.
      * @return a Java Collections map representing the GraphObject state
      */
     public Map<String, Object> asMap();
-
+    
     /**
      * Gets the underlying JSONObject representation of this graph object.
      * @return the underlying JSONObject representation of this graph object
      */
     public JSONObject getInnerJSONObject();
-
+    
     /**
      * Gets a property of the GraphObject
      * @param propertyName the name of the property to get
      * @return the value of the named property
      */
     public Object getProperty(String propertyName);
-
+    
     /**
      * Sets a property of the GraphObject
      * @param propertyName the name of the property to set
      * @param propertyValue the value of the named property to set
      */
     public void setProperty(String propertyName, Object propertyValue);
-
+    
     /**
      * Removes a property of the GraphObject
      * @param propertyName the name of the property to remove
      */
     public void removeProperty(String propertyName);
-
+    
     /**
      * Creates proxies that implement GraphObject, GraphObjectList, and their derived types. These proxies allow access
      * to underlying collections and name/value property bags via strongly-typed property getters and setters.
@@ -91,13 +91,13 @@
     final class Factory {
         private static final HashSet<Class<?>> verifiedGraphObjectClasses = new HashSet<Class<?>>();
         private static final SimpleDateFormat[] dateFormats = new SimpleDateFormat[] {
-                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.US),
-                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.US), new SimpleDateFormat("yyyy-MM-dd", Locale.US), };
-
+        new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.US),
+        new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.US), new SimpleDateFormat("yyyy-MM-dd", Locale.US), };
+        
         // No objects of this type should exist.
         private Factory() {
         }
-
+        
         /**
          * Creates a GraphObject proxy that provides typed access to the data in an underlying JSONObject.
          * @param json the JSONObject containing the data to be exposed
@@ -109,7 +109,7 @@ private Factory() {
         public static GraphObject create(JSONObject json) {
             return create(json, GraphObject.class);
         }
-
+        
         /**
          * Creates a GraphObject-derived proxy that provides typed access to the data in an underlying JSONObject.
          * @param json the JSONObject containing the data to be exposed
@@ -122,7 +122,7 @@ public static GraphObject create(JSONObject json) {
         public static <T extends GraphObject> T create(JSONObject json, Class<T> graphObjectClass) {
             return createGraphObjectProxy(graphObjectClass, json);
         }
-
+        
         /**
          * Creates a GraphObject proxy that initially contains no data.
          * @return a GraphObject with no data
@@ -133,7 +133,7 @@ public static GraphObject create(JSONObject json) {
         public static GraphObject create() {
             return create(GraphObject.class);
         }
-
+        
         /**
          * Creates a GraphObject-derived proxy that initially contains no data.
          * @param graphObjectClass the GraphObject-derived type to return
@@ -145,7 +145,7 @@ public static GraphObject create() {
         public static <T extends GraphObject> T create(Class<T> graphObjectClass) {
             return createGraphObjectProxy(graphObjectClass, new JSONObject());
         }
-
+        
         /**
          * Determines if two GraphObjects represent the same underlying graph object, based on their IDs.
          * @param a a graph object
@@ -166,7 +166,7 @@ public static boolean hasSameId(GraphObject a, GraphObject b) {
             }
             return idA.equals(idB);
         }
-
+        
         /**
          * Creates a GraphObjectList-derived proxy that provides typed access to the data in an underlying JSONArray.
          * @param array the JSONArray containing the data to be exposed
@@ -179,7 +179,7 @@ public static boolean hasSameId(GraphObject a, GraphObject b) {
         public static <T> GraphObjectList<T> createList(JSONArray array, Class<T> graphObjectClass) {
             return new GraphObjectListImpl<T>(array, graphObjectClass);
         }
-
+        
         /**
          * Creates a GraphObjectList-derived proxy that initially contains no data.
          * @param graphObjectClass the GraphObject-derived type to return
@@ -191,55 +191,55 @@ public static boolean hasSameId(GraphObject a, GraphObject b) {
         public static <T> GraphObjectList<T> createList(Class<T> graphObjectClass) {
             return createList(new JSONArray(), graphObjectClass);
         }
-
+        
         private static <T extends GraphObject> T createGraphObjectProxy(Class<T> graphObjectClass, JSONObject state) {
             verifyCanProxyClass(graphObjectClass);
-
-            Class<?>[] interfaces = new Class[] { graphObjectClass };
+            
+            Class<?>[] interfaces = new Class<?>[] { graphObjectClass };
             GraphObjectProxy graphObjectProxy = new GraphObjectProxy(state, graphObjectClass);
-
+            
             @SuppressWarnings("unchecked")
             T graphObject = (T) Proxy.newProxyInstance(GraphObject.class.getClassLoader(), interfaces, graphObjectProxy);
-
+            
             return graphObject;
         }
-
+        
         private static Map<String, Object> createGraphObjectProxyForMap(JSONObject state) {
-            Class<?>[] interfaces = new Class[]{Map.class};
+        	Class<?>[] interfaces = new Class<?>[]{Map.class};
             GraphObjectProxy graphObjectProxy = new GraphObjectProxy(state, Map.class);
-
+            
             @SuppressWarnings("unchecked")
             Map<String, Object> graphObject = (Map<String, Object>) Proxy
-                    .newProxyInstance(GraphObject.class.getClassLoader(), interfaces, graphObjectProxy);
-
+            .newProxyInstance(GraphObject.class.getClassLoader(), interfaces, graphObjectProxy);
+            
             return graphObject;
         }
-
+        
         private static synchronized <T extends GraphObject> boolean hasClassBeenVerified(Class<T> graphObjectClass) {
             return verifiedGraphObjectClasses.contains(graphObjectClass);
         }
-
+        
         private static synchronized <T extends GraphObject> void recordClassHasBeenVerified(Class<T> graphObjectClass) {
             verifiedGraphObjectClasses.add(graphObjectClass);
         }
-
+        
         private static <T extends GraphObject> void verifyCanProxyClass(Class<T> graphObjectClass) {
             if (hasClassBeenVerified(graphObjectClass)) {
                 return;
             }
-
+            
             if (!graphObjectClass.isInterface()) {
                 throw new FacebookGraphObjectException("Factory can only wrap interfaces, not class: "
-                        + graphObjectClass.getName());
+                                                       + graphObjectClass.getName());
             }
-
+            
             Method[] methods = graphObjectClass.getMethods();
             for (Method method : methods) {
                 String methodName = method.getName();
                 int parameterCount = method.getParameterTypes().length;
                 Class<?> returnType = method.getReturnType();
                 boolean hasPropertyNameOverride = method.isAnnotationPresent(PropertyName.class);
-
+                
                 if (method.getDeclaringClass().isAssignableFrom(GraphObject.class)) {
                     // Don't worry about any methods from GraphObject or one of its base classes.
                     continue;
@@ -266,39 +266,39 @@ public static boolean hasSameId(GraphObject a, GraphObject b) {
                         continue;
                     }
                 }
-
+                
                 throw new FacebookGraphObjectException("Factory can't proxy method: " + method.toString());
             }
-
+            
             recordClassHasBeenVerified(graphObjectClass);
         }
-
+        
         // If expectedType is a generic type, expectedTypeAsParameterizedType must be provided in order to determine
         // generic parameter types.
         static <U> U coerceValueToExpectedType(Object value, Class<U> expectedType,
-                ParameterizedType expectedTypeAsParameterizedType) {
+                                               ParameterizedType expectedTypeAsParameterizedType) {
             if (value == null) {
                 return null;
             }
-
+            
             Class<?> valueType = value.getClass();
             if (expectedType.isAssignableFrom(valueType)) {
                 @SuppressWarnings("unchecked")
                 U result = (U) value;
                 return result;
             }
-
+            
             if (expectedType.isPrimitive()) {
                 // If the result is a primitive, let the runtime succeed or fail at unboxing it.
                 @SuppressWarnings("unchecked")
                 U result = (U) value;
                 return result;
             }
-
+            
             if (GraphObject.class.isAssignableFrom(expectedType)) {
                 @SuppressWarnings("unchecked")
                 Class<? extends GraphObject> graphObjectClass = (Class<? extends GraphObject>) expectedType;
-
+                
                 // We need a GraphObject, but we don't have one.
                 if (JSONObject.class.isAssignableFrom(valueType)) {
                     // We can wrap a JSONObject as a GraphObject.
@@ -314,20 +314,20 @@ public static boolean hasSameId(GraphObject a, GraphObject b) {
                     throw new FacebookGraphObjectException("Can't create GraphObject from " + valueType.getName());
                 }
             } else if (Iterable.class.equals(expectedType) || Collection.class.equals(expectedType)
-                    || List.class.equals(expectedType) || GraphObjectList.class.equals(expectedType)) {
+                       || List.class.equals(expectedType) || GraphObjectList.class.equals(expectedType)) {
                 if (expectedTypeAsParameterizedType == null) {
                     throw new FacebookGraphObjectException("can't infer generic type of: " + expectedType.toString());
                 }
-
+                
                 Type[] actualTypeArguments = expectedTypeAsParameterizedType.getActualTypeArguments();
-
+                
                 if (actualTypeArguments == null || actualTypeArguments.length != 1
-                        || !(actualTypeArguments[0] instanceof Class<?>)) {
+                    || !(actualTypeArguments[0] instanceof Class<?>)) {
                     throw new FacebookGraphObjectException(
-                            "Expect collection properties to be of a type with exactly one generic parameter.");
+                                                           "Expect collection properties to be of a type with exactly one generic parameter.");
                 }
                 Class<?> collectionGenericArgument = (Class<?>) actualTypeArguments[0];
-
+                
                 if (JSONArray.class.isAssignableFrom(valueType)) {
                     JSONArray jsonArray = (JSONArray) value;
                     @SuppressWarnings("unchecked")
@@ -338,7 +338,7 @@ public static boolean hasSameId(GraphObject a, GraphObject b) {
                 }
             } else if (String.class.equals(expectedType)) {
                 if (Double.class.isAssignableFrom(valueType) ||
-                        Float.class.isAssignableFrom(valueType)) {
+                    Float.class.isAssignableFrom(valueType)) {
                     @SuppressWarnings("unchecked")
                     U result = (U) String.format("%f", value);
                     return result;
@@ -364,14 +364,14 @@ public static boolean hasSameId(GraphObject a, GraphObject b) {
                 }
             }
             throw new FacebookGraphObjectException("Can't convert type" + valueType.getName() + " to "
-                    + expectedType.getName());
+                                                   + expectedType.getName());
         }
-
+        
         static String convertCamelCaseToLowercaseWithUnderscores(String string) {
             string = string.replaceAll("([a-z])([A-Z])", "$1_$2");
             return string.toLowerCase(Locale.US);
         }
-
+        
         private static Object getUnderlyingJSONObject(Object obj) {
             Class<?> objClass = obj.getClass();
             if (GraphObject.class.isAssignableFrom(objClass)) {
@@ -383,33 +383,33 @@ private static Object getUnderlyingJSONObject(Object obj) {
             }
             return obj;
         }
-
+        
         private abstract static class ProxyBase<STATE> implements InvocationHandler {
             // Pre-loaded Method objects for the methods in java.lang.Object
             private static final String EQUALS_METHOD = "equals";
             private static final String TOSTRING_METHOD = "toString";
-
+            
             protected final STATE state;
-
+            
             protected ProxyBase(STATE state) {
                 this.state = state;
             }
-
+            
             // Declared to return Object just to simplify implementation of proxy helpers.
             protected final Object throwUnexpectedMethodSignature(Method method) {
                 throw new FacebookGraphObjectException(getClass().getName() + " got an unexpected method signature: "
-                        + method.toString());
+                                                       + method.toString());
             }
-
+            
             protected final Object proxyObjectMethods(Object proxy, Method method, Object[] args) throws Throwable {
                 String methodName = method.getName();
                 if (methodName.equals(EQUALS_METHOD)) {
                     Object other = args[0];
-
+                    
                     if (other == null) {
                         return false;
                     }
-
+                    
                     InvocationHandler handler = Proxy.getInvocationHandler(other);
                     if (!(handler instanceof GraphObjectProxy)) {
                         return false;
@@ -419,13 +419,13 @@ protected final Object proxyObjectMethods(Object proxy, Method method, Object[]
                 } else if (methodName.equals(TOSTRING_METHOD)) {
                     return toString();
                 }
-
+                
                 // For others, just defer to the implementation object.
                 return method.invoke(this.state, args);
             }
-
+            
         }
-
+        
         private final static class GraphObjectProxy extends ProxyBase<JSONObject> {
             private static final String CLEAR_METHOD = "clear";
             private static final String CONTAINSKEY_METHOD = "containsKey";
@@ -445,23 +445,23 @@ protected final Object proxyObjectMethods(Object proxy, Method method, Object[]
             private static final String SETPROPERTY_METHOD = "setProperty";
             private static final String REMOVEPROPERTY_METHOD = "removeProperty";
             private static final String GETINNERJSONOBJECT_METHOD = "getInnerJSONObject";
-
+            
             private final Class<?> graphObjectClass;
-
+            
             public GraphObjectProxy(JSONObject state, Class<?> graphObjectClass) {
                 super(state);
                 this.graphObjectClass = graphObjectClass;
             }
-
+            
             @Override
             public String toString() {
                 return String.format("GraphObject{graphObjectClass=%s, state=%s}", graphObjectClass.getSimpleName(), state);
             }
-
+            
             @Override
             public final Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                 Class<?> declaringClass = method.getDeclaringClass();
-
+                
                 if (declaringClass == Object.class) {
                     return proxyObjectMethods(proxy, method, args);
                 } else if (declaringClass == Map.class) {
@@ -471,10 +471,10 @@ public final Object invoke(Object proxy, Method method, Object[] args) throws Th
                 } else if (GraphObject.class.isAssignableFrom(declaringClass)) {
                     return proxyGraphObjectGettersAndSetters(method, args);
                 }
-
+                
                 return throwUnexpectedMethodSignature(method);
             }
-
+            
             private final Object proxyMapMethods(Method method, Object[] args) {
                 String methodName = method.getName();
                 if (methodName.equals(CLEAR_METHOD)) {
@@ -513,18 +513,18 @@ private final Object proxyMapMethods(Method method, Object[] args) {
                 } else if (methodName.equals(VALUES_METHOD)) {
                     return JsonUtil.jsonObjectValues(this.state);
                 }
-
+                
                 return throwUnexpectedMethodSignature(method);
             }
-
+            
             private final Object proxyGraphObjectMethods(Object proxy, Method method, Object[] args) {
                 String methodName = method.getName();
                 if (methodName.equals(CAST_METHOD)) {
                     @SuppressWarnings("unchecked")
                     Class<? extends GraphObject> graphObjectClass = (Class<? extends GraphObject>) args[0];
-
+                    
                     if (graphObjectClass != null &&
-                            graphObjectClass.isAssignableFrom(this.graphObjectClass)) {
+                        graphObjectClass.isAssignableFrom(this.graphObjectClass)) {
                         return proxy;
                     }
                     return Factory.createGraphObjectProxy(graphObjectClass, this.state);
@@ -542,33 +542,33 @@ private final Object proxyGraphObjectMethods(Object proxy, Method method, Object
                     this.state.remove((String) args[0]);
                     return null;
                 }
-
+                
                 return throwUnexpectedMethodSignature(method);
             }
-
+            
             private final Object proxyGraphObjectGettersAndSetters(Method method, Object[] args) throws JSONException {
                 String methodName = method.getName();
                 int parameterCount = method.getParameterTypes().length;
                 PropertyName propertyNameOverride = method.getAnnotation(PropertyName.class);
-
+                
                 String key = propertyNameOverride != null ? propertyNameOverride.value() :
-                        convertCamelCaseToLowercaseWithUnderscores(methodName.substring(3));
-
+                convertCamelCaseToLowercaseWithUnderscores(methodName.substring(3));
+                
                 // If it's a get or a set on a GraphObject-derived class, we can handle it.
                 if (parameterCount == 0) {
                     // Has to be a getter. ASSUMPTION: The GraphObject-derived class has been verified
                     Object value = this.state.opt(key);
-
+                    
                     Class<?> expectedType = method.getReturnType();
-
+                    
                     Type genericReturnType = method.getGenericReturnType();
                     ParameterizedType parameterizedReturnType = null;
                     if (genericReturnType instanceof ParameterizedType) {
                         parameterizedReturnType = (ParameterizedType) genericReturnType;
                     }
-
+                    
                     value = coerceValueToExpectedType(value, expectedType, parameterizedReturnType);
-
+                    
                     return value;
                 } else if (parameterCount == 1) {
                     // Has to be a setter. ASSUMPTION: The GraphObject-derived class has been verified
@@ -594,10 +594,10 @@ private final Object proxyGraphObjectGettersAndSetters(Method method, Object[] a
                     this.state.putOpt(key, value);
                     return null;
                 }
-
+                
                 return throwUnexpectedMethodSignature(method);
             }
-
+            
             private Object setJSONProperty(Object[] args) {
                 String name = (String) args[0];
                 Object property = args[1];
@@ -610,24 +610,24 @@ private Object setJSONProperty(Object[] args) {
                 return null;
             }
         }
-
+        
         private final static class GraphObjectListImpl<T> extends AbstractList<T> implements GraphObjectList<T> {
             private final JSONArray state;
             private final Class<?> itemType;
-
+            
             public GraphObjectListImpl(JSONArray state, Class<?> itemType) {
                 Validate.notNull(state, "state");
                 Validate.notNull(itemType, "itemType");
-
+                
                 this.state = state;
                 this.itemType = itemType;
             }
-
+            
             @Override
             public String toString() {
                 return String.format("GraphObjectList{itemType=%s, state=%s}", itemType.getSimpleName(), state);
             }
-
+            
             @Override
             public void add(int location, T object) {
                 // We only support adding at the end of the list, due to JSONArray restrictions.
@@ -636,24 +636,24 @@ public void add(int location, T object) {
                 } else if (location < size()) {
                     throw new UnsupportedOperationException("Only adding items at the end of the list is supported.");
                 }
-
+                
                 put(location, object);
             }
-
+            
             @Override
             public T set(int location, T object) {
                 checkIndex(location);
-
+                
                 T result = get(location);
                 put(location, object);
                 return result;
             }
-
+            
             @Override
             public int hashCode() {
                 return state.hashCode();
             }
-
+            
             @Override
             public boolean equals(Object obj) {
                 if (this == obj)
@@ -665,26 +665,26 @@ public boolean equals(Object obj) {
                 GraphObjectListImpl<T> other = (GraphObjectListImpl<T>) obj;
                 return state.equals(other.state);
             }
-
+            
             @SuppressWarnings("unchecked")
             @Override
             public T get(int location) {
                 checkIndex(location);
-
+                
                 Object value = state.opt(location);
-
+                
                 // Class<?> expectedType = method.getReturnType();
                 // Type genericType = method.getGenericReturnType();
                 T result = (T) coerceValueToExpectedType(value, itemType, null);
-
+                
                 return result;
             }
-
+            
             @Override
             public int size() {
                 return state.length();
             }
-
+            
             @Override
             public final <U extends GraphObject> GraphObjectList<U> castToListOf(Class<U> graphObjectClass) {
                 if (GraphObject.class.isAssignableFrom(itemType)) {
@@ -693,45 +693,45 @@ public int size() {
                         GraphObjectList<U> result = (GraphObjectList<U>)this;
                         return result;
                     }
-
+                    
                     return createList(state, graphObjectClass);
                 } else {
                     throw new FacebookGraphObjectException("Can't cast GraphObjectCollection of non-GraphObject type "
-                            + itemType);
+                                                           + itemType);
                 }
             }
-
+            
             @Override
             public final JSONArray getInnerJSONArray() {
                 return state;
             }
-
+            
             @Override
             public void clear() {
                 throw new UnsupportedOperationException();
             }
-
+            
             @Override
             public boolean remove(Object o) {
                 throw new UnsupportedOperationException();
             }
-
+            
             @Override
             public boolean removeAll(Collection<?> c) {
                 throw new UnsupportedOperationException();
             }
-
+            
             @Override
             public boolean retainAll(Collection<?> c) {
                 throw new UnsupportedOperationException();
             }
-
+            
             private void checkIndex(int index) {
                 if (index < 0 || index >= state.length()) {
                     throw new IndexOutOfBoundsException();
                 }
             }
-
+            
             private void put(int index, T obj) {
                 Object underlyingObject = getUnderlyingJSONObject(obj);
                 try {
