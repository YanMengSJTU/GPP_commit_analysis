diff --git a/facebook/TestApp/AndroidManifest.xml b/facebook/TestApp/AndroidManifest.xml
deleted file mode 100644
index cccc2923d..000000000
--- a/facebook/TestApp/AndroidManifest.xml
+++ /dev/null
@@ -1,15 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-      package="com.facebook.sdk"
-      android:versionCode="1"
-      android:versionName="1.0">
-    <application android:label="@string/app_name" android:icon="@drawable/ic_launcher">
-        <activity android:name="StatusActivity"
-                  android:label="@string/app_name">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
diff --git a/facebook/TestApp/SdkTestApp.eml b/facebook/TestApp/SdkTestApp.eml
deleted file mode 100644
index 4104d1ffc..000000000
--- a/facebook/TestApp/SdkTestApp.eml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<component>
-	<exclude-output/>
-	<contentEntry url="file://$MODULE_DIR$"/>
-</component>
diff --git a/facebook/TestApp/SdkTestApp.iml b/facebook/TestApp/SdkTestApp.iml
deleted file mode 100644
index 04f3d28e2..000000000
--- a/facebook/TestApp/SdkTestApp.iml
+++ /dev/null
@@ -1,51 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
-  <component name="EclipseModuleManager">
-    <conelement value="com.android.ide.eclipse.adt.LIBRARIES" />
-    <src_description expected_position="0">
-      <src_folder value="file://$MODULE_DIR$/src" expected_position="0" />
-      <src_folder value="file://$MODULE_DIR$/gen" expected_position="1" />
-    </src_description>
-  </component>
-  <component name="FacetManager">
-    <facet type="android" name="Android">
-      <configuration>
-        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
-        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
-        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
-        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
-        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
-        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
-        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
-        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
-        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
-        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
-        <option name="APK_PATH" value="" />
-        <option name="LIBRARY_PROJECT" value="false" />
-        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
-        <option name="GENERATE_UNSIGNED_APK" value="false" />
-        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
-        <option name="PACK_TEST_CODE" value="true" />
-        <option name="RUN_PROGUARD" value="false" />
-        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
-        <resOverlayFolders>
-          <path>/res-overlay</path>
-        </resOverlayFolders>
-        <includeSystemProguardFile>true</includeSystemProguardFile>
-        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
-        <additionalNativeLibs />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/bin/classes" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
-    </content>
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
-  </component>
-</module>
-
diff --git a/facebook/TestApp/ant.properties b/facebook/TestApp/ant.properties
deleted file mode 100644
index b0971e891..000000000
--- a/facebook/TestApp/ant.properties
+++ /dev/null
@@ -1,17 +0,0 @@
-# This file is used to override default values used by the Ant build system.
-#
-# This file must be checked into Version Control Systems, as it is
-# integral to the build system of your project.
-
-# This file is only used by the Ant script.
-
-# You can use this to override default values such as
-#  'source.dir' for the location of your java source folder and
-#  'out.dir' for the location of your output folder.
-
-# You can also use it define how the release builds are signed by declaring
-# the following properties:
-#  'key.store' for the location of your keystore and
-#  'key.alias' for the name of the key to use.
-# The password will be asked during the build when you use the 'release' target.
-
diff --git a/facebook/TestApp/build.xml b/facebook/TestApp/build.xml
deleted file mode 100644
index ea49a3fca..000000000
--- a/facebook/TestApp/build.xml
+++ /dev/null
@@ -1,83 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="FacebookSdk" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties" />
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties" />
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties" />
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through an env var"
-            unless="sdk.dir"
-    />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true" />
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml" />
-
-</project>
diff --git a/facebook/TestApp/proguard-project.txt b/facebook/TestApp/proguard-project.txt
deleted file mode 100644
index f2fe1559a..000000000
--- a/facebook/TestApp/proguard-project.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/facebook/TestApp/project.properties b/facebook/TestApp/project.properties
deleted file mode 100644
index b0620672e..000000000
--- a/facebook/TestApp/project.properties
+++ /dev/null
@@ -1,15 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-8
-
diff --git a/facebook/TestApp/res/drawable-hdpi/ic_launcher.png b/facebook/TestApp/res/drawable-hdpi/ic_launcher.png
deleted file mode 100644
index 8074c4c57..000000000
Binary files a/facebook/TestApp/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/facebook/TestApp/res/drawable-ldpi/ic_launcher.png b/facebook/TestApp/res/drawable-ldpi/ic_launcher.png
deleted file mode 100644
index 1095584ec..000000000
Binary files a/facebook/TestApp/res/drawable-ldpi/ic_launcher.png and /dev/null differ
diff --git a/facebook/TestApp/res/drawable-mdpi/ic_launcher.png b/facebook/TestApp/res/drawable-mdpi/ic_launcher.png
deleted file mode 100644
index a07c69fa5..000000000
Binary files a/facebook/TestApp/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/facebook/TestApp/res/layout/main.xml b/facebook/TestApp/res/layout/main.xml
deleted file mode 100644
index 2c0cc449a..000000000
--- a/facebook/TestApp/res/layout/main.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:orientation="vertical"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    >
-<TextView
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:text="SDK Unit Tests"
-    />
-</LinearLayout>
-
diff --git a/facebook/TestApp/res/values/strings.xml b/facebook/TestApp/res/values/strings.xml
deleted file mode 100644
index 520cc92a7..000000000
--- a/facebook/TestApp/res/values/strings.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<resources>
-    <string name="app_name">StatusActivity</string>
-</resources>
diff --git a/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java b/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java
deleted file mode 100644
index 317e5567f..000000000
--- a/facebook/TestApp/src/com/facebook/sdk/StatusActivity.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.sdk;
-
-import android.app.Activity;
-import android.os.Bundle;
-
-public class StatusActivity extends Activity
-{
-    /** Called when the activity is first created. */
-    @Override
-    public void onCreate(Bundle savedInstanceState)
-    {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main);
-    }
-}
diff --git a/facebook/res/layout/com_facebook_usersettingsfragment.xml b/facebook/res/layout/com_facebook_usersettingsfragment.xml
deleted file mode 100644
index 04a9a1ded..000000000
--- a/facebook/res/layout/com_facebook_usersettingsfragment.xml
+++ /dev/null
@@ -1,59 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<ScrollView
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:loginView="http://schemas.android.com/apk/res-auto"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent"
-    android:background="@drawable/com_facebook_usersettingsfragment_background_gradient" >
-    <LinearLayout
-        android:layout_width="fill_parent"
-        android:layout_height="fill_parent"
-        android:orientation="vertical">
-
-        <ImageView
-            android:id="@+id/com_facebook_usersettingsfragment_logo_image"
-            android:layout_width="193dp"
-            android:layout_height="44dp"
-            android:layout_gravity="center_horizontal"
-            android:src="@drawable/com_facebook_logo"
-            android:layout_marginTop="35dp"
-            android:contentDescription="@string/com_facebook_logo_content_description"/>
-
-        <TextView
-            android:id="@+id/com_facebook_usersettingsfragment_profile_name"
-            android:layout_width="fill_parent"
-            android:layout_height="100dp"
-            android:lines="1"
-            android:textSize="16sp"
-            android:textStyle="bold"
-            android:layout_marginTop="35dp"
-            android:gravity="center"/>
-    
-        <com.facebook.widget.LoginButton
-            android:id="@+id/com_facebook_usersettingsfragment_login_button"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center_horizontal"
-            android:layout_marginTop="35dp"
-            android:layout_marginBottom="35dp"
-            loginView:login_text="@string/com_facebook_usersettingsfragment_log_in_button"
-            style="@style/com_facebook_loginview_silver_style" />
-    
-    </LinearLayout>
-</ScrollView>
diff --git a/facebook/res/values-es/strings.xml b/facebook/res/values-es/strings.xml
deleted file mode 100644
index d73c5ab27..000000000
--- a/facebook/res/values-es/strings.xml
+++ /dev/null
@@ -1,44 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<resources>
-    <string name="com_facebook_dialogloginactivity_ok_button">Aceptar</string>
-    <string name="com_facebook_loginview_log_out_button">Cerrar Sesión</string>
-    <string name="com_facebook_loginview_log_in_button">Iniciar Sesión</string>
-    <string name="com_facebook_loginview_logged_in_as">Sesión iniciada como: %1$s</string>
-    <string name="com_facebook_loginview_logged_in_using_facebook">Sesión iniciada con Facebook</string>
-    <string name="com_facebook_loginview_log_out_action">Cerrar sesión</string>
-    <string name="com_facebook_loginview_cancel_action">Cancelar</string>
-    <string name="com_facebook_logo_content_description">Logo de Facebook</string>
-    <string name="com_facebook_usersettingsfragment_log_in_button">Iniciar Sesión&#8230;</string>
-    <string name="com_facebook_usersettingsfragment_logged_in">Sesión iniciada</string>
-    <string name="com_facebook_usersettingsfragment_not_logged_in">No has iniciado sesión</string>
-    <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d estuvieron aquí</string>
-    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
-    <string name="com_facebook_placepicker_subtitle_were_here_only_format">es:%1$,d estuvieron aquí</string>
-    <string name="com_facebook_picker_done_button_text">Aceptar</string>
-    <string name="com_facebook_choose_friends">Elige Amigos</string>
-    <string name="com_facebook_nearby">Cercano</string>
-    <string name="com_facebook_loading">Cargando</string>
-    <string name="com_facebook_internet_permission_error_title">Error de AndroidManifest</string>
-    <string name="com_facebook_internet_permission_error_message">WebView inicio de sesión requiere permiso INTERNET</string>
-    <string name="com_facebook_requesterror_web_login">Por favor, iniciar sesión a través https://www.facebook.com o https://m.facebook.com para volver a activar la aplicación para conectar con Facebook.</string>
-    <string name="com_facebook_requesterror_relogin">La aplicación no se conecta con Facebook, inicie sesión y volver a conectar esta aplicación.</string>
-    <string name="com_facebook_requesterror_password_changed">Su contraseña de Facebook ha cambiado, por favor vuelva a conectar la aplicación con Facebook.</string>
-    <string name="com_facebook_requesterror_reconnect">Se produjo un error al conectar con Facebook, por favor vuelva a conectar la aplicación con Facebook.</string>
-    <string name="com_facebook_requesterror_permissions">Una conexión de aplicación con Facebook falló debido a permisos insuficientes, por favor, conceda los permisos de aplicaciones para realizar la operación.</string>
-</resources>
diff --git a/facebook/res/values-he/strings.xml b/facebook/res/values-he/strings.xml
deleted file mode 100644
index 385330517..000000000
--- a/facebook/res/values-he/strings.xml
+++ /dev/null
@@ -1,44 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<resources>
-    <string name="com_facebook_loginview_log_out_button">התנתק</string>
-    <string name="com_facebook_loginview_log_in_button">התחבר</string>
-    <string name="com_facebook_loginview_logged_in_as">מחובר בשם: %1$s</string>
-    <string name="com_facebook_loginview_logged_in_using_facebook">מחובר באמצעות פייסבוק</string>
-    <string name="com_facebook_loginview_log_out_action">התנתק</string>
-    <string name="com_facebook_loginview_cancel_action">בטל</string>
-    <string name="com_facebook_logo_content_description">פייסבוק לוגו</string>
-    <string name="com_facebook_usersettingsfragment_log_in_button">התחבר&#8230;</string>
-    <string name="com_facebook_usersettingsfragment_logged_in">מחובר</string>
-    <string name="com_facebook_usersettingsfragment_not_logged_in">לא מחובר</string>
-    <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d היו פה</string>
-    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
-    <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d היו פה</string>
-    <string name="com_facebook_picker_done_button_text">בצע</string>
-    <string name="com_facebook_choose_friends">בחר חברים</string>
-    <string name="com_facebook_nearby">קרוב אליי</string>
-    <string name="com_facebook_loading">..מעלה</string>
-    <string name="com_facebook_internet_permission_error_title">AndroidManifest שגיאת</string>
-    <string name="com_facebook_internet_permission_error_message">ההתחברות לתצוגת אתר דורשת אישור אינטרנט</string>
-    <string name="com_facebook_requesterror_web_login">.כדי לאפשר מחדש לאפליקציה להתחבר עם פייסבוק https://www.facebook.com או https://m.facebook.com אנא היכנס דרך</string>
-    <string name="com_facebook_requesterror_relogin">.האפליקציה אינה מחוברת לפייסבוק, אנא היכנס וחבר מחדש את האפליקציה</string>
-    <string name="com_facebook_requesterror_password_changed">.הסיסמה שלך בפייסבוק השתנתה, אנא חבר מחדש את האפליקציה עם פייסבוק</string>
-    <string name="com_facebook_requesterror_reconnect">.ארעה שגיאה בעת החיבור עם פייסבוק, חבר בבקשה מחדש את האפליקציה עם פייסבוק</string>
-    <string name="com_facebook_requesterror_permissions">.חיבור האפליקציה עם פייסבוק נכשל בשל הרשאות לא מספקות, אנא הענק הרשאות לאפליקציה בכדי שהפעולה תוכל להתבצע</string>
-    <string name="com_facebook_dialogloginactivity_ok_button">אישור</string>
-</resources>
diff --git a/facebook/res/values-iw/strings.xml b/facebook/res/values-iw/strings.xml
deleted file mode 100644
index 385330517..000000000
--- a/facebook/res/values-iw/strings.xml
+++ /dev/null
@@ -1,44 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<resources>
-    <string name="com_facebook_loginview_log_out_button">התנתק</string>
-    <string name="com_facebook_loginview_log_in_button">התחבר</string>
-    <string name="com_facebook_loginview_logged_in_as">מחובר בשם: %1$s</string>
-    <string name="com_facebook_loginview_logged_in_using_facebook">מחובר באמצעות פייסבוק</string>
-    <string name="com_facebook_loginview_log_out_action">התנתק</string>
-    <string name="com_facebook_loginview_cancel_action">בטל</string>
-    <string name="com_facebook_logo_content_description">פייסבוק לוגו</string>
-    <string name="com_facebook_usersettingsfragment_log_in_button">התחבר&#8230;</string>
-    <string name="com_facebook_usersettingsfragment_logged_in">מחובר</string>
-    <string name="com_facebook_usersettingsfragment_not_logged_in">לא מחובר</string>
-    <string name="com_facebook_placepicker_subtitle_format">%1$s • %2$,d היו פה</string>
-    <string name="com_facebook_placepicker_subtitle_catetory_only_format">%1$s</string>
-    <string name="com_facebook_placepicker_subtitle_were_here_only_format">%1$,d היו פה</string>
-    <string name="com_facebook_picker_done_button_text">בצע</string>
-    <string name="com_facebook_choose_friends">בחר חברים</string>
-    <string name="com_facebook_nearby">קרוב אליי</string>
-    <string name="com_facebook_loading">..מעלה</string>
-    <string name="com_facebook_internet_permission_error_title">AndroidManifest שגיאת</string>
-    <string name="com_facebook_internet_permission_error_message">ההתחברות לתצוגת אתר דורשת אישור אינטרנט</string>
-    <string name="com_facebook_requesterror_web_login">.כדי לאפשר מחדש לאפליקציה להתחבר עם פייסבוק https://www.facebook.com או https://m.facebook.com אנא היכנס דרך</string>
-    <string name="com_facebook_requesterror_relogin">.האפליקציה אינה מחוברת לפייסבוק, אנא היכנס וחבר מחדש את האפליקציה</string>
-    <string name="com_facebook_requesterror_password_changed">.הסיסמה שלך בפייסבוק השתנתה, אנא חבר מחדש את האפליקציה עם פייסבוק</string>
-    <string name="com_facebook_requesterror_reconnect">.ארעה שגיאה בעת החיבור עם פייסבוק, חבר בבקשה מחדש את האפליקציה עם פייסבוק</string>
-    <string name="com_facebook_requesterror_permissions">.חיבור האפליקציה עם פייסבוק נכשל בשל הרשאות לא מספקות, אנא הענק הרשאות לאפליקציה בכדי שהפעולה תוכל להתבצע</string>
-    <string name="com_facebook_dialogloginactivity_ok_button">אישור</string>
-</resources>
diff --git a/facebook/src/com/facebook/android/AsyncFacebookRunner.java b/facebook/src/com/facebook/android/AsyncFacebookRunner.java
deleted file mode 100644
index 2420fd4b3..000000000
--- a/facebook/src/com/facebook/android/AsyncFacebookRunner.java
+++ /dev/null
@@ -1,341 +0,0 @@
-/**
- * Copyright 2010-present Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import android.content.Context;
-import android.os.Bundle;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.net.MalformedURLException;
-
-/**
- * A sample implementation of asynchronous API requests. This class provides
- * the ability to execute API methods and have the call return immediately,
- * without blocking the calling thread. This is necessary when accessing the
- * API in the UI thread, for instance. The request response is returned to 
- * the caller via a callback interface, which the developer must implement.
- *
- * This sample implementation simply spawns a new thread for each request,
- * and makes the API call immediately.  This may work in many applications,
- * but more sophisticated users may re-implement this behavior using a thread
- * pool, a network thread, a request queue, or other mechanism.  Advanced
- * functionality could be built, such as rate-limiting of requests, as per
- * a specific application's needs.
- *
- * @deprecated
- *
- * @see RequestListener
- *        The callback interface.
- *
- * @author  Jim Brusstar (jimbru@fb.com),
- *          Yariv Sadan (yariv@fb.com),
- *          Luke Shepard (lshepard@fb.com)
- */
-@Deprecated
-public class AsyncFacebookRunner {
-
-    Facebook fb;
-
-    public AsyncFacebookRunner(Facebook fb) {
-        this.fb = fb;
-    }
-
-    /**
-     * Invalidate the current user session by removing the access token in
-     * memory, clearing the browser cookies, and calling auth.expireSession
-     * through the API. The application will be notified when logout is
-     * complete via the callback interface.
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked
-     * in a background thread; operations that affect the UI will need to be
-     * posted to the UI thread or an appropriate handler.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Session} for more info.
-     *
-     * @param context
-     *            The Android context in which the logout should be called: it
-     *            should be the same context in which the login occurred in
-     *            order to clear any stored cookies
-     * @param listener
-     *            Callback interface to notify the application when the request
-     *            has completed.
-     * @param state
-     *            An arbitrary object used to identify the request when it
-     *            returns to the callback. This has no effect on the request
-     *            itself.
-     */
-    @Deprecated
-    public void logout(final Context context,
-                       final RequestListener listener,
-                       final Object state) {
-        new Thread() {
-            @Override public void run() {
-                try {
-                    String response = fb.logoutImpl(context);
-                    if (response.length() == 0 || response.equals("false")){
-                        listener.onFacebookError(new FacebookError(
-                                "auth.expireSession failed"), state);
-                        return;
-                    }
-                    listener.onComplete(response, state);
-                } catch (FileNotFoundException e) {
-                    listener.onFileNotFoundException(e, state);
-                } catch (MalformedURLException e) {
-                    listener.onMalformedURLException(e, state);
-                } catch (IOException e) {
-                    listener.onIOException(e, state);
-                }
-            }
-        }.start();
-    }
-
-    @Deprecated
-    public void logout(final Context context, final RequestListener listener) {
-        logout(context, listener, /* state */ null);
-    }
-
-    /**
-     * Make a request to Facebook's old (pre-graph) API with the given
-     * parameters. One of the parameter keys must be "method" and its value
-     * should be a valid REST server API method.
-     * <p/>
-     * See http://developers.facebook.com/docs/reference/rest/
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked
-     * in a background thread; operations that affect the UI will need to be
-     * posted to the UI thread or an appropriate handler.
-     * <p/>
-     * Example:
-     * <code>
-     *  Bundle parameters = new Bundle();
-     *  parameters.putString("method", "auth.expireSession", new Listener());
-     *  String response = request(parameters);
-     * </code>
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
-     *
-     * @param parameters
-     *            Key-value pairs of parameters to the request. Refer to the
-     *            documentation: one of the parameters must be "method".
-     * @param listener
-     *            Callback interface to notify the application when the request
-     *            has completed.
-     * @param state
-     *            An arbitrary object used to identify the request when it
-     *            returns to the callback. This has no effect on the request
-     *            itself.
-     */
-    @Deprecated
-    public void request(Bundle parameters,
-                        RequestListener listener,
-                        final Object state) {
-        request(null, parameters, "GET", listener, state);
-    }
-
-    @Deprecated
-    public void request(Bundle parameters, RequestListener listener) {
-        request(null, parameters, "GET", listener, /* state */ null);
-    }
-
-    /**
-     * Make a request to the Facebook Graph API without any parameters.
-     * <p/>
-     * See http://developers.facebook.com/docs/api
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked
-     * in a background thread; operations that affect the UI will need to be
-     * posted to the UI thread or an appropriate handler.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
-     *
-     * @param graphPath
-     *            Path to resource in the Facebook graph, e.g., to fetch data
-     *            about the currently logged authenticated user, provide "me",
-     *            which will fetch http://graph.facebook.com/me
-     * @param listener
-     *            Callback interface to notify the application when the request
-     *            has completed.
-     * @param state
-     *            An arbitrary object used to identify the request when it
-     *            returns to the callback. This has no effect on the request
-     *            itself.
-     */
-    @Deprecated
-    public void request(String graphPath,
-                        RequestListener listener,
-                        final Object state) {
-        request(graphPath, new Bundle(), "GET", listener, state);
-    }
-
-    @Deprecated
-    public void request(String graphPath, RequestListener listener) {
-        request(graphPath, new Bundle(), "GET", listener, /* state */ null);
-    }
-
-    /**
-     * Make a request to the Facebook Graph API with the given string parameters
-     * using an HTTP GET (default method).
-     * <p/>
-     * See http://developers.facebook.com/docs/api
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked
-     * in a background thread; operations that affect the UI will need to be
-     * posted to the UI thread or an appropriate handler.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
-     *
-     * @param graphPath
-     *            Path to resource in the Facebook graph, e.g., to fetch data
-     *            about the currently logged authenticated user, provide "me",
-     *            which will fetch http://graph.facebook.com/me
-     * @param parameters
-     *            key-value string parameters, e.g. the path "search" with
-     *            parameters "q" : "facebook" would produce a query for the
-     *            following graph resource:
-     *            https://graph.facebook.com/search?q=facebook
-     * @param listener
-     *            Callback interface to notify the application when the request
-     *            has completed.
-     * @param state
-     *            An arbitrary object used to identify the request when it
-     *            returns to the callback. This has no effect on the request
-     *            itself.
-     */
-    @Deprecated
-    public void request(String graphPath,
-                        Bundle parameters,
-                        RequestListener listener,
-                        final Object state) {
-        request(graphPath, parameters, "GET", listener, state);
-    }
-
-    @Deprecated
-    public void request(String graphPath,
-                        Bundle parameters,
-                        RequestListener listener) {
-        request(graphPath, parameters, "GET", listener, /* state */ null);
-    }
-
-    /**
-     * Make a request to the Facebook Graph API with the given HTTP method and
-     * string parameters. Note that binary data parameters (e.g. pictures) are
-     * not yet supported by this helper function.
-     * <p/>
-     * See http://developers.facebook.com/docs/api
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked
-     * in a background thread; operations that affect the UI will need to be
-     * posted to the UI thread or an appropriate handler.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
-     *
-     * @param graphPath
-     *            Path to resource in the Facebook graph, e.g., to fetch data
-     *            about the currently logged authenticated user, provide "me",
-     *            which will fetch http://graph.facebook.com/me
-     * @param parameters
-     *            key-value string parameters, e.g. the path "search" with
-     *            parameters {"q" : "facebook"} would produce a query for the
-     *            following graph resource:
-     *            https://graph.facebook.com/search?q=facebook
-     * @param httpMethod
-     *            http verb, e.g. "POST", "DELETE"
-     * @param listener
-     *            Callback interface to notify the application when the request
-     *            has completed.
-     * @param state
-     *            An arbitrary object used to identify the request when it
-     *            returns to the callback. This has no effect on the request
-     *            itself.
-     */
-    @Deprecated
-    public void request(final String graphPath,
-                        final Bundle parameters,
-                        final String httpMethod,
-                        final RequestListener listener,
-                        final Object state) {
-        new Thread() {
-            @Override public void run() {
-                try {
-                    String resp = fb.requestImpl(graphPath, parameters, httpMethod);
-                    listener.onComplete(resp, state);
-                } catch (FileNotFoundException e) {
-                    listener.onFileNotFoundException(e, state);
-                } catch (MalformedURLException e) {
-                    listener.onMalformedURLException(e, state);
-                } catch (IOException e) {
-                    listener.onIOException(e, state);
-                }
-            }
-        }.start();
-    }
-
-    /**
-     * Callback interface for API requests.
-     * <p/>
-     * Each method includes a 'state' parameter that identifies the calling
-     * request. It will be set to the value passed when originally calling the
-     * request method, or null if none was passed.
-     * <p/>
-     * This interface is deprecated.  See {@link Facebook} and {@link com.facebook.Request} for more info.
-     */
-    @Deprecated
-    public static interface RequestListener {
-
-        /**
-         * Called when a request completes with the given response.
-         *
-         * Executed by a background thread: do not update the UI in this method.
-         */
-        public void onComplete(String response, Object state);
-
-        /**
-         * Called when a request has a network or request error.
-         *
-         * Executed by a background thread: do not update the UI in this method.
-         */
-        public void onIOException(IOException e, Object state);
-
-        /**
-         * Called when a request fails because the requested resource is
-         * invalid or does not exist.
-         *
-         * Executed by a background thread: do not update the UI in this method.
-         */
-        public void onFileNotFoundException(FileNotFoundException e,
-                                            Object state);
-
-        /**
-         * Called if an invalid graph path is provided (which may result in a
-         * malformed URL).
-         *
-         * Executed by a background thread: do not update the UI in this method.
-         */
-        public void onMalformedURLException(MalformedURLException e,
-                                            Object state);
-
-        /**
-         * Called when the server-side Facebook method fails.
-         *
-         * Executed by a background thread: do not update the UI in this method.
-         */
-        public void onFacebookError(FacebookError e, Object state);
-
-    }
-
-}
diff --git a/facebook/src/com/facebook/android/DialogError.java b/facebook/src/com/facebook/android/DialogError.java
deleted file mode 100644
index a99c4e613..000000000
--- a/facebook/src/com/facebook/android/DialogError.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * Copyright 2010-present Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-/**
- * Encapsulation of Dialog Error.
- * <p/>
- * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
- * <p/>
- * All public members of this class are intentionally deprecated.
- * New code should instead use
- * {@link com.facebook.FacebookException}
- * <p/>
- * Adding @Deprecated to this class causes warnings in other deprecated classes
- * that reference this one.  That is the only reason this entire class is not
- * deprecated.
- *
- * @devDocDeprecated
- */
-public class DialogError extends Throwable {
-
-    private static final long serialVersionUID = 1L;
-
-    /**
-     * The ErrorCode received by the WebView: see
-     * http://developer.android.com/reference/android/webkit/WebViewClient.html
-     */
-    private int mErrorCode;
-
-    /** The URL that the dialog was trying to load */
-    private String mFailingUrl;
-
-    @Deprecated
-    public DialogError(String message, int errorCode, String failingUrl) {
-        super(message);
-        mErrorCode = errorCode;
-        mFailingUrl = failingUrl;
-    }
-
-    @Deprecated
-    public int getErrorCode() {
-        return mErrorCode;
-    }
-
-    @Deprecated
-    public String getFailingUrl() {
-        return mFailingUrl;
-    }
-
-}
diff --git a/facebook/src/com/facebook/android/Facebook.java b/facebook/src/com/facebook/android/Facebook.java
deleted file mode 100644
index 2b439e7d7..000000000
--- a/facebook/src/com/facebook/android/Facebook.java
+++ /dev/null
@@ -1,1357 +0,0 @@
-/**
- * Copyright 2010-present Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import android.Manifest;
-import android.app.Activity;
-import android.content.*;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.PackageManager.NameNotFoundException;
-import android.content.pm.ResolveInfo;
-import android.content.pm.Signature;
-import android.net.Uri;
-import android.os.*;
-import com.facebook.*;
-import com.facebook.Session.StatusCallback;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.lang.ref.WeakReference;
-import java.net.MalformedURLException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
- * <p/>
- * All public members of this class are intentionally deprecated.
- * New code should instead use
- * {@link Session} to manage session state,
- * {@link Request} to make API requests, and
- * {@link com.facebook.widget.WebDialog} to make dialog requests.
- * <p/>
- * Adding @Deprecated to this class causes warnings in other deprecated classes
- * that reference this one.  That is the only reason this entire class is not
- * deprecated.
- *
- * @devDocDeprecated
- */
-public class Facebook {
-
-    // Strings used in the authorization flow
-    @Deprecated
-    public static final String REDIRECT_URI = "fbconnect://success";
-    @Deprecated
-    public static final String CANCEL_URI = "fbconnect://cancel";
-    @Deprecated
-    public static final String TOKEN = "access_token";
-    @Deprecated
-    public static final String EXPIRES = "expires_in";
-    @Deprecated
-    public static final String SINGLE_SIGN_ON_DISABLED = "service_disabled";
-
-    @Deprecated
-    public static final Uri ATTRIBUTION_ID_CONTENT_URI =
-        Uri.parse("content://com.facebook.katana.provider.AttributionIdProvider");
-    @Deprecated
-    public static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
-
-    @Deprecated
-    public static final int FORCE_DIALOG_AUTH = -1;
-
-    private static final String LOGIN = "oauth";
-
-    // Used as default activityCode by authorize(). See authorize() below.
-    private static final int DEFAULT_AUTH_ACTIVITY_CODE = 32665;
-
-    // Facebook server endpoints: may be modified in a subclass for testing
-    @Deprecated
-    protected static String DIALOG_BASE_URL = "https://m.facebook.com/dialog/";
-    @Deprecated
-    protected static String GRAPH_BASE_URL = "https://graph.facebook.com/";
-    @Deprecated
-    protected static String RESTSERVER_URL = "https://api.facebook.com/restserver.php";
-
-    private final Object lock = new Object();
-
-    private String accessToken = null;
-    private long accessExpiresMillisecondsAfterEpoch = 0;
-    private long lastAccessUpdateMillisecondsAfterEpoch = 0;
-    private String mAppId;
-
-    private Activity pendingAuthorizationActivity;
-    private String[] pendingAuthorizationPermissions;
-    private Session pendingOpeningSession;
-
-    private volatile Session session; // must synchronize this.sync to write
-    private boolean sessionInvalidated; // must synchronize this.sync to access
-    private SetterTokenCachingStrategy tokenCache;
-    private volatile Session userSetSession;
-
-    // If the last time we extended the access token was more than 24 hours ago
-    // we try to refresh the access token again.
-    final private long REFRESH_TOKEN_BARRIER = 24L * 60L * 60L * 1000L;
-
-    /**
-     * Constructor for Facebook object.
-     * 
-     * @param appId
-     *            Your Facebook application ID. Found at
-     *            www.facebook.com/developers/apps.php.
-     */
-    @Deprecated
-    public Facebook(String appId) {
-        if (appId == null) {
-            throw new IllegalArgumentException("You must specify your application ID when instantiating "
-                    + "a Facebook object. See README for details.");
-        }
-        mAppId = appId;
-    }
-
-    /**
-     * Default authorize method. Grants only basic permissions.
-     * <p/>
-     * See authorize() below for @params.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     */
-    @Deprecated
-    public void authorize(Activity activity, final DialogListener listener) {
-        authorize(activity, new String[]{}, DEFAULT_AUTH_ACTIVITY_CODE, SessionLoginBehavior.SSO_WITH_FALLBACK,
-                listener);
-    }
-
-    /**
-     * Authorize method that grants custom permissions.
-     * <p/>
-     * See authorize() below for @params.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     */
-    @Deprecated
-    public void authorize(Activity activity, String[] permissions, final DialogListener listener) {
-        authorize(activity, permissions, DEFAULT_AUTH_ACTIVITY_CODE, SessionLoginBehavior.SSO_WITH_FALLBACK, listener);
-    }
-
-    /**
-     * Full authorize method.
-     * <p/>
-     * Starts either an Activity or a dialog which prompts the user to log in to
-     * Facebook and grant the requested permissions to the given application.
-     * <p/>
-     * This method will, when possible, use Facebook's single sign-on for
-     * Android to obtain an access token. This involves proxying a call through
-     * the Facebook for Android stand-alone application, which will handle the
-     * authentication flow, and return an OAuth access token for making API
-     * calls.
-     * <p/>
-     * Because this process will not be available for all users, if single
-     * sign-on is not possible, this method will automatically fall back to the
-     * OAuth 2.0 User-Agent flow. In this flow, the user credentials are handled
-     * by Facebook in an embedded WebView, not by the client application. As
-     * such, the dialog makes a network request and renders HTML content rather
-     * than a native UI. The access token is retrieved from a redirect to a
-     * special URL that the WebView handles.
-     * <p/>
-     * Note that User credentials could be handled natively using the OAuth 2.0
-     * Username and Password Flow, but this is not supported by this SDK.
-     * <p/>
-     * See http://developers.facebook.com/docs/authentication/ and
-     * http://wiki.oauth.net/OAuth-2 for more details.
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked in
-     * the original calling thread (not in a background thread).
-     * <p/>
-     * Also note that requests may be made to the API without calling authorize
-     * first, in which case only public information is returned.
-     * <p/>
-     * IMPORTANT: Note that single sign-on authentication will not function
-     * correctly if you do not include a call to the authorizeCallback() method
-     * in your onActivityResult() function! Please see below for more
-     * information. single sign-on may be disabled by passing FORCE_DIALOG_AUTH
-     * as the activityCode parameter in your call to authorize().
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param activity
-     *            The Android activity in which we want to display the
-     *            authorization dialog.
-     * @param permissions
-     *            A list of permissions required for this application: e.g.
-     *            "read_stream", "publish_stream", "offline_access", etc. see
-     *            http://developers.facebook.com/docs/authentication/permissions
-     *            This parameter should not be null -- if you do not require any
-     *            permissions, then pass in an empty String array.
-     * @param activityCode
-     *            Single sign-on requires an activity result to be called back
-     *            to the client application -- if you are waiting on other
-     *            activities to return data, pass a custom activity code here to
-     *            avoid collisions. If you would like to force the use of legacy
-     *            dialog-based authorization, pass FORCE_DIALOG_AUTH for this
-     *            parameter. Otherwise just omit this parameter and Facebook
-     *            will use a suitable default. See
-     *            http://developer.android.com/reference/android/
-     *            app/Activity.html for more information.
-     * @param listener
-     *            Callback interface for notifying the calling application when
-     *            the authentication dialog has completed, failed, or been
-     *            canceled.
-     */
-    @Deprecated
-    public void authorize(Activity activity, String[] permissions, int activityCode, final DialogListener listener) {
-        SessionLoginBehavior behavior = (activityCode >= 0) ? SessionLoginBehavior.SSO_WITH_FALLBACK
-                : SessionLoginBehavior.SUPPRESS_SSO;
-
-        authorize(activity, permissions, activityCode, behavior, listener);
-    }
-
-    /**
-     * Full authorize method.
-     * 
-     * Starts either an Activity or a dialog which prompts the user to log in to
-     * Facebook and grant the requested permissions to the given application.
-     * 
-     * This method will, when possible, use Facebook's single sign-on for
-     * Android to obtain an access token. This involves proxying a call through
-     * the Facebook for Android stand-alone application, which will handle the
-     * authentication flow, and return an OAuth access token for making API
-     * calls.
-     * 
-     * Because this process will not be available for all users, if single
-     * sign-on is not possible, this method will automatically fall back to the
-     * OAuth 2.0 User-Agent flow. In this flow, the user credentials are handled
-     * by Facebook in an embedded WebView, not by the client application. As
-     * such, the dialog makes a network request and renders HTML content rather
-     * than a native UI. The access token is retrieved from a redirect to a
-     * special URL that the WebView handles.
-     * 
-     * Note that User credentials could be handled natively using the OAuth 2.0
-     * Username and Password Flow, but this is not supported by this SDK.
-     * 
-     * See http://developers.facebook.com/docs/authentication/ and
-     * http://wiki.oauth.net/OAuth-2 for more details.
-     * 
-     * Note that this method is asynchronous and the callback will be invoked in
-     * the original calling thread (not in a background thread).
-     * 
-     * Also note that requests may be made to the API without calling authorize
-     * first, in which case only public information is returned.
-     * 
-     * IMPORTANT: Note that single sign-on authentication will not function
-     * correctly if you do not include a call to the authorizeCallback() method
-     * in your onActivityResult() function! Please see below for more
-     * information. single sign-on may be disabled by passing FORCE_DIALOG_AUTH
-     * as the activityCode parameter in your call to authorize().
-     * 
-     * @param activity
-     *            The Android activity in which we want to display the
-     *            authorization dialog.
-     * @param permissions
-     *            A list of permissions required for this application: e.g.
-     *            "read_stream", "publish_stream", "offline_access", etc. see
-     *            http://developers.facebook.com/docs/authentication/permissions
-     *            This parameter should not be null -- if you do not require any
-     *            permissions, then pass in an empty String array.
-     * @param activityCode
-     *            Single sign-on requires an activity result to be called back
-     *            to the client application -- if you are waiting on other
-     *            activities to return data, pass a custom activity code here to
-     *            avoid collisions. If you would like to force the use of legacy
-     *            dialog-based authorization, pass FORCE_DIALOG_AUTH for this
-     *            parameter. Otherwise just omit this parameter and Facebook
-     *            will use a suitable default. See
-     *            http://developer.android.com/reference/android/
-     *            app/Activity.html for more information.
-     * @param behavior
-     *            The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *            specifies what behaviors should be attempted during
-     *            authorization.
-     * @param listener
-     *            Callback interface for notifying the calling application when
-     *            the authentication dialog has completed, failed, or been
-     *            canceled.
-     */
-    private void authorize(Activity activity, String[] permissions, int activityCode,
-                          SessionLoginBehavior behavior, final DialogListener listener) {
-        checkUserSession("authorize");
-        pendingOpeningSession = new Session.Builder(activity).
-                setApplicationId(mAppId).
-                setTokenCachingStrategy(getTokenCache()).
-                build();
-        pendingAuthorizationActivity = activity;
-        pendingAuthorizationPermissions = (permissions != null) ? permissions : new String[0];
-
-        StatusCallback callback = new StatusCallback() {
-            @Override
-            public void call(Session callbackSession, SessionState state, Exception exception) {
-                // Invoke user-callback.
-                onSessionCallback(callbackSession, state, exception, listener);
-            }
-        };
-
-        Session.OpenRequest openRequest = new Session.OpenRequest(activity).
-                setCallback(callback).
-                setLoginBehavior(behavior).
-                setRequestCode(activityCode).
-                setPermissions(Arrays.asList(permissions));
-        openSession(pendingOpeningSession, openRequest, pendingAuthorizationPermissions.length > 0);
-    }
-
-    private void openSession(Session session, Session.OpenRequest openRequest, boolean isPublish) {
-        openRequest.setIsLegacy(true);
-        if (isPublish) {
-            session.openForPublish(openRequest);
-        } else {
-            session.openForRead(openRequest);
-        }
-    }
-
-    @SuppressWarnings("deprecation")
-    private void onSessionCallback(Session callbackSession, SessionState state, Exception exception,
-            DialogListener listener) {
-        Bundle extras = callbackSession.getAuthorizationBundle();
-
-        if (state == SessionState.OPENED) {
-            Session sessionToClose = null;
-
-            synchronized (Facebook.this.lock) {
-                if (callbackSession != Facebook.this.session) {
-                    sessionToClose = Facebook.this.session;
-                    Facebook.this.session = callbackSession;
-                    Facebook.this.sessionInvalidated = false;
-                }
-            }
-
-            if (sessionToClose != null) {
-                sessionToClose.close();
-            }
-
-            listener.onComplete(extras);
-        } else if (exception != null) {
-            if (exception instanceof FacebookOperationCanceledException) {
-                listener.onCancel();
-            } else if ((exception instanceof FacebookAuthorizationException) && (extras != null)
-                    && extras.containsKey(Session.WEB_VIEW_ERROR_CODE_KEY)
-                    && extras.containsKey(Session.WEB_VIEW_FAILING_URL_KEY)) {
-                DialogError error = new DialogError(exception.getMessage(),
-                        extras.getInt(Session.WEB_VIEW_ERROR_CODE_KEY),
-                        extras.getString(Session.WEB_VIEW_FAILING_URL_KEY));
-                listener.onError(error);
-            } else {
-                FacebookError error = new FacebookError(exception.getMessage());
-                listener.onFacebookError(error);
-            }
-        }
-    }
-
-    /**
-     * Helper to validate a service intent by resolving and checking the
-     * provider's package signature.
-     * 
-     * @param context
-     * @param intent
-     * @return true if the service intent resolution happens successfully and
-     *         the signatures match.
-     */
-    private boolean validateServiceIntent(Context context, Intent intent) {
-        ResolveInfo resolveInfo = context.getPackageManager().resolveService(intent, 0);
-        if (resolveInfo == null) {
-            return false;
-        }
-
-        return validateAppSignatureForPackage(context, resolveInfo.serviceInfo.packageName);
-    }
-
-    /**
-     * Query the signature for the application that would be invoked by the
-     * given intent and verify that it matches the FB application's signature.
-     * 
-     * @param context
-     * @param packageName
-     * @return true if the app's signature matches the expected signature.
-     */
-    private boolean validateAppSignatureForPackage(Context context, String packageName) {
-
-        PackageInfo packageInfo;
-        try {
-            packageInfo = context.getPackageManager().getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
-        } catch (NameNotFoundException e) {
-            return false;
-        }
-
-        for (Signature signature : packageInfo.signatures) {
-            if (signature.toCharsString().equals(FB_APP_SIGNATURE)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * IMPORTANT: If you are using the deprecated authorize() method,
-     * this method must be invoked at the top of the calling
-     * activity's onActivityResult() function or Facebook authentication will
-     * not function properly!
-     * <p/>
-     * If your calling activity does not currently implement onActivityResult(),
-     * you must implement it and include a call to this method if you intend to
-     * use the authorize() method in this SDK.
-     * <p/>
-     * For more information, see
-     * http://developer.android.com/reference/android/app/
-     * Activity.html#onActivityResult(int, int, android.content.Intent)
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     */
-    @Deprecated
-    public void authorizeCallback(int requestCode, int resultCode, Intent data) {
-        checkUserSession("authorizeCallback");
-        Session pending = this.pendingOpeningSession;
-        if (pending != null) {
-            if (pending.onActivityResult(this.pendingAuthorizationActivity, requestCode, resultCode, data)) {
-                this.pendingOpeningSession = null;
-                this.pendingAuthorizationActivity = null;
-                this.pendingAuthorizationPermissions = null;
-            }
-        }
-    }
-
-    /**
-     * Refresh OAuth access token method. Binds to Facebook for Android
-     * stand-alone application application to refresh the access token. This
-     * method tries to connect to the Facebook App which will handle the
-     * authentication flow, and return a new OAuth access token. This method
-     * will automatically replace the old token with a new one. Note that this
-     * method is asynchronous and the callback will be invoked in the original
-     * calling thread (not in a background thread).
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param context
-     *            The Android Context that will be used to bind to the Facebook
-     *            RefreshToken Service
-     * @param serviceListener
-     *            Callback interface for notifying the calling application when
-     *            the refresh request has completed or failed (can be null). In
-     *            case of a success a new token can be found inside the result
-     *            Bundle under Facebook.ACCESS_TOKEN key.
-     * @return true if the binding to the RefreshToken Service was created
-     */
-    @Deprecated
-    public boolean extendAccessToken(Context context, ServiceListener serviceListener) {
-        checkUserSession("extendAccessToken");
-        Intent intent = new Intent();
-
-        intent.setClassName("com.facebook.katana", "com.facebook.katana.platform.TokenRefreshService");
-
-        // Verify that the application whose package name is
-        // com.facebook.katana
-        // has the expected FB app signature.
-        if (!validateServiceIntent(context, intent)) {
-            return false;
-        }
-
-        return context.bindService(intent, new TokenRefreshServiceConnection(context, serviceListener),
-                Context.BIND_AUTO_CREATE);
-    }
-
-    /**
-     * Calls extendAccessToken if shouldExtendAccessToken returns true.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @return the same value as extendAccessToken if the the token requires
-     *         refreshing, true otherwise
-     */
-    @Deprecated
-    public boolean extendAccessTokenIfNeeded(Context context, ServiceListener serviceListener) {
-        checkUserSession("extendAccessTokenIfNeeded");
-        if (shouldExtendAccessToken()) {
-            return extendAccessToken(context, serviceListener);
-        }
-        return true;
-    }
-
-    /**
-     * Check if the access token requires refreshing.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @return true if the last time a new token was obtained was over 24 hours
-     *         ago.
-     */
-    @Deprecated
-    public boolean shouldExtendAccessToken() {
-        checkUserSession("shouldExtendAccessToken");
-        return isSessionValid()
-                && (System.currentTimeMillis() - lastAccessUpdateMillisecondsAfterEpoch >= REFRESH_TOKEN_BARRIER);
-    }
-
-    /**
-     * Handles connection to the token refresh service (this service is a part
-     * of Facebook App).
-     */
-    private class TokenRefreshServiceConnection implements ServiceConnection {
-
-        final Messenger messageReceiver = new Messenger(
-                new TokenRefreshConnectionHandler(Facebook.this, this));
-
-        final ServiceListener serviceListener;
-        final Context applicationsContext;
-
-        Messenger messageSender = null;
-
-        public TokenRefreshServiceConnection(Context applicationsContext, ServiceListener serviceListener) {
-            this.applicationsContext = applicationsContext;
-            this.serviceListener = serviceListener;
-        }
-
-        @Override
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            messageSender = new Messenger(service);
-            refreshToken();
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName arg) {
-            serviceListener.onError(new Error("Service disconnected"));
-            // We returned an error so there's no point in
-            // keeping the binding open.
-            applicationsContext.unbindService(TokenRefreshServiceConnection.this);
-        }
-
-        private void refreshToken() {
-            Bundle requestData = new Bundle();
-            requestData.putString(TOKEN, accessToken);
-
-            Message request = Message.obtain();
-            request.setData(requestData);
-            request.replyTo = messageReceiver;
-
-            try {
-                messageSender.send(request);
-            } catch (RemoteException e) {
-                serviceListener.onError(new Error("Service connection error"));
-            }
-        }
-    }
-
-    // Creating a static Handler class to reduce the possibility of a memory leak.
-    // Handler objects for the same thread all share a common Looper object, which they post messages
-    // to and read from. As messages contain target Handler, as long as there are messages with target
-    // handler in the message queue, the handler cannot be garbage collected. If handler is not static,
-    // the instance of the containing class also cannot be garbage collected even if it is destroyed.
-    private static class TokenRefreshConnectionHandler extends Handler {
-        WeakReference<Facebook> facebookWeakReference;
-        WeakReference<TokenRefreshServiceConnection> connectionWeakReference;
-
-        TokenRefreshConnectionHandler(Facebook facebook, TokenRefreshServiceConnection connection) {
-            super();
-            facebookWeakReference = new WeakReference<Facebook>(facebook);
-            connectionWeakReference = new WeakReference<TokenRefreshServiceConnection>(connection);
-        }
-
-        @Override
-        @SuppressWarnings("deprecation")
-        public void handleMessage(Message msg) {
-            Facebook facebook = facebookWeakReference.get();
-            TokenRefreshServiceConnection connection = connectionWeakReference.get();
-            if (facebook == null || connection == null) {
-                return;
-            }
-
-            String token = msg.getData().getString(TOKEN);
-            // Legacy functions in Facebook class (and ServiceListener implementors) expect expires_in in
-            // milliseconds from epoch
-            long expiresAtMsecFromEpoch = msg.getData().getLong(EXPIRES) * 1000L;
-
-            if (token != null) {
-                facebook.setAccessToken(token);
-                facebook.setAccessExpires(expiresAtMsecFromEpoch);
-
-                Session refreshSession = facebook.session;
-                if (refreshSession != null) {
-                    // Session.internalRefreshToken expects the original bundle with expires_in in seconds from
-                    // epoch.
-                    LegacyHelper.extendTokenCompleted(refreshSession, msg.getData());
-                }
-
-                if (connection.serviceListener != null) {
-                    // To avoid confusion we should return the expiration time in
-                    // the same format as the getAccessExpires() function - that
-                    // is in milliseconds.
-                    Bundle resultBundle = (Bundle) msg.getData().clone();
-                    resultBundle.putLong(EXPIRES, expiresAtMsecFromEpoch);
-
-                    connection.serviceListener.onComplete(resultBundle);
-                }
-            } else if (connection.serviceListener != null) { // extract errors only if
-                // client wants them
-                String error = msg.getData().getString("error");
-                if (msg.getData().containsKey("error_code")) {
-                    int errorCode = msg.getData().getInt("error_code");
-                    connection.serviceListener.onFacebookError(new FacebookError(error, null, errorCode));
-                } else {
-                    connection.serviceListener.onError(new Error(error != null ? error : "Unknown service error"));
-                }
-            }
-
-            if (connection != null) {
-                // The refreshToken function should be called rarely,
-                // so there is no point in keeping the binding open.
-                connection.applicationsContext.unbindService(connection);
-            }
-        }
-    }
-
-    /**
-     * Invalidate the current user session by removing the access token in
-     * memory, clearing the browser cookie, and calling auth.expireSession
-     * through the API.
-     * <p/>
-     * Note that this method blocks waiting for a network response, so do not
-     * call it in a UI thread.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param context
-     *            The Android context in which the logout should be called: it
-     *            should be the same context in which the login occurred in
-     *            order to clear any stored cookies
-     * @throws IOException
-     * @throws MalformedURLException
-     * @return JSON string representation of the auth.expireSession response
-     *         ("true" if successful)
-     */
-    @Deprecated
-    public String logout(Context context) throws MalformedURLException, IOException {
-        return logoutImpl(context);
-    }
-
-    String logoutImpl(Context context) throws MalformedURLException, IOException  {
-        checkUserSession("logout");
-        Bundle b = new Bundle();
-        b.putString("method", "auth.expireSession");
-        String response = request(b);
-
-        long currentTimeMillis = System.currentTimeMillis();
-        Session sessionToClose = null;
-
-        synchronized (this.lock) {
-            sessionToClose = session;
-
-            session = null;
-            accessToken = null;
-            accessExpiresMillisecondsAfterEpoch = 0;
-            lastAccessUpdateMillisecondsAfterEpoch = currentTimeMillis;
-            sessionInvalidated = false;
-        }
-
-        if (sessionToClose != null) {
-            sessionToClose.closeAndClearTokenInformation();
-        }
-
-        return response;
-    }
-
-    /**
-     * Make a request to Facebook's old (pre-graph) API with the given
-     * parameters. One of the parameter keys must be "method" and its value
-     * should be a valid REST server API method.
-     * <p/>
-     * See http://developers.facebook.com/docs/reference/rest/
-     * <p/>
-     * Note that this method blocks waiting for a network response, so do not
-     * call it in a UI thread.
-     * <p/>
-     * Example: <code>
-     *  Bundle parameters = new Bundle();
-     *  parameters.putString("method", "auth.expireSession");
-     *  String response = request(parameters);
-     * </code>
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
-     *
-     * @param parameters
-     *            Key-value pairs of parameters to the request. Refer to the
-     *            documentation: one of the parameters must be "method".
-     * @throws IOException
-     *             if a network error occurs
-     * @throws MalformedURLException
-     *             if accessing an invalid endpoint
-     * @throws IllegalArgumentException
-     *             if one of the parameters is not "method"
-     * @return JSON string representation of the response
-     */
-    @Deprecated
-    public String request(Bundle parameters) throws MalformedURLException, IOException {
-        if (!parameters.containsKey("method")) {
-            throw new IllegalArgumentException("API method must be specified. "
-                    + "(parameters must contain key \"method\" and value). See"
-                    + " http://developers.facebook.com/docs/reference/rest/");
-        }
-        return requestImpl(null, parameters, "GET");
-    }
-
-    /**
-     * Make a request to the Facebook Graph API without any parameters.
-     * <p/>
-     * See http://developers.facebook.com/docs/api
-     * <p/>
-     * Note that this method blocks waiting for a network response, so do not
-     * call it in a UI thread.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
-     *
-     * @param graphPath
-     *            Path to resource in the Facebook graph, e.g., to fetch data
-     *            about the currently logged authenticated user, provide "me",
-     *            which will fetch http://graph.facebook.com/me
-     * @throws IOException
-     * @throws MalformedURLException
-     * @return JSON string representation of the response
-     */
-    @Deprecated
-    public String request(String graphPath) throws MalformedURLException, IOException {
-        return requestImpl(graphPath, new Bundle(), "GET");
-    }
-
-    /**
-     * Make a request to the Facebook Graph API with the given string parameters
-     * using an HTTP GET (default method).
-     * <p/>
-     * See http://developers.facebook.com/docs/api
-     * <p/>
-     * Note that this method blocks waiting for a network response, so do not
-     * call it in a UI thread.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
-     *
-     * @param graphPath
-     *            Path to resource in the Facebook graph, e.g., to fetch data
-     *            about the currently logged authenticated user, provide "me",
-     *            which will fetch http://graph.facebook.com/me
-     * @param parameters
-     *            key-value string parameters, e.g. the path "search" with
-     *            parameters "q" : "facebook" would produce a query for the
-     *            following graph resource:
-     *            https://graph.facebook.com/search?q=facebook
-     * @throws IOException
-     * @throws MalformedURLException
-     * @return JSON string representation of the response
-     */
-    @Deprecated
-    public String request(String graphPath, Bundle parameters) throws MalformedURLException, IOException {
-        return requestImpl(graphPath, parameters, "GET");
-    }
-
-    /**
-     * Synchronously make a request to the Facebook Graph API with the given
-     * HTTP method and string parameters. Note that binary data parameters (e.g.
-     * pictures) are not yet supported by this helper function.
-     * <p/>
-     * See http://developers.facebook.com/docs/api
-     * <p/>
-     * Note that this method blocks waiting for a network response, so do not
-     * call it in a UI thread.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Request} for more info.
-     *
-     * @param graphPath
-     *            Path to resource in the Facebook graph, e.g., to fetch data
-     *            about the currently logged authenticated user, provide "me",
-     *            which will fetch http://graph.facebook.com/me
-     * @param params
-     *            Key-value string parameters, e.g. the path "search" with
-     *            parameters {"q" : "facebook"} would produce a query for the
-     *            following graph resource:
-     *            https://graph.facebook.com/search?q=facebook
-     * @param httpMethod
-     *            http verb, e.g. "GET", "POST", "DELETE"
-     * @throws IOException
-     * @throws MalformedURLException
-     * @return JSON string representation of the response
-     */
-    @Deprecated
-    public String request(String graphPath, Bundle params, String httpMethod) throws FileNotFoundException,
-            MalformedURLException, IOException {
-        return requestImpl(graphPath, params, httpMethod);
-    }
-
-    // Internal call to avoid deprecated warnings.
-    @SuppressWarnings("deprecation")
-    String requestImpl(String graphPath, Bundle params, String httpMethod) throws FileNotFoundException,
-            MalformedURLException, IOException {
-        params.putString("format", "json");
-        if (isSessionValid()) {
-            params.putString(TOKEN, getAccessToken());
-        }
-        String url = (graphPath != null) ? GRAPH_BASE_URL + graphPath : RESTSERVER_URL;
-        return Util.openUrl(url, httpMethod, params);
-    }
-
-    /**
-     * Generate a UI dialog for the request action in the given Android context.
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked in
-     * the original calling thread (not in a background thread).
-     *
-     * This method is deprecated. See {@link com.facebook.widget.WebDialog}.
-     *
-     * @param context
-     *            The Android context in which we will generate this dialog.
-     * @param action
-     *            String representation of the desired method: e.g. "login",
-     *            "stream.publish", ...
-     * @param listener
-     *            Callback interface to notify the application when the dialog
-     *            has completed.
-     */
-    @Deprecated
-    public void dialog(Context context, String action, DialogListener listener) {
-        dialog(context, action, new Bundle(), listener);
-    }
-
-    /**
-     * Generate a UI dialog for the request action in the given Android context
-     * with the provided parameters.
-     * <p/>
-     * Note that this method is asynchronous and the callback will be invoked in
-     * the original calling thread (not in a background thread).
-     *
-     * This method is deprecated. See {@link com.facebook.widget.WebDialog}.
-     * 
-     * @param context
-     *            The Android context in which we will generate this dialog.
-     * @param action
-     *            String representation of the desired method: e.g. "feed" ...
-     * @param parameters
-     *            String key-value pairs to be passed as URL parameters.
-     * @param listener
-     *            Callback interface to notify the application when the dialog
-     *            has completed.
-     */
-    @Deprecated
-    public void dialog(Context context, String action, Bundle parameters, final DialogListener listener) {
-        parameters.putString("display", "touch");
-        parameters.putString("redirect_uri", REDIRECT_URI);
-
-        if (action.equals(LOGIN)) {
-            parameters.putString("type", "user_agent");
-            parameters.putString("client_id", mAppId);
-        } else {
-            parameters.putString("app_id", mAppId);
-            // We do not want to add an access token when displaying the auth dialog.
-            if (isSessionValid()) {
-                parameters.putString(TOKEN, getAccessToken());
-            }
-        }
-
-        if (context.checkCallingOrSelfPermission(Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED) {
-            Util.showAlert(context, "Error", "Application requires permission to access the Internet");
-        } else {
-            new FbDialog(context, action, parameters, listener).show();
-        }
-    }
-
-    /**
-     * Returns whether the current access token is valid
-     *
-     * @return boolean - whether this object has an non-expired session token
-     */
-    @Deprecated
-    public boolean isSessionValid() {
-        return (getAccessToken() != null)
-                && ((getAccessExpires() == 0) || (System.currentTimeMillis() < getAccessExpires()));
-    }
-
-    /**
-     * Allows the user to set a Session for the Facebook class to use.
-     * If a Session is set here, then one should not use the authorize, logout,
-     * or extendAccessToken methods which alter the Session object since that may
-     * result in undefined behavior. Using those methods after setting the
-     * session here will result in exceptions being thrown.
-     *
-     * @param session the Session object to use, cannot be null
-     */
-    @Deprecated
-    public void setSession(Session session) {
-        if (session == null) {
-            throw new IllegalArgumentException("session cannot be null");
-        }
-        synchronized (this.lock) {
-            this.userSetSession = session;
-        }
-    }
-
-    private void checkUserSession(String methodName) {
-        if (userSetSession != null) {
-            throw new UnsupportedOperationException(
-                    String.format("Cannot call %s after setSession has been called.", methodName));
-        }
-    }
-
-    /**
-     * Get the underlying Session object to use with 3.0 api.
-     * 
-     * @return Session - underlying session
-     */
-    @Deprecated
-    public final Session getSession() {
-        while (true) {
-            String cachedToken = null;
-            Session oldSession = null;
-
-            synchronized (this.lock) {
-                if (userSetSession != null) {
-                    return userSetSession;
-                }
-                if ((session != null) || !sessionInvalidated) {
-                    return session;
-                }
-
-                cachedToken = accessToken;
-                oldSession = session;
-            }
-
-            if (cachedToken == null) {
-                return null;
-            }
-
-            // At this point we do not have a valid session, but mAccessToken is
-            // non-null.
-            // So we can try building a session based on that.
-            List<String> permissions;
-            if (oldSession != null) {
-                permissions = oldSession.getPermissions();
-            } else if (pendingAuthorizationPermissions != null) {
-                permissions = Arrays.asList(pendingAuthorizationPermissions);
-            } else {
-                permissions = Collections.<String>emptyList();
-            }
-
-            Session newSession = new Session.Builder(pendingAuthorizationActivity).
-                    setApplicationId(mAppId).
-                    setTokenCachingStrategy(getTokenCache()).
-                    build();
-            if (newSession.getState() != SessionState.CREATED_TOKEN_LOADED) {
-                return null;
-            }
-            Session.OpenRequest openRequest =
-                    new Session.OpenRequest(pendingAuthorizationActivity).setPermissions(permissions);
-            openSession(newSession, openRequest, !permissions.isEmpty());
-
-            Session invalidatedSession = null;
-            Session returnSession = null;
-
-            synchronized (this.lock) {
-                if (sessionInvalidated || (session == null)) {
-                    invalidatedSession = session;
-                    returnSession = session = newSession;
-                    sessionInvalidated = false;
-                }
-            }
-
-            if (invalidatedSession != null) {
-                invalidatedSession.close();
-            }
-
-            if (returnSession != null) {
-                return returnSession;
-            }
-            // Else token state changed between the synchronized blocks, so
-            // retry..
-        }
-    }
-
-    /**
-     * Retrieve the OAuth 2.0 access token for API access: treat with care.
-     * Returns null if no session exists.
-     *
-     * @return String - access token
-     */
-    @Deprecated
-    public String getAccessToken() {
-        Session s = getSession();
-        if (s != null) {
-            return s.getAccessToken();
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Retrieve the current session's expiration time (in milliseconds since
-     * Unix epoch), or 0 if the session doesn't expire or doesn't exist.
-     *
-     * @return long - session expiration time
-     */
-    @Deprecated
-    public long getAccessExpires() {
-        Session s = getSession();
-        if (s != null) {
-            return s.getExpirationDate().getTime();
-        } else {
-            return accessExpiresMillisecondsAfterEpoch;
-        }
-    }
-
-    /**
-     * Retrieve the last time the token was updated (in milliseconds since
-     * the Unix epoch), or 0 if the token has not been set.
-     *
-     * @return long - timestamp of the last token update.
-     */
-    @Deprecated
-    public long getLastAccessUpdate() {
-        return lastAccessUpdateMillisecondsAfterEpoch;
-    }
-
-    /**
-     * Restore the token, expiration time, and last update time from cached values.
-     * These should be values obtained from getAccessToken(), getAccessExpires, and
-     * getLastAccessUpdate() respectively.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param accessToken - access token
-     * @param accessExpires - access token expiration time
-     * @param lastAccessUpdate - timestamp of the last token update
-     */
-    @Deprecated
-    public void setTokenFromCache(String accessToken, long accessExpires, long lastAccessUpdate) {
-        checkUserSession("setTokenFromCache");
-        synchronized (this.lock) {
-            this.accessToken = accessToken;
-            accessExpiresMillisecondsAfterEpoch = accessExpires;
-            lastAccessUpdateMillisecondsAfterEpoch = lastAccessUpdate;
-        }
-    }
-
-    /**
-     * Set the OAuth 2.0 access token for API access.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param token
-     *            - access token
-     */
-    @Deprecated
-    public void setAccessToken(String token) {
-        checkUserSession("setAccessToken");
-        synchronized (this.lock) {
-            accessToken = token;
-            lastAccessUpdateMillisecondsAfterEpoch = System.currentTimeMillis();
-            sessionInvalidated = true;
-        }
-    }
-
-    /**
-     * Set the current session's expiration time (in milliseconds since Unix
-     * epoch), or 0 if the session doesn't expire.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param timestampInMsec
-     *            - timestamp in milliseconds
-     */
-    @Deprecated
-    public void setAccessExpires(long timestampInMsec) {
-        checkUserSession("setAccessExpires");
-        synchronized (this.lock) {
-            accessExpiresMillisecondsAfterEpoch = timestampInMsec;
-            lastAccessUpdateMillisecondsAfterEpoch = System.currentTimeMillis();
-            sessionInvalidated = true;
-        }
-    }
-
-    /**
-     * Set the current session's duration (in seconds since Unix epoch), or "0"
-     * if session doesn't expire.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param expiresInSecsFromNow
-     *            - duration in seconds (or 0 if the session doesn't expire)
-     */
-    @Deprecated
-    public void setAccessExpiresIn(String expiresInSecsFromNow) {
-        checkUserSession("setAccessExpiresIn");
-        if (expiresInSecsFromNow != null) {
-            long expires = expiresInSecsFromNow.equals("0") ? 0 : System.currentTimeMillis()
-                    + Long.parseLong(expiresInSecsFromNow) * 1000L;
-            setAccessExpires(expires);
-        }
-    }
-
-    /**
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @return the String representing application ID
-     */
-    @Deprecated
-    public String getAppId() {
-        return mAppId;
-    }
-
-    /**
-     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.
-     *
-     * @param appId the String representing the application ID
-     */
-    @Deprecated
-    public void setAppId(String appId) {
-        checkUserSession("setAppId");
-        synchronized (this.lock) {
-            mAppId = appId;
-            sessionInvalidated = true;
-        }
-    }
-
-    private TokenCachingStrategy getTokenCache() {
-        // Intentionally not volatile/synchronized--it is okay if we race to
-        // create more than one of these.
-        if (tokenCache == null) {
-            tokenCache = new SetterTokenCachingStrategy();
-        }
-        return tokenCache;
-    }
-
-    private static String[] stringArray(List<String> list) {
-        String[] array = new String[list.size()];
-
-        if (list != null) {
-            for (int i = 0; i < array.length; i++) {
-                array[i] = list.get(i);
-            }
-        }
-
-        return array;
-    }
-
-    private static List<String> stringList(String[] array) {
-        if (array != null) {
-            return Arrays.asList(array);
-        } else {
-            return Collections.emptyList();
-        }
-    }
-
-    private class SetterTokenCachingStrategy extends TokenCachingStrategy {
-
-        @Override
-        public Bundle load() {
-            Bundle bundle = new Bundle();
-
-            if (accessToken != null) {
-                TokenCachingStrategy.putToken(bundle, accessToken);
-                TokenCachingStrategy.putExpirationMilliseconds(bundle, accessExpiresMillisecondsAfterEpoch);
-                TokenCachingStrategy.putPermissions(bundle, stringList(pendingAuthorizationPermissions));
-                TokenCachingStrategy.putSource(bundle, AccessTokenSource.WEB_VIEW);
-                TokenCachingStrategy.putLastRefreshMilliseconds(bundle, lastAccessUpdateMillisecondsAfterEpoch);
-            }
-
-            return bundle;
-        }
-
-        @Override
-        public void save(Bundle bundle) {
-            accessToken = TokenCachingStrategy.getToken(bundle);
-            accessExpiresMillisecondsAfterEpoch = TokenCachingStrategy.getExpirationMilliseconds(bundle);
-            pendingAuthorizationPermissions = stringArray(TokenCachingStrategy.getPermissions(bundle));
-            lastAccessUpdateMillisecondsAfterEpoch = TokenCachingStrategy.getLastRefreshMilliseconds(bundle);
-        }
-
-        @Override
-        public void clear() {
-            accessToken = null;
-        }
-    }
-
-    /**
-     * Get Attribution ID for app install conversion tracking.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
-     *
-     * @param contentResolver
-     * @return Attribution ID that will be used for conversion tracking. It will be null only if
-     *         the user has not installed or logged in to the Facebook app.
-     */
-    @Deprecated
-    public static String getAttributionId(ContentResolver contentResolver) {
-        return Settings.getAttributionId(contentResolver);
-    }
-
-    /**
-     * Get the auto install publish setting.  If true, an install event will be published during authorize(), unless
-     * it has occurred previously or the app does not have install attribution enabled on the application's developer
-     * config page.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
-     *
-     * @return a Boolean indicating whether installation of the app should be auto-published.
-     */
-    @Deprecated
-    public boolean getShouldAutoPublishInstall() {
-        return Settings.getShouldAutoPublishInstall();
-    }
-
-    /**
-     * Sets whether auto publishing of installs will occur.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
-     *
-     * @param value a Boolean indicating whether installation of the app should be auto-published.
-     */
-    @Deprecated
-    public void setShouldAutoPublishInstall(boolean value) {
-        Settings.setShouldAutoPublishInstall(value);
-    }
-
-    /**
-     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
-     * multiple installs being published to the graph.
-     * <p/>
-     * This method is deprecated.  See {@link Facebook} and {@link Settings} for more info.
-     *
-     * @param context the current Android context
-     * @return Always false.  Earlier versions of the API returned true if it was no longer necessary to call.
-     * Apps should ignore this value, but for compatibility we will return false to ensure repeat calls (and the
-     * underlying code will prevent duplicate network traffic).
-     */
-    @Deprecated
-    public boolean publishInstall(final Context context) {
-        Settings.publishInstallAsync(context, mAppId);
-        return false;
-    }
-
-    /**
-     * Callback interface for dialog requests.
-     * <p/>
-     * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
-     * <p/>
-     * All public members of this class are intentionally deprecated.
-     * New code should instead use
-     * {@link com.facebook.widget.WebDialog}
-     * <p/>
-     * Adding @Deprecated to this class causes warnings in other deprecated classes
-     * that reference this one.  That is the only reason this entire class is not
-     * deprecated.
-     *
-     * @devDocDeprecated
-     */
-    public static interface DialogListener {
-
-        /**
-         * Called when a dialog completes.
-         * 
-         * Executed by the thread that initiated the dialog.
-         * 
-         * @param values
-         *            Key-value string pairs extracted from the response.
-         */
-        public void onComplete(Bundle values);
-
-        /**
-         * Called when a Facebook responds to a dialog with an error.
-         * 
-         * Executed by the thread that initiated the dialog.
-         * 
-         */
-        public void onFacebookError(FacebookError e);
-
-        /**
-         * Called when a dialog has an error.
-         * 
-         * Executed by the thread that initiated the dialog.
-         * 
-         */
-        public void onError(DialogError e);
-
-        /**
-         * Called when a dialog is canceled by the user.
-         * 
-         * Executed by the thread that initiated the dialog.
-         * 
-         */
-        public void onCancel();
-
-    }
-
-    /**
-     * Callback interface for service requests.
-     * <p/>
-     * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
-     * <p/>
-     * All public members of this class are intentionally deprecated.
-     * New code should instead use
-     * {@link Session} to manage session state.
-     * <p/>
-     * Adding @Deprecated to this class causes warnings in other deprecated classes
-     * that reference this one.  That is the only reason this entire class is not
-     * deprecated.
-     *
-     * @devDocDeprecated
-     */
-    public static interface ServiceListener {
-
-        /**
-         * Called when a service request completes.
-         * 
-         * @param values
-         *            Key-value string pairs extracted from the response.
-         */
-        public void onComplete(Bundle values);
-
-        /**
-         * Called when a Facebook server responds to the request with an error.
-         */
-        public void onFacebookError(FacebookError e);
-
-        /**
-         * Called when a Facebook Service responds to the request with an error.
-         */
-        public void onError(Error e);
-
-    }
-
-    @Deprecated
-    public static final String FB_APP_SIGNATURE =
-        "30820268308201d102044a9c4610300d06092a864886f70d0101040500307a310"
-        + "b3009060355040613025553310b30090603550408130243413112301006035504"
-        + "07130950616c6f20416c746f31183016060355040a130f46616365626f6f6b204"
-        + "d6f62696c653111300f060355040b130846616365626f6f6b311d301b06035504"
-        + "03131446616365626f6f6b20436f72706f726174696f6e3020170d30393038333"
-        + "13231353231365a180f32303530303932353231353231365a307a310b30090603"
-        + "55040613025553310b30090603550408130243413112301006035504071309506"
-        + "16c6f20416c746f31183016060355040a130f46616365626f6f6b204d6f62696c"
-        + "653111300f060355040b130846616365626f6f6b311d301b06035504031314466"
-        + "16365626f6f6b20436f72706f726174696f6e30819f300d06092a864886f70d01"
-        + "0101050003818d0030818902818100c207d51df8eb8c97d93ba0c8c1002c928fa"
-        + "b00dc1b42fca5e66e99cc3023ed2d214d822bc59e8e35ddcf5f44c7ae8ade50d7"
-        + "e0c434f500e6c131f4a2834f987fc46406115de2018ebbb0d5a3c261bd97581cc"
-        + "fef76afc7135a6d59e8855ecd7eacc8f8737e794c60a761c536b72b11fac8e603"
-        + "f5da1a2d54aa103b8a13c0dbc10203010001300d06092a864886f70d010104050"
-        + "0038181005ee9be8bcbb250648d3b741290a82a1c9dc2e76a0af2f2228f1d9f9c"
-        + "4007529c446a70175c5a900d5141812866db46be6559e2141616483998211f4a6"
-        + "73149fb2232a10d247663b26a9031e15f84bc1c74d141ff98a02d76f85b2c8ab2"
-        + "571b6469b232d8e768a7f7ca04f7abe4a775615916c07940656b58717457b42bd"
-        + "928a2";
-
-}
diff --git a/facebook/src/com/facebook/android/FacebookError.java b/facebook/src/com/facebook/android/FacebookError.java
deleted file mode 100644
index 41ae794fc..000000000
--- a/facebook/src/com/facebook/android/FacebookError.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * Copyright 2010-present Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-/**
- * Encapsulation of a Facebook Error: a Facebook request that could not be
- * fulfilled.
- * <p/>
- * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
- * <p/>
- * All public members of this class are intentionally deprecated.
- * New code should instead use
- * {@link com.facebook.FacebookException}
- * <p/>
- * Adding @Deprecated to this class causes warnings in other deprecated classes
- * that reference this one.  That is the only reason this entire class is not
- * deprecated.
- *
- * @devDocDeprecated
- */
-public class FacebookError extends RuntimeException {
-
-    private static final long serialVersionUID = 1L;
-
-    private int mErrorCode = 0;
-    private String mErrorType;
-
-    @Deprecated
-    public FacebookError(String message) {
-        super(message);
-    }
-
-    @Deprecated
-    public FacebookError(String message, String type, int code) {
-        super(message);
-        mErrorType = type;
-        mErrorCode = code;
-    }
-
-    @Deprecated
-    public int getErrorCode() {
-        return mErrorCode;
-    }
-
-    @Deprecated
-    public String getErrorType() {
-        return mErrorType;
-    }
-
-}
diff --git a/facebook/src/com/facebook/android/FbDialog.java b/facebook/src/com/facebook/android/FbDialog.java
deleted file mode 100644
index 603e69280..000000000
--- a/facebook/src/com/facebook/android/FbDialog.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/**
- * Copyright 2010-present Facebook
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.android;
-
-import android.content.Context;
-import android.os.Bundle;
-import com.facebook.*;
-import com.facebook.android.Facebook.DialogListener;
-import com.facebook.widget.WebDialog;
-
-/**
- * This class is deprecated. See {@link com.facebook.widget.WebDialog}.
- */
-@Deprecated
-public class FbDialog extends WebDialog {
-    private DialogListener mListener;
-
-    public FbDialog(Context context, String url, DialogListener listener) {
-        this(context, url, listener, DEFAULT_THEME);
-    }
-
-    public FbDialog(Context context, String url, DialogListener listener, int theme) {
-        super(context, url, theme);
-        setDialogListener(listener);
-    }
-
-    public FbDialog(Context context, String action, Bundle parameters, DialogListener listener) {
-        super(context, action, parameters, DEFAULT_THEME, null);
-        setDialogListener(listener);
-    }
-
-    public FbDialog(Context context, String action, Bundle parameters, DialogListener listener,
-            int theme) {
-        super(context, action, parameters, theme, null);
-        setDialogListener(listener);
-    }
-
-    private void setDialogListener(DialogListener listener) {
-        this.mListener = listener;
-        setOnCompleteListener(new OnCompleteListener() {
-            @Override
-            public void onComplete(Bundle values, FacebookException error) {
-                callDialogListener(values, error);
-            }
-        });
-    }
-
-    private void callDialogListener(Bundle values, FacebookException error) {
-        if (mListener == null) {
-            return;
-        }
-
-        if (values != null) {
-            mListener.onComplete(values);
-        } else {
-            if (error instanceof FacebookDialogException) {
-                FacebookDialogException facebookDialogException = (FacebookDialogException) error;
-                DialogError dialogError = new DialogError(facebookDialogException.getMessage(),
-                        facebookDialogException.getErrorCode(), facebookDialogException.getFailingUrl());
-                mListener.onError(dialogError);
-            } else if (error instanceof FacebookOperationCanceledException) {
-                mListener.onCancel();
-            } else {
-                FacebookError facebookError = new FacebookError(error.getMessage());
-                mListener.onFacebookError(facebookError);
-            }
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/widget/UserSettingsFragment.java b/facebook/src/com/facebook/widget/UserSettingsFragment.java
deleted file mode 100644
index 3ba4359d9..000000000
--- a/facebook/src/com/facebook/widget/UserSettingsFragment.java
+++ /dev/null
@@ -1,394 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.os.Bundle;
-import android.text.TextUtils;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.TextView;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.model.GraphUser;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.List;
-
-/**
- * A Fragment that displays a Login/Logout button as well as the user's
- * profile picture and name when logged in.
- * <p/>
- * This Fragment will create and use the active session upon construction
- * if it has the available data (if the app ID is specified in the manifest).
- * It will also open the active session if it does not require user interaction
- * (i.e. if the session is in the {@link com.facebook.SessionState#CREATED_TOKEN_LOADED} state.
- * Developers can override the use of the active session by calling
- * the {@link #setSession(com.facebook.Session)} method.
- */
-public class UserSettingsFragment extends FacebookFragment {
-
-    private static final String NAME = "name";
-    private static final String ID = "id";
-    private static final String PICTURE = "picture";
-    private static final String FIELDS = "fields";
-    
-    private static final String REQUEST_FIELDS = TextUtils.join(",", new String[] {ID, NAME, PICTURE});
-
-    private LoginButton loginButton;
-    private LoginButton.LoginButtonProperties loginButtonProperties = new LoginButton.LoginButtonProperties();
-    private TextView connectedStateLabel;
-    private GraphUser user;
-    private Session userInfoSession; // the Session used to fetch the current user info
-    private Drawable userProfilePic;
-    private String userProfilePicID;
-    private Session.StatusCallback sessionStatusCallback;
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        View view = inflater.inflate(R.layout.com_facebook_usersettingsfragment, container, false);
-        loginButton = (LoginButton) view.findViewById(R.id.com_facebook_usersettingsfragment_login_button);
-        loginButton.setProperties(loginButtonProperties);
-        loginButton.setFragment(this);
-        Session session = getSession();
-        if (session != null && !session.equals(Session.getActiveSession())) {
-            loginButton.setSession(session);
-        }
-        connectedStateLabel = (TextView) view.findViewById(R.id.com_facebook_usersettingsfragment_profile_name);
-        
-        // if no background is set for some reason, then default to Facebook blue
-        if (view.getBackground() == null) {
-            view.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
-        } else {
-            view.getBackground().setDither(true);
-        }
-        return view;
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setRetainInstance(true);
-    }
-
-    /**
-     * @throws com.facebook.FacebookException if errors occur during the loading of user information
-     */
-    @Override
-    public void onResume() {
-        super.onResume();
-        fetchUserInfo();
-        updateUI();
-    }
-
-    /**
-     * Set the Session object to use instead of the active Session. Since a Session
-     * cannot be reused, if the user logs out from this Session, and tries to
-     * log in again, a new Active Session will be used instead.
-     * <p/>
-     * If the passed in session is currently opened, this method will also attempt to
-     * load some user information for display (if needed).
-     *
-     * @param newSession the Session object to use
-     * @throws com.facebook.FacebookException if errors occur during the loading of user information
-     */
-    @Override
-    public void setSession(Session newSession) {
-        super.setSession(newSession);
-        if (loginButton != null) {
-            loginButton.setSession(newSession);
-        }
-        fetchUserInfo();
-        updateUI();
-    }
-
-    /**
-     * Sets the default audience to use when the session is opened.
-     * This value is only useful when specifying write permissions for the native
-     * login dialog.
-     *
-     * @param defaultAudience the default audience value to use
-     */
-    public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
-        loginButtonProperties.setDefaultAudience(defaultAudience);
-    }
-
-    /**
-     * Gets the default audience to use when the session is opened.
-     * This value is only useful when specifying write permissions for the native
-     * login dialog.
-     *
-     * @return the default audience value to use
-     */
-    public SessionDefaultAudience getDefaultAudience() {
-        return loginButtonProperties.getDefaultAudience();
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * can only be read permissions. If any publish permissions are included, the login
-     * attempt by the user will fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the UserSettingsFragment is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setPublishPermissions has been called
-     */
-    public void setReadPermissions(List<String> permissions) {
-        loginButtonProperties.setReadPermissions(permissions, getSession());
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * should only be publish permissions. If any read permissions are included, the login
-     * attempt by the user may fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setReadPermissions has been called
-     * @throws IllegalArgumentException if permissions is null or empty
-     */
-    public void setPublishPermissions(List<String> permissions) {
-        loginButtonProperties.setPublishPermissions(permissions, getSession());
-    }
-
-
-    /**
-     * Clears the permissions currently associated with this LoginButton.
-     */
-    public void clearPermissions() {
-        loginButtonProperties.clearPermissions();
-    }
-
-    /**
-     * Sets the login behavior for the session that will be opened. If null is specified,
-     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
-     * will be used.
-     *
-     * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *                      specifies what behaviors should be attempted during
-     *                      authorization.
-     */
-    public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
-        loginButtonProperties.setLoginBehavior(loginBehavior);
-    }
-
-    /**
-     * Gets the login behavior for the session that will be opened. If null is returned,
-     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
-     * will be used.
-     *
-     * @return loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *                      specifies what behaviors should be attempted during
-     *                      authorization.
-     */
-    public SessionLoginBehavior getLoginBehavior() {
-        return loginButtonProperties.getLoginBehavior();
-    }
-
-    /**
-     * Sets an OnErrorListener for this instance of UserSettingsFragment to call into when
-     * certain exceptions occur.
-     *
-     * @param onErrorListener The listener object to set
-     */
-    public void setOnErrorListener(LoginButton.OnErrorListener onErrorListener) {
-        loginButtonProperties.setOnErrorListener(onErrorListener);
-    }
-
-    /**
-     * Returns the current OnErrorListener for this instance of UserSettingsFragment.
-     *
-     * @return The OnErrorListener
-     */
-    public LoginButton.OnErrorListener getOnErrorListener() {
-        return loginButtonProperties.getOnErrorListener();
-    }
-
-    /**
-     * Sets the callback interface that will be called whenever the status of the Session
-     * associated with this LoginButton changes.
-     *
-     * @param callback the callback interface
-     */
-    public void setSessionStatusCallback(Session.StatusCallback callback) {
-        this.sessionStatusCallback = callback;
-    }
-
-    /**
-     * Sets the callback interface that will be called whenever the status of the Session
-     * associated with this LoginButton changes.
-
-     * @return the callback interface
-     */
-    public Session.StatusCallback getSessionStatusCallback() {
-        return sessionStatusCallback;
-    }
-
-    @Override
-    protected void onSessionStateChange(SessionState state, Exception exception) {
-        fetchUserInfo();
-        updateUI();
-
-        if (sessionStatusCallback != null) {
-            sessionStatusCallback.call(getSession(), state, exception);
-        }
-    }
-
-    // For Testing Only
-    List<String> getPermissions() {
-        return loginButtonProperties.getPermissions();
-    }
-    
-    private void fetchUserInfo() {
-        final Session currentSession = getSession();
-        if (currentSession != null && currentSession.isOpened()) {
-            if (currentSession != userInfoSession) {
-                Request request = Request.newMeRequest(currentSession, new Request.GraphUserCallback() {
-                    @Override
-                    public void onCompleted(GraphUser me, Response response) {
-                        if (currentSession == getSession()) {
-                            user = me;
-                            updateUI();
-                        }
-                        if (response.getError() != null) {
-                            loginButton.handleError(response.getError().getException());
-                        }
-                    }
-                });
-                Bundle parameters = new Bundle();
-                parameters.putString(FIELDS, REQUEST_FIELDS);
-                request.setParameters(parameters);
-                Request.executeBatchAsync(request);
-                userInfoSession = currentSession;
-            }
-        } else {
-            user = null;
-        }
-    }
-    
-    private void updateUI() {
-        if (!isAdded()) {
-            return;
-        }
-        if (isSessionOpen()) {
-            connectedStateLabel.setTextColor(getResources().getColor(R.color.com_facebook_usersettingsfragment_connected_text_color));
-            connectedStateLabel.setShadowLayer(1f, 0f, -1f,
-                    getResources().getColor(R.color.com_facebook_usersettingsfragment_connected_shadow_color));
-            
-            if (user != null) {
-                ImageRequest request = getImageRequest();
-                if (request != null) {
-                    URL requestUrl = request.getImageUrl();
-                    // Do we already have the right picture? If so, leave it alone.
-                    if (!requestUrl.equals(connectedStateLabel.getTag())) {
-                        if (user.getId().equals(userProfilePicID)) {
-                            connectedStateLabel.setCompoundDrawables(null, userProfilePic, null, null);
-                            connectedStateLabel.setTag(requestUrl);
-                        } else {
-                            ImageDownloader.downloadAsync(request);
-                        }
-                    }
-                }
-                connectedStateLabel.setText(user.getName());
-            } else {
-                connectedStateLabel.setText(getResources().getString(
-                        R.string.com_facebook_usersettingsfragment_logged_in));
-                Drawable noProfilePic = getResources().getDrawable(R.drawable.com_facebook_profile_default_icon);
-                noProfilePic.setBounds(0, 0,
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height));
-                connectedStateLabel.setCompoundDrawables(null, noProfilePic, null, null);
-            }
-        } else {
-            int textColor = getResources().getColor(R.color.com_facebook_usersettingsfragment_not_connected_text_color);
-            connectedStateLabel.setTextColor(textColor);
-            connectedStateLabel.setShadowLayer(0f, 0f, 0f, textColor);
-            connectedStateLabel.setText(getResources().getString(
-                    R.string.com_facebook_usersettingsfragment_not_logged_in));
-            connectedStateLabel.setCompoundDrawables(null, null, null, null);
-            connectedStateLabel.setTag(null);
-        }
-    }
-
-    private ImageRequest getImageRequest() {
-        ImageRequest request = null;
-        try {
-            ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
-                    getActivity(),
-                    ImageRequest.getProfilePictureUrl(
-                            user.getId(),
-                            getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
-                            getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height)));
-
-            request = requestBuilder.setCallerTag(this)
-                    .setCallback(
-                            new ImageRequest.Callback() {
-                                @Override
-                                public void onCompleted(ImageResponse response) {
-                                    processImageResponse(user.getId(), response);
-                                }
-                            })
-                    .build();
-        } catch (MalformedURLException e) {
-        }
-        return request;
-    }
-
-    private void processImageResponse(String id, ImageResponse response) {
-        if (response != null) {
-            Bitmap bitmap = response.getBitmap();
-            if (bitmap != null) {
-                BitmapDrawable drawable = new BitmapDrawable(UserSettingsFragment.this.getResources(), bitmap);
-                drawable.setBounds(0, 0,
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height));
-                userProfilePic = drawable;
-                userProfilePicID = id;
-                connectedStateLabel.setCompoundDrawables(null, drawable, null, null);
-                connectedStateLabel.setTag(response.getRequest().getImageUrl());
-            }
-        }
-    }
-}
diff --git a/facebook/tests/.classpath b/facebook/tests/.classpath
deleted file mode 100644
index a4763d1ee..000000000
--- a/facebook/tests/.classpath
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/facebook/tests/.project b/facebook/tests/.project
deleted file mode 100644
index 82993b5a8..000000000
--- a/facebook/tests/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>SDKTests</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/facebook/tests/AndroidManifest.xml b/facebook/tests/AndroidManifest.xml
deleted file mode 100644
index 1509af65d..000000000
--- a/facebook/tests/AndroidManifest.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- package name must be unique so suffix with "tests" so package loader doesn't ignore us -->
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.facebook.sdk.tests"
-          android:versionCode="1"
-          android:versionName="1.0">
-    <uses-permission android:name="android.permission.INTERNET"></uses-permission>
-    <uses-sdk android:minSdkVersion="7" android:targetSdkVersion="7"/>
-    <!-- We add an application tag here just so that we can indicate that
-         this package needs to link against the android.test library,
-         which is needed when building test cases. -->
-    <application>
-        <uses-library android:name="android.test.runner"/>
-        <activity android:name="com.facebook.FacebookTestCase$FacebookTestActivity"/>
-        <activity android:name="com.facebook.widget.FriendPickerFragmentTests$TestActivity"/>
-        <activity android:name="com.facebook.widget.PlacePickerFragmentTests$TestActivity"/>
-        <activity android:name="com.facebook.widget.GraphObjectPagingLoaderTests$TestActivity"/>
-        <activity android:name="com.facebook.widget.UserSettingsFragmentTests$TestActivity"/>
-        <activity android:name="com.facebook.LoginActivity" />
-        <activity android:name="com.facebook.FacebookActivityTests$FacebookTestActivity" />
-        <meta-data android:name="com.facebook.sdk.ApplicationId" android:value="@string/app_id"/>
-    </application>
-    <!--
-    This declares that this application uses the instrumentation test runner targeting
-    the package of com.facebook.sdk.  To run the tests use the command:
-    "adb shell am instrument -w com.facebook.sdk.tests/android.test.InstrumentationTestRunner"
-    -->
-    <instrumentation android:name="android.test.InstrumentationTestRunner"
-                     android:targetPackage="com.facebook.sdk.tests"
-                     android:label="Tests for com.facebook.sdk.tests"/>
-</manifest>
diff --git a/facebook/tests/SdkTests.eml b/facebook/tests/SdkTests.eml
deleted file mode 100644
index 3bbc2f8d5..000000000
--- a/facebook/tests/SdkTests.eml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<component>
-	<exclude-output/>
-	<contentEntry url="file://$MODULE_DIR$"/>
-	<module name="SdkTestApp" scope="PROVIDED"/>
-</component>
diff --git a/facebook/tests/SdkTests.iml b/facebook/tests/SdkTests.iml
deleted file mode 100644
index 75d82b2fc..000000000
--- a/facebook/tests/SdkTests.iml
+++ /dev/null
@@ -1,55 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="JAVA_MODULE" version="4">
-  <component name="EclipseModuleManager">
-    <conelement value="com.android.ide.eclipse.adt.LIBRARIES" />
-    <src_description expected_position="1">
-      <src_folder value="file://$MODULE_DIR$/src" expected_position="1" />
-      <src_folder value="file://$MODULE_DIR$/gen" expected_position="2" />
-    </src_description>
-  </component>
-  <component name="FacetManager">
-    <facet type="android" name="Android">
-      <configuration>
-        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
-        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
-        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/AndroidManifest.xml" />
-        <option name="RES_FOLDER_RELATIVE_PATH" value="/res" />
-        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/assets" />
-        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/libs" />
-        <option name="USE_CUSTOM_APK_RESOURCE_FOLDER" value="false" />
-        <option name="CUSTOM_APK_RESOURCE_FOLDER" value="" />
-        <option name="USE_CUSTOM_COMPILER_MANIFEST" value="false" />
-        <option name="CUSTOM_COMPILER_MANIFEST" value="" />
-        <option name="APK_PATH" value="" />
-        <option name="LIBRARY_PROJECT" value="false" />
-        <option name="RUN_PROCESS_RESOURCES_MAVEN_TASK" value="true" />
-        <option name="GENERATE_UNSIGNED_APK" value="false" />
-        <option name="CUSTOM_DEBUG_KEYSTORE_PATH" value="" />
-        <option name="PACK_TEST_CODE" value="true" />
-        <option name="RUN_PROGUARD" value="false" />
-        <option name="PROGUARD_CFG_PATH" value="/proguard-project.txt" />
-        <resOverlayFolders>
-          <path>/res-overlay</path>
-        </resOverlayFolders>
-        <includeSystemProguardFile>true</includeSystemProguardFile>
-        <includeAssetsFromLibraries>true</includeAssetsFromLibraries>
-        <additionalNativeLibs />
-      </configuration>
-    </facet>
-  </component>
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/bin/classes" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/assets" isTestSource="false" />
-    </content>
-    <orderEntry type="jdk" jdkName="Android 2.2 Platform" jdkType="Android SDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="module" module-name="android-sdk" exported="" />
-    <orderEntry type="module" module-name="SdkTestApp" scope="PROVIDED" />
-    <orderEntry type="library" name="android-support-v4" level="project" />
-  </component>
-</module>
-
diff --git a/facebook/tests/ant.properties b/facebook/tests/ant.properties
deleted file mode 100644
index 928de2ff9..000000000
--- a/facebook/tests/ant.properties
+++ /dev/null
@@ -1,20 +0,0 @@
-# This file is used to override default values used by the Ant build system.
-#
-# This file must be checked into Version Control Systems, as it is
-# integral to the build system of your project.
-
-# This file is only used by the Ant script.
-
-# You can use this to override default values such as
-#  'source.dir' for the location of your java source folder and
-#  'out.dir' for the location of your output folder.
-
-# You can also use it define how the release builds are signed by declaring
-# the following properties:
-#  'key.store' for the location of your keystore and
-#  'key.alias' for the name of the key to use.
-# The password will be asked during the build when you use the 'release' target.
-
-# Removed based on advice at code.google.com/p/android/issues/detail?id=21108#c2
-# and the comment that follows.
-# tested.project.dir=../TestApp
diff --git a/facebook/tests/assets/DarkScreen.mov b/facebook/tests/assets/DarkScreen.mov
deleted file mode 100644
index 2e86e5c49..000000000
Binary files a/facebook/tests/assets/DarkScreen.mov and /dev/null differ
diff --git a/facebook/tests/build.xml b/facebook/tests/build.xml
deleted file mode 100644
index 34c89faa8..000000000
--- a/facebook/tests/build.xml
+++ /dev/null
@@ -1,101 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="FacebookSdkTests" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties" />
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties" />
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties" />
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through an env var"
-            unless="sdk.dir"
-    />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true" />
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml" />
-
-    <!-- SDK Tools r15 workaround -->
-    <property name="tested.manifest.package" value="com.facebook.sdk.tests" />
-
-    <!-- This seems to have no effect.  The value remains android.test.AndroidTestRunner -->
-    <!-- <property name="test.runner" value="android.test.InstrumentationTestRunner" /> -->
-
-    <target name="run-tests">
-      <echo>Running tests...</echo>
-      <exec executable="${adb}" failonerror="true">
-        <arg line="${adb.device.arg}" />
-        <arg value="shell" />
-        <arg value="am" />
-        <arg value="instrument" />
-        <arg value="-w" />
-        <!-- was <arg value="${tested.manifest.package}/${test.runner}" /> -->
-        <arg value="${tested.manifest.package}/android.test.InstrumentationTestRunner" />
-      </exec>
-    </target>
-</project>
diff --git a/facebook/tests/proguard-project.txt b/facebook/tests/proguard-project.txt
deleted file mode 100644
index f2fe1559a..000000000
--- a/facebook/tests/proguard-project.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/facebook/tests/project.properties b/facebook/tests/project.properties
deleted file mode 100644
index 705d57d8d..000000000
--- a/facebook/tests/project.properties
+++ /dev/null
@@ -1,16 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-8
-test.runner=android.test.AndroidTestRunner
-android.library.reference.1=../../facebook
diff --git a/facebook/tests/res/layout/friend_picker_test_layout_1.xml b/facebook/tests/res/layout/friend_picker_test_layout_1.xml
deleted file mode 100644
index 4cffc58e7..000000000
--- a/facebook/tests/res/layout/friend_picker_test_layout_1.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              xmlns:app="http://schemas.android.com/apk/res-auto"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent">
-
-    <fragment
-            android:id="@+id/friend_picker_fragment"
-            android:name="com.facebook.widget.FriendPickerFragment"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
-            app:show_pictures="false"
-            app:multi_select="false"
-            app:extra_fields="middle_name,link"
-            />
-</LinearLayout>
diff --git a/facebook/tests/res/layout/place_picker_test_layout_1.xml b/facebook/tests/res/layout/place_picker_test_layout_1.xml
deleted file mode 100644
index ec77493cb..000000000
--- a/facebook/tests/res/layout/place_picker_test_layout_1.xml
+++ /dev/null
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-              xmlns:app="http://schemas.android.com/apk/res-auto"
-              android:layout_width="fill_parent"
-              android:layout_height="fill_parent">
-
-    <fragment
-            android:id="@+id/place_picker_fragment"
-            android:name="com.facebook.widget.PlacePickerFragment"
-            android:layout_width="fill_parent"
-            android:layout_height="fill_parent"
-            app:show_pictures="false"
-            app:radius_in_meters="75"
-            app:results_limit="5"
-            app:search_text="coffee"
-            app:extra_fields="checkins,general_info"
-            />
-</LinearLayout>
diff --git a/facebook/tests/res/values/strings.xml b/facebook/tests/res/values/strings.xml
deleted file mode 100644
index 05dacbbfd..000000000
--- a/facebook/tests/res/values/strings.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-    Copyright 2010-present Facebook.
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
--->
-
-<resources>
-    <string name="app_id">1234567890</string>
-</resources>
diff --git a/facebook/tests/src/com/facebook/AccessTokenTests.java b/facebook/tests/src/com/facebook/AccessTokenTests.java
deleted file mode 100644
index 83d2cc162..000000000
--- a/facebook/tests/src/com/facebook/AccessTokenTests.java
+++ /dev/null
@@ -1,279 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.internal.Utility;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-
-public final class AccessTokenTests extends AndroidTestCase {
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testEmptyToken() {
-        List<String> permissions = Utility.arrayList();
-        AccessToken token = AccessToken.createEmptyToken(permissions);
-        TestUtils.assertSamePermissions(permissions, token);
-        assertEquals("", token.getToken());
-        assertTrue(token.isInvalid());
-        assertTrue(token.getExpires().before(new Date()));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testEmptyTokenWithPermissions() {
-        List<String> permissions = Utility.arrayList("stream_publish");
-        AccessToken token = AccessToken.createEmptyToken(permissions);
-        TestUtils.assertSamePermissions(permissions, token);
-        assertEquals("", token.getToken());
-        assertTrue(token.isInvalid());
-        assertTrue(token.getExpires().before(new Date()));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testFromDialog() {
-        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
-        String token = "AnImaginaryTokenValue";
-
-        Bundle bundle = new Bundle();
-        bundle.putString("access_token", token);
-        bundle.putString("expires_in", "60");
-
-        AccessToken accessToken = AccessToken.createFromWebBundle(permissions, bundle, AccessTokenSource.WEB_VIEW);
-        TestUtils.assertSamePermissions(permissions, accessToken);
-        assertEquals(token, accessToken.getToken());
-        assertEquals(AccessTokenSource.WEB_VIEW, accessToken.getSource());
-        assertTrue(!accessToken.isInvalid());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testFromSSOWithExpiresString() {
-        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
-        String token = "AnImaginaryTokenValue";
-
-        Intent intent = new Intent();
-        intent.putExtra("access_token", token);
-        intent.putExtra("expires_in", "60");
-        intent.putExtra("extra_extra", "Something unrelated");
-
-        AccessToken accessToken = AccessToken
-                .createFromWebBundle(permissions, intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_WEB);
-
-        TestUtils.assertSamePermissions(permissions, accessToken);
-        assertEquals(token, accessToken.getToken());
-        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
-        assertTrue(!accessToken.isInvalid());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testFromSSOWithExpiresLong() {
-        List<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
-        String token = "AnImaginaryTokenValue";
-
-        Intent intent = new Intent();
-        intent.putExtra("access_token", token);
-        intent.putExtra("expires_in", 60L);
-        intent.putExtra("extra_extra", "Something unrelated");
-
-        AccessToken accessToken = AccessToken
-                .createFromWebBundle(permissions, intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_WEB);
-        TestUtils.assertSamePermissions(permissions, accessToken);
-        assertEquals(token, accessToken.getToken());
-        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
-        assertTrue(!accessToken.isInvalid());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testFromNativeLogin() {
-        ArrayList<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
-        String token = "AnImaginaryTokenValue";
-
-        long nowSeconds = new Date().getTime() / 1000;
-        Intent intent = new Intent();
-        intent.putExtra(NativeProtocol.EXTRA_ACCESS_TOKEN, token);
-        intent.putExtra(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, nowSeconds + 60L);
-        intent.putExtra(NativeProtocol.EXTRA_PERMISSIONS, permissions);
-
-        AccessToken accessToken = AccessToken.createFromNativeLogin(
-                intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_NATIVE);
-        TestUtils.assertSamePermissions(permissions, accessToken);
-        assertEquals(token, accessToken.getToken());
-        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_NATIVE, accessToken.getSource());
-        assertTrue(!accessToken.isInvalid());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCacheRoundtrip() {
-        ArrayList<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
-        String token = "AnImaginaryTokenValue";
-        Date later = TestUtils.nowPlusSeconds(60);
-        Date earlier = TestUtils.nowPlusSeconds(-60);
-
-        Bundle bundle = new Bundle();
-        TokenCachingStrategy.putToken(bundle, token);
-        TokenCachingStrategy.putExpirationDate(bundle, later);
-        TokenCachingStrategy.putSource(bundle, AccessTokenSource.FACEBOOK_APPLICATION_WEB);
-        TokenCachingStrategy.putLastRefreshDate(bundle, earlier);
-        TokenCachingStrategy.putPermissions(bundle, permissions);
-
-        AccessToken accessToken = AccessToken.createFromCache(bundle);
-        TestUtils.assertSamePermissions(permissions, accessToken);
-        assertEquals(token, accessToken.getToken());
-        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
-        assertTrue(!accessToken.isInvalid());
-
-        Bundle cache = accessToken.toCacheBundle();
-        TestUtils.assertEqualContents(bundle, cache);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCachePutGet() {
-        Bundle bundle = new Bundle();
-
-        for (String token : new String[] { "", "A completely random token value" }) {
-            TokenCachingStrategy.putToken(bundle, token);
-            assertEquals(token, TokenCachingStrategy.getToken(bundle));
-        }
-
-        for (Date date : new Date[] { new Date(42), new Date() }) {
-            TokenCachingStrategy.putExpirationDate(bundle, date);
-            assertEquals(date, TokenCachingStrategy.getExpirationDate(bundle));
-
-            TokenCachingStrategy.putLastRefreshDate(bundle, date);
-            assertEquals(date, TokenCachingStrategy.getLastRefreshDate(bundle));
-        }
-
-        for (long milliseconds : new long[] { 0, -1, System.currentTimeMillis() }) {
-            TokenCachingStrategy.putExpirationMilliseconds(bundle, milliseconds);
-            assertEquals(milliseconds, TokenCachingStrategy.getExpirationMilliseconds(bundle));
-
-            TokenCachingStrategy.putLastRefreshMilliseconds(bundle, milliseconds);
-            assertEquals(milliseconds, TokenCachingStrategy.getLastRefreshMilliseconds(bundle));
-        }
-
-        for (AccessTokenSource source : AccessTokenSource.values()) {
-            TokenCachingStrategy.putSource(bundle, source);
-            assertEquals(source, TokenCachingStrategy.getSource(bundle));
-        }
-
-        List<String> normalList = Arrays.asList("", "Another completely random token value");
-        List<String> emptyList = Arrays.asList();
-        ArrayList<String> normalArrayList = new ArrayList<String>(normalList);
-        ArrayList<String> emptyArrayList = new ArrayList<String>();
-        @SuppressWarnings("unchecked")
-        List<List<String>> permissionLists = Arrays
-                .asList(normalList, emptyList, normalArrayList, emptyArrayList);
-        for (List<String> list : permissionLists) {
-            TokenCachingStrategy.putPermissions(bundle, list);
-            TestUtils.assertSamePermissions(list, TokenCachingStrategy.getPermissions(bundle));
-        }
-        normalArrayList.add(null);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testBasicSerialization() throws IOException {
-        AccessToken accessToken = AccessToken.createFromString("a token",
-                Arrays.asList("permission_1", "permission_2"), AccessTokenSource.WEB_VIEW);
-        AccessToken res = TestUtils.serializeAndUnserialize(accessToken);
-        
-        // if one field got serialized most likely all other non transient fields
-        // got serialized correctly.
-        assertEquals(accessToken.getPermissions(), res.getPermissions());
-        assertEquals(accessToken.getToken(), res.getToken());
-        assertEquals(accessToken.getSource(), res.getSource());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testPermissionsAreImmutable() {
-        List<String> permissions = Arrays.asList("go to Jail", "do not pass Go");
-        AccessToken accessToken = new AccessToken("some token", new Date(), permissions,
-                AccessTokenSource.FACEBOOK_APPLICATION_WEB, new Date());
-
-        permissions = accessToken.getPermissions();
-
-        try {
-            permissions.add("can't touch this");
-            fail();
-        } catch (UnsupportedOperationException ex) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateFromExistingTokenDefaults() {
-        final String token = "A token of my esteem";
-
-        AccessToken accessToken = AccessToken.createFromExistingAccessToken(token, null, null, null, null);
-
-        assertEquals(token, accessToken.getToken());
-        assertEquals(new Date(Long.MAX_VALUE), accessToken.getExpires());
-        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
-        assertEquals(0, accessToken.getPermissions().size());
-        // Allow slight variation for test execution time
-        long delta = accessToken.getLastRefresh().getTime() - new Date().getTime();
-        assertTrue(delta < 1000);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateFromExistingToken() {
-        final String token = "A token of my esteem";
-        final List<String> permissions = Arrays.asList("walk", "chew gum");
-        final Date expires = new Date(2025, 5, 3);
-        final Date lastRefresh = new Date(2023, 8, 15);
-        final AccessTokenSource source = AccessTokenSource.WEB_VIEW;
-
-        AccessToken accessToken = AccessToken
-                .createFromExistingAccessToken(token, expires, lastRefresh, source, permissions);
-
-        assertEquals(token, accessToken.getToken());
-        assertEquals(expires, accessToken.getExpires());
-        assertEquals(lastRefresh, accessToken.getLastRefresh());
-        assertEquals(source, accessToken.getSource());
-        assertEquals(permissions, accessToken.getPermissions());
-    }
-}
diff --git a/facebook/tests/src/com/facebook/AsyncRequestTests.java b/facebook/tests/src/com/facebook/AsyncRequestTests.java
deleted file mode 100644
index 28f23adae..000000000
--- a/facebook/tests/src/com/facebook/AsyncRequestTests.java
+++ /dev/null
@@ -1,312 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.graphics.Bitmap;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphPlace;
-import com.facebook.model.GraphUser;
-
-import java.net.HttpURLConnection;
-import java.util.Arrays;
-import java.util.List;
-
-public class AsyncRequestTests extends FacebookTestCase {
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanLaunchAsyncRequestFromUiThread() {
-        Request request = Request.newPostRequest(null, "me/feeds", null, null);
-        try {
-            TestRequestAsyncTask task = createAsyncTaskOnUiThread(request);
-            assertNotNull(task);
-        } catch (Throwable throwable) {
-            assertNull(throwable);
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testExecuteWithNullRequestsThrows() throws Exception {
-        try {
-            TestRequestAsyncTask task = new TestRequestAsyncTask((Request[]) null);
-
-            task.executeOnBlockerThread();
-
-            waitAndAssertSuccessOrRethrow(1);
-
-            fail("expected NullPointerException");
-        } catch (NullPointerException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testExecuteBatchWithZeroRequestsThrows() throws Exception {
-        try {
-            TestRequestAsyncTask task = new TestRequestAsyncTask(new Request[] {});
-
-            task.executeOnBlockerThread();
-
-            waitAndAssertSuccessOrRethrow(1);
-
-            fail("expected IllegalArgumentException");
-        } catch (IllegalArgumentException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testExecuteBatchWithNullRequestThrows() throws Exception {
-        try {
-            TestRequestAsyncTask task = new TestRequestAsyncTask(new Request[] { null });
-
-            task.executeOnBlockerThread();
-
-            waitAndAssertSuccessOrRethrow(1);
-
-            fail("expected NullPointerException");
-        } catch (NullPointerException exception) {
-        }
-
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExecuteSingleGet() {
-        Request request = new Request(null, "TourEiffel", null, null, new ExpectSuccessCallback() {
-            @Override
-            protected void performAsserts(Response response) {
-                assertNotNull(response);
-                GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
-                assertEquals("Paris", graphPlace.getLocation().getCity());
-            }
-        });
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
-
-        task.executeOnBlockerThread();
-
-        // Wait on 2 signals: request and task will both signal.
-        waitAndAssertSuccess(2);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExecuteSingleGetUsingHttpURLConnection() {
-        Request request = new Request(null, "TourEiffel", null, null, new ExpectSuccessCallback() {
-            @Override
-            protected void performAsserts(Response response) {
-                assertNotNull(response);
-                GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
-                assertEquals("Paris", graphPlace.getLocation().getCity());
-            }
-        });
-        HttpURLConnection connection = Request.toHttpConnection(request);
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(connection, Arrays.asList(new Request[] { request }));
-
-        task.executeOnBlockerThread();
-
-        // Wait on 2 signals: request and task will both signal.
-        waitAndAssertSuccess(2);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExecuteSingleGetFailureCase() {
-        Request request = new Request(null, "-1", null, null, new ExpectFailureCallback());
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
-
-        task.executeOnBlockerThread();
-
-        // Wait on 2 signals: request and task will both signal.
-        waitAndAssertSuccess(2);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testBatchWithoutAppIDIsError() throws Throwable {
-        Request request1 = new Request(null, "TourEiffel", null, null, new ExpectFailureCallback());
-        Request request2 = new Request(null, "SpaceNeedle", null, null, new ExpectFailureCallback());
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(request1, request2);
-
-        task.executeOnBlockerThread();
-
-        // Wait on 3 signals: request1, request2, and task will all signal.
-        waitAndAssertSuccessOrRethrow(3);
-    }
-
-    @LargeTest
-    public void testMixedSuccessAndFailure() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        final int NUM_REQUESTS = 8;
-        Request[] requests = new Request[NUM_REQUESTS];
-        for (int i = 0; i < NUM_REQUESTS; ++i) {
-            boolean shouldSucceed = (i % 2) == 1;
-            if (shouldSucceed) {
-                requests[i] = new Request(session, "me", null, null, new ExpectSuccessCallback());
-            } else {
-                requests[i] = new Request(session, "-1", null, null, new ExpectFailureCallback());
-            }
-        }
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(requests);
-
-        task.executeOnBlockerThread();
-
-        // Note: plus 1, because the overall async task signals as well.
-        waitAndAssertSuccess(NUM_REQUESTS + 1);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testStaticExecuteMeAsync() {
-        final TestSession session = openTestSessionWithSharedUser();
-
-        class MeCallback extends ExpectSuccessCallback implements Request.GraphUserCallback {
-            @Override
-            public void onCompleted(GraphUser me, Response response) {
-                assertNotNull(me);
-                assertEquals(session.getTestUserId(), me.getId());
-                RequestTests.validateMeResponse(session, response);
-                onCompleted(response);
-            }
-        }
-
-        runOnBlockerThread(new Runnable() {
-            @Override
-            public void run() {
-                Request.executeMeRequestAsync(session, new MeCallback());
-            }
-        }, false);
-        waitAndAssertSuccess(1);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testStaticExecuteMyFriendsAsync() {
-        final TestSession session = openTestSessionWithSharedUser();
-
-        class FriendsCallback extends ExpectSuccessCallback implements Request.GraphUserListCallback {
-            @Override
-            public void onCompleted(List<GraphUser> friends, Response response) {
-                assertNotNull(friends);
-                RequestTests.validateMyFriendsResponse(session, response);
-                onCompleted(response);
-            }
-        }
-
-        runOnBlockerThread(new Runnable() {
-            @Override
-            public void run() {
-                Request.executeMyFriendsRequestAsync(session, new FriendsCallback());
-            }
-        }, false);
-        waitAndAssertSuccess(1);
-    }
-
-    @LargeTest
-    public void testBatchUploadPhoto() {
-        TestSession session = openTestSessionWithSharedUserAndPermissions(null, "user_photos");
-
-        final int image1Size = 120;
-        final int image2Size = 150;
-
-        Bitmap bitmap1 = createTestBitmap(image1Size);
-        Bitmap bitmap2 = createTestBitmap(image2Size);
-
-        Request uploadRequest1 = Request.newUploadPhotoRequest(session, bitmap1, null);
-        uploadRequest1.setBatchEntryName("uploadRequest1");
-        Request uploadRequest2 = Request.newUploadPhotoRequest(session, bitmap2, null);
-        uploadRequest2.setBatchEntryName("uploadRequest2");
-        Request getRequest1 = new Request(session, "{result=uploadRequest1:$.id}", null, null,
-                new ExpectSuccessCallback() {
-                    @Override
-                    protected void performAsserts(Response response) {
-                        assertNotNull(response);
-                        GraphObject retrievedPhoto = response.getGraphObject();
-                        assertNotNull(retrievedPhoto);
-                        assertEquals(image1Size, retrievedPhoto.getProperty("width"));
-                    }
-                });
-        Request getRequest2 = new Request(session, "{result=uploadRequest2:$.id}", null, null,
-                new ExpectSuccessCallback() {
-                    @Override
-                    protected void performAsserts(Response response) {
-                        assertNotNull(response);
-                        GraphObject retrievedPhoto = response.getGraphObject();
-                        assertNotNull(retrievedPhoto);
-                        assertEquals(image2Size, retrievedPhoto.getProperty("width"));
-                    }
-                });
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(uploadRequest1, uploadRequest2, getRequest1, getRequest2);
-        task.executeOnBlockerThread();
-
-        // Wait on 3 signals: getRequest1, getRequest2, and task will all signal.
-        waitAndAssertSuccess(3);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testShortTimeoutCausesFailure() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request request = new Request(session, "me/likes", null, null, new ExpectFailureCallback());
-
-        RequestBatch requestBatch = new RequestBatch(request);
-
-        // 1 millisecond timeout should be too short for response from server.
-        requestBatch.setTimeout(1);
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(requestBatch);
-        task.executeOnBlockerThread();
-
-        // Note: plus 1, because the overall async task signals as well.
-        waitAndAssertSuccess(2);
-    }
-
-    @LargeTest
-    public void testLongTimeoutAllowsSuccess() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request request = new Request(session, "me", null, null, new ExpectSuccessCallback());
-
-        RequestBatch requestBatch = new RequestBatch(request);
-
-        // 10 second timeout should be long enough for successful response from server.
-        requestBatch.setTimeout(10000);
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(requestBatch);
-        task.executeOnBlockerThread();
-
-        // Note: plus 1, because the overall async task signals as well.
-        waitAndAssertSuccess(2);
-    }
-}
diff --git a/facebook/tests/src/com/facebook/AuthorizationClientTests.java b/facebook/tests/src/com/facebook/AuthorizationClientTests.java
deleted file mode 100644
index 5267f41c3..000000000
--- a/facebook/tests/src/com/facebook/AuthorizationClientTests.java
+++ /dev/null
@@ -1,684 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.os.Bundle;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.model.GraphMultiResult;
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphObjectList;
-import com.facebook.model.GraphUser;
-
-import java.io.*;
-import java.util.*;
-
-public class AuthorizationClientTests extends FacebookTestCase {
-    private static final String ACCESS_TOKEN = "An access token";
-    private static final long EXPIRES_IN_DELTA = 3600 * 24 * 60;
-    private static final ArrayList<String> PERMISSIONS = new ArrayList<String>(
-            Arrays.asList("go outside", "come back in"));
-    private static final String ERROR_MESSAGE = "This is bad!";
-
-    class MockAuthorizationClient extends AuthorizationClient {
-        Result result;
-        boolean triedNextHandler = false;
-
-        MockAuthorizationClient() {
-            setContext(getActivity());
-        }
-
-        AuthorizationClient.AuthorizationRequest getRequest() {
-            return pendingRequest;
-        }
-
-        void setRequest(AuthorizationClient.AuthorizationRequest request) {
-            pendingRequest = request;
-        }
-
-        @Override
-        void complete(Result result) {
-            this.result = result;
-        }
-
-        @Override
-        void tryNextHandler() {
-            triedNextHandler = true;
-        }
-    }
-
-    // WebViewAuthHandler tests
-
-    AuthorizationClient.AuthorizationRequest createRequest() {
-        Session.AuthorizationRequest request = new Session.AuthorizationRequest(getActivity());
-        request.setPermissions(PERMISSIONS);
-        return request.getAuthorizationClientRequest();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testWebViewHandlesSuccess() {
-        Bundle bundle = new Bundle();
-        bundle.putString("access_token", ACCESS_TOKEN);
-        bundle.putString("expires_in", String.format("%d", EXPIRES_IN_DELTA));
-        bundle.putString("code", "Something else");
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onWebDialogComplete(request, bundle, null);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
-
-        AccessToken token = client.result.token;
-        assertNotNull(token);
-        assertEquals(ACCESS_TOKEN, token.getToken());
-        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
-        assertEquals(PERMISSIONS, token.getPermissions());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testWebViewHandlesCancel() {
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onWebDialogComplete(request, null, new FacebookOperationCanceledException());
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
-        assertNull(client.result.token);
-        assertNotNull(client.result.errorMessage);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testWebViewHandlesError() {
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onWebDialogComplete(request, null, new FacebookException(ERROR_MESSAGE));
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
-        assertNull(client.result.token);
-        assertNotNull(client.result.errorMessage);
-        assertEquals(client.result.errorMessage, ERROR_MESSAGE);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testWebViewChecksInternetPermission() {
-        MockAuthorizationClient client = new MockAuthorizationClient() {
-            @Override
-            int checkPermission(String permission) {
-                return PackageManager.PERMISSION_DENIED;
-            }
-        };
-        AuthorizationClient.WebViewAuthHandler handler = client.new WebViewAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onWebDialogComplete(request, null, new FacebookException(ERROR_MESSAGE));
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
-        assertNull(client.result.token);
-        assertNotNull(client.result.errorMessage);
-    }
-
-    // GetTokenAuthHandler tests
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetTokenHandlesSuccessWithAllPermissions() {
-        Bundle bundle = new Bundle();
-        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS, PERMISSIONS);
-        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
-        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.GetTokenAuthHandler handler = client.new GetTokenAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.getTokenCompleted(request, bundle);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
-
-        AccessToken token = client.result.token;
-        assertNotNull(token);
-        assertEquals(ACCESS_TOKEN, token.getToken());
-        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
-        assertEquals(PERMISSIONS, token.getPermissions());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetTokenHandlesSuccessWithSomePermissions() {
-        Bundle bundle = new Bundle();
-        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS, new ArrayList<String>(Arrays.asList("go outside")));
-        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
-        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.GetTokenAuthHandler handler = client.new GetTokenAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
-
-        client.setRequest(request);
-        handler.getTokenCompleted(request, bundle);
-
-        assertNull(client.result);
-        assertTrue(client.triedNextHandler);
-
-        assertEquals(1, request.getPermissions().size());
-        assertTrue(request.getPermissions().contains("come back in"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetTokenHandlesNoResult() {
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.GetTokenAuthHandler handler = client.new GetTokenAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
-
-        client.setRequest(request);
-        handler.getTokenCompleted(request, null);
-
-        assertNull(client.result);
-        assertTrue(client.triedNextHandler);
-
-        assertEquals(PERMISSIONS.size(), request.getPermissions().size());
-    }
-
-    // KatanaLoginDialogAuthHandler tests
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLoginDialogHandlesSuccess() {
-        Bundle bundle = new Bundle();
-        bundle.putStringArrayList(NativeProtocol.EXTRA_PERMISSIONS, PERMISSIONS);
-        bundle.putLong(NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date().getTime() / 1000 + EXPIRES_IN_DELTA);
-        bundle.putString(NativeProtocol.EXTRA_ACCESS_TOKEN, ACCESS_TOKEN);
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_OK, intent);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
-
-        AccessToken token = client.result.token;
-        assertNotNull(token);
-        assertEquals(ACCESS_TOKEN, token.getToken());
-        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
-        assertEquals(PERMISSIONS, token.getPermissions());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLoginDialogHandlesCancel() {
-        Bundle bundle = new Bundle();
-        bundle.putString(NativeProtocol.STATUS_ERROR_DESCRIPTION, ERROR_MESSAGE);
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
-
-        AccessToken token = client.result.token;
-        assertNull(token);
-        assertNotNull(client.result.errorMessage);
-        assertEquals(ERROR_MESSAGE, client.result.errorMessage);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLoginDialogHandlesError() {
-        Bundle bundle = new Bundle();
-        bundle.putString(NativeProtocol.STATUS_ERROR_TYPE, ERROR_MESSAGE);
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_OK, intent);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
-
-        AccessToken token = client.result.token;
-        assertNull(token);
-        assertNotNull(client.result.errorMessage);
-        assertEquals(ERROR_MESSAGE, client.result.errorMessage);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLoginDialogHandlesDisabled() {
-        Bundle bundle = new Bundle();
-        bundle.putInt(NativeProtocol.EXTRA_PROTOCOL_VERSION, NativeProtocol.PROTOCOL_VERSION_20121101);
-        bundle.putString(NativeProtocol.STATUS_ERROR_TYPE, NativeProtocol.ERROR_SERVICE_DISABLED);
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaLoginDialogAuthHandler handler = client.new KatanaLoginDialogAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_OK, intent);
-
-        assertNull(client.result);
-        assertTrue(client.triedNextHandler);
-    }
-
-    // KatanaProxyAuthHandler tests
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testProxyAuthHandlesSuccess() {
-        Bundle bundle = new Bundle();
-        bundle.putLong(AccessToken.EXPIRES_IN_KEY, EXPIRES_IN_DELTA);
-        bundle.putString(AccessToken.ACCESS_TOKEN_KEY, ACCESS_TOKEN);
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_OK, intent);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
-
-        AccessToken token = client.result.token;
-        assertNotNull(token);
-        assertEquals(ACCESS_TOKEN, token.getToken());
-        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
-        assertEquals(PERMISSIONS, token.getPermissions());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testProxyAuthHandlesCancel() {
-        Bundle bundle = new Bundle();
-        bundle.putString("error", ERROR_MESSAGE);
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
-
-        assertNull(client.result.token);
-        assertNotNull(client.result.errorMessage);
-        assertTrue(client.result.errorMessage.contains(ERROR_MESSAGE));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testProxyAuthHandlesCancelErrorMessage() {
-        Bundle bundle = new Bundle();
-        bundle.putString("error", "access_denied");
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.CANCEL, client.result.code);
-
-        assertNull(client.result.token);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testProxyAuthHandlesDisabled() {
-        Bundle bundle = new Bundle();
-        bundle.putString("error", "service_disabled");
-
-        Intent intent = new Intent();
-        intent.putExtras(bundle);
-
-        MockAuthorizationClient client = new MockAuthorizationClient();
-        AuthorizationClient.KatanaProxyAuthHandler handler = client.new KatanaProxyAuthHandler();
-
-        AuthorizationClient.AuthorizationRequest request = createRequest();
-        client.setRequest(request);
-        handler.onActivityResult(0, Activity.RESULT_OK, intent);
-
-        assertNull(client.result);
-        assertTrue(client.triedNextHandler);
-    }
-
-    // Reauthorization validation tests
-
-    class MockValidatingAuthorizationClient extends MockAuthorizationClient {
-        private final HashMap<String, String> mapAccessTokenToFbid = new HashMap<String, String>();
-        private List<String> permissionsToReport = Arrays.asList();
-        private TestBlocker blocker;
-
-        public MockValidatingAuthorizationClient(TestBlocker blocker) {
-            this.blocker = blocker;
-        }
-
-        public void addAccessTokenToFbidMapping(String accessToken, String fbid) {
-            mapAccessTokenToFbid.put(accessToken, fbid);
-        }
-
-        public void addAccessTokenToFbidMapping(AccessToken accessToken, String fbid) {
-            mapAccessTokenToFbid.put(accessToken.getToken(), fbid);
-        }
-
-        public void setPermissionsToReport(List<String> permissionsToReport) {
-            this.permissionsToReport = permissionsToReport;
-        }
-
-        @Override
-        void complete(Result result) {
-            super.complete(result);
-            blocker.signal();
-        }
-
-        @Override
-        Request createGetProfileIdRequest(final String accessToken) {
-            return new MockRequest() {
-                @Override
-                public Response createResponse() {
-                    String fbid = mapAccessTokenToFbid.get(accessToken);
-                    GraphUser user = GraphObject.Factory.create(GraphUser.class);
-                    user.setId(fbid);
-                    return new Response(this, null, user, false);
-                }
-            };
-        }
-
-        @Override
-        Request createGetPermissionsRequest(String accessToken) {
-            final List<String> permissions = permissionsToReport;
-            return new MockRequest() {
-                @Override
-                public Response createResponse() {
-                    GraphObject permissionsObject = GraphObject.Factory.create();
-                    if (permissions != null) {
-                        for (String permission : permissions) {
-                            permissionsObject.setProperty(permission, 1);
-                        }
-                    }
-                    GraphObjectList<GraphObject> data = GraphObject.Factory.createList(GraphObject.class);
-                    data.add(permissionsObject);
-
-                    GraphMultiResult result = GraphObject.Factory.create(GraphMultiResult.class);
-                    result.setProperty("data", data);
-
-                    return new Response(this, null, result, false);
-                }
-            };
-        }
-
-        @Override
-        RequestBatch createReauthValidationBatch(final Result pendingResult) {
-            RequestBatch batch = super.createReauthValidationBatch(pendingResult);
-
-            batch.setCallbackHandler(blocker.getHandler());
-            // Turn it into a MockRequestBatch.
-            return new MockRequestBatch(batch);
-        }
-    }
-
-    static final String USER_1_FBID = "user1";
-    static final String USER_1_ACCESS_TOKEN = "An access token for user 1";
-    static final String USER_2_FBID = "user2";
-    static final String USER_2_ACCESS_TOKEN = "An access token for user 2";
-
-    AuthorizationClient.AuthorizationRequest createNewPermissionRequest(String accessToken) {
-        Session.NewPermissionsRequest request = new Session.NewPermissionsRequest(getActivity(), PERMISSIONS);
-        request.setValidateSameFbidAsToken(accessToken);
-        return request.getAuthorizationClientRequest();
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testReauthorizationWithSameFbidSucceeds() throws Exception {
-        TestBlocker blocker = getTestBlocker();
-
-        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
-        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
-        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
-        client.setPermissionsToReport(PERMISSIONS);
-
-        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
-        client.setRequest(request);
-
-        AccessToken token = AccessToken.createFromExistingAccessToken(USER_1_ACCESS_TOKEN, null, null, null, PERMISSIONS);
-        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(token);
-
-        client.completeAndValidate(result);
-
-        blocker.waitForSignals(1);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
-
-        AccessToken resultToken = client.result.token;
-        assertNotNull(resultToken);
-        assertEquals(USER_1_ACCESS_TOKEN, resultToken.getToken());
-        assertEquals(PERMISSIONS, resultToken.getPermissions());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testReauthorizationWithFewerPermissionsSucceeds() throws Exception {
-        TestBlocker blocker = getTestBlocker();
-
-        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
-        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
-        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
-        client.setPermissionsToReport(Arrays.asList("go outside"));
-
-        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
-        client.setRequest(request);
-
-        AccessToken token = AccessToken.createFromExistingAccessToken(USER_1_ACCESS_TOKEN, null, null, null, PERMISSIONS);
-        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(token);
-
-        client.completeAndValidate(result);
-
-        blocker.waitForSignals(1);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.SUCCESS, client.result.code);
-
-        AccessToken resultToken = client.result.token;
-        assertNotNull(resultToken);
-        assertEquals(USER_1_ACCESS_TOKEN, resultToken.getToken());
-        assertEquals(Arrays.asList("go outside"), resultToken.getPermissions());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testReauthorizationWithDifferentFbidsFails() throws Exception {
-        TestBlocker blocker = getTestBlocker();
-
-        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
-        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
-        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
-        client.setPermissionsToReport(PERMISSIONS);
-
-        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
-        client.setRequest(request);
-
-        AccessToken token = AccessToken.createFromExistingAccessToken(USER_2_ACCESS_TOKEN, null, null, null, PERMISSIONS);
-        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(token);
-
-        client.completeAndValidate(result);
-
-        blocker.waitForSignals(1);
-
-        assertNotNull(client.result);
-        assertEquals(AuthorizationClient.Result.Code.ERROR, client.result.code);
-
-        assertNull(client.result.token);
-        assertNotNull(client.result.errorMessage);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testLegacyReauthDoesntValidate() throws Exception {
-        TestBlocker blocker = getTestBlocker();
-
-        MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient(blocker);
-        AuthorizationClient.AuthorizationRequest request = createNewPermissionRequest(USER_1_ACCESS_TOKEN);
-        request.setIsLegacy(true);
-        client.setRequest(request);
-
-        AccessToken token = AccessToken.createFromExistingAccessToken(USER_2_ACCESS_TOKEN, null, null, null, PERMISSIONS);
-        AuthorizationClient.Result result = AuthorizationClient.Result.createTokenResult(token);
-
-        client.completeAndValidate(result);
-
-        AccessToken resultToken = client.result.token;
-        assertNotNull(resultToken);
-        assertEquals(USER_2_ACCESS_TOKEN, resultToken.getToken());
-        assertEquals(PERMISSIONS, resultToken.getPermissions());
-    }
-
-    // Serialization tests
-
-    static class DoNothingAuthorizationClient extends AuthorizationClient {
-        // Don't actually do anything.
-        @Override
-        boolean tryCurrentHandler() {
-            return true;
-        }
-    }
-
-    public void testSerialization() throws IOException, ClassNotFoundException {
-        AuthorizationClient client = new DoNothingAuthorizationClient();
-
-        // Call this to set up some state.
-        client.setContext(getActivity());
-        client.setOnCompletedListener(new AuthorizationClient.OnCompletedListener() {
-            @Override
-            public void onCompleted(AuthorizationClient.Result result) {
-            }
-        });
-        client.setBackgroundProcessingListener(new AuthorizationClient.BackgroundProcessingListener() {
-            @Override
-            public void onBackgroundProcessingStarted() {
-            }
-
-            @Override
-            public void onBackgroundProcessingStopped() {
-            }
-        });
-        client.authorize(createRequest());
-
-        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
-        ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream);
-        outputStream.writeObject(client);
-        outputStream.close();
-
-        byte [] byteArray = byteArrayOutputStream.toByteArray();
-
-        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);
-        ObjectInputStream inputStream = new ObjectInputStream(byteArrayInputStream);
-
-        Object obj = inputStream.readObject();
-        assertNotNull(obj);
-        assertTrue(obj instanceof AuthorizationClient);
-
-        AuthorizationClient resultClient = (AuthorizationClient)obj;
-        assertNull(resultClient.startActivityDelegate);
-        assertNull(resultClient.onCompletedListener);
-        assertNull(resultClient.backgroundProcessingListener);
-        assertNull(resultClient.context);
-        assertNotNull(resultClient.currentHandler);
-        assertTrue(resultClient.currentHandler instanceof AuthorizationClient.GetTokenAuthHandler);
-        assertNotNull(resultClient.handlersToTry);
-        assertTrue(resultClient.handlersToTry.size() > 0);
-        assertNotNull(resultClient.pendingRequest);
-        assertEquals(PERMISSIONS, resultClient.pendingRequest.getPermissions());
-    }
-}
diff --git a/facebook/tests/src/com/facebook/BatchRequestTests.java b/facebook/tests/src/com/facebook/BatchRequestTests.java
deleted file mode 100644
index 6b23689ee..000000000
--- a/facebook/tests/src/com/facebook/BatchRequestTests.java
+++ /dev/null
@@ -1,537 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.graphics.Bitmap;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphPlace;
-import com.facebook.model.GraphUser;
-import com.facebook.internal.CacheableRequestBatch;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
-
-public class BatchRequestTests extends FacebookTestCase {
-    protected void setUp() throws Exception {
-        super.setUp();
-
-        // Tests that need this set should explicitly set it.
-        Request.setDefaultBatchApplicationId(null);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateEmptyRequestBatch() {
-        CacheableRequestBatch batch = new CacheableRequestBatch();
-
-        Request meRequest = Request.newMeRequest(null, null);
-        assertEquals(0, batch.size());
-        batch.add(meRequest);
-        assertEquals(1, batch.size());
-        assertEquals(meRequest, batch.get(0));
-
-        String key = "The Key";
-        assertNull(batch.getCacheKeyOverride());
-        batch.setCacheKeyOverride(key);
-        assertEquals(key, batch.getCacheKeyOverride());
-
-        assertTrue(!batch.getForceRoundTrip());
-        batch.setForceRoundTrip(true);
-        assertTrue(batch.getForceRoundTrip());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateNonemptyRequestBatch() {
-        Request meRequest = Request.newMeRequest(null, null);
-
-        RequestBatch batch = new RequestBatch(new Request[] { meRequest, meRequest });
-        assertEquals(2, batch.size());
-        assertEquals(meRequest, batch.get(0));
-        assertEquals(meRequest, batch.get(1));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testBatchWithoutAppIDIsError() {
-        Request request1 = new Request(null, "TourEiffel", null, null, new ExpectFailureCallback());
-        Request request2 = new Request(null, "SpaceNeedle", null, null, new ExpectFailureCallback());
-        Request.executeBatchAndWait(request1, request2);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExecuteBatchedGets() throws IOException {
-        setBatchApplicationIdForTestApp();
-
-        Request request1 = new Request(null, "TourEiffel");
-        Request request2 = new Request(null, "SpaceNeedle");
-
-        List<Response> responses = Request.executeBatchAndWait(request1, request2);
-        assertEquals(2, responses.size());
-        assertTrue(responses.get(0).getError() == null);
-        assertTrue(responses.get(1).getError() == null);
-
-        GraphPlace eiffelTower = responses.get(0).getGraphObjectAs(GraphPlace.class);
-        GraphPlace spaceNeedle = responses.get(1).getGraphObjectAs(GraphPlace.class);
-        assertTrue(eiffelTower != null);
-        assertTrue(spaceNeedle != null);
-
-        assertEquals("Paris", eiffelTower.getLocation().getCity());
-        assertEquals("Seattle", spaceNeedle.getLocation().getCity());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testFacebookErrorResponsesCreateErrors() {
-        setBatchApplicationIdForTestApp();
-
-        Request request1 = new Request(null, "somestringthatshouldneverbeavalidfobjectid");
-        Request request2 = new Request(null, "someotherstringthatshouldneverbeavalidfobjectid");
-        List<Response> responses = Request.executeBatchAndWait(request1, request2);
-
-        assertEquals(2, responses.size());
-        assertTrue(responses.get(0).getError() != null);
-        assertTrue(responses.get(1).getError() != null);
-
-        FacebookRequestError error = responses.get(0).getError();
-        assertTrue(error.getException() instanceof FacebookServiceException);
-        assertTrue(error.getErrorType() != null);
-        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
-    }
-
-    @LargeTest
-    public void testBatchPostStatusUpdate() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        GraphObject statusUpdate1 = createStatusUpdate();
-        GraphObject statusUpdate2 = createStatusUpdate();
-
-        Request postRequest1 = Request.newPostRequest(session, "me/feed", statusUpdate1, null);
-        postRequest1.setBatchEntryName("postRequest1");
-        Request postRequest2 = Request.newPostRequest(session, "me/feed", statusUpdate2, null);
-        postRequest2.setBatchEntryName("postRequest2");
-        Request getRequest1 = new Request(session, "{result=postRequest1:$.id}");
-        Request getRequest2 = new Request(session, "{result=postRequest2:$.id}");
-
-        List<Response> responses = Request.executeBatchAndWait(postRequest1, postRequest2, getRequest1, getRequest2);
-        assertNotNull(responses);
-        assertEquals(4, responses.size());
-        assertNoErrors(responses);
-
-        GraphObject retrievedStatusUpdate1 = responses.get(2).getGraphObject();
-        GraphObject retrievedStatusUpdate2 = responses.get(3).getGraphObject();
-        assertNotNull(retrievedStatusUpdate1);
-        assertNotNull(retrievedStatusUpdate2);
-
-        assertEquals(statusUpdate1.getProperty("message"), retrievedStatusUpdate1.getProperty("message"));
-        assertEquals(statusUpdate2.getProperty("message"), retrievedStatusUpdate2.getProperty("message"));
-    }
-
-    @LargeTest
-    public void testTwoDifferentAccessTokens() {
-        TestSession session1 = openTestSessionWithSharedUser();
-        TestSession session2 = openTestSessionWithSharedUser(SECOND_TEST_USER_TAG);
-
-        Request request1 = Request.newMeRequest(session1, null);
-        Request request2 = Request.newMeRequest(session2, null);
-
-        List<Response> responses = Request.executeBatchAndWait(request1, request2);
-        assertNotNull(responses);
-        assertEquals(2, responses.size());
-
-        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
-        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
-
-        assertNotNull(user1);
-        assertNotNull(user2);
-
-        assertFalse(user1.getId().equals(user2.getId()));
-        assertEquals(session1.getTestUserId(), user1.getId());
-        assertEquals(session2.getTestUserId(), user2.getId());
-    }
-
-    @LargeTest
-    public void testBatchWithValidSessionAndNoSession() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request request1 = new Request(session, "me");
-        Request request2 = new Request(null, "zuck");
-
-        List<Response> responses = Request.executeBatchAndWait(request1, request2);
-        assertNotNull(responses);
-        assertEquals(2, responses.size());
-
-        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
-        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
-
-        assertNotNull(user1);
-        assertNotNull(user2);
-
-        assertFalse(user1.getId().equals(user2.getId()));
-        assertEquals(session.getTestUserId(), user1.getId());
-        assertEquals("4", user2.getId());
-    }
-
-    @LargeTest
-    public void testBatchWithNoSessionAndValidSession() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request request1 = new Request(null, "zuck");
-        Request request2 = new Request(session, "me");
-
-        List<Response> responses = Request.executeBatchAndWait(request1, request2);
-        assertNotNull(responses);
-        assertEquals(2, responses.size());
-
-        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
-        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
-
-        assertNotNull(user1);
-        assertNotNull(user2);
-
-        assertFalse(user1.getId().equals(user2.getId()));
-        assertEquals("4", user1.getId());
-        assertEquals(session.getTestUserId(), user2.getId());
-    }
-
-    @LargeTest
-    public void testBatchWithTwoSessionlessRequestsAndDefaultAppID() {
-        TestSession session = getTestSessionWithSharedUser(null);
-        String appId = session.getApplicationId();
-        Request.setDefaultBatchApplicationId(appId);
-
-        Request request1 = new Request(null, "zuck");
-        Request request2 = new Request(null, "zuck");
-
-        List<Response> responses = Request.executeBatchAndWait(request1, request2);
-        assertNotNull(responses);
-        assertEquals(2, responses.size());
-
-        GraphUser user1 = responses.get(0).getGraphObjectAs(GraphUser.class);
-        GraphUser user2 = responses.get(1).getGraphObjectAs(GraphUser.class);
-
-        assertNotNull(user1);
-        assertNotNull(user2);
-
-        assertEquals("4", user1.getId());
-        assertEquals("4", user2.getId());
-    }
-
-    @LargeTest
-    public void testMixedSuccessAndFailure() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        final int NUM_REQUESTS = 8;
-        Request[] requests = new Request[NUM_REQUESTS];
-        for (int i = 0; i < NUM_REQUESTS; ++i) {
-            boolean shouldSucceed = (i % 2) == 1;
-            requests[i] = new Request(session, shouldSucceed ? "me" : "-1");
-        }
-
-        List<Response> responses = Request.executeBatchAndWait(requests);
-        assertNotNull(responses);
-        assertEquals(NUM_REQUESTS, responses.size());
-
-        for (int i = 0; i < NUM_REQUESTS; ++i) {
-            boolean shouldSucceed = (i % 2) == 1;
-
-            Response response = responses.get(i);
-            assertNotNull(response);
-            if (shouldSucceed) {
-                assertNull(response.getError());
-                assertNotNull(response.getGraphObject());
-            } else {
-                assertNotNull(response.getError());
-                assertNull(response.getGraphObject());
-            }
-        }
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testClosedSessionDoesntAppendAccessToken() {
-        TestSession session = openTestSessionWithSharedUser();
-        session.close();
-        Request request1 = new Request(session, "me", null, null, new ExpectFailureCallback());
-        Request request2 = new Request(session, "me", null, null, new ExpectFailureCallback());
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(request1, request2);
-        task.executeOnBlockerThread();
-
-        waitAndAssertSuccess(2);
-    }
-
-    @LargeTest
-    public void testBatchUploadPhoto() {
-        TestSession session = openTestSessionWithSharedUserAndPermissions(null, "user_photos");
-
-        final int image1Size = 120;
-        final int image2Size = 150;
-
-        Bitmap bitmap1 = createTestBitmap(image1Size);
-        Bitmap bitmap2 = createTestBitmap(image2Size);
-
-        Request uploadRequest1 = Request.newUploadPhotoRequest(session, bitmap1, null);
-        uploadRequest1.setBatchEntryName("uploadRequest1");
-        Request uploadRequest2 = Request.newUploadPhotoRequest(session, bitmap2, null);
-        uploadRequest2.setBatchEntryName("uploadRequest2");
-        Request getRequest1 = new Request(session, "{result=uploadRequest1:$.id}");
-        Request getRequest2 = new Request(session, "{result=uploadRequest2:$.id}");
-
-        List<Response> responses = Request.executeBatchAndWait(uploadRequest1, uploadRequest2, getRequest1, getRequest2);
-        assertNotNull(responses);
-        assertEquals(4, responses.size());
-        assertNoErrors(responses);
-
-        GraphObject retrievedPhoto1 = responses.get(2).getGraphObject();
-        GraphObject retrievedPhoto2 = responses.get(3).getGraphObject();
-        assertNotNull(retrievedPhoto1);
-        assertNotNull(retrievedPhoto2);
-
-        assertEquals(image1Size, retrievedPhoto1.getProperty("width"));
-        assertEquals(image2Size, retrievedPhoto2.getProperty("width"));
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCallbacksAreCalled() {
-        setBatchApplicationIdForTestApp();
-
-        ArrayList<Request> requests = new ArrayList<Request>();
-        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
-
-        final int NUM_REQUESTS = 4;
-        for (int i = 0; i < NUM_REQUESTS; ++i) {
-            Request request = new Request(null, "4");
-
-            request.setCallback(new Request.Callback() {
-                @Override
-                public void onCompleted(Response response) {
-                    calledBack.add(true);
-                }
-            });
-
-            requests.add(request);
-        }
-
-        List<Response> responses = Request.executeBatchAndWait(requests);
-        assertNotNull(responses);
-        assertTrue(calledBack.size() == NUM_REQUESTS);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCacheMyFriendsRequest() throws IOException {
-        Response.getResponseCache().clearForTest();
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request request = Request.newMyFriendsRequest(session, null);
-
-        CacheableRequestBatch batch = new CacheableRequestBatch(request);
-        batch.setCacheKeyOverride("MyFriends");
-
-        // Running the request with empty cache should hit the server.
-        List<Response> responses = Request.executeBatchAndWait(batch);
-        assertNotNull(responses);
-        assertEquals(1, responses.size());
-
-        Response response = responses.get(0);
-        assertNotNull(response);
-        assertNull(response.getError());
-        assertTrue(!response.getIsFromCache());
-
-        // Running again should hit the cache.
-        responses = Request.executeBatchAndWait(batch);
-        assertNotNull(responses);
-        assertEquals(1, responses.size());
-
-        response = responses.get(0);
-        assertNotNull(response);
-        assertNull(response.getError());
-        assertTrue(response.getIsFromCache());
-
-        // Forcing roundtrip should hit the server again.
-        batch.setForceRoundTrip(true);
-        responses = Request.executeBatchAndWait(batch);
-        assertNotNull(responses);
-        assertEquals(1, responses.size());
-
-        response = responses.get(0);
-        assertNotNull(response);
-        assertNull(response.getError());
-        assertTrue(!response.getIsFromCache());
-
-        Response.getResponseCache().clearForTest();
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCacheMeAndMyFriendsRequest() throws IOException {
-        Response.getResponseCache().clearForTest();
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request requestMe = Request.newMeRequest(session, null);
-        Request requestMyFriends = Request.newMyFriendsRequest(session, null);
-
-        CacheableRequestBatch batch = new CacheableRequestBatch(new Request[] { requestMyFriends, requestMe });
-        batch.setCacheKeyOverride("MyFriends");
-
-        // Running the request with empty cache should hit the server.
-        List<Response> responses = Request.executeBatchAndWait(batch);
-        assertNotNull(responses);
-        assertEquals(2, responses.size());
-
-        for (Response response : responses) {
-            assertNotNull(response);
-            assertNull(response.getError());
-            assertTrue(!response.getIsFromCache());
-        }
-
-        // Running again should hit the cache.
-        responses = Request.executeBatchAndWait(batch);
-        assertNotNull(responses);
-        assertEquals(2, responses.size());
-
-        for (Response response : responses) {
-            assertNotNull(response);
-            assertNull(response.getError());
-            assertTrue(response.getIsFromCache());
-        }
-
-        // Forcing roundtrip should hit the server again.
-        batch.setForceRoundTrip(true);
-        responses = Request.executeBatchAndWait(batch);
-        assertNotNull(responses);
-        assertEquals(2, responses.size());
-
-        for (Response response : responses) {
-            assertNotNull(response);
-            assertNull(response.getError());
-            assertTrue(!response.getIsFromCache());
-        }
-
-        Response.getResponseCache().clearForTest();
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExplicitDependencyDefaultsToOmitFirstResponse() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request requestMe = Request.newMeRequest(session, null);
-        requestMe.setBatchEntryName("me_request");
-
-        Request requestMyFriends = Request.newMyFriendsRequest(session, null);
-        requestMyFriends.setBatchEntryDependsOn("me_request");
-
-        List<Response> responses = Request.executeBatchAndWait(requestMe, requestMyFriends);
-
-        Response meResponse = responses.get(0);
-        Response myFriendsResponse = responses.get(1);
-
-        assertNull(meResponse.getGraphObject());
-        assertNotNull(myFriendsResponse.getGraphObject());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExplicitDependencyCanIncludeFirstResponse() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request requestMe = Request.newMeRequest(session, null);
-        requestMe.setBatchEntryName("me_request");
-        requestMe.setBatchEntryOmitResultOnSuccess(false);
-
-        Request requestMyFriends = Request.newMyFriendsRequest(session, null);
-        requestMyFriends.setBatchEntryDependsOn("me_request");
-
-        List<Response> responses = Request.executeBatchAndWait(requestMe, requestMyFriends);
-
-        Response meResponse = responses.get(0);
-        Response myFriendsResponse = responses.get(1);
-
-        assertNotNull(meResponse.getGraphObject());
-        assertNotNull(myFriendsResponse.getGraphObject());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testAddAndRemoveBatchCallbacks() {
-        RequestBatch batch = new RequestBatch();
-
-        RequestBatch.Callback callback1 = new RequestBatch.Callback() {
-            @Override
-            public void onBatchCompleted(RequestBatch batch) {
-            }
-        };
-
-        RequestBatch.Callback callback2 = new RequestBatch.Callback() {
-            @Override
-            public void onBatchCompleted(RequestBatch batch) {
-            }
-        };
-
-        batch.addCallback(callback1);
-        batch.addCallback(callback2);
-
-        assertEquals(2, batch.getCallbacks().size());
-
-        batch.removeCallback(callback1);
-        batch.removeCallback(callback2);
-
-        assertEquals(0, batch.getCallbacks().size());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testBatchCallbackIsCalled() {
-        final AtomicInteger count = new AtomicInteger();
-        Request request1 = Request.newGraphPathRequest(null, "4", new Request.Callback() {
-            @Override
-            public void onCompleted(Response response) {
-                count.incrementAndGet();
-            }
-        });
-        Request request2 = Request.newGraphPathRequest(null, "4", new Request.Callback() {
-            @Override
-            public void onCompleted(Response response) {
-                count.incrementAndGet();
-            }
-        });
-
-        RequestBatch batch = new RequestBatch(request1, request2);
-        batch.addCallback(new RequestBatch.Callback() {
-            @Override
-            public void onBatchCompleted(RequestBatch batch) {
-                count.incrementAndGet();
-            }
-        });
-
-        batch.executeAndWait();
-        assertEquals(3, count.get());
-    }
-}
diff --git a/facebook/tests/src/com/facebook/FacebookActivityTestCase.java b/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
deleted file mode 100644
index 458c1f926..000000000
--- a/facebook/tests/src/com/facebook/FacebookActivityTestCase.java
+++ /dev/null
@@ -1,680 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.app.Activity;
-import android.content.res.AssetManager;
-import android.graphics.Bitmap;
-import android.graphics.Color;
-import android.os.Bundle;
-import android.os.ConditionVariable;
-import android.os.Handler;
-import android.test.ActivityInstrumentationTestCase2;
-import android.util.Log;
-import com.facebook.model.GraphObject;
-import com.facebook.internal.Utility;
-import junit.framework.AssertionFailedError;
-import org.json.JSONException;
-import org.json.JSONObject;
-import org.json.JSONTokener;
-
-import java.io.*;
-import java.net.HttpURLConnection;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-public class FacebookActivityTestCase<T extends Activity> extends ActivityInstrumentationTestCase2<T> {
-    private static final String TAG = FacebookActivityTestCase.class.getSimpleName();
-
-    private static String applicationId;
-    private static String applicationSecret;
-
-    public final static String SECOND_TEST_USER_TAG = "Second";
-    public final static String THIRD_TEST_USER_TAG = "Third";
-
-    private TestBlocker testBlocker;
-
-    protected synchronized TestBlocker getTestBlocker() {
-        if (testBlocker == null) {
-            testBlocker = TestBlocker.createTestBlocker();
-        }
-        return testBlocker;
-    }
-
-    public FacebookActivityTestCase(Class<T> activityClass) {
-        super("", activityClass);
-    }
-
-    // Returns an un-opened TestSession
-    protected TestSession getTestSessionWithSharedUser() {
-        return getTestSessionWithSharedUser(null);
-    }
-
-    // Returns an un-opened TestSession
-    protected TestSession getTestSessionWithSharedUser(String sessionUniqueUserTag) {
-        return getTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, new ArrayList<String>());
-    }
-
-    protected TestSession getTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
-            List<String> permissions) {
-        return TestSession.createSessionWithSharedUser(getActivity(), permissions, sessionUniqueUserTag);
-    }
-
-    // Returns an un-opened TestSession
-    protected TestSession getTestSessionWithPrivateUser(TestBlocker testBlocker) {
-        return TestSession.createSessionWithPrivateUser(getActivity(), null);
-    }
-
-    protected TestSession openTestSessionWithSharedUser(final TestBlocker blocker) {
-        return openTestSessionWithSharedUser(blocker, null);
-    }
-
-    protected TestSession openTestSessionWithSharedUser(final TestBlocker blocker, String sessionUniqueUserTag) {
-        TestSession session = getTestSessionWithSharedUser();
-        openSession(getActivity(), session, blocker);
-        return session;
-    }
-
-    protected TestSession openTestSessionWithSharedUser() {
-        return openTestSessionWithSharedUser((String) null);
-    }
-
-    protected TestSession openTestSessionWithSharedUser(String sessionUniqueUserTag) {
-        return openTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, (String[]) null);
-    }
-
-    protected TestSession openTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
-            String... permissions) {
-        List<String> permissionList = (permissions != null) ? Arrays.asList(permissions) : null;
-        return openTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, permissionList);
-    }
-
-    protected TestSession openTestSessionWithSharedUserAndPermissions(String sessionUniqueUserTag,
-            List<String> permissions) {
-        final TestBlocker blocker = getTestBlocker();
-        TestSession session = getTestSessionWithSharedUserAndPermissions(sessionUniqueUserTag, permissions);
-        openSession(getActivity(), session, blocker);
-        return session;
-    }
-
-    // Turns exceptions from the TestBlocker into JUnit assertions
-    protected void waitAndAssertSuccess(TestBlocker testBlocker, int numSignals) {
-        try {
-            testBlocker.waitForSignalsAndAssertSuccess(numSignals);
-        } catch (AssertionFailedError e) {
-            throw e;
-        } catch (Exception e) {
-            fail("Got exception: " + e.getMessage());
-        }
-    }
-
-    protected void waitAndAssertSuccess(int numSignals) {
-        waitAndAssertSuccess(getTestBlocker(), numSignals);
-    }
-
-    protected void waitAndAssertSuccessOrRethrow(int numSignals) throws Exception {
-        getTestBlocker().waitForSignalsAndAssertSuccess(numSignals);
-    }
-
-    protected void runAndBlockOnUiThread(final int expectedSignals, final Runnable runnable) throws Throwable {
-        final TestBlocker blocker = getTestBlocker();
-        runTestOnUiThread(new Runnable() {
-            @Override
-            public void run() {
-                runnable.run();
-                blocker.signal();
-            }
-        });
-        // We wait for the operation to complete; wait for as many other signals as we expect.
-        blocker.waitForSignals(1 + expectedSignals);
-        // Wait for the UI thread to become idle so any UI updates the runnable triggered have a chance
-        // to finish before we return.
-        getInstrumentation().waitForIdleSync();
-    }
-
-    protected synchronized void readApplicationIdAndSecret() {
-        synchronized (FacebookTestCase.class) {
-            if (applicationId != null && applicationSecret != null) {
-                return;
-            }
-
-            AssetManager assets = getInstrumentation().getContext().getResources().getAssets();
-            InputStream stream = null;
-            final String errorMessage = "could not read applicationId and applicationSecret from config.json; ensure "
-                    + "you have run 'configure_unit_tests.sh'. Error: ";
-            try {
-                stream = assets.open("config.json");
-                String string = Utility.readStreamToString(stream);
-
-                JSONTokener tokener = new JSONTokener(string);
-                Object obj = tokener.nextValue();
-                if (!(obj instanceof JSONObject)) {
-                    fail(errorMessage + "could not deserialize a JSONObject");
-                }
-                JSONObject jsonObject = (JSONObject) obj;
-
-                applicationId = jsonObject.optString("applicationId");
-                applicationSecret = jsonObject.optString("applicationSecret");
-
-                if (Utility.isNullOrEmpty(applicationId) || Utility.isNullOrEmpty(applicationSecret)) {
-                    fail(errorMessage + "one or both config values are missing");
-                }
-
-                TestSession.setTestApplicationId(applicationId);
-                TestSession.setTestApplicationSecret(applicationSecret);
-            } catch (IOException e) {
-                fail(errorMessage + e.toString());
-            } catch (JSONException e) {
-                fail(errorMessage + e.toString());
-            } finally {
-                if (stream != null) {
-                    try {
-                        stream.close();
-                    } catch (IOException e) {
-                        fail(errorMessage + e.toString());
-                    }
-                }
-            }
-        }
-    }
-
-    protected void openSession(Activity activity, TestSession session) {
-        final TestBlocker blocker = getTestBlocker();
-        openSession(activity, session, blocker);
-    }
-
-    protected void openSession(Activity activity, TestSession session, final TestBlocker blocker) {
-        Session.OpenRequest openRequest = new Session.OpenRequest(activity).
-                setCallback(new Session.StatusCallback() {
-                    boolean signaled = false;
-
-                    @Override
-                    public void call(Session session, SessionState state, Exception exception) {
-                        if (exception != null) {
-                            Log.w(TAG,
-                                    "openSession: received an error opening session: " + exception.toString());
-                        }
-                        assertTrue(exception == null);
-                        // Only signal once, or we might screw up the count on the blocker.
-                        if (!signaled) {
-                            blocker.signal();
-                            signaled = true;
-                        }
-                    }
-                });
-
-        session.openForRead(openRequest);
-        waitAndAssertSuccess(blocker, 1);
-    }
-
-    protected void setUp() throws Exception {
-        super.setUp();
-
-        // Make sure we have read application ID and secret.
-        readApplicationIdAndSecret();
-
-        // These are useful for debugging unit test failures.
-        Settings.addLoggingBehavior(LoggingBehavior.REQUESTS);
-        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);
-
-        // We want the UI thread to be in StrictMode to catch any violations.
-        turnOnStrictModeForUiThread();
-    }
-
-    protected void tearDown() throws Exception {
-        super.tearDown();
-
-        if (testBlocker != null) {
-            testBlocker.quit();
-        }
-    }
-
-    protected Bundle getNativeLinkingExtras(String token) {
-        Bundle extras = new Bundle();
-        String extraLaunchUriString = String
-                .format("fbrpc://facebook/nativethirdparty?app_id=%s&package_name=com.facebook.sdk.tests&class_name=com.facebook.FacebookActivityTests$FacebookTestActivity&access_token=%s",
-                        TestSession.getTestApplicationId(), token);
-        extras.putString("extra_launch_uri", extraLaunchUriString);
-        extras.putString("expires_in", "3600");
-        extras.putLong("app_id", Long.parseLong(TestSession.getTestApplicationId()));
-        extras.putString("access_token", token);
-
-        return extras;
-    }
-
-    interface GraphObjectPostResult extends GraphObject {
-        String getId();
-    }
-
-    protected GraphObject getAndAssert(Session session, String id) {
-        Request request = new Request(session, id);
-        Response response = request.executeAndWait();
-        assertNotNull(response);
-
-        assertNull(response.getError());
-
-        GraphObject result = response.getGraphObject();
-        assertNotNull(result);
-
-        return result;
-    }
-
-    protected GraphObject postGetAndAssert(Session session, String path, GraphObject graphObject) {
-        Request request = Request.newPostRequest(session, path, graphObject, null);
-        Response response = request.executeAndWait();
-        assertNotNull(response);
-
-        assertNull(response.getError());
-
-        GraphObjectPostResult result = response.getGraphObjectAs(GraphObjectPostResult.class);
-        assertNotNull(result);
-        assertNotNull(result.getId());
-
-        return getAndAssert(session, result.getId());
-    }
-
-    protected void setBatchApplicationIdForTestApp() {
-        String appId = TestSession.getTestApplicationId();
-        Request.setDefaultBatchApplicationId(appId);
-    }
-
-    protected <U extends GraphObject> U batchCreateAndGet(Session session, String graphPath, GraphObject graphObject,
-            String fields, Class<U> resultClass) {
-        Request create = Request.newPostRequest(session, graphPath, graphObject, new ExpectSuccessCallback());
-        create.setBatchEntryName("create");
-        Request get = Request.newGraphPathRequest(session, "{result=create:$.id}", new ExpectSuccessCallback());
-        if (fields != null) {
-            Bundle parameters = new Bundle();
-            parameters.putString("fields", fields);
-            get.setParameters(parameters);
-        }
-
-        return batchPostAndGet(create, get, resultClass);
-    }
-
-    protected <U extends GraphObject> U batchUpdateAndGet(Session session, String graphPath, GraphObject graphObject,
-            String fields, Class<U> resultClass) {
-        Request update = Request.newPostRequest(session, graphPath, graphObject, new ExpectSuccessCallback());
-        Request get = Request.newGraphPathRequest(session, graphPath, new ExpectSuccessCallback());
-        if (fields != null) {
-            Bundle parameters = new Bundle();
-            parameters.putString("fields", fields);
-            get.setParameters(parameters);
-        }
-
-        return batchPostAndGet(update, get, resultClass);
-    }
-
-    protected <U extends GraphObject> U batchPostAndGet(Request post, Request get, Class<U> resultClass) {
-        List<Response> responses = Request.executeBatchAndWait(post, get);
-        assertEquals(2, responses.size());
-
-        U resultGraphObject = responses.get(1).getGraphObjectAs(resultClass);
-        assertNotNull(resultGraphObject);
-        return resultGraphObject;
-    }
-
-    protected GraphObject createStatusUpdate() {
-        GraphObject statusUpdate = GraphObject.Factory.create();
-        String message = String.format(
-                "Check out my awesome new status update posted at: %s. Some chars for you: +\"[]:,", new Date());
-        statusUpdate.setProperty("message", message);
-        return statusUpdate;
-    }
-
-    protected Bitmap createTestBitmap(int size) {
-        Bitmap image = Bitmap.createBitmap(size, size, Bitmap.Config.RGB_565);
-        image.eraseColor(Color.BLUE);
-        return image;
-    }
-
-    protected void issueFriendRequest(TestSession session, String targetUserId) {
-        String graphPath = "me/friends/" + targetUserId;
-        Request request = Request.newPostRequest(session, graphPath, null, null);
-        Response response = request.executeAndWait();
-        // We will get a 400 error if the users are already friends.
-        FacebookRequestError error = response.getError();
-        assertTrue(error == null || error.getRequestStatusCode() == 400);
-    }
-
-    protected void makeTestUsersFriends(TestSession session1, TestSession session2) {
-        issueFriendRequest(session1, session2.getTestUserId());
-        issueFriendRequest(session2, session1.getTestUserId());
-    }
-
-    protected void assertDateEqualsWithinDelta(Date expected, Date actual, long deltaInMsec) {
-        long delta = Math.abs(expected.getTime() - actual.getTime());
-        assertTrue(delta < deltaInMsec);
-    }
-
-    protected void assertDateDiffersWithinDelta(Date expected, Date actual, long expectedDifference, long deltaInMsec) {
-        long delta = Math.abs(expected.getTime() - actual.getTime()) - expectedDifference;
-        assertTrue(delta < deltaInMsec);
-    }
-
-    protected void assertNoErrors(List<Response> responses) {
-        for (int i = 0; i < responses.size(); ++i) {
-            Response response = responses.get(i);
-            assertNotNull(response);
-            assertNull(response.getError());
-        }
-    }
-
-    protected File createTempFileFromAsset(String assetPath) throws IOException {
-        InputStream inputStream = null;
-        FileOutputStream outStream = null;
-
-        try {
-            AssetManager assets = getInstrumentation().getContext().getResources().getAssets();
-            inputStream = assets.open(assetPath);
-
-            File outputDir = getActivity().getCacheDir(); // context being the Activity pointer
-            File outputFile = File.createTempFile("prefix", assetPath, outputDir);
-            outStream = new FileOutputStream(outputFile);
-
-            final int bufferSize = 1024 * 2;
-            byte[] buffer = new byte[bufferSize];
-            int n = 0;
-            while ((n = inputStream.read(buffer)) != -1) {
-                outStream.write(buffer, 0, n);
-            }
-
-            return outputFile;
-        } finally {
-            Utility.closeQuietly(outStream);
-            Utility.closeQuietly(inputStream);
-        }
-    }
-
-    protected void runOnBlockerThread(final Runnable runnable, boolean waitForCompletion) {
-        Runnable runnableToPost = runnable;
-        final ConditionVariable condition = waitForCompletion ? new ConditionVariable(!waitForCompletion) : null;
-
-        if (waitForCompletion) {
-            runnableToPost = new Runnable() {
-                @Override
-                public void run() {
-                    runnable.run();
-                    condition.open();
-                }
-            };
-        }
-
-        TestBlocker blocker = getTestBlocker();
-        Handler handler = blocker.getHandler();
-        handler.post(runnableToPost);
-
-        if (waitForCompletion) {
-            boolean success = condition.block(10000);
-            assertTrue(success);
-        }
-    }
-
-    protected void closeBlockerAndAssertSuccess() {
-        TestBlocker blocker = getTestBlocker();
-        testBlocker = null;
-
-        blocker.quit();
-
-        boolean joined = false;
-        while (!joined) {
-            try {
-                blocker.join();
-                joined = true;
-            } catch (InterruptedException e) {
-            }
-        }
-
-        try {
-            blocker.assertSuccess();
-        } catch (Exception e) {
-            fail(e.toString());
-        }
-    }
-
-    protected TestRequestAsyncTask createAsyncTaskOnUiThread(final Request... requests) throws Throwable {
-        final ArrayList<TestRequestAsyncTask> result = new ArrayList<TestRequestAsyncTask>();
-        runTestOnUiThread(new Runnable() {
-            @Override
-            public void run() {
-                result.add(new TestRequestAsyncTask(requests));
-            }
-        });
-        return result.isEmpty() ? null : result.get(0);
-    }
-
-
-    /*
-     * Classes and helpers related to asynchronous requests.
-     */
-
-    // A subclass of RequestAsyncTask that knows how to interact with TestBlocker to ensure that tests can wait
-    // on and assert success of async tasks.
-    protected class TestRequestAsyncTask extends RequestAsyncTask {
-        private final TestBlocker blocker = FacebookActivityTestCase.this.getTestBlocker();
-
-        public TestRequestAsyncTask(Request... requests) {
-            super(requests);
-        }
-
-        public TestRequestAsyncTask(List<Request> requests) {
-            super(requests);
-        }
-
-        public TestRequestAsyncTask(RequestBatch requests) {
-            super(requests);
-        }
-
-        public TestRequestAsyncTask(HttpURLConnection connection, Request... requests) {
-            super(connection, requests);
-        }
-
-        public TestRequestAsyncTask(HttpURLConnection connection, List<Request> requests) {
-            super(connection, requests);
-        }
-
-        public TestRequestAsyncTask(HttpURLConnection connection, RequestBatch requests) {
-            super(connection, requests);
-        }
-
-        public final TestBlocker getBlocker() {
-            return blocker;
-        }
-
-        public final Exception getThrowable() {
-            return getException();
-        }
-
-        protected void onPostExecute(List<Response> result) {
-            try {
-                super.onPostExecute(result);
-
-                if (getException() != null) {
-                    blocker.setException(getException());
-                }
-            } finally {
-                Log.d("TestRequestAsyncTask", "signaling blocker");
-                blocker.signal();
-            }
-        }
-
-        // In order to be able to block and accumulate exceptions, we want to ensure the async task is really
-        // being started on the blocker's thread, rather than the test's thread. Use this instead of calling
-        // execute directly in unit tests.
-        public void executeOnBlockerThread() {
-            ensureAsyncTaskLoaded();
-
-            Runnable runnable = new Runnable() {
-                public void run() {
-                    execute();
-                }
-            };
-            Handler handler = new Handler(blocker.getLooper());
-            handler.post(runnable);
-        }
-
-        private void ensureAsyncTaskLoaded() {
-            // Work around this issue on earlier frameworks: http://stackoverflow.com/a/7818839/782044
-            try {
-                runAndBlockOnUiThread(0, new Runnable() {
-                    @Override
-                    public void run() {
-                        try {
-                            Class.forName("android.os.AsyncTask");
-                        } catch (ClassNotFoundException e) {
-                        }
-                    }
-                });
-            } catch (Throwable throwable) {
-            }
-        }
-    }
-
-    // Provides an implementation of Request.Callback that will assert either success (no error) or failure (error)
-    // of a request, and allow derived classes to perform additional asserts.
-    protected class TestCallback implements Request.Callback {
-        private final TestBlocker blocker;
-        private final boolean expectSuccess;
-
-        public TestCallback(TestBlocker blocker, boolean expectSuccess) {
-            this.blocker = blocker;
-            this.expectSuccess = expectSuccess;
-        }
-
-        public TestCallback(boolean expectSuccess) {
-            this(FacebookActivityTestCase.this.getTestBlocker(), expectSuccess);
-        }
-
-        @Override
-        public void onCompleted(Response response) {
-            try {
-                // We expect to be called on the right thread.
-                if (Thread.currentThread() != blocker) {
-                    throw new FacebookException("Invalid thread " + Thread.currentThread().getId()
-                            + "; expected to be called on thread " + blocker.getId());
-                }
-
-                // We expect either success or failure.
-                if (expectSuccess && response.getError() != null) {
-                    throw response.getError().getException();
-                } else if (!expectSuccess && response.getError() == null) {
-                    throw new FacebookException("Expected failure case, received no error");
-                }
-
-                // Some tests may want more fine-grained control and assert additional conditions.
-                performAsserts(response);
-            } catch (Exception e) {
-                blocker.setException(e);
-            } finally {
-                // Tell anyone waiting on us that this callback was called.
-                blocker.signal();
-            }
-        }
-
-        protected void performAsserts(Response response) {
-        }
-    }
-
-    // A callback that will assert if the request resulted in an error.
-    protected class ExpectSuccessCallback extends TestCallback {
-        public ExpectSuccessCallback() {
-            super(true);
-        }
-    }
-
-    // A callback that will assert if the request did NOT result in an error.
-    protected class ExpectFailureCallback extends TestCallback {
-        public ExpectFailureCallback() {
-            super(false);
-        }
-    }
-
-    public static abstract class MockRequest extends Request {
-        public abstract Response createResponse();
-    }
-
-    public static class MockRequestBatch extends RequestBatch {
-        public MockRequestBatch(MockRequest... requests) {
-            super(requests);
-        }
-
-        // Caller must ensure that all the requests in the batch are, in fact, MockRequests.
-        public MockRequestBatch(RequestBatch requests) {
-            super(requests);
-        }
-
-        @Override
-        List<Response> executeAndWaitImpl() {
-            List<Request> requests = getRequests();
-
-            List<Response> responses = new ArrayList<Response>();
-            for (Request request : requests) {
-                MockRequest mockRequest = (MockRequest) request;
-                responses.add(mockRequest.createResponse());
-            }
-
-            Request.runCallbacks(this, responses);
-
-            return responses;
-        }
-    }
-
-    private AtomicBoolean strictModeOnForUiThread = new AtomicBoolean();
-
-    protected void turnOnStrictModeForUiThread() {
-        // We only ever need to do this once. If the boolean is true, we know that the next runnable
-        // posted to the UI thread will have strict mode on.
-        if (strictModeOnForUiThread.get() == false) {
-            try {
-                runTestOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        // Double-check whether we really need to still do this on the UI thread.
-                        if (strictModeOnForUiThread.compareAndSet(false, true)) {
-                            turnOnStrictModeForThisThread();
-                        }
-                    }
-                });
-            } catch (Throwable throwable) {
-            }
-        }
-    }
-
-    protected void turnOnStrictModeForThisThread() {
-        // We use reflection, because Instrumentation will complain about any references to StrictMode in API versions < 9
-        // when attempting to run the unit tests. No particular effort has been made to make this efficient, since we
-        // expect to call it just once.
-        try {
-            ClassLoader loader = Thread.currentThread().getContextClassLoader();
-            Class<?> strictModeClass = Class.forName("android.os.StrictMode", true, loader);
-            Class<?> threadPolicyClass = Class.forName("android.os.StrictMode$ThreadPolicy", true, loader);
-            Class<?> threadPolicyBuilderClass = Class.forName("android.os.StrictMode$ThreadPolicy$Builder", true,
-                    loader);
-
-            Object threadPolicyBuilder = threadPolicyBuilderClass.getConstructor().newInstance();
-            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("detectAll").invoke(threadPolicyBuilder);
-            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("penaltyDeath").invoke(threadPolicyBuilder);
-
-            Object threadPolicy = threadPolicyBuilderClass.getMethod("build").invoke(threadPolicyBuilder);
-            strictModeClass.getMethod("setThreadPolicy", threadPolicyClass).invoke(strictModeClass, threadPolicy);
-        } catch (Exception ex) {
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/FacebookActivityTests.java b/facebook/tests/src/com/facebook/FacebookActivityTests.java
deleted file mode 100644
index cbb187582..000000000
--- a/facebook/tests/src/com/facebook/FacebookActivityTests.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-
-public class FacebookActivityTests extends FacebookActivityTestCase<FacebookActivityTests.FacebookTestActivity> {
-    public FacebookActivityTests() {
-        super(FacebookActivityTests.FacebookTestActivity.class);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-
-        Session activeSession = Session.getActiveSession();
-        if (activeSession != null) {
-            activeSession.closeAndClearTokenInformation();
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLaunchingWithEmptyIntent() {
-        Intent intent = new Intent(Intent.ACTION_MAIN);
-        setActivityIntent(intent);
-        FacebookTestActivity activity = getActivity();
-
-        assertNull(Session.getActiveSession());
-        assertFalse(activity.hasNativeLinkIntentForTesting());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLaunchingWithValidNativeLinkingIntent() {
-        final String token = "A token less unique than most";
-
-        Intent intent = new Intent(Intent.ACTION_MAIN);
-        intent.putExtras(getNativeLinkingExtras(token));
-        setActivityIntent(intent);
-
-        assertNull(Session.getActiveSession());
-
-        FacebookTestActivity activity = getActivity();
-        Session activeSession = Session.getActiveSession();
-        assertNull(activeSession);
-        assertTrue(activity.hasNativeLinkIntentForTesting());
-    }
-
-    public static class FacebookTestActivity extends Activity {
-        public boolean hasNativeLinkIntentForTesting() {
-            return AccessToken.createFromNativeLinkingIntent(getIntent()) != null;
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/FacebookRequestErrorTests.java b/facebook/tests/src/com/facebook/FacebookRequestErrorTests.java
deleted file mode 100644
index 63377e889..000000000
--- a/facebook/tests/src/com/facebook/FacebookRequestErrorTests.java
+++ /dev/null
@@ -1,321 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import com.facebook.sdk.tests.R;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-public class FacebookRequestErrorTests extends FacebookTestCase {
-    public static final String ERROR_SINGLE_RESPONSE =
-            "{\n" +
-            "  \"error\": {\n" +
-            "    \"message\": \"Unknown path components: /unknown\",\n" +
-            "    \"type\": \"OAuthException\",\n" +
-            "    \"code\": 2500\n" +
-            "  }\n" +
-            "}";
-
-    public static final String ERROR_BATCH_RESPONSE =
-            "[\n" +
-            "  {\n" +
-            "    \"headers\": [\n" +
-            "      {\n" +
-            "        \"value\": \"*\",\n" +
-            "        \"name\": \"Access-Control-Allow-Origin\"\n" +
-            "      },\n" +
-            "      {\n" +
-            "        \"value\": \"no-store\",\n" +
-            "        \"name\": \"Cache-Control\"\n" +
-            "      },\n" +
-            "      {\n" +
-            "        \"value\": \"close\",\n" +
-            "        \"name\": \"Connection\"\n" +
-            "      },\n" +
-            "      {\n" +
-            "        \"value\": \"text\\/javascript; charset=UTF-8\",\n" +
-            "        \"name\": \"Content-Type\"\n" +
-            "      },\n" +
-            "      {\n" +
-            "        \"value\": \"Sat, 01 Jan 2000 00:00:00 GMT\",\n" +
-            "        \"name\": \"Expires\"\n" +
-            "      },\n" +
-            "      {\n" +
-            "        \"value\": \"no-cache\",\n" +
-            "        \"name\": \"Pragma\"\n" +
-            "      },\n" +
-            "      {\n" +
-            "        \"value\": \"OAuth \\\"Facebook Platform\\\" \\\"invalid_request\\\" \\\"An active access token must be used to query information about the current user.\\\"\",\n" +
-            "        \"name\": \"WWW-Authenticate\"\n" +
-            "      }\n" +
-            "    ],\n" +
-            "    \"body\": \"{\\\"error\\\":{\\\"message\\\":\\\"An active access token must be used to query information about the current user.\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":2500}}\",\n" +
-            "    \"code\": 400\n" +
-            "  },\n" +
-            "  {\n" +
-            "    \"headers\": [\n" +
-            "      {\n" +
-            "        \"value\": \"*\",\n" +
-            "        \"name\": \"Access-Control-Allow-Origin\"\n" +
-            "      },\n" +
-            "      {\n" +
-            "        \"value\": \"no-store\",\n" +
-            "        \"name\": \"Cache-Control\"\n" +
-            "      },\n" +
-            "      {\n" +
-            "        \"value\": \"close\",\n" +
-            "        \"name\": \"Connection\"\n" +
-            "      },\n" +
-            "      {\n" +
-            "        \"value\": \"text\\/javascript; charset=UTF-8\",\n" +
-            "        \"name\": \"Content-Type\"\n" +
-            "      },\n" +
-            "      {\n" +
-            "        \"value\": \"Sat, 01 Jan 2000 00:00:00 GMT\",\n" +
-            "        \"name\": \"Expires\"\n" +
-            "      },\n" +
-            "      {\n" +
-            "        \"value\": \"no-cache\",\n" +
-            "        \"name\": \"Pragma\"\n" +
-            "      },\n" +
-            "      {\n" +
-            "        \"value\": \"OAuth \\\"Facebook Platform\\\" \\\"invalid_request\\\" \\\"An active access token must be used to query information about the current user.\\\"\",\n" +
-            "        \"name\": \"WWW-Authenticate\"\n" +
-            "      }\n" +
-            "    ],\n" +
-            "    \"body\": \"{\\\"error\\\":{\\\"message\\\":\\\"An active access token must be used to query information about the current user.\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":2500}}\",\n" +
-            "    \"code\": 400\n" +
-            "  }\n" +
-            "]";
-
-
-    public static final String ERROR_SINGLE_RESPONSE_THROTTLE =
-            "{\n" +
-            "  \"error\": {\n" +
-            "    \"message\": \"Application request limit reached\",\n" +
-            "    \"code\": 4\n" +
-            "  }\n" +
-            "}";
-
-    public static final String ERROR_SINGLE_RESPONSE_SERVER =
-            "{\n" +
-            "  \"error\": {\n" +
-            "    \"message\": \"Some Server Error\",\n" +
-            "    \"code\": 2\n" +
-            "  }\n" +
-            "}";
-
-    public static final String ERROR_SINGLE_RESPONSE_PERMISSION =
-            "{\n" +
-            "  \"error\": {\n" +
-            "    \"type\": \"OAuthException\",\n" +
-            "    \"message\": \"(#200) Requires extended permission: publish_actions\",\n" +
-            "    \"code\": 200\n" +
-            "  }\n" +
-            "}";
-
-    public static final String ERROR_SINGLE_RESPONSE_WEB_LOGIN =
-            "{\n" +
-            "  \"error\": {\n" +
-            "    \"message\": \"User need to login\",\n" +
-            "    \"type\": \"OAuthException\",\n" +
-            "    \"code\": 102,\n" +
-            "    \"error_subcode\": 459\n" +
-            "  }\n" +
-            "}";
-
-    public static final String ERROR_SINGLE_RESPONSE_RELOGIN =
-            "{\n" +
-            "  \"error\": {\n" +
-            "    \"message\": \"User need to relogin\",\n" +
-            "    \"type\": \"OAuthException\",\n" +
-            "    \"code\": 102\n" +
-            "  }\n" +
-            "}";
-
-    public static final String ERROR_SINGLE_RESPONSE_RELOGIN_DELETED_APP =
-            "{\n" +
-            "  \"error\": {\n" +
-            "    \"message\": \"User need to relogin\",\n" +
-            "    \"type\": \"OAuthException\",\n" +
-            "    \"code\": 190,\n" +
-            "    \"error_subcode\": 458\n" +
-            "  }\n" +
-            "}";
-
-    public void testClientException() {
-        final String errorMsg = "some error happened";
-        FacebookRequestError error = new FacebookRequestError(null, new FacebookException(errorMsg));
-        assertEquals(errorMsg, error.getErrorMessage());
-        assertEquals(FacebookRequestError.Category.CLIENT, error.getCategory());
-        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getErrorCode());
-        assertEquals(FacebookRequestError.INVALID_HTTP_STATUS_CODE, error.getRequestStatusCode());
-        assertEquals(0, error.getUserActionMessageId());
-    }
-
-    public void testSingleRequestWithoutBody() throws JSONException {
-        JSONObject withStatusCode = new JSONObject();
-        withStatusCode.put("code", 400);
-        FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCode, withStatusCode, null);
-        assertNotNull(error);
-        assertEquals(400, error.getRequestStatusCode());
-        assertEquals(FacebookRequestError.Category.BAD_REQUEST, error.getCategory());
-        assertEquals(0, error.getUserActionMessageId());
-    }
-
-    public void testSingleErrorWithBody() throws JSONException {
-        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE);
-        JSONObject withStatusCodeAndBody = new JSONObject();
-        withStatusCodeAndBody.put("code", 400);
-        withStatusCodeAndBody.put("body", originalResponse);
-        FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
-        assertNotNull(error);
-        assertEquals(400, error.getRequestStatusCode());
-        assertEquals("Unknown path components: /unknown", error.getErrorMessage());
-        assertEquals("OAuthException", error.getErrorType());
-        assertEquals(2500, error.getErrorCode());
-        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.BAD_REQUEST, error.getCategory());
-        assertEquals(0, error.getUserActionMessageId());
-    }
-
-    public void testBatchRequest() throws JSONException {
-        JSONArray batchResponse = new JSONArray(ERROR_BATCH_RESPONSE);
-        assertEquals(2, batchResponse.length());
-        JSONObject firstResponse = (JSONObject) batchResponse.get(0);
-        FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(firstResponse, batchResponse, null);
-        assertNotNull(error);
-        assertEquals(400, error.getRequestStatusCode());
-        assertEquals("An active access token must be used to query information about the current user.",
-                error.getErrorMessage());
-        assertEquals("OAuthException", error.getErrorType());
-        assertEquals(2500, error.getErrorCode());
-        assertTrue(error.getBatchRequestResult() instanceof  JSONArray);
-        assertEquals(FacebookRequestError.Category.BAD_REQUEST, error.getCategory());
-        assertEquals(0, error.getUserActionMessageId());
-    }
-
-    public void testSingleThrottledError() throws JSONException {
-        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_THROTTLE);
-        JSONObject withStatusCodeAndBody = new JSONObject();
-        withStatusCodeAndBody.put("code", 403);
-        withStatusCodeAndBody.put("body", originalResponse);
-        FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
-        assertNotNull(error);
-        assertEquals(403, error.getRequestStatusCode());
-        assertEquals("Application request limit reached", error.getErrorMessage());
-        assertNull(error.getErrorType());
-        assertEquals(4, error.getErrorCode());
-        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.THROTTLING, error.getCategory());
-        assertEquals(0, error.getUserActionMessageId());
-    }
-
-    public void testSingleServerError() throws JSONException {
-        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_SERVER);
-        JSONObject withStatusCodeAndBody = new JSONObject();
-        withStatusCodeAndBody.put("code", 500);
-        withStatusCodeAndBody.put("body", originalResponse);
-        FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
-        assertNotNull(error);
-        assertEquals(500, error.getRequestStatusCode());
-        assertEquals("Some Server Error", error.getErrorMessage());
-        assertNull(error.getErrorType());
-        assertEquals(2, error.getErrorCode());
-        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.SERVER, error.getCategory());
-        assertEquals(0, error.getUserActionMessageId());
-    }
-
-    public void testSinglePermissionError() throws JSONException {
-        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_PERMISSION);
-        JSONObject withStatusCodeAndBody = new JSONObject();
-        withStatusCodeAndBody.put("code", 400);
-        withStatusCodeAndBody.put("body", originalResponse);
-        FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
-        assertNotNull(error);
-        assertEquals(400, error.getRequestStatusCode());
-        assertEquals("(#200) Requires extended permission: publish_actions", error.getErrorMessage());
-        assertEquals("OAuthException", error.getErrorType());
-        assertEquals(200, error.getErrorCode());
-        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getSubErrorCode());
-        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.PERMISSION, error.getCategory());
-        assertEquals(R.string.com_facebook_requesterror_permissions, error.getUserActionMessageId());
-    }
-
-    public void testSingleWebLoginError() throws JSONException {
-        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_WEB_LOGIN);
-        JSONObject withStatusCodeAndBody = new JSONObject();
-        withStatusCodeAndBody.put("code", 400);
-        withStatusCodeAndBody.put("body", originalResponse);
-        FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
-        assertNotNull(error);
-        assertEquals(400, error.getRequestStatusCode());
-        assertEquals("User need to login", error.getErrorMessage());
-        assertEquals("OAuthException", error.getErrorType());
-        assertEquals(102, error.getErrorCode());
-        assertEquals(459, error.getSubErrorCode());
-        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.AUTHENTICATION_RETRY, error.getCategory());
-        assertEquals(R.string.com_facebook_requesterror_web_login, error.getUserActionMessageId());
-    }
-
-    public void testSingleReloginError() throws JSONException {
-        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_RELOGIN);
-        JSONObject withStatusCodeAndBody = new JSONObject();
-        withStatusCodeAndBody.put("code", 400);
-        withStatusCodeAndBody.put("body", originalResponse);
-        FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
-        assertNotNull(error);
-        assertEquals(400, error.getRequestStatusCode());
-        assertEquals("User need to relogin", error.getErrorMessage());
-        assertEquals("OAuthException", error.getErrorType());
-        assertEquals(102, error.getErrorCode());
-        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getSubErrorCode());
-        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.AUTHENTICATION_REOPEN_SESSION, error.getCategory());
-        assertEquals(R.string.com_facebook_requesterror_reconnect, error.getUserActionMessageId());
-    }
-
-    public void testSingleReloginDeletedAppError() throws JSONException {
-        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_RELOGIN_DELETED_APP);
-        JSONObject withStatusCodeAndBody = new JSONObject();
-        withStatusCodeAndBody.put("code", 400);
-        withStatusCodeAndBody.put("body", originalResponse);
-        FacebookRequestError error =
-                FacebookRequestError.checkResponseAndCreateError(withStatusCodeAndBody, originalResponse, null);
-        assertNotNull(error);
-        assertEquals(400, error.getRequestStatusCode());
-        assertEquals("User need to relogin", error.getErrorMessage());
-        assertEquals("OAuthException", error.getErrorType());
-        assertEquals(190, error.getErrorCode());
-        assertEquals(458, error.getSubErrorCode());
-        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
-        assertEquals(FacebookRequestError.Category.AUTHENTICATION_REOPEN_SESSION, error.getCategory());
-        assertEquals(R.string.com_facebook_requesterror_relogin, error.getUserActionMessageId());
-    }
-}
diff --git a/facebook/tests/src/com/facebook/FacebookTestCase.java b/facebook/tests/src/com/facebook/FacebookTestCase.java
deleted file mode 100644
index 37f892f05..000000000
--- a/facebook/tests/src/com/facebook/FacebookTestCase.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.app.Activity;
-
-public class FacebookTestCase extends FacebookActivityTestCase<FacebookTestCase.FacebookTestActivity> {
-    public FacebookTestCase() {
-        super(FacebookTestCase.FacebookTestActivity.class);
-        Settings.addLoggingBehavior(LoggingBehavior.REQUESTS);
-        Settings.addLoggingBehavior(LoggingBehavior.INCLUDE_RAW_RESPONSES);
-    }
-
-    public static class FacebookTestActivity extends Activity {
-    }
-}
-
diff --git a/facebook/tests/src/com/facebook/GraphRequestTests.java b/facebook/tests/src/com/facebook/GraphRequestTests.java
deleted file mode 100644
index 0a78dc1da..000000000
--- a/facebook/tests/src/com/facebook/GraphRequestTests.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.test.suitebuilder.annotation.LargeTest;
-import com.facebook.model.GraphObject;
-
-import java.util.Date;
-
-// These tests relate to serialization/de-serialization of graph objects in a variety of scenarios, rather than
-// to the underlying request/batch plumbing.
-public class GraphRequestTests extends FacebookTestCase {
-
-    @LargeTest
-    public void testCommentRoundTrip() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        GraphObject status = createStatusUpdate();
-        GraphObject createdStatus = batchCreateAndGet(session, "me/feed", status, null, GraphObject.class);
-        String statusID = (String) createdStatus.getProperty("id");
-
-        GraphObject comment = GraphObject.Factory.create();
-        final String commentMessage = "It truly is a wonderful status update.";
-        comment.setProperty("message", commentMessage);
-
-        GraphObject createdComment1 = batchCreateAndGet(session, statusID + "/comments", comment, null,
-                GraphObject.class);
-        assertNotNull(createdComment1);
-
-        String comment1ID = (String) createdComment1.getProperty("id");
-        String comment1Message = (String) createdComment1.getProperty("message");
-        assertNotNull(comment1ID);
-        assertNotNull(comment1Message);
-        assertEquals(commentMessage, comment1Message);
-
-        // Try posting the same comment to the same status update. We need to clear its ID first.
-        createdComment1.removeProperty("id");
-        GraphObject createdComment2 = batchCreateAndGet(session, statusID + "/comments", createdComment1, null,
-                GraphObject.class);
-        assertNotNull(createdComment2);
-
-        String comment2ID = (String) createdComment2.getProperty("id");
-        String comment2Message = (String) createdComment2.getProperty("message");
-        assertNotNull(comment2ID);
-        assertFalse(comment1ID.equals(comment2ID));
-        assertNotNull(comment2Message);
-        assertEquals(commentMessage, comment2Message);
-    }
-
-    @LargeTest
-    public void testEventRoundTrip() {
-        TestSession session = openTestSessionWithSharedUserAndPermissions(null, "create_event");
-
-        GraphObject event = GraphObject.Factory.create();
-        // Android emulators tend to not have the right date/time. To avoid issues with posting events in the past
-        // or too far in the future, we use a constant year. This test will break in 2030, angering our robot overlords.
-        Date startTime = new Date(130, 2, 17, 12, 34, 56);
-        event.setProperty("name", "My awesome St. Patrick's Day party on " + startTime.toString());
-        final String eventDescription = "This is a great event. You should all come.";
-        event.setProperty("description", eventDescription);
-        Date endTime = new Date(startTime.getTime() + 3600 * 1000);
-        event.setProperty("start_time", startTime);
-        event.setProperty("end_time", endTime);
-        event.setProperty("location", "My house");
-
-        GraphObject event1 = batchCreateAndGet(session, "me/events", event, null, GraphObject.class);
-        assertNotNull(event1);
-        assertEquals(eventDescription, event1.getProperty("description"));
-
-        event1.removeProperty("id");
-        GraphObject event2 = batchCreateAndGet(session, "me/events", event1, null, GraphObject.class);
-        assertNotNull(event2);
-        assertEquals(eventDescription, event2.getProperty("description"));
-    }
-
-}
diff --git a/facebook/tests/src/com/facebook/RequestTests.java b/facebook/tests/src/com/facebook/RequestTests.java
deleted file mode 100644
index dc60fe2c0..000000000
--- a/facebook/tests/src/com/facebook/RequestTests.java
+++ /dev/null
@@ -1,684 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.graphics.Bitmap;
-import android.location.Location;
-import android.net.Uri;
-import android.os.Bundle;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.model.*;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URISyntaxException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-public class RequestTests extends FacebookTestCase {
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateRequest() {
-        Request request = new Request();
-        assertTrue(request != null);
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreatePostRequest() {
-        GraphObject graphObject = GraphObject.Factory.create();
-        Request request = Request.newPostRequest(null, "me/statuses", graphObject, null);
-        assertTrue(request != null);
-        assertEquals(HttpMethod.POST, request.getHttpMethod());
-        assertEquals("me/statuses", request.getGraphPath());
-        assertEquals(graphObject, request.getGraphObject());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateMeRequest() {
-        Request request = Request.newMeRequest(null, null);
-        assertTrue(request != null);
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-        assertEquals("me", request.getGraphPath());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateMyFriendsRequest() {
-        Request request = Request.newMyFriendsRequest(null, null);
-        assertTrue(request != null);
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-        assertEquals("me/friends", request.getGraphPath());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateUploadPhotoRequest() {
-        Bitmap image = Bitmap.createBitmap(128, 128, Bitmap.Config.ALPHA_8);
-
-        Request request = Request.newUploadPhotoRequest(null, image, null);
-        assertTrue(request != null);
-
-        Bundle parameters = request.getParameters();
-        assertTrue(parameters != null);
-
-        assertTrue(parameters.containsKey("picture"));
-        assertEquals(image, parameters.getParcelable("picture"));
-        assertEquals("me/photos", request.getGraphPath());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreatePlacesSearchRequestWithLocation() {
-        Location location = new Location("");
-        location.setLatitude(47.6204);
-        location.setLongitude(-122.3491);
-
-        Request request = Request.newPlacesSearchRequest(null, location, 1000, 50, null, null);
-
-        assertTrue(request != null);
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-        assertEquals("search", request.getGraphPath());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreatePlacesSearchRequestWithSearchText() {
-        Request request = Request.newPlacesSearchRequest(null, null, 1000, 50, "Starbucks", null);
-
-        assertTrue(request != null);
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-        assertEquals("search", request.getGraphPath());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreatePlacesSearchRequestRequiresLocationOrSearchText() {
-        try {
-            Request request = Request.newPlacesSearchRequest(null, null, 1000, 50, null, null);
-            fail("expected exception");
-        } catch (FacebookException exception) {
-            // Success
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetHttpMethodToNilGivesDefault() {
-        Request request = new Request();
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-
-        request.setHttpMethod(null);
-        assertEquals(HttpMethod.GET, request.getHttpMethod());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testExecuteBatchWithNullRequestsThrows() {
-        try {
-            Request.executeBatchAndWait((Request[]) null);
-            fail("expected NullPointerException");
-        } catch (NullPointerException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testExecuteBatchWithZeroRequestsThrows() {
-        try {
-            Request.executeBatchAndWait(new Request[]{});
-            fail("expected IllegalArgumentException");
-        } catch (IllegalArgumentException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testExecuteBatchWithNullRequestThrows() {
-        try {
-            Request.executeBatchAndWait(new Request[]{null});
-            fail("expected NullPointerException");
-        } catch (NullPointerException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testToHttpConnectionWithNullRequestsThrows() {
-        try {
-            Request.toHttpConnection((Request[]) null);
-            fail("expected NullPointerException");
-        } catch (NullPointerException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testToHttpConnectionWithZeroRequestsThrows() {
-        try {
-            Request.toHttpConnection(new Request[]{});
-            fail("expected IllegalArgumentException");
-        } catch (IllegalArgumentException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testToHttpConnectionWithNullRequestThrows() {
-        try {
-            Request.toHttpConnection(new Request[]{null});
-            fail("expected NullPointerException");
-        } catch (NullPointerException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSingleGetToHttpRequest() throws Exception {
-        Request requestMe = new Request(null, "TourEiffel");
-        HttpURLConnection connection = Request.toHttpConnection(requestMe);
-
-        assertTrue(connection != null);
-
-        assertEquals("GET", connection.getRequestMethod());
-        assertEquals("/TourEiffel", connection.getURL().getPath());
-
-        assertTrue(connection.getRequestProperty("User-Agent").startsWith("FBAndroidSDK"));
-
-        Uri uri = Uri.parse(connection.getURL().toString());
-        assertEquals("android", uri.getQueryParameter("sdk"));
-        assertEquals("json", uri.getQueryParameter("format"));
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExecuteSingleGet() {
-        Request request = new Request(null, "TourEiffel");
-        Response response = request.executeAndWait();
-
-        assertTrue(response != null);
-        assertTrue(response.getError() == null);
-        assertTrue(response.getGraphObject() != null);
-
-        GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
-        assertEquals("Paris", graphPlace.getLocation().getCity());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExecuteSingleGetUsingHttpURLConnection() throws IOException {
-        Request request = new Request(null, "TourEiffel");
-        HttpURLConnection connection = Request.toHttpConnection(request);
-
-        List<Response> responses = Request.executeConnectionAndWait(connection, Arrays.asList(new Request[]{request}));
-        assertNotNull(responses);
-        assertEquals(1, responses.size());
-
-        Response response = responses.get(0);
-
-        assertTrue(response != null);
-        assertTrue(response.getError() == null);
-        assertTrue(response.getGraphObject() != null);
-
-        GraphPlace graphPlace = response.getGraphObjectAs(GraphPlace.class);
-        assertEquals("Paris", graphPlace.getLocation().getCity());
-
-        // Make sure calling code can still access HTTP headers and call disconnect themselves.
-        int code = connection.getResponseCode();
-        assertEquals(200, code);
-        assertTrue(connection.getHeaderFields().keySet().contains("Content-Length"));
-        connection.disconnect();
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testFacebookErrorResponseCreatesError() {
-        Request request = new Request(null, "somestringthatshouldneverbeavalidfobjectid");
-        Response response = request.executeAndWait();
-
-        assertTrue(response != null);
-
-        FacebookRequestError error = response.getError();
-        assertNotNull(error);
-        FacebookException exception = error.getException();
-        assertNotNull(exception);
-
-        assertTrue(exception instanceof FacebookServiceException);
-        assertNotNull(error.getErrorType());
-        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
-        assertNotNull(error.getRequestResultBody());
-    }
-
-    @LargeTest
-    public void testFacebookSuccessResponseWithErrorCodeCreatesError() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request request = Request.newRestRequest(session, "auth.extendSSOAccessToken", null, null);
-        assertNotNull(request);
-
-        // Because TestSession access tokens were not created via SSO, we expect to get an error from the service,
-        // but with a 200 (success) code.
-        Response response = request.executeAndWait();
-
-        assertTrue(response != null);
-
-        FacebookRequestError error = response.getError();
-        assertNotNull(error);
-
-        assertTrue(error.getException() instanceof FacebookServiceException);
-        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
-        assertNotNull(error.getRequestResultBody());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testRequestWithUnopenedSessionFails() {
-        TestSession session = getTestSessionWithSharedUser(null);
-        Request request = new Request(session, "me");
-        Response response = request.executeAndWait();
-
-        assertNotNull(response.getError());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExecuteRequestMe() {
-        TestSession session = openTestSessionWithSharedUser();
-        Request request = Request.newMeRequest(session, null);
-        Response response = request.executeAndWait();
-
-        validateMeResponse(session, response);
-    }
-
-    static void validateMeResponse(TestSession session, Response response) {
-        assertNull(response.getError());
-
-        GraphUser me = response.getGraphObjectAs(GraphUser.class);
-        assertNotNull(me);
-        assertEquals(session.getTestUserId(), me.getId());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExecuteMyFriendsRequest() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        Request request = Request.newMyFriendsRequest(session, null);
-        Response response = request.executeAndWait();
-
-        validateMyFriendsResponse(session, response);
-    }
-
-    static void validateMyFriendsResponse(TestSession session, Response response) {
-        assertNotNull(response);
-
-        assertNull(response.getError());
-
-        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
-        assertNotNull(graphResult);
-
-        List<GraphObject> results = graphResult.getData();
-        assertNotNull(results);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExecutePlaceRequestWithLocation() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        Location location = new Location("");
-        location.setLatitude(47.6204);
-        location.setLongitude(-122.3491);
-
-        Request request = Request.newPlacesSearchRequest(session, location, 5, 5, null, null);
-        Response response = request.executeAndWait();
-        assertNotNull(response);
-
-        assertNull(response.getError());
-
-        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
-        assertNotNull(graphResult);
-
-        List<GraphObject> results = graphResult.getData();
-        assertNotNull(results);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExecutePlaceRequestWithSearchText() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        // Pass a distance without a location to ensure it is correctly ignored.
-        Request request = Request.newPlacesSearchRequest(session, null, 1000, 5, "Starbucks", null);
-        Response response = request.executeAndWait();
-        assertNotNull(response);
-
-        assertNull(response.getError());
-
-        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
-        assertNotNull(graphResult);
-
-        List<GraphObject> results = graphResult.getData();
-        assertNotNull(results);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testExecutePlaceRequestWithLocationAndSearchText() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        Location location = new Location("");
-        location.setLatitude(47.6204);
-        location.setLongitude(-122.3491);
-
-        Request request = Request.newPlacesSearchRequest(session, location, 1000, 5, "Starbucks", null);
-        Response response = request.executeAndWait();
-        assertNotNull(response);
-
-        assertNull(response.getError());
-
-        GraphMultiResult graphResult = response.getGraphObjectAs(GraphMultiResult.class);
-        assertNotNull(graphResult);
-
-        List<GraphObject> results = graphResult.getData();
-        assertNotNull(results);
-    }
-
-    @LargeTest
-    public void testExecuteUploadPhoto() {
-        TestSession session = openTestSessionWithSharedUser();
-        Bitmap image = createTestBitmap(128);
-
-        Request request = Request.newUploadPhotoRequest(session, image, null);
-        Response response = request.executeAndWait();
-        assertNotNull(response);
-
-        assertNull(response.getError());
-
-        GraphObject result = response.getGraphObject();
-        assertNotNull(result);
-    }
-
-    @LargeTest
-    public void testExecuteUploadPhotoViaFile() throws IOException {
-        File outputFile = null;
-        FileOutputStream outStream = null;
-
-        try {
-            TestSession session = openTestSessionWithSharedUser();
-            Bitmap image = createTestBitmap(128);
-
-            File outputDir = getActivity().getCacheDir(); // context being the Activity pointer
-            outputFile = File.createTempFile("prefix", "extension", outputDir);
-
-            outStream = new FileOutputStream(outputFile);
-            image.compress(Bitmap.CompressFormat.PNG, 100, outStream);
-            outStream.close();
-            outStream = null;
-
-            Request request = Request.newUploadPhotoRequest(session, outputFile, null);
-            Response response = request.executeAndWait();
-            assertNotNull(response);
-
-            assertNull(response.getError());
-
-            GraphObject result = response.getGraphObject();
-            assertNotNull(result);
-        } finally {
-            if (outStream != null) {
-                outStream.close();
-            }
-            if (outputFile != null) {
-                outputFile.delete();
-            }
-        }
-    }
-
-    @LargeTest
-    public void testUploadVideoFile() throws IOException, URISyntaxException {
-        File tempFile = null;
-        try {
-            TestSession session = openTestSessionWithSharedUser();
-            tempFile = createTempFileFromAsset("DarkScreen.mov");
-
-            Request request = Request.newUploadVideoRequest(session, tempFile, null);
-            Response response = request.executeAndWait();
-            assertNotNull(response);
-
-            assertNull(response.getError());
-
-            GraphObject result = response.getGraphObject();
-            assertNotNull(result);
-        } catch (Exception ex) {
-            return;
-        } finally {
-            if (tempFile != null) {
-                tempFile.delete();
-            }
-        }
-    }
-
-    @LargeTest
-    public void testPostStatusUpdate() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        GraphObject statusUpdate = createStatusUpdate();
-
-        GraphObject retrievedStatusUpdate = postGetAndAssert(session, "me/feed", statusUpdate);
-
-        assertEquals(statusUpdate.getProperty("message"), retrievedStatusUpdate.getProperty("message"));
-    }
-
-    @LargeTest
-    public void testRestMethodGetUser() {
-        TestSession session = openTestSessionWithSharedUser();
-        String testUserId = session.getTestUserId();
-
-        Bundle parameters = new Bundle();
-        parameters.putString("uids", testUserId);
-        parameters.putString("fields", "uid,name");
-
-        Request request = Request.newRestRequest(session, "users.getInfo", parameters, null);
-        Response response = request.executeAndWait();
-        assertNotNull(response);
-
-        GraphObjectList<GraphObject> graphObjects = response.getGraphObjectList();
-        assertNotNull(graphObjects);
-        assertEquals(1, graphObjects.size());
-
-        GraphObject user = graphObjects.get(0);
-        assertNotNull(user);
-        assertEquals(testUserId, user.getProperty("uid").toString());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCallbackIsCalled() {
-        Request request = new Request(null, "4");
-
-        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
-        request.setCallback(new Request.Callback() {
-            @Override
-            public void onCompleted(Response response) {
-                calledBack.add(true);
-            }
-        });
-
-        Response response = request.executeAndWait();
-        assertNotNull(response);
-        assertTrue(calledBack.size() == 1);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testBatchTimeoutIsApplied() {
-        Request request = new Request(null, "me");
-        RequestBatch batch = new RequestBatch(request);
-
-        // We assume 1 ms is short enough to fail
-        batch.setTimeout(1);
-
-        List<Response> responses = Request.executeBatchAndWait(batch);
-        assertNotNull(responses);
-        assertTrue(responses.size() == 1);
-        Response response = responses.get(0);
-        assertNotNull(response);
-        assertNotNull(response.getError());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testBatchTimeoutCantBeNegative() {
-        try {
-            RequestBatch batch = new RequestBatch();
-            batch.setTimeout(-1);
-            fail();
-        } catch (IllegalArgumentException ex) {
-        }
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCantSetBothGraphPathAndRestMethod() {
-        Request request = new Request();
-        request.setGraphPath("me");
-        request.setRestMethod("amethod");
-        request.setCallback(new ExpectFailureCallback());
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
-        task.executeOnBlockerThread();
-
-        waitAndAssertSuccess(1);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testClosedSessionDoesntAppendAccessToken() {
-        TestSession session = openTestSessionWithSharedUser();
-        session.close();
-        Request request = new Request(session, "me", null, null, new ExpectFailureCallback());
-
-        TestRequestAsyncTask task = new TestRequestAsyncTask(request);
-        task.executeOnBlockerThread();
-
-        waitAndAssertSuccess(1);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCantUseComplexParameterInGetRequest() {
-        TestSession session = openTestSessionWithSharedUser();
-
-        Bundle parameters = new Bundle();
-        parameters.putShortArray("foo", new short[1]);
-
-        Request request = new Request(session, "me", parameters, HttpMethod.GET, new ExpectFailureCallback());
-        Response response = request.executeAndWait();
-
-        FacebookRequestError error = response.getError();
-        assertNotNull(error);
-        FacebookException exception = error.getException();
-        assertNotNull(exception);
-        assertTrue(exception.getMessage().contains("short[]"));
-    }
-
-    private final Location SEATTLE_LOCATION = new Location("") {
-        {
-            setLatitude(47.6097);
-            setLongitude(-122.3331);
-        }
-    };
-
-    @LargeTest
-    public void testPaging() {
-        TestSession session = openTestSessionWithSharedUser();
-        final List<GraphPlace> returnedPlaces = new ArrayList<GraphPlace>();
-        Request request = Request
-                .newPlacesSearchRequest(session, SEATTLE_LOCATION, 1000, 5, null, new Request.GraphPlaceListCallback() {
-                    @Override
-                    public void onCompleted(List<GraphPlace> places, Response response) {
-                        returnedPlaces.addAll(places);
-                    }
-                });
-        Response response = request.executeAndWait();
-
-        assertNull(response.getError());
-        assertNotNull(response.getGraphObject());
-        assertNotSame(0, returnedPlaces.size());
-
-        returnedPlaces.clear();
-
-        Request nextRequest = response.getRequestForPagedResults(Response.PagingDirection.NEXT);
-        assertNotNull(nextRequest);
-
-        nextRequest.setCallback(request.getCallback());
-        response = nextRequest.executeAndWait();
-
-        assertNull(response.getError());
-        assertNotNull(response.getGraphObject());
-        assertNotSame(0, returnedPlaces.size());
-
-        returnedPlaces.clear();
-
-        Request previousRequest = response.getRequestForPagedResults(Response.PagingDirection.PREVIOUS);
-        assertNotNull(previousRequest);
-
-        previousRequest.setCallback(request.getCallback());
-        response = previousRequest.executeAndWait();
-
-        assertNull(response.getError());
-        assertNotNull(response.getGraphObject());
-        assertNotSame(0, returnedPlaces.size());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testRequestWithClosedSessionThrowsException() {
-        TestSession session = getTestSessionWithSharedUser();
-        assertFalse(session.isOpened());
-
-        Request request = new Request(session, "4");
-        Response response = request.executeAndWait();
-
-        assertNotNull(response.getError());
-    }
-}
diff --git a/facebook/tests/src/com/facebook/SessionTests.java b/facebook/tests/src/com/facebook/SessionTests.java
deleted file mode 100644
index ce16bbf5c..000000000
--- a/facebook/tests/src/com/facebook/SessionTests.java
+++ /dev/null
@@ -1,818 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.support.v4.content.LocalBroadcastManager;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.internal.Utility;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-
-public class SessionTests extends SessionTestsBase {
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        new SharedPreferencesTokenCachingStrategy(getActivity()).clear();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testFailNullArguments() {
-        try {
-            new Session(null);
-
-            // Should not get here
-            assertFalse(true);
-        } catch (NullPointerException e) {
-            // got expected exception
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testActiveSessionChangeRegistration() {
-        final WaitForBroadcastReceiver receiver0 = new WaitForBroadcastReceiver();
-        final WaitForBroadcastReceiver receiver1 = new WaitForBroadcastReceiver();
-        final WaitForBroadcastReceiver receiver2 = new WaitForBroadcastReceiver();
-        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());
-
-        try {
-            // Register these on the blocker thread so they will send
-            // notifications there as well. The notifications need to be on a
-            // different thread than the progress.
-            Runnable initialize0 = new Runnable() {
-                @Override
-                public void run() {
-                    broadcastManager.registerReceiver(receiver0, getActiveSessionAllFilter());
-
-                    broadcastManager.registerReceiver(receiver1,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_SET));
-                    broadcastManager.registerReceiver(receiver1,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
-                    broadcastManager.registerReceiver(receiver1,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED));
-
-                    broadcastManager.registerReceiver(receiver2,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
-                    broadcastManager.registerReceiver(receiver2,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED));
-                }
-            };
-            runOnBlockerThread(initialize0, true);
-
-            // Verify all actions show up where they are expected
-            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver1, receiver2);
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
-            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver1, receiver2);
-
-            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver1, receiver2);
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
-            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver1, receiver2);
-
-            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver1);
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
-            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver1);
-
-            receiver0.incrementExpectCount();
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
-            receiver0.waitForExpectedCalls();
-
-            // Remove receiver1 and verify actions continue to show up where
-            // expected
-            broadcastManager.unregisterReceiver(receiver1);
-
-            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver2);
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
-            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver2);
-
-            WaitForBroadcastReceiver.incrementExpectCounts(receiver0, receiver2);
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
-            WaitForBroadcastReceiver.waitForExpectedCalls(receiver0, receiver2);
-
-            receiver0.incrementExpectCount();
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
-            receiver0.waitForExpectedCalls();
-
-            receiver0.incrementExpectCount();
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
-            receiver0.waitForExpectedCalls();
-
-            // Remove receiver0 and register receiver1 multiple times for one
-            // action
-            broadcastManager.unregisterReceiver(receiver0);
-
-            Runnable initialize1 = new Runnable() {
-                @Override
-                public void run() {
-                    broadcastManager.registerReceiver(receiver1,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
-                    broadcastManager.registerReceiver(receiver1,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
-                    broadcastManager.registerReceiver(receiver1,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
-                }
-            };
-            runOnBlockerThread(initialize1, true);
-
-            receiver1.incrementExpectCount(3);
-            receiver2.incrementExpectCount();
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
-            receiver1.waitForExpectedCalls();
-            receiver2.waitForExpectedCalls();
-
-            receiver2.incrementExpectCount();
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
-            receiver2.waitForExpectedCalls();
-
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
-            Session.postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
-
-            closeBlockerAndAssertSuccess();
-        } finally {
-            broadcastManager.unregisterReceiver(receiver0);
-            broadcastManager.unregisterReceiver(receiver1);
-            broadcastManager.unregisterReceiver(receiver2);
-            Session.setActiveSession(null);
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetActiveSession() {
-        Session.setActiveSession(null);
-
-        final WaitForBroadcastReceiver receiverOpened = new WaitForBroadcastReceiver();
-        final WaitForBroadcastReceiver receiverClosed = new WaitForBroadcastReceiver();
-        final WaitForBroadcastReceiver receiverSet = new WaitForBroadcastReceiver();
-        final WaitForBroadcastReceiver receiverUnset = new WaitForBroadcastReceiver();
-        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());
-
-        try {
-            Runnable initializeOnBlockerThread = new Runnable() {
-                @Override
-                public void run() {
-                    broadcastManager.registerReceiver(receiverOpened,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_OPENED));
-                    broadcastManager.registerReceiver(receiverClosed,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED));
-                    broadcastManager.registerReceiver(receiverSet,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_SET));
-                    broadcastManager.registerReceiver(receiverUnset,
-                            getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_UNSET));
-                }
-            };
-            runOnBlockerThread(initializeOnBlockerThread, true);
-
-            // null -> null should not fire events
-            assertEquals(null, Session.getActiveSession());
-            Session.setActiveSession(null);
-            assertEquals(null, Session.getActiveSession());
-
-            Session session0 = new Session.Builder(getActivity()).
-                    setApplicationId("FakeAppId").
-                    setTokenCachingStrategy(new MockTokenCachingStrategy()).
-                    build();
-            assertEquals(SessionState.CREATED_TOKEN_LOADED, session0.getState());
-
-            // For unopened session, we should only see the Set event.
-            receiverSet.incrementExpectCount();
-            Session.setActiveSession(session0);
-            assertEquals(session0, Session.getActiveSession());
-            receiverSet.waitForExpectedCalls();
-
-            // When we open it, then we should see the Opened event.
-            receiverOpened.incrementExpectCount();
-            session0.openForRead(null);
-            receiverOpened.waitForExpectedCalls();
-
-            // Setting to itself should not fire events
-            Session.setActiveSession(session0);
-            assertEquals(session0, Session.getActiveSession());
-
-            // Setting from one opened session to another should deliver a full
-            // cycle of events
-            WaitForBroadcastReceiver.incrementExpectCounts(receiverClosed, receiverUnset, receiverSet, receiverOpened);
-            Session session1 = new Session.Builder(getActivity()).
-                    setApplicationId("FakeAppId").
-                    setTokenCachingStrategy(new MockTokenCachingStrategy()).
-                    build();
-            assertEquals(SessionState.CREATED_TOKEN_LOADED, session1.getState());
-            session1.openForRead(null);
-            assertEquals(SessionState.OPENED, session1.getState());
-            Session.setActiveSession(session1);
-            WaitForBroadcastReceiver.waitForExpectedCalls(receiverClosed, receiverUnset, receiverSet, receiverOpened);
-            assertEquals(SessionState.CLOSED, session0.getState());
-            assertEquals(session1, Session.getActiveSession());
-
-            closeBlockerAndAssertSuccess();
-        } finally {
-            broadcastManager.unregisterReceiver(receiverOpened);
-            broadcastManager.unregisterReceiver(receiverClosed);
-            broadcastManager.unregisterReceiver(receiverSet);
-            broadcastManager.unregisterReceiver(receiverUnset);
-            Session.setActiveSession(null);
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenSuccess() {
-        ArrayList<String> permissions = new ArrayList<String>();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-        AccessToken openToken = AccessToken
-                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        session.addAuthorizeResult(openToken);
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        verifySessionHasToken(session, openToken);
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Verify we saved the token to cache.
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenForPublishSuccess() {
-        ArrayList<String> permissions = new ArrayList<String>();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-        AccessToken openToken = AccessToken
-                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        session.addAuthorizeResult(openToken);
-        session.openForPublish(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
-                setPermissions(Arrays.asList(new String[]{
-                        "publish_something",
-                        "manage_something",
-                        "ads_management",
-                        "create_event",
-                        "rsvp_event"
-                })));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        verifySessionHasToken(session, openToken);
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Verify we saved the token to cache.
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenForPublishSuccessWithReadPermissions() {
-        ArrayList<String> permissions = new ArrayList<String>();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-        AccessToken openToken = AccessToken
-                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        session.addAuthorizeResult(openToken);
-        session.openForPublish(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
-                setPermissions(Arrays.asList(new String[]{
-                        "publish_something",
-                        "manage_something",
-                        "ads_management",
-                        "create_event",
-                        "rsvp_event",
-                        "read_something"
-                })));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        verifySessionHasToken(session, openToken);
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Verify we saved the token to cache.
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenFromTokenCache() {
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        String token = "A token less unique than most";
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(token, DEFAULT_TIMEOUT_MILLISECONDS);
-        ScriptedSession session = createScriptedSessionOnBlockerThread("app-id", cache);
-
-        // Verify state when we have a token in cache.
-        assertEquals(SessionState.CREATED_TOKEN_LOADED, session.getState());
-
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-
-        // Verify we open with no authorize call.
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        // Verify no token information is saved.
-        assertTrue(cache.getSavedState() == null);
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenActiveFromEmptyTokenCache() {
-        new SharedPreferencesTokenCachingStrategy(getActivity()).clear();
-
-        assertNull(Session.openActiveSessionFromCache(getActivity()));
-    }
-
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenFailure() {
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-        Exception openException = new Exception();
-
-        session.addAuthorizeResult(openException);
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-
-        // Verify we get the expected exception and no saved state.
-        statusRecorder.waitForCall(session, SessionState.CLOSED_LOGIN_FAILED, openException);
-        assertTrue(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenForReadFailure() {
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        try {
-            session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder).
-                    setPermissions(Arrays.asList(new String[]{"publish_something"})));
-            fail("should not reach here without an exception");
-        } catch (FacebookException e) {
-            assertTrue(e.getMessage().contains("Cannot pass a publish or manage permission"));
-        } finally {
-            stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-            statusRecorder.close();
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testRequestNewReadPermissionsSuccess() {
-        ArrayList<String> permissions = new ArrayList<String>();
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        // Session.open
-        final AccessToken openToken = AccessToken
-                .createFromString("Allows playing outside", permissions, AccessTokenSource.TEST_USER);
-        permissions.add("play_outside");
-
-        session.addAuthorizeResult(openToken, "play_outside");
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        verifySessionHasToken(session, openToken);
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Successful Session.reauthorize with new permissions
-        final AccessToken reauthorizeToken = AccessToken.createFromString(
-                "Allows playing outside and eating ice cream", permissions, AccessTokenSource.TEST_USER);
-        permissions.add("eat_ice_cream");
-
-        session.addAuthorizeResult(reauthorizeToken, "play_outside", "eat_ice_cream");
-        session.requestNewReadPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
-        statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, null);
-
-        verifySessionHasToken(session, reauthorizeToken);
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(reauthorizeToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Failing reauthorization with new permissions
-        final Exception reauthorizeException = new Exception("Don't run with scissors");
-        permissions.add("run_with_scissors");
-
-        session.addAuthorizeResult(reauthorizeException);
-        session.requestNewReadPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
-        statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, reauthorizeException);
-
-        // Verify we do not overwrite cache if reauthorize fails
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(reauthorizeToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorders.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testRequestNewPublishPermissionsSuccess() {
-        ArrayList<String> permissions = new ArrayList<String>();
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        // Session.open
-        final AccessToken openToken = AccessToken
-                .createFromString("Allows playing outside", permissions, AccessTokenSource.TEST_USER);
-        permissions.add("play_outside");
-
-        session.addAuthorizeResult(openToken, "play_outside");
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        verifySessionHasToken(session, openToken);
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(openToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Successful Session.reauthorize with new permissions
-        final AccessToken reauthorizeToken = AccessToken.createFromString(
-                "Allows playing outside and publish eating ice cream", permissions, AccessTokenSource.TEST_USER);
-        permissions.add("publish_eat_ice_cream");
-
-        session.addAuthorizeResult(reauthorizeToken, "play_outside", "publish_eat_ice_cream");
-        session.requestNewPublishPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
-        statusRecorder.waitForCall(session, SessionState.OPENED_TOKEN_UPDATED, null);
-
-        verifySessionHasToken(session, reauthorizeToken);
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(reauthorizeToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Failing reauthorization with publish permissions on a read request
-        permissions.add("publish_run_with_scissors");
-
-        try {
-            session.requestNewReadPermissions(new Session.NewPermissionsRequest(getActivity(), permissions));
-            fail("Should not reach here without an exception");
-        } catch (FacebookException e) {
-            assertTrue(e.getMessage().contains("Cannot pass a publish or manage permission"));
-        } finally {
-            stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-            statusRecorder.close();
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenWithAccessToken() {
-        String token = "This is a fake token.";
-        Date expirationDate = new Date(new Date().getTime() + 3600 * 1000);
-        Date lastRefreshDate = new Date();
-        List<String> permissions = Arrays.asList(new String[]{"email", "publish_stream"});
-
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        AccessToken accessToken = AccessToken.createFromExistingAccessToken(token, expirationDate, lastRefreshDate,
-                AccessTokenSource.FACEBOOK_APPLICATION_WEB, permissions);
-        session.open(accessToken, statusRecorder);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        AccessToken expectedToken = new AccessToken(token, expirationDate, permissions,
-                AccessTokenSource.FACEBOOK_APPLICATION_WEB, lastRefreshDate);
-        verifySessionHasToken(session, expectedToken);
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Verify we saved the token to cache.
-        assertTrue(cache.getSavedState() != null);
-        assertEquals(expectedToken.getToken(), TokenCachingStrategy.getToken(cache.getSavedState()));
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenWithAccessTokenWithDefaults() {
-        String token = "This is a fake token.";
-
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        AccessToken accessToken = AccessToken.createFromExistingAccessToken(token, null, null, null, null);
-        session.open(accessToken, statusRecorder);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        assertEquals(token, session.getAccessToken());
-        assertEquals(new Date(Long.MAX_VALUE), session.getExpirationDate());
-        assertEquals(0, session.getPermissions().size());
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Verify we saved the token to cache.
-        assertTrue(cache.getSavedState() != null);
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testSessionWillExtendTokenIfNeeded() {
-        TestSession session = openTestSessionWithSharedUser();
-        session.forceExtendAccessToken(true);
-
-        Request request = Request.newMeRequest(session, null);
-        request.executeAndWait();
-
-        assertTrue(session.getWasAskedToExtendAccessToken());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testSessionWillNotExtendTokenIfCurrentlyAttempting() {
-        TestSession session = openTestSessionWithSharedUser();
-        session.forceExtendAccessToken(true);
-        session.fakeTokenRefreshAttempt();
-
-        Request request = Request.newMeRequest(session, null);
-        request.executeAndWait();
-        assertFalse(session.getWasAskedToExtendAccessToken());
-    }
-
-
-    @LargeTest
-    public void testBasicSerialization() throws IOException, ClassNotFoundException {
-        // Try to test the happy path, that there are no unserializable fields
-        // in the session.
-        Session session0 = new Session.Builder(getActivity()).setApplicationId("fakeID").build();
-        Session session1 = TestUtils.serializeAndUnserialize(session0);
-
-        // do some basic assertions
-        assertNotNull(session0.getAccessToken());
-        assertEquals(session0, session1);
-
-        Session.AuthorizationRequest authRequest0 =
-                new Session.OpenRequest(getActivity()).
-                        setRequestCode(123).
-                        setLoginBehavior(SessionLoginBehavior.SSO_ONLY);
-        Session.AuthorizationRequest authRequest1 = TestUtils.serializeAndUnserialize(authRequest0);
-
-        assertEquals(authRequest0.getLoginBehavior(), authRequest1.getLoginBehavior());
-        assertEquals(authRequest0.getRequestCode(), authRequest1.getRequestCode());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenSessionWithNativeLinkingIntent() {
-        String token = "A token less unique than most";
-
-        Intent intent = new Intent(Intent.ACTION_MAIN);
-        intent.putExtras(getNativeLinkingExtras(token));
-
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, DEFAULT_TIMEOUT_MILLISECONDS);
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        assertEquals(SessionState.CREATED, session.getState());
-
-        AccessToken accessToken = AccessToken.createFromNativeLinkingIntent(intent);
-        assertNotNull(accessToken);
-        session.open(accessToken, statusRecorder);
-
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        assertEquals(token, session.getAccessToken());
-        // Expiration time should be 3600s after now (allow 5s variation for test execution time)
-        long delta = session.getExpirationDate().getTime() - new Date().getTime();
-        assertTrue(Math.abs(delta - 3600 * 1000) < 5000);
-        assertEquals(0, session.getPermissions().size());
-        assertEquals(Utility.getMetadataApplicationId(getActivity()), session.getApplicationId());
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        assertFalse(cache.getSavedState() == null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpenActiveSessionWithNativeLinkingIntent() {
-        Session activeSession = Session.getActiveSession();
-        if (activeSession != null) {
-            activeSession.closeAndClearTokenInformation();
-        }
-
-        SharedPreferencesTokenCachingStrategy tokenCache = new SharedPreferencesTokenCachingStrategy(getActivity());
-        assertEquals(0, tokenCache.load().size());
-
-        String token = "A token less unique than most";
-
-        Intent intent = new Intent(Intent.ACTION_MAIN);
-        intent.putExtras(getNativeLinkingExtras(token));
-
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-
-        AccessToken accessToken = AccessToken.createFromNativeLinkingIntent(intent);
-        assertNotNull(accessToken);
-        Session session = Session.openActiveSessionWithAccessToken(getActivity(), accessToken, statusRecorder);
-        assertEquals(session, Session.getActiveSession());
-
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        assertNotSame(0, tokenCache.load().size());
-
-        assertEquals(token, session.getAccessToken());
-        // Expiration time should be 3600s after now (allow 5s variation for test execution time)
-        long delta = session.getExpirationDate().getTime() - new Date().getTime();
-        assertTrue(Math.abs(delta - 3600 * 1000) < 5000);
-        assertEquals(0, session.getPermissions().size());
-        assertEquals(Utility.getMetadataApplicationId(getActivity()), session.getApplicationId());
-
-        // Verify we get a close callback.
-        session.close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testOpeningSessionWithPendingRequestResultsInExceptionCallback() {
-        ArrayList<String> permissions = new ArrayList<String>();
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-        AccessToken openToken = AccessToken
-                .createFromString("A token of thanks", permissions, AccessTokenSource.TEST_USER);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-        session.addPendingAuthorizeResult();
-
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-        session.openForRead(new Session.OpenRequest(getActivity()).setCallback(statusRecorder));
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENING, new UnsupportedOperationException());
-
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    static IntentFilter getActiveSessionFilter(String... actions) {
-        IntentFilter filter = new IntentFilter();
-
-        for (String action : actions) {
-            filter.addAction(action);
-        }
-
-        return filter;
-    }
-
-    static IntentFilter getActiveSessionAllFilter() {
-        return getActiveSessionFilter(Session.ACTION_ACTIVE_SESSION_CLOSED, Session.ACTION_ACTIVE_SESSION_OPENED,
-                Session.ACTION_ACTIVE_SESSION_SET, Session.ACTION_ACTIVE_SESSION_UNSET);
-    }
-
-    private void verifySessionHasToken(Session session, AccessToken token) {
-        assertEquals(token.getToken(), session.getAccessToken());
-        assertEquals(token.getExpires(), session.getExpirationDate());
-        TestUtils.assertAtLeastExpectedPermissions(token.getPermissions(), session.getPermissions());
-    }
-}
diff --git a/facebook/tests/src/com/facebook/SessionTestsBase.java b/facebook/tests/src/com/facebook/SessionTestsBase.java
deleted file mode 100644
index 57bc0b194..000000000
--- a/facebook/tests/src/com/facebook/SessionTestsBase.java
+++ /dev/null
@@ -1,316 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Bundle;
-import android.os.ConditionVariable;
-import android.os.Looper;
-import com.facebook.internal.Utility;
-import com.facebook.model.GraphMultiResult;
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphObjectList;
-import com.facebook.model.GraphUser;
-
-import java.util.*;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-
-public class SessionTestsBase extends FacebookTestCase {
-    public static final int DEFAULT_TIMEOUT_MILLISECONDS = 10 * 1000;
-    static final int SIMULATED_WORKING_MILLISECONDS = 20;
-    public static final int STRAY_CALLBACK_WAIT_MILLISECONDS = 50;
-
-    public ScriptedSession createScriptedSessionOnBlockerThread(TokenCachingStrategy cachingStrategy) {
-        return createScriptedSessionOnBlockerThread(Utility.getMetadataApplicationId(getActivity()), cachingStrategy);
-    }
-
-    ScriptedSession createScriptedSessionOnBlockerThread(final String applicationId,
-            final TokenCachingStrategy cachingStrategy) {
-        class MutableState {
-            ScriptedSession session;
-        }
-        ;
-        final MutableState mutable = new MutableState();
-
-        runOnBlockerThread(new Runnable() {
-            @Override
-            public void run() {
-                mutable.session = new ScriptedSession(getActivity(), applicationId, cachingStrategy);
-            }
-        }, true);
-
-        return mutable.session;
-    }
-
-    public static void stall(int stallMsec) {
-        try {
-            Thread.sleep(stallMsec);
-        } catch (InterruptedException e) {
-            fail("InterruptedException while stalling");
-        }
-    }
-
-    public class ScriptedSession extends Session {
-        private static final long serialVersionUID = 1L;
-        private final LinkedList<AuthorizeResult> pendingAuthorizations = new LinkedList<AuthorizeResult>();
-        private AuthorizationRequest lastRequest;
-        private AuthorizeResult currentAuthorization = null;
-
-        public ScriptedSession(Context currentContext, String applicationId, TokenCachingStrategy tokenCachingStrategy) {
-            super(currentContext, applicationId, tokenCachingStrategy);
-        }
-
-        public void addAuthorizeResult(String token, List<String> permissions, AccessTokenSource source) {
-            addAuthorizeResult(AccessToken.createFromString(token, permissions, source));
-        }
-
-        public void addAuthorizeResult(AccessToken token) {
-            pendingAuthorizations.add(new AuthorizeResult(token));
-        }
-
-        public void addAuthorizeResult(AccessToken token, List<String> permissions) {
-            pendingAuthorizations.add(new AuthorizeResult(token, permissions));
-        }
-
-        public void addAuthorizeResult(AccessToken token, String... permissions) {
-            pendingAuthorizations.add(new AuthorizeResult(token, Arrays.asList(permissions)));
-        }
-
-        public void addAuthorizeResult(Exception exception) {
-            pendingAuthorizations.add(new AuthorizeResult(exception));
-        }
-
-        public void addPendingAuthorizeResult() {
-            pendingAuthorizations.add(new AuthorizeResult());
-        }
-
-        public AuthorizationRequest getLastRequest() {
-            return lastRequest;
-        }
-
-        public SessionDefaultAudience getLastRequestAudience() {
-            return lastRequest.getDefaultAudience();
-        }
-
-        // Overrides authorize to return the next AuthorizeResult we added.
-        @Override
-        void authorize(final AuthorizationRequest request) {
-            lastRequest = request;
-            getActivity().runOnUiThread(new Runnable() {
-                @Override
-                public void run() {
-                    stall(SIMULATED_WORKING_MILLISECONDS);
-                    currentAuthorization = pendingAuthorizations.poll();
-
-                    if (currentAuthorization == null) {
-                        fail("Missing call to addScriptedAuthorization");
-                    }
-                    if (!currentAuthorization.leaveAsPending) {
-                        finishAuthOrReauth(currentAuthorization.token, currentAuthorization.exception);
-                    }
-                }
-            });
-        }
-
-        private class AuthorizeResult {
-            final AccessToken token;
-            final Exception exception;
-            final List<String> resultingPermissions;
-            final boolean leaveAsPending;
-
-            private AuthorizeResult(AccessToken token, Exception exception, List<String> permissions) {
-                this.token = token;
-                this.exception = exception;
-                this.resultingPermissions = permissions;
-                this.leaveAsPending = false;
-            }
-
-            private AuthorizeResult() {
-                this.token = null;
-                this.exception = null;
-                this.resultingPermissions = null;
-                this.leaveAsPending = true;
-            }
-
-            AuthorizeResult(AccessToken token, List<String> permissions) {
-                this(token, null, permissions);
-            }
-
-            AuthorizeResult(AccessToken token) {
-                this(token, null, null);
-            }
-
-            AuthorizeResult(Exception exception) {
-                this(null, exception, null);
-            }
-        }
-    }
-
-    public static class SessionStatusCallbackRecorder implements Session.StatusCallback {
-        private final BlockingQueue<Call> calls = new LinkedBlockingQueue<Call>();
-        volatile boolean isClosed = false;
-
-        public void waitForCall(Session session, SessionState state, Exception exception) {
-            Call call = null;
-
-            try {
-                call = calls.poll(DEFAULT_TIMEOUT_MILLISECONDS, TimeUnit.MILLISECONDS);
-                if (call == null) {
-                    fail("Did not get a status callback within timeout.");
-                }
-            } catch (InterruptedException e) {
-                fail("InterruptedException while waiting for status callback: " + e);
-            }
-
-            assertEquals(session, call.session);
-            assertEquals(state, call.state);
-            if (exception != null && call.exception != null) {
-                assertEquals(exception.getClass(), call.exception.getClass());
-            } else {
-                // They should both be null if either of them is.
-                assertTrue(exception == call.exception);
-            }
-        }
-
-        public void close() {
-            isClosed = true;
-            assertEquals(0, calls.size());
-        }
-
-        @Override
-        public void call(Session session, SessionState state, Exception exception) {
-            Call call = new Call(session, state, exception);
-            if (!calls.offer(call)) {
-                fail("Test Error: Blocking queue ran out of capacity");
-            }
-            if (isClosed) {
-                fail("Reauthorize callback called after closed");
-            }
-            assertEquals("Callback should run on main UI thread", Thread.currentThread(),
-                    Looper.getMainLooper().getThread());
-        }
-
-        private static class Call {
-            final Session session;
-            final SessionState state;
-            final Exception exception;
-
-            Call(Session session, SessionState state, Exception exception) {
-                this.session = session;
-                this.state = state;
-                this.exception = exception;
-            }
-        }
-
-    }
-
-    public static class MockTokenCachingStrategy extends TokenCachingStrategy {
-        private final String token;
-        private final long expires_in;
-        private Bundle saved;
-
-        MockTokenCachingStrategy() {
-            this("FakeToken", DEFAULT_TIMEOUT_MILLISECONDS);
-        }
-
-        public MockTokenCachingStrategy(String token, long expires_in) {
-            this.token = token;
-            this.expires_in = expires_in;
-            this.saved = null;
-        }
-
-        public Bundle getSavedState() {
-            return saved;
-        }
-
-        @Override
-        public Bundle load() {
-            Bundle bundle = null;
-
-            if (token != null) {
-                bundle = new Bundle();
-
-                TokenCachingStrategy.putToken(bundle, token);
-                TokenCachingStrategy.putExpirationMilliseconds(bundle, System.currentTimeMillis() + expires_in);
-            }
-
-            return bundle;
-        }
-
-        @Override
-        public void save(Bundle bundle) {
-            this.saved = bundle;
-        }
-
-        @Override
-        public void clear() {
-            this.saved = null;
-        }
-    }
-
-    static class WaitForBroadcastReceiver extends BroadcastReceiver {
-        static int idGenerator = 0;
-        final int id = idGenerator++;
-
-        ConditionVariable condition = new ConditionVariable(true);
-        int expectCount;
-        int actualCount;
-
-        public void incrementExpectCount() {
-            incrementExpectCount(1);
-        }
-
-        public void incrementExpectCount(int n) {
-            expectCount += n;
-            if (actualCount < expectCount) {
-                condition.close();
-            }
-        }
-
-        public void waitForExpectedCalls() {
-            if (!condition.block(DEFAULT_TIMEOUT_MILLISECONDS)) {
-                assertTrue(false);
-            }
-        }
-
-        public static void incrementExpectCounts(WaitForBroadcastReceiver... receivers) {
-            for (WaitForBroadcastReceiver receiver : receivers) {
-                receiver.incrementExpectCount();
-            }
-        }
-
-        public static void waitForExpectedCalls(WaitForBroadcastReceiver... receivers) {
-            for (WaitForBroadcastReceiver receiver : receivers) {
-                receiver.waitForExpectedCalls();
-            }
-        }
-
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (++actualCount == expectCount) {
-                condition.open();
-            }
-            assertTrue(actualCount <= expectCount);
-            assertEquals("BroadcastReceiver should receive on main UI thread",
-                    Thread.currentThread(), Looper.getMainLooper().getThread());
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/SettingsTests.java b/facebook/tests/src/com/facebook/SettingsTests.java
deleted file mode 100644
index 2a4fb7c3a..000000000
--- a/facebook/tests/src/com/facebook/SettingsTests.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.os.ConditionVariable;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.internal.Utility;
-
-import java.io.IOException;
-import java.util.concurrent.Executor;
-
-public final class SettingsTests extends AndroidTestCase {
-
-    @SmallTest @MediumTest @LargeTest
-    public void testGetExecutor() {
-        final ConditionVariable condition = new ConditionVariable();
-
-        Settings.getExecutor().execute(new Runnable() {
-            @Override
-            public void run() {
-                condition.open();
-            }
-        });
-
-        boolean success = condition.block(5000);
-        assertTrue(success);
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testSetExecutor() {
-        final ConditionVariable condition = new ConditionVariable();
-
-        final Runnable runnable = new Runnable() {
-            @Override
-            public void run() { }
-        };
-
-        final Executor executor = new Executor() {
-            @Override
-            public void execute(Runnable command) {
-                assertEquals(runnable, command);
-                command.run();
-
-                condition.open();
-            }
-        };
-
-        Executor original = Settings.getExecutor();
-        try {
-            Settings.setExecutor(executor);
-            Settings.getExecutor().execute(runnable);
-
-            boolean success = condition.block(5000);
-            assertTrue(success);
-        } finally {
-            Settings.setExecutor(original);
-        }
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testLogdException() {
-        try {
-            throw new IOException("Simulated error");
-        } catch (IOException e) {
-            Utility.logd("SettingsTest", e);
-        }
-
-        try {
-            throw new IOException(null);
-        } catch (IOException e) {
-            Utility.logd("SettingsTest", e);
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java b/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java
deleted file mode 100644
index bab3fb38f..000000000
--- a/facebook/tests/src/com/facebook/SharedPreferencesTokenCacheTests.java
+++ /dev/null
@@ -1,349 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.os.Bundle;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.internal.Utility;
-import junit.framework.Assert;
-
-import java.lang.reflect.Array;
-import java.util.*;
-
-
-public final class SharedPreferencesTokenCacheTests extends AndroidTestCase {
-
-    private static final String BOOLEAN_KEY = "booleanKey";
-    private static final String BOOLEAN_ARRAY_KEY = "booleanArrayKey";
-    private static final String BYTE_KEY = "byteKey";
-    private static final String BYTE_ARRAY_KEY = "byteArrayKey";
-    private static final String SHORT_KEY = "shortKey";
-    private static final String SHORT_ARRAY_KEY = "shortArrayKey";
-    private static final String INT_KEY = "intKey";
-    private static final String INT_ARRAY_KEY = "intArrayKey";
-    private static final String LONG_KEY = "longKey";
-    private static final String LONG_ARRAY_KEY = "longArrayKey";
-    private static final String FLOAT_ARRAY_KEY = "floatKey";
-    private static final String FLOAT_KEY = "floatArrayKey";
-    private static final String DOUBLE_KEY = "doubleKey";
-    private static final String DOUBLE_ARRAY_KEY = "doubleArrayKey";
-    private static final String CHAR_KEY = "charKey";
-    private static final String CHAR_ARRAY_KEY = "charArrayKey";
-    private static final String STRING_KEY = "stringKey";
-    private static final String STRING_LIST_KEY = "stringListKey";
-    private static final String SERIALIZABLE_KEY = "serializableKey";
-
-    private static Random random = new Random((new Date()).getTime());
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testAllTypes() {
-        Bundle originalBundle = new Bundle();
-
-        putBoolean(BOOLEAN_KEY, originalBundle);
-        putBooleanArray(BOOLEAN_ARRAY_KEY, originalBundle);
-        putByte(BYTE_KEY, originalBundle);
-        putByteArray(BYTE_ARRAY_KEY, originalBundle);
-        putShort(SHORT_KEY, originalBundle);
-        putShortArray(SHORT_ARRAY_KEY, originalBundle);
-        putInt(INT_KEY, originalBundle);
-        putIntArray(INT_ARRAY_KEY, originalBundle);
-        putLong(LONG_KEY, originalBundle);
-        putLongArray(LONG_ARRAY_KEY, originalBundle);
-        putFloat(FLOAT_KEY, originalBundle);
-        putFloatArray(FLOAT_ARRAY_KEY, originalBundle);
-        putDouble(DOUBLE_KEY, originalBundle);
-        putDoubleArray(DOUBLE_ARRAY_KEY, originalBundle);
-        putChar(CHAR_KEY, originalBundle);
-        putCharArray(CHAR_ARRAY_KEY, originalBundle);
-        putString(STRING_KEY, originalBundle);
-        putStringList(STRING_LIST_KEY, originalBundle);
-        originalBundle.putSerializable(SERIALIZABLE_KEY, AccessTokenSource.FACEBOOK_APPLICATION_WEB);
-
-        ensureApplicationContext();
-
-        SharedPreferencesTokenCachingStrategy cache = new SharedPreferencesTokenCachingStrategy(getContext());
-        cache.save(originalBundle);
-
-        SharedPreferencesTokenCachingStrategy cache2 = new SharedPreferencesTokenCachingStrategy(getContext());
-        Bundle cachedBundle = cache2.load();
-
-        Assert.assertEquals(originalBundle.getBoolean(BOOLEAN_KEY), cachedBundle.getBoolean(BOOLEAN_KEY));
-        assertArrayEquals(originalBundle.getBooleanArray(BOOLEAN_ARRAY_KEY), cachedBundle.getBooleanArray(BOOLEAN_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getByte(BYTE_KEY), cachedBundle.getByte(BYTE_KEY));
-        assertArrayEquals(originalBundle.getByteArray(BYTE_ARRAY_KEY), cachedBundle.getByteArray(BYTE_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getShort(SHORT_KEY), cachedBundle.getShort(SHORT_KEY));
-        assertArrayEquals(originalBundle.getShortArray(SHORT_ARRAY_KEY), cachedBundle.getShortArray(SHORT_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getInt(INT_KEY), cachedBundle.getInt(INT_KEY));
-        assertArrayEquals(originalBundle.getIntArray(INT_ARRAY_KEY), cachedBundle.getIntArray(INT_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getLong(LONG_KEY), cachedBundle.getLong(LONG_KEY));
-        assertArrayEquals(originalBundle.getLongArray(LONG_ARRAY_KEY), cachedBundle.getLongArray(LONG_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getFloat(FLOAT_KEY), cachedBundle.getFloat(FLOAT_KEY));
-        assertArrayEquals(originalBundle.getFloatArray(FLOAT_ARRAY_KEY), cachedBundle.getFloatArray(FLOAT_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getDouble(DOUBLE_KEY), cachedBundle.getDouble(DOUBLE_KEY));
-        assertArrayEquals(originalBundle.getDoubleArray(DOUBLE_ARRAY_KEY), cachedBundle.getDoubleArray(DOUBLE_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getChar(CHAR_KEY), cachedBundle.getChar(CHAR_KEY));
-        assertArrayEquals(originalBundle.getCharArray(CHAR_ARRAY_KEY), cachedBundle.getCharArray(CHAR_ARRAY_KEY));
-        Assert.assertEquals(originalBundle.getString(STRING_KEY), cachedBundle.getString(STRING_KEY));
-        assertListEquals(originalBundle.getStringArrayList(STRING_LIST_KEY), cachedBundle.getStringArrayList(
-                STRING_LIST_KEY));
-        Assert.assertEquals(originalBundle.getSerializable(SERIALIZABLE_KEY),
-                cachedBundle.getSerializable(SERIALIZABLE_KEY));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMultipleCaches() {
-        Bundle bundle1 = new Bundle(), bundle2 = new Bundle();
-
-        bundle1.putInt(INT_KEY, 10);
-        bundle1.putString(STRING_KEY, "ABC");
-        bundle2.putInt(INT_KEY, 100);
-        bundle2.putString(STRING_KEY, "xyz");
-
-        ensureApplicationContext();
-
-        SharedPreferencesTokenCachingStrategy cache1 = new SharedPreferencesTokenCachingStrategy(getContext());
-        SharedPreferencesTokenCachingStrategy cache2 = new SharedPreferencesTokenCachingStrategy(getContext(), "CustomCache");
-
-        cache1.save(bundle1);
-        cache2.save(bundle2);
-
-        // Get new references to make sure we are getting persisted data.
-        // Reverse the cache references for fun.
-        cache1 = new SharedPreferencesTokenCachingStrategy(getContext(), "CustomCache");
-        cache2 = new SharedPreferencesTokenCachingStrategy(getContext());
-
-        Bundle newBundle1 = cache1.load(), newBundle2 = cache2.load();
-
-        Assert.assertEquals(bundle2.getInt(INT_KEY), newBundle1.getInt(INT_KEY));
-        Assert.assertEquals(bundle2.getString(STRING_KEY), newBundle1.getString(STRING_KEY));
-        Assert.assertEquals(bundle1.getInt(INT_KEY), newBundle2.getInt(INT_KEY));
-        Assert.assertEquals(bundle1.getString(STRING_KEY), newBundle2.getString(STRING_KEY));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCacheRoundtrip() {
-        ArrayList<String> permissions = Utility.arrayList("stream_publish", "go_outside_and_play");
-        String token = "AnImaginaryTokenValue";
-        Date later = TestUtils.nowPlusSeconds(60);
-        Date earlier = TestUtils.nowPlusSeconds(-60);
-
-        SharedPreferencesTokenCachingStrategy cache = new SharedPreferencesTokenCachingStrategy(getContext());
-        cache.clear();
-
-        Bundle bundle = new Bundle();
-        TokenCachingStrategy.putToken(bundle, token);
-        TokenCachingStrategy.putExpirationDate(bundle, later);
-        TokenCachingStrategy.putSource(bundle, AccessTokenSource.FACEBOOK_APPLICATION_NATIVE);
-        TokenCachingStrategy.putLastRefreshDate(bundle, earlier);
-        TokenCachingStrategy.putPermissions(bundle, permissions);
-
-        cache.save(bundle);
-        bundle = cache.load();
-
-        AccessToken accessToken = AccessToken.createFromCache(bundle);
-        TestUtils.assertSamePermissions(permissions, accessToken);
-        assertEquals(token, accessToken.getToken());
-        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_NATIVE, accessToken.getSource());
-        assertTrue(!accessToken.isInvalid());
-
-        Bundle cachedBundle = accessToken.toCacheBundle();
-        TestUtils.assertEqualContents(bundle, cachedBundle);
-    }
-
-    private static void assertArrayEquals(Object a1, Object a2) {
-        Assert.assertNotNull(a1);
-        Assert.assertNotNull(a2);
-        Assert.assertEquals(a1.getClass(), a2.getClass());
-        Assert.assertTrue("Not an array", a1.getClass().isArray());
-
-        int length = Array.getLength(a1);
-        Assert.assertEquals(length, Array.getLength(a2));
-        for (int i = 0; i < length; i++) {
-            Object a1Value = Array.get(a1, i);
-            Object a2Value = Array.get(a2, i);
-
-            Assert.assertEquals(a1Value, a2Value);
-        }
-    }
-
-    private static void assertListEquals(List<?> l1, List<?> l2) {
-        Assert.assertNotNull(l1);
-        Assert.assertNotNull(l2);
-
-        Iterator<?> i1 = l1.iterator(), i2 = l2.iterator();
-        while (i1.hasNext() && i2.hasNext()) {
-            Assert.assertEquals(i1.next(), i2.next());
-        }
-
-        Assert.assertTrue("Lists not of the same length", !i1.hasNext());
-        Assert.assertTrue("Lists not of the same length", !i2.hasNext());
-    }
-
-    private static void putInt(String key, Bundle bundle) {
-        bundle.putInt(key, random.nextInt());
-    }
-
-    private static void putIntArray(String key, Bundle bundle) {
-        int length = random.nextInt(50);
-        int[] array = new int[length];
-        for (int i = 0; i < length; i++) {
-            array[i] = random.nextInt();
-        }
-        bundle.putIntArray(key, array);
-    }
-
-    private static void putShort(String key, Bundle bundle) {
-        bundle.putShort(key, (short)random.nextInt());
-    }
-
-    private static void putShortArray(String key, Bundle bundle) {
-        int length = random.nextInt(50);
-        short[] array = new short[length];
-        for (int i = 0; i < length; i++) {
-            array[i] = (short)random.nextInt();
-        }
-        bundle.putShortArray(key, array);
-    }
-
-    private static void putByte(String key, Bundle bundle) {
-        bundle.putByte(key, (byte)random.nextInt());
-    }
-
-    private static void putByteArray(String key, Bundle bundle) {
-        int length = random.nextInt(50);
-        byte[] array = new byte[length];
-        random.nextBytes(array);
-        bundle.putByteArray(key, array);
-    }
-
-    private static void putBoolean(String key, Bundle bundle) {
-        bundle.putBoolean(key, random.nextBoolean());
-    }
-
-    private static void putBooleanArray(String key, Bundle bundle) {
-        int length = random.nextInt(50);
-        boolean[] array = new boolean[length];
-        for (int i = 0; i < length; i++) {
-            array[i] = random.nextBoolean();
-        }
-        bundle.putBooleanArray(key, array);
-    }
-
-    private static void putLong(String key, Bundle bundle) {
-        bundle.putLong(key, random.nextLong());
-    }
-
-    private static void putLongArray(String key, Bundle bundle) {
-        int length = random.nextInt(50);
-        long[] array = new long[length];
-        for (int i = 0; i < length; i++) {
-            array[i] = random.nextLong();
-        }
-        bundle.putLongArray(key, array);
-    }
-
-    private static void putFloat(String key, Bundle bundle) {
-        bundle.putFloat(key, random.nextFloat());
-    }
-
-    private static void putFloatArray(String key, Bundle bundle) {
-        int length = random.nextInt(50);
-        float[] array = new float[length];
-        for (int i = 0; i < length; i++) {
-            array[i] = random.nextFloat();
-        }
-        bundle.putFloatArray(key, array);
-    }
-
-    private static void putDouble(String key, Bundle bundle) {
-        bundle.putDouble(key, random.nextDouble());
-    }
-
-    private static void putDoubleArray(String key, Bundle bundle) {
-        int length = random.nextInt(50);
-        double[] array = new double[length];
-        for (int i = 0; i < length; i++) {
-            array[i] = random.nextDouble();
-        }
-        bundle.putDoubleArray(key, array);
-    }
-
-    private static void putChar(String key, Bundle bundle) {
-        bundle.putChar(key, getChar());
-    }
-
-    private static void putCharArray(String key, Bundle bundle) {
-        bundle.putCharArray(key, getCharArray());
-    }
-
-    private static void putString(String key, Bundle bundle) {
-        bundle.putString(key, new String(getCharArray()));
-    }
-
-    private static void putStringList(String key, Bundle bundle) {
-        int length = random.nextInt(50);
-        ArrayList<String> stringList = new ArrayList<String>(length);
-        while (0 < length--) {
-            if (length == 0) {
-                stringList.add(null);
-            } else {
-                stringList.add(new String(getCharArray()));
-            }
-        }
-
-        bundle.putStringArrayList(key, stringList);
-    }
-
-    private static char[] getCharArray() {
-        int length = random.nextInt(50);
-        char[] array = new char[length];
-        for (int i = 0; i < length; i++) {
-            array[i] = getChar();
-        }
-
-        return array;
-    }
-
-    private static char getChar() {
-        return (char)random.nextInt(255);
-    }
-
-    private void ensureApplicationContext() {
-        // Since the test case is not running on the UI thread, the applicationContext might
-        // not be ready (i.e. it might be null). Wait for a bit to resolve this.
-        long waitedFor = 0;
-        try {
-            // Don't hold up execution for too long.
-            while (getContext().getApplicationContext() == null && waitedFor <= 2000) {
-                Thread.sleep(50);
-                waitedFor += 50;
-            }
-        }
-        catch (InterruptedException e) {
-        }
-    }
-
-}
diff --git a/facebook/tests/src/com/facebook/TestBlocker.java b/facebook/tests/src/com/facebook/TestBlocker.java
deleted file mode 100644
index 93801de3c..000000000
--- a/facebook/tests/src/com/facebook/TestBlocker.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.os.Handler;
-import android.os.HandlerThread;
-
-public class TestBlocker extends HandlerThread {
-    private Exception exception;
-    public int signals;
-    private volatile Handler handler;
-
-    private TestBlocker() {
-        super("TestBlocker");
-    }
-
-    public synchronized static TestBlocker createTestBlocker() {
-        TestBlocker blocker = new TestBlocker();
-        blocker.start();
-
-        // Wait until we have a Looper and Handler.
-        synchronized (blocker) {
-            while (blocker.handler == null) {
-                try {
-                    blocker.wait();
-                } catch (InterruptedException e) {
-                }
-            }
-        }
-
-        return blocker;
-    }
-
-    @Override
-    public void run() {
-        try {
-            super.run();
-        } catch (Exception e) {
-            setException(e);
-        }
-        synchronized (this) {
-            notifyAll();
-        }
-    }
-
-    public Handler getHandler() {
-        return handler;
-    }
-
-    public void assertSuccess() throws Exception {
-        Exception e = getException();
-        if (e != null) {
-            throw e;
-        }
-    }
-
-    public synchronized void signal() {
-        ++signals;
-        notifyAll();
-    }
-
-    public void waitForSignals(int numSignals) throws Exception {
-        // Make sure we aren't sitting on an unhandled exception before we even start, because that means our
-        // thread isn't around anymore.
-        assertSuccess();
-
-        setException(null);
-
-        synchronized (this) {
-            while (getException() == null && signals < numSignals) {
-                try {
-                    wait();
-                } catch (InterruptedException e) {
-                }
-            }
-            signals = 0;
-        }
-    }
-
-    public void waitForSignalsAndAssertSuccess(int numSignals) throws Exception {
-        waitForSignals(numSignals);
-        assertSuccess();
-    }
-
-    public synchronized Exception getException() {
-        return exception;
-    }
-
-    public synchronized void setException(Exception e) {
-        exception = e;
-        notifyAll();
-    }
-
-    @Override
-    protected void onLooperPrepared() {
-        synchronized (this) {
-            handler = new Handler(getLooper());
-            notifyAll();
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/TestSessionTests.java b/facebook/tests/src/com/facebook/TestSessionTests.java
deleted file mode 100644
index c88f24e23..000000000
--- a/facebook/tests/src/com/facebook/TestSessionTests.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.os.Bundle;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import org.json.JSONArray;
-
-// Because TestSession is the component under test here, be careful in calling methods on FacebookTestCase that
-// assume TestSession works correctly.
-public class TestSessionTests extends FacebookTestCase {
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanCreateWithPrivateUser() {
-        TestSession session = TestSession.createSessionWithPrivateUser(getActivity(), null);
-        assertTrue(session != null);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanCreateWithSharedUser() {
-        TestSession session = TestSession.createSessionWithSharedUser(getActivity(), null);
-        assertTrue(session != null);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCanOpenWithSharedUser() throws Throwable {
-        final TestBlocker blocker = getTestBlocker();
-        TestSession session = getTestSessionWithSharedUser();
-
-        Session.OpenRequest openRequest = new Session.OpenRequest(getActivity()).
-                setCallback(
-                        new Session.StatusCallback() {
-                            @Override
-                            public void call(Session session, SessionState state, Exception exception) {
-                                assertTrue(exception == null);
-                                blocker.signal();
-                            }
-                        });
-        session.openForRead(openRequest);
-
-        waitAndAssertSuccess(blocker, 1);
-
-        assertTrue(session.getState().isOpened());
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testSharedUserDoesntCreateUnnecessaryUsers() throws Throwable {
-        TestSession session = getTestSessionWithSharedUser();
-        openSession(getActivity(), session);
-
-        // Note that this test is somewhat brittle in that the count of test users could change for
-        // external reasons while the test is running. For that reason it may not be appropriate for an
-        // automated test suite, and could be run only when testing changes to TestSession.
-        int startingUserCount = countTestUsers();
-
-        session = getTestSessionWithSharedUser();
-        openSession(getActivity(), session);
-
-        int endingUserCount = countTestUsers();
-
-        assertSame(startingUserCount, endingUserCount);
-    }
-
-    // This test is currently unreliable, I believe due to timing/replication issues that cause the
-    // counts to occasionally be off. Taking out of test runs for now until a more robust test can be added.
-    @LargeTest
-    public void failing_testPrivateUserIsDeletedOnSessionClose() throws Throwable {
-        final TestBlocker blocker = getTestBlocker();
-
-        // See comment above regarding test user count.
-        int startingUserCount = countTestUsers();
-
-        TestSession session = getTestSessionWithPrivateUser(blocker);
-        openSession(getActivity(), session);
-
-        int sessionOpenUserCount = countTestUsers();
-
-        assertSame(startingUserCount + 1, sessionOpenUserCount);
-
-        session.close();
-
-        int endingUserCount = countTestUsers();
-
-        assertSame(startingUserCount, endingUserCount);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCannotChangeTestApplicationIdOnceSet() {
-        try {
-            TestSession.setTestApplicationId("hello");
-            TestSession.setTestApplicationId("world");
-            fail("expected exception");
-        } catch (FacebookException e) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCannotChangeTestApplicationSecretOnceSet() {
-        try {
-            TestSession.setTestApplicationSecret("hello");
-            TestSession.setTestApplicationSecret("world");
-            fail("expected exception");
-        } catch (FacebookException e) {
-        }
-    }
-
-    private int countTestUsers() {
-        TestSession session = getTestSessionWithSharedUser(null);
-
-        String appAccessToken = TestSession.getAppAccessToken();
-        assertNotNull(appAccessToken);
-        String applicationId = session.getApplicationId();
-        assertNotNull(applicationId);
-
-        String fqlQuery = String.format("SELECT id FROM test_account WHERE app_id = %s", applicationId);
-        Bundle parameters = new Bundle();
-        parameters.putString("q", fqlQuery);
-        parameters.putString("access_token", appAccessToken);
-
-        Request request = new Request(null, "fql", parameters, null);
-        Response response = request.executeAndWait();
-
-        JSONArray data = (JSONArray) response.getGraphObject().getProperty("data");
-        return data.length();
-    }
-}
diff --git a/facebook/tests/src/com/facebook/TestUtils.java b/facebook/tests/src/com/facebook/TestUtils.java
deleted file mode 100644
index 08ffadda2..000000000
--- a/facebook/tests/src/com/facebook/TestUtils.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.os.Bundle;
-import junit.framework.Assert;
-
-import java.io.*;
-import java.util.Date;
-import java.util.List;
-
-public class TestUtils {
-    public static <T extends Serializable> T serializeAndUnserialize(T t) {
-        try {
-            ByteArrayOutputStream os = new ByteArrayOutputStream();
-            new ObjectOutputStream(os).writeObject(t);
-            ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
-
-            @SuppressWarnings("unchecked")
-            T ret = (T) (new ObjectInputStream(is)).readObject();
-
-            return ret;
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        } catch (ClassNotFoundException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    static Date nowPlusSeconds(long offset) {
-        return new Date(new Date().getTime() + (offset * 1000L));
-    }
-
-    static void assertSamePermissions(List<String> expected, AccessToken actual) {
-        if (expected == null) {
-            Assert.assertEquals(null, actual.getPermissions());
-        } else {
-            for (String p : expected) {
-                Assert.assertTrue(actual.getPermissions().contains(p));
-            }
-            for (String p : actual.getPermissions()) {
-                Assert.assertTrue(expected.contains(p));
-            }
-        }
-    }
-
-    static void assertSamePermissions(List<String> expected, List<String> actual) {
-        if (expected == null) {
-            Assert.assertEquals(null, actual);
-        } else {
-            for (String p : expected) {
-                Assert.assertTrue(actual.contains(p));
-            }
-            for (String p : actual) {
-                Assert.assertTrue(expected.contains(p));
-            }
-        }
-    }
-
-    static void assertAtLeastExpectedPermissions(List<String> expected, List<String> actual) {
-        if (expected != null) {
-            for (String p : expected) {
-                Assert.assertTrue(actual.contains(p));
-            }
-        }
-    }
-
-    static void assertEqualContents(Bundle a, Bundle b) {
-        for (String key : a.keySet()) {
-            if (!b.containsKey(key)) {
-                Assert.fail("bundle does not include key " + key);
-            }
-            Assert.assertEquals(a.get(key), b.get(key));
-        }
-        for (String key : b.keySet()) {
-            if (!a.containsKey(key)) {
-                Assert.fail("bundle does not include key " + key);
-            }
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/internal/FileLruCacheTests.java b/facebook/tests/src/com/facebook/internal/FileLruCacheTests.java
deleted file mode 100644
index 9fe648317..000000000
--- a/facebook/tests/src/com/facebook/internal/FileLruCacheTests.java
+++ /dev/null
@@ -1,359 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.internal;
-
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.Random;
-
-public final class FileLruCacheTests extends AndroidTestCase {
-    private static final Random random = new Random();
-
-    @SmallTest @MediumTest @LargeTest
-    public void testCacheOutputStream() throws IOException {
-        int dataSize = 1024;
-        byte[] data = generateBytes(dataSize);
-        String key = "a";
-
-        // Limit to 2x to allow for extra header data
-        FileLruCache cache = new FileLruCache(getContext(), "testCacheOutputStream", limitCacheSize(2*dataSize));
-
-        put(cache, key, data);
-        checkValue(cache, key, data);
-        cache.clearForTest();
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testCacheInputStream() throws IOException {
-        int dataSize = 1024;
-        byte[] data = generateBytes(dataSize);
-        String key = "a";
-        InputStream stream = new ByteArrayInputStream(data);
-
-        // Limit to 2x to allow for extra header data
-        FileLruCache cache = new FileLruCache(getContext(), "testCacheInputStream", limitCacheSize(2*dataSize));
-        cache.clearForTest();
-
-        InputStream wrapped = cache.interceptAndPut(key, stream);
-        consumeAndClose(wrapped);
-        checkValue(cache, key, data);
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testCacheClear() throws IOException {
-        int dataSize = 1024;
-        byte[] data = generateBytes(dataSize);
-        String key = "a";
-
-        // Limit to 2x to allow for extra header data
-        FileLruCache cache = new FileLruCache(getContext(), "testCacheClear", limitCacheSize(2*dataSize));
-        cache.clearForTest();
-
-        put(cache, key, data);
-        checkValue(cache, key, data);
-
-        cache.clearForTest();
-        assertEquals(false, hasValue(cache, key));
-        assertEquals(0, cache.sizeInBytesForTest());
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testSizeInBytes() throws IOException {
-        int count = 17;
-        int dataSize = 53;
-        int cacheSize = count * dataSize;
-        byte[] data = generateBytes(dataSize);
-
-        // Limit to 2x to allow for extra header data
-        FileLruCache cache = new FileLruCache(getContext(), "testSizeInBytes", limitCacheSize(2*cacheSize));
-        cache.clearForTest();
-
-        for (int i = 0; i < count; i++) {
-            put(cache, i, data);
-
-            // The size reported by sizeInBytes includes a version/size token as well
-            // as a JSON blob that records the name.  Verify that the cache size is larger
-            // than the data content but not more than twice as large.  This guarantees
-            // that sizeInBytes is doing at least approximately the right thing.
-            int totalDataSize = (i + 1) * dataSize;
-            assertTrue(cache.sizeInBytesForTest() > totalDataSize);
-            assertTrue(cache.sizeInBytesForTest() < 2 * totalDataSize);
-        }
-        for (int i = 0; i < count; i++) {
-            String key = Integer.valueOf(i).toString();
-            checkValue(cache, key, data);
-        }
-    }
-
-    @MediumTest @LargeTest
-    public void testCacheSizeLimit() throws IOException {
-        int count = 64;
-        int dataSize = 32;
-        int cacheSize = count * dataSize / 2;
-        byte[] data = generateBytes(dataSize);
-
-        // Here we do not set the limit to 2x to make sure we hit the limit well before we have
-        // added all the data.
-        FileLruCache cache = new FileLruCache(getContext(), "testCacheSizeLimit", limitCacheSize(cacheSize));
-        cache.clearForTest();
-
-        for (int i = 0; i < count; i++) {
-            put(cache, i, data);
-
-            // See comment in testSizeInBytes for why this is not an exact calculation.
-            //
-            // This changes verification such that the final cache size lands somewhere
-            // between half and full quota.
-            int totalDataSize = (i + 1) * dataSize;
-            assertTrue(cache.sizeInBytesForTest() > Math.min(totalDataSize, cacheSize/2));
-            assertTrue(cache.sizeInBytesForTest() < Math.min(2 * totalDataSize, cacheSize));
-        }
-
-        // Verify that some keys exist and others do not
-        boolean hasValueExists = false;
-        boolean hasNoValueExists = false;
-
-        for (int i = 0; i < count; i++) {
-            String key = Integer.valueOf(i).toString();
-            if (hasValue(cache, key)) {
-                hasValueExists = true;
-                checkValue(cache, key, data);
-            } else {
-                hasNoValueExists = true;
-            }
-        }
-
-        assertEquals(true, hasValueExists);
-        assertEquals(true, hasNoValueExists);
-    }
-
-    @MediumTest @LargeTest
-    public void testCacheCountLimit() throws IOException {
-        int count = 64;
-        int dataSize = 32;
-        int cacheCount = count / 2;
-        byte[] data = generateBytes(dataSize);
-
-        // Here we only limit by count, and we allow half of the entries.
-        FileLruCache cache = new FileLruCache(getContext(), "testCacheCountLimit", limitCacheCount(cacheCount));
-        cache.clearForTest();
-
-        for (int i = 0; i < count; i++) {
-            put(cache, i, data);
-        }
-
-        // Verify that some keys exist and others do not
-        boolean hasValueExists = false;
-        boolean hasNoValueExists = false;
-
-        for (int i = 0; i < count; i++) {
-            if (hasValue(cache, i)) {
-                hasValueExists = true;
-                checkValue(cache, i, data);
-            } else {
-                hasNoValueExists = true;
-            }
-        }
-
-        assertEquals(true, hasValueExists);
-        assertEquals(true, hasNoValueExists);
-    }
-
-    @LargeTest
-    public void testCacheLru() throws IOException, InterruptedException {
-        int keepCount = 10;
-        int otherCount = 5;
-        int dataSize = 64;
-        byte[] data = generateBytes(dataSize);
-
-        // Limit by count, and allow all the keep keys plus one other.
-        FileLruCache cache = new FileLruCache(getContext(), "testCacheLru", limitCacheCount(keepCount + 1));
-        cache.clearForTest();
-
-        for (int i = 0; i < keepCount; i++) {
-            put(cache, i, data);
-        }
-
-        // Make sure operations are separated by enough time that the file timestamps are all different.
-        // On the test device, it looks like lastModified has 1-second resolution, so we have to wait at
-        // least a second to guarantee that updated timestamps will come later.
-        Thread.sleep(1000);
-        for (int i = 0; i < otherCount; i++) {
-            put(cache, keepCount + i, data);
-            Thread.sleep(1000);
-
-            // By verifying all the keep keys, they should be LRU and survive while the others do not.
-            for (int keepIndex = 0; keepIndex < keepCount; keepIndex++) {
-                checkValue(cache, keepIndex, data);
-            }
-            Thread.sleep(1000);
-        }
-
-        // All but the last other key should have been pushed out
-        for (int i = 0; i < (otherCount - 1); i++) {
-            String key = Integer.valueOf(keepCount + i).toString();
-            assertEquals(false, hasValue(cache, key));
-        }
-    }
-
-    @LargeTest
-    public void testConcurrentWritesToSameKey() throws IOException, InterruptedException {
-        final int count = 5;
-        final int dataSize = 81;
-        final int threadCount = 31;
-        final int iterationCount = 10;
-        final byte[] data = generateBytes(dataSize);
-
-        final FileLruCache cache = new FileLruCache(
-                getContext(), "testConcurrentWritesToSameKey", limitCacheCount(count+1));
-        cache.clearForTest();
-
-        Runnable run = new Runnable() {
-            @Override
-            public void run() {
-                for (int iterations = 0; iterations < iterationCount; iterations++) {
-                    for (int i = 0; i < count; i++) {
-                        put(cache, i, data);
-                    }
-                }
-            }
-        };
-
-        // Create a bunch of threads to write a set of keys repeatedly
-        Thread[] threads = new Thread[threadCount];
-        for (int i = 0; i < threads.length; i++) {
-            threads[i] = new Thread(run);
-        }
-
-        for (Thread thread : threads) {
-            thread.start();
-        }
-
-        for (Thread thread : threads) {
-            thread.join(10 * 1000, 0);
-        }
-
-        // Verify that the file state ended up consistent in the end
-        for (int i = 0; i < count; i++) {
-            checkValue(cache, i, data);
-        }
-    }
-
-    byte[] generateBytes(int n) {
-        byte[] bytes = new byte[n];
-        random.nextBytes(bytes);
-        return bytes;
-    }
-
-    FileLruCache.Limits limitCacheSize(int n) {
-        FileLruCache.Limits limits = new FileLruCache.Limits();
-        limits.setByteCount(n);
-        return limits;
-    }
-
-    FileLruCache.Limits limitCacheCount(int n) {
-        FileLruCache.Limits limits = new FileLruCache.Limits();
-        limits.setFileCount(n);
-        return limits;
-    }
-
-    void put(FileLruCache cache, int i, byte[] data) {
-        put(cache, Integer.valueOf(i).toString(), data);
-    }
-
-    void put(FileLruCache cache, String key, byte[] data) {
-        try {
-            OutputStream stream = cache.openPutStream(key);
-            assertNotNull(stream);
-
-            stream.write(data);
-            stream.close();
-        } catch (IOException e) {
-            // Fail test and print Exception
-            assertNull(e);
-        }
-    }
-
-    void checkValue(FileLruCache cache, int i, byte[] expected) {
-        checkValue(cache, Integer.valueOf(i).toString(), expected);
-    }
-
-    void checkValue(FileLruCache cache, String key, byte[] expected) {
-        try {
-            InputStream stream = cache.get(key);
-            assertNotNull(stream);
-
-            checkInputStream(expected, stream);
-            stream.close();
-        } catch (IOException e) {
-            // Fail test and print Exception
-            assertNull(e);
-        }
-    }
-
-    boolean hasValue(FileLruCache cache, int i) {
-        return hasValue(cache, Integer.valueOf(i).toString());
-    }
-
-    boolean hasValue(FileLruCache cache, String key) {
-        InputStream stream = null;
-
-        try {
-            stream = cache.get(key);
-        } catch (IOException e) {
-            // Fail test and print Exception
-            assertNull(e);
-        }
-
-        return stream != null;
-    }
-
-    void checkInputStream(byte[] expected, InputStream actual) {
-        try {
-            for (int i = 0; i < expected.length; i++) {
-                int b = actual.read();
-                assertEquals(((int)expected[i]) & 0xff, b);
-            }
-
-            int eof = actual.read();
-            assertEquals(-1, eof);
-        } catch (IOException e) {
-            // Fail test and print Exception
-            assertNull(e);
-        }
-    }
-
-    void consumeAndClose(InputStream stream) {
-        try {
-            byte[] buffer = new byte[1024];
-            while (stream.read(buffer) > -1) {
-                // these bytes intentionally ignored
-            }
-            stream.close();
-        } catch (IOException e) {
-            // Fail test and print Exception
-            assertNull(e);
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/internal/SessionTrackerTests.java b/facebook/tests/src/com/facebook/internal/SessionTrackerTests.java
deleted file mode 100644
index 1646009f3..000000000
--- a/facebook/tests/src/com/facebook/internal/SessionTrackerTests.java
+++ /dev/null
@@ -1,183 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.internal;
-
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.*;
-import com.facebook.internal.SessionTracker;
-
-import java.util.Collections;
-
-public class SessionTrackerTests extends SessionTestsBase {
-
-    private static final String TOKEN_STR = "A token of thanks";
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    // Tests the SessionDelegate while tracking the active session
-    public void testDelegateWithActiveSession() throws Exception {
-        Session.setActiveSession(null);
-        final SessionStatusCallbackRecorder statusRecorder =
-                new SessionStatusCallbackRecorder();
-        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        final ScriptedSession session =
-                createScriptedSessionOnBlockerThread(cache);
-
-        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
-
-        final SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder);
-        Session.setActiveSession(session);
-
-        session.openForRead(new Session.OpenRequest(getActivity()));
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-        assertNotNull("Session should be open", tracker.getOpenSession());
-        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
-        tracker.getOpenSession().close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        tracker.stopTracking();
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    // Tests the SessionDelegate while tracking a passed in session from the constructor
-    public void testDelegateWithSessionInConstructor() throws Exception {
-        final SessionStatusCallbackRecorder statusRecorder =
-                new SessionStatusCallbackRecorder();
-        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        final ScriptedSession session =
-                createScriptedSessionOnBlockerThread(cache);
-
-        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
-
-        SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder, session);
-
-        session.openForRead(new Session.OpenRequest(getActivity()));
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-        assertNotNull("Session should be open", tracker.getOpenSession());
-        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
-        tracker.getOpenSession().close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        tracker.stopTracking();
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    // Tests the SessionDelegate while tracking the active session and then a new session
-    public void testDelegateWithActiveSessionThenNewSession() throws Exception {
-        Session.setActiveSession(null);
-        final SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        final ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
-
-        SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder);
-        Session.setActiveSession(session);
-
-        session.openForRead(new Session.OpenRequest(getActivity()));
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-        assertNotNull("Session should be open", tracker.getOpenSession());
-        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
-        tracker.getOpenSession().close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        final ScriptedSession newSession = createScriptedSessionOnBlockerThread(cache);
-        newSession.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
-
-        tracker.setSession(newSession);
-        assertNull("Session should not be open", tracker.getOpenSession());
-        newSession.openForRead(new Session.OpenRequest(getActivity()));
-
-        statusRecorder.waitForCall(newSession, SessionState.OPENING, null);
-        statusRecorder.waitForCall(newSession, SessionState.OPENED, null);
-        assertNotNull("Session should be open", tracker.getOpenSession());
-        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
-        tracker.getOpenSession().close();
-        statusRecorder.waitForCall(newSession, SessionState.CLOSED, null);
-
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        tracker.stopTracking();
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    // Tests the SessionDelegate while tracking a new session and then an active session
-    public void testDelegateWithSessionThenActiveSession() throws Exception {
-        Session.setActiveSession(null);
-        final SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder();
-        final MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        final ScriptedSession session = createScriptedSessionOnBlockerThread(cache);
-
-        session.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
-
-        final SessionTracker tracker = new SessionTracker(getActivity(), statusRecorder, session);
-
-        session.openForRead(new Session.OpenRequest(getActivity()));
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-        assertNotNull("Session should be open", tracker.getOpenSession());
-        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
-        tracker.getOpenSession().close();
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        final ScriptedSession newSession = createScriptedSessionOnBlockerThread(cache);
-        newSession.addAuthorizeResult(TOKEN_STR, Collections.<String>emptyList(), AccessTokenSource.TEST_USER);
-
-        // need to run on the blocker thread so that when we register the 
-        // BroadcastReceivers, the handler gets run on the right thread
-        runOnBlockerThread(new Runnable() {
-            public void run() {
-                tracker.setSession(null);
-                Session.setActiveSession(newSession);
-            }
-        }, true);
-
-        assertNull("Session should not be open", tracker.getOpenSession());
-        newSession.openForRead(new Session.OpenRequest(getActivity()));
-
-        statusRecorder.waitForCall(newSession, SessionState.OPENING, null);
-        statusRecorder.waitForCall(newSession, SessionState.OPENED, null);
-        assertNotNull("Session should be open", tracker.getOpenSession());
-        assertEquals("Access Token check", TOKEN_STR, tracker.getOpenSession().getAccessToken());
-        tracker.getOpenSession().close();
-        statusRecorder.waitForCall(newSession, SessionState.CLOSED, null);
-
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        tracker.stopTracking();
-        statusRecorder.close();
-    }
-}
diff --git a/facebook/tests/src/com/facebook/internal/ValidateTests.java b/facebook/tests/src/com/facebook/internal/ValidateTests.java
deleted file mode 100644
index 54d164b6e..000000000
--- a/facebook/tests/src/com/facebook/internal/ValidateTests.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.internal;
-
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.internal.Validate;
-
-import java.util.Arrays;
-
-public class ValidateTests extends AndroidTestCase {
-    
-    @SmallTest
-    public void testNotNullOnNonNull() {
-        Validate.notNull("A string", "name");
-    }
-
-    @SmallTest
-    public void testNotNullOnNull() {
-        try {
-            Validate.notNull(null, "name");
-            fail("expected exception");
-        } catch (Exception e) {
-        }
-    }
-
-    @SmallTest
-    public void testNotEmptyOnNonEmpty() {
-        Validate.notEmpty(Arrays.asList(new String[] { "hi" }), "name");
-    }
-
-    @SmallTest
-    public void testNotEmptylOnEmpty() {
-        try {
-            Validate.notEmpty(Arrays.asList(new String[] {}), "name");
-            fail("expected exception");
-        } catch (Exception e) {
-        }
-    }
-
-    @SmallTest
-    public void testNotNullOrEmptyOnNonEmpty() {
-        Validate.notNullOrEmpty("hi", "name");
-    }
-
-    @SmallTest
-    public void testNotNullOrEmptyOnEmpty() {
-        try {
-            Validate.notNullOrEmpty("", "name");
-            fail("expected exception");
-        } catch (Exception e) {
-        }
-    }
-
-    @SmallTest
-    public void testNotNullOrEmptyOnNull() {
-        try {
-            Validate.notNullOrEmpty(null, "name");
-            fail("expected exception");
-        } catch (Exception e) {
-        }
-    }
-
-    @SmallTest
-    public void testOneOfOnValid() {
-        Validate.oneOf("hi", "name", "hi", "there");
-    }
-
-    @SmallTest
-    public void testOneOfOnInvalid() {
-        try {
-            Validate.oneOf("hit", "name", "hi", "there");
-            fail("expected exception");
-        } catch (Exception e) {
-        }
-    }
-
-    @SmallTest
-    public void testOneOfOnValidNull() {
-        Validate.oneOf(null, "name", "hi", "there", null);
-    }
-
-    @SmallTest
-    public void testOneOfOnInvalidNull() {
-        try {
-            Validate.oneOf(null, "name", "hi", "there");
-            fail("expected exception");
-        } catch (Exception e) {
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/model/GraphObjectFactoryTests.java b/facebook/tests/src/com/facebook/model/GraphObjectFactoryTests.java
deleted file mode 100644
index f50d3bac6..000000000
--- a/facebook/tests/src/com/facebook/model/GraphObjectFactoryTests.java
+++ /dev/null
@@ -1,1145 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.model;
-
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.FacebookGraphObjectException;
-import junit.framework.Assert;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.util.*;
-import java.util.Map.Entry;
-
-public final class GraphObjectFactoryTests extends AndroidTestCase {
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCreateEmptyGraphObject() {
-        GraphObject graphObject = GraphObject.Factory.create();
-        assertTrue(graphObject != null);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanTreatAsMap() {
-        GraphObject graphObject = GraphObject.Factory.create();
-
-        graphObject.setProperty("hello", "world");
-        assertEquals("world", (String) graphObject.asMap().get("hello"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanTreatAsGraphPlace() {
-        GraphPlace graphPlace = GraphObject.Factory.create(GraphPlace.class);
-
-        graphPlace.setName("hello");
-        assertEquals("hello", graphPlace.getName());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanTreatAsGraphUser() {
-        GraphUser graphUser = GraphObject.Factory.create(GraphUser.class);
-
-        graphUser.setFirstName("Michael");
-        assertEquals("Michael", graphUser.getFirstName());
-        assertEquals("Michael", graphUser.getProperty("first_name"));
-        assertEquals("Michael", graphUser.asMap().get("first_name"));
-
-        graphUser.setProperty("last_name", "Scott");
-        assertEquals("Scott", graphUser.getProperty("last_name"));
-        assertEquals("Scott", graphUser.getLastName());
-        assertEquals("Scott", graphUser.asMap().get("last_name"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanCastBetweenGraphObjectTypes() {
-        GraphObject graphObject = GraphObject.Factory.create();
-
-        graphObject.setProperty("first_name", "Mickey");
-
-        GraphUser graphUser = graphObject.cast(GraphUser.class);
-        assertTrue(graphUser != null);
-        // Should see the name we set earlier as a GraphObject.
-        assertEquals("Mickey", graphUser.getFirstName());
-
-        // Changes to GraphUser should be reflected in GraphObject version.
-        graphUser.setLastName("Mouse");
-        assertEquals("Mouse", graphObject.getProperty("last_name"));
-    }
-
-    interface Base extends GraphObject {
-    }
-
-    interface Derived extends Base {
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCastingToSameTypeGivesSameObject() {
-        Base base = GraphObject.Factory.create(Base.class);
-
-        Base cast = base.cast(Base.class);
-
-        assertTrue(base == cast);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCastingToBaseTypeGivesSameObject() {
-        Derived derived = GraphObject.Factory.create(Derived.class);
-
-        Base cast = derived.cast(Base.class);
-        assertTrue(derived == cast);
-
-        cast = cast.cast(Derived.class);
-        assertTrue(derived == cast);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanSetComplexTypes() {
-        GraphLocation graphLocation = GraphObject.Factory.create(GraphLocation.class);
-        graphLocation.setCity("Seattle");
-
-        GraphPlace graphPlace = GraphObject.Factory.create(GraphPlace.class);
-        graphPlace.setLocation(graphLocation);
-
-        assertEquals(graphLocation, graphPlace.getLocation());
-        assertEquals("Seattle", graphPlace.getLocation().getCity());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanConvertFromJSON() throws JSONException {
-        JSONObject jsonLocation = new JSONObject();
-        jsonLocation.put("city", "Paris");
-        jsonLocation.put("country", "France");
-
-        JSONObject jsonPlace = new JSONObject();
-        jsonPlace.put("location", jsonLocation);
-        jsonPlace.put("name", "Eiffel Tower");
-
-        GraphPlace graphPlace = GraphObject.Factory.create(jsonPlace, GraphPlace.class);
-        GraphLocation graphLocation = graphPlace.getLocation();
-        assertEquals("Paris", graphLocation.getCity());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanConvertFromGraphObject() throws JSONException {
-        GraphObject graphObject = GraphObject.Factory.create();
-        graphObject.setProperty("city", "Paris");
-        graphObject.setProperty("country", "France");
-
-        JSONObject jsonPlace = new JSONObject();
-        jsonPlace.put("location", graphObject);
-        jsonPlace.put("name", "Eiffel Tower");
-
-        GraphPlace graphPlace = GraphObject.Factory.create(jsonPlace, GraphPlace.class);
-        GraphLocation graphLocation = graphPlace.getLocation();
-        assertEquals("Paris", graphLocation.getCity());
-    }
-
-    private abstract class GraphObjectClass implements GraphObject {
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanConvertNumbers() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("double_as_string", 3.14159);
-        jsonObject.put("int_as_string", 42);
-
-        GraphMetric metric = GraphObject.Factory.create(jsonObject, GraphMetric.class);
-        assertEquals("42", metric.getIntAsString());
-        assertNotNull(metric.getDoubleAsString());
-        assertTrue(metric.getDoubleAsString().startsWith("3.14159"));
-    }
-
-    private interface GraphMetric extends GraphObject {
-        String getIntAsString();
-        String getDoubleAsString();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapNonInterface() {
-        try {
-            GraphObject.Factory.create(GraphObjectClass.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadNoParameterMethodNameGraphObject extends GraphObject {
-        Object floppityFlee();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadZeroParameterMethodName() {
-        try {
-            GraphObject.Factory.create(BadNoParameterMethodNameGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadSingleParameterMethodNameGraphObject extends GraphObject {
-        void floppityFlee(Object obj);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadSingleParameterMethodName() {
-        try {
-            GraphObject.Factory.create(BadSingleParameterMethodNameGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadGetterNameGraphObject extends GraphObject {
-        void get();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadGetterName() {
-        try {
-            GraphObject.Factory.create(BadGetterNameGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadGetterParamsGraphObject extends GraphObject {
-        Object getFoo(Object obj);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadGetterParams() {
-        try {
-            GraphObject.Factory.create(BadGetterParamsGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadGetterReturnTypeGraphObject extends GraphObject {
-        void getFoo();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadGetterReturnType() {
-        try {
-            GraphObject.Factory.create(BadGetterReturnTypeGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadSetterNameGraphObject extends GraphObject {
-        void set();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadSetterName() {
-        try {
-            GraphObject.Factory.create(BadSetterNameGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadSetterParamsGraphObject extends GraphObject {
-        void setFoo();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadSetterParams() {
-        try {
-            GraphObject.Factory.create(BadSetterParamsGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadSetterReturnTypeGraphObject extends GraphObject {
-        Object setFoo(Object obj);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadSetterReturnType() {
-        try {
-            GraphObject.Factory.create(BadSetterReturnTypeGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface BadBaseInterfaceGraphObject extends BadSetterReturnTypeGraphObject {
-        void setBar(Object obj);
-
-        Object getBar();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadBaseInterface() {
-        try {
-            GraphObject.Factory.create(BadBaseInterfaceGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    private interface GoodPropertyOverrideInterfaceGraphObject extends GraphObject {
-        void setDefaultName(String s);
-
-        // No annotation to ensure that the right property is being set.
-        String getAnotherDefaultName();
-
-        @PropertyName("another_default_name")
-        void putSomething(String s);
-
-        @PropertyName("default_name")
-        String retrieveSomething();
-
-        @PropertyName("MixedCase")
-        void setMixedCase(String s);
-
-        @PropertyName("MixedCase")
-        String getMixedCase();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanOverrideGraphPropertyNames() {
-        GoodPropertyOverrideInterfaceGraphObject graphObject =
-                GraphObject.Factory.create(GoodPropertyOverrideInterfaceGraphObject.class);
-
-        String testValue = "flu-blah";
-        graphObject.setDefaultName(testValue);
-        Assert.assertEquals(testValue, graphObject.retrieveSomething());
-
-        testValue = testValue + "1";
-        graphObject.putSomething(testValue);
-        Assert.assertEquals(testValue, graphObject.getAnotherDefaultName());
-
-        testValue = testValue + "2";
-        graphObject.setMixedCase(testValue);
-        Assert.assertEquals(testValue, graphObject.getMixedCase());
-    }
-
-    private interface BadPropertyOverrideInterfaceGraphObject extends GraphObject {
-        @PropertyName("")
-        void setMissingProperty(Object value);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantWrapBadPropertyNameOverrides() {
-        try {
-            GraphObject.Factory.create(BadPropertyOverrideInterfaceGraphObject.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testObjectEquals() {
-        GraphObject graphObject = GraphObject.Factory.create();
-        graphObject.setProperty("aKey", "aValue");
-
-        assertTrue(graphObject.equals(graphObject));
-
-        GraphPlace graphPlace = graphObject.cast(GraphPlace.class);
-        assertTrue(graphObject.equals(graphPlace));
-        assertTrue(graphPlace.equals(graphObject));
-
-        GraphObject aDifferentGraphObject = GraphObject.Factory.create();
-        aDifferentGraphObject.setProperty("aKey", "aDifferentValue");
-        assertFalse(graphObject.equals(aDifferentGraphObject));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetProperty() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        assertEquals("world", graphObject.getProperty("hello"));
-        assertTrue(graphObject.getProperty("fred") == null);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSetProperty() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        graphObject.setProperty("hello", "world");
-        graphObject.setProperty("don't imagine", "purple elephants");
-
-        assertEquals("world", jsonObject.getString("hello"));
-        assertEquals("purple elephants", jsonObject.getString("don't imagine"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testRemoveProperty() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("whirled", "peas");
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        graphObject.setProperty("hello", "world");
-        graphObject.setProperty("don't imagine", "purple elephants");
-
-        assertEquals("world", jsonObject.getString("hello"));
-        assertEquals("purple elephants", jsonObject.getString("don't imagine"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapClear() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        assertEquals(1, jsonObject.length());
-
-        graphObject.asMap().clear();
-
-        assertEquals(0, jsonObject.length());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapContainsKey() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        assertTrue(graphObject.asMap().containsKey("hello"));
-        assertFalse(graphObject.asMap().containsKey("hocus"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapContainsValue() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        assertTrue(graphObject.asMap().containsValue("world"));
-        assertFalse(graphObject.asMap().containsValue("pocus"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapEntrySet() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        Set<Entry<String, Object>> entrySet = graphObject.asMap().entrySet();
-        assertEquals(2, entrySet.size());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapGet() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        assertEquals("world", graphObject.asMap().get("hello"));
-        assertTrue(graphObject.getProperty("fred") == null);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapGetReturnsNullForMissingProperty() throws JSONException {
-        GraphUser graphUser = GraphObject.Factory.create(GraphUser.class);
-        assertNull(graphUser.getBirthday());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapIsEmpty() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        assertTrue(graphObject.asMap().isEmpty());
-
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-        assertFalse(graphObject.asMap().isEmpty());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapKeySet() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        Set<String> keySet = graphObject.asMap().keySet();
-        assertEquals(2, keySet.size());
-        assertTrue(keySet.contains("hello"));
-        assertTrue(keySet.contains("hocus"));
-        assertFalse(keySet.contains("world"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapPut() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        graphObject.setProperty("hello", "world");
-        graphObject.setProperty("hocus", "pocus");
-
-        assertEquals("pocus", jsonObject.get("hocus"));
-        assertEquals(2, jsonObject.length());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapPutOfWrapperPutsJSONObject() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        graphObject.setProperty("hello", "world");
-        graphObject.setProperty("hocus", "pocus");
-
-        GraphObject parentObject = GraphObject.Factory.create();
-        parentObject.setProperty("key", graphObject);
-
-        JSONObject jsonParent = parentObject.getInnerJSONObject();
-        Object obj = jsonParent.opt("key");
-
-        assertNotNull(obj);
-        assertEquals(jsonObject, obj);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapPutOfWrapperPutsJSONArray() throws JSONException {
-        JSONArray jsonArray = new JSONArray();
-
-        GraphObjectList<String> graphObjectList = GraphObject.Factory
-                .createList(jsonArray, String.class);
-        graphObjectList.add("hello");
-        graphObjectList.add("world");
-
-        GraphObject parentObject = GraphObject.Factory.create();
-        parentObject.setProperty("key", graphObjectList);
-
-        JSONObject jsonParent = parentObject.getInnerJSONObject();
-        Object obj = jsonParent.opt("key");
-
-        assertNotNull(obj);
-        assertEquals(jsonArray, obj);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapPutAll() throws JSONException {
-        HashMap<String, Object> map = new HashMap<String, Object>();
-        map.put("hello", "world");
-        map.put("hocus", "pocus");
-
-        JSONObject jsonObject = new JSONObject();
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        graphObject.asMap().putAll(map);
-        assertEquals("pocus", jsonObject.get("hocus"));
-        assertEquals(2, jsonObject.length());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapRemove() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        graphObject.removeProperty("hello");
-
-        assertEquals(1, jsonObject.length());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapSize() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        assertEquals(2, graphObject.asMap().size());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMapValues() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        Collection<Object> values = graphObject.asMap().values();
-
-        assertEquals(2, values.size());
-        assertTrue(values.contains("world"));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetInnerJSONObject() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-
-        assertEquals(jsonObject, graphObject.getInnerJSONObject());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSettingGraphObjectProxyStoresJSONObject() throws JSONException {
-        GraphPlace graphPlace = GraphObject.Factory.create(GraphPlace.class);
-        GraphLocation graphLocation = GraphObject.Factory.create(GraphLocation.class);
-
-        graphPlace.setLocation(graphLocation);
-
-        assertEquals(graphLocation.getInnerJSONObject(), graphPlace.getInnerJSONObject().get("location"));
-
-    }
-
-    private interface DateGraphObject extends GraphObject {
-        Date getDate1();
-
-        Date getDate2();
-
-        Date getDate3();
-
-        Date getDate4();
-        void setDate4(Date date);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testGetStringsAsDates() {
-        DateGraphObject dates = GraphObject.Factory.create(DateGraphObject.class);
-        dates.setProperty("date1", "2012-07-04");
-        dates.setProperty("date2", "2012-07-04T19:30:50");
-        dates.setProperty("date3", "2012-07-04T19:20:40-0400");
-
-        // Dates without a time zone should be assumed to be in the current timezone.
-        Calendar cal = new GregorianCalendar();
-        cal.set(Calendar.MILLISECOND, 0);
-
-        cal.set(2012, 6, 4, 0, 0, 0);
-        Date expectedDate1 = cal.getTime();
-        Date date1 = dates.getDate1();
-        assertEquals(expectedDate1, date1);
-
-        cal.set(2012, 6, 4, 19, 30, 50);
-        Date expectedDate2 = cal.getTime();
-        Date date2 = dates.getDate2();
-        assertEquals(expectedDate2, date2);
-
-        // Dates with an explicit time zone should take that timezone into account.
-        cal = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
-        cal.set(Calendar.MILLISECOND, 0);
-        cal.set(2012, 6, 4, 23, 20, 40);
-
-        Date expectedDate3 = cal.getTime();
-        Date date3 = dates.getDate3();
-        assertEquals(expectedDate3, date3);
-
-        cal.set(2012, 9, 28, 9, 53, 0);
-        Date expectedDate4 = cal.getTime();
-        dates.setDate4(expectedDate4);
-        Date date4 = dates.getDate4();
-        assertEquals(expectedDate4, date4);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionAdd() throws JSONException {
-        JSONArray array = new JSONArray();
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        collection.add(5);
-
-        assertTrue(array.length() == 1);
-        assertTrue(array.optInt(0) == 5);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionAddAll() throws JSONException {
-        JSONArray array = new JSONArray();
-
-        Collection<Integer> collectionToAdd = Arrays.asList(5, -1);
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        collection.addAll(collectionToAdd);
-
-        assertTrue(array.length() == 2);
-        assertTrue(array.optInt(0) == 5);
-        assertTrue(array.optInt(1) == -1);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionContains() throws JSONException {
-        JSONArray array = new JSONArray();
-        array.put(5);
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        assertTrue(collection.contains(5));
-        assertFalse(collection.contains(6));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionContainsAll() throws JSONException {
-        JSONArray array = new JSONArray();
-        array.put(5);
-        array.put(-1);
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        assertTrue(collection.containsAll(Arrays.asList(5)));
-        assertTrue(collection.containsAll(Arrays.asList(5, -1)));
-        assertFalse(collection.containsAll(Arrays.asList(5, -1, 2)));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionIsEmpty() throws JSONException {
-        JSONArray array = new JSONArray();
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        assertTrue(collection.isEmpty());
-
-        array.put(5);
-        assertFalse(collection.isEmpty());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionIterator() throws JSONException {
-        JSONArray array = new JSONArray();
-        array.put(5);
-        array.put(-1);
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        Iterator<Integer> iter = collection.iterator();
-        assertTrue(iter.hasNext());
-        assertTrue(iter.next() == 5);
-        assertTrue(iter.hasNext());
-        assertTrue(iter.next() == -1);
-        assertFalse(iter.hasNext());
-
-        for (Integer i : collection) {
-            assertNotSame(0, i);
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionIteratorOfGraphObject() throws JSONException {
-        Collection<GraphLocation> collection = GraphObject.Factory.createList(GraphLocation.class);
-
-        GraphLocation seattle = GraphObject.Factory.create(GraphLocation.class);
-        seattle.setCity("Seattle");
-        collection.add(seattle);
-        GraphLocation paris = GraphObject.Factory.create(GraphLocation.class);
-        paris.setCity("Paris");
-        collection.add(paris);
-
-        Iterator<GraphLocation> iter = collection.iterator();
-        assertTrue(iter.hasNext());
-        assertEquals(seattle, iter.next());
-        assertTrue(iter.hasNext());
-        assertEquals(paris, iter.next());
-        assertFalse(iter.hasNext());
-
-        for (GraphLocation location : collection) {
-            assertTrue(location != null);
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionSize() throws JSONException {
-        JSONArray array = new JSONArray();
-
-        Collection<Integer> collection = GraphObject.Factory.createList(array, Integer.class);
-        assertEquals(0, collection.size());
-
-        array.put(5);
-        assertEquals(1, collection.size());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionClearThrows() throws JSONException {
-        try {
-            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
-            collection.clear();
-            fail("Expected exception");
-        } catch (UnsupportedOperationException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionRemoveThrows() throws JSONException {
-        try {
-            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
-            collection.remove(5);
-            fail("Expected exception");
-        } catch (UnsupportedOperationException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionRemoveAllThrows() throws JSONException {
-        try {
-            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
-            collection.removeAll(Arrays.asList());
-            fail("Expected exception");
-        } catch (UnsupportedOperationException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionRetainAllThrows() throws JSONException {
-        try {
-            Collection<Integer> collection = GraphObject.Factory.createList(Integer.class);
-            collection.retainAll(Arrays.asList());
-            fail("Expected exception");
-        } catch (UnsupportedOperationException exception) {
-        }
-    }
-
-    private interface Locations extends GraphObject {
-        Collection<GraphLocation> getLocations();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testObjectWrapsJSONCollection() throws JSONException {
-        JSONObject jsonLocation = new JSONObject();
-        jsonLocation.put("city", "Seattle");
-
-        JSONArray jsonArray = new JSONArray();
-        jsonArray.put(jsonLocation);
-
-        JSONObject jsonLocations = new JSONObject();
-        jsonLocations.put("locations", jsonArray);
-
-        Locations locations = GraphObject.Factory.create(jsonLocations, Locations.class);
-        Collection<GraphLocation> locationsGraphObjectCollection = locations.getLocations();
-        assertTrue(locationsGraphObjectCollection != null);
-
-        GraphLocation graphLocation = locationsGraphObjectCollection.iterator().next();
-        assertTrue(graphLocation != null);
-        assertEquals("Seattle", graphLocation.getCity());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testObjectWrapsIterable() throws JSONException {
-        GraphUser user = GraphObject.Factory.create(GraphUser.class);
-        user.setFirstName("Foo");
-        user.setLastName("Bar");
-
-        List<GraphUser> users = new ArrayList<GraphUser>();
-        users.add(user);
-
-        OpenGraphAction action = GraphObject.Factory.create(OpenGraphAction.class);
-        action.setTags(users);
-
-        String json = action.getInnerJSONObject().toString();
-
-        assertTrue("JSON string should contain last_name", json.contains("last_name"));
-
-        Object tags = action.getInnerJSONObject().get("tags");
-        assertNotNull("tags should not be null", tags);
-        assertTrue("tags should be JSONArray", tags instanceof JSONArray);
-
-        List<GraphObject> retrievedUsers = action.getTags();
-        assertEquals("Size should be 1", 1, retrievedUsers.size());
-        GraphUser retrievedUser = retrievedUsers.get(0).cast(GraphUser.class);
-        assertEquals("First name should be Foo", "Foo", retrievedUser.getFirstName());
-        assertEquals("Last name should be Bar", "Bar", retrievedUser.getLastName());
-
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionWrapsJSONObject() throws JSONException {
-        JSONObject jsonLocation = new JSONObject();
-        jsonLocation.put("city", "Seattle");
-
-        JSONArray jsonArray = new JSONArray();
-        jsonArray.put(jsonLocation);
-        Collection<GraphLocation> locationsGraphObjectCollection = GraphObject.Factory
-                .createList(jsonArray,
-                        GraphLocation.class);
-        assertTrue(locationsGraphObjectCollection != null);
-
-        GraphLocation graphLocation = locationsGraphObjectCollection.iterator().next();
-        assertTrue(graphLocation != null);
-        assertEquals("Seattle", graphLocation.getCity());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCannotCastCollectionOfNonGraphObjects() throws JSONException {
-        try {
-            GraphObjectList<Integer> collection = GraphObject.Factory.createList(Integer.class);
-            collection.castToListOf(GraphLocation.class);
-            fail("Expected exception");
-        } catch (FacebookGraphObjectException exception) {
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanCastCollectionOfGraphObjects() throws JSONException {
-        JSONObject jsonSeattle = new JSONObject();
-        jsonSeattle.put("city", "Seattle");
-
-        JSONArray jsonArray = new JSONArray();
-        jsonArray.put(jsonSeattle);
-
-        GraphObjectList<GraphObject> collection = GraphObject.Factory
-                .createList(jsonArray, GraphObject.class);
-
-        GraphObjectList<GraphLocation> locationCollection = collection.castToListOf(GraphLocation.class);
-        assertTrue(locationCollection != null);
-
-        GraphLocation seattle = locationCollection.iterator().next();
-        assertTrue(seattle != null);
-        assertEquals("Seattle", seattle.getCity());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCastingCollectionToSameTypeGivesSameObject() {
-        GraphObjectList<Base> base = GraphObject.Factory.createList(Base.class);
-
-        GraphObjectList<Base> cast = base.castToListOf(Base.class);
-
-        assertTrue(base == cast);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCastingCollectionToBaseTypeGivesSameObject() {
-        GraphObjectList<Derived> derived = GraphObject.Factory.createList(Derived.class);
-
-        GraphObjectList<Base> cast = derived.castToListOf(Base.class);
-
-        assertTrue((GraphObjectList<?>)derived == (GraphObjectList<?>)cast);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanGetInnerJSONArray() throws JSONException {
-        JSONArray jsonArray = new JSONArray();
-
-        GraphObjectList<GraphObject> collection = GraphObject.Factory
-                .createList(jsonArray, GraphObject.class);
-
-        assertEquals(jsonArray, collection.getInnerJSONArray());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanGetRandomAccess() throws JSONException {
-        JSONArray jsonArray = new JSONArray();
-        jsonArray.put("Seattle");
-        jsonArray.put("Menlo Park");
-
-        GraphObjectList<String> collection = GraphObject.Factory
-                .createList(jsonArray, String.class);
-
-        assertEquals("Menlo Park", collection.get(1));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanSetRandomAccess() throws JSONException {
-        JSONArray jsonArray = new JSONArray();
-
-        GraphObjectList<String> collection = GraphObject.Factory
-                .createList(jsonArray, String.class);
-
-        collection.add("Seattle");
-        collection.add("Menlo Park");
-
-        collection.set(1, "Ann Arbor");
-        assertEquals("Ann Arbor", collection.get(1));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCollectionPutOfWrapperPutsJSONObject() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-
-        GraphObject graphObject = GraphObject.Factory.create(jsonObject);
-        graphObject.setProperty("hello", "world");
-        graphObject.setProperty("hocus", "pocus");
-
-        GraphObjectList<GraphObject> parentList = GraphObject.Factory
-                .createList(GraphObject.class);
-        parentList.add(graphObject);
-
-        JSONArray jsonArray = parentList.getInnerJSONArray();
-
-        Object obj = jsonArray.opt(0);
-
-        assertNotNull(obj);
-        assertEquals(jsonObject, obj);
-
-        parentList.set(0, graphObject);
-
-        obj = jsonArray.opt(0);
-
-        assertNotNull(obj);
-        assertEquals(jsonObject, obj);
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCamelCaseToLowercase() {
-        assertEquals("hello_world", GraphObject.Factory
-                .convertCamelCaseToLowercaseWithUnderscores("HelloWorld"));
-        assertEquals("hello_world", GraphObject.Factory
-                .convertCamelCaseToLowercaseWithUnderscores("helloWorld"));
-    }
-
-
-}
diff --git a/facebook/tests/src/com/facebook/model/JsonUtilTests.java b/facebook/tests/src/com/facebook/model/JsonUtilTests.java
deleted file mode 100644
index 8f6b60b34..000000000
--- a/facebook/tests/src/com/facebook/model/JsonUtilTests.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.model;
-
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map.Entry;
-import java.util.Set;
-
-public final class JsonUtilTests extends AndroidTestCase {
-
-    @SmallTest @MediumTest @LargeTest
-    public void testJsonObjectClear() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        JsonUtil.jsonObjectClear(jsonObject);
-        assertEquals(0, jsonObject.length());
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testJsonObjectContainsValue() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        assertTrue(JsonUtil.jsonObjectContainsValue(jsonObject, "pocus"));
-        assertFalse(JsonUtil.jsonObjectContainsValue(jsonObject, "Fred"));
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testJsonObjectEntrySet() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        Set<Entry<String, Object>> entrySet = JsonUtil.jsonObjectEntrySet(jsonObject);
-        assertEquals(2, entrySet.size());
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testJsonObjectKeySet() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        Set<String> keySet = JsonUtil.jsonObjectKeySet(jsonObject);
-        assertEquals(2, keySet.size());
-        assertTrue(keySet.contains("hello"));
-        assertFalse(keySet.contains("world"));
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testJsonObjectPutAll() throws JSONException {
-        HashMap<String, Object> map = new HashMap<String, Object>();
-        map.put("hello", "world");
-        map.put("hocus", "pocus");
-
-        JSONObject jsonObject = new JSONObject();
-        JsonUtil.jsonObjectPutAll(jsonObject, map);
-
-        assertEquals("pocus", jsonObject.get("hocus"));
-        assertEquals(2, jsonObject.length());
-    }
-
-    @SmallTest @MediumTest @LargeTest
-    public void testJsonObjectValues() throws JSONException {
-        JSONObject jsonObject = new JSONObject();
-        jsonObject.put("hello", "world");
-        jsonObject.put("hocus", "pocus");
-
-        Collection<Object> values = JsonUtil.jsonObjectValues(jsonObject);
-
-        assertEquals(2, values.size());
-        assertTrue(values.contains("world"));
-    }
-}
diff --git a/facebook/tests/src/com/facebook/widget/FragmentTestCase.java b/facebook/tests/src/com/facebook/widget/FragmentTestCase.java
deleted file mode 100644
index 78ac4845a..000000000
--- a/facebook/tests/src/com/facebook/widget/FragmentTestCase.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.FragmentActivity;
-import android.widget.LinearLayout;
-import com.facebook.FacebookActivityTestCase;
-
-public class FragmentTestCase<T extends FragmentTestCase.TestFragmentActivity<?>> extends FacebookActivityTestCase<T> {
-    public FragmentTestCase(Class<T> activityClass) {
-        super(activityClass);
-    }
-
-    protected T getTestActivity() {
-        return (T) getActivity();
-    }
-
-    public static class TestFragmentActivity<T extends Fragment> extends FragmentActivity {
-        public static final int FRAGMENT_ID = 0xFACE;
-
-        private Class<T> fragmentClass;
-        private int fragmentId;
-
-        protected TestFragmentActivity(Class<T> fragmentClass) {
-            this.fragmentClass = fragmentClass;
-        }
-
-        @Override
-        protected void onCreate(Bundle savedInstanceState) {
-            super.onCreate(savedInstanceState);
-            if (getAutoCreateUI()) {
-                setContentToFragment(null);
-            }
-        }
-
-        protected boolean getAutoCreateUI() {
-            return true;
-        }
-
-        void setContentToFragment(T fragment) {
-            if (fragment == null) {
-                fragment = createFragment();
-            }
-
-            LinearLayout layout = new LinearLayout(this);
-            layout.setOrientation(LinearLayout.VERTICAL);
-            layout.setLayoutParams(new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT,
-                    LinearLayout.LayoutParams.FILL_PARENT));
-            layout.setId(FRAGMENT_ID);
-
-            getSupportFragmentManager().beginTransaction()
-                    .add(FRAGMENT_ID, fragment)
-                    .commit();
-
-            fragmentId = FRAGMENT_ID;
-
-            setContentView(layout);
-        }
-
-        void setContentToLayout(int i, int fragmentId) {
-            this.fragmentId = fragmentId;
-            setContentView(i);
-        }
-
-        T createFragment() {
-            try {
-                return fragmentClass.newInstance();
-            } catch (IllegalAccessException e) {
-                fail("could not create fragment");
-            } catch (InstantiationException e) {
-                fail("could not create fragment");
-            }
-            return null;
-        }
-
-        T getFragment() {
-            @SuppressWarnings("unchecked")
-            T fragment = (T) getSupportFragmentManager().findFragmentById(fragmentId);
-            return fragment;
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/widget/FriendPickerFragmentTests.java b/facebook/tests/src/com/facebook/widget/FriendPickerFragmentTests.java
deleted file mode 100644
index aa3c0a57d..000000000
--- a/facebook/tests/src/com/facebook/widget/FriendPickerFragmentTests.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.os.Bundle;
-import android.test.TouchUtils;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.view.View;
-import android.widget.CheckBox;
-import android.widget.ListView;
-import com.facebook.TestBlocker;
-import com.facebook.TestSession;
-import com.facebook.sdk.tests.R;
-
-import java.util.Arrays;
-import java.util.Collection;
-
-public class FriendPickerFragmentTests extends FragmentTestCase<FriendPickerFragmentTests.TestActivity> {
-    public FriendPickerFragmentTests() {
-        super(TestActivity.class);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCanSetParametersProgrammatically() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                Bundle bundle = new Bundle();
-                // We deliberately set these to non-defaults to ensure they are set correctly.
-                bundle.putString(FriendPickerFragment.USER_ID_BUNDLE_KEY, "4");
-                bundle.putBoolean(FriendPickerFragment.MULTI_SELECT_BUNDLE_KEY, false);
-                bundle.putBoolean(FriendPickerFragment.SHOW_PICTURES_BUNDLE_KEY, false);
-                bundle.putString(FriendPickerFragment.EXTRA_FIELDS_BUNDLE_KEY, "middle_name,link");
-                FriendPickerFragment fragment = new FriendPickerFragment(bundle);
-                getActivity().setContentToFragment(fragment);
-            }
-        });
-
-        // We don't just test the fragment we created directly above, because we want it to go through the
-        // activity lifecycle and ensure the settings are still correct.
-        final FriendPickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        assertEquals("4", fragment.getUserId());
-        assertEquals(false, fragment.getMultiSelect());
-        assertEquals(false, fragment.getShowPictures());
-        Collection<String> extraFields = fragment.getExtraFields();
-        assertTrue(extraFields.contains("middle_name"));
-        assertTrue(extraFields.contains("link"));
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCanSetParametersViaLayout() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                getActivity().setContentToLayout(R.layout.friend_picker_test_layout_1, R.id.friend_picker_fragment);
-            }
-        });
-
-        final FriendPickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        assertEquals(false, fragment.getShowPictures());
-        assertEquals(false, fragment.getMultiSelect());
-        Collection<String> extraFields = fragment.getExtraFields();
-        assertTrue(extraFields.contains("middle_name"));
-        assertTrue(extraFields.contains("link"));
-        // It doesn't make sense to specify user id via layout, so we don't support it.
-    }
-
-    @LargeTest
-    public void testFriendsLoad() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        // We don't auto-create any UI, so do it now. Needs to run on the UI thread.
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                getActivity().setContentToFragment(null);
-            }
-        });
-
-        final FriendPickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        // Ensure our test user has at least one friend.
-        final TestSession session1 = openTestSessionWithSharedUser();
-        TestSession session2 = openTestSessionWithSharedUser(SECOND_TEST_USER_TAG);
-        makeTestUsersFriends(session1, session2);
-
-        // Trigger a data load (on the UI thread).
-        final TestBlocker blocker = getTestBlocker();
-        // We expect to get called twice -- once with results, once to indicate we are done paging.
-        runAndBlockOnUiThread(2, new Runnable() {
-            @Override
-            public void run() {
-                fragment.setSession(session1);
-                fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
-                    @Override
-                    public void onDataChanged(PickerFragment<?> fragment) {
-                        blocker.signal();
-                    }
-                });
-                fragment.setExtraFields(Arrays.asList("first_name"));
-                fragment.loadData(true);
-            }
-        });
-
-        // We should have at least one item in the list by now.
-        ListView listView = (ListView) fragment.getView().findViewById(R.id.com_facebook_picker_list_view);
-        assertNotNull(listView);
-        View firstChild = listView.getChildAt(0);
-        assertNotNull(firstChild);
-
-        // Assert our state before we touch anything.
-        CheckBox checkBox = (CheckBox)listView.findViewById(R.id.com_facebook_picker_checkbox);
-        assertNotNull(checkBox);
-        assertFalse(checkBox.isChecked());
-        assertEquals(0, fragment.getSelection().size());
-
-        // Click on the first item in the list view.
-        TouchUtils.clickView(this, firstChild);
-
-        // We should have a selection (it might not be the user we made a friend up above, if the
-        // test user has more than one friend).
-        assertEquals(1, fragment.getSelection().size());
-
-        // We should have gotten the extra field we wanted.
-        assertNotNull(fragment.getSelection().iterator().next().getFirstName());
-
-        // And the checkbox should be checked.
-        assertTrue(checkBox.isChecked());
-
-        // Touch the item again. We should go back to no selection.
-        TouchUtils.clickView(this, firstChild);
-        assertEquals(0, fragment.getSelection().size());
-        assertFalse(checkBox.isChecked());
-    }
-
-    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<FriendPickerFragment> {
-        public TestActivity() {
-            super(FriendPickerFragment.class);
-        }
-
-        @Override
-        protected boolean getAutoCreateUI() {
-            return false;
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/widget/GraphObjectPagingLoaderTests.java b/facebook/tests/src/com/facebook/widget/GraphObjectPagingLoaderTests.java
deleted file mode 100644
index 1ac0a3f69..000000000
--- a/facebook/tests/src/com/facebook/widget/GraphObjectPagingLoaderTests.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.location.Location;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.LoaderManager;
-import android.support.v4.content.Loader;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import com.facebook.*;
-import com.facebook.model.GraphPlace;
-
-public class GraphObjectPagingLoaderTests extends FragmentTestCase<GraphObjectPagingLoaderTests.TestActivity> {
-    public GraphObjectPagingLoaderTests() {
-        super(TestActivity.class);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testLoaderLoadsAndFollowsNextLinks() throws Exception {
-        CountingCallback callback = new CountingCallback();
-        final GraphObjectPagingLoader<GraphPlace> loader = (GraphObjectPagingLoader<GraphPlace>)
-                getActivity().getSupportLoaderManager().initLoader(0, null, callback);
-
-        TestSession session = openTestSessionWithSharedUser();
-
-        Location location = new Location("");
-        location.setLatitude(47.6204);
-        location.setLongitude(-122.3491);
-
-        final Request request = Request.newPlacesSearchRequest(session, location, 1000, 5, null, null);
-
-        // Need to run this on blocker thread so callbacks are made there.
-        runOnBlockerThread(new Runnable() {
-            @Override
-            public void run() {
-                loader.startLoading(request, false);
-            }
-        }, false);
-
-        getTestBlocker().waitForSignals(1);
-        assertEquals(1, callback.onLoadFinishedCount);
-        assertEquals(0, callback.onErrorCount);
-        assertEquals(0, callback.onLoadResetCount);
-        // We might not get back the exact number we requested because of privacy or other rules on
-        // the service side.
-        assertNotNull(callback.results);
-        assertTrue(callback.results.getCount() > 0);
-
-        runOnBlockerThread(new Runnable() {
-            @Override
-            public void run() {
-                loader.followNextLink();
-            }
-        }, false);
-        getTestBlocker().waitForSignals(1);
-        assertEquals(2, callback.onLoadFinishedCount);
-        assertEquals(0, callback.onErrorCount);
-        assertEquals(0, callback.onLoadResetCount);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testLoaderFinishesImmediatelyOnNoResults() throws Exception {
-        CountingCallback callback = new CountingCallback();
-        final GraphObjectPagingLoader<GraphPlace> loader = (GraphObjectPagingLoader<GraphPlace>)
-                getActivity().getSupportLoaderManager().initLoader(0, null, callback);
-
-        TestSession session = openTestSessionWithSharedUser();
-
-        // Unlikely to ever be a Place here.
-        Location location = new Location("");
-        location.setLatitude(-1.0);
-        location.setLongitude(-1.0);
-
-        final Request request = Request.newPlacesSearchRequest(session, location, 10, 5, null, null);
-
-        // Need to run this on blocker thread so callbacks are made there.
-        runOnBlockerThread(new Runnable() {
-            @Override
-            public void run() {
-                loader.startLoading(request, false);
-            }
-        }, false);
-
-        getTestBlocker().waitForSignals(1);
-        assertEquals(1, callback.onLoadFinishedCount);
-        assertEquals(0, callback.onErrorCount);
-        assertEquals(0, callback.onLoadResetCount);
-        assertNotNull(callback.results);
-        assertEquals(0, callback.results.getCount());
-    }
-
-    private class CountingCallback implements
-            GraphObjectPagingLoader.OnErrorListener, LoaderManager.LoaderCallbacks<SimpleGraphObjectCursor<GraphPlace>> {
-        public int onLoadFinishedCount;
-        public int onLoadResetCount;
-        public int onErrorCount;
-        public SimpleGraphObjectCursor<GraphPlace> results;
-
-        private TestBlocker testBlocker = getTestBlocker();
-
-        @Override
-        public void onError(FacebookException error, GraphObjectPagingLoader<?> loader) {
-            ++onErrorCount;
-            testBlocker.signal();
-        }
-
-        @Override
-        public Loader<SimpleGraphObjectCursor<GraphPlace>> onCreateLoader(int id, Bundle args) {
-            GraphObjectPagingLoader<GraphPlace> loader = new GraphObjectPagingLoader<GraphPlace>(getActivity(),
-                    GraphPlace.class);
-            loader.setOnErrorListener(this);
-            return loader;
-        }
-
-        @Override
-        public void onLoadFinished(Loader<SimpleGraphObjectCursor<GraphPlace>> loader,
-                SimpleGraphObjectCursor<GraphPlace> data) {
-            results = data;
-            ++onLoadFinishedCount;
-            testBlocker.signal();
-        }
-
-        @Override
-        public void onLoaderReset(Loader<SimpleGraphObjectCursor<GraphPlace>> loader) {
-            ++onLoadResetCount;
-            testBlocker.signal();
-        }
-    }
-
-    public static class DummyFragment extends Fragment  {
-    }
-
-    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<DummyFragment> {
-        public TestActivity() {
-            super(DummyFragment.class);
-        }
-
-        @Override
-        protected boolean getAutoCreateUI() {
-            return false;
-        }
-    }
-
-}
diff --git a/facebook/tests/src/com/facebook/widget/ImageResponseCacheTests.java b/facebook/tests/src/com/facebook/widget/ImageResponseCacheTests.java
deleted file mode 100644
index 6c0300e03..000000000
--- a/facebook/tests/src/com/facebook/widget/ImageResponseCacheTests.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.test.AndroidTestCase;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import com.facebook.internal.Utility;
-import com.facebook.widget.ImageResponseCache;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.nio.ByteBuffer;
-import java.util.Arrays;
-
-public final class ImageResponseCacheTests extends AndroidTestCase {
-
-    @MediumTest @LargeTest
-    public void testImageCaching() throws IOException {
-        // In unit test, since we need verify first access the image is not in cache
-        // we need clear the cache first
-        ImageResponseCache.getCache(safeGetContext()).clearForTest();
-        String imgUrl = "http://sphotos-b.xx.fbcdn.net/hphotos-snc7/300716_163831917043403_1106723719_n.jpg";
-        
-        Bitmap bmp1 = readImage(imgUrl, false);
-        Bitmap bmp2 = readImage(imgUrl, true);
-        compareImages(bmp1, bmp2);
-    }
-    
-    @MediumTest @LargeTest
-    public void testImageNotCaching() throws IOException {
-        
-        String imgUrl = "http://graph.facebook.com/ryanseacrest/picture?type=large";
-        
-        Bitmap bmp1 = readImage(imgUrl, false);
-        Bitmap bmp2 = readImage(imgUrl, false);
-        compareImages(bmp1, bmp2);
-    }
-
-    private Bitmap readImage(String uri, boolean expectedFromCache) {
-        Bitmap bmp = null;
-        InputStream istream = null;
-        try
-        {
-            URL url = new URL(uri);
-            // Check if the cache contains value for this url
-            boolean isInCache = (ImageResponseCache.getCache(safeGetContext()).get(url.toString()) != null);
-            assertTrue(isInCache == expectedFromCache);
-            // Read the image
-            istream = ImageResponseCache.getCachedImageStream(url, safeGetContext());
-            if (istream == null) {
-                HttpURLConnection connection = (HttpURLConnection)url.openConnection();
-                istream = ImageResponseCache.interceptAndCacheImageStream(safeGetContext(), connection);
-            }
-            assertTrue(istream != null);
-            bmp = BitmapFactory.decodeStream(istream);
-            assertTrue(bmp != null);
-        } catch (Exception e) {
-             assertNull(e);
-        } finally {
-            Utility.closeQuietly(istream);
-        }
-        return bmp;
-    }
-    
-    private static void compareImages(Bitmap bmp1, Bitmap bmp2) {
-        assertTrue(bmp1.getHeight() == bmp2.getHeight());
-        assertTrue(bmp1.getWidth() == bmp1.getWidth());
-        ByteBuffer buffer1 = ByteBuffer.allocate(bmp1.getHeight() * bmp1.getRowBytes());
-        bmp1.copyPixelsToBuffer(buffer1);
-
-        ByteBuffer buffer2 = ByteBuffer.allocate(bmp2.getHeight() * bmp2.getRowBytes());
-        bmp2.copyPixelsToBuffer(buffer2);
-
-        assertTrue(Arrays.equals(buffer1.array(), buffer2.array()));
-    }
-
-    private Context safeGetContext() {
-        for (;;) {
-            if ((getContext() != null) && (getContext().getApplicationContext() != null)) {
-                return getContext();
-            }
-            try {
-                Thread.sleep(25);
-            } catch (InterruptedException e) {
-            }
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/widget/LoginButtonTest.java b/facebook/tests/src/com/facebook/widget/LoginButtonTest.java
deleted file mode 100644
index 2cf88637e..000000000
--- a/facebook/tests/src/com/facebook/widget/LoginButtonTest.java
+++ /dev/null
@@ -1,313 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.*;
-import com.facebook.widget.LoginButton;
-import junit.framework.Assert;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-public class LoginButtonTest extends SessionTestsBase {
-
-    static final int STRAY_CALLBACK_WAIT_MILLISECONDS = 50;
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLoginButton() throws Throwable {
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        final ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
-        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder = new SessionTestsBase.SessionStatusCallbackRecorder();
-
-        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
-        session.addCallback(statusRecorder);
-
-        // Verify state with no token in cache
-        Assert.assertEquals(SessionState.CREATED, session.getState());
-
-        // Add another status recorder to ensure that the callback we hand to LoginButton
-        // also gets called as expected. We expect to get the same order of calls as statusRecorder does.
-        final SessionStatusCallbackRecorder loginButtonStatusRecorder = new SessionStatusCallbackRecorder();
-
-        // Create the button. To get session status updates, we need to actually attach the
-        // button to a window, which must be done on the UI thread.
-        final LoginButton button = new LoginButton(getActivity());
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                getActivity().setContentView(button);
-                button.setSession(session);
-                button.setSessionStatusCallback(loginButtonStatusRecorder);
-                button.performClick();
-            }
-        });
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        loginButtonStatusRecorder.waitForCall(session, SessionState.OPENING, null);
-
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-        loginButtonStatusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-        loginButtonStatusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testLoginFail() {
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
-        final Exception openException = new Exception("Open failed!");
-        final AtomicBoolean clicked = new AtomicBoolean(false);
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        final LoginButton button = new LoginButton(getActivity());
-        LoginButton.OnErrorListener listener = new LoginButton.OnErrorListener() {
-            @Override
-            public void onError(FacebookException exception) {
-                synchronized (this) {
-                    assertEquals(exception.getCause().getMessage(), openException.getMessage());
-                    clicked.set(true);
-                    this.notifyAll();
-                }
-            }
-        };
-        button.setOnErrorListener(listener);
-        button.setSession(session);
-        session.addAuthorizeResult(openException);
-
-        button.onAttachedToWindow();
-        button.performClick();
-
-        try {
-            synchronized (listener) {
-                listener.wait(DEFAULT_TIMEOUT_MILLISECONDS);
-            }
-        } catch (InterruptedException e) {
-            fail("Interrupted during open");
-        }
-
-        if (!clicked.get()) {
-            fail("Did not get exception");
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanAddReadPermissions() {
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
-        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder = new SessionTestsBase.SessionStatusCallbackRecorder();
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        final LoginButton button = new LoginButton(getActivity());
-        button.setSession(session);
-        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_another"}));
-        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
-        session.addCallback(statusRecorder);
-
-        button.performClick();
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanAddPublishPermissions() {
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
-        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
-                new SessionTestsBase.SessionStatusCallbackRecorder();
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        final LoginButton button = new LoginButton(getActivity());
-        button.setSession(session);
-        button.setPublishPermissions(Arrays.asList(new String[] {"publish_permission", "publish_another"}));
-        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
-        session.addCallback(statusRecorder);
-
-        button.performClick();
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantAddReadThenPublishPermissions() {
-        final LoginButton button = new LoginButton(getActivity());
-        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_another"}));
-        try {
-            button.setPublishPermissions(Arrays.asList(new String[] {"read_permission", "read_a_third"}));
-            fail("Should not be able to reach here");
-        } catch (Exception e) {
-            assertTrue(e instanceof UnsupportedOperationException);
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantAddPublishThenReadPermissions() {
-        final LoginButton button = new LoginButton(getActivity());
-        button.setPublishPermissions(Arrays.asList(new String[] {"publish_permission", "publish_another"}));
-        try {
-            button.setReadPermissions(Arrays.asList(new String[] {"publish_permission", "publish_a_third"}));
-            fail("Should not be able to reach here");
-        } catch (Exception e) {
-            assertTrue(e instanceof UnsupportedOperationException);
-        }
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanAddReadThenPublishPermissionsWithClear() {
-        final LoginButton button = new LoginButton(getActivity());
-        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_another"}));
-        button.clearPermissions();
-        button.setPublishPermissions(Arrays.asList(new String[] {"publish_permission", "publish_another"}));
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCantAddMorePermissionsToOpenSession() {
-        MockTokenCachingStrategy cache = new MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
-        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
-                new SessionTestsBase.SessionStatusCallbackRecorder();
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        final LoginButton button = new LoginButton(getActivity());
-        button.setSession(session);
-        session.addAuthorizeResult("A token of thanks",
-                Arrays.asList(new String[] {"read_permission", "read_another"}), AccessTokenSource.TEST_USER);
-        session.addCallback(statusRecorder);
-
-        button.performClick();
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        // this should be fine
-        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_another"}));
-
-        button.setReadPermissions(Arrays.asList(new String[] {"read_permission", "read_a_third"}));
-        List<String> permissions = button.getPermissions();
-        assertTrue(permissions.contains("read_permission"));
-        assertTrue(permissions.contains("read_another"));
-        assertFalse(permissions.contains("read_a_third"));
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testCanSetDefaultAudience() {
-        SessionTestsBase.MockTokenCachingStrategy cache = new SessionTestsBase.MockTokenCachingStrategy(null, 0);
-        ScriptedSession session = new ScriptedSession(getActivity(), "SomeId", cache);
-        SessionTestsBase.SessionStatusCallbackRecorder statusRecorder =
-                new SessionTestsBase.SessionStatusCallbackRecorder();
-
-        // Verify state with no token in cache
-        assertEquals(SessionState.CREATED, session.getState());
-
-        final LoginButton button = new LoginButton(getActivity());
-        button.setSession(session);
-        button.setPublishPermissions(Arrays.asList(new String[] {"publish_permission", "publish_another"}));
-        button.setDefaultAudience(SessionDefaultAudience.FRIENDS);
-        session.addAuthorizeResult("A token of thanks", new ArrayList<String>(), AccessTokenSource.TEST_USER);
-        session.addCallback(statusRecorder);
-
-        button.performClick();
-
-        statusRecorder.waitForCall(session, SessionState.OPENING, null);
-        statusRecorder.waitForCall(session, SessionState.OPENED, null);
-
-        assertNotNull(session.getLastRequest());
-        assertEquals(SessionDefaultAudience.FRIENDS, session.getLastRequestAudience());
-
-        // Verify token information is cleared.
-        session.closeAndClearTokenInformation();
-        assertTrue(cache.getSavedState() == null);
-        statusRecorder.waitForCall(session, SessionState.CLOSED, null);
-
-        // Wait a bit so we can fail if any unexpected calls arrive on the
-        // recorder.
-        stall(STRAY_CALLBACK_WAIT_MILLISECONDS);
-        statusRecorder.close();
-    }
-
-}
diff --git a/facebook/tests/src/com/facebook/widget/PlacePickerFragmentTests.java b/facebook/tests/src/com/facebook/widget/PlacePickerFragmentTests.java
deleted file mode 100644
index 52fa16017..000000000
--- a/facebook/tests/src/com/facebook/widget/PlacePickerFragmentTests.java
+++ /dev/null
@@ -1,279 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.location.Location;
-import android.os.Bundle;
-import android.test.TouchUtils;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.view.View;
-import android.widget.ListView;
-import com.facebook.*;
-import com.facebook.sdk.tests.R;
-
-import java.util.Collection;
-
-public class PlacePickerFragmentTests extends FragmentTestCase<PlacePickerFragmentTests.TestActivity> {
-    public PlacePickerFragmentTests() {
-        super(TestActivity.class);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCanSetParametersProgrammatically() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        final Location location = new Location("");
-        location.setLatitude(47.6204);
-        location.setLongitude(-122.3491);
-
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                Bundle bundle = new Bundle();
-                // We deliberately set these to non-defaults to ensure they are set correctly.
-                bundle.putBoolean(PlacePickerFragment.SHOW_PICTURES_BUNDLE_KEY, false);
-                bundle.putInt(PlacePickerFragment.RADIUS_IN_METERS_BUNDLE_KEY, 75);
-                bundle.putInt(PlacePickerFragment.RESULTS_LIMIT_BUNDLE_KEY, 5);
-                bundle.putString(PlacePickerFragment.SEARCH_TEXT_BUNDLE_KEY, "coffee");
-                bundle.putParcelable(PlacePickerFragment.LOCATION_BUNDLE_KEY, location);
-                bundle.putString(FriendPickerFragment.EXTRA_FIELDS_BUNDLE_KEY, "checkins,general_info");
-
-                PlacePickerFragment fragment = new PlacePickerFragment(bundle);
-                getActivity().setContentToFragment(fragment);
-            }
-        });
-
-        // We don't just test the fragment we created directly above, because we want it to go through the
-        // activity lifecycle and ensure the settings are still correct.
-        final PlacePickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        assertEquals(false, fragment.getShowPictures());
-        assertEquals(75, fragment.getRadiusInMeters());
-        assertEquals(5, fragment.getResultsLimit());
-        assertEquals("coffee", fragment.getSearchText());
-        assertEquals(location, fragment.getLocation());
-        Collection<String> extraFields = fragment.getExtraFields();
-        assertTrue(extraFields.contains("checkins"));
-        assertTrue(extraFields.contains("general_info"));
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCanSetParametersViaLayout() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                getActivity().setContentToLayout(R.layout.place_picker_test_layout_1, R.id.place_picker_fragment);
-            }
-        });
-
-        final PlacePickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        assertEquals(false, fragment.getShowPictures());
-        assertEquals(75, fragment.getRadiusInMeters());
-        assertEquals(5, fragment.getResultsLimit());
-        assertEquals("coffee", fragment.getSearchText());
-        Collection<String> extraFields = fragment.getExtraFields();
-        assertTrue(extraFields.contains("checkins"));
-        assertTrue(extraFields.contains("general_info"));
-        // It doesn't make sense to specify location via layout, so we don't support it.
-    }
-
-    @LargeTest
-    public void testPlacesLoad() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        // We don't auto-create any UI, so do it now. Needs to run on the UI thread.
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                getActivity().setContentToFragment(null);
-            }
-        });
-        getInstrumentation().waitForIdleSync();
-
-        final PlacePickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        final TestSession session = openTestSessionWithSharedUser();
-
-        // Trigger a data load (on the UI thread).
-        final TestBlocker blocker = getTestBlocker();
-        runAndBlockOnUiThread(1, new Runnable() {
-            @Override
-            public void run() {
-                fragment.setSession(session);
-
-                Location location = new Location("");
-                location.setLatitude(47.6204);
-                location.setLongitude(-122.3491);
-                fragment.setLocation(location);
-
-                fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
-                    @Override
-                    public void onDataChanged(PickerFragment<?> fragment) {
-                        blocker.signal();
-                    }
-                });
-                fragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
-                    @Override
-                    public void onError(PickerFragment<?> fragment, FacebookException error) {
-                        fail("Got unexpected error: " + error.toString());
-                    }
-                });
-                fragment.loadData(true);
-            }
-        });
-
-        // We should have at least one item in the list by now.
-        ListView listView = (ListView) fragment.getView().findViewById(R.id.com_facebook_picker_list_view);
-        assertNotNull(listView);
-        View firstChild = listView.getChildAt(0);
-        assertNotNull(firstChild);
-
-        // Assert our state before we touch anything.
-        assertNull(fragment.getSelection());
-
-        // Click on the first item in the list view.
-        TouchUtils.clickView(this, firstChild);
-
-        // We should have a selection.
-        assertNotNull(fragment.getSelection());
-
-        // Touch the item again. We should go back to no selection.
-        TouchUtils.clickView(this, firstChild);
-        assertNull(fragment.getSelection());
-    }
-
-    @LargeTest
-    public void testClearsResultsWhenSessionClosed() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        // We don't auto-create any UI, so do it now. Needs to run on the UI thread.
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                getActivity().setContentToFragment(null);
-            }
-        });
-        getInstrumentation().waitForIdleSync();
-
-        final PlacePickerFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        final TestSession session = openTestSessionWithSharedUser();
-
-        // Trigger a data load (on the UI thread).
-        // We use multiple test blockers to keep the counts from getting confused if other events
-        // cause our listeners to fire.
-        final TestBlocker blocker1 = TestBlocker.createTestBlocker();
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                fragment.setSession(session);
-
-                Location location = new Location("");
-                location.setLatitude(47.6204);
-                location.setLongitude(-122.3491);
-                fragment.setLocation(location);
-
-                fragment.setOnDataChangedListener(new PickerFragment.OnDataChangedListener() {
-                    @Override
-                    public void onDataChanged(PickerFragment<?> fragment) {
-                        blocker1.signal();
-                    }
-                });
-                fragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
-                    @Override
-                    public void onError(PickerFragment<?> fragment, FacebookException error) {
-                        fail("Got unexpected error: " + error.getMessage());
-                    }
-                });
-                fragment.loadData(true);
-            }
-        });
-        blocker1.waitForSignals(1);
-
-        // We should have at least one item in the list by now.
-        ListView listView = (ListView) fragment.getView().findViewById(R.id.com_facebook_picker_list_view);
-        assertNotNull(listView);
-
-        Thread.sleep(500);
-
-        int lastPosition = listView.getLastVisiblePosition();
-        assertTrue(lastPosition > -1);
-
-        View firstChild = listView.getChildAt(0);
-        assertNotNull(firstChild);
-
-        // Assert our state before we touch anything.
-        assertNull(fragment.getSelection());
-
-        // Click on the first item in the list view.
-        TouchUtils.clickView(this, firstChild);
-
-        // We should have a selection.
-        assertNotNull(fragment.getSelection());
-
-        // To validate the behavior, we need to wait until the session state notifications have been processed.
-        // We run this on the UI thread but don't wait on the blocker until we've closed the session.
-        final TestBlocker blocker2 = TestBlocker.createTestBlocker();
-        runAndBlockOnUiThread(0, new Runnable() {
-            @Override
-            public void run() {
-                session.addCallback(new Session.StatusCallback() {
-                    @Override
-                    public void call(Session session, SessionState state, Exception exception) {
-                        blocker2.signal();
-                    }
-                });
-            }
-        });
-        session.close();
-        // Wait for the notification and for any UI activity to stop.
-        blocker2.waitForSignals(1);
-        getInstrumentation().waitForIdleSync();
-
-        Thread.sleep(500);
-        // The list and the selection should have been cleared.
-        lastPosition = listView.getLastVisiblePosition();
-        assertTrue(lastPosition == -1);
-        assertNull(fragment.getSelection());
-    }
-
-    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<PlacePickerFragment> {
-        public TestActivity() {
-            super(PlacePickerFragment.class);
-        }
-
-        @Override
-        protected boolean getAutoCreateUI() {
-            return false;
-        }
-    }
-
-}
diff --git a/facebook/tests/src/com/facebook/widget/UserSettingsFragmentTests.java b/facebook/tests/src/com/facebook/widget/UserSettingsFragmentTests.java
deleted file mode 100644
index db12791b1..000000000
--- a/facebook/tests/src/com/facebook/widget/UserSettingsFragmentTests.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.os.Bundle;
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import com.facebook.SessionDefaultAudience;
-import com.facebook.SessionLoginBehavior;
-
-import java.util.Arrays;
-import java.util.List;
-
-public class UserSettingsFragmentTests extends FragmentTestCase<UserSettingsFragmentTests.TestActivity> {
-
-    public UserSettingsFragmentTests() {
-        super(TestActivity.class);
-    }
-
-    @MediumTest
-    @LargeTest
-    public void testCanSetParametersViaLayout() throws Throwable {
-        TestActivity activity = getActivity();
-        assertNotNull(activity);
-
-        final UserSettingsFragment fragment = activity.getFragment();
-        assertNotNull(fragment);
-
-        assertEquals(SessionLoginBehavior.SUPPRESS_SSO, fragment.getLoginBehavior());
-        assertEquals(SessionDefaultAudience.EVERYONE, fragment.getDefaultAudience());
-        List<String> permissions = fragment.getPermissions();
-        assertEquals(2, permissions.size());
-        assertEquals("read_1", permissions.get(0));
-    }
-
-    public static class TestActivity extends FragmentTestCase.TestFragmentActivity<UserSettingsFragment> {
-        public TestActivity() {
-            super(UserSettingsFragment.class);
-        }
-
-        @Override
-        public void onCreate(Bundle savedInstanceState) {
-            super.onCreate(savedInstanceState);
-            getSupportFragmentManager().executePendingTransactions();
-            UserSettingsFragment fragment = getFragment();
-            fragment.setLoginBehavior(SessionLoginBehavior.SUPPRESS_SSO);
-            fragment.setReadPermissions(Arrays.asList("read_1", "read_2"));
-            fragment.setDefaultAudience(SessionDefaultAudience.EVERYONE);
-        }
-    }
-}
diff --git a/facebook/tests/src/com/facebook/widget/WorkQueueTests.java b/facebook/tests/src/com/facebook/widget/WorkQueueTests.java
deleted file mode 100644
index e6ce1e2d7..000000000
--- a/facebook/tests/src/com/facebook/widget/WorkQueueTests.java
+++ /dev/null
@@ -1,345 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.test.suitebuilder.annotation.LargeTest;
-import android.test.suitebuilder.annotation.MediumTest;
-import android.test.suitebuilder.annotation.SmallTest;
-import com.facebook.FacebookTestCase;
-import com.facebook.widget.WorkQueue;
-
-import java.util.ArrayList;
-import java.util.concurrent.Executor;
-import java.security.SecureRandom;
-
-public class WorkQueueTests extends FacebookTestCase {
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testEmptyValidate() {
-        WorkQueue manager = new WorkQueue();
-        manager.validate();
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testRunSomething() {
-        CountingRunnable run = new CountingRunnable();
-        assertEquals(0, run.getRunCount());
-
-        ScriptableExecutor executor = new ScriptableExecutor();
-        assertEquals(0, executor.getPendingCount());
-
-        WorkQueue manager = new WorkQueue(1, executor);
-
-        addActiveWorkItem(manager, run);
-        assertEquals(1, executor.getPendingCount());
-        assertEquals(0, run.getRunCount());
-
-        executeNext(manager, executor);
-        assertEquals(0, executor.getPendingCount());
-        assertEquals(1, run.getRunCount());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testRunSequence() {
-        final int workTotal = 100;
-
-        CountingRunnable run = new CountingRunnable();
-        ScriptableExecutor executor = new ScriptableExecutor();
-        WorkQueue manager = new WorkQueue(1, executor);
-
-        for (int i = 0; i < workTotal; i++) {
-            addActiveWorkItem(manager, run);
-            assertEquals(1, executor.getPendingCount());
-        }
-
-        for (int i = 0; i < workTotal; i++) {
-            assertEquals(1, executor.getPendingCount());
-            assertEquals(i, run.getRunCount());
-            executeNext(manager, executor);
-        }
-        assertEquals(0, executor.getPendingCount());
-        assertEquals(workTotal, run.getRunCount());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testRunParallel() {
-        final int workTotal = 100;
-
-        CountingRunnable run = new CountingRunnable();
-        ScriptableExecutor executor = new ScriptableExecutor();
-        WorkQueue manager = new WorkQueue(workTotal, executor);
-
-        for (int i = 0; i < workTotal; i++) {
-            assertEquals(i, executor.getPendingCount());
-            addActiveWorkItem(manager, run);
-        }
-
-        for (int i = 0; i < workTotal; i++) {
-            assertEquals(workTotal - i, executor.getPendingCount());
-            assertEquals(i, run.getRunCount());
-            executeNext(manager, executor);
-        }
-        assertEquals(0, executor.getPendingCount());
-        assertEquals(workTotal, run.getRunCount());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testSimpleCancel() {
-        CountingRunnable run = new CountingRunnable();
-        ScriptableExecutor executor = new ScriptableExecutor();
-        WorkQueue manager = new WorkQueue(1, executor);
-
-        addActiveWorkItem(manager, run);
-        WorkQueue.WorkItem work1 = addActiveWorkItem(manager, run);
-        cancelWork(manager, work1);
-
-        assertEquals(1, executor.getPendingCount());
-        executeNext(manager, executor);
-        assertEquals(0, executor.getPendingCount());
-    }
-
-    @SmallTest
-    @MediumTest
-    @LargeTest
-    public void testMoveToFront() {
-        final int firstCount = 8;
-        final int highCount = 17;
-
-        ArrayList<WorkQueue.WorkItem> highWorkItems = new ArrayList<WorkQueue.WorkItem>();
-        CountingRunnable highRun = new CountingRunnable();
-        CountingRunnable firstRun = new CountingRunnable();
-        CountingRunnable lowRun = new CountingRunnable();
-        ScriptableExecutor executor = new ScriptableExecutor();
-        WorkQueue manager = new WorkQueue(firstCount, executor);
-
-        for (int i = 0; i < firstCount; i++) {
-            addActiveWorkItem(manager, firstRun);
-        }
-
-        int lowCount = 0;
-        for (int h = 0; h < highCount; h++) {
-            highWorkItems.add(addActiveWorkItem(manager, highRun));
-            for (int l = 0; l < h; l++) {
-                addActiveWorkItem(manager, lowRun);
-                lowCount++;
-            }
-        }
-
-        assertEquals(firstCount, executor.getPendingCount());
-        for (WorkQueue.WorkItem highItem : highWorkItems) {
-            prioritizeWork(manager, highItem);
-        }
-
-        for (int i = 0; i < firstCount; i++) {
-            assertEquals(i, firstRun.getRunCount());
-            executeNext(manager, executor);
-        }
-
-        for (int i = 0; i < highCount; i++) {
-            assertEquals(i, highRun.getRunCount());
-            executeNext(manager, executor);
-        }
-
-        for (int i = 0; i < lowCount; i++) {
-            assertEquals(i, lowRun.getRunCount());
-            executeNext(manager, executor);
-        }
-
-        assertEquals(firstCount, firstRun.getRunCount());
-        assertEquals(highCount, highRun.getRunCount());
-        assertEquals(lowCount, lowRun.getRunCount());
-    }
-
-    // Test cancelling running work item, completed work item
-
-    @LargeTest
-    public void testThreadStress() {
-        WorkQueue manager = new WorkQueue();
-        ArrayList<StressRunnable> runnables = new ArrayList<StressRunnable>();
-        final int threadCount = 20;
-
-        for (int i = 0; i < threadCount; i++) {
-            runnables.add(new StressRunnable(manager, 20));
-        }
-
-        for (int i = 0; i < threadCount; i++) {
-            manager.addActiveWorkItem(runnables.get(i));
-        }
-
-        for (int i = 0; i < threadCount; i++) {
-            runnables.get(i).waitForDone();
-        }
-    }
-
-    private WorkQueue.WorkItem addActiveWorkItem(WorkQueue manager, Runnable runnable) {
-        manager.validate();
-        WorkQueue.WorkItem workItem = manager.addActiveWorkItem(runnable);
-        manager.validate();
-        return workItem;
-    }
-
-    private void executeNext(WorkQueue manager, ScriptableExecutor executor) {
-        manager.validate();
-        executor.runNext();
-        manager.validate();
-    }
-
-    private void cancelWork(WorkQueue manager, WorkQueue.WorkItem workItem) {
-        manager.validate();
-        workItem.cancel();
-        manager.validate();
-    }
-
-    private void prioritizeWork(WorkQueue manager, WorkQueue.WorkItem workItem) {
-        manager.validate();
-        workItem.moveToFront();
-        manager.validate();
-    }
-
-    static class StressRunnable implements Runnable {
-        static ArrayList<WorkQueue.WorkItem> tracked = new ArrayList<WorkQueue.WorkItem>();
-
-        final WorkQueue manager;
-        final SecureRandom random = new SecureRandom();
-        final int iterationCount;
-        int iterationIndex = 0;
-        boolean isDone = false;
-
-        StressRunnable(WorkQueue manager, int iterationCount) {
-            this.manager = manager;
-            this.iterationCount = iterationCount;
-        }
-
-        @Override
-        public void run() {
-            // Each iteration runs a random action against the WorkQueue.
-            if (iterationIndex++ < iterationCount) {
-                final int sleepWeight = 80;
-                final int trackThisWeight = 10;
-                final int prioritizeTrackedWeight = 6;
-                final int validateWeight = 2;
-                int weight = 0;
-                final int n = random.nextInt(sleepWeight + trackThisWeight + prioritizeTrackedWeight + validateWeight);
-                WorkQueue.WorkItem workItem = manager.addActiveWorkItem(this);
-
-                if (n < (weight += sleepWeight)) {
-                    // Sleep
-                    try {
-                        Thread.sleep(n/4);
-                    } catch (InterruptedException e) {
-                    }
-                } else if (n < (weight += trackThisWeight)) {
-                    // Track this work item to activate later
-                    synchronized (tracked) {
-                        tracked.add(workItem);
-                    }
-                } else if (n < (weight += prioritizeTrackedWeight)) {
-                    // Background all pending items, prioritize tracked items, and clear tracked list
-                    ArrayList<WorkQueue.WorkItem> items = new ArrayList<WorkQueue.WorkItem>();
-
-                    synchronized (tracked) {
-                        items.addAll(tracked);
-                        tracked.clear();
-                    }
-
-                    for (WorkQueue.WorkItem item : items) {
-                        item.moveToFront();
-                    }
-                } else {
-                    // Validate
-                    manager.validate();
-                }
-            } else {
-                // Also have all threads validate once they are done.
-                manager.validate();
-                synchronized (this) {
-                    isDone = true;
-                    this.notifyAll();
-                }
-            }
-        }
-
-        void waitForDone() {
-            synchronized (this) {
-                while (!isDone) {
-                    try {
-                        this.wait();
-                    } catch (InterruptedException e) {
-                    }
-                }
-            }
-        }
-    }
-
-    class ScriptableExecutor implements Executor {
-        private final ArrayList<Runnable> runnables = new ArrayList<Runnable>();
-
-        int getPendingCount() {
-            return runnables.size();
-        }
-
-        void runNext() {
-            assertTrue(runnables.size() > 0);
-            runnables.get(0).run();
-            runnables.remove(0);
-        }
-
-        void runLast() {
-            assertTrue(runnables.size() > 0);
-            int index = runnables.size() - 1;
-            runnables.get(index).run();
-            runnables.remove(index);
-        }
-
-        @Override
-        public void execute(Runnable runnable) {
-            synchronized (this) {
-                runnables.add(runnable);
-            }
-        }
-    }
-
-    class CountingRunnable implements Runnable {
-        volatile int runCount = 0;
-
-        int getRunCount() {
-            return runCount;
-        }
-
-        @Override
-        public void run() {
-            synchronized (this) {
-                runCount++;
-            }
-
-            try {
-                Thread.sleep(1);
-            } catch (InterruptedException e) {
-            }
-        }
-    }
-}
