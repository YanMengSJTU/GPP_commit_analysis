diff --git a/facebook/src/com/facebook/Session.java b/facebook/src/com/facebook/Session.java
index 6d9ba30f8..86c296ca9 100644
--- a/facebook/src/com/facebook/Session.java
+++ b/facebook/src/com/facebook/Session.java
@@ -16,18 +16,48 @@
 
 package com.facebook;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InvalidObjectException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
 import android.Manifest;
 import android.app.Activity;
 import android.app.AlertDialog;
-import android.content.*;
-import android.content.pm.*;
+import android.content.ActivityNotFoundException;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
-import android.os.*;
+import android.content.pm.ResolveInfo;
+import android.content.pm.Signature;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
 import android.support.v4.app.Fragment;
 import android.support.v4.content.LocalBroadcastManager;
 import android.text.TextUtils;
 import android.util.Log;
 import android.webkit.CookieSyncManager;
+
 import com.facebook.android.Util;
 import com.facebook.internal.ServerProtocol;
 import com.facebook.internal.SessionAuthorizationType;
@@ -35,10 +65,6 @@
 import com.facebook.internal.Validate;
 import com.facebook.widget.WebDialog;
 
-import java.io.*;
-import java.lang.ref.WeakReference;
-import java.util.*;
-
 /**
  * <p>
  * Session is used to authenticate a user and manage the user's session with
@@ -47,7 +73,7 @@
  * <p>
  * Sessions must be opened before they can be used to make a Request. When a
  * Session is created, it attempts to initialize itself from a TokenCache.
- * Closing the session can optionally clear this cache.  The Session lifecycle
+ * Closing the session can optionally clear this cache. The Session lifecycle
  * uses {@link SessionState SessionState} to indicate its state.
  * </p>
  * <p>
@@ -65,9 +91,8 @@
 
     /**
      * The default activity code used for authorization.
-     *
-     * @see #openForRead(OpenRequest)
-     *      open
+     * 
+     * @see #openForRead(OpenRequest) open
      */
     public static final int DEFAULT_AUTHORIZE_ACTIVITY_CODE = 0xface;
 
@@ -86,30 +111,34 @@
     public static final String WEB_VIEW_FAILING_URL_KEY = "com.facebook.sdk.FailingUrl";
 
     /**
-     * The action used to indicate that the active session has been set. This should
-     * be used as an action in an IntentFilter and BroadcastReceiver registered with
-     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     * The action used to indicate that the active session has been set. This
+     * should be used as an action in an IntentFilter and BroadcastReceiver
+     * registered with the
+     * {@link android.support.v4.content.LocalBroadcastManager}.
      */
     public static final String ACTION_ACTIVE_SESSION_SET = "com.facebook.sdk.ACTIVE_SESSION_SET";
 
     /**
-     * The action used to indicate that the active session has been set to null. This should
-     * be used as an action in an IntentFilter and BroadcastReceiver registered with
-     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     * The action used to indicate that the active session has been set to null.
+     * This should be used as an action in an IntentFilter and BroadcastReceiver
+     * registered with the
+     * {@link android.support.v4.content.LocalBroadcastManager}.
      */
     public static final String ACTION_ACTIVE_SESSION_UNSET = "com.facebook.sdk.ACTIVE_SESSION_UNSET";
 
     /**
-     * The action used to indicate that the active session has been opened. This should
-     * be used as an action in an IntentFilter and BroadcastReceiver registered with
-     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     * The action used to indicate that the active session has been opened. This
+     * should be used as an action in an IntentFilter and BroadcastReceiver
+     * registered with the
+     * {@link android.support.v4.content.LocalBroadcastManager}.
      */
     public static final String ACTION_ACTIVE_SESSION_OPENED = "com.facebook.sdk.ACTIVE_SESSION_OPENED";
 
     /**
-     * The action used to indicate that the active session has been closed. This should
-     * be used as an action in an IntentFilter and BroadcastReceiver registered with
-     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     * The action used to indicate that the active session has been closed. This
+     * should be used as an action in an IntentFilter and BroadcastReceiver
+     * registered with the
+     * {@link android.support.v4.content.LocalBroadcastManager}.
      */
     public static final String ACTION_ACTIVE_SESSION_CLOSED = "com.facebook.sdk.ACTIVE_SESSION_CLOSED";
 
@@ -134,13 +163,15 @@
     private static final String PUBLISH_PERMISSION_PREFIX = "publish";
     private static final String MANAGE_PERMISSION_PREFIX = "manage";
     @SuppressWarnings("serial")
-    private static final Set<String> OTHER_PUBLISH_PERMISSIONS = new HashSet<String>() {{
-        add("ads_management");
-        add("create_event");
-        add("rsvp_event");
-    }};
+    private static final Set<String> OTHER_PUBLISH_PERMISSIONS = new HashSet<String>() {
+        {
+            add("ads_management");
+            add("create_event");
+            add("rsvp_event");
+        }
+    };
 
-    private String applicationId;
+    private final String applicationId;
     private SessionState state;
     private AccessToken tokenInfo;
     private Date lastAttemptedTokenExtendDate = new Date(0);
@@ -150,8 +181,8 @@
 
     // The following are not serialized with the Session object
     private volatile Bundle authorizationBundle;
-    private List<StatusCallback> callbacks;
-    private Handler handler;
+    private final List<StatusCallback> callbacks;
+    private final Handler handler;
     private AutoPublishAsyncTask autoPublishAsyncTask;
     // This is the object that synchronizes access to state and tokenInfo
     private Object lock = new Object();
@@ -160,9 +191,9 @@
 
     /**
      * Serialization proxy for the Session class. This is version 1 of
-     * serialization. Future serializations may differ in format. This
-     * class should not be modified. If serializations formats change,
-     * create a new class SerializationProxyVx.
+     * serialization. Future serializations may differ in format. This class
+     * should not be modified. If serializations formats change, create a new
+     * class SerializationProxyVx.
      */
     private static class SerializationProxyV1 implements Serializable {
         private static final long serialVersionUID = 7663436173185080063L;
@@ -173,9 +204,8 @@
         private final boolean shouldAutoPublish;
         private final AuthorizationRequest pendingRequest;
 
-        SerializationProxyV1(String applicationId, SessionState state,
-                AccessToken tokenInfo, Date lastAttemptedTokenExtendDate,
-                boolean shouldAutoPublish, AuthorizationRequest pendingRequest) {
+        SerializationProxyV1(String applicationId, SessionState state, AccessToken tokenInfo,
+                Date lastAttemptedTokenExtendDate, boolean shouldAutoPublish, AuthorizationRequest pendingRequest) {
             this.applicationId = applicationId;
             this.state = state;
             this.tokenInfo = tokenInfo;
@@ -185,16 +215,15 @@
         }
 
         private Object readResolve() {
-            return new Session(applicationId, state, tokenInfo,
-                    lastAttemptedTokenExtendDate, shouldAutoPublish, pendingRequest);
+            return new Session(applicationId, state, tokenInfo, lastAttemptedTokenExtendDate, shouldAutoPublish,
+                    pendingRequest);
         }
     }
 
     /**
      * Used by version 1 of the serialization proxy, do not modify.
      */
-    private Session(String applicationId, SessionState state,
-            AccessToken tokenInfo, Date lastAttemptedTokenExtendDate,
+    private Session(String applicationId, SessionState state, AccessToken tokenInfo, Date lastAttemptedTokenExtendDate,
             boolean shouldAutoPublish, AuthorizationRequest pendingRequest) {
         this.applicationId = applicationId;
         this.state = state;
@@ -211,8 +240,9 @@ private Session(String applicationId, SessionState state,
 
     /**
      * Initializes a new Session with the specified context.
-     *
-     * @param currentContext The Activity or Service creating this Session.
+     * 
+     * @param currentContext
+     *            The Activity or Service creating this Session.
      */
     public Session(Context currentContext) {
         this(currentContext, null, null, true);
@@ -255,21 +285,21 @@ public Session(Context currentContext) {
                 // If expired or we require new permissions, clear out the
                 // current token cache.
                 tokenCache.clear();
-                this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
+                this.tokenInfo = AccessToken.createEmptyToken(Collections.<String> emptyList());
             } else {
                 // Otherwise we have a valid token, so use it.
                 this.tokenInfo = AccessToken.createFromCache(tokenState);
                 this.state = SessionState.CREATED_TOKEN_LOADED;
             }
         } else {
-            this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
+            this.tokenInfo = AccessToken.createEmptyToken(Collections.<String> emptyList());
         }
     }
 
     /**
      * Returns a Bundle containing data that was returned from Facebook during
      * authorization.
-     *
+     * 
      * @return a Bundle containing data that was returned from Facebook during
      *         authorization.
      */
@@ -281,7 +311,7 @@ public final Bundle getAuthorizationBundle() {
 
     /**
      * Returns a boolean indicating whether the session is opened.
-     *
+     * 
      * @return a boolean indicating whether the session is opened.
      */
     public final boolean isOpened() {
@@ -297,9 +327,9 @@ public final boolean isClosed() {
     }
 
     /**
-     * Returns the current state of the Session.
-     * See {@link SessionState} for details.
-     *
+     * Returns the current state of the Session. See {@link SessionState} for
+     * details.
+     * 
      * @return the current state of the Session.
      */
     public final SessionState getState() {
@@ -310,7 +340,7 @@ public final SessionState getState() {
 
     /**
      * Returns the application id associated with this Session.
-     *
+     * 
      * @return the application id associated with this Session.
      */
     public final String getApplicationId() {
@@ -319,7 +349,7 @@ public final String getApplicationId() {
 
     /**
      * Returns the access token String.
-     *
+     * 
      * @return the access token String, or null if there is no access token
      */
     public final String getAccessToken() {
@@ -336,8 +366,9 @@ public final String getAccessToken() {
      * Note that Session automatically attempts to extend the lifetime of Tokens
      * as needed when Facebook requests are made.
      * </p>
-     *
-     * @return the Date at which the current token will expire, or null if there is no access token
+     * 
+     * @return the Date at which the current token will expire, or null if there
+     *         is no access token
      */
     public final Date getExpirationDate() {
         synchronized (this.lock) {
@@ -352,11 +383,12 @@ public final Date getExpirationDate() {
      * <p>
      * If there is a valid token, this represents the permissions granted by
      * that token. This can change during calls to
-     * {@link #reauthorizeForRead(com.facebook.Session.ReauthorizeRequest)}
-     * or {@link #reauthorizeForPublish(com.facebook.Session.ReauthorizeRequest)}.
+     * {@link #reauthorizeForRead(com.facebook.Session.ReauthorizeRequest)} or
+     * {@link #reauthorizeForPublish(com.facebook.Session.ReauthorizeRequest)}.
      * </p>
-     *
-     * @return the list of permissions associated with the session, or null if there is no access token
+     * 
+     * @return the list of permissions associated with the session, or null if
+     *         there is no access token
      */
     public final List<String> getPermissions() {
         synchronized (this.lock) {
@@ -371,24 +403,29 @@ public final Date getExpirationDate() {
      * <p>
      * A session may not be used with {@link Request Request} and other classes
      * in the SDK until it is open. If, prior to calling open, the session is in
-     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
-     * state, and the requested permissions are a subset of the previously authorized
-     * permissions, then the Session becomes usable immediately with no user interaction.
+     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state,
+     * and the requested permissions are a subset of the previously authorized
+     * permissions, then the Session becomes usable immediately with no user
+     * interaction.
      * </p>
      * <p>
-     * The permissions associated with the openRequest passed to this method must
-     * be read permissions only (or null/empty). It is not allowed to pass publish
-     * permissions to this method and will result in an exception being thrown.
+     * The permissions associated with the openRequest passed to this method
+     * must be read permissions only (or null/empty). It is not allowed to pass
+     * publish permissions to this method and will result in an exception being
+     * thrown.
      * </p>
      * <p>
-     * Any open method must be called at most once, and cannot be called after the
-     * Session is closed. Calling the method at an invalid time will result in
-     * UnsuportedOperationException.
+     * Any open method must be called at most once, and cannot be called after
+     * the Session is closed. Calling the method at an invalid time will result
+     * in UnsuportedOperationException.
      * </p>
-     *
-     * @param openRequest the open request, can be null only if the Session is in the
-     *                    {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
-     * @throws FacebookException if any publish permissions are requested
+     * 
+     * @param openRequest
+     *            the open request, can be null only if the Session is in the
+     *            {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
+     *            state
+     * @throws FacebookException
+     *             if any publish permissions are requested
      */
     public final void openForRead(OpenRequest openRequest) {
         open(openRequest, SessionAuthorizationType.READ);
@@ -401,24 +438,29 @@ public final void openForRead(OpenRequest openRequest) {
      * <p>
      * A session may not be used with {@link Request Request} and other classes
      * in the SDK until it is open. If, prior to calling open, the session is in
-     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
-     * state, and the requested permissions are a subset of the previously authorized
-     * permissions, then the Session becomes usable immediately with no user interaction.
+     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state,
+     * and the requested permissions are a subset of the previously authorized
+     * permissions, then the Session becomes usable immediately with no user
+     * interaction.
      * </p>
      * <p>
-     * The permissions associated with the openRequest passed to this method must
-     * be publish permissions only and must be non-empty. Any read permissions
-     * will result in a warning, and may fail during server-side authorization.
+     * The permissions associated with the openRequest passed to this method
+     * must be publish permissions only and must be non-empty. Any read
+     * permissions will result in a warning, and may fail during server-side
+     * authorization.
      * </p>
      * <p>
-     * Any open method must be called at most once, and cannot be called after the
-     * Session is closed. Calling the method at an invalid time will result in
-     * UnsuportedOperationException.
+     * Any open method must be called at most once, and cannot be called after
+     * the Session is closed. Calling the method at an invalid time will result
+     * in UnsuportedOperationException.
      * </p>
-     *
-     * @param openRequest the open request, can be null only if the Session is in the
-     *                    {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
-     * @throws FacebookException if the passed in request is null or has no permissions set.
+     * 
+     * @param openRequest
+     *            the open request, can be null only if the Session is in the
+     *            {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
+     *            state
+     * @throws FacebookException
+     *             if the passed in request is null or has no permissions set.
      */
     public final void openForPublish(OpenRequest openRequest) {
         open(openRequest, SessionAuthorizationType.PUBLISH);
@@ -431,17 +473,18 @@ public final void openForPublish(OpenRequest openRequest) {
      * <p>
      * A session may not be used with {@link Request Request} and other classes
      * in the SDK until it is open. If, prior to calling open, the session is in
-     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
-     * state, then the Session becomes usable immediately with no user interaction.
+     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state,
+     * then the Session becomes usable immediately with no user interaction.
      * Otherwise, this will open the Session with basic permissions.
      * </p>
      * <p>
-     * Any open method must be called at most once, and cannot be called after the
-     * Session is closed. Calling the method at an invalid time will result in
-     * UnsuportedOperationException.
+     * Any open method must be called at most once, and cannot be called after
+     * the Session is closed. Calling the method at an invalid time will result
+     * in UnsuportedOperationException.
      * </p>
-     *
-     * @param activity the Activity used to open the Session
+     * 
+     * @param activity
+     *            the Activity used to open the Session
      */
     public final void openForRead(Activity activity) {
         openForRead(new OpenRequest(activity));
@@ -454,17 +497,18 @@ public final void openForRead(Activity activity) {
      * <p>
      * A session may not be used with {@link Request Request} and other classes
      * in the SDK until it is open. If, prior to calling open, the session is in
-     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
-     * state, then the Session becomes usable immediately with no user interaction.
+     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state,
+     * then the Session becomes usable immediately with no user interaction.
      * Otherwise, this will open the Session with basic permissions.
      * </p>
      * <p>
-     * Any open method must be called at most once, and cannot be called after the
-     * Session is closed. Calling the method at an invalid time will result in
-     * UnsuportedOperationException.
+     * Any open method must be called at most once, and cannot be called after
+     * the Session is closed. Calling the method at an invalid time will result
+     * in UnsuportedOperationException.
      * </p>
-     *
-     * @param fragment the Fragment used to open the Session
+     * 
+     * @param fragment
+     *            the Fragment used to open the Session
      */
     public final void openForRead(Fragment fragment) {
         openForRead(new OpenRequest(fragment));
@@ -475,56 +519,67 @@ public final void openForRead(Fragment fragment) {
      * Logs a user in to Facebook.
      * </p>
      * <p>
-     * This method should only be called if the session is in
-     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
-     * state.
+     * This method should only be called if the session is in the
+     * {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state.
      * </p>
      * <p>
-     * Any open method must be called at most once, and cannot be called after the
-     * Session is closed. Calling the method at an invalid time will result in
-     * UnsuportedOperationException.
+     * Any open method must be called at most once, and cannot be called after
+     * the Session is closed. Calling the method at an invalid time will result
+     * in UnsuportedOperationException.
      * </p>
-     *
-     * @throws UnsupportedOperationException If the session is in an invalid state.
+     * 
+     * @throws UnsupportedOperationException
+     *             If the session is in an invalid state.
      */
     public final void open() {
         if (state.equals(SessionState.CREATED_TOKEN_LOADED)) {
             openForRead((OpenRequest) null);
         } else {
             throw new UnsupportedOperationException(String.format(
-                    "Cannot call open without an OpenRequest when the state is %s",
-                    state.toString()));
+                    "Cannot call open without an OpenRequest when the state is %s", state.toString()));
         }
     }
 
     /**
-     * Opens a session based on an existing Facebook access token. This method should be used
-     * only in instances where an application has previously obtained an access token and wishes
-     * to import it into the Session/TokenCache-based session-management system. A primary
-     * example would be an application which previously did not use the Facebook SDK for Android
-     * and implemented its own session-management scheme, but wishes to implement an upgrade path
-     * for existing users so they do not need to log in again when upgrading to a version of
-     * the app that uses the SDK. In general, this method will be called only once, when the app
-     * detects that it has been upgraded -- after that, the usual Session lifecycle methods
+     * Opens a session based on an existing Facebook access token. This method
+     * should be used only in instances where an application has previously
+     * obtained an access token and wishes to import it into the
+     * Session/TokenCache-based session-management system. A primary example
+     * would be an application which previously did not use the Facebook SDK for
+     * Android and implemented its own session-management scheme, but wishes to
+     * implement an upgrade path for existing users so they do not need to log
+     * in again when upgrading to a version of the app that uses the SDK. In
+     * general, this method will be called only once, when the app detects that
+     * it has been upgraded -- after that, the usual Session lifecycle methods
      * should be used to manage the session and its associated token.
      * <p/>
-     * No validation is done that the token, token source, or permissions are actually valid.
-     * It is the caller's responsibility to ensure that these accurately reflect the state of
-     * the token that has been passed in, or calls to the Facebook API may fail.
-     *
-     * @param accessToken       the actual access token obtained from Facebook
-     * @param expirationTime    the expiration date associated with the token
-     * @param lastRefreshTime   the last time the token was refreshed (or when it was first obtained)
-     * @param accessTokenSource an enum indicating how the token was originally obtained (in most cases,
-     *                          this will be either AccessTokenSource.FACEBOOK_APPLICATION or
-     *                          AccessTokenSource.WEB_VIEW)
-     * @param permissions       the permissions that were requested when the token was obtained (or when
-     *                          it was last reauthorized); may be null if permission set is unknown
-     * @param callback          a callback that will be called when the session status changes; may be null
+     * No validation is done that the token, token source, or permissions are
+     * actually valid. It is the caller's responsibility to ensure that these
+     * accurately reflect the state of the token that has been passed in, or
+     * calls to the Facebook API may fail.
+     * 
+     * @param accessToken
+     *            the actual access token obtained from Facebook
+     * @param expirationTime
+     *            the expiration date associated with the token
+     * @param lastRefreshTime
+     *            the last time the token was refreshed (or when it was first
+     *            obtained)
+     * @param accessTokenSource
+     *            an enum indicating how the token was originally obtained (in
+     *            most cases, this will be either
+     *            AccessTokenSource.FACEBOOK_APPLICATION or
+     *            AccessTokenSource.WEB_VIEW)
+     * @param permissions
+     *            the permissions that were requested when the token was
+     *            obtained (or when it was last reauthorized); may be null if
+     *            permission set is unknown
+     * @param callback
+     *            a callback that will be called when the session status
+     *            changes; may be null
      */
-    public final void openWithImportedAccessToken(String accessToken, Date expirationTime,
-            Date lastRefreshTime, AccessTokenSource accessTokenSource, List<String> permissions,
-            StatusCallback callback) {
+    public final void openWithImportedAccessToken(String accessToken, Date expirationTime, Date lastRefreshTime,
+            AccessTokenSource accessTokenSource, List<String> permissions, StatusCallback callback) {
         AccessToken newToken = new AccessToken(accessToken, expirationTime, permissions, accessTokenSource,
                 lastRefreshTime);
         openWithAccessToken(newToken, callback);
@@ -541,12 +596,14 @@ public final void openWithImportedAccessToken(String accessToken, Date expiratio
      * match the newPermissions. If this fails, the Session remains unchanged.
      * </p>
      * <p>
-     * The permissions associated with the reauthorizeRequest passed to this method must
-     * be read permissions only (or null/empty). It is not allowed to pass publish
-     * permissions to this method and will result in an exception being thrown.
+     * The permissions associated with the reauthorizeRequest passed to this
+     * method must be read permissions only (or null/empty). It is not allowed
+     * to pass publish permissions to this method and will result in an
+     * exception being thrown.
      * </p>
-     *
-     * @param reauthorizeRequest the reauthorization request
+     * 
+     * @param reauthorizeRequest
+     *            the reauthorization request
      */
     public final void reauthorizeForRead(ReauthorizeRequest reauthorizeRequest) {
         reauthorize(reauthorizeRequest, SessionAuthorizationType.READ);
@@ -561,12 +618,14 @@ public final void reauthorizeForRead(ReauthorizeRequest reauthorizeRequest) {
      * match the newPermissions. If this fails, the Session remains unchanged.
      * </p>
      * <p>
-     * The permissions associated with the reauthorizeRequest passed to this method must
-     * be publish permissions only and must be non-empty. Any read permissions
-     * will result in a warning, and may fail during server-side authorization.
+     * The permissions associated with the reauthorizeRequest passed to this
+     * method must be publish permissions only and must be non-empty. Any read
+     * permissions will result in a warning, and may fail during server-side
+     * authorization.
      * </p>
-     *
-     * @param reauthorizeRequest the reauthorization request
+     * 
+     * @param reauthorizeRequest
+     *            the reauthorization request
      */
     public final void reauthorizeForPublish(ReauthorizeRequest reauthorizeRequest) {
         reauthorize(reauthorizeRequest, SessionAuthorizationType.PUBLISH);
@@ -579,16 +638,20 @@ public final void reauthorizeForPublish(ReauthorizeRequest reauthorizeRequest) {
      * reauthorize should forward the resulting onActivityResult call here to
      * update the Session state based on the contents of the resultCode and
      * data.
-     *
-     * @param currentActivity The Activity that is forwarding the onActivityResult call.
-     * @param requestCode     The requestCode parameter from the forwarded call. When this
-     *                        onActivityResult occurs as part of Facebook authorization
-     *                        flow, this value is the activityCode passed to open or
-     *                        authorize.
-     * @param resultCode      An int containing the resultCode parameter from the forwarded
-     *                        call.
-     * @param data            The Intent passed as the data parameter from the forwarded
-     *                        call.
+     * 
+     * @param currentActivity
+     *            The Activity that is forwarding the onActivityResult call.
+     * @param requestCode
+     *            The requestCode parameter from the forwarded call. When this
+     *            onActivityResult occurs as part of Facebook authorization
+     *            flow, this value is the activityCode passed to open or
+     *            authorize.
+     * @param resultCode
+     *            An int containing the resultCode parameter from the forwarded
+     *            call.
+     * @param data
+     *            The Intent passed as the data parameter from the forwarded
+     *            call.
      * @return A boolean indicating whether the requestCode matched a pending
      *         authorization request for this Session.
      */
@@ -671,19 +734,18 @@ public final void close() {
             final SessionState oldState = this.state;
 
             switch (this.state) {
-                case CREATED:
-                case OPENING:
-                    this.state = SessionState.CLOSED_LOGIN_FAILED;
-                    postStateChange(oldState, this.state, new FacebookException(
-                            "Log in attempt aborted."));
-                    break;
-
-                case CREATED_TOKEN_LOADED:
-                case OPENED:
-                case OPENED_TOKEN_UPDATED:
-                    this.state = SessionState.CLOSED;
-                    postStateChange(oldState, this.state, null);
-                    break;
+            case CREATED:
+            case OPENING:
+                this.state = SessionState.CLOSED_LOGIN_FAILED;
+                postStateChange(oldState, this.state, new FacebookException("Log in attempt aborted."));
+                break;
+
+            case CREATED_TOKEN_LOADED:
+            case OPENED:
+            case OPENED_TOKEN_UPDATED:
+                this.state = SessionState.CLOSED;
+                postStateChange(oldState, this.state, null);
+                break;
             }
         }
     }
@@ -718,24 +780,25 @@ public String toString() {
      * automatically updates its token. This is only provided for backwards
      * compatibility and may be removed in a future release.
      * </p>
-     *
-     * @param bundle Opaque Bundle of data from the Facebook class.
+     * 
+     * @param bundle
+     *            Opaque Bundle of data from the Facebook class.
      */
     public void internalRefreshToken(Bundle bundle) {
         synchronized (this.lock) {
             final SessionState oldState = this.state;
 
             switch (this.state) {
-                case OPENED:
-                    this.state = SessionState.OPENED_TOKEN_UPDATED;
-                    postStateChange(oldState, this.state, null);
-                    break;
-                case OPENED_TOKEN_UPDATED:
-                    break;
-                default:
-                    // Silently ignore attempts to refresh token if we are not open
-                    Log.d(TAG, "refreshToken ignored in state " + this.state);
-                    return;
+            case OPENED:
+                this.state = SessionState.OPENED_TOKEN_UPDATED;
+                postStateChange(oldState, this.state, null);
+                break;
+            case OPENED_TOKEN_UPDATED:
+                break;
+            default:
+                // Silently ignore attempts to refresh token if we are not open
+                Log.d(TAG, "refreshToken ignored in state " + this.state);
+                return;
             }
             this.tokenInfo = AccessToken.createForRefresh(this.tokenInfo, bundle);
             if (this.tokenCache != null) {
@@ -745,8 +808,8 @@ public void internalRefreshToken(Bundle bundle) {
     }
 
     private Object writeReplace() {
-        return new SerializationProxyV1(applicationId, state, tokenInfo,
-                lastAttemptedTokenExtendDate, shouldAutoPublish, pendingRequest);
+        return new SerializationProxyV1(applicationId, state, tokenInfo, lastAttemptedTokenExtendDate,
+                shouldAutoPublish, pendingRequest);
     }
 
     // have a readObject that throws to prevent spoofing
@@ -756,9 +819,11 @@ private void readObject(ObjectInputStream stream) throws InvalidObjectException
 
     /**
      * Save the Session object into the supplied Bundle.
-     *
-     * @param session the Session to save
-     * @param bundle  the Bundle to save the Session to
+     * 
+     * @param session
+     *            the Session to save
+     * @param bundle
+     *            the Bundle to save the Session to
      */
     public static final void saveSession(Session session, Bundle bundle) {
         if (bundle != null && session != null) {
@@ -774,19 +839,22 @@ public static final void saveSession(Session session, Bundle bundle) {
     }
 
     /**
-     * Restores the saved session from a Bundle, if any. Returns the restored Session or
-     * null if it could not be restored.
-     *
-     * @param context  the Activity or Service creating the Session, must not be null
-     * @param cache    the TokenCache to use to load and store the token. If this is
-     *                 null, a default token cache that stores data in
-     *                 SharedPreferences will be used
-     * @param callback the callback to notify for Session state changes, can be null
-     * @param bundle   the bundle to restore the Session from
+     * Restores the saved session from a Bundle, if any. Returns the restored
+     * Session or null if it could not be restored.
+     * 
+     * @param context
+     *            the Activity or Service creating the Session, must not be null
+     * @param cache
+     *            the TokenCache to use to load and store the token. If this is
+     *            null, a default token cache that stores data in
+     *            SharedPreferences will be used
+     * @param callback
+     *            the callback to notify for Session state changes, can be null
+     * @param bundle
+     *            the bundle to restore the Session from
      * @return the restored Session, or null
      */
-    public static final Session restoreSession(
-            Context context, TokenCache cache, StatusCallback callback, Bundle bundle) {
+    public static final Session restoreSession(Context context, TokenCache cache, StatusCallback callback, Bundle bundle) {
         if (bundle == null) {
             return null;
         }
@@ -815,10 +883,9 @@ public static final Session restoreSession(
         return null;
     }
 
-
     /**
      * Returns the current active Session, or null if there is none.
-     *
+     * 
      * @return the current active Session, or null if there is none.
      */
     public static final Session getActiveSession() {
@@ -838,9 +905,10 @@ public static final Session getActiveSession() {
      * <p>
      * It is legal to set this to null, or to a Session that is not yet open.
      * </p>
-     *
-     * @param session A Session to use as the active Session, or null to indicate
-     *                that there is no active Session.
+     * 
+     * @param session
+     *            A Session to use as the active Session, or null to indicate
+     *            that there is no active Session.
      */
     public static final void setActiveSession(Session session) {
         synchronized (Session.staticLock) {
@@ -869,10 +937,11 @@ public static final void setActiveSession(Session session) {
     }
 
     /**
-     * Create a new Session, and if a token cache is available, open the
-     * Session and make it active without any user interaction.
-     *
-     * @param context The Context creating this session
+     * Create a new Session, and if a token cache is available, open the Session
+     * and make it active without any user interaction.
+     * 
+     * @param context
+     *            The Context creating this session
      * @return The new session or null if one could not be created
      */
     public static Session openActiveSession(Context context) {
@@ -880,18 +949,21 @@ public static Session openActiveSession(Context context) {
     }
 
     /**
-     * If allowLoginUI is true, this will create a new Session, make it active, and
-     * open it. If the default token cache is not available, then this will request
-     * basic permissions. If the default token cache is available and cached tokens
-     * are loaded, this will use the cached token and associated permissions.
+     * If allowLoginUI is true, this will create a new Session, make it active,
+     * and open it. If the default token cache is not available, then this will
+     * request basic permissions. If the default token cache is available and
+     * cached tokens are loaded, this will use the cached token and associated
+     * permissions.
      * <p/>
-     * If allowedLoginUI is false, this will only create the active session and open
-     * it if it requires no user interaction (i.e. the token cache is available and
-     * there are cached tokens).
-     *
-     * @param activity     The Activity that is opening the new Session.
-     * @param allowLoginUI if false, only sets the active session and opens it if it
-     *                     does not require user interaction
+     * If allowedLoginUI is false, this will only create the active session and
+     * open it if it requires no user interaction (i.e. the token cache is
+     * available and there are cached tokens).
+     * 
+     * @param activity
+     *            The Activity that is opening the new Session.
+     * @param allowLoginUI
+     *            if false, only sets the active session and opens it if it does
+     *            not require user interaction
      * @return The new Session or null if one could not be created
      */
     public static Session openActiveSession(Activity activity, boolean allowLoginUI) {
@@ -899,41 +971,48 @@ public static Session openActiveSession(Activity activity, boolean allowLoginUI)
     }
 
     /**
-     * If allowLoginUI is true, this will create a new Session, make it active, and
-     * open it. If the default token cache is not available, then this will request
-     * basic permissions. If the default token cache is available and cached tokens
-     * are loaded, this will use the cached token and associated permissions.
+     * If allowLoginUI is true, this will create a new Session, make it active,
+     * and open it. If the default token cache is not available, then this will
+     * request basic permissions. If the default token cache is available and
+     * cached tokens are loaded, this will use the cached token and associated
+     * permissions.
      * <p/>
-     * If allowedLoginUI is false, this will only create the active session and open
-     * it if it requires no user interaction (i.e. the token cache is available and
-     * there are cached tokens).
-     *
-     * @param activity     The Activity that is opening the new Session.
-     * @param allowLoginUI if false, only sets the active session and opens it if it
-     *                     does not require user interaction
-     * @param callback     The {@link StatusCallback SessionStatusCallback} to
-     *                     notify regarding Session state changes.
+     * If allowedLoginUI is false, this will only create the active session and
+     * open it if it requires no user interaction (i.e. the token cache is
+     * available and there are cached tokens).
+     * 
+     * @param activity
+     *            The Activity that is opening the new Session.
+     * @param allowLoginUI
+     *            if false, only sets the active session and opens it if it does
+     *            not require user interaction
+     * @param callback
+     *            The {@link StatusCallback SessionStatusCallback} to notify
+     *            regarding Session state changes.
      * @return The new Session or null if one could not be created
      */
-    public static Session openActiveSession(Activity activity, boolean allowLoginUI,
-            StatusCallback callback) {
+    public static Session openActiveSession(Activity activity, boolean allowLoginUI, StatusCallback callback) {
         return openActiveSession(activity, allowLoginUI, new OpenRequest(activity).setCallback(callback));
     }
 
     /**
-     * If allowLoginUI is true, this will create a new Session, make it active, and
-     * open it. If the default token cache is not available, then this will request
-     * basic permissions. If the default token cache is available and cached tokens
-     * are loaded, this will use the cached token and associated permissions.
+     * If allowLoginUI is true, this will create a new Session, make it active,
+     * and open it. If the default token cache is not available, then this will
+     * request basic permissions. If the default token cache is available and
+     * cached tokens are loaded, this will use the cached token and associated
+     * permissions.
      * <p/>
-     * If allowedLoginUI is false, this will only create the active session and open
-     * it if it requires no user interaction (i.e. the token cache is available and
-     * there are cached tokens).
-     *
-     * @param context      The Activity or Service creating this Session
-     * @param fragment     The Fragment that is opening the new Session.
-     * @param allowLoginUI if false, only sets the active session and opens it if it
-     *                     does not require user interaction
+     * If allowedLoginUI is false, this will only create the active session and
+     * open it if it requires no user interaction (i.e. the token cache is
+     * available and there are cached tokens).
+     * 
+     * @param context
+     *            The Activity or Service creating this Session
+     * @param fragment
+     *            The Fragment that is opening the new Session.
+     * @param allowLoginUI
+     *            if false, only sets the active session and opens it if it does
+     *            not require user interaction
      * @return The new Session or null if one could not be created
      */
     public static Session openActiveSession(Context context, Fragment fragment, boolean allowLoginUI) {
@@ -941,56 +1020,107 @@ public static Session openActiveSession(Context context, Fragment fragment, bool
     }
 
     /**
-     * If allowLoginUI is true, this will create a new Session, make it active, and
-     * open it. If the default token cache is not available, then this will request
-     * basic permissions. If the default token cache is available and cached tokens
-     * are loaded, this will use the cached token and associated permissions.
+     * If allowLoginUI is true, this will create a new Session, make it active,
+     * and open it. If the default token cache is not available, then this will
+     * request basic permissions. If the default token cache is available and
+     * cached tokens are loaded, this will use the cached token and associated
+     * permissions.
      * <p/>
-     * If allowedLoginUI is false, this will only create the active session and open
-     * it if it requires no user interaction (i.e. the token cache is available and
-     * there are cached tokens).
-     *
-     * @param context      The Activity or Service creating this Session
-     * @param fragment     The Fragment that is opening the new Session.
-     * @param allowLoginUI if false, only sets the active session and opens it if it
-     *                     does not require user interaction
-     * @param callback     The {@link StatusCallback SessionStatusCallback} to
-     *                     notify regarding Session state changes.
+     * If allowedLoginUI is false, this will only create the active session and
+     * open it if it requires no user interaction (i.e. the token cache is
+     * available and there are cached tokens).
+     * 
+     * @param context
+     *            The Activity or Service creating this Session
+     * @param fragment
+     *            The Fragment that is opening the new Session.
+     * @param allowLoginUI
+     *            if false, only sets the active session and opens it if it does
+     *            not require user interaction
+     * @param callback
+     *            The {@link StatusCallback SessionStatusCallback} to notify
+     *            regarding Session state changes.
      * @return The new Session or null if one could not be created
      */
-    public static Session openActiveSession(Context context, Fragment fragment,
-            boolean allowLoginUI, StatusCallback callback) {
+    public static Session openActiveSession(Context context, Fragment fragment, boolean allowLoginUI,
+            StatusCallback callback) {
         return openActiveSession(context, allowLoginUI, new OpenRequest(fragment).setCallback(callback));
     }
 
     /**
-     * Opens a session based on an existing Facebook access token, and also makes this session
-     * the currently active session. This method should be used
-     * only in instances where an application has previously obtained an access token and wishes
-     * to import it into the Session/TokenCache-based session-management system. A primary
-     * example would be an application which previously did not use the Facebook SDK for Android
-     * and implemented its own session-management scheme, but wishes to implement an upgrade path
-     * for existing users so they do not need to log in again when upgrading to a version of
-     * the app that uses the SDK. In general, this method will be called only once, when the app
-     * detects that it has been upgraded -- after that, the usual Session lifecycle methods
-     * should be used to manage the session and its associated token.
+     * If allowLoginUI is true, this will create a new Session, make it active,
+     * and open it. If the default token cache is not available, then this will
+     * request basic permissions. If the default token cache is available and
+     * cached tokens are loaded, this will use the cached token and associated
+     * permissions.
      * <p/>
-     * No validation is done that the token, token source, or permissions are actually valid.
-     * It is the caller's responsibility to ensure that these accurately reflect the state of
-     * the token that has been passed in, or calls to the Facebook API may fail.
-     *
-     * @param context           the Context to use for creation the session
-     * @param applicationId the Facebook Application ID to associate with the session; if null, this
-     *                      will be read from the package's metadata
-     * @param accessToken       the actual access token obtained from Facebook
-     * @param expirationTime    the expiration date associated with the token
-     * @param lastRefreshTime   the last time the token was refreshed (or when it was first obtained)
-     * @param accessTokenSource an enum indicating how the token was originally obtained (in most cases,
-     *                          this will be either AccessTokenSource.FACEBOOK_APPLICATION or
-     *                          AccessTokenSource.WEB_VIEW)
-     * @param permissions       the permissions that were requested when the token was obtained (or when
-     *                          it was last reauthorized); may be null if permission set is unknown
-     * @param callback          a callback that will be called when the session status changes; may be null
+     * If allowedLoginUI is false, this will only create the active session and
+     * open it if it requires no user interaction (i.e. the token cache is
+     * available and there are cached tokens).
+     * 
+     * @param context
+     *            The Activity or Service creating this Session
+     * @param fragment
+     *            The Fragment that is opening the new Session.
+     * @param allowLoginUI
+     *            if false, only sets the active session and opens it if it does
+     *            not require user interaction
+     * @param callback
+     *            The {@link StatusCallback SessionStatusCallback} to notify
+     *            regarding Session state changes.
+     * @param permissions
+     *            The permissions to request.
+     * @return The new Session or null if one could not be created
+     */
+    public static Session openActiveSession(Context context, Fragment fragment, boolean allowLoginUI,
+            StatusCallback callback, List<String> permissions) {
+        return openActiveSession(context, allowLoginUI,
+                new OpenRequest(fragment).setCallback(callback).setPermissions(permissions));
+    }
+
+    /**
+     * Opens a session based on an existing Facebook access token, and also
+     * makes this session the currently active session. This method should be
+     * used only in instances where an application has previously obtained an
+     * access token and wishes to import it into the Session/TokenCache-based
+     * session-management system. A primary example would be an application
+     * which previously did not use the Facebook SDK for Android and implemented
+     * its own session-management scheme, but wishes to implement an upgrade
+     * path for existing users so they do not need to log in again when
+     * upgrading to a version of the app that uses the SDK. In general, this
+     * method will be called only once, when the app detects that it has been
+     * upgraded -- after that, the usual Session lifecycle methods should be
+     * used to manage the session and its associated token.
+     * <p/>
+     * No validation is done that the token, token source, or permissions are
+     * actually valid. It is the caller's responsibility to ensure that these
+     * accurately reflect the state of the token that has been passed in, or
+     * calls to the Facebook API may fail.
+     * 
+     * @param context
+     *            the Context to use for creation the session
+     * @param applicationId
+     *            the Facebook Application ID to associate with the session; if
+     *            null, this will be read from the package's metadata
+     * @param accessToken
+     *            the actual access token obtained from Facebook
+     * @param expirationTime
+     *            the expiration date associated with the token
+     * @param lastRefreshTime
+     *            the last time the token was refreshed (or when it was first
+     *            obtained)
+     * @param accessTokenSource
+     *            an enum indicating how the token was originally obtained (in
+     *            most cases, this will be either
+     *            AccessTokenSource.FACEBOOK_APPLICATION or
+     *            AccessTokenSource.WEB_VIEW)
+     * @param permissions
+     *            the permissions that were requested when the token was
+     *            obtained (or when it was last reauthorized); may be null if
+     *            permission set is unknown
+     * @param callback
+     *            a callback that will be called when the session status
+     *            changes; may be null
      */
     public static Session openActiveSessionWithImportedAccessToken(Context context, String applicationId,
             String accessToken, Date expirationTime, Date lastRefreshTime, AccessTokenSource accessTokenSource,
@@ -1046,13 +1176,13 @@ void authorize(AuthorizationRequest request) {
                 final SessionState oldState = this.state;
 
                 switch (this.state) {
-                    case CLOSED:
-                    case CLOSED_LOGIN_FAILED:
-                        return;
+                case CLOSED:
+                case CLOSED_LOGIN_FAILED:
+                    return;
 
-                    default:
-                        this.state = SessionState.CLOSED_LOGIN_FAILED;
-                        postStateChange(oldState, this.state, new FacebookException("Log in attempt failed."));
+                default:
+                    this.state = SessionState.CLOSED_LOGIN_FAILED;
+                    postStateChange(oldState, this.state, new FacebookException("Log in attempt failed."));
                 }
             }
         }
@@ -1085,28 +1215,28 @@ private void open(OpenRequest openRequest, SessionAuthorizationType authType) {
             final SessionState oldState = this.state;
 
             switch (this.state) {
-                case CREATED:
-                    this.state = newState = SessionState.OPENING;
-                    if (openRequest == null) {
-                        throw new IllegalArgumentException("openRequest cannot be null when opening a new Session");
-                    }
-                    pendingRequest = openRequest;
-                    break;
-                case CREATED_TOKEN_LOADED:
-                    if (openRequest != null && !Utility.isNullOrEmpty(openRequest.getPermissions())) {
-                        if (!Utility.isSubset(openRequest.getPermissions(), getPermissions())) {
-                            pendingRequest = openRequest;
-                        }
-                    }
-                    if (pendingRequest == null) {
-                        this.state = newState = SessionState.OPENED;
-                    } else {
-                        this.state = newState = SessionState.OPENING;
+            case CREATED:
+                this.state = newState = SessionState.OPENING;
+                if (openRequest == null) {
+                    throw new IllegalArgumentException("openRequest cannot be null when opening a new Session");
+                }
+                pendingRequest = openRequest;
+                break;
+            case CREATED_TOKEN_LOADED:
+                if (openRequest != null && !Utility.isNullOrEmpty(openRequest.getPermissions())) {
+                    if (!Utility.isSubset(openRequest.getPermissions(), getPermissions())) {
+                        pendingRequest = openRequest;
                     }
-                    break;
-                default:
-                    throw new UnsupportedOperationException(
-                            "Session: an attempt was made to open an already opened session.");
+                }
+                if (pendingRequest == null) {
+                    this.state = newState = SessionState.OPENED;
+                } else {
+                    this.state = newState = SessionState.OPENING;
+                }
+                break;
+            default:
+                throw new UnsupportedOperationException(
+                        "Session: an attempt was made to open an already opened session.");
             }
             if (openRequest != null) {
                 addCallback(openRequest.getCallback());
@@ -1157,13 +1287,13 @@ private void reauthorize(ReauthorizeRequest reauthorizeRequest, SessionAuthoriza
                             "Session: an attempt was made to reauthorize a session that has a pending request.");
                 }
                 switch (this.state) {
-                    case OPENED:
-                    case OPENED_TOKEN_UPDATED:
-                        pendingRequest = reauthorizeRequest;
-                        break;
-                    default:
-                        throw new UnsupportedOperationException(
-                                "Session: an attempt was made to reauthorize a session that is not currently open.");
+                case OPENED:
+                case OPENED_TOKEN_UPDATED:
+                    pendingRequest = reauthorizeRequest;
+                    break;
+                default:
+                    throw new UnsupportedOperationException(
+                            "Session: an attempt was made to reauthorize a session that is not currently open.");
                 }
             }
 
@@ -1172,15 +1302,17 @@ private void reauthorize(ReauthorizeRequest reauthorizeRequest, SessionAuthoriza
     }
 
     private void validateLoginBehavior(AuthorizationRequest request) {
-        if (request != null && !request.suppressLoginActivityVerification &&
-                (SessionLoginBehavior.SSO_WITH_FALLBACK.equals(request.getLoginBehavior()) ||
-                        SessionLoginBehavior.SUPPRESS_SSO.equals(request.getLoginBehavior()))) {
+        if (request != null
+                && !request.suppressLoginActivityVerification
+                && (SessionLoginBehavior.SSO_WITH_FALLBACK.equals(request.getLoginBehavior()) || SessionLoginBehavior.SUPPRESS_SSO
+                        .equals(request.getLoginBehavior()))) {
             Intent intent = new Intent();
             intent.setClass(getStaticContext(), LoginActivity.class);
             if (!resolveIntent(intent, false)) {
-                throw new FacebookException(String.format(
-                        "Cannot use SessionLoginBehavior %s when %s is not declared as an activity in AndroidManifest.xml",
-                        request.getLoginBehavior(), LoginActivity.class.getName()));
+                throw new FacebookException(
+                        String.format(
+                                "Cannot use SessionLoginBehavior %s when %s is not declared as an activity in AndroidManifest.xml",
+                                request.getLoginBehavior(), LoginActivity.class.getName()));
             }
         }
     }
@@ -1195,16 +1327,13 @@ private void validatePermissions(AuthorizationRequest request, SessionAuthorizat
         for (String permission : request.getPermissions()) {
             if (isPublishPermission(permission)) {
                 if (SessionAuthorizationType.READ.equals(authType)) {
-                    throw new FacebookException(
-                            String.format(
-                                    "Cannot pass a publish permission (%s) to a request for read authorization",
-                                    permission));
+                    throw new FacebookException(String.format(
+                            "Cannot pass a publish permission (%s) to a request for read authorization", permission));
                 }
             } else {
                 if (SessionAuthorizationType.PUBLISH.equals(authType)) {
-                    Log.w(TAG,
-                            String.format(
-                                    "Should not pass a read permission (%s) to a request for publish authorization",
+                    Log.w(TAG, String
+                            .format("Should not pass a read permission (%s) to a request for publish authorization",
                                     permission));
                 }
             }
@@ -1212,10 +1341,9 @@ private void validatePermissions(AuthorizationRequest request, SessionAuthorizat
     }
 
     private boolean isPublishPermission(String permission) {
-        return permission != null &&
-                (permission.startsWith(PUBLISH_PERMISSION_PREFIX) ||
-                        permission.startsWith(MANAGE_PERMISSION_PREFIX) ||
-                        OTHER_PUBLISH_PERMISSIONS.contains(permission));
+        return permission != null
+                && (permission.startsWith(PUBLISH_PERMISSION_PREFIX) || permission.startsWith(MANAGE_PERMISSION_PREFIX) || OTHER_PUBLISH_PERMISSIONS
+                        .contains(permission));
 
     }
 
@@ -1240,8 +1368,8 @@ private boolean tryActivityAuth(Intent intent, AuthorizationRequest request, boo
 
     private boolean resolveIntent(Intent intent, boolean validateSignature) {
         ResolveInfo resolveInfo = getStaticContext().getPackageManager().resolveActivity(intent, 0);
-        if ((resolveInfo == null) ||
-                (validateSignature && !validateFacebookAppSignature(resolveInfo.activityInfo.packageName))) {
+        if ((resolveInfo == null)
+                || (validateSignature && !validateFacebookAppSignature(resolveInfo.activityInfo.packageName))) {
             return false;
         }
         return true;
@@ -1255,9 +1383,8 @@ private boolean tryDialogAuth(final AuthorizationRequest request) {
             return true;
         }
 
-        Log.w(TAG,
-                String.format("Please add %s as an activity to your AndroidManifest.xml",
-                        LoginActivity.class.getName()));
+        Log.w(TAG, String.format("Please add %s as an activity to your AndroidManifest.xml",
+                LoginActivity.class.getName()));
 
         int permissionCheck = getStaticContext().checkCallingOrSelfPermission(Manifest.permission.INTERNET);
         Activity activityContext = request.getStartActivityDelegate().getActivityContext();
@@ -1275,7 +1402,8 @@ private boolean tryDialogAuth(final AuthorizationRequest request) {
             parameters.putString(ServerProtocol.DIALOG_PARAM_SCOPE, scope);
         }
 
-        // The call to clear cookies will create the first instance of CookieSyncManager if necessary
+        // The call to clear cookies will create the first instance of
+        // CookieSyncManager if necessary
         Utility.clearFacebookCookies(getStaticContext());
 
         WebDialog.OnCompleteListener listener = new WebDialog.OnCompleteListener() {
@@ -1318,8 +1446,7 @@ private boolean tryKatanaProxyAuth(AuthorizationRequest request) {
     private boolean validateFacebookAppSignature(String packageName) {
         PackageInfo packageInfo = null;
         try {
-            packageInfo = staticContext.getPackageManager().getPackageInfo(packageName,
-                    PackageManager.GET_SIGNATURES);
+            packageInfo = staticContext.getPackageManager().getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
         } catch (NameNotFoundException e) {
             return false;
         }
@@ -1350,19 +1477,18 @@ void finishAuth(AccessToken newToken, Exception exception) {
             final SessionState oldState = this.state;
 
             switch (this.state) {
-                case OPENING:
-                case OPENED:
-                case OPENED_TOKEN_UPDATED:
-                    if (newToken != null) {
-                        this.tokenInfo = newToken;
-                        this.state = (oldState == SessionState.OPENING) ? SessionState.OPENED
-                                : SessionState.OPENED_TOKEN_UPDATED;
-                    } else if (exception != null) {
-                        this.state = (oldState == SessionState.OPENING) ? SessionState.CLOSED_LOGIN_FAILED
-                                : oldState;
-                    }
-                    postStateChange(oldState, this.state, exception);
-                    break;
+            case OPENING:
+            case OPENED:
+            case OPENED_TOKEN_UPDATED:
+                if (newToken != null) {
+                    this.tokenInfo = newToken;
+                    this.state = (oldState == SessionState.OPENING) ? SessionState.OPENED
+                            : SessionState.OPENED_TOKEN_UPDATED;
+                } else if (exception != null) {
+                    this.state = (oldState == SessionState.OPENING) ? SessionState.CLOSED_LOGIN_FAILED : oldState;
+                }
+                postStateChange(oldState, this.state, exception);
+                break;
             }
             pendingRequest = null;
         }
@@ -1374,15 +1500,20 @@ void postStateChange(final SessionState oldState, final SessionState newState, f
         }
 
         synchronized (callbacks) {
-            // Need to schedule the callbacks inside the same queue to preserve ordering.
-            // Otherwise these callbacks could have been added to the queue before the SessionTracker
+            // Need to schedule the callbacks inside the same queue to preserve
+            // ordering.
+            // Otherwise these callbacks could have been added to the queue
+            // before the SessionTracker
             // gets the ACTIVE_SESSION_SET action.
             Runnable runCallbacks = new Runnable() {
+                @Override
                 public void run() {
                     for (final StatusCallback callback : callbacks) {
                         Runnable closure = new Runnable() {
+                            @Override
                             public void run() {
-                                // This can be called inside a synchronized block.
+                                // This can be called inside a synchronized
+                                // block.
                                 callback.call(Session.this, newState, exception);
                             }
                         };
@@ -1479,8 +1610,7 @@ void setCurrentTokenRefreshRequest(TokenRefreshRequest request) {
 
     class TokenRefreshRequest implements ServiceConnection {
 
-        final Messenger messageReceiver = new Messenger(
-                new TokenRefreshRequestHandler(Session.this, this));
+        final Messenger messageReceiver = new Messenger(new TokenRefreshRequestHandler(Session.this, this));
 
         Messenger messageSender = null;
 
@@ -1535,15 +1665,20 @@ private void refreshToken() {
 
     }
 
-    // Creating a static Handler class to reduce the possibility of a memory leak.
-    // Handler objects for the same thread all share a common Looper object, which they post messages
-    // to and read from. As messages contain target Handler, as long as there are messages with target
-    // handler in the message queue, the handler cannot be garbage collected. If handler is not static,
-    // the instance of the containing class also cannot be garbage collected even if it is destroyed.
+    // Creating a static Handler class to reduce the possibility of a memory
+    // leak.
+    // Handler objects for the same thread all share a common Looper object,
+    // which they post messages
+    // to and read from. As messages contain target Handler, as long as there
+    // are messages with target
+    // handler in the message queue, the handler cannot be garbage collected. If
+    // handler is not static,
+    // the instance of the containing class also cannot be garbage collected
+    // even if it is destroyed.
     static class TokenRefreshRequestHandler extends Handler {
 
-        private WeakReference<Session> sessionWeakReference;
-        private WeakReference<TokenRefreshRequest> refreshRequestWeakReference;
+        private final WeakReference<Session> sessionWeakReference;
+        private final WeakReference<TokenRefreshRequest> refreshRequestWeakReference;
 
         TokenRefreshRequestHandler(Session session, TokenRefreshRequest refreshRequest) {
             super(Looper.getMainLooper());
@@ -1572,7 +1707,7 @@ public void handleMessage(Message msg) {
 
     /**
      * Provides asynchronous notification of Session state changes.
-     *
+     * 
      * @see Session#open open
      */
     public interface StatusCallback {
@@ -1591,10 +1726,8 @@ public boolean equals(Object otherObj) {
         }
         Session other = (Session) otherObj;
 
-        return areEqual(other.applicationId, applicationId) &&
-                areEqual(other.authorizationBundle, authorizationBundle) &&
-                areEqual(other.state, state) &&
-                areEqual(other.getExpirationDate(), getExpirationDate());
+        return areEqual(other.applicationId, applicationId) && areEqual(other.authorizationBundle, authorizationBundle)
+                && areEqual(other.state, state) && areEqual(other.getExpirationDate(), getExpirationDate());
     }
 
     private static boolean areEqual(Object a, Object b) {
@@ -1616,8 +1749,9 @@ private static boolean areEqual(Object a, Object b) {
 
         /**
          * Constructs a new Builder associated with the context.
-         *
-         * @param context the Activity or Service starting the Session
+         * 
+         * @param context
+         *            the Activity or Service starting the Session
          */
         public Builder(Context context) {
             this.context = context;
@@ -1625,8 +1759,9 @@ public Builder(Context context) {
 
         /**
          * Sets the application id for the Session.
-         *
-         * @param applicationId the application id
+         * 
+         * @param applicationId
+         *            the application id
          * @return the Builder instance
          */
         public Builder setApplicationId(final String applicationId) {
@@ -1636,8 +1771,9 @@ public Builder setApplicationId(final String applicationId) {
 
         /**
          * Sets the TokenCache for the Session.
-         *
-         * @param tokenCache the token cache to use
+         * 
+         * @param tokenCache
+         *            the token cache to use
          * @return the Builder instance
          */
         public Builder setTokenCache(final TokenCache tokenCache) {
@@ -1652,7 +1788,7 @@ public Builder setShouldAutoPublishInstall(boolean shouldAutoPublishInstall) {
 
         /**
          * Build the Session.
-         *
+         * 
          * @return a new Session
          */
         public Session build() {
@@ -1670,7 +1806,8 @@ private void autoPublishAsync() {
         AutoPublishAsyncTask asyncTask = null;
         synchronized (this) {
             if (autoPublishAsyncTask == null && shouldAutoPublish) {
-                // copy the application id to guarantee thread safety against our container.
+                // copy the application id to guarantee thread safety against
+                // our container.
                 String applicationId = Session.this.applicationId;
 
                 // skip publish if we don't have an application id.
@@ -1758,8 +1895,8 @@ public Activity getActivityContext() {
         /**
          * Constructor to be used for V1 serialization only, DO NOT CHANGE.
          */
-        private AuthorizationRequest(SessionLoginBehavior loginBehavior, int requestCode,
-                List<String> permissions, boolean suppressLoginActivityVerification) {
+        private AuthorizationRequest(SessionLoginBehavior loginBehavior, int requestCode, List<String> permissions,
+                boolean suppressLoginActivityVerification) {
             startActivityDelegate = new StartActivityDelegate() {
                 @Override
                 public void startActivityForResult(Intent intent, int requestCode) {
@@ -1781,7 +1918,7 @@ public Activity getActivityContext() {
 
         /**
          * Used for backwards compatibility with Facebook.java only, DO NOT USE.
-         *
+         * 
          * @param suppressVerification
          */
         public void suppressLoginActivityVerification(boolean suppressVerification) {
@@ -1836,23 +1973,23 @@ StartActivityDelegate getStartActivityDelegate() {
 
         boolean allowKatana() {
             switch (loginBehavior) {
-                case SSO_ONLY:
-                    return true;
-                case SUPPRESS_SSO:
-                    return false;
-                default:
-                    return true;
+            case SSO_ONLY:
+                return true;
+            case SUPPRESS_SSO:
+                return false;
+            default:
+                return true;
             }
         }
 
         boolean allowWebView() {
             switch (loginBehavior) {
-                case SSO_ONLY:
-                    return false;
-                case SUPPRESS_SSO:
-                    return true;
-                default:
-                    return true;
+            case SSO_ONLY:
+                return false;
+            case SUPPRESS_SSO:
+                return true;
+            default:
+                return true;
             }
         }
 
@@ -1872,11 +2009,11 @@ void readObject(ObjectInputStream stream) throws InvalidObjectException {
             private static final long serialVersionUID = -8748347685113614927L;
             private final SessionLoginBehavior loginBehavior;
             private final int requestCode;
-            private boolean suppressLoginActivityVerification;
+            private final boolean suppressLoginActivityVerification;
             private final List<String> permissions;
 
-            private AuthRequestSerializationProxyV1(SessionLoginBehavior loginBehavior,
-                    int requestCode, List<String> permissions, boolean suppressVerification) {
+            private AuthRequestSerializationProxyV1(SessionLoginBehavior loginBehavior, int requestCode,
+                    List<String> permissions, boolean suppressVerification) {
                 this.loginBehavior = loginBehavior;
                 this.requestCode = requestCode;
                 this.permissions = permissions;
@@ -1898,8 +2035,9 @@ private Object readResolve() {
 
         /**
          * Constructs an OpenRequest.
-         *
-         * @param activity the Activity to use to open the Session
+         * 
+         * @param activity
+         *            the Activity to use to open the Session
          */
         public OpenRequest(Activity activity) {
             super(activity);
@@ -1907,8 +2045,9 @@ public OpenRequest(Activity activity) {
 
         /**
          * Constructs an OpenRequest.
-         *
-         * @param fragment the Fragment to use to open the Session
+         * 
+         * @param fragment
+         *            the Fragment to use to open the Session
          */
         public OpenRequest(Fragment fragment) {
             super(fragment);
@@ -1916,11 +2055,13 @@ public OpenRequest(Fragment fragment) {
 
         /**
          * Sets the StatusCallback for the OpenRequest.
-         *
-         * @param statusCallback The {@link StatusCallback SessionStatusCallback} to
-         *                       notify regarding Session state changes.
+         * 
+         * @param statusCallback
+         *            The {@link StatusCallback SessionStatusCallback} to notify
+         *            regarding Session state changes.
          * @return the OpenRequest object to allow for chaining
          */
+        @Override
         public final OpenRequest setCallback(StatusCallback statusCallback) {
             super.setCallback(statusCallback);
             return this;
@@ -1928,12 +2069,14 @@ public final OpenRequest setCallback(StatusCallback statusCallback) {
 
         /**
          * Sets the login behavior for the OpenRequest.
-         *
-         * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-         *                      specifies what behaviors should be attempted during
-         *                      authorization.
+         * 
+         * @param loginBehavior
+         *            The {@link SessionLoginBehavior SessionLoginBehavior} that
+         *            specifies what behaviors should be attempted during
+         *            authorization.
          * @return the OpenRequest object to allow for chaining
          */
+        @Override
         public final OpenRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
             super.setLoginBehavior(loginBehavior);
             return this;
@@ -1941,13 +2084,16 @@ public final OpenRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
 
         /**
          * Sets the request code for the OpenRequest.
-         *
-         * @param requestCode An integer that identifies this request. This integer will be used
-         *                    as the request code in {@link Activity#onActivityResult
-         *                    onActivityResult}. This integer should be >= 0. If a value < 0 is
-         *                    passed in, then a default value will be used.
+         * 
+         * @param requestCode
+         *            An integer that identifies this request. This integer will
+         *            be used as the request code in
+         *            {@link Activity#onActivityResult onActivityResult}. This
+         *            integer should be >= 0. If a value < 0 is passed in, then
+         *            a default value will be used.
          * @return the OpenRequest object to allow for chaining
          */
+        @Override
         public final OpenRequest setRequestCode(int requestCode) {
             super.setRequestCode(requestCode);
             return this;
@@ -1955,12 +2101,14 @@ public final OpenRequest setRequestCode(int requestCode) {
 
         /**
          * Sets the permissions for the OpenRequest.
-         *
-         * @param permissions A List&lt;String&gt; representing the permissions to request
-         *                    during the authentication flow. A null or empty List
-         *                    represents basic permissions.
+         * 
+         * @param permissions
+         *            A List&lt;String&gt; representing the permissions to
+         *            request during the authentication flow. A null or empty
+         *            List represents basic permissions.
          * @return the OpenRequest object to allow for chaining
          */
+        @Override
         public final OpenRequest setPermissions(List<String> permissions) {
             super.setPermissions(permissions);
             return this;
@@ -1975,9 +2123,11 @@ public final OpenRequest setPermissions(List<String> permissions) {
 
         /**
          * Constructs a ReauthorizeRequest.
-         *
-         * @param activity    the Activity used to reauthorize
-         * @param permissions additional permissions to request
+         * 
+         * @param activity
+         *            the Activity used to reauthorize
+         * @param permissions
+         *            additional permissions to request
          */
         public ReauthorizeRequest(Activity activity, List<String> permissions) {
             super(activity);
@@ -1986,9 +2136,11 @@ public ReauthorizeRequest(Activity activity, List<String> permissions) {
 
         /**
          * Constructs a ReauthorizeRequest.
-         *
-         * @param fragment    the Fragment used to reauthorize
-         * @param permissions additional permissions to request
+         * 
+         * @param fragment
+         *            the Fragment used to reauthorize
+         * @param permissions
+         *            additional permissions to request
          */
         public ReauthorizeRequest(Fragment fragment, List<String> permissions) {
             super(fragment);
@@ -1997,11 +2149,13 @@ public ReauthorizeRequest(Fragment fragment, List<String> permissions) {
 
         /**
          * Sets the StatusCallback for the ReauthorizeRequest.
-         *
-         * @param statusCallback The {@link StatusCallback SessionStatusCallback} to
-         *                       notify regarding Session state changes.
+         * 
+         * @param statusCallback
+         *            The {@link StatusCallback SessionStatusCallback} to notify
+         *            regarding Session state changes.
          * @return the ReauthorizeRequest object to allow for chaining
          */
+        @Override
         public final ReauthorizeRequest setCallback(StatusCallback statusCallback) {
             super.setCallback(statusCallback);
             return this;
@@ -2009,12 +2163,14 @@ public final ReauthorizeRequest setCallback(StatusCallback statusCallback) {
 
         /**
          * Sets the login behavior for the ReauthorizeRequest.
-         *
-         * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-         *                      specifies what behaviors should be attempted during
-         *                      authorization.
+         * 
+         * @param loginBehavior
+         *            The {@link SessionLoginBehavior SessionLoginBehavior} that
+         *            specifies what behaviors should be attempted during
+         *            authorization.
          * @return the ReauthorizeRequest object to allow for chaining
          */
+        @Override
         public final ReauthorizeRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
             super.setLoginBehavior(loginBehavior);
             return this;
@@ -2022,13 +2178,16 @@ public final ReauthorizeRequest setLoginBehavior(SessionLoginBehavior loginBehav
 
         /**
          * Sets the request code for the ReauthorizeRequest.
-         *
-         * @param requestCode An integer that identifies this request. This integer will be used
-         *                    as the request code in {@link Activity#onActivityResult
-         *                    onActivityResult}. This integer should be >= 0. If a value < 0 is
-         *                    passed in, then a default value will be used.
+         * 
+         * @param requestCode
+         *            An integer that identifies this request. This integer will
+         *            be used as the request code in
+         *            {@link Activity#onActivityResult onActivityResult}. This
+         *            integer should be >= 0. If a value < 0 is passed in, then
+         *            a default value will be used.
          * @return the ReauthorizeRequest object to allow for chaining
          */
+        @Override
         public final ReauthorizeRequest setRequestCode(int requestCode) {
             super.setRequestCode(requestCode);
             return this;
