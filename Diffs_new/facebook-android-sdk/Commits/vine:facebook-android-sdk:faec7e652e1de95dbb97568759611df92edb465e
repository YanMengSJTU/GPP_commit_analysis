diff --git a/facebook/src/com/facebook/AuthorizationClient.java b/facebook/src/com/facebook/AuthorizationClient.java
index 13c8e5c9a..145efa494 100644
--- a/facebook/src/com/facebook/AuthorizationClient.java
+++ b/facebook/src/com/facebook/AuthorizationClient.java
@@ -143,10 +143,8 @@ void cancelCurrentHandler() {
     }
 
     boolean onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (requestCode == pendingRequest.getRequestCode()) {
-            return currentHandler.onActivityResult(requestCode, resultCode, data);
-        }
-        return false;
+        return    (requestCode == pendingRequest.getRequestCode()) &&
+                    currentHandler.onActivityResult(requestCode, resultCode, data);
     }
 
     private List<AuthHandler> getHandlerTypes(AuthorizationRequest request) {
@@ -208,10 +206,7 @@ private void completeWithFailure() {
     }
 
     boolean tryCurrentHandler() {
-        if (currentHandler.needsInternetPermission() && !checkInternetPermission()) {
-            return false;
-        }
-        return currentHandler.tryAuthorize(pendingRequest);
+        return !(currentHandler.needsInternetPermission() && !checkInternetPermission()) && currentHandler.tryAuthorize(pendingRequest);
     }
 
     void completeAndValidate(Result outcome) {
diff --git a/facebook/src/com/facebook/LegacyHelper.java b/facebook/src/com/facebook/LegacyHelper.java
deleted file mode 100644
index dcdfd8561..000000000
--- a/facebook/src/com/facebook/LegacyHelper.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook;
-
-import android.os.Bundle;
-
-/**
- * LegacyHelper is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the methods in this class is unsupported, and they may be modified or removed without warning at
- * any time.
- */
-public class LegacyHelper {
-    @Deprecated
-    public static void extendTokenCompleted(Session session, Bundle bundle) {
-        session.extendTokenCompleted(bundle);
-    }
-}
diff --git a/facebook/src/com/facebook/android/Util.java b/facebook/src/com/facebook/android/Util.java
index 8906777ee..addd8a0b3 100644
--- a/facebook/src/com/facebook/android/Util.java
+++ b/facebook/src/com/facebook/android/Util.java
@@ -16,36 +16,15 @@
 
 package com.facebook.android;
 
-import android.app.AlertDialog.Builder;
-import android.content.Context;
 import android.os.Bundle;
-import com.facebook.internal.Utility;
-import org.json.JSONException;
-import org.json.JSONObject;
 
 import java.io.*;
 import java.net.*;
 
-/**
- * Utility class supporting the Facebook Object.
- * <p/>
- * THIS CLASS SHOULD BE CONSIDERED DEPRECATED.
- * <p/>
- * All public members of this class are intentionally deprecated.
- * New code should instead use
- * {@link com.facebook.Request}
- * <p/>
- * Adding @Deprecated to this class causes warnings in other deprecated classes
- * that reference this one.  That is the only reason this entire class is not
- * deprecated.
- *
- * @devDocDeprecated
- */
 public final class Util {
 
     private final static String UTF8 = "UTF-8";
 
-    @Deprecated
     public static Bundle decodeUrl(String s) {
         Bundle params = new Bundle();
         if (s != null) {
diff --git a/facebook/src/com/facebook/model/GraphObject.java b/facebook/src/com/facebook/model/GraphObject.java
index 7231ea547..868da204b 100644
--- a/facebook/src/com/facebook/model/GraphObject.java
+++ b/facebook/src/com/facebook/model/GraphObject.java
@@ -161,10 +161,7 @@ public static boolean hasSameId(GraphObject a, GraphObject b) {
             }
             Object idA = a.getProperty("id");
             Object idB = b.getProperty("id");
-            if (idA == null || idB == null || !(idA instanceof String) || !(idB instanceof String)) {
-                return false;
-            }
-            return idA.equals(idB);
+            return !(idA == null || idB == null || !(idA instanceof String) || !(idB instanceof String)) && idA.equals(idB);
         }
 
         /**
diff --git a/facebook/src/com/facebook/widget/FacebookFragment.java b/facebook/src/com/facebook/widget/FacebookFragment.java
deleted file mode 100644
index e9849a8ab..000000000
--- a/facebook/src/com/facebook/widget/FacebookFragment.java
+++ /dev/null
@@ -1,297 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import com.facebook.Session;
-import com.facebook.SessionLoginBehavior;
-import com.facebook.SessionState;
-import com.facebook.internal.SessionAuthorizationType;
-import com.facebook.internal.SessionTracker;
-
-import java.util.Date;
-import java.util.List;
-
-/**
- * <p>Basic implementation of a Fragment that uses a Session to perform 
- * Single Sign On (SSO). This class is package private, and is not intended
- * to be consumed by external applications.</p>
- * 
- * <p>The method {@link android.support.v4.app.Fragment#onActivityResult} is
- * used to manage the session information, so if you override it in a subclass, 
- * be sure to call {@code super.onActivityResult}.</p>
- * 
- * <p>The methods in this class are not thread-safe.</p>
- */
-class FacebookFragment extends Fragment {
-
-    private SessionTracker sessionTracker;
-
-    @Override
-    public void onActivityCreated(Bundle savedInstanceState) {
-        super.onActivityCreated(savedInstanceState);
-        sessionTracker = new SessionTracker(getActivity(), new DefaultSessionStatusCallback());
-    }
-    
-    /**
-     * Called when the activity that was launched exits. This method manages session
-     * information when a session is opened. If this method is overridden in subclasses,
-     * be sure to call {@code super.onActivityResult(...)} first.
-     */
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        super.onActivityResult(requestCode, resultCode, data);
-        sessionTracker.getSession().onActivityResult(this.getActivity(), requestCode, resultCode, data);
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-        sessionTracker.stopTracking();
-    }
-
-    /**
-     * Use the supplied Session object instead of the active Session.
-     *
-     * @param newSession the Session object to use
-     */
-    public void setSession(Session newSession) {
-        if (sessionTracker != null) {
-            sessionTracker.setSession(newSession);
-        }
-    }
-
-    // METHOD TO BE OVERRIDDEN
-    
-    /**
-     * Called when the session state changes. Override this method to take action
-     * on session state changes.
-     * 
-     * @param state the new state
-     * @param exception any exceptions that occurred during the state change
-     */
-    protected void onSessionStateChange(SessionState state, Exception exception) {
-    }
-
-    // ACCESSORS (CANNOT BE OVERRIDDEN)
-    
-    /**
-     * Gets the current Session.
-     * 
-     * @return the current Session object.
-     */
-    protected final Session getSession() {
-        if (sessionTracker != null) {
-            return sessionTracker.getSession();
-        }
-        return null;
-    }
-
-    /**
-     * Determines whether the current session is open.
-     * 
-     * @return true if the current session is open
-     */
-    protected final boolean isSessionOpen() {
-        if (sessionTracker != null) {
-            return sessionTracker.getOpenSession() != null;
-        }
-        return false;
-    }
-    
-    /**
-     * Gets the current state of the session or null if no session has been created.
-     * 
-     * @return the current state of the session
-     */
-    protected final SessionState getSessionState() {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getSession();
-            return (currentSession != null) ? currentSession.getState() : null;
-        }
-        return null;
-    }
-    
-    /**
-     * Gets the access token associated with the current session or null if no 
-     * session has been created.
-     * 
-     * @return the access token
-     */
-    protected final String getAccessToken() {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getOpenSession();
-            return (currentSession != null) ? currentSession.getAccessToken() : null;
-        }
-        return null;
-    }
-
-    /**
-     * Gets the date at which the current session will expire or null if no session 
-     * has been created.
-     * 
-     * @return the date at which the current session will expire
-     */
-    protected final Date getExpirationDate() {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getOpenSession();
-            return (currentSession != null) ? currentSession.getExpirationDate() : null;
-        }
-        return null;
-    }
-    
-    /**
-     * Closes the current session.
-     */
-    protected final void closeSession() {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getOpenSession();
-            if (currentSession != null) {
-                currentSession.close();
-            }
-        }
-    }
-    
-    /**
-     * Closes the current session as well as clearing the token cache.
-     */
-    protected final void closeSessionAndClearTokenInformation() {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getOpenSession();
-            if (currentSession != null) {
-                currentSession.closeAndClearTokenInformation();
-            }
-        }
-    }
-    
-    /**
-     * Gets the permissions associated with the current session or null if no session 
-     * has been created.
-     * 
-     * @return the permissions associated with the current session
-     */
-    protected final List<String> getSessionPermissions() {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getSession();
-            return (currentSession != null) ? currentSession.getPermissions() : null;
-        }
-        return null;
-    }
-
-    /**
-     * Opens a new session. This method will use the application id from
-     * the associated meta-data value and an empty list of permissions.
-     */
-    protected final void openSession() {
-        openSessionForRead(null, null);
-    }
-
-    /**
-     * Opens a new session with read permissions. If either applicationID or permissions
-     * is null, this method will default to using the values from the associated
-     * meta-data value and an empty list respectively.
-     *
-     * @param applicationId the applicationID, can be null
-     * @param permissions the permissions list, can be null
-     */
-    protected final void openSessionForRead(String applicationId, List<String> permissions) {
-        openSessionForRead(applicationId, permissions, SessionLoginBehavior.SSO_WITH_FALLBACK,
-                Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
-    }
-
-    /**
-     * Opens a new session with read permissions. If either applicationID or permissions
-     * is null, this method will default to using the values from the associated
-     * meta-data value and an empty list respectively.
-     *
-     * @param applicationId the applicationID, can be null
-     * @param permissions the permissions list, can be null
-     * @param behavior the login behavior to use with the session
-     * @param activityCode the activity code to use for the SSO activity
-     */
-    protected final void openSessionForRead(String applicationId, List<String> permissions,
-            SessionLoginBehavior behavior, int activityCode) {
-        openSession(applicationId, permissions, behavior, activityCode, SessionAuthorizationType.READ);
-    }
-
-    /**
-     * Opens a new session with publish permissions. If either applicationID is null,
-     * this method will default to using the value from the associated
-     * meta-data value. The permissions list cannot be null.
-     *
-     * @param applicationId the applicationID, can be null
-     * @param permissions the permissions list, cannot be null
-     */
-    protected final void openSessionForPublish(String applicationId, List<String> permissions) {
-        openSessionForPublish(applicationId, permissions, SessionLoginBehavior.SSO_WITH_FALLBACK,
-                Session.DEFAULT_AUTHORIZE_ACTIVITY_CODE);
-    }
-
-    /**
-     * Opens a new session with publish permissions. If either applicationID is null,
-     * this method will default to using the value from the associated
-     * meta-data value. The permissions list cannot be null.
-     *
-     * @param applicationId the applicationID, can be null
-     * @param permissions the permissions list, cannot be null
-     * @param behavior the login behavior to use with the session
-     * @param activityCode the activity code to use for the SSO activity
-     */
-    protected final void openSessionForPublish(String applicationId, List<String> permissions,
-            SessionLoginBehavior behavior, int activityCode) {
-        openSession(applicationId, permissions, behavior, activityCode, SessionAuthorizationType.PUBLISH);
-    }
-
-    private void openSession(String applicationId, List<String> permissions,
-            SessionLoginBehavior behavior, int activityCode, SessionAuthorizationType authType) {
-        if (sessionTracker != null) {
-            Session currentSession = sessionTracker.getSession();
-            if (currentSession == null || currentSession.getState().isClosed()) {
-                Session session = new Session.Builder(getActivity()).setApplicationId(applicationId).build();
-                Session.setActiveSession(session);
-                currentSession = session;
-            }
-            if (!currentSession.isOpened()) {
-                Session.OpenRequest openRequest = new Session.OpenRequest(this).
-                        setPermissions(permissions).
-                        setLoginBehavior(behavior).
-                        setRequestCode(activityCode);
-                if (SessionAuthorizationType.PUBLISH.equals(authType)) {
-                    currentSession.openForPublish(openRequest);
-                } else {
-                    currentSession.openForRead(openRequest);
-                }
-            }
-        }
-    }
-
-    /**
-     * The default callback implementation for the session.
-     */
-    private class DefaultSessionStatusCallback implements Session.StatusCallback {
-
-        @Override
-        public void call(Session session, 
-                         SessionState state,
-                         Exception exception) {
-            FacebookFragment.this.onSessionStateChange(state, exception);
-        }
-        
-    }
-}
diff --git a/facebook/src/com/facebook/widget/FriendPickerFragment.java b/facebook/src/com/facebook/widget/FriendPickerFragment.java
deleted file mode 100644
index 7867a5ea8..000000000
--- a/facebook/src/com/facebook/widget/FriendPickerFragment.java
+++ /dev/null
@@ -1,257 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.annotation.SuppressLint;
-import android.app.Activity;
-import android.content.res.TypedArray;
-import android.os.Bundle;
-import android.text.TextUtils;
-import android.util.AttributeSet;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.model.GraphUser;
-
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-/**
- * Provides a Fragment that displays a list of a user's friends and allows one or more of the
- * friends to be selected.
- */
-public class FriendPickerFragment extends PickerFragment<GraphUser> {
-    /**
-     * The key for a String parameter in the fragment's Intent bundle to indicate what user's
-     * friends should be shown. The default is to display the currently authenticated user's friends.
-     */
-    public static final String USER_ID_BUNDLE_KEY = "com.facebook.widget.FriendPickerFragment.UserId";
-    /**
-     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
-     * picker should allow more than one friend to be selected or not.
-     */
-    public static final String MULTI_SELECT_BUNDLE_KEY = "com.facebook.widget.FriendPickerFragment.MultiSelect";
-
-    private static final String ID = "id";
-    private static final String NAME = "name";
-
-    private String userId;
-
-    private boolean multiSelect = true;
-
-    /**
-     * Default constructor. Creates a Fragment with all default properties.
-     */
-    public FriendPickerFragment() {
-        this(null);
-    }
-
-    /**
-     * Constructor.
-     * @param args  a Bundle that optionally contains one or more values containing additional
-     *              configuration information for the Fragment.
-     */
-    @SuppressLint("ValidFragment")
-    public FriendPickerFragment(Bundle args) {
-        super(GraphUser.class, R.layout.com_facebook_friendpickerfragment, args);
-        setFriendPickerSettingsFromBundle(args);
-    }
-
-    /**
-     * Gets the ID of the user whose friends should be displayed. If null, the default is to
-     * show the currently authenticated user's friends.
-     * @return the user ID, or null
-     */
-    public String getUserId() {
-        return userId;
-    }
-
-    /**
-     * Sets the ID of the user whose friends should be displayed. If null, the default is to
-     * show the currently authenticated user's friends.
-     * @param userId     the user ID, or null
-     */
-    public void setUserId(String userId) {
-        this.userId = userId;
-    }
-
-    /**
-     * Gets whether the user can select multiple friends, or only one friend.
-     * @return true if the user can select multiple friends, false if only one friend
-     */
-    public boolean getMultiSelect() {
-        return multiSelect;
-    }
-
-    /**
-     * Sets whether the user can select multiple friends, or only one friend.
-     * @param multiSelect    true if the user can select multiple friends, false if only one friend
-     */
-    public void setMultiSelect(boolean multiSelect) {
-        if (this.multiSelect != multiSelect) {
-            this.multiSelect = multiSelect;
-            setSelectionStrategy(createSelectionStrategy());
-        }
-    }
-
-    /**
-     * Gets the currently-selected list of users.
-     * @return the currently-selected list of users
-     */
-    public List<GraphUser> getSelection() {
-        return getSelectedGraphObjects();
-    }
-
-    @Override
-    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
-        super.onInflate(activity, attrs, savedInstanceState);
-        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_friend_picker_fragment);
-
-        setMultiSelect(a.getBoolean(R.styleable.com_facebook_friend_picker_fragment_multi_select, multiSelect));
-
-        a.recycle();
-    }
-
-    public void setSettingsFromBundle(Bundle inState) {
-        super.setSettingsFromBundle(inState);
-        setFriendPickerSettingsFromBundle(inState);
-    }
-
-    void saveSettingsToBundle(Bundle outState) {
-        super.saveSettingsToBundle(outState);
-
-        outState.putString(USER_ID_BUNDLE_KEY, userId);
-        outState.putBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect);
-    }
-
-    @Override
-    PickerFragmentAdapter<GraphUser> createAdapter() {
-        PickerFragmentAdapter<GraphUser> adapter = new PickerFragmentAdapter<GraphUser>(
-                this.getActivity()) {
-
-            @Override
-            protected int getGraphObjectRowLayoutId(GraphUser graphObject) {
-                return R.layout.com_facebook_picker_list_row;
-            }
-
-            @Override
-            protected int getDefaultPicture() {
-                return R.drawable.com_facebook_profile_default_icon;
-            }
-
-        };
-        adapter.setShowCheckbox(true);
-        adapter.setShowPicture(getShowPictures());
-        adapter.setSortFields(Arrays.asList(new String[]{NAME}));
-        adapter.setGroupByField(NAME);
-
-        return adapter;
-    }
-
-    @Override
-    LoadingStrategy createLoadingStrategy() {
-        return new ImmediateLoadingStrategy();
-    }
-
-    @Override
-    SelectionStrategy createSelectionStrategy() {
-        return multiSelect ? new MultiSelectionStrategy() : new SingleSelectionStrategy();
-    }
-
-    @Override
-    Request getRequestForLoadData(Session session) {
-        if (adapter == null) {
-            throw new FacebookException("Can't issue requests until Fragment has been created.");
-        }
-
-        String userToFetch = (userId != null) ? userId : "me";
-        return createRequest(userToFetch, extraFields, session);
-    }
-
-    @Override
-    String getDefaultTitleText() {
-        return getString(R.string.com_facebook_choose_friends);
-    }
-
-    private Request createRequest(String userID, Set<String> extraFields, Session session) {
-        Request request = Request.newGraphPathRequest(session, userID + "/friends", null);
-
-        Set<String> fields = new HashSet<String>(extraFields);
-        String[] requiredFields = new String[]{
-                ID,
-                NAME
-        };
-        fields.addAll(Arrays.asList(requiredFields));
-
-        String pictureField = adapter.getPictureFieldSpecifier();
-        if (pictureField != null) {
-            fields.add(pictureField);
-        }
-
-        Bundle parameters = request.getParameters();
-        parameters.putString("fields", TextUtils.join(",", fields));
-        request.setParameters(parameters);
-
-        return request;
-    }
-
-    private void setFriendPickerSettingsFromBundle(Bundle inState) {
-        // We do this in a separate non-overridable method so it is safe to call from the constructor.
-        if (inState != null) {
-            if (inState.containsKey(USER_ID_BUNDLE_KEY)) {
-                setUserId(inState.getString(USER_ID_BUNDLE_KEY));
-            }
-            setMultiSelect(inState.getBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect));
-        }
-    }
-
-    private class ImmediateLoadingStrategy extends LoadingStrategy {
-        @Override
-        protected void onLoadFinished(GraphObjectPagingLoader<GraphUser> loader,
-                SimpleGraphObjectCursor<GraphUser> data) {
-            super.onLoadFinished(loader, data);
-
-            // We could be called in this state if we are clearing data or if we are being re-attached
-            // in the middle of a query.
-            if (data == null || loader.isLoading()) {
-                return;
-            }
-
-            if (data.areMoreObjectsAvailable()) {
-                // We got results, but more are available.
-                followNextLink();
-            } else {
-                // We finished loading results.
-                hideActivityCircle();
-
-                // If this was from the cache, schedule a delayed refresh query (unless we got no results
-                // at all, in which case refresh immediately.
-                if (data.isFromCache()) {
-                    loader.refreshOriginalRequest(data.getCount() == 0 ? CACHED_RESULT_REFRESH_DELAY : 0);
-                }
-            }
-        }
-
-        private void followNextLink() {
-            // This may look redundant, but this causes the circle to be alpha-dimmed if we have results.
-            displayActivityCircle();
-
-            loader.followNextLink();
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/widget/GraphObjectAdapter.java b/facebook/src/com/facebook/widget/GraphObjectAdapter.java
deleted file mode 100644
index 42643d6a0..000000000
--- a/facebook/src/com/facebook/widget/GraphObjectAdapter.java
+++ /dev/null
@@ -1,824 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.ViewStub;
-import android.widget.*;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.model.GraphObject;
-import org.json.JSONObject;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.text.Collator;
-import java.util.*;
-
-class GraphObjectAdapter<T extends GraphObject> extends BaseAdapter implements SectionIndexer {
-    private static final int DISPLAY_SECTIONS_THRESHOLD = 1;
-    private static final int HEADER_VIEW_TYPE = 0;
-    private static final int GRAPH_OBJECT_VIEW_TYPE = 1;
-    private static final int ACTIVITY_CIRCLE_VIEW_TYPE = 2;
-    private static final int MAX_PREFETCHED_PICTURES = 20;
-
-    private static final String ID = "id";
-    private static final String NAME = "name";
-    private static final String PICTURE = "picture";
-
-    private final Map<String, ImageRequest> pendingRequests = new HashMap<String, ImageRequest>();
-    private final LayoutInflater inflater;
-    private List<String> sectionKeys = new ArrayList<String>();
-    private Map<String, ArrayList<T>> graphObjectsBySection = new HashMap<String, ArrayList<T>>();
-    private Map<String, T> graphObjectsById = new HashMap<String, T>();
-    private boolean displaySections;
-    private List<String> sortFields;
-    private String groupByField;
-    private boolean showPicture;
-    private boolean showCheckbox;
-    private Filter<T> filter;
-    private DataNeededListener dataNeededListener;
-    private GraphObjectCursor<T> cursor;
-    private Context context;
-    private Map<String, ImageResponse> prefetchedPictureCache = new HashMap<String, ImageResponse>();
-    private ArrayList<String> prefetchedProfilePictureIds = new ArrayList<String>();
-    private OnErrorListener onErrorListener;
-
-    public interface DataNeededListener {
-        public void onDataNeeded();
-    }
-
-    public interface OnErrorListener {
-        void onError(GraphObjectAdapter<?> adapter, FacebookException error);
-    }
-
-    public static class SectionAndItem<T extends GraphObject> {
-        public String sectionKey;
-        public T graphObject;
-
-        public enum Type {
-            GRAPH_OBJECT,
-            SECTION_HEADER,
-            ACTIVITY_CIRCLE
-        }
-
-        public SectionAndItem(String sectionKey, T graphObject) {
-            this.sectionKey = sectionKey;
-            this.graphObject = graphObject;
-        }
-
-        public Type getType() {
-            if (sectionKey == null) {
-                return Type.ACTIVITY_CIRCLE;
-            } else if (graphObject == null) {
-                return Type.SECTION_HEADER;
-            } else {
-                return Type.GRAPH_OBJECT;
-            }
-        }
-    }
-
-    interface Filter<T> {
-        boolean includeItem(T graphObject);
-    }
-
-    public GraphObjectAdapter(Context context) {
-        this.context = context;
-        this.inflater = LayoutInflater.from(context);
-    }
-
-    public List<String> getSortFields() {
-        return sortFields;
-    }
-
-    public void setSortFields(List<String> sortFields) {
-        this.sortFields = sortFields;
-    }
-
-    public String getGroupByField() {
-        return groupByField;
-    }
-
-    public void setGroupByField(String groupByField) {
-        this.groupByField = groupByField;
-    }
-
-    public boolean getShowPicture() {
-        return showPicture;
-    }
-
-    public void setShowPicture(boolean showPicture) {
-        this.showPicture = showPicture;
-    }
-
-    public boolean getShowCheckbox() {
-        return showCheckbox;
-    }
-
-    public void setShowCheckbox(boolean showCheckbox) {
-        this.showCheckbox = showCheckbox;
-    }
-
-    public DataNeededListener getDataNeededListener() {
-        return dataNeededListener;
-    }
-
-    public void setDataNeededListener(DataNeededListener dataNeededListener) {
-        this.dataNeededListener = dataNeededListener;
-    }
-
-    public OnErrorListener getOnErrorListener() {
-        return onErrorListener;
-    }
-
-    public void setOnErrorListener(OnErrorListener onErrorListener) {
-        this.onErrorListener = onErrorListener;
-    }
-
-    public GraphObjectCursor<T> getCursor() {
-        return cursor;
-    }
-
-    public boolean changeCursor(GraphObjectCursor<T> cursor) {
-        if (this.cursor == cursor) {
-            return false;
-        }
-        if (this.cursor != null) {
-            this.cursor.close();
-        }
-        this.cursor = cursor;
-
-        rebuildAndNotify();
-        return true;
-    }
-
-    public void rebuildAndNotify() {
-        rebuildSections();
-        notifyDataSetChanged();
-    }
-
-    public void prioritizeViewRange(int firstVisibleItem, int lastVisibleItem, int prefetchBuffer) {
-        if (lastVisibleItem < firstVisibleItem) {
-            return;
-        }
-
-        // We want to prioritize requests for items which are visible but do not have pictures
-        // loaded yet. We also want to pre-fetch pictures for items which are not yet visible
-        // but are within a buffer on either side of the visible items, on the assumption that
-        // they will be visible soon. For these latter items, we'll store the images in memory
-        // in the hopes we can immediately populate their image view when needed.
-
-        // Prioritize the requests in reverse order since each call to prioritizeRequest will just
-        // move it to the front of the queue. And we want the earliest ones in the range to be at
-        // the front of the queue, so all else being equal, the list will appear to populate from
-        // the top down.
-        for (int i = lastVisibleItem; i >= 0; i--) {
-            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
-            if (sectionAndItem.graphObject != null) {
-                String id = getIdOfGraphObject(sectionAndItem.graphObject);
-                ImageRequest request = pendingRequests.get(id);
-                if (request != null) {
-                    ImageDownloader.prioritizeRequest(request);
-                }
-            }
-        }
-
-        // For items which are not visible, but within the buffer on either side, we want to
-        // fetch those items and store them in a small in-memory cache of bitmaps.
-        int start = Math.max(0, firstVisibleItem - prefetchBuffer);
-        int end = Math.min(lastVisibleItem + prefetchBuffer, getCount() - 1);
-        ArrayList<T> graphObjectsToPrefetchPicturesFor = new ArrayList<T>();
-        // Add the IDs before and after the visible range.
-        for (int i = start; i < firstVisibleItem; ++i) {
-            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
-            if (sectionAndItem.graphObject != null) {
-                graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
-            }
-        }
-        for (int i = lastVisibleItem + 1; i <= end; ++i) {
-            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
-            if (sectionAndItem.graphObject != null) {
-                graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
-            }
-        }
-        for (T graphObject : graphObjectsToPrefetchPicturesFor) {
-            URL url = getPictureUrlOfGraphObject(graphObject);
-            final String id = getIdOfGraphObject(graphObject);
-
-            // This URL already have been requested for pre-fetching, but we want to act in an LRU manner, so move
-            // it to the end of the list regardless.
-            boolean alreadyPrefetching = prefetchedProfilePictureIds.remove(id);
-            prefetchedProfilePictureIds.add(id);
-
-            // If we've already requested it for pre-fetching, no need to do so again.
-            if (!alreadyPrefetching) {
-                downloadProfilePicture(id, url, null);
-            }
-        }
-    }
-
-    protected String getSectionKeyOfGraphObject(T graphObject) {
-        String result = null;
-
-        if (groupByField != null) {
-            result = (String) graphObject.getProperty(groupByField);
-            if (result != null && result.length() > 0) {
-                result = result.substring(0, 1).toUpperCase();
-            }
-        }
-
-        return (result != null) ? result : "";
-    }
-
-    protected CharSequence getTitleOfGraphObject(T graphObject) {
-        return (String) graphObject.getProperty(NAME);
-    }
-
-    protected CharSequence getSubTitleOfGraphObject(T graphObject) {
-        return null;
-    }
-
-    protected URL getPictureUrlOfGraphObject(T graphObject) {
-        String url = null;
-        Object o = graphObject.getProperty(PICTURE);
-        if (o instanceof String) {
-            url = (String) o;
-        } else if (o instanceof JSONObject) {
-            ItemPicture itemPicture = GraphObject.Factory.create((JSONObject) o).cast(ItemPicture.class);
-            ItemPictureData data = itemPicture.getData();
-            if (data != null) {
-                url = data.getUrl();
-            }
-        }
-
-        if (url != null) {
-            try {
-                return new URL(url);
-            } catch (MalformedURLException e) {
-            }
-        }
-        return null;
-    }
-
-    protected View getSectionHeaderView(String sectionHeader, View convertView, ViewGroup parent) {
-        TextView result = (TextView) convertView;
-
-        if (result == null) {
-            result = (TextView) inflater.inflate(R.layout.com_facebook_picker_list_section_header, null);
-        }
-
-        result.setText(sectionHeader);
-
-        return result;
-    }
-
-    protected View getGraphObjectView(T graphObject, View convertView, ViewGroup parent) {
-        View result = convertView;
-
-        if (result == null) {
-            result = createGraphObjectView(graphObject, convertView);
-        }
-
-        populateGraphObjectView(result, graphObject);
-        return result;
-    }
-
-    private View getActivityCircleView(View convertView, ViewGroup parent) {
-        View result = convertView;
-
-        if (result == null) {
-            result = inflater.inflate(R.layout.com_facebook_picker_activity_circle_row, null);
-        }
-        ProgressBar activityCircle = (ProgressBar) result.findViewById(R.id.com_facebook_picker_row_activity_circle);
-        activityCircle.setVisibility(View.VISIBLE);
-
-        return result;
-    }
-
-    protected int getGraphObjectRowLayoutId(T graphObject) {
-        return R.layout.com_facebook_picker_list_row;
-    }
-
-    protected int getDefaultPicture() {
-        return R.drawable.com_facebook_profile_default_icon;
-    }
-
-    protected View createGraphObjectView(T graphObject, View convertView) {
-        View result = inflater.inflate(getGraphObjectRowLayoutId(graphObject), null);
-
-        ViewStub checkboxStub = (ViewStub) result.findViewById(R.id.com_facebook_picker_checkbox_stub);
-        if (checkboxStub != null) {
-            if (!getShowCheckbox()) {
-                checkboxStub.setVisibility(View.GONE);
-            } else {
-                CheckBox checkBox = (CheckBox) checkboxStub.inflate();
-                updateCheckboxState(checkBox, false);
-            }
-        }
-
-        ViewStub profilePicStub = (ViewStub) result.findViewById(R.id.com_facebook_picker_profile_pic_stub);
-        if (!getShowPicture()) {
-            profilePicStub.setVisibility(View.GONE);
-        } else {
-            ImageView imageView = (ImageView) profilePicStub.inflate();
-            imageView.setVisibility(View.VISIBLE);
-        }
-
-        return result;
-    }
-
-    protected void populateGraphObjectView(View view, T graphObject) {
-        String id = getIdOfGraphObject(graphObject);
-        view.setTag(id);
-
-        CharSequence title = getTitleOfGraphObject(graphObject);
-        TextView titleView = (TextView) view.findViewById(R.id.com_facebook_picker_title);
-        if (titleView != null) {
-            titleView.setText(title, TextView.BufferType.SPANNABLE);
-        }
-
-        CharSequence subtitle = getSubTitleOfGraphObject(graphObject);
-        TextView subtitleView = (TextView) view.findViewById(R.id.picker_subtitle);
-        if (subtitleView != null) {
-            if (subtitle != null) {
-                subtitleView.setText(subtitle, TextView.BufferType.SPANNABLE);
-                subtitleView.setVisibility(View.VISIBLE);
-            } else {
-                subtitleView.setVisibility(View.GONE);
-            }
-        }
-
-        if (getShowCheckbox()) {
-            CheckBox checkBox = (CheckBox) view.findViewById(R.id.com_facebook_picker_checkbox);
-            updateCheckboxState(checkBox, isGraphObjectSelected(id));
-        }
-
-        if (getShowPicture()) {
-            URL pictureURL = getPictureUrlOfGraphObject(graphObject);
-
-            if (pictureURL != null) {
-                ImageView profilePic = (ImageView) view.findViewById(R.id.com_facebook_picker_image);
-
-                // See if we have already pre-fetched this; if not, download it.
-                if (prefetchedPictureCache.containsKey(id)) {
-                    ImageResponse response = prefetchedPictureCache.get(id);
-                    profilePic.setImageBitmap(response.getBitmap());
-                    profilePic.setTag(response.getRequest().getImageUrl());
-                } else {
-                    downloadProfilePicture(id, pictureURL, profilePic);
-                }
-            }
-        }
-    }
-
-    /**
-     * @throws FacebookException if the GraphObject doesn't have an ID.
-     */
-    String getIdOfGraphObject(T graphObject) {
-        if (graphObject.asMap().containsKey(ID)) {
-            Object obj = graphObject.getProperty(ID);
-            if (obj instanceof String) {
-                return (String) obj;
-            }
-        }
-        throw new FacebookException("Received an object without an ID.");
-    }
-
-    boolean filterIncludesItem(T graphObject) {
-        return filter == null || filter.includeItem(graphObject);
-    }
-
-    Filter<T> getFilter() {
-        return filter;
-    }
-
-    void setFilter(Filter<T> filter) {
-        this.filter = filter;
-    }
-
-    boolean isGraphObjectSelected(String graphObjectId) {
-        return false;
-    }
-
-    void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
-        // Default is no-op
-    }
-
-    String getPictureFieldSpecifier() {
-        // How big is our image?
-        View view = createGraphObjectView(null, null);
-        ImageView picture = (ImageView) view.findViewById(R.id.com_facebook_picker_image);
-        if (picture == null) {
-            return null;
-        }
-
-        // Note: these dimensions are in pixels, not dips
-        ViewGroup.LayoutParams layoutParams = picture.getLayoutParams();
-        return String.format("picture.height(%d).width(%d)", layoutParams.height, layoutParams.width);
-    }
-
-
-    private boolean shouldShowActivityCircleCell() {
-        // We show the "more data" activity circle cell if we have a listener to request more data,
-        // we are expecting more data, and we have some data already (i.e., not on a fresh query).
-        return (cursor != null) && cursor.areMoreObjectsAvailable() && (dataNeededListener != null) && !isEmpty();
-    }
-
-    private void rebuildSections() {
-        sectionKeys = new ArrayList<String>();
-        graphObjectsBySection = new HashMap<String, ArrayList<T>>();
-        graphObjectsById = new HashMap<String, T>();
-        displaySections = false;
-
-        if (cursor == null || cursor.getCount() == 0) {
-            return;
-        }
-
-        int objectsAdded = 0;
-        cursor.moveToFirst();
-        do {
-            T graphObject = cursor.getGraphObject();
-
-            if (!filterIncludesItem(graphObject)) {
-                continue;
-            }
-
-            objectsAdded++;
-
-            String sectionKeyOfItem = getSectionKeyOfGraphObject(graphObject);
-            if (!graphObjectsBySection.containsKey(sectionKeyOfItem)) {
-                sectionKeys.add(sectionKeyOfItem);
-                graphObjectsBySection.put(sectionKeyOfItem, new ArrayList<T>());
-            }
-            List<T> section = graphObjectsBySection.get(sectionKeyOfItem);
-            section.add(graphObject);
-
-            graphObjectsById.put(getIdOfGraphObject(graphObject), graphObject);
-        } while (cursor.moveToNext());
-
-        if (sortFields != null) {
-            final Collator collator = Collator.getInstance();
-            for (List<T> section : graphObjectsBySection.values()) {
-                Collections.sort(section, new Comparator<GraphObject>() {
-                    @Override
-                    public int compare(GraphObject a, GraphObject b) {
-                        return compareGraphObjects(a, b, sortFields, collator);
-                    }
-                });
-            }
-        }
-
-        Collections.sort(sectionKeys, Collator.getInstance());
-
-        displaySections = sectionKeys.size() > 1 && objectsAdded > DISPLAY_SECTIONS_THRESHOLD;
-    }
-
-    SectionAndItem<T> getSectionAndItem(int position) {
-        if (sectionKeys.size() == 0) {
-            return null;
-        }
-        String sectionKey = null;
-        T graphObject = null;
-
-        if (!displaySections) {
-            sectionKey = sectionKeys.get(0);
-            List<T> section = graphObjectsBySection.get(sectionKey);
-            if (position >= 0 && position < section.size()) {
-                graphObject = graphObjectsBySection.get(sectionKey).get(position);
-            } else {
-                // We are off the end; we must be adding an activity circle to indicate more data is coming.
-                assert dataNeededListener != null && cursor.areMoreObjectsAvailable();
-                // We return null for both to indicate this.
-                return new SectionAndItem<T>(null, null);
-            }
-        } else {
-            // Count through the sections; the "0" position in each section is the header. We decrement
-            // position each time we skip forward a certain number of elements, including the header.
-            for (String key : sectionKeys) {
-                // Decrement if we skip over the header
-                if (position-- == 0) {
-                    sectionKey = key;
-                    break;
-                }
-
-                List<T> section = graphObjectsBySection.get(key);
-                if (position < section.size()) {
-                    // The position is somewhere in this section. Get the corresponding graph object.
-                    sectionKey = key;
-                    graphObject = section.get(position);
-                    break;
-                }
-                // Decrement by as many items as we skipped over
-                position -= section.size();
-            }
-        }
-        if (sectionKey != null) {
-            // Note: graphObject will be null if this represents a section header.
-            return new SectionAndItem<T>(sectionKey, graphObject);
-        } else {
-            throw new IndexOutOfBoundsException("position");
-        }
-    }
-
-    int getPosition(String sectionKey, T graphObject) {
-        int position = 0;
-        boolean found = false;
-
-        // First find the section key and increment position one for each header we will render;
-        // increment by the size of each section prior to the one we want.
-        for (String key : sectionKeys) {
-            if (displaySections) {
-                position++;
-            }
-            if (key.equals(sectionKey)) {
-                found = true;
-                break;
-            } else {
-                position += graphObjectsBySection.get(key).size();
-            }
-        }
-
-        if (!found) {
-            return -1;
-        } else if (graphObject == null) {
-            // null represents the header for a section; we counted this header in position earlier,
-            // so subtract it back out.
-            return position - (displaySections ? 1 : 0);
-        }
-
-        // Now find index of this item within that section.
-        for (T t : graphObjectsBySection.get(sectionKey)) {
-            if (GraphObject.Factory.hasSameId(t, graphObject)) {
-                return position;
-            }
-            position++;
-        }
-        return -1;
-    }
-
-    @Override
-    public boolean isEmpty() {
-        // We'll never populate sectionKeys unless we have at least one object.
-        return sectionKeys.size() == 0;
-    }
-
-    @Override
-    public int getCount() {
-        if (sectionKeys.size() == 0) {
-            return 0;
-        }
-
-        // If we are not displaying sections, we don't display a header; otherwise, we have one header per item in
-        // addition to the actual items.
-        int count = (displaySections) ? sectionKeys.size() : 0;
-        for (List<T> section : graphObjectsBySection.values()) {
-            count += section.size();
-        }
-
-        // If we should show a cell with an activity circle indicating more data is coming, add it to the count.
-        if (shouldShowActivityCircleCell()) {
-            ++count;
-        }
-
-        return count;
-    }
-
-    @Override
-    public boolean areAllItemsEnabled() {
-        return displaySections;
-    }
-
-    @Override
-    public boolean hasStableIds() {
-        return true;
-    }
-
-    @Override
-    public boolean isEnabled(int position) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
-        return sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT;
-    }
-
-    @Override
-    public Object getItem(int position) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
-        return (sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT) ? sectionAndItem.graphObject : null;
-    }
-
-    @Override
-    public long getItemId(int position) {
-        // We assume IDs that can be converted to longs. If this is not the case for certain types of
-        // GraphObjects, subclasses should override this to return, e.g., position, and override hasStableIds
-        // to return false.
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
-        if (sectionAndItem != null && sectionAndItem.graphObject != null) {
-            String id = getIdOfGraphObject(sectionAndItem.graphObject);
-            if (id != null) {
-                return Long.parseLong(id);
-            }
-        }
-        return 0;
-    }
-
-    @Override
-    public int getViewTypeCount() {
-        return 3;
-    }
-
-    @Override
-    public int getItemViewType(int position) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
-        switch (sectionAndItem.getType()) {
-            case SECTION_HEADER:
-                return HEADER_VIEW_TYPE;
-            case GRAPH_OBJECT:
-                return GRAPH_OBJECT_VIEW_TYPE;
-            case ACTIVITY_CIRCLE:
-                return ACTIVITY_CIRCLE_VIEW_TYPE;
-            default:
-                throw new FacebookException("Unexpected type of section and item.");
-        }
-    }
-
-    @Override
-    public View getView(int position, View convertView, ViewGroup parent) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
-
-        switch (sectionAndItem.getType()) {
-            case SECTION_HEADER:
-                return getSectionHeaderView(sectionAndItem.sectionKey, convertView, parent);
-            case GRAPH_OBJECT:
-                return getGraphObjectView(sectionAndItem.graphObject, convertView, parent);
-            case ACTIVITY_CIRCLE:
-                // If we get a request for this view, it means we need more data.
-                assert cursor.areMoreObjectsAvailable() && (dataNeededListener != null);
-                dataNeededListener.onDataNeeded();
-                return getActivityCircleView(convertView, parent);
-            default:
-                throw new FacebookException("Unexpected type of section and item.");
-        }
-    }
-
-    @Override
-    public Object[] getSections() {
-        if (displaySections) {
-            return sectionKeys.toArray();
-        } else {
-            return new Object[0];
-        }
-    }
-
-    @Override
-    public int getPositionForSection(int section) {
-        if (displaySections) {
-            section = Math.max(0, Math.min(section, sectionKeys.size() - 1));
-            if (section < sectionKeys.size()) {
-                return getPosition(sectionKeys.get(section), null);
-            }
-        }
-        return 0;
-    }
-
-    @Override
-    public int getSectionForPosition(int position) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
-        if (sectionAndItem != null &&
-                sectionAndItem.getType() != SectionAndItem.Type.ACTIVITY_CIRCLE) {
-            return Math.max(0, Math.min(sectionKeys.indexOf(sectionAndItem.sectionKey), sectionKeys.size() - 1));
-        }
-        return 0;
-    }
-
-    public List<T> getGraphObjectsById(Collection<String> ids) {
-        Set<String> idSet = new HashSet<String>();
-        idSet.addAll(ids);
-
-        ArrayList<T> result = new ArrayList<T>(idSet.size());
-        for (String id : idSet) {
-            T graphObject = graphObjectsById.get(id);
-            if (graphObject != null) {
-                result.add(graphObject);
-            }
-        }
-
-        return result;
-    }
-
-    private void downloadProfilePicture(final String profileId, URL pictureURL, final ImageView imageView) {
-        if (pictureURL == null) {
-            return;
-        }
-
-        // If we don't have an imageView, we are pre-fetching this image to store in-memory because we
-        // think the user might scroll to its corresponding list row. If we do have an imageView, we
-        // only want to queue a download if the view's tag isn't already set to the URL (which would mean
-        // it's already got the correct picture).
-        boolean prefetching = imageView == null;
-        if (prefetching || !pictureURL.equals(imageView.getTag())) {
-            if (!prefetching) {
-                // Setting the tag to the profile ID indicates that we're currently downloading the
-                // picture for this profile; we'll set it to the actual picture URL when complete.
-                imageView.setTag(profileId);
-                imageView.setImageResource(getDefaultPicture());
-            }
-
-            ImageRequest.Builder builder = new ImageRequest.Builder(context.getApplicationContext(), pictureURL)
-                    .setCallerTag(this)
-                    .setCallback(
-                            new ImageRequest.Callback() {
-                                @Override
-                                public void onCompleted(ImageResponse response) {
-                                    processImageResponse(response, profileId, imageView);
-                                }
-                            });
-
-            ImageRequest newRequest = builder.build();
-            pendingRequests.put(profileId, newRequest);
-
-            ImageDownloader.downloadAsync(newRequest);
-        }
-    }
-
-    private void callOnErrorListener(Exception exception) {
-        if (onErrorListener != null) {
-            if (!(exception instanceof FacebookException)) {
-                exception = new FacebookException(exception);
-            }
-            onErrorListener.onError(this, (FacebookException) exception);
-        }
-    }
-
-    private void processImageResponse(ImageResponse response, String graphObjectId, ImageView imageView) {
-        pendingRequests.remove(graphObjectId);
-        if (response.getError() != null) {
-            callOnErrorListener(response.getError());
-        }
-
-        if (imageView == null) {
-            // This was a pre-fetch request.
-            if (response.getBitmap() != null) {
-                // Is the cache too big?
-                if (prefetchedPictureCache.size() >= MAX_PREFETCHED_PICTURES) {
-                    // Find the oldest one and remove it.
-                    String oldestId = prefetchedProfilePictureIds.remove(0);
-                    prefetchedPictureCache.remove(oldestId);
-                }
-                prefetchedPictureCache.put(graphObjectId, response);
-            }
-        } else if (imageView != null && graphObjectId.equals(imageView.getTag())) {
-            Exception error = response.getError();
-            Bitmap bitmap = response.getBitmap();
-            if (error == null && bitmap != null) {
-                imageView.setImageBitmap(bitmap);
-                imageView.setTag(response.getRequest().getImageUrl());
-            }
-        }
-    }
-
-    private static int compareGraphObjects(GraphObject a, GraphObject b, Collection<String> sortFields,
-            Collator collator) {
-        for (String sortField : sortFields) {
-            String sa = (String) a.getProperty(sortField);
-            String sb = (String) b.getProperty(sortField);
-
-            if (sa != null && sb != null) {
-                int result = collator.compare(sa, sb);
-                if (result != 0) {
-                    return result;
-                }
-            } else if (!(sa == null && sb == null)) {
-                return (sa == null) ? -1 : 1;
-            }
-        }
-        return 0;
-    }
-
-
-    // Graph object type to navigate the JSON that sometimes comes back instead of a URL string
-    private interface ItemPicture extends GraphObject {
-        ItemPictureData getData();
-    }
-
-    // Graph object type to navigate the JSON that sometimes comes back instead of a URL string
-    private interface ItemPictureData extends GraphObject {
-        String getUrl();
-    }
-}
diff --git a/facebook/src/com/facebook/widget/GraphObjectCursor.java b/facebook/src/com/facebook/widget/GraphObjectCursor.java
deleted file mode 100644
index 9495535e0..000000000
--- a/facebook/src/com/facebook/widget/GraphObjectCursor.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import com.facebook.model.GraphObject;
-
-interface GraphObjectCursor<T extends GraphObject> {
-    boolean isFromCache();
-
-    boolean areMoreObjectsAvailable();
-
-    int getCount();
-
-    int getPosition();
-
-    boolean move(int offset);
-
-    boolean moveToPosition(int position);
-
-    boolean moveToFirst();
-
-    boolean moveToLast();
-
-    boolean moveToNext();
-
-    boolean moveToPrevious();
-
-    boolean isFirst();
-
-    boolean isLast();
-
-    boolean isBeforeFirst();
-
-    boolean isAfterLast();
-
-    T getGraphObject();
-
-    void close();
-
-    boolean isClosed();
-}
diff --git a/facebook/src/com/facebook/widget/GraphObjectPagingLoader.java b/facebook/src/com/facebook/widget/GraphObjectPagingLoader.java
deleted file mode 100644
index 26b33c99d..000000000
--- a/facebook/src/com/facebook/widget/GraphObjectPagingLoader.java
+++ /dev/null
@@ -1,226 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.content.Context;
-import android.os.Handler;
-import android.support.v4.content.Loader;
-import com.facebook.*;
-import com.facebook.model.GraphObject;
-import com.facebook.model.GraphObjectList;
-import com.facebook.internal.CacheableRequestBatch;
-
-class GraphObjectPagingLoader<T extends GraphObject> extends Loader<SimpleGraphObjectCursor<T>> {
-    private final Class<T> graphObjectClass;
-    private boolean skipRoundtripIfCached;
-    private Request originalRequest;
-    private Request currentRequest;
-    private Request nextRequest;
-    private OnErrorListener onErrorListener;
-    private SimpleGraphObjectCursor<T> cursor;
-    private boolean appendResults = false;
-    private boolean loading = false;
-
-    public interface OnErrorListener {
-        public void onError(FacebookException error, GraphObjectPagingLoader<?> loader);
-    }
-
-    public GraphObjectPagingLoader(Context context, Class<T> graphObjectClass) {
-        super(context);
-
-        this.graphObjectClass = graphObjectClass;
-    }
-
-    public OnErrorListener getOnErrorListener() {
-        return onErrorListener;
-    }
-
-    public void setOnErrorListener(OnErrorListener listener) {
-        this.onErrorListener = listener;
-    }
-
-    public SimpleGraphObjectCursor<T> getCursor() {
-        return cursor;
-    }
-
-    public void clearResults() {
-        nextRequest = null;
-        originalRequest = null;
-        currentRequest = null;
-
-        deliverResult(null);
-    }
-
-    public boolean isLoading() {
-        return loading;
-    }
-
-    public void startLoading(Request request, boolean skipRoundtripIfCached) {
-        originalRequest = request;
-        startLoading(request, skipRoundtripIfCached, 0);
-    }
-
-    public void refreshOriginalRequest(long afterDelay) {
-        if (originalRequest == null) {
-            throw new FacebookException(
-                    "refreshOriginalRequest may not be called until after startLoading has been called.");
-        }
-        startLoading(originalRequest, false, afterDelay);
-    }
-
-    public void followNextLink() {
-        if (nextRequest != null) {
-            appendResults = true;
-            currentRequest = nextRequest;
-
-            currentRequest.setCallback(new Request.Callback() {
-                @Override
-                public void onCompleted(Response response) {
-                    requestCompleted(response);
-                }
-            });
-
-            loading = true;
-            CacheableRequestBatch batch = putRequestIntoBatch(currentRequest, skipRoundtripIfCached);
-            Request.executeBatchAsync(batch);
-        }
-    }
-
-    @Override
-    public void deliverResult(SimpleGraphObjectCursor<T> cursor) {
-        SimpleGraphObjectCursor<T> oldCursor = this.cursor;
-        this.cursor = cursor;
-
-        if (isStarted()) {
-            super.deliverResult(cursor);
-
-            if (oldCursor != null && oldCursor != cursor && !oldCursor.isClosed()) {
-                oldCursor.close();
-            }
-        }
-    }
-
-    @Override
-    protected void onStartLoading() {
-        super.onStartLoading();
-
-        if (cursor != null) {
-            deliverResult(cursor);
-        }
-    }
-
-    private void startLoading(Request request, boolean skipRoundtripIfCached, long afterDelay) {
-        this.skipRoundtripIfCached = skipRoundtripIfCached;
-        appendResults = false;
-        nextRequest = null;
-        currentRequest = request;
-        currentRequest.setCallback(new Request.Callback() {
-            @Override
-            public void onCompleted(Response response) {
-                requestCompleted(response);
-            }
-        });
-
-        // We are considered loading even if we have a delay.
-        loading = true;
-
-        final RequestBatch batch = putRequestIntoBatch(request, skipRoundtripIfCached);
-        Runnable r = new Runnable() {
-            @Override
-            public void run() {
-                Request.executeBatchAsync(batch);
-            }
-        };
-        if (afterDelay == 0) {
-            r.run();
-        } else {
-            Handler handler = new Handler();
-            handler.postDelayed(r, afterDelay);
-        }
-    }
-
-    private CacheableRequestBatch putRequestIntoBatch(Request request, boolean skipRoundtripIfCached) {
-        // We just use the request URL as the cache key.
-        CacheableRequestBatch batch = new CacheableRequestBatch(request);
-        // We use the default cache key (request URL).
-        batch.setForceRoundTrip(!skipRoundtripIfCached);
-        return batch;
-    }
-
-    private void requestCompleted(Response response) {
-        Request request = response.getRequest();
-        if (request != currentRequest) {
-            return;
-        }
-
-        loading = false;
-        currentRequest = null;
-
-        FacebookRequestError requestError = response.getError();
-        FacebookException exception = (requestError == null) ? null : requestError.getException();
-        if (response.getGraphObject() == null && exception == null) {
-            exception = new FacebookException("GraphObjectPagingLoader received neither a result nor an error.");
-        }
-
-        if (exception != null) {
-            nextRequest = null;
-
-            if (onErrorListener != null) {
-                onErrorListener.onError(exception, this);
-            }
-        } else {
-            addResults(response);
-        }
-    }
-
-    private void addResults(Response response) {
-        SimpleGraphObjectCursor<T> cursorToModify = (cursor == null || !appendResults) ? new SimpleGraphObjectCursor<T>() :
-                new SimpleGraphObjectCursor<T>(cursor);
-
-        PagedResults result = response.getGraphObjectAs(PagedResults.class);
-        boolean fromCache = response.getIsFromCache();
-
-        GraphObjectList<T> data = result.getData().castToListOf(graphObjectClass);
-        boolean haveData = data.size() > 0;
-
-        if (haveData) {
-            nextRequest = response.getRequestForPagedResults(Response.PagingDirection.NEXT);
-
-            cursorToModify.addGraphObjects(data, fromCache);
-            cursorToModify.setMoreObjectsAvailable(true);
-        }
-
-        if (!haveData) {
-            cursorToModify.setMoreObjectsAvailable(false);
-            cursorToModify.setFromCache(fromCache);
-
-            nextRequest = null;
-        }
-
-        // Once we get any set of results NOT from the cache, stop trying to get any future ones
-        // from it.
-        if (!fromCache) {
-            skipRoundtripIfCached = false;
-        }
-
-        deliverResult(cursorToModify);
-    }
-
-    interface PagedResults extends GraphObject {
-        GraphObjectList<GraphObject> getData();
-    }
-}
diff --git a/facebook/src/com/facebook/widget/ImageDownloader.java b/facebook/src/com/facebook/widget/ImageDownloader.java
deleted file mode 100644
index 6fef68043..000000000
--- a/facebook/src/com/facebook/widget/ImageDownloader.java
+++ /dev/null
@@ -1,343 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.os.Handler;
-import com.facebook.FacebookException;
-import com.facebook.internal.Utility;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.*;
-
-class ImageDownloader {
-    private static final int DOWNLOAD_QUEUE_MAX_CONCURRENT = WorkQueue.DEFAULT_MAX_CONCURRENT;
-    private static final int CACHE_READ_QUEUE_MAX_CONCURRENT = 2;
-    private static final Handler handler = new Handler();
-    private static WorkQueue downloadQueue = new WorkQueue(DOWNLOAD_QUEUE_MAX_CONCURRENT);
-    private static WorkQueue cacheReadQueue = new WorkQueue(CACHE_READ_QUEUE_MAX_CONCURRENT);
-
-    private static final Map<RequestKey, DownloaderContext> pendingRequests = new HashMap<RequestKey, DownloaderContext>();
-
-    /**
-     * Downloads the image specified in the passed in request.
-     * If a callback is specified, it is guaranteed to be invoked on the calling thread.
-     * @param request Request to process
-     */
-    static void downloadAsync(ImageRequest request) {
-        if (request == null) {
-            return;
-        }
-
-        // NOTE: This is the ONLY place where the original request's Url is read. From here on,
-        // we will keep track of the Url separately. This is because we might be dealing with a
-        // redirect response and the Url might change. We can't create our own new ImageRequests
-        // for these changed Urls since the caller might be doing some book-keeping with the request's
-        // object reference. So we keep the old references and just map them to new urls in the downloader
-        RequestKey key = new RequestKey(request.getImageUrl(), request.getCallerTag());
-        synchronized (pendingRequests) {
-            DownloaderContext downloaderContext = pendingRequests.get(key);
-            if (downloaderContext != null) {
-                downloaderContext.request = request;
-                downloaderContext.isCancelled = false;
-                downloaderContext.workItem.moveToFront();
-            } else {
-                enqueueCacheRead(request, key, request.isCachedRedirectAllowed());
-            }
-        }
-    }
-
-    static boolean cancelRequest(ImageRequest request) {
-        boolean cancelled = false;
-        RequestKey key = new RequestKey(request.getImageUrl(), request.getCallerTag());
-        synchronized (pendingRequests) {
-            DownloaderContext downloaderContext = pendingRequests.get(key);
-            if (downloaderContext != null) {
-                // If we were able to find the request in our list of pending requests, then we will
-                // definitely be able to prevent an ImageResponse from being issued. This is regardless
-                // of whether a cache-read or network-download is underway for this request.
-                cancelled = true;
-
-                if (downloaderContext.workItem.cancel()) {
-                    pendingRequests.remove(key);
-                } else {
-                    // May be attempting a cache-read right now. So keep track of the cancellation
-                    // to prevent network calls etc
-                    downloaderContext.isCancelled = true;
-                }
-            }
-        }
-
-        return cancelled;
-    }
-
-    static void prioritizeRequest(ImageRequest request) {
-        RequestKey key = new RequestKey(request.getImageUrl(), request.getCallerTag());
-        synchronized (pendingRequests) {
-            DownloaderContext downloaderContext = pendingRequests.get(key);
-            if (downloaderContext != null) {
-                downloaderContext.workItem.moveToFront();
-            }
-        }
-    }
-
-    private static void enqueueCacheRead(ImageRequest request, RequestKey key, boolean allowCachedRedirects) {
-        enqueueRequest(
-                request,
-                key,
-                cacheReadQueue,
-                new CacheReadWorkItem(request.getContext(), key, allowCachedRedirects));
-    }
-
-    private static void enqueueDownload(ImageRequest request, RequestKey key) {
-        enqueueRequest(
-                request,
-                key,
-                downloadQueue,
-                new DownloadImageWorkItem(request.getContext(), key));
-    }
-
-    private static void enqueueRequest(
-            ImageRequest request,
-            RequestKey key,
-            WorkQueue workQueue,
-            Runnable workItem) {
-        synchronized (pendingRequests) {
-            DownloaderContext downloaderContext = new DownloaderContext();
-            downloaderContext.request = request;
-            pendingRequests.put(key, downloaderContext);
-
-            // The creation of the WorkItem should be done after the pending request has been registered.
-            // This is necessary since the WorkItem might kick off right away and attempt to retrieve
-            // the request's DownloaderContext prior to it being ready for access.
-            //
-            // It is also necessary to hold on to the lock until after the workItem is created, since
-            // calls to cancelRequest or prioritizeRequest might come in and expect a registered
-            // request to have a workItem available as well.
-            downloaderContext.workItem = workQueue.addActiveWorkItem(workItem);
-        }
-    }
-
-    private static void issueResponse(
-            RequestKey key,
-            final Exception error,
-            final Bitmap bitmap,
-            final boolean isCachedRedirect) {
-        // Once the old downloader context is removed, we are thread-safe since this is the
-        // only reference to it
-        DownloaderContext completedRequestContext = removePendingRequest(key);
-        if (completedRequestContext != null && !completedRequestContext.isCancelled) {
-            final ImageRequest request = completedRequestContext.request;
-            final ImageRequest.Callback callback = request.getCallback();
-            if (callback != null) {
-                handler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        ImageResponse response = new ImageResponse(
-                                request,
-                                error,
-                                isCachedRedirect,
-                                bitmap);
-                        callback.onCompleted(response);
-                    }
-                });
-            }
-        }
-    }
-
-    private static void readFromCache(RequestKey key, Context context, boolean allowCachedRedirects) {
-        InputStream cachedStream = null;
-        boolean isCachedRedirect = false;
-        if (allowCachedRedirects) {
-            URL redirectUrl = UrlRedirectCache.getRedirectedUrl(context, key.url);
-            if (redirectUrl != null) {
-                cachedStream = ImageResponseCache.getCachedImageStream(redirectUrl, context);
-                isCachedRedirect = cachedStream != null;
-            }
-        }
-
-        if (!isCachedRedirect) {
-            cachedStream = ImageResponseCache.getCachedImageStream(key.url, context);
-        }
-
-        if (cachedStream != null) {
-            // We were able to find a cached image.
-            Bitmap bitmap = BitmapFactory.decodeStream(cachedStream);
-            Utility.closeQuietly(cachedStream);
-            issueResponse(key, null, bitmap, isCachedRedirect);
-        } else {
-            // Once the old downloader context is removed, we are thread-safe since this is the
-            // only reference to it
-            DownloaderContext downloaderContext = removePendingRequest(key);
-            if (downloaderContext != null && !downloaderContext.isCancelled) {
-                enqueueDownload(downloaderContext.request, key);
-            }
-        }
-    }
-
-    private static void download(RequestKey key, Context context) {
-        HttpURLConnection connection = null;
-        InputStream stream = null;
-        Exception error = null;
-        Bitmap bitmap = null;
-        boolean issueResponse = true;
-
-        try {
-            connection = (HttpURLConnection) key.url.openConnection();
-            connection.setInstanceFollowRedirects(false);
-
-            switch (connection.getResponseCode()) {
-                case HttpURLConnection.HTTP_MOVED_PERM:
-                case HttpURLConnection.HTTP_MOVED_TEMP:
-                    // redirect. So we need to perform further requests
-                    issueResponse = false;
-
-                    String redirectLocation = connection.getHeaderField("location");
-                    if (!Utility.isNullOrEmpty(redirectLocation)) {
-                        URL redirectUrl = new URL(redirectLocation);
-                        UrlRedirectCache.cacheUrlRedirect(context, key.url, redirectUrl);
-
-                        // Once the old downloader context is removed, we are thread-safe since this is the
-                        // only reference to it
-                        DownloaderContext downloaderContext = removePendingRequest(key);
-                        if (downloaderContext != null && !downloaderContext.isCancelled) {
-                            enqueueCacheRead(
-                                    downloaderContext.request,
-                                    new RequestKey(redirectUrl, key.tag),
-                                    false);
-                        }
-                    }
-                    break;
-
-                case HttpURLConnection.HTTP_OK:
-                    // image should be available
-                    stream = ImageResponseCache.interceptAndCacheImageStream(context, connection);
-                    bitmap = BitmapFactory.decodeStream(stream);
-                    break;
-
-                default:
-                    stream = connection.getErrorStream();
-                    InputStreamReader reader = new InputStreamReader(stream);
-                    char[] buffer = new char[128];
-                    int bufferLength;
-                    StringBuilder errorMessageBuilder = new StringBuilder();
-                    while ((bufferLength = reader.read(buffer, 0, buffer.length)) > 0) {
-                        errorMessageBuilder.append(buffer, 0, bufferLength);
-                    }
-                    Utility.closeQuietly(reader);
-
-                    error = new FacebookException(errorMessageBuilder.toString());
-                    break;
-            }
-        } catch (IOException e) {
-            error = e;
-        } finally {
-            Utility.closeQuietly(stream);
-            Utility.disconnectQuietly(connection);
-        }
-
-        if (issueResponse) {
-            issueResponse(key, error, bitmap, false);
-        }
-    }
-
-    private static DownloaderContext removePendingRequest(RequestKey key) {
-        synchronized (pendingRequests) {
-            return pendingRequests.remove(key);
-        }
-    }
-
-    private static class RequestKey {
-        private static final int HASH_SEED = 29; // Some random prime number
-        private static final int HASH_MULTIPLIER = 37; // Some random prime number
-
-        URL url;
-        Object tag;
-
-        RequestKey(URL url, Object tag) {
-            this.url = url;
-            this.tag = tag;
-        }
-
-        @Override
-        public int hashCode() {
-            int result = HASH_SEED;
-
-            result = (result * HASH_MULTIPLIER) + url.hashCode();
-            result = (result * HASH_MULTIPLIER) + tag.hashCode();
-
-            return result;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            boolean isEqual = false;
-
-            if (o != null && o instanceof RequestKey) {
-                RequestKey compareTo = (RequestKey)o;
-                isEqual = compareTo.url == url && compareTo.tag == tag;
-            }
-
-            return isEqual;
-        }
-    }
-
-    private static class DownloaderContext {
-        WorkQueue.WorkItem workItem;
-        ImageRequest request;
-        boolean isCancelled;
-    }
-
-    private static class CacheReadWorkItem implements Runnable {
-        private Context context;
-        private RequestKey key;
-        private boolean allowCachedRedirects;
-
-        CacheReadWorkItem(Context context, RequestKey key, boolean allowCachedRedirects) {
-            this.context = context;
-            this.key = key;
-            this.allowCachedRedirects = allowCachedRedirects;
-        }
-
-        @Override
-        public void run() {
-            readFromCache(key, context, allowCachedRedirects);
-        }
-    }
-
-    private static class DownloadImageWorkItem implements Runnable {
-        private Context context;
-        private RequestKey key;
-
-        DownloadImageWorkItem(Context context, RequestKey key) {
-            this.context = context;
-            this.key = key;
-        }
-
-        @Override
-        public void run() {
-            download(key, context);
-        }
-
-    }
-}
diff --git a/facebook/src/com/facebook/widget/ImageRequest.java b/facebook/src/com/facebook/widget/ImageRequest.java
deleted file mode 100644
index 5c45ff723..000000000
--- a/facebook/src/com/facebook/widget/ImageRequest.java
+++ /dev/null
@@ -1,145 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.content.Context;
-import android.net.Uri;
-import com.facebook.internal.Validate;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-
-class ImageRequest {
-
-    interface Callback {
-        /**
-         * This method should always be called on the UI thread. ImageDownloader makes
-         * sure to do this when it is responsible for issuing the ImageResponse
-         * @param response
-         */
-        void onCompleted(ImageResponse response);
-    }
-
-    static final int UNSPECIFIED_DIMENSION = 0;
-
-    private static final String PROFILEPIC_URL_FORMAT =
-            "https://graph.facebook.com/%s/picture";
-    private static final String HEIGHT_PARAM = "height";
-    private static final String WIDTH_PARAM = "width";
-    private static final String MIGRATION_PARAM = "migration_overrides";
-    private static final String MIGRATION_VALUE = "{october_2012:true}";
-
-    private Context context;
-    private URL imageUrl;
-    private Callback callback;
-    private boolean allowCachedRedirects;
-    private Object callerTag;
-
-    static URL getProfilePictureUrl(
-            String userId,
-            int width,
-            int height)
-        throws MalformedURLException {
-
-        Validate.notNullOrEmpty(userId, "userId");
-
-        width = Math.max(width, UNSPECIFIED_DIMENSION);
-        height = Math.max(height, UNSPECIFIED_DIMENSION);
-
-        if (width == UNSPECIFIED_DIMENSION && height == UNSPECIFIED_DIMENSION) {
-            throw new IllegalArgumentException("Either width or height must be greater than 0");
-        }
-
-        Uri.Builder builder = new Uri.Builder().encodedPath(String.format(PROFILEPIC_URL_FORMAT, userId));
-
-        if (height != UNSPECIFIED_DIMENSION) {
-            builder.appendQueryParameter(HEIGHT_PARAM, String.valueOf(height));
-        }
-
-        if (width != UNSPECIFIED_DIMENSION) {
-            builder.appendQueryParameter(WIDTH_PARAM, String.valueOf(width));
-        }
-
-        builder.appendQueryParameter(MIGRATION_PARAM, MIGRATION_VALUE);
-
-        return new URL(builder.toString());
-    }
-
-    private ImageRequest(Builder builder) {
-        this.context = builder.context;
-        this.imageUrl = builder.imageUrl;
-        this.callback = builder.callback;
-        this.allowCachedRedirects = builder.allowCachedRedirects;
-        this.callerTag = builder.callerTag == null ? new Object() : builder.callerTag;
-    }
-
-    Context getContext() {
-        return context;
-    }
-
-    URL getImageUrl() {
-        return imageUrl;
-    }
-
-    Callback getCallback() {
-        return callback;
-    }
-
-    boolean isCachedRedirectAllowed() {
-        return allowCachedRedirects;
-    }
-
-    Object getCallerTag() {
-        return callerTag;
-    }
-
-    static class Builder {
-        // Required
-        private Context context;
-        private URL imageUrl;
-
-        // Optional
-        private Callback callback;
-        private boolean allowCachedRedirects;
-        private Object callerTag;
-
-        Builder(Context context, URL imageUrl) {
-            Validate.notNull(imageUrl, "imageUrl");
-            this.context = context;
-            this.imageUrl = imageUrl;
-        }
-
-        Builder setCallback(Callback callback) {
-            this.callback = callback;
-            return this;
-        }
-
-        Builder setCallerTag(Object callerTag) {
-            this.callerTag = callerTag;
-            return this;
-        }
-
-        Builder setAllowCachedRedirects(boolean allowCachedRedirects) {
-            this.allowCachedRedirects = allowCachedRedirects;
-            return this;
-        }
-
-        ImageRequest build() {
-            return new ImageRequest(this);
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/widget/ImageResponse.java b/facebook/src/com/facebook/widget/ImageResponse.java
deleted file mode 100644
index ae47eec9d..000000000
--- a/facebook/src/com/facebook/widget/ImageResponse.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.graphics.Bitmap;
-
-class ImageResponse {
-
-    private ImageRequest request;
-    private Exception error;
-    private boolean isCachedRedirect;
-    private Bitmap bitmap;
-
-    ImageResponse(ImageRequest request, Exception error, boolean isCachedRedirect, Bitmap bitmap) {
-        this.request = request;
-        this.error = error;
-        this.bitmap = bitmap;
-        this.isCachedRedirect = isCachedRedirect;
-    }
-
-    ImageRequest getRequest() {
-        return request;
-    }
-
-    Exception getError() {
-        return error;
-    }
-
-    Bitmap getBitmap() {
-        return bitmap;
-    }
-
-    boolean isCachedRedirect() {
-        return isCachedRedirect;
-    }
-}
diff --git a/facebook/src/com/facebook/widget/ImageResponseCache.java b/facebook/src/com/facebook/widget/ImageResponseCache.java
deleted file mode 100644
index 53b8d824f..000000000
--- a/facebook/src/com/facebook/widget/ImageResponseCache.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.content.Context;
-import android.util.Log;
-import com.facebook.internal.Logger;
-import com.facebook.LoggingBehavior;
-import com.facebook.internal.Utility;
-import com.facebook.internal.FileLruCache;
-
-import java.io.BufferedInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-
-class ImageResponseCache {
-    static final String TAG = ImageResponseCache.class.getSimpleName();
-
-    private volatile static FileLruCache imageCache;
-
-    synchronized static FileLruCache getCache(Context context) throws IOException{
-        if (imageCache == null) {
-            imageCache = new FileLruCache(context.getApplicationContext(), TAG, new FileLruCache.Limits());
-        }
-        return imageCache;
-    }
-
-    // Get stream from cache, or return null if the image is not cached.
-    // Does not throw if there was an error.
-    static InputStream getCachedImageStream(URL url, Context context) {
-        InputStream imageStream = null;
-        if (url != null) {
-            if (isCDNURL(url)) {
-                try {
-                    FileLruCache cache = getCache(context);
-                    imageStream = cache.get(url.toString());
-                } catch (IOException e) {
-                    Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, e.toString());
-                }
-            }
-        }
-
-        return imageStream;
-    }
-
-    static InputStream interceptAndCacheImageStream(Context context, HttpURLConnection connection) throws IOException {
-        InputStream stream = null;
-        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
-            URL url = connection.getURL();
-            stream = connection.getInputStream(); // Default stream in case caching fails
-            if (isCDNURL(url)) {
-                try {
-                    FileLruCache cache = getCache(context);
-
-                    // Wrap stream with a caching stream
-                    stream = cache.interceptAndPut(
-                            url.toString(),
-                            new BufferedHttpInputStream(stream, connection));
-                } catch (IOException e) {
-                    // Caching is best effort
-                }
-            }
-        }
-        return stream;
-    }
-
-   private static boolean isCDNURL(URL url) {
-        if (url != null) {
-            String uriHost = url.getHost();
-
-            if (uriHost.endsWith("fbcdn.net")) {
-                return true;
-            }
-
-            if (uriHost.startsWith("fbcdn") && uriHost.endsWith("akamaihd.net")) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    private static class BufferedHttpInputStream extends BufferedInputStream {
-        HttpURLConnection connection;
-        BufferedHttpInputStream(InputStream stream, HttpURLConnection connection) {
-            super(stream, Utility.DEFAULT_STREAM_BUFFER_SIZE);
-            this.connection = connection;
-        }
-
-        @Override
-        public void close() throws IOException {
-            super.close();
-            Utility.disconnectQuietly(connection);
-        }
-    }
-}
-
diff --git a/facebook/src/com/facebook/widget/LoginButton.java b/facebook/src/com/facebook/widget/LoginButton.java
deleted file mode 100644
index 0000687ce..000000000
--- a/facebook/src/com/facebook/widget/LoginButton.java
+++ /dev/null
@@ -1,593 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.res.TypedArray;
-import android.support.v4.app.Fragment;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.util.TypedValue;
-import android.view.Gravity;
-import android.view.View;
-import android.widget.Button;
-import android.widget.CompoundButton;
-import android.widget.Switch;
-
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.model.GraphUser;
-import com.facebook.internal.SessionAuthorizationType;
-import com.facebook.internal.SessionTracker;
-import com.facebook.internal.Utility;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * A Log In/Log Out button that maintains session state and logs
- * in/out for the app.
- * <p/>
- * This control will create and use the active session upon construction
- * if it has the available data (if the app ID is specified in the manifest).
- * It will also open the active session if it does not require user interaction
- * (i.e. if the session is in the {@link com.facebook.SessionState#CREATED_TOKEN_LOADED} state.
- * Developers can override the use of the active session by calling
- * the {@link #setSession(com.facebook.Session)} method.
- */
-public class LoginButton extends Switch {
-
-    private static final String TAG = LoginButton.class.getName();
-    private String applicationId = null;
-    private SessionTracker sessionTracker;
-    private UserInfoChangedCallback userInfoChangedCallback;
-    private Fragment parentFragment;
-    private LoginButtonProperties properties = new LoginButtonProperties();
-    private boolean isParentChecked = true;
-
-    static class LoginButtonProperties {
-        private SessionDefaultAudience defaultAudience = SessionDefaultAudience.FRIENDS;
-        private List<String> permissions = new ArrayList<String>();
-        private SessionAuthorizationType authorizationType = null;
-        private OnErrorListener onErrorListener;
-        private SessionLoginBehavior loginBehavior = SessionLoginBehavior.SSO_WITH_FALLBACK;
-        private Session.StatusCallback sessionStatusCallback;
-
-        public void setOnErrorListener(OnErrorListener onErrorListener) {
-            this.onErrorListener = onErrorListener;
-        }
-
-        public OnErrorListener getOnErrorListener() {
-            return onErrorListener;
-        }
-
-        public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
-            this.defaultAudience = defaultAudience;
-        }
-
-        public SessionDefaultAudience getDefaultAudience() {
-            return defaultAudience;
-        }
-
-        public void setReadPermissions(List<String> permissions, Session session) {
-            if (SessionAuthorizationType.PUBLISH.equals(authorizationType)) {
-                throw new UnsupportedOperationException(
-                        "Cannot call setReadPermissions after setPublishPermissions has been called.");
-            }
-            if (validatePermissions(permissions, SessionAuthorizationType.READ, session)) {
-                this.permissions = permissions;
-                authorizationType = SessionAuthorizationType.READ;
-            }
-        }
-
-        public void setPublishPermissions(List<String> permissions, Session session) {
-            if (SessionAuthorizationType.READ.equals(authorizationType)) {
-                throw new UnsupportedOperationException(
-                        "Cannot call setPublishPermissions after setReadPermissions has been called.");
-            }
-            if (validatePermissions(permissions, SessionAuthorizationType.PUBLISH, session)) {
-                this.permissions = permissions;
-                authorizationType = SessionAuthorizationType.PUBLISH;
-            }
-        }
-
-        private boolean validatePermissions(List<String> permissions,
-                SessionAuthorizationType authType, Session currentSession) {
-            if (SessionAuthorizationType.PUBLISH.equals(authType)) {
-                if (Utility.isNullOrEmpty(permissions)) {
-                    throw new IllegalArgumentException("Permissions for publish actions cannot be null or empty.");
-                }
-            }
-            if (currentSession != null && currentSession.isOpened()) {
-                if (!Utility.isSubset(permissions, currentSession.getPermissions())) {
-                    Log.e(TAG, "Cannot set additional permissions when session is already open.");
-                    return false;
-                }
-            }
-            return true;
-        }
-
-        List<String> getPermissions() {
-            return permissions;
-        }
-
-        public void clearPermissions() {
-            permissions = null;
-            authorizationType = null;
-        }
-
-        public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
-            this.loginBehavior = loginBehavior;
-        }
-
-        public SessionLoginBehavior getLoginBehavior() {
-            return loginBehavior;
-        }
-
-        public void setSessionStatusCallback(Session.StatusCallback callback) {
-            this.sessionStatusCallback = callback;
-        }
-
-        public Session.StatusCallback getSessionStatusCallback() {
-            return sessionStatusCallback;
-        }
-    }
-
-    /**
-     * Specifies a callback interface that will be called when the button's notion of the current
-     * user changes (if the fetch_user_info attribute is true for this control).
-     */
-    public interface UserInfoChangedCallback {
-        /**
-         * Called when the current user changes.
-         * @param user  the current user, or null if there is no user
-         */
-        void onUserInfoFetched(GraphUser user);
-    }
-
-    /**
-     * Callback interface that will be called when a network or other error is encountered
-     * while logging in.
-     */
-    public interface OnErrorListener {
-        /**
-         * Called when a network or other error is encountered.
-         * @param error     a FacebookException representing the error that was encountered.
-         */
-        void onError(FacebookException error);
-    }
-
-    /**
-     * Create the LoginButton.
-     *
-     * @see View#View(Context)
-     */
-    public LoginButton(Context context) {
-        super(context);
-        initializeActiveSessionWithCachedToken(context);
-        // since onFinishInflate won't be called, we need to finish initialization ourselves
-        finishInit();
-    }
-
-    /**
-     * Create the LoginButton by inflating from XML
-     *
-     * @see View#View(Context, AttributeSet)
-     */
-    public LoginButton(Context context, AttributeSet attrs) {
-        super(context, attrs);
-
-        if (!isInEditMode()) {
-            initializeActiveSessionWithCachedToken(context);
-        }        
-    }
-
-    /**
-     * Create the LoginButton by inflating from XML and applying a style.
-     *
-     * @see View#View(Context, AttributeSet, int)
-     */
-    public LoginButton(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        initializeActiveSessionWithCachedToken(context);
-    }
-
-    /**
-     * Sets an OnErrorListener for this instance of LoginButton to call into when
-     * certain exceptions occur.
-     *
-     * @param onErrorListener The listener object to set
-     */
-    public void setOnErrorListener(OnErrorListener onErrorListener) {
-        properties.setOnErrorListener(onErrorListener);
-    }
-
-    /**
-     * Returns the current OnErrorListener for this instance of LoginButton.
-     *
-     * @return The OnErrorListener
-     */
-    public OnErrorListener getOnErrorListener() {
-        return properties.getOnErrorListener();
-    }
-
-    /**
-     * Sets the default audience to use when the session is opened.
-     * This value is only useful when specifying write permissions for the native
-     * login dialog.
-     *
-     * @param defaultAudience the default audience value to use
-     */
-    public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
-        properties.setDefaultAudience(defaultAudience);
-    }
-
-    /**
-     * Gets the default audience to use when the session is opened.
-     * This value is only useful when specifying write permissions for the native
-     * login dialog.
-     *
-     * @return the default audience value to use
-     */
-    public SessionDefaultAudience getDefaultAudience() {
-        return properties.getDefaultAudience();
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * can only be read permissions. If any publish permissions are included, the login
-     * attempt by the user will fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setPublishPermissions has been called
-     */
-    public void setReadPermissions(List<String> permissions) {
-        properties.setReadPermissions(permissions, sessionTracker.getSession());
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * should only be publish permissions. If any read permissions are included, the login
-     * attempt by the user may fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setReadPermissions has been called
-     * @throws IllegalArgumentException if permissions is null or empty
-     */
-    public void setPublishPermissions(List<String> permissions) {
-        properties.setPublishPermissions(permissions, sessionTracker.getSession());
-    }
-
-
-    /**
-     * Clears the permissions currently associated with this LoginButton.
-     */
-    public void clearPermissions() {
-        properties.clearPermissions();
-    }
-
-    /**
-     * Sets the login behavior for the session that will be opened. If null is specified,
-     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
-     * will be used.
-     *
-     * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *                      specifies what behaviors should be attempted during
-     *                      authorization.
-     */
-    public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
-        properties.setLoginBehavior(loginBehavior);
-    }
-
-    /**
-     * Gets the login behavior for the session that will be opened. If null is returned,
-     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
-     * will be used.
-     *
-     * @return loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *                      specifies what behaviors should be attempted during
-     *                      authorization.
-     */
-    public SessionLoginBehavior getLoginBehavior() {
-        return properties.getLoginBehavior();
-    }
-
-    /**
-     * Set the application ID to be used to open the session.
-     *
-     * @param applicationId the application ID to use
-     */
-    public void setApplicationId(String applicationId) {
-        this.applicationId = applicationId;
-    }
-
-    /**
-     * Gets the callback interface that will be called when the current user changes.
-     * @return the callback interface
-     */
-    public UserInfoChangedCallback getUserInfoChangedCallback() {
-        return userInfoChangedCallback;
-    }
-
-    /**
-     * Sets the callback interface that will be called when the current user changes.
-     *
-     * @param userInfoChangedCallback   the callback interface
-     */
-    public void setUserInfoChangedCallback(UserInfoChangedCallback userInfoChangedCallback) {
-        this.userInfoChangedCallback = userInfoChangedCallback;
-    }
-
-    /**
-     * Sets the callback interface that will be called whenever the status of the Session
-     * associated with this LoginButton changes. Note that updates will only be sent to the
-     * callback while the LoginButton is actually attached to a window.
-     *
-     * @param callback the callback interface
-     */
-    public void setSessionStatusCallback(Session.StatusCallback callback) {
-        properties.setSessionStatusCallback(callback);
-    }
-
-    /**
-     * Sets the callback interface that will be called whenever the status of the Session
-     * associated with this LoginButton changes.
-
-     * @return the callback interface
-     */
-    public Session.StatusCallback getSessionStatusCallback() {
-        return properties.getSessionStatusCallback();
-    }
-
-    /**
-     * Provides an implementation for {@link Activity#onActivityResult
-     * onActivityResult} that updates the Session based on information returned
-     * during the authorization flow. The Activity containing this view
-     * should forward the resulting onActivityResult call here to
-     * update the Session state based on the contents of the resultCode and
-     * data.
-     *
-     * @param requestCode
-     *            The requestCode parameter from the forwarded call. When this
-     *            onActivityResult occurs as part of Facebook authorization
-     *            flow, this value is the activityCode passed to open or
-     *            authorize.
-     * @param resultCode
-     *            An int containing the resultCode parameter from the forwarded
-     *            call.
-     * @param data
-     *            The Intent passed as the data parameter from the forwarded
-     *            call.
-     * @return A boolean indicating whether the requestCode matched a pending
-     *         authorization request for this Session.
-     * @see Session#onActivityResult(Activity, int, int, Intent)
-     */
-    public boolean onActivityResult(int requestCode, int resultCode, Intent data) {
-        Session session = sessionTracker.getSession();
-        if (session != null) {
-            return session.onActivityResult((Activity)getContext(), requestCode,
-                    resultCode, data);
-        } else {
-            return false;
-        }
-    }
-
-    /**
-     * Set the Session object to use instead of the active Session. Since a Session
-     * cannot be reused, if the user logs out from this Session, and tries to
-     * log in again, a new Active Session will be used instead.
-     * <p/>
-     * If the passed in session is currently opened, this method will also attempt to
-     * load some user information for display (if needed).
-     *
-     * @param newSession the Session object to use
-     * @throws FacebookException if errors occur during the loading of user information
-     */
-    public void setSession(Session newSession) {
-        sessionTracker.setSession(newSession);
-        fetchUserInfo();
-        setButtonText();
-    }
-
-    @Override
-    public void onFinishInflate() {
-        super.onFinishInflate();
-        finishInit();
-    }
-
-    private void finishInit() {
-        setOnCheckedChangeListener(new LoginClickListener());
-        setButtonText();
-        if (!isInEditMode()) {
-            sessionTracker = new SessionTracker(getContext(), new LoginButtonCallback(), null, false);
-            fetchUserInfo();
-        }
-    }
-
-    /**
-     * Sets the fragment that contains this control. This allows the LoginButton to be
-     * embedded inside a Fragment, and will allow the fragment to receive the
-     * {@link Fragment#onActivityResult(int, int, android.content.Intent) onActivityResult}
-     * call rather than the Activity.
-     *
-     * @param fragment the fragment that contains this control
-     */
-    public void setFragment(Fragment fragment) {
-        parentFragment = fragment;
-    }
-
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-        if (sessionTracker != null && !sessionTracker.isTracking()) {
-            sessionTracker.startTracking();
-            fetchUserInfo();
-            setButtonText();
-        }
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        super.onDetachedFromWindow();
-        if (sessionTracker != null) {
-            sessionTracker.stopTracking();
-        }
-    }
-
-    // For testing purposes only
-    List<String> getPermissions() {
-        return properties.getPermissions();
-    }
-
-    void setProperties(LoginButtonProperties properties) {
-        this.properties = properties;
-    }
-
-    private void setButtonText() {
-        //sessionTracker != null && sessionTracker.getOpenSession() != null;
-    }
-
-    private boolean initializeActiveSessionWithCachedToken(Context context) {
-        if (context == null) {
-            return false;
-        }
-
-        Session session = Session.getActiveSession();
-        if (session != null) {
-            return session.isOpened();
-        }
-
-        String applicationId = Utility.getMetadataApplicationId(context);
-        if (applicationId == null) {
-            return false;
-        }
-
-        return Session.openActiveSessionFromCache(context) != null;
-    }
-
-    private void fetchUserInfo() {
-        //null
-    }
-
-    private class LoginClickListener implements OnCheckedChangeListener {
-
-        public void onClick() {
-            Context context = getContext();
-            final Session openSession = sessionTracker.getOpenSession();
-            if (openSession != null) {
-                // If the Session is currently open, it must mean we need to log out
-            } else {
-                Session currentSession = sessionTracker.getSession();
-                if (currentSession == null || currentSession.getState().isClosed()) {
-                    sessionTracker.setSession(null);
-                    Session session = new Session.Builder(context).setApplicationId(applicationId).build();
-                    Session.setActiveSession(session);
-                    currentSession = session;
-                }
-                if (!currentSession.isOpened()) {
-                    Session.OpenRequest openRequest = null;
-                    if (parentFragment != null) {
-                        openRequest = new Session.OpenRequest(parentFragment);
-                    } else if (context instanceof Activity) {
-                        openRequest = new Session.OpenRequest((Activity)context);
-                    }
-
-                    if (openRequest != null) {
-                        openRequest.setDefaultAudience(properties.defaultAudience);
-                        openRequest.setPermissions(properties.permissions);
-                        openRequest.setLoginBehavior(properties.loginBehavior);
-
-                        if (SessionAuthorizationType.PUBLISH.equals(properties.authorizationType)) {
-                            currentSession.openForPublish(openRequest);
-                        } else {
-                            currentSession.openForRead(openRequest);
-                        }
-                    }
-                }
-            }
-        }
-
-        @Override
-        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-            if(!isParentChecked){
-                setChecked(false);
-            }else{
-                ArrayList<String> permissions = new ArrayList<String>();
-                permissions.add("publish_actions");
-                setPublishPermissions(permissions);
-                onClick();
-            }
-        }
-    }
-
-    private class LoginButtonCallback implements Session.StatusCallback {
-        @Override
-        public void call(Session session, SessionState state,
-                         Exception exception) {
-            fetchUserInfo();
-            setButtonText();
-            if (exception != null) {
-                handleError(exception);
-            }
-
-            if (properties.sessionStatusCallback != null) {
-                properties.sessionStatusCallback.call(session, state, exception);
-            }
-        }
-    };
-
-    void handleError(Exception exception) {
-        if (properties.onErrorListener != null) {
-            if (exception instanceof FacebookException) {
-                properties.onErrorListener.onError((FacebookException)exception);
-            } else {
-                properties.onErrorListener.onError(new FacebookException(exception));
-            }
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/widget/PickerFragment.java b/facebook/src/com/facebook/widget/PickerFragment.java
deleted file mode 100644
index c084cc0ad..000000000
--- a/facebook/src/com/facebook/widget/PickerFragment.java
+++ /dev/null
@@ -1,1049 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.drawable.Drawable;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.LoaderManager;
-import android.support.v4.content.Loader;
-import android.text.TextUtils;
-import android.util.AttributeSet;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.ViewStub;
-import android.view.animation.AlphaAnimation;
-import android.widget.*;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.model.GraphObject;
-import com.facebook.internal.SessionTracker;
-
-import java.util.*;
-
-/**
- * Provides functionality common to SDK UI elements that allow the user to pick one or more
- * graph objects (e.g., places, friends) from a list of possibilities. The UI is exposed as a
- * Fragment to allow to it to be included in an Activity along with other Fragments. The Fragments
- * can be configured by passing parameters as part of their Intent bundle, or (for certain
- * properties) by specifying attributes in their XML layout files.
- * <br/>
- * PickerFragments support callbacks that will be called in the event of an error, when the
- * underlying data has been changed, or when the set of selected graph objects changes.
- */
-public abstract class PickerFragment<T extends GraphObject> extends Fragment {
-    /**
-     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
-     * picker should show pictures (if available) for the graph objects.
-     */
-    public static final String SHOW_PICTURES_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ShowPictures";
-    /**
-     * The key for a String parameter in the fragment's Intent bundle to indicate which extra fields
-     * beyond the default fields should be retrieved for any graph objects in the results.
-     */
-    public static final String EXTRA_FIELDS_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ExtraFields";
-    /**
-     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
-     * picker should display a title bar with a Done button.
-     */
-    public static final String SHOW_TITLE_BAR_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ShowTitleBar";
-    /**
-     * The key for a String parameter in the fragment's Intent bundle to indicate the text to
-     * display in the title bar.
-     */
-    public static final String TITLE_TEXT_BUNDLE_KEY = "com.facebook.widget.PickerFragment.TitleText";
-    /**
-     * The key for a String parameter in the fragment's Intent bundle to indicate the text to
-     * display in the Done btuton.
-     */
-    public static final String DONE_BUTTON_TEXT_BUNDLE_KEY = "com.facebook.widget.PickerFragment.DoneButtonText";
-
-    private static final String SELECTION_BUNDLE_KEY = "com.facebook.android.PickerFragment.Selection";
-    private static final String ACTIVITY_CIRCLE_SHOW_KEY = "com.facebook.android.PickerFragment.ActivityCircleShown";
-    private static final int PROFILE_PICTURE_PREFETCH_BUFFER = 5;
-
-    private final int layout;
-    private OnErrorListener onErrorListener;
-    private OnDataChangedListener onDataChangedListener;
-    private OnSelectionChangedListener onSelectionChangedListener;
-    private OnDoneButtonClickedListener onDoneButtonClickedListener;
-    private GraphObjectFilter<T> filter;
-    private boolean showPictures = true;
-    private boolean showTitleBar = true;
-    private ListView listView;
-    HashSet<String> extraFields = new HashSet<String>();
-    GraphObjectAdapter<T> adapter;
-    private final Class<T> graphObjectClass;
-    private LoadingStrategy loadingStrategy;
-    private SelectionStrategy selectionStrategy;
-    private ProgressBar activityCircle;
-    private SessionTracker sessionTracker;
-    private String titleText;
-    private String doneButtonText;
-    private TextView titleTextView;
-    private Button doneButton;
-    private Drawable titleBarBackground;
-    private Drawable doneButtonBackground;
-
-    PickerFragment(Class<T> graphObjectClass, int layout, Bundle args) {
-        this.graphObjectClass = graphObjectClass;
-        this.layout = layout;
-
-        setPickerFragmentSettingsFromBundle(args);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        adapter = createAdapter();
-        adapter.setFilter(new GraphObjectAdapter.Filter<T>() {
-            @Override
-            public boolean includeItem(T graphObject) {
-                return filterIncludesItem(graphObject);
-            }
-        });
-    }
-
-    @Override
-    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
-        super.onInflate(activity, attrs, savedInstanceState);
-        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_picker_fragment);
-
-        setShowPictures(a.getBoolean(R.styleable.com_facebook_picker_fragment_show_pictures, showPictures));
-        String extraFieldsString = a.getString(R.styleable.com_facebook_picker_fragment_extra_fields);
-        if (extraFieldsString != null) {
-            String[] strings = extraFieldsString.split(",");
-            setExtraFields(Arrays.asList(strings));
-        }
-
-        showTitleBar = a.getBoolean(R.styleable.com_facebook_picker_fragment_show_title_bar, showTitleBar);
-        titleText = a.getString(R.styleable.com_facebook_picker_fragment_title_text);
-        doneButtonText = a.getString(R.styleable.com_facebook_picker_fragment_done_button_text);
-        titleBarBackground = a.getDrawable(R.styleable.com_facebook_picker_fragment_title_bar_background);
-        doneButtonBackground = a.getDrawable(R.styleable.com_facebook_picker_fragment_done_button_background);
-
-        a.recycle();
-    }
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        ViewGroup view = (ViewGroup) inflater.inflate(layout, container, false);
-
-        listView = (ListView) view.findViewById(R.id.com_facebook_picker_list_view);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-            @Override
-            public void onItemClick(AdapterView<?> parent, View v, int position, long id) {
-                onListItemClick((ListView) parent, v, position);
-            }
-        });
-        listView.setOnLongClickListener(new View.OnLongClickListener() {
-            @Override
-            public boolean onLongClick(View v) {
-                // We don't actually do anything differently on long-clicks, but setting the listener
-                // enables the selector transition that we have for visual consistency with the
-                // Facebook app's pickers.
-                return false;
-            }
-        });
-        listView.setOnScrollListener(onScrollListener);
-        listView.setAdapter(adapter);
-
-        activityCircle = (ProgressBar) view.findViewById(R.id.com_facebook_picker_activity_circle);
-
-        return view;
-    }
-
-    @Override
-    public void onActivityCreated(final Bundle savedInstanceState) {
-        super.onActivityCreated(savedInstanceState);
-
-        sessionTracker = new SessionTracker(getActivity(), new Session.StatusCallback() {
-            @Override
-            public void call(Session session, SessionState state, Exception exception) {
-                if (!session.isOpened()) {
-                    // When a session is closed, we want to clear out our data so it is not visible to subsequent users
-                    clearResults();
-                }
-            }
-        });
-
-        setSettingsFromBundle(savedInstanceState);
-
-        loadingStrategy = createLoadingStrategy();
-        loadingStrategy.attach(adapter);
-
-        selectionStrategy = createSelectionStrategy();
-        selectionStrategy.readSelectionFromBundle(savedInstanceState, SELECTION_BUNDLE_KEY);
-
-        // Should we display a title bar? (We need to do this after we've retrieved our bundle settings.)
-        if (showTitleBar) {
-            inflateTitleBar((ViewGroup) getView());
-        }
-
-        if (activityCircle != null && savedInstanceState != null) {
-            boolean shown = savedInstanceState.getBoolean(ACTIVITY_CIRCLE_SHOW_KEY, false);
-            if (shown) {
-                displayActivityCircle();
-            } else {
-                // Should be hidden already, but just to be sure.
-                hideActivityCircle();
-            }
-        }
-    }
-
-    @Override
-    public void onDetach() {
-        super.onDetach();
-
-        listView.setOnScrollListener(null);
-        listView.setAdapter(null);
-
-        loadingStrategy.detach();
-        sessionTracker.stopTracking();
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-
-        saveSettingsToBundle(outState);
-        selectionStrategy.saveSelectionToBundle(outState, SELECTION_BUNDLE_KEY);
-        if (activityCircle != null) {
-            outState.putBoolean(ACTIVITY_CIRCLE_SHOW_KEY, activityCircle.getVisibility() == View.VISIBLE);
-        }
-    }
-
-    @Override
-    public void setArguments(Bundle args) {
-        super.setArguments(args);
-        setSettingsFromBundle(args);
-    }
-
-    /**
-     * Gets the current OnDataChangedListener for this fragment, which will be called whenever
-     * the underlying data being displaying in the picker has changed.
-     *
-     * @return the OnDataChangedListener, or null if there is none
-     */
-    public OnDataChangedListener getOnDataChangedListener() {
-        return onDataChangedListener;
-    }
-
-    /**
-     * Sets the current OnDataChangedListener for this fragment, which will be called whenever
-     * the underlying data being displaying in the picker has changed.
-     *
-     * @param onDataChangedListener the OnDataChangedListener, or null if there is none
-     */
-    public void setOnDataChangedListener(OnDataChangedListener onDataChangedListener) {
-        this.onDataChangedListener = onDataChangedListener;
-    }
-
-    /**
-     * Gets the current OnSelectionChangedListener for this fragment, which will be called
-     * whenever the user selects or unselects a graph object in the list.
-     *
-     * @return the OnSelectionChangedListener, or null if there is none
-     */
-    public OnSelectionChangedListener getOnSelectionChangedListener() {
-        return onSelectionChangedListener;
-    }
-
-    /**
-     * Sets the current OnSelectionChangedListener for this fragment, which will be called
-     * whenever the user selects or unselects a graph object in the list.
-     *
-     * @param onSelectionChangedListener the OnSelectionChangedListener, or null if there is none
-     */
-    public void setOnSelectionChangedListener(
-            OnSelectionChangedListener onSelectionChangedListener) {
-        this.onSelectionChangedListener = onSelectionChangedListener;
-    }
-
-    /**
-     * Gets the current OnDoneButtonClickedListener for this fragment, which will be called
-     * when the user clicks the Done button.
-     *
-     * @return the OnDoneButtonClickedListener, or null if there is none
-     */
-    public OnDoneButtonClickedListener getOnDoneButtonClickedListener() {
-        return onDoneButtonClickedListener;
-    }
-
-    /**
-     * Sets the current OnDoneButtonClickedListener for this fragment, which will be called
-     * when the user clicks the Done button. This will only be possible if the title bar is
-     * being shown in this fragment.
-     *
-     * @param onDoneButtonClickedListener the OnDoneButtonClickedListener, or null if there is none
-     */
-    public void setOnDoneButtonClickedListener(OnDoneButtonClickedListener onDoneButtonClickedListener) {
-        this.onDoneButtonClickedListener = onDoneButtonClickedListener;
-    }
-
-    /**
-     * Gets the current OnErrorListener for this fragment, which will be called in the event
-     * of network or other errors encountered while populating the graph objects in the list.
-     *
-     * @return the OnErrorListener, or null if there is none
-     */
-    public OnErrorListener getOnErrorListener() {
-        return onErrorListener;
-    }
-
-    /**
-     * Sets the current OnErrorListener for this fragment, which will be called in the event
-     * of network or other errors encountered while populating the graph objects in the list.
-     *
-     * @param onErrorListener the OnErrorListener, or null if there is none
-     */
-    public void setOnErrorListener(OnErrorListener onErrorListener) {
-        this.onErrorListener = onErrorListener;
-    }
-
-    /**
-     * Gets the current filter for this fragment, which will be called for each graph object
-     * returned from the service to determine if it should be displayed in the list.
-     * If no filter is specified, all retrieved graph objects will be displayed.
-     *
-     * @return the GraphObjectFilter, or null if there is none
-     */
-    public GraphObjectFilter<T> getFilter() {
-        return filter;
-    }
-
-    /**
-     * Sets the current filter for this fragment, which will be called for each graph object
-     * returned from the service to determine if it should be displayed in the list.
-     * If no filter is specified, all retrieved graph objects will be displayed.
-     *
-     * @param filter the GraphObjectFilter, or null if there is none
-     */
-    public void setFilter(GraphObjectFilter<T> filter) {
-        this.filter = filter;
-    }
-
-    /**
-     * Gets the Session to use for any Facebook requests this fragment will make.
-     *
-     * @return the Session that will be used for any Facebook requests, or null if there is none
-     */
-    public Session getSession() {
-        return sessionTracker.getSession();
-    }
-
-    /**
-     * Sets the Session to use for any Facebook requests this fragment will make. If the
-     * parameter is null, the fragment will use the current active session, if any.
-     *
-     * @param session the Session to use for Facebook requests, or null to use the active session
-     */
-    public void setSession(Session session) {
-        sessionTracker.setSession(session);
-    }
-
-    /**
-     * Gets whether to display pictures, if available, for displayed graph objects.
-     *
-     * @return true if pictures should be displayed, false if not
-     */
-    public boolean getShowPictures() {
-        return showPictures;
-    }
-
-    /**
-     * Sets whether to display pictures, if available, for displayed graph objects.
-     *
-     * @param showPictures true if pictures should be displayed, false if not
-     */
-    public void setShowPictures(boolean showPictures) {
-        this.showPictures = showPictures;
-    }
-
-    /**
-     * Gets the extra fields to request for the retrieved graph objects.
-     *
-     * @return the extra fields to request
-     */
-    public Set<String> getExtraFields() {
-        return new HashSet<String>(extraFields);
-    }
-
-    /**
-     * Sets the extra fields to request for the retrieved graph objects.
-     *
-     * @param fields the extra fields to request
-     */
-    public void setExtraFields(Collection<String> fields) {
-        extraFields = new HashSet<String>();
-        if (fields != null) {
-            extraFields.addAll(fields);
-        }
-    }
-
-    /**
-     * Sets whether to show a title bar with a Done button. This must be
-     * called prior to the Fragment going through its creation lifecycle to have an effect.
-     *
-     * @param showTitleBar true if a title bar should be displayed, false if not
-     */
-    public void setShowTitleBar(boolean showTitleBar) {
-        this.showTitleBar = showTitleBar;
-    }
-
-    /**
-     * Gets whether to show a title bar with a Done button. The default is true.
-     *
-     * @return true if a title bar will be shown, false if not.
-     */
-    public boolean getShowTitleBar() {
-        return showTitleBar;
-    }
-
-    /**
-     * Sets the text to show in the title bar, if a title bar is to be shown. This must be
-     * called prior to the Fragment going through its creation lifecycle to have an effect, or
-     * the default will be used.
-     *
-     * @param titleText the text to show in the title bar
-     */
-    public void setTitleText(String titleText) {
-        this.titleText = titleText;
-    }
-
-    /**
-     * Gets the text to show in the title bar, if a title bar is to be shown.
-     *
-     * @return the text to show in the title bar
-     */
-    public String getTitleText() {
-        if (titleText == null) {
-            titleText = getDefaultTitleText();
-        }
-        return titleText;
-    }
-
-    /**
-     * Sets the text to show in the Done button, if a title bar is to be shown. This must be
-     * called prior to the Fragment going through its creation lifecycle to have an effect, or
-     * the default will be used.
-     *
-     * @param doneButtonText the text to show in the Done button
-     */
-    public void setDoneButtonText(String doneButtonText) {
-        this.doneButtonText = doneButtonText;
-    }
-
-    /**
-     * Gets the text to show in the Done button, if a title bar is to be shown.
-     *
-     * @return the text to show in the Done button
-     */
-    public String getDoneButtonText() {
-        if (doneButtonText == null) {
-            doneButtonText = getDefaultDoneButtonText();
-        }
-        return doneButtonText;
-    }
-
-    /**
-     * Causes the picker to load data from the service and display it to the user.
-     *
-     * @param forceReload if true, data will be loaded even if there is already data being displayed (or loading);
-     *                    if false, data will not be re-loaded if it is already displayed (or loading)
-     */
-    public void loadData(boolean forceReload) {
-        if (!forceReload && loadingStrategy.isDataPresentOrLoading()) {
-            return;
-        }
-        loadDataSkippingRoundTripIfCached();
-    }
-
-    /**
-     * Updates the properties of the PickerFragment based on the contents of the supplied Bundle;
-     * calling Activities may use this to pass additional configuration information to the
-     * PickerFragment beyond what is specified in its XML layout.
-     *
-     * @param inState a Bundle containing keys corresponding to properties of the PickerFragment
-     */
-    public void setSettingsFromBundle(Bundle inState) {
-        setPickerFragmentSettingsFromBundle(inState);
-    }
-
-    boolean filterIncludesItem(T graphObject) {
-        if (filter != null) {
-            return filter.includeItem(graphObject);
-        }
-        return true;
-    }
-
-    List<T> getSelectedGraphObjects() {
-        return adapter.getGraphObjectsById(selectionStrategy.getSelectedIds());
-    }
-
-    void saveSettingsToBundle(Bundle outState) {
-        outState.putBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
-        if (!extraFields.isEmpty()) {
-            outState.putString(EXTRA_FIELDS_BUNDLE_KEY, TextUtils.join(",", extraFields));
-        }
-        outState.putBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
-        outState.putString(TITLE_TEXT_BUNDLE_KEY, titleText);
-        outState.putString(DONE_BUTTON_TEXT_BUNDLE_KEY, doneButtonText);
-    }
-
-    abstract Request getRequestForLoadData(Session session);
-
-    abstract PickerFragmentAdapter<T> createAdapter();
-
-    abstract LoadingStrategy createLoadingStrategy();
-
-    abstract SelectionStrategy createSelectionStrategy();
-
-    void onLoadingData() {
-    }
-
-    String getDefaultTitleText() {
-        return null;
-    }
-
-    String getDefaultDoneButtonText() {
-        return getString(R.string.com_facebook_picker_done_button_text);
-    }
-
-    void displayActivityCircle() {
-        if (activityCircle != null) {
-            layoutActivityCircle();
-            activityCircle.setVisibility(View.VISIBLE);
-        }
-    }
-
-    void layoutActivityCircle() {
-        // If we've got no data, make the activity circle full-opacity. Otherwise we'll dim it to avoid
-        //  cluttering the UI.
-        float alpha = (!adapter.isEmpty()) ? .25f : 1.0f;
-        setAlpha(activityCircle, alpha);
-    }
-
-    void hideActivityCircle() {
-        if (activityCircle != null) {
-            // We use an animation to dim the activity circle; need to clear this or it will remain visible.
-            activityCircle.clearAnimation();
-            activityCircle.setVisibility(View.INVISIBLE);
-        }
-    }
-
-    void setSelectionStrategy(SelectionStrategy selectionStrategy) {
-        if (selectionStrategy != this.selectionStrategy) {
-            this.selectionStrategy = selectionStrategy;
-            if (adapter != null) {
-                // Adapter should cause a re-render.
-                adapter.notifyDataSetChanged();
-            }
-        }
-    }
-
-    private static void setAlpha(View view, float alpha) {
-        // Set the alpha appropriately (setAlpha is API >= 11, this technique works on all API levels).
-        AlphaAnimation alphaAnimation = new AlphaAnimation(alpha, alpha);
-        alphaAnimation.setDuration(0);
-        alphaAnimation.setFillAfter(true);
-        view.startAnimation(alphaAnimation);
-    }
-
-
-    private void setPickerFragmentSettingsFromBundle(Bundle inState) {
-        // We do this in a separate non-overridable method so it is safe to call from the constructor.
-        if (inState != null) {
-            showPictures = inState.getBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
-            String extraFieldsString = inState.getString(EXTRA_FIELDS_BUNDLE_KEY);
-            if (extraFieldsString != null) {
-                String[] strings = extraFieldsString.split(",");
-                setExtraFields(Arrays.asList(strings));
-            }
-            showTitleBar = inState.getBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
-            String titleTextString = inState.getString(TITLE_TEXT_BUNDLE_KEY);
-            if (titleTextString != null) {
-                titleText = titleTextString;
-                if (titleTextView != null) {
-                    titleTextView.setText(titleText);
-                }
-            }
-            String doneButtonTextString = inState.getString(DONE_BUTTON_TEXT_BUNDLE_KEY);
-            if (doneButtonTextString != null) {
-                doneButtonText = doneButtonTextString;
-                if (doneButton != null) {
-                    doneButton.setText(doneButtonText);
-                }
-            }
-        }
-    }
-
-    private void inflateTitleBar(ViewGroup view) {
-        ViewStub stub = (ViewStub) view.findViewById(R.id.com_facebook_picker_title_bar_stub);
-        if (stub != null) {
-            View titleBar = stub.inflate();
-
-            final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
-                    RelativeLayout.LayoutParams.FILL_PARENT,
-                    RelativeLayout.LayoutParams.FILL_PARENT);
-            layoutParams.addRule(RelativeLayout.BELOW, R.id.com_facebook_picker_title_bar);
-            listView.setLayoutParams(layoutParams);
-
-            if (titleBarBackground != null) {
-                titleBar.setBackgroundDrawable(titleBarBackground);
-            }
-
-            doneButton = (Button) view.findViewById(R.id.com_facebook_picker_done_button);
-            if (doneButton != null) {
-                doneButton.setOnClickListener(new View.OnClickListener() {
-                    @Override
-                    public void onClick(View v) {
-                        if (onDoneButtonClickedListener != null) {
-                            onDoneButtonClickedListener.onDoneButtonClicked(PickerFragment.this);
-                        }
-                    }
-                });
-
-                if (getDoneButtonText() != null) {
-                    doneButton.setText(getDoneButtonText());
-                }
-
-                if (doneButtonBackground != null) {
-                    doneButton.setBackgroundDrawable(doneButtonBackground);
-                }
-            }
-
-            titleTextView = (TextView) view.findViewById(R.id.com_facebook_picker_title);
-            if (titleTextView != null) {
-                if (getTitleText() != null) {
-                    titleTextView.setText(getTitleText());
-                }
-            }
-        }
-    }
-
-    private void onListItemClick(ListView listView, View v, int position) {
-        @SuppressWarnings("unchecked")
-        T graphObject = (T) listView.getItemAtPosition(position);
-        String id = adapter.getIdOfGraphObject(graphObject);
-        selectionStrategy.toggleSelection(id);
-        adapter.notifyDataSetChanged();
-
-        if (onSelectionChangedListener != null) {
-            onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
-        }
-    }
-
-    private void loadDataSkippingRoundTripIfCached() {
-        clearResults();
-
-        Request request = getRequestForLoadData(getSession());
-        if (request != null) {
-            onLoadingData();
-            loadingStrategy.startLoading(request);
-        }
-    }
-
-    private void clearResults() {
-        if (adapter != null) {
-            boolean wasSelection = !selectionStrategy.isEmpty();
-            boolean wasData = !adapter.isEmpty();
-
-            loadingStrategy.clearResults();
-            selectionStrategy.clear();
-            adapter.notifyDataSetChanged();
-
-            // Tell anyone who cares the data and selection has changed, if they have.
-            if (wasData && onDataChangedListener != null) {
-                onDataChangedListener.onDataChanged(PickerFragment.this);
-            }
-            if (wasSelection && onSelectionChangedListener != null) {
-                onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
-            }
-        }
-    }
-
-    void updateAdapter(SimpleGraphObjectCursor<T> data) {
-        if (adapter != null) {
-            // As we fetch additional results and add them to the table, we do not
-            // want the items displayed jumping around seemingly at random, frustrating the user's
-            // attempts at scrolling, etc. Since results may be added anywhere in
-            // the table, we choose to try to keep the first visible row in a fixed
-            // position (from the user's perspective). We try to keep it positioned at
-            // the same offset from the top of the screen so adding new items seems
-            // smoother, as opposed to having it "snap" to a multiple of row height
-
-            // We use the second row, to give context above and below it and avoid
-            // cases where the first row is only barely visible, thus providing little context.
-            // The exception is where the very first row is visible, in which case we use that.
-            View view = listView.getChildAt(1);
-            int anchorPosition = listView.getFirstVisiblePosition();
-            if (anchorPosition > 0) {
-                anchorPosition++;
-            }
-            GraphObjectAdapter.SectionAndItem<T> anchorItem = adapter.getSectionAndItem(anchorPosition);
-            final int top = (view != null &&
-                    anchorItem.getType() != GraphObjectAdapter.SectionAndItem.Type.ACTIVITY_CIRCLE) ?
-                    view.getTop() : 0;
-
-            // Now actually add the results.
-            boolean dataChanged = adapter.changeCursor(data);
-
-            if (view != null && anchorItem != null) {
-                // Put the item back in the same spot it was.
-                final int newPositionOfItem = adapter.getPosition(anchorItem.sectionKey, anchorItem.graphObject);
-                if (newPositionOfItem != -1) {
-                    listView.setSelectionFromTop(newPositionOfItem, top);
-                }
-            }
-
-            if (dataChanged && onDataChangedListener != null) {
-                onDataChangedListener.onDataChanged(PickerFragment.this);
-            }
-        }
-    }
-
-    private void reprioritizeDownloads() {
-        int lastVisibleItem = listView.getLastVisiblePosition();
-        if (lastVisibleItem >= 0) {
-            int firstVisibleItem = listView.getFirstVisiblePosition();
-            adapter.prioritizeViewRange(firstVisibleItem, lastVisibleItem, PROFILE_PICTURE_PREFETCH_BUFFER);
-        }
-    }
-
-    private ListView.OnScrollListener onScrollListener = new ListView.OnScrollListener() {
-        @Override
-        public void onScrollStateChanged(AbsListView view, int scrollState) {
-        }
-
-        @Override
-        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
-            reprioritizeDownloads();
-        }
-    };
-
-    /**
-     * Callback interface that will be called when a network or other error is encountered
-     * while retrieving graph objects.
-     */
-    public interface OnErrorListener {
-        /**
-         * Called when a network or other error is encountered.
-         *
-         * @param error a FacebookException representing the error that was encountered.
-         */
-        void onError(PickerFragment<?> fragment, FacebookException error);
-    }
-
-    /**
-     * Callback interface that will be called when the underlying data being displayed in the
-     * picker has been updated.
-     */
-    public interface OnDataChangedListener {
-        /**
-         * Called when the set of data being displayed in the picker has changed.
-         */
-        void onDataChanged(PickerFragment<?> fragment);
-    }
-
-    /**
-     * Callback interface that will be called when the user selects or unselects graph objects
-     * in the picker.
-     */
-    public interface OnSelectionChangedListener {
-        /**
-         * Called when the user selects or unselects graph objects in the picker.
-         */
-        void onSelectionChanged(PickerFragment<?> fragment);
-    }
-
-    /**
-     * Callback interface that will be called when the user clicks the Done button on the
-     * title bar.
-     */
-    public interface OnDoneButtonClickedListener {
-        /**
-         * Called when the user clicks the Done button.
-         */
-        void onDoneButtonClicked(PickerFragment<?> fragment);
-    }
-
-    /**
-     * Callback interface that will be called to determine if a graph object should be displayed.
-     *
-     * @param <T>
-     */
-    public interface GraphObjectFilter<T> {
-        /**
-         * Called to determine if a graph object should be displayed.
-         *
-         * @param graphObject the graph object
-         * @return true to display the graph object, false to hide it
-         */
-        boolean includeItem(T graphObject);
-    }
-
-    abstract class LoadingStrategy {
-        protected final static int CACHED_RESULT_REFRESH_DELAY = 2 * 1000;
-
-        protected GraphObjectPagingLoader<T> loader;
-        protected GraphObjectAdapter<T> adapter;
-
-        public void attach(GraphObjectAdapter<T> adapter) {
-            loader = (GraphObjectPagingLoader<T>) getLoaderManager().initLoader(0, null,
-                    new LoaderManager.LoaderCallbacks<SimpleGraphObjectCursor<T>>() {
-                        @Override
-                        public Loader<SimpleGraphObjectCursor<T>> onCreateLoader(int id, Bundle args) {
-                            return LoadingStrategy.this.onCreateLoader();
-                        }
-
-                        @Override
-                        public void onLoadFinished(Loader<SimpleGraphObjectCursor<T>> loader,
-                                SimpleGraphObjectCursor<T> data) {
-                            if (loader != LoadingStrategy.this.loader) {
-                                throw new FacebookException("Received callback for unknown loader.");
-                            }
-                            LoadingStrategy.this.onLoadFinished((GraphObjectPagingLoader<T>) loader, data);
-                        }
-
-                        @Override
-                        public void onLoaderReset(Loader<SimpleGraphObjectCursor<T>> loader) {
-                            if (loader != LoadingStrategy.this.loader) {
-                                throw new FacebookException("Received callback for unknown loader.");
-                            }
-                            LoadingStrategy.this.onLoadReset((GraphObjectPagingLoader<T>) loader);
-                        }
-                    });
-
-            loader.setOnErrorListener(new GraphObjectPagingLoader.OnErrorListener() {
-                @Override
-                public void onError(FacebookException error, GraphObjectPagingLoader<?> loader) {
-                    hideActivityCircle();
-                    if (onErrorListener != null) {
-                        onErrorListener.onError(PickerFragment.this, error);
-                    }
-                }
-            });
-
-            this.adapter = adapter;
-            // Tell the adapter about any data we might already have.
-            this.adapter.changeCursor(loader.getCursor());
-            this.adapter.setOnErrorListener(new GraphObjectAdapter.OnErrorListener() {
-                @Override
-                public void onError(GraphObjectAdapter<?> adapter, FacebookException error) {
-                    if (onErrorListener != null) {
-                        onErrorListener.onError(PickerFragment.this, error);
-                    }
-                }
-            });
-        }
-
-        public void detach() {
-            adapter.setDataNeededListener(null);
-            adapter.setOnErrorListener(null);
-            loader.setOnErrorListener(null);
-
-            loader = null;
-            adapter = null;
-        }
-
-        public void clearResults() {
-            if (loader != null) {
-                loader.clearResults();
-            }
-        }
-
-        public void startLoading(Request request) {
-            if (loader != null) {
-                loader.startLoading(request, true);
-                onStartLoading(loader, request);
-            }
-        }
-
-        public boolean isDataPresentOrLoading() {
-            return !adapter.isEmpty() || loader.isLoading();
-        }
-
-        protected GraphObjectPagingLoader<T> onCreateLoader() {
-            return new GraphObjectPagingLoader<T>(getActivity(), graphObjectClass);
-        }
-
-        protected void onStartLoading(GraphObjectPagingLoader<T> loader, Request request) {
-            displayActivityCircle();
-        }
-
-        protected void onLoadReset(GraphObjectPagingLoader<T> loader) {
-            adapter.changeCursor(null);
-        }
-
-        protected void onLoadFinished(GraphObjectPagingLoader<T> loader, SimpleGraphObjectCursor<T> data) {
-            updateAdapter(data);
-        }
-    }
-
-    abstract class SelectionStrategy {
-        abstract boolean isSelected(String id);
-
-        abstract void toggleSelection(String id);
-
-        abstract Collection<String> getSelectedIds();
-
-        abstract void clear();
-
-        abstract boolean isEmpty();
-
-        abstract boolean shouldShowCheckBoxIfUnselected();
-
-        abstract void saveSelectionToBundle(Bundle outBundle, String key);
-
-        abstract void readSelectionFromBundle(Bundle inBundle, String key);
-    }
-
-    class SingleSelectionStrategy extends SelectionStrategy {
-        private String selectedId;
-
-        public Collection<String> getSelectedIds() {
-            return Arrays.asList(new String[]{selectedId});
-        }
-
-        @Override
-        boolean isSelected(String id) {
-            return selectedId != null && id != null && selectedId.equals(id);
-        }
-
-        @Override
-        void toggleSelection(String id) {
-            if (selectedId != null && selectedId.equals(id)) {
-                selectedId = null;
-            } else {
-                selectedId = id;
-            }
-        }
-
-        @Override
-        void saveSelectionToBundle(Bundle outBundle, String key) {
-            if (!TextUtils.isEmpty(selectedId)) {
-                outBundle.putString(key, selectedId);
-            }
-        }
-
-        @Override
-        void readSelectionFromBundle(Bundle inBundle, String key) {
-            if (inBundle != null) {
-                selectedId = inBundle.getString(key);
-            }
-        }
-
-        @Override
-        public void clear() {
-            selectedId = null;
-        }
-
-        @Override
-        boolean isEmpty() {
-            return selectedId == null;
-        }
-
-        @Override
-        boolean shouldShowCheckBoxIfUnselected() {
-            return false;
-        }
-    }
-
-    class MultiSelectionStrategy extends SelectionStrategy {
-        private Set<String> selectedIds = new HashSet<String>();
-
-        public Collection<String> getSelectedIds() {
-            return selectedIds;
-        }
-
-        @Override
-        boolean isSelected(String id) {
-            return id != null && selectedIds.contains(id);
-        }
-
-        @Override
-        void toggleSelection(String id) {
-            if (id != null) {
-                if (selectedIds.contains(id)) {
-                    selectedIds.remove(id);
-                } else {
-                    selectedIds.add(id);
-                }
-            }
-        }
-
-        @Override
-        void saveSelectionToBundle(Bundle outBundle, String key) {
-            if (!selectedIds.isEmpty()) {
-                String ids = TextUtils.join(",", selectedIds);
-                outBundle.putString(key, ids);
-            }
-        }
-
-        @Override
-        void readSelectionFromBundle(Bundle inBundle, String key) {
-            if (inBundle != null) {
-                String ids = inBundle.getString(key);
-                if (ids != null) {
-                    String[] splitIds = TextUtils.split(ids, ",");
-                    selectedIds.clear();
-                    Collections.addAll(selectedIds, splitIds);
-                }
-            }
-        }
-
-        @Override
-        public void clear() {
-            selectedIds.clear();
-        }
-
-        @Override
-        boolean isEmpty() {
-            return selectedIds.isEmpty();
-        }
-
-        @Override
-        boolean shouldShowCheckBoxIfUnselected() {
-            return true;
-        }
-    }
-
-    abstract class PickerFragmentAdapter<U extends GraphObject> extends GraphObjectAdapter<T> {
-        public PickerFragmentAdapter(Context context) {
-            super(context);
-        }
-
-        @Override
-        boolean isGraphObjectSelected(String graphObjectId) {
-            return selectionStrategy.isSelected(graphObjectId);
-        }
-
-        @Override
-        void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
-            checkBox.setChecked(graphObjectSelected);
-            int visible = (graphObjectSelected || selectionStrategy
-                    .shouldShowCheckBoxIfUnselected()) ? View.VISIBLE : View.GONE;
-            checkBox.setVisibility(visible);
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/widget/PlacePickerFragment.java b/facebook/src/com/facebook/widget/PlacePickerFragment.java
deleted file mode 100644
index 0ae78c0fa..000000000
--- a/facebook/src/com/facebook/widget/PlacePickerFragment.java
+++ /dev/null
@@ -1,530 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.location.Location;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
-import android.text.Editable;
-import android.text.TextUtils;
-import android.text.TextWatcher;
-import android.util.AttributeSet;
-import android.view.ViewGroup;
-import android.view.ViewStub;
-import android.view.inputmethod.InputMethodManager;
-import android.widget.EditText;
-import android.widget.ListView;
-import android.widget.RelativeLayout;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.model.GraphPlace;
-import com.facebook.internal.Logger;
-import com.facebook.internal.Utility;
-
-import java.util.*;
-
-public class PlacePickerFragment extends PickerFragment<GraphPlace> {
-    /**
-     * The key for an int parameter in the fragment's Intent bundle to indicate the radius in meters around
-     * the center point to search. The default is 1000 meters.
-     */
-    public static final String RADIUS_IN_METERS_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.RadiusInMeters";
-    /**
-     * The key for an int parameter in the fragment's Intent bundle to indicate what how many results to
-     * return at a time. The default is 100 results.
-     */
-    public static final String RESULTS_LIMIT_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.ResultsLimit";
-    /**
-     * The key for a String parameter in the fragment's Intent bundle to indicate what search text should
-     * be sent to the service. The default is to have no search text.
-     */
-    public static final String SEARCH_TEXT_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.SearchText";
-    /**
-     * The key for a Location parameter in the fragment's Intent bundle to indicate what geographical
-     * location should be the center of the search.
-     */
-    public static final String LOCATION_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.Location";
-    /**
-     * The key for a boolean parameter in the fragment's Intent bundle to indicate that the fragment
-     * should display a search box and automatically update the search text as it changes.
-     */
-    public static final String SHOW_SEARCH_BOX_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.ShowSearchBox";
-
-    /**
-     * The default radius around the center point to search.
-     */
-    public static final int DEFAULT_RADIUS_IN_METERS = 1000;
-    /**
-     * The default number of results to retrieve.
-     */
-    public static final int DEFAULT_RESULTS_LIMIT = 100;
-
-    private static final int searchTextTimerDelayInMilliseconds = 2 * 1000;
-
-    private static final String ID = "id";
-    private static final String NAME = "name";
-    private static final String LOCATION = "location";
-    private static final String CATEGORY = "category";
-    private static final String WERE_HERE_COUNT = "were_here_count";
-    private static final String TAG = "PlacePickerFragment";
-
-    private Location location;
-    private int radiusInMeters = DEFAULT_RADIUS_IN_METERS;
-    private int resultsLimit = DEFAULT_RESULTS_LIMIT;
-    private String searchText;
-    private Timer searchTextTimer;
-    private boolean hasSearchTextChangedSinceLastQuery;
-    private boolean showSearchBox = true;
-    private EditText searchBox;
-
-    /**
-     * Default constructor. Creates a Fragment with all default properties.
-     */
-    public PlacePickerFragment() {
-        this(null);
-    }
-
-    /**
-     * Constructor.
-     *
-     * @param args a Bundle that optionally contains one or more values containing additional
-     *             configuration information for the Fragment.
-     */
-    public PlacePickerFragment(Bundle args) {
-        super(GraphPlace.class, R.layout.com_facebook_placepickerfragment, args);
-        setPlacePickerSettingsFromBundle(args);
-    }
-
-    /**
-     * Gets the location to search around. Either the location or the search text (or both) must be specified.
-     *
-     * @return the Location to search around
-     */
-    public Location getLocation() {
-        return location;
-    }
-
-    /**
-     * Sets the location to search around. Either the location or the search text (or both) must be specified.
-     *
-     * @param location the Location to search around
-     */
-    public void setLocation(Location location) {
-        this.location = location;
-    }
-
-    /**
-     * Gets the radius in meters around the location to search.
-     *
-     * @return the radius in meters
-     */
-    public int getRadiusInMeters() {
-        return radiusInMeters;
-    }
-
-    /**
-     * Sets the radius in meters around the location to search.
-     *
-     * @param radiusInMeters the radius in meters
-     */
-    public void setRadiusInMeters(int radiusInMeters) {
-        this.radiusInMeters = radiusInMeters;
-    }
-
-    /**
-     * Gets the number of results to retrieve.
-     *
-     * @return the number of results to retrieve
-     */
-    public int getResultsLimit() {
-        return resultsLimit;
-    }
-
-    /**
-     * Sets the number of results to retrieve.
-     *
-     * @param resultsLimit the number of results to retrieve
-     */
-    public void setResultsLimit(int resultsLimit) {
-        this.resultsLimit = resultsLimit;
-    }
-
-    /**
-     * Gets the search text (e.g., category, name) to search for. Either the location or the search
-     * text (or both) must be specified.
-     *
-     * @return the search text
-     */
-    public String getSearchText() {
-        return searchText;
-    }
-
-    /**
-     * Sets the search text (e.g., category, name) to search for. Either the location or the search
-     * text (or both) must be specified. If a search box is displayed, this will update its contents
-     * to the specified text.
-     *
-     * @param searchText the search text
-     */
-    public void setSearchText(String searchText) {
-        if (TextUtils.isEmpty(searchText)) {
-            searchText = null;
-        }
-        this.searchText = searchText;
-        if (this.searchBox != null) {
-            this.searchBox.setText(searchText);
-        }
-    }
-
-    /**
-     * Sets the search text and reloads the data in the control. This is used to provide search-box
-     * functionality where the user may be typing or editing text rapidly. It uses a timer to avoid repeated
-     * requerying, preferring to wait until the user pauses typing to refresh the data. Note that this
-     * method will NOT update the text in the search box, if any, as it is intended to be called as a result
-     * of changes to the search box (and is public to enable applications to provide their own search box
-     * UI instead of the default one).
-     *
-     * @param searchText                 the search text
-     * @param forceReloadEventIfSameText if true, will reload even if the search text has not changed; if false,
-     *                                   identical search text will not force a reload
-     */
-    public void onSearchBoxTextChanged(String searchText, boolean forceReloadEventIfSameText) {
-        if (!forceReloadEventIfSameText && Utility.stringsEqualOrEmpty(this.searchText, searchText)) {
-            return;
-        }
-
-        if (TextUtils.isEmpty(searchText)) {
-            searchText = null;
-        }
-        this.searchText = searchText;
-
-        // If search text is being set in response to user input, it is wasteful to send a new request
-        // with every keystroke. Send a request the first time the search text is set, then set up a 2-second timer
-        // and send whatever changes the user has made since then. (If nothing has changed
-        // in 2 seconds, we reset so the next change will cause an immediate re-query.)
-        hasSearchTextChangedSinceLastQuery = true;
-        if (searchTextTimer == null) {
-            searchTextTimer = createSearchTextTimer();
-        }
-    }
-
-    /**
-     * Gets the currently-selected place.
-     *
-     * @return the currently-selected place, or null if there is none
-     */
-    public GraphPlace getSelection() {
-        Collection<GraphPlace> selection = getSelectedGraphObjects();
-        return (selection != null && selection.size() > 0) ? selection.iterator().next() : null;
-    }
-
-    public void setSettingsFromBundle(Bundle inState) {
-        super.setSettingsFromBundle(inState);
-        setPlacePickerSettingsFromBundle(inState);
-    }
-
-    @Override
-    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
-        super.onInflate(activity, attrs, savedInstanceState);
-        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_place_picker_fragment);
-
-        setRadiusInMeters(a.getInt(R.styleable.com_facebook_place_picker_fragment_radius_in_meters, radiusInMeters));
-        setResultsLimit(a.getInt(R.styleable.com_facebook_place_picker_fragment_results_limit, resultsLimit));
-        if (a.hasValue(R.styleable.com_facebook_place_picker_fragment_results_limit)) {
-            setSearchText(a.getString(R.styleable.com_facebook_place_picker_fragment_search_text));
-        }
-        showSearchBox = a.getBoolean(R.styleable.com_facebook_place_picker_fragment_show_search_box, showSearchBox);
-
-        a.recycle();
-    }
-
-    @Override
-    public void onActivityCreated(final Bundle savedInstanceState) {
-        super.onActivityCreated(savedInstanceState);
-
-        ViewGroup view = (ViewGroup) getView();
-        if (showSearchBox) {
-            ViewStub stub = (ViewStub) view.findViewById(R.id.com_facebook_placepickerfragment_search_box_stub);
-            if (stub != null) {
-                searchBox = (EditText) stub.inflate();
-
-                // Put the list under the search box
-                RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
-                        RelativeLayout.LayoutParams.FILL_PARENT,
-                        RelativeLayout.LayoutParams.FILL_PARENT);
-                layoutParams.addRule(RelativeLayout.BELOW, R.id.search_box);
-
-                ListView listView = (ListView) view.findViewById(R.id.com_facebook_picker_list_view);
-                listView.setLayoutParams(layoutParams);
-
-                // If we need to, put the search box under the title bar.
-                if (view.findViewById(R.id.com_facebook_picker_title_bar) != null) {
-                    layoutParams = new RelativeLayout.LayoutParams(
-                            RelativeLayout.LayoutParams.FILL_PARENT,
-                            RelativeLayout.LayoutParams.WRAP_CONTENT);
-                    layoutParams.addRule(RelativeLayout.BELOW, R.id.com_facebook_picker_title_bar);
-
-                    searchBox.setLayoutParams(layoutParams);
-                }
-
-                searchBox.addTextChangedListener(new SearchTextWatcher());
-                if (!TextUtils.isEmpty(searchText)) {
-                    searchBox.setText(searchText);
-                }
-            }
-        }
-    }
-
-    @Override
-    public void onAttach(Activity activity) {
-        super.onAttach(activity);
-
-        if (searchBox != null) {
-            InputMethodManager imm = (InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);
-            imm.showSoftInput(searchBox, InputMethodManager.SHOW_IMPLICIT);
-        }
-    }
-
-    @Override
-    public void onDetach() {
-        super.onDetach();
-
-        if (searchBox != null) {
-            InputMethodManager imm = (InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);
-            imm.hideSoftInputFromWindow(searchBox.getWindowToken(), 0);
-        }
-    }
-
-    void saveSettingsToBundle(Bundle outState) {
-        super.saveSettingsToBundle(outState);
-
-        outState.putInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters);
-        outState.putInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit);
-        outState.putString(SEARCH_TEXT_BUNDLE_KEY, searchText);
-        outState.putParcelable(LOCATION_BUNDLE_KEY, location);
-        outState.putBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
-    }
-
-    @Override
-    void onLoadingData() {
-        hasSearchTextChangedSinceLastQuery = false;
-    }
-
-    @Override
-    Request getRequestForLoadData(Session session) {
-        return createRequest(location, radiusInMeters, resultsLimit, searchText, extraFields, session);
-    }
-
-    @Override
-    String getDefaultTitleText() {
-        return getString(R.string.com_facebook_nearby);
-    }
-
-    @Override
-    PickerFragmentAdapter<GraphPlace> createAdapter() {
-        PickerFragmentAdapter<GraphPlace> adapter = new PickerFragmentAdapter<GraphPlace>(
-                this.getActivity()) {
-            @Override
-            protected CharSequence getSubTitleOfGraphObject(GraphPlace graphObject) {
-                String category = graphObject.getCategory();
-                Integer wereHereCount = (Integer) graphObject.getProperty(WERE_HERE_COUNT);
-
-                String result = null;
-                if (category != null && wereHereCount != null) {
-                    result = getString(R.string.com_facebook_placepicker_subtitle_format, category, wereHereCount);
-                } else if (category == null && wereHereCount != null) {
-                    result = getString(R.string.com_facebook_placepicker_subtitle_were_here_only_format, wereHereCount);
-                } else if (category != null && wereHereCount == null) {
-                    result = getString(R.string.com_facebook_placepicker_subtitle_catetory_only_format, category);
-                }
-                return result;
-            }
-
-            @Override
-            protected int getGraphObjectRowLayoutId(GraphPlace graphObject) {
-                return R.layout.com_facebook_placepickerfragment_list_row;
-            }
-
-            @Override
-            protected int getDefaultPicture() {
-                return R.drawable.com_facebook_place_default_icon;
-            }
-
-        };
-        adapter.setShowCheckbox(false);
-        adapter.setShowPicture(getShowPictures());
-        return adapter;
-    }
-
-    @Override
-    LoadingStrategy createLoadingStrategy() {
-        return new AsNeededLoadingStrategy();
-    }
-
-    @Override
-    SelectionStrategy createSelectionStrategy() {
-        return new SingleSelectionStrategy();
-    }
-
-    private Request createRequest(Location location, int radiusInMeters, int resultsLimit, String searchText,
-            Set<String> extraFields,
-            Session session) {
-        Request request = Request.newPlacesSearchRequest(session, location, radiusInMeters, resultsLimit, searchText,
-                null);
-
-        Set<String> fields = new HashSet<String>(extraFields);
-        String[] requiredFields = new String[]{
-                ID,
-                NAME,
-                LOCATION,
-                CATEGORY,
-                WERE_HERE_COUNT
-        };
-        fields.addAll(Arrays.asList(requiredFields));
-
-        String pictureField = adapter.getPictureFieldSpecifier();
-        if (pictureField != null) {
-            fields.add(pictureField);
-        }
-
-        Bundle parameters = request.getParameters();
-        parameters.putString("fields", TextUtils.join(",", fields));
-        request.setParameters(parameters);
-
-        return request;
-    }
-
-    private void setPlacePickerSettingsFromBundle(Bundle inState) {
-        // We do this in a separate non-overridable method so it is safe to call from the constructor.
-        if (inState != null) {
-            setRadiusInMeters(inState.getInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters));
-            setResultsLimit(inState.getInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit));
-            if (inState.containsKey(SEARCH_TEXT_BUNDLE_KEY)) {
-                setSearchText(inState.getString(SEARCH_TEXT_BUNDLE_KEY));
-            }
-            if (inState.containsKey(LOCATION_BUNDLE_KEY)) {
-                Location location = inState.getParcelable(LOCATION_BUNDLE_KEY);
-                setLocation(location);
-            }
-            showSearchBox = inState.getBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
-        }
-    }
-
-    private Timer createSearchTextTimer() {
-        Timer timer = new Timer();
-        timer.schedule(new TimerTask() {
-            @Override
-            public void run() {
-                onSearchTextTimerTriggered();
-            }
-        }, 0, searchTextTimerDelayInMilliseconds);
-
-        return timer;
-    }
-
-    private void onSearchTextTimerTriggered() {
-        if (hasSearchTextChangedSinceLastQuery) {
-            Handler handler = new Handler(Looper.getMainLooper());
-            handler.post(new Runnable() {
-                @Override
-                public void run() {
-                    FacebookException error = null;
-                    try {
-                        loadData(true);
-                    } catch (FacebookException fe) {
-                        error = fe;
-                    } catch (Exception e) {
-                        error = new FacebookException(e);
-                    } finally {
-                        if (error != null) {
-                            OnErrorListener onErrorListener = getOnErrorListener();
-                            if (onErrorListener != null) {
-                                onErrorListener.onError(PlacePickerFragment.this, error);
-                            } else {
-                                Logger.log(LoggingBehavior.REQUESTS, TAG, "Error loading data : %s", error);
-                            }
-                        }
-                    }
-                }
-            });
-        } else {
-            // Nothing has changed in 2 seconds. Invalidate and forget about this timer.
-            // Next time the user types, we will fire a query immediately again.
-            searchTextTimer.cancel();
-            searchTextTimer = null;
-        }
-    }
-
-    private class AsNeededLoadingStrategy extends LoadingStrategy {
-        @Override
-        public void attach(GraphObjectAdapter<GraphPlace> adapter) {
-            super.attach(adapter);
-
-            this.adapter.setDataNeededListener(new GraphObjectAdapter.DataNeededListener() {
-                @Override
-                public void onDataNeeded() {
-                    // Do nothing if we are currently loading data . We will get notified again when that load finishes if the adapter still
-                    // needs more data. Otherwise, follow the next link.
-                    if (!loader.isLoading()) {
-                        loader.followNextLink();
-                    }
-                }
-            });
-        }
-
-        @Override
-        protected void onLoadFinished(GraphObjectPagingLoader<GraphPlace> loader,
-                SimpleGraphObjectCursor<GraphPlace> data) {
-            super.onLoadFinished(loader, data);
-
-            // We could be called in this state if we are clearing data or if we are being re-attached
-            // in the middle of a query.
-            if (data == null || loader.isLoading()) {
-                return;
-            }
-
-            hideActivityCircle();
-
-            if (data.isFromCache()) {
-                // Only the first page can be cached, since all subsequent pages will be round-tripped. Force
-                // a refresh of the first page before we allow paging to begin. If the first page produced
-                // no data, launch the refresh immediately, otherwise schedule it for later.
-                loader.refreshOriginalRequest(data.areMoreObjectsAvailable() ? CACHED_RESULT_REFRESH_DELAY : 0);
-            }
-        }
-    }
-
-    private class SearchTextWatcher implements TextWatcher {
-
-        @Override
-        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
-        }
-
-        @Override
-        public void onTextChanged(CharSequence s, int start, int before, int count) {
-            onSearchBoxTextChanged(s.toString(), false);
-        }
-
-        @Override
-        public void afterTextChanged(Editable s) {
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/widget/ProfilePictureView.java b/facebook/src/com/facebook/widget/ProfilePictureView.java
deleted file mode 100644
index b6878588b..000000000
--- a/facebook/src/com/facebook/widget/ProfilePictureView.java
+++ /dev/null
@@ -1,520 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.os.Bundle;
-import android.os.Parcelable;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.ViewGroup;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-import com.facebook.FacebookException;
-import com.facebook.LoggingBehavior;
-import com.facebook.android.R;
-import com.facebook.internal.Logger;
-import com.facebook.internal.Utility;
-
-import java.net.MalformedURLException;
-
-/**
- * View that displays the profile photo of a supplied profile ID, while conforming
- * to user specified dimensions.
- */
-public class ProfilePictureView extends FrameLayout {
-
-    /**
-     * Callback interface that will be called when a network or other error is encountered
-     * while retrieving profile pictures.
-     */
-    public interface OnErrorListener {
-        /**
-         * Called when a network or other error is encountered.
-         * @param error     a FacebookException representing the error that was encountered.
-         */
-        void onError(FacebookException error);
-    }
-
-    /**
-     * Tag used when logging calls are made by ProfilePictureView
-     */
-    public static final String TAG = ProfilePictureView.class.getSimpleName();
-
-    /**
-     * Indicates that the specific size of the View will be set via layout params.
-     * ProfilePictureView will default to NORMAL X NORMAL, if the layout params set on
-     * this instance do not have a fixed size.
-     * Used in calls to setPresetSize() and getPresetSize().
-     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
-     */
-    public static final int CUSTOM = -1;
-
-    /**
-     * Indicates that the profile image should fit in a SMALL X SMALL space, regardless
-     * of whether the cropped or un-cropped version is chosen.
-     * Used in calls to setPresetSize() and getPresetSize().
-     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
-     */
-    public static final int SMALL = -2;
-
-    /**
-     * Indicates that the profile image should fit in a NORMAL X NORMAL space, regardless
-     * of whether the cropped or un-cropped version is chosen.
-     * Used in calls to setPresetSize() and getPresetSize().
-     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
-     */
-    public static final int NORMAL = -3;
-
-    /**
-     * Indicates that the profile image should fit in a LARGE X LARGE space, regardless
-     * of whether the cropped or un-cropped version is chosen.
-     * Used in calls to setPresetSize() and getPresetSize().
-     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
-     */
-    public static final int LARGE = -4;
-
-    private static final int MIN_SIZE = 1;
-    private static final boolean IS_CROPPED_DEFAULT_VALUE = true;
-    private static final String SUPER_STATE_KEY = "ProfilePictureView_superState";
-    private static final String PROFILE_ID_KEY = "ProfilePictureView_profileId";
-    private static final String PRESET_SIZE_KEY = "ProfilePictureView_presetSize";
-    private static final String IS_CROPPED_KEY = "ProfilePictureView_isCropped";
-    private static final String BITMAP_KEY = "ProfilePictureView_bitmap";
-    private static final String BITMAP_WIDTH_KEY = "ProfilePictureView_width";
-    private static final String BITMAP_HEIGHT_KEY = "ProfilePictureView_height";
-    private static final String PENDING_REFRESH_KEY = "ProfilePictureView_refresh";
-
-    private String profileId;
-    private int queryHeight = ImageRequest.UNSPECIFIED_DIMENSION;
-    private int queryWidth = ImageRequest.UNSPECIFIED_DIMENSION;
-    private boolean isCropped = IS_CROPPED_DEFAULT_VALUE;
-    private Bitmap imageContents;
-    private ImageView image;
-    private int presetSizeType = CUSTOM;
-    private ImageRequest lastRequest;
-    private OnErrorListener onErrorListener;
-
-    /**
-     * Constructor
-     *
-     * @param context Context for this View
-     */
-    public ProfilePictureView(Context context) {
-        super(context);
-        initialize(context);
-    }
-
-    /**
-     * Constructor
-     *
-     * @param context Context for this View
-     * @param attrs   AttributeSet for this View.
-     *                The attribute 'preset_size' is processed here
-     */
-    public ProfilePictureView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        initialize(context);
-        parseAttributes(attrs);
-    }
-
-    /**
-     * Constructor
-     *
-     * @param context  Context for this View
-     * @param attrs    AttributeSet for this View.
-     *                 The attribute 'preset_size' is processed here
-     * @param defStyle Default style for this View
-     */
-    public ProfilePictureView(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        initialize(context);
-        parseAttributes(attrs);
-    }
-
-    /**
-     * Gets the current preset size type
-     *
-     * @return The current preset size type, if set; CUSTOM if not
-     */
-    public final int getPresetSize() {
-        return presetSizeType;
-    }
-
-    /**
-     * Apply a preset size to this profile photo
-     *
-     * @param sizeType The size type to apply: SMALL, NORMAL or LARGE
-     */
-    public final void setPresetSize(int sizeType) {
-        switch (sizeType) {
-            case SMALL:
-            case NORMAL:
-            case LARGE:
-            case CUSTOM:
-                this.presetSizeType = sizeType;
-                break;
-
-            default:
-                throw new IllegalArgumentException("Must use a predefined preset size");
-        }
-
-        requestLayout();
-    }
-
-    /**
-     * Indicates whether the cropped version of the profile photo has been chosen
-     *
-     * @return True if the cropped version is chosen, false if not.
-     */
-    public final boolean isCropped() {
-        return isCropped;
-    }
-
-    /**
-     * Sets the profile photo to be the cropped version, or the original version
-     *
-     * @param showCroppedVersion True to select the cropped version
-     *                           False to select the standard version
-     */
-    public final void setCropped(boolean showCroppedVersion) {
-        isCropped = showCroppedVersion;
-        // No need to force the refresh since we will catch the change in required dimensions
-        refreshImage(false);
-    }
-
-    /**
-     * Returns the profile Id for the current profile photo
-     *
-     * @return The profile Id
-     */
-    public final String getProfileId() {
-        return profileId;
-    }
-
-    /**
-     * Sets the profile Id for this profile photo
-     *
-     * @param profileId The profileId
-     *               NULL/Empty String will show the blank profile photo
-     */
-    public final void setProfileId(String profileId) {
-        boolean force = false;
-        if (Utility.isNullOrEmpty(this.profileId) || !this.profileId.equalsIgnoreCase(profileId)) {
-            // Clear out the old profilePicture before requesting for the new one.
-            setBlankProfilePicture();
-            force = true;
-        }
-
-        this.profileId = profileId;
-        refreshImage(force);
-    }
-
-    /**
-     * Returns the current OnErrorListener for this instance of ProfilePictureView
-     *
-     * @return The OnErrorListener
-     */
-    public final OnErrorListener getOnErrorListener() {
-        return onErrorListener;
-    }
-
-    /**
-     * Sets an OnErrorListener for this instance of ProfilePictureView to call into when
-     * certain exceptions occur.
-     *
-     * @param onErrorListener The listener object to set
-     */
-    public final void setOnErrorListener(OnErrorListener onErrorListener) {
-        this.onErrorListener = onErrorListener;
-    }
-
-    /**
-     * Overriding onMeasure to handle the case where WRAP_CONTENT might be
-     * specified in the layout. Since we don't know the dimensions of the profile
-     * photo, we need to handle this case specifically.
-     * <p/>
-     * The approach is to default to a NORMAL sized amount of space in the case that
-     * a preset size is not specified. This logic is applied to both width and height
-     */
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        ViewGroup.LayoutParams params = getLayoutParams();
-        boolean customMeasure = false;
-        int newHeight = MeasureSpec.getSize(heightMeasureSpec);
-        int newWidth = MeasureSpec.getSize(widthMeasureSpec);
-        if (MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY &&
-                params.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
-            newHeight = getPresetSizeInPixels(true); // Default to a preset size
-            heightMeasureSpec = MeasureSpec.makeMeasureSpec(newHeight, MeasureSpec.EXACTLY);
-            customMeasure = true;
-        }
-
-        if (MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY &&
-                params.width == ViewGroup.LayoutParams.WRAP_CONTENT) {
-            newWidth = getPresetSizeInPixels(true); // Default to a preset size
-            widthMeasureSpec = MeasureSpec.makeMeasureSpec(newWidth, MeasureSpec.EXACTLY);
-            customMeasure = true;
-        }
-
-        if (customMeasure) {
-            // Since we are providing custom dimensions, we need to handle the measure
-            // phase from here
-            setMeasuredDimension(newWidth, newHeight);
-            measureChildren(widthMeasureSpec, heightMeasureSpec);
-        } else {
-            // Rely on FrameLayout to do the right thing
-            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
-        }
-    }
-
-    /**
-     * In addition to calling super.Layout(), we also attempt to get a new image that
-     * is properly size for the layout dimensions
-     */
-    @Override
-    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-        super.onLayout(changed, left, top, right, bottom);
-
-        // See if the image needs redrawing
-        refreshImage(false);
-    }
-
-    /**
-     * Some of the current state is returned as a Bundle to allow quick restoration
-     * of the ProfilePictureView object in scenarios like orientation changes.
-     * @return a Parcelable containing the current state
-     */
-    @Override
-    protected Parcelable onSaveInstanceState() {
-        Parcelable superState = super.onSaveInstanceState();
-        Bundle instanceState = new Bundle();
-        instanceState.putParcelable(SUPER_STATE_KEY, superState);
-        instanceState.putString(PROFILE_ID_KEY, profileId);
-        instanceState.putInt(PRESET_SIZE_KEY, presetSizeType);
-        instanceState.putBoolean(IS_CROPPED_KEY, isCropped);
-        instanceState.putParcelable(BITMAP_KEY, imageContents);
-        instanceState.putInt(BITMAP_WIDTH_KEY, queryWidth);
-        instanceState.putInt(BITMAP_HEIGHT_KEY, queryHeight);
-        instanceState.putBoolean(PENDING_REFRESH_KEY, lastRequest != null);
-
-        return instanceState;
-    }
-
-    /**
-     * If the passed in state is a Bundle, an attempt is made to restore from it.
-     * @param state a Parcelable containing the current state
-     */
-    @Override
-    protected void onRestoreInstanceState(Parcelable state) {
-        if (state.getClass() != Bundle.class) {
-            super.onRestoreInstanceState(state);
-        } else {
-            Bundle instanceState = (Bundle)state;
-            super.onRestoreInstanceState(instanceState.getParcelable(SUPER_STATE_KEY));
-
-            profileId = instanceState.getString(PROFILE_ID_KEY);
-            presetSizeType = instanceState.getInt(PRESET_SIZE_KEY);
-            isCropped = instanceState.getBoolean(IS_CROPPED_KEY);
-            queryWidth = instanceState.getInt(BITMAP_WIDTH_KEY);
-            queryHeight = instanceState.getInt(BITMAP_HEIGHT_KEY);
-
-            setImageBitmap((Bitmap)instanceState.getParcelable(BITMAP_KEY));
-
-            if (instanceState.getBoolean(PENDING_REFRESH_KEY)) {
-                refreshImage(true);
-            }
-        }
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        super.onDetachedFromWindow();
-
-        // Null out lastRequest. This way, when the response is returned, we can ascertain
-        // that the view is detached and hence should not attempt to update its contents.
-        lastRequest = null;
-    }
-
-    private void initialize(Context context) {
-        // We only want our ImageView in here. Nothing else is permitted
-        removeAllViews();
-
-        image = new ImageView(context);
-
-        LayoutParams imageLayout = new LayoutParams(
-                LayoutParams.MATCH_PARENT,
-                LayoutParams.MATCH_PARENT);
-
-        image.setLayoutParams(imageLayout);
-
-        // We want to prevent up-scaling the image, but still have it fit within
-        // the layout bounds as best as possible.
-        image.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
-        addView(image);
-    }
-
-    private void parseAttributes(AttributeSet attrs) {
-        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.com_facebook_profile_picture_view);
-        setPresetSize(a.getInt(R.styleable.com_facebook_profile_picture_view_preset_size, CUSTOM));
-        isCropped = a.getBoolean(R.styleable.com_facebook_profile_picture_view_is_cropped, IS_CROPPED_DEFAULT_VALUE);
-        a.recycle();
-    }
-
-    private void refreshImage(boolean force) {
-        boolean changed = updateImageQueryParameters();
-        // Note: do not use Utility.isNullOrEmpty here as this will cause the Eclipse
-        // Graphical Layout editor to fail in some cases
-        if (profileId == null || profileId.length() == 0 ||
-                ((queryWidth == ImageRequest.UNSPECIFIED_DIMENSION) &&
-                        (queryHeight == ImageRequest.UNSPECIFIED_DIMENSION))) {
-            setBlankProfilePicture();
-        } else if (changed || force) {
-            sendImageRequest(true);
-        }
-    }
-
-    private void setBlankProfilePicture() {
-        int blankImageResource = isCropped() ?
-                R.drawable.com_facebook_profile_picture_blank_square :
-                R.drawable.com_facebook_profile_picture_blank_portrait;
-        setImageBitmap( BitmapFactory.decodeResource(getResources(), blankImageResource));
-    }
-
-    private void setImageBitmap(Bitmap imageBitmap) {
-        if (image != null && imageBitmap != null) {
-            imageContents = imageBitmap; // Hold for save-restore cycles
-            image.setImageBitmap(imageBitmap);
-        }
-    }
-
-    private void sendImageRequest(boolean allowCachedResponse) {
-        try {
-            ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
-                    getContext(),
-                    ImageRequest.getProfilePictureUrl(profileId, queryWidth,  queryHeight));
-
-            ImageRequest request = requestBuilder.setAllowCachedRedirects(allowCachedResponse)
-                    .setCallerTag(this)
-                    .setCallback(
-                    new ImageRequest.Callback() {
-                        @Override
-                        public void onCompleted(ImageResponse response) {
-                            processResponse(response);
-                        }
-                    })
-                    .build();
-
-            // Make sure to cancel the old request before sending the new one to prevent
-            // accidental cancellation of the new request. This could happen if the URL and
-            // caller tag stayed the same.
-            if (lastRequest != null) {
-                ImageDownloader.cancelRequest(lastRequest);
-            }
-            lastRequest = request;
-
-            ImageDownloader.downloadAsync(request);
-        } catch (MalformedURLException e) {
-            Logger.log(LoggingBehavior.REQUESTS, Log.ERROR, TAG, e.toString());
-        }
-    }
-
-    private void processResponse(ImageResponse response) {
-        // First check if the response is for the right request. We may have:
-        // 1. Sent a new request, thus super-ceding this one.
-        // 2. Detached this view, in which case the response should be discarded.
-        if (response.getRequest() == lastRequest) {
-            lastRequest = null;
-            Bitmap responseImage = response.getBitmap();
-            Exception error = response.getError();
-            if (error != null) {
-                OnErrorListener listener = onErrorListener;
-                if (listener != null) {
-                    listener.onError(new FacebookException(
-                            "Error in downloading profile picture for profileId: " + getProfileId(), error));
-                } else {
-                    Logger.log(LoggingBehavior.REQUESTS, Log.ERROR, TAG, error.toString());
-                }
-            } else if (responseImage != null) {
-                setImageBitmap(responseImage);
-
-                if (response.isCachedRedirect()) {
-                    sendImageRequest(false);
-                }
-            }
-        }
-    }
-
-    private boolean updateImageQueryParameters() {
-        int newHeightPx = getHeight();
-        int newWidthPx = getWidth();
-        if (newWidthPx < MIN_SIZE || newHeightPx < MIN_SIZE) {
-            // Not enough space laid out for this View yet. Or something else is awry.
-            return false;
-        }
-
-        int presetSize = getPresetSizeInPixels(false);
-        if (presetSize != ImageRequest.UNSPECIFIED_DIMENSION) {
-            newWidthPx = presetSize;
-            newHeightPx = presetSize;
-        }
-
-        // The cropped version is square
-        // If full version is desired, then only one dimension is required.
-        if (newWidthPx <= newHeightPx) {
-            newHeightPx = isCropped() ? newWidthPx : ImageRequest.UNSPECIFIED_DIMENSION;
-        } else {
-            newWidthPx = isCropped() ? newHeightPx : ImageRequest.UNSPECIFIED_DIMENSION;
-        }
-
-        boolean changed = (newWidthPx != queryWidth) || (newHeightPx != queryHeight);
-
-        queryWidth = newWidthPx;
-        queryHeight = newHeightPx;
-
-        return changed;
-    }
-
-    private int getPresetSizeInPixels(boolean forcePreset) {
-        int dimensionId;
-        switch (presetSizeType) {
-            case SMALL:
-                dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_small;
-                break;
-            case NORMAL:
-                dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_normal;
-                break;
-            case LARGE:
-                dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_large;
-                break;
-            case CUSTOM:
-                if (!forcePreset) {
-                    return ImageRequest.UNSPECIFIED_DIMENSION;
-                } else {
-                    dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_normal;
-                    break;
-                }
-            default:
-                return ImageRequest.UNSPECIFIED_DIMENSION;
-        }
-
-        return getResources().getDimensionPixelSize(dimensionId);
-    }
-}
diff --git a/facebook/src/com/facebook/widget/SimpleGraphObjectCursor.java b/facebook/src/com/facebook/widget/SimpleGraphObjectCursor.java
deleted file mode 100644
index 04c98ba6d..000000000
--- a/facebook/src/com/facebook/widget/SimpleGraphObjectCursor.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.database.CursorIndexOutOfBoundsException;
-import com.facebook.model.GraphObject;
-
-import java.util.ArrayList;
-import java.util.Collection;
-
-class SimpleGraphObjectCursor<T extends GraphObject> implements GraphObjectCursor<T> {
-    private int pos = -1;
-    private boolean closed = false;
-    private ArrayList<T> graphObjects = new ArrayList<T>();
-    private boolean moreObjectsAvailable = false;
-    private boolean fromCache = false;
-
-    SimpleGraphObjectCursor() {
-    }
-
-    SimpleGraphObjectCursor(SimpleGraphObjectCursor<T> other) {
-        pos = other.pos;
-        closed = other.closed;
-        graphObjects = new ArrayList<T>();
-        graphObjects.addAll(other.graphObjects);
-        fromCache = other.fromCache;
-
-        // We do not copy observers.
-    }
-
-    public void addGraphObjects(Collection<T> graphObjects, boolean fromCache) {
-        this.graphObjects.addAll(graphObjects);
-        // We consider this cached if ANY results were from the cache.
-        this.fromCache |= fromCache;
-    }
-
-    public boolean isFromCache() {
-        return fromCache;
-    }
-
-    public void setFromCache(boolean fromCache) {
-        this.fromCache = fromCache;
-    }
-
-    public boolean areMoreObjectsAvailable() {
-        return moreObjectsAvailable;
-    }
-
-    public void setMoreObjectsAvailable(boolean moreObjectsAvailable) {
-        this.moreObjectsAvailable = moreObjectsAvailable;
-    }
-
-    @Override
-    public int getCount() {
-        return graphObjects.size();
-    }
-
-    @Override
-    public int getPosition() {
-        return pos;
-    }
-
-    @Override
-    public boolean move(int offset) {
-        return moveToPosition(pos + offset);
-    }
-
-    @Override
-    public boolean moveToPosition(int position) {
-        final int count = getCount();
-        if (position >= count) {
-            pos = count;
-            return false;
-        }
-
-        if (position < 0) {
-            pos = -1;
-            return false;
-        }
-
-        pos = position;
-        return true;
-    }
-
-    @Override
-    public boolean moveToFirst() {
-        return moveToPosition(0);
-    }
-
-    @Override
-    public boolean moveToLast() {
-        return moveToPosition(getCount() - 1);
-    }
-
-    @Override
-    public boolean moveToNext() {
-        return moveToPosition(pos + 1);
-    }
-
-    @Override
-    public boolean moveToPrevious() {
-        return moveToPosition(pos - 1);
-    }
-
-    @Override
-    public boolean isFirst() {
-        return (pos == 0) && (getCount() != 0);
-    }
-
-    @Override
-    public boolean isLast() {
-        final int count = getCount();
-        return (pos == (count - 1)) && (count != 0);
-    }
-
-    @Override
-    public boolean isBeforeFirst() {
-        return (getCount() == 0) || (pos == -1);
-    }
-
-    @Override
-    public boolean isAfterLast() {
-        final int count = getCount();
-        return (count == 0) || (pos == count);
-    }
-
-    @Override
-    public T getGraphObject() {
-        if (pos < 0) {
-            throw new CursorIndexOutOfBoundsException("Before first object.");
-        }
-        if (pos >= graphObjects.size()) {
-            throw new CursorIndexOutOfBoundsException("After last object.");
-        }
-        return graphObjects.get(pos);
-    }
-
-    @Override
-    public void close() {
-        closed = true;
-    }
-
-    @Override
-    public boolean isClosed() {
-        return closed;
-    }
-
-}
diff --git a/facebook/src/com/facebook/widget/UrlRedirectCache.java b/facebook/src/com/facebook/widget/UrlRedirectCache.java
deleted file mode 100644
index bd4598983..000000000
--- a/facebook/src/com/facebook/widget/UrlRedirectCache.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.content.Context;
-import com.facebook.internal.FileLruCache;
-import com.facebook.internal.Utility;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.net.MalformedURLException;
-import java.net.URL;
-
-class UrlRedirectCache {
-    static final String TAG = UrlRedirectCache.class.getSimpleName();
-    private static final String REDIRECT_CONTENT_TAG = TAG + "_Redirect";
-
-    private volatile static FileLruCache urlRedirectCache;
-
-    synchronized static FileLruCache getCache(Context context) throws IOException{
-        if (urlRedirectCache == null) {
-            urlRedirectCache = new FileLruCache(context.getApplicationContext(), TAG, new FileLruCache.Limits());
-        }
-        return urlRedirectCache;
-    }
-
-    static URL getRedirectedUrl(Context context, URL url) {
-        if (url == null) {
-            return null;
-        }
-
-        String urlString = url.toString();
-        URL finalUrl = null;
-        InputStreamReader reader = null;
-        try {
-            InputStream stream;
-            FileLruCache cache = getCache(context);
-            boolean redirectExists = false;
-            while ((stream = cache.get(urlString, REDIRECT_CONTENT_TAG)) != null) {
-                redirectExists = true;
-
-                // Get the redirected url
-                reader = new InputStreamReader(stream);
-                char[] buffer = new char[128];
-                int bufferLength;
-                StringBuilder urlBuilder = new StringBuilder();
-                while ((bufferLength = reader.read(buffer, 0, buffer.length)) > 0) {
-                    urlBuilder.append(buffer, 0, bufferLength);
-                }
-                Utility.closeQuietly(reader);
-
-                // Iterate to the next url in the redirection
-                urlString = urlBuilder.toString();
-            }
-
-            if (redirectExists) {
-                finalUrl = new URL(urlString);
-            }
-        } catch (MalformedURLException e) {
-            // caching is best effort, so ignore the exception
-        } catch (IOException ioe) {
-        } finally {
-            Utility.closeQuietly(reader);
-        }
-
-        return finalUrl;
-    }
-
-    static void cacheUrlRedirect(Context context, URL fromUrl, URL toUrl) {
-        if (fromUrl == null || toUrl == null) {
-            return;
-        }
-
-        OutputStream redirectStream = null;
-        try {
-            FileLruCache cache = getCache(context);
-            redirectStream = cache.openPutStream(fromUrl.toString(), REDIRECT_CONTENT_TAG);
-            redirectStream.write(toUrl.toString().getBytes());
-        } catch (IOException e) {
-            // Caching is best effort
-        } finally {
-            Utility.closeQuietly(redirectStream);
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/widget/WorkQueue.java b/facebook/src/com/facebook/widget/WorkQueue.java
deleted file mode 100644
index d5e8a4640..000000000
--- a/facebook/src/com/facebook/widget/WorkQueue.java
+++ /dev/null
@@ -1,221 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import com.facebook.Settings;
-
-import java.util.concurrent.Executor;
-
-class WorkQueue {
-    public static final int DEFAULT_MAX_CONCURRENT = 8;
-
-    private final Object workLock = new Object();
-    private WorkNode pendingJobs;
-
-    private final int maxConcurrent;
-    private final Executor executor;
-
-    private WorkNode runningJobs = null;
-    private int runningCount = 0;
-
-    WorkQueue() {
-        this(DEFAULT_MAX_CONCURRENT);
-    }
-
-    WorkQueue(int maxConcurrent) {
-        this(maxConcurrent, Settings.getExecutor());
-    }
-
-    WorkQueue(int maxConcurrent, Executor executor) {
-        this.maxConcurrent = maxConcurrent;
-        this.executor = executor;
-    }
-
-    WorkItem addActiveWorkItem(Runnable callback) {
-        return addActiveWorkItem(callback, true);
-    }
-
-    WorkItem addActiveWorkItem(Runnable callback, boolean addToFront) {
-        WorkNode node = new WorkNode(callback);
-        synchronized (workLock) {
-            pendingJobs = node.addToList(pendingJobs, addToFront);
-        }
-
-        startItem();
-        return node;
-    }
-
-    void validate() {
-        synchronized (workLock) {
-            // Verify that all running items know they are running, and counts match
-            int count = 0;
-
-            if (runningJobs != null) {
-                WorkNode walk = runningJobs;
-                do {
-                    walk.verify(true);
-                    count++;
-                    walk = walk.getNext();
-                } while (walk != runningJobs);
-            }
-
-            assert runningCount == count;
-        }
-    }
-
-    private void startItem() {
-        finishItemAndStartNew(null);
-    }
-
-    private void finishItemAndStartNew(WorkNode finished) {
-        WorkNode ready = null;
-
-        synchronized (workLock) {
-            if (finished != null) {
-                runningJobs = finished.removeFromList(runningJobs);
-                runningCount--;
-            }
-
-            if (runningCount < maxConcurrent) {
-                ready = pendingJobs; // Head of the pendingJobs queue
-                if (ready != null) {
-                    // The Queue reassignments are necessary since 'ready' might have been
-                    // added / removed from the front of either queue, which changes its
-                    // respective head.
-                    pendingJobs = ready.removeFromList(pendingJobs);
-                    runningJobs = ready.addToList(runningJobs, false);
-                    runningCount++;
-
-                    ready.setIsRunning(true);
-                }
-            }
-        }
-
-        if (ready != null) {
-            execute(ready);
-        }
-    }
-
-    private void execute(final WorkNode node) {
-        executor.execute(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    node.getCallback().run();
-                } finally {
-                    finishItemAndStartNew(node);
-                }
-            }
-        });
-    }
-
-    private class WorkNode implements WorkItem {
-        private final Runnable callback;
-        private WorkNode next;
-        private WorkNode prev;
-        private boolean isRunning;
-
-        WorkNode(Runnable callback) {
-            this.callback = callback;
-        }
-
-        @Override
-        public boolean cancel() {
-            synchronized (workLock) {
-                if (!isRunning()) {
-                    pendingJobs = removeFromList(pendingJobs);
-                    return true;
-                }
-            }
-
-            return false;
-        }
-
-        @Override
-        public void moveToFront() {
-            synchronized (workLock) {
-                if (!isRunning()) {
-                    pendingJobs = removeFromList(pendingJobs);
-                    pendingJobs = addToList(pendingJobs, true);
-                }
-            }
-        }
-
-        @Override
-        public boolean isRunning() {
-            return isRunning;
-        }
-
-        Runnable getCallback() {
-            return callback;
-        }
-
-        WorkNode getNext() {
-            return next;
-        }
-
-        void setIsRunning(boolean isRunning) {
-            this.isRunning = isRunning;
-        }
-
-        WorkNode addToList(WorkNode list, boolean addToFront) {
-            assert next == null;
-            assert prev == null;
-
-            if (list == null) {
-                list = next = prev = this;
-            } else {
-                next = list;
-                prev = list.prev;
-                next.prev = prev.next = this;
-            }
-
-            return addToFront ? this : list;
-        }
-
-        WorkNode removeFromList(WorkNode list) {
-            assert next != null;
-            assert prev != null;
-
-            if (list == this) {
-                if (next == this) {
-                    list = null;
-                } else {
-                    list = next;
-                }
-            }
-
-            next.prev = prev;
-            prev.next = next;
-            next = prev = null;
-
-            return list;
-        }
-
-        void verify(boolean shouldBeRunning) {
-            assert prev.next == this;
-            assert next.prev == this;
-            assert isRunning() == shouldBeRunning;
-        }
-    }
-
-    interface WorkItem {
-        boolean cancel();
-        boolean isRunning();
-        void moveToFront();
-    }
-}
