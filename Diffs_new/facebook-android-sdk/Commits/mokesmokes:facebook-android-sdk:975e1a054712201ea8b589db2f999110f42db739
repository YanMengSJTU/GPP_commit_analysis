diff --git a/facebook/src/com/facebook/AuthorizationClient.java b/facebook/src/com/facebook/AuthorizationClient.java
index 51b178c9a..a6e63b34e 100644
--- a/facebook/src/com/facebook/AuthorizationClient.java
+++ b/facebook/src/com/facebook/AuthorizationClient.java
@@ -26,6 +26,7 @@
 import android.os.Bundle;
 import android.text.TextUtils;
 import android.webkit.CookieSyncManager;
+
 import com.facebook.android.R;
 import com.facebook.internal.AnalyticsEvents;
 import com.facebook.internal.NativeProtocol;
@@ -36,6 +37,7 @@
 import com.facebook.model.GraphObjectList;
 import com.facebook.model.GraphUser;
 import com.facebook.widget.WebDialog;
+
 import org.json.JSONException;
 import org.json.JSONObject;
 
@@ -211,9 +213,11 @@ boolean checkInternetPermission() {
 
         int permissionCheck = checkPermission(Manifest.permission.INTERNET);
         if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
-            String errorType = context.getString(R.string.com_facebook_internet_permission_error_title);
-            String errorDescription = context.getString(R.string.com_facebook_internet_permission_error_message);
-            complete(Result.createErrorResult(pendingRequest, errorType, errorDescription));
+            //String errorType = context.getString(R.string.com_facebook_internet_permission_error_title);
+            //String errorDescription = context.getString(R.string.com_facebook_internet_permission_error_message);
+            String errorType = context.getString(Utility.resId_errorTitle);
+            String errorDescription = context.getString(Utility.resId_errorMessage);
+        	complete(Result.createErrorResult(pendingRequest, errorType, errorDescription));
 
             return false;
         }
diff --git a/facebook/src/com/facebook/FacebookRequestError.java b/facebook/src/com/facebook/FacebookRequestError.java
index 937e2b580..9e2d2444a 100644
--- a/facebook/src/com/facebook/FacebookRequestError.java
+++ b/facebook/src/com/facebook/FacebookRequestError.java
@@ -141,21 +141,21 @@ private FacebookRequestError(int requestStatusCode, int errorCode,
                 errorCategory = Category.THROTTLING;
             } else if (errorCode == EC_PERMISSION_DENIED || EC_RANGE_PERMISSION.contains(errorCode)) {
                 errorCategory = Category.PERMISSION;
-                messageId = R.string.com_facebook_requesterror_permissions;
+                messageId = -1;
             } else if (errorCode == EC_INVALID_SESSION || errorCode == EC_INVALID_TOKEN) {
                 if (subErrorCode == EC_USER_CHECKPOINTED || subErrorCode == EC_UNCONFIRMED_USER) {
                     errorCategory = Category.AUTHENTICATION_RETRY;
-                    messageId = R.string.com_facebook_requesterror_web_login;
+                    messageId = -1;
                     shouldNotify = true;
                 } else {
                     errorCategory = Category.AUTHENTICATION_REOPEN_SESSION;
 
                     if ((subErrorCode == EC_APP_NOT_INSTALLED) || (subErrorCode == EC_EXPIRED)) {
-                        messageId = R.string.com_facebook_requesterror_relogin;
+                        messageId = -1;
                     } else if (subErrorCode == EC_PASSWORD_CHANGED) {
-                        messageId = R.string.com_facebook_requesterror_password_changed;
+                        messageId = -1;
                     } else {
-                        messageId = R.string.com_facebook_requesterror_reconnect;
+                        messageId = -1;
                         shouldNotify = true;
                     }
                 }
diff --git a/facebook/src/com/facebook/LoginActivity.java b/facebook/src/com/facebook/LoginActivity.java
index 096f00eae..786767052 100644
--- a/facebook/src/com/facebook/LoginActivity.java
+++ b/facebook/src/com/facebook/LoginActivity.java
@@ -21,7 +21,9 @@
 import android.os.Bundle;
 import android.util.Log;
 import android.view.View;
+
 import com.facebook.android.R;
+import com.facebook.internal.Utility;
 
 /**
  * This Activity is a necessary part of the overall Facebook login process
@@ -54,7 +56,8 @@
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        setContentView(R.layout.com_facebook_login_activity_layout);
+        //setContentView(R.layout.com_facebook_login_activity_layout);
+        setContentView(Utility.resId_loginActivityLayout);
 
         if (savedInstanceState != null) {
             callingPackage = savedInstanceState.getString(SAVED_CALLING_PKG_KEY);
@@ -75,12 +78,14 @@ public void onCompleted(AuthorizationClient.Result outcome) {
         authorizationClient.setBackgroundProcessingListener(new AuthorizationClient.BackgroundProcessingListener() {
             @Override
             public void onBackgroundProcessingStarted() {
-                findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.VISIBLE);
+                //findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.VISIBLE);
+            	findViewById(Utility.resId_loginActivityProgressBar).setVisibility(View.VISIBLE);
             }
 
             @Override
             public void onBackgroundProcessingStopped() {
-                findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.GONE);
+                //findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.GONE);
+            	findViewById(Utility.resId_loginActivityProgressBar).setVisibility(View.GONE);
             }
         });
     }
@@ -122,7 +127,8 @@ public void onPause() {
         super.onPause();
 
         authorizationClient.cancelCurrentHandler();
-        findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.GONE);
+        //findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.GONE);
+        findViewById(Utility.resId_loginActivityProgressBar).setVisibility(View.GONE);
     }
 
     @Override
diff --git a/facebook/src/com/facebook/internal/Utility.java b/facebook/src/com/facebook/internal/Utility.java
index 0bebf6ed9..43b09ec03 100644
--- a/facebook/src/com/facebook/internal/Utility.java
+++ b/facebook/src/com/facebook/internal/Utility.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.content.res.Resources;
 import android.net.Uri;
 import android.os.Bundle;
 import android.os.Parcelable;
@@ -26,9 +27,11 @@
 import android.util.Log;
 import android.webkit.CookieManager;
 import android.webkit.CookieSyncManager;
+
 import com.facebook.*;
 import com.facebook.android.BuildConfig;
 import com.facebook.model.GraphObject;
+
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -64,6 +67,95 @@
 
     private static Map<String, FetchedAppSettings> fetchedAppSettings =
             new ConcurrentHashMap<String, FetchedAppSettings>();
+    
+    // *************** APPCELERATOR TITANIUM CUSTOMIZATION ***************************
+    // Resource IDs used in com.facebook package. Fetch the resource id using Resources.getIdentifier, since
+    // we merge resources into Titanium project and don't have access to R here.
+    public static int resId_blueColor = -1;
+    public static int resId_chooseFriends = -1;
+    public static int resId_close = -1;
+    public static int resId_errorMessage = -1;
+    public static int resId_errorTitle = -1;
+    public static int resId_friendPickerFragment = -1;
+    public static int resId_friendPickerFragmentMultiSelect = -1;
+    public static int resId_friendPickerFragmentStyleable = -1;
+    public static int resId_loading = -1;
+    public static int resId_loginActivityLayout = -1;
+    public static int resId_loginActivityProgressBar = -1;
+    public static int resId_loginButtonImage = -1;
+    public static int resId_loginView = -1;
+    public static int resId_loginViewCancelAction = -1;
+    public static int resId_loginViewConfirmLogout = -1;
+    public static int resId_loginViewFetchUserInfo = -1;
+    public static int resId_loginViewHeight = -1;
+    public static int resId_loginViewPaddingBottom = -1;
+    public static int resId_loginViewPaddingLeft = -1;
+    public static int resId_loginViewPaddingRight = -1;
+    public static int resId_loginViewPaddingTop = -1;
+    public static int resId_loginViewTextColor = -1;
+    public static int resId_loginViewTextSize = -1;
+    public static int resId_loginViewLoggedInAs = -1;
+    public static int resId_loginViewLoggedUsingFacebook = -1;
+    public static int resId_loginViewLoginButton = -1;
+    public static int resId_loginViewLoginText = -1;
+    public static int resId_loginViewLogoutAction = -1;
+    public static int resId_loginViewLogoutButton = -1;
+    public static int resId_loginViewLogoutText = -1;
+    public static int resId_loginViewWidth = -1;
+    public static int resId_nearby = -1;
+    public static int resId_pickerActivityCircle = -1;
+    public static int resId_pickerCheckbox = -1;
+    public static int resId_pickerCheckboxStub = -1;
+    public static int resId_pickerDoneButton = -1;
+    public static int resId_pickerDoneButtonText = -1;
+    public static int resId_pickerImage = -1;
+    public static int resId_pickerListRow = -1;
+    public static int resId_pickerListSectionHeader = -1;
+    public static int resId_pickerListView = -1;
+    public static int resId_pickerProfilePicStub = -1;
+    public static int resId_pickerRowActivityCircle = -1;
+    public static int resId_pickerSubTitle = -1;
+    public static int resId_pickerTitle = -1;
+    public static int resId_pickerTitleBar = -1;
+    public static int resId_pickerTitleBarStub = -1;
+    public static int resId_placeDefaultIcon = -1;
+    public static int resId_placePickerFragment = -1;
+    public static int resId_placePickerFragmentAttrs = -1;
+    public static int resId_placePickerFragmentListRow = -1;
+    public static int resId_placePickerFragmentRadiusInMeters = -1;
+    public static int resId_placePickerFragmentResultsLimit = -1;
+    public static int resId_placePickerFragmentSearchBoxStub = -1;
+    public static int resId_placePickerFragmentSearchText = -1;
+    public static int resId_placePickerFragmentShowSearchBox = -1;
+    public static int resId_placePickerSubtitleCatalogOnlyFormat = -1;
+    public static int resId_placePickerSubtitleFormat = -1;
+    public static int resId_placePickerSubtitleWereHereOnlyFormat = -1;
+    public static int resId_profileDefaultIcon = -1;
+    public static int resId_profilePictureBlankPortrait = -1;
+    public static int resId_profilePictureBlankSquare = -1;
+    public static int resId_profilePictureIsCropped = -1;
+    public static int resId_profilePictureLarge = -1;
+    public static int resId_profilePictureNormal = -1;
+    public static int resId_profilePicturePresetSize = -1;
+    public static int resId_profilePictureSmall = -1;
+    public static int resId_profilePictureView = -1;
+    public static int resId_requestErrorPasswordChanged = -1;
+    public static int resId_requestErrorPermissions = -1;
+    public static int resId_requestErrorReconnect = -1;
+    public static int resId_requestErrorRelogin = -1;
+    public static int resId_requestErrorWebLogin = -1;
+    public static int resId_searchBox = -1;
+    public static int resId_userSettingsFragment = -1;
+    public static int resId_userSettingsFragmentConnectedShadowColor = -1;
+    public static int resId_userSettingsFragmentConnectedTextColor = -1;
+    public static int resId_userSettingsFragmentLoggedIn = -1;
+    public static int resId_userSettingsFragmentLoginButton = -1;
+    public static int resId_userSettingsFragmentNotConnectedTextColor = -1;
+    public static int resId_userSettingsFragmentNotLoggedIn = -1;
+    public static int resId_userSettingsFragmentProfileName = -1;
+    public static int resId_userSettingsFragmentProfilePictureHeight = -1;
+    public static int resId_userSettingsFragmentProfilePictureWidth = -1;
+    
 
     public static class FetchedAppSettings {
         private boolean supportsAttribution;
@@ -393,4 +485,95 @@ public static void deleteDirectory(File directoryOrFile) {
         }
         return result;
     }
+    
+	public static void loadResourceIds(Context context)
+	{
+		String packageName = context.getPackageName();
+		Resources resources = context.getResources();
+		
+		resId_blueColor = resources.getIdentifier("com_facebook_blue", "color", packageName);
+		resId_chooseFriends = resources.getIdentifier("com_facebook_choose_friends", "string", packageName);
+		resId_close = resources.getIdentifier("com_facebook_close", "drawable", packageName);
+		resId_errorMessage = resources.getIdentifier("com_facebook_internet_permission_error_message", "string", packageName);
+		resId_errorTitle = resources.getIdentifier("com_facebook_internet_permission_error_title", "string", packageName);
+		resId_friendPickerFragment = resources.getIdentifier("com_facebook_friendpickerfragment", "layout", packageName);
+		resId_friendPickerFragmentMultiSelect = resources.getIdentifier("com_facebook_friend_picker_fragment_multi_select", "styleable", packageName);
+		resId_friendPickerFragmentStyleable = resources.getIdentifier("com_facebook_friend_picker_fragment", "styleable", packageName);
+		resId_loading = resources.getIdentifier("com_facebook_loading", "string", packageName);
+		resId_loginActivityLayout = resources.getIdentifier("com_facebook_login_activity_layout", "layout", packageName);
+		resId_loginActivityProgressBar = resources.getIdentifier("com_facebook_login_activity_progress_bar", "id", packageName);
+		resId_loginButtonImage = resources.getIdentifier("com_facebook_loginbutton_blue", "drawable", packageName);
+		resId_loginView = resources.getIdentifier("com_facebook_login_view", "styleable", packageName);
+		resId_loginViewCancelAction = resources.getIdentifier("com_facebook_loginview_cancel_action", "string", packageName);
+		resId_loginViewConfirmLogout = resources.getIdentifier("com_facebook_login_view_confirm_logout", "styleable", packageName);
+		resId_loginViewFetchUserInfo = resources.getIdentifier("com_facebook_login_view_fetch_user_info", "styleable", packageName);
+		resId_loginViewHeight = resources.getIdentifier("com_facebook_loginview_height", "dimen", packageName);
+		resId_loginViewPaddingBottom = resources.getIdentifier("com_facebook_loginview_padding_bottom", "dimen", packageName);
+		resId_loginViewPaddingLeft = resources.getIdentifier("com_facebook_loginview_padding_left", "dimen", packageName);
+		resId_loginViewPaddingRight = resources.getIdentifier("com_facebook_loginview_padding_right", "dimen", packageName);
+		resId_loginViewPaddingTop = resources.getIdentifier("com_facebook_loginview_padding_top", "dimen", packageName);
+		resId_loginViewTextColor = resources.getIdentifier("com_facebook_loginview_text_color", "color", packageName);
+		resId_loginViewTextSize = resources.getIdentifier("com_facebook_loginview_text_size", "dimen", packageName);
+		resId_loginViewLoggedInAs = resources.getIdentifier("com_facebook_loginview_logged_in_as", "string", packageName);
+		resId_loginViewLoggedUsingFacebook = resources.getIdentifier("com_facebook_loginview_logged_in_using_facebook", "string", packageName);
+		resId_loginViewLoginButton = resources.getIdentifier("com_facebook_loginview_log_in_button", "string", packageName);
+		resId_loginViewLoginText = resources.getIdentifier("com_facebook_login_view_login_text", "styleable", packageName);
+		resId_loginViewLogoutAction = resources.getIdentifier("com_facebook_loginview_log_out_action", "string", packageName);
+		resId_loginViewLogoutButton = resources.getIdentifier("com_facebook_loginview_log_out_button", "string", packageName);
+		resId_loginViewLogoutText = resources.getIdentifier("com_facebook_login_view_logout_text", "styleable", packageName);
+		resId_loginViewWidth = resources.getIdentifier("com_facebook_loginview_width", "dimen", packageName);
+		resId_nearby = resources.getIdentifier("com_facebook_nearby", "string", packageName);
+		resId_pickerActivityCircle = resources.getIdentifier("com_facebook_picker_activity_circle", "id", packageName);
+		resId_pickerCheckbox = resources.getIdentifier("com_facebook_picker_checkbox", "id", packageName);
+		resId_pickerCheckboxStub = resources.getIdentifier("com_facebook_picker_checkbox_stub", "id", packageName);
+		resId_pickerDoneButton = resources.getIdentifier("com_facebook_picker_done_button", "id", packageName);
+		resId_pickerDoneButtonText = resources.getIdentifier("com_facebook_picker_done_button_text", "id", packageName);
+		resId_pickerImage = resources.getIdentifier("com_facebook_picker_image", "image", packageName);
+		resId_pickerListRow = resources.getIdentifier("com_facebook_picker_list_row", "layout", packageName);
+		resId_pickerListSectionHeader = resources.getIdentifier("com_facebook_picker_list_section_header", "layout", packageName);
+		resId_pickerListView = resources.getIdentifier("com_facebook_picker_list_view", "id", packageName);
+		resId_pickerProfilePicStub = resources.getIdentifier("com_facebook_picker_profile_pic_stub", "id", packageName);
+		resId_pickerRowActivityCircle = resources.getIdentifier("com_facebook_picker_row_activity_circle", "id", packageName);
+		resId_pickerSubTitle = resources.getIdentifier("picker_subtitle", "id", packageName);
+		resId_pickerTitle = resources.getIdentifier("com_facebook_picker_title", "id", packageName);
+		resId_pickerTitleBar = resources.getIdentifier("com_facebook_picker_title_bar", "id", packageName);
+		resId_pickerTitleBarStub = resources.getIdentifier("com_facebook_picker_title_bar_stub", "id", packageName);
+		resId_placeDefaultIcon = resources.getIdentifier("com_facebook_place_default_icon", "drawable", packageName);
+		resId_placePickerFragment = resources.getIdentifier("com_facebook_placepickerfragment", "layout", packageName);
+		resId_placePickerFragmentAttrs = resources.getIdentifier("com_facebook_place_picker_fragment", "styleable", packageName);
+		resId_placePickerFragmentListRow = resources.getIdentifier("com_facebook_placepickerfragment_list_row", "layout", packageName);
+		resId_placePickerFragmentRadiusInMeters = resources.getIdentifier("com_facebook_place_picker_fragment_radius_in_meters", "styleable", packageName);
+		resId_placePickerFragmentResultsLimit = resources.getIdentifier("com_facebook_place_picker_fragment_results_limit", "styleable", packageName);
+		resId_placePickerFragmentSearchBoxStub = resources.getIdentifier("com_facebook_placepickerfragment_search_box_stub", "id", packageName);
+		resId_placePickerFragmentSearchText = resources.getIdentifier("com_facebook_place_picker_fragment_search_text", "styleable", packageName);
+		resId_placePickerFragmentShowSearchBox = resources.getIdentifier("com_facebook_place_picker_fragment_show_search_box", "styleable", packageName);
+		resId_placePickerSubtitleCatalogOnlyFormat = resources.getIdentifier("com_facebook_placepicker_subtitle_catetory_only_format", "string", packageName);
+		resId_placePickerSubtitleFormat = resources.getIdentifier("com_facebook_placepicker_subtitle_format", "string", packageName);
+		resId_placePickerSubtitleWereHereOnlyFormat = resources.getIdentifier("com_facebook_placepicker_subtitle_were_here_only_format", "string", packageName);
+		resId_profileDefaultIcon = resources.getIdentifier("com_facebook_profile_default_icon", "drawable", packageName);
+		resId_profilePictureBlankPortrait = resources.getIdentifier("com_facebook_profile_picture_blank_portrait", "drawable", packageName);
+		resId_profilePictureBlankSquare = resources.getIdentifier("com_facebook_profile_picture_blank_square", "drawable", packageName);
+		resId_profilePictureIsCropped = resources.getIdentifier("com_facebook_profile_picture_view_is_cropped", "styleable", packageName);
+		resId_profilePictureLarge = resources.getIdentifier("com_facebook_profilepictureview_preset_size_large", "dimen", packageName);
+		resId_profilePictureNormal = resources.getIdentifier("com_facebook_profilepictureview_preset_size_normal", "dimen", packageName);
+		resId_profilePicturePresetSize = resources.getIdentifier("com_facebook_profile_picture_view_preset_size", "styleable", packageName);
+		resId_profilePictureSmall = resources.getIdentifier("com_facebook_profilepictureview_preset_size_small", "dimen", packageName);
+		resId_profilePictureView = resources.getIdentifier("com_facebook_profile_picture_view", "styleable", packageName);
+		resId_requestErrorPasswordChanged = resources.getIdentifier("com_facebook_requesterror_password_changed", "string", packageName);
+		resId_requestErrorPermissions = resources.getIdentifier("com_facebook_requesterror_permissions", "string", packageName);
+		resId_requestErrorReconnect = resources.getIdentifier("com_facebook_requesterror_reconnect", "string", packageName);
+		resId_requestErrorRelogin = resources.getIdentifier("com_facebook_requesterror_relogin", "string", packageName);
+		resId_requestErrorWebLogin = resources.getIdentifier("com_facebook_requesterror_web_login", "string", packageName);
+		resId_searchBox = resources.getIdentifier("search_box", "id", packageName);
+		resId_userSettingsFragment = resources.getIdentifier("com_facebook_usersettingsfragment", "layout", packageName);
+		resId_userSettingsFragmentConnectedShadowColor = resources.getIdentifier("com_facebook_usersettingsfragment_connected_shadow_color", "color", packageName);
+		resId_userSettingsFragmentConnectedTextColor = resources.getIdentifier("com_facebook_usersettingsfragment_connected_text_color", "color", packageName);
+		resId_userSettingsFragmentLoggedIn = resources.getIdentifier("com_facebook_usersettingsfragment_logged_in", "string", packageName);
+		resId_userSettingsFragmentLoginButton = resources.getIdentifier("com_facebook_usersettingsfragment_login_button", "id", packageName);
+		resId_userSettingsFragmentNotConnectedTextColor = resources.getIdentifier("com_facebook_usersettingsfragment_not_connected_text_color", "color", packageName);
+		resId_userSettingsFragmentNotLoggedIn = resources.getIdentifier("com_facebook_usersettingsfragment_not_logged_in", "string", packageName);
+		resId_userSettingsFragmentProfileName = resources.getIdentifier("com_facebook_usersettingsfragment_profile_name", "id", packageName);
+		resId_userSettingsFragmentProfilePictureHeight = resources.getIdentifier("com_facebook_usersettingsfragment_profile_picture_height", "dimen", packageName);
+		resId_userSettingsFragmentProfilePictureWidth = resources.getIdentifier("com_facebook_usersettingsfragment_profile_picture_width", "dimen", packageName);
+	}    
 }
diff --git a/facebook/src/com/facebook/widget/FriendPickerFragment.java b/facebook/src/com/facebook/widget/FriendPickerFragment.java
deleted file mode 100644
index cddc3ace3..000000000
--- a/facebook/src/com/facebook/widget/FriendPickerFragment.java
+++ /dev/null
@@ -1,274 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.annotation.SuppressLint;
-import android.app.Activity;
-import android.content.res.TypedArray;
-import android.os.Bundle;
-import android.text.TextUtils;
-import android.util.AttributeSet;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.internal.AnalyticsEvents;
-import com.facebook.model.GraphUser;
-
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-/**
- * Provides a Fragment that displays a list of a user's friends and allows one or more of the
- * friends to be selected.
- */
-public class FriendPickerFragment extends PickerFragment<GraphUser> {
-    /**
-     * The key for a String parameter in the fragment's Intent bundle to indicate what user's
-     * friends should be shown. The default is to display the currently authenticated user's friends.
-     */
-    public static final String USER_ID_BUNDLE_KEY = "com.facebook.widget.FriendPickerFragment.UserId";
-    /**
-     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
-     * picker should allow more than one friend to be selected or not.
-     */
-    public static final String MULTI_SELECT_BUNDLE_KEY = "com.facebook.widget.FriendPickerFragment.MultiSelect";
-
-    private static final String ID = "id";
-    private static final String NAME = "name";
-
-    private String userId;
-
-    private boolean multiSelect = true;
-
-    /**
-     * Default constructor. Creates a Fragment with all default properties.
-     */
-    public FriendPickerFragment() {
-        this(null);
-    }
-
-    /**
-     * Constructor.
-     * @param args  a Bundle that optionally contains one or more values containing additional
-     *              configuration information for the Fragment.
-     */
-    @SuppressLint("ValidFragment")
-    public FriendPickerFragment(Bundle args) {
-        super(GraphUser.class, R.layout.com_facebook_friendpickerfragment, args);
-        setFriendPickerSettingsFromBundle(args);
-    }
-
-    /**
-     * Gets the ID of the user whose friends should be displayed. If null, the default is to
-     * show the currently authenticated user's friends.
-     * @return the user ID, or null
-     */
-    public String getUserId() {
-        return userId;
-    }
-
-    /**
-     * Sets the ID of the user whose friends should be displayed. If null, the default is to
-     * show the currently authenticated user's friends.
-     * @param userId     the user ID, or null
-     */
-    public void setUserId(String userId) {
-        this.userId = userId;
-    }
-
-    /**
-     * Gets whether the user can select multiple friends, or only one friend.
-     * @return true if the user can select multiple friends, false if only one friend
-     */
-    public boolean getMultiSelect() {
-        return multiSelect;
-    }
-
-    /**
-     * Sets whether the user can select multiple friends, or only one friend.
-     * @param multiSelect    true if the user can select multiple friends, false if only one friend
-     */
-    public void setMultiSelect(boolean multiSelect) {
-        if (this.multiSelect != multiSelect) {
-            this.multiSelect = multiSelect;
-            setSelectionStrategy(createSelectionStrategy());
-        }
-    }
-
-    /**
-     * Gets the currently-selected list of users.
-     * @return the currently-selected list of users
-     */
-    public List<GraphUser> getSelection() {
-        return getSelectedGraphObjects();
-    }
-
-    @Override
-    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
-        super.onInflate(activity, attrs, savedInstanceState);
-        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_friend_picker_fragment);
-
-        setMultiSelect(a.getBoolean(R.styleable.com_facebook_friend_picker_fragment_multi_select, multiSelect));
-
-        a.recycle();
-    }
-
-    public void setSettingsFromBundle(Bundle inState) {
-        super.setSettingsFromBundle(inState);
-        setFriendPickerSettingsFromBundle(inState);
-    }
-
-    void saveSettingsToBundle(Bundle outState) {
-        super.saveSettingsToBundle(outState);
-
-        outState.putString(USER_ID_BUNDLE_KEY, userId);
-        outState.putBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect);
-    }
-
-    @Override
-    PickerFragmentAdapter<GraphUser> createAdapter() {
-        PickerFragmentAdapter<GraphUser> adapter = new PickerFragmentAdapter<GraphUser>(
-                this.getActivity()) {
-
-            @Override
-            protected int getGraphObjectRowLayoutId(GraphUser graphObject) {
-                return R.layout.com_facebook_picker_list_row;
-            }
-
-            @Override
-            protected int getDefaultPicture() {
-                return R.drawable.com_facebook_profile_default_icon;
-            }
-
-        };
-        adapter.setShowCheckbox(true);
-        adapter.setShowPicture(getShowPictures());
-        adapter.setSortFields(Arrays.asList(new String[]{NAME}));
-        adapter.setGroupByField(NAME);
-
-        return adapter;
-    }
-
-    @Override
-    LoadingStrategy createLoadingStrategy() {
-        return new ImmediateLoadingStrategy();
-    }
-
-    @Override
-    SelectionStrategy createSelectionStrategy() {
-        return multiSelect ? new MultiSelectionStrategy() : new SingleSelectionStrategy();
-    }
-
-    @Override
-    Request getRequestForLoadData(Session session) {
-        if (adapter == null) {
-            throw new FacebookException("Can't issue requests until Fragment has been created.");
-        }
-
-        String userToFetch = (userId != null) ? userId : "me";
-        return createRequest(userToFetch, extraFields, session);
-    }
-
-    @Override
-    String getDefaultTitleText() {
-        return getString(R.string.com_facebook_choose_friends);
-    }
-
-    @Override
-    void logAppEvents(boolean doneButtonClicked) {
-        AppEventsLogger logger = AppEventsLogger.newLogger(this.getActivity(), getSession());
-        Bundle parameters = new Bundle();
-
-        // If Done was clicked, we know this completed successfully. If not, we don't know (caller might have
-        // dismissed us in response to selection changing, or user might have hit back button). Either way
-        // we'll log the number of selections.
-        String outcome = doneButtonClicked ? AnalyticsEvents.PARAMETER_DIALOG_OUTCOME_VALUE_COMPLETED :
-                AnalyticsEvents.PARAMETER_DIALOG_OUTCOME_VALUE_UNKNOWN;
-        parameters.putString(AnalyticsEvents.PARAMETER_DIALOG_OUTCOME, outcome);
-        parameters.putInt("num_friends_picked", getSelection().size());
-
-        logger.logSdkEvent(AnalyticsEvents.EVENT_FRIEND_PICKER_USAGE, null, parameters);
-    }
-
-    private Request createRequest(String userID, Set<String> extraFields, Session session) {
-        Request request = Request.newGraphPathRequest(session, userID + "/friends", null);
-
-        Set<String> fields = new HashSet<String>(extraFields);
-        String[] requiredFields = new String[]{
-                ID,
-                NAME
-        };
-        fields.addAll(Arrays.asList(requiredFields));
-
-        String pictureField = adapter.getPictureFieldSpecifier();
-        if (pictureField != null) {
-            fields.add(pictureField);
-        }
-
-        Bundle parameters = request.getParameters();
-        parameters.putString("fields", TextUtils.join(",", fields));
-        request.setParameters(parameters);
-
-        return request;
-    }
-
-    private void setFriendPickerSettingsFromBundle(Bundle inState) {
-        // We do this in a separate non-overridable method so it is safe to call from the constructor.
-        if (inState != null) {
-            if (inState.containsKey(USER_ID_BUNDLE_KEY)) {
-                setUserId(inState.getString(USER_ID_BUNDLE_KEY));
-            }
-            setMultiSelect(inState.getBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect));
-        }
-    }
-
-    private class ImmediateLoadingStrategy extends LoadingStrategy {
-        @Override
-        protected void onLoadFinished(GraphObjectPagingLoader<GraphUser> loader,
-                SimpleGraphObjectCursor<GraphUser> data) {
-            super.onLoadFinished(loader, data);
-
-            // We could be called in this state if we are clearing data or if we are being re-attached
-            // in the middle of a query.
-            if (data == null || loader.isLoading()) {
-                return;
-            }
-
-            if (data.areMoreObjectsAvailable()) {
-                // We got results, but more are available.
-                followNextLink();
-            } else {
-                // We finished loading results.
-                hideActivityCircle();
-
-                // If this was from the cache, schedule a delayed refresh query (unless we got no results
-                // at all, in which case refresh immediately.
-                if (data.isFromCache()) {
-                    loader.refreshOriginalRequest(data.getCount() == 0 ? CACHED_RESULT_REFRESH_DELAY : 0);
-                }
-            }
-        }
-
-        private void followNextLink() {
-            // This may look redundant, but this causes the circle to be alpha-dimmed if we have results.
-            displayActivityCircle();
-
-            loader.followNextLink();
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/widget/GraphObjectAdapter.java b/facebook/src/com/facebook/widget/GraphObjectAdapter.java
deleted file mode 100644
index 3686cb8b2..000000000
--- a/facebook/src/com/facebook/widget/GraphObjectAdapter.java
+++ /dev/null
@@ -1,827 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.ViewStub;
-import android.widget.*;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.internal.ImageDownloader;
-import com.facebook.internal.ImageRequest;
-import com.facebook.internal.ImageResponse;
-import com.facebook.model.GraphObject;
-import org.json.JSONObject;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.text.Collator;
-import java.util.*;
-
-class GraphObjectAdapter<T extends GraphObject> extends BaseAdapter implements SectionIndexer {
-    private static final int DISPLAY_SECTIONS_THRESHOLD = 1;
-    private static final int HEADER_VIEW_TYPE = 0;
-    private static final int GRAPH_OBJECT_VIEW_TYPE = 1;
-    private static final int ACTIVITY_CIRCLE_VIEW_TYPE = 2;
-    private static final int MAX_PREFETCHED_PICTURES = 20;
-
-    private static final String ID = "id";
-    private static final String NAME = "name";
-    private static final String PICTURE = "picture";
-
-    private final Map<String, ImageRequest> pendingRequests = new HashMap<String, ImageRequest>();
-    private final LayoutInflater inflater;
-    private List<String> sectionKeys = new ArrayList<String>();
-    private Map<String, ArrayList<T>> graphObjectsBySection = new HashMap<String, ArrayList<T>>();
-    private Map<String, T> graphObjectsById = new HashMap<String, T>();
-    private boolean displaySections;
-    private List<String> sortFields;
-    private String groupByField;
-    private boolean showPicture;
-    private boolean showCheckbox;
-    private Filter<T> filter;
-    private DataNeededListener dataNeededListener;
-    private GraphObjectCursor<T> cursor;
-    private Context context;
-    private Map<String, ImageResponse> prefetchedPictureCache = new HashMap<String, ImageResponse>();
-    private ArrayList<String> prefetchedProfilePictureIds = new ArrayList<String>();
-    private OnErrorListener onErrorListener;
-
-    public interface DataNeededListener {
-        public void onDataNeeded();
-    }
-
-    public interface OnErrorListener {
-        void onError(GraphObjectAdapter<?> adapter, FacebookException error);
-    }
-
-    public static class SectionAndItem<T extends GraphObject> {
-        public String sectionKey;
-        public T graphObject;
-
-        public enum Type {
-            GRAPH_OBJECT,
-            SECTION_HEADER,
-            ACTIVITY_CIRCLE
-        }
-
-        public SectionAndItem(String sectionKey, T graphObject) {
-            this.sectionKey = sectionKey;
-            this.graphObject = graphObject;
-        }
-
-        public Type getType() {
-            if (sectionKey == null) {
-                return Type.ACTIVITY_CIRCLE;
-            } else if (graphObject == null) {
-                return Type.SECTION_HEADER;
-            } else {
-                return Type.GRAPH_OBJECT;
-            }
-        }
-    }
-
-    interface Filter<T> {
-        boolean includeItem(T graphObject);
-    }
-
-    public GraphObjectAdapter(Context context) {
-        this.context = context;
-        this.inflater = LayoutInflater.from(context);
-    }
-
-    public List<String> getSortFields() {
-        return sortFields;
-    }
-
-    public void setSortFields(List<String> sortFields) {
-        this.sortFields = sortFields;
-    }
-
-    public String getGroupByField() {
-        return groupByField;
-    }
-
-    public void setGroupByField(String groupByField) {
-        this.groupByField = groupByField;
-    }
-
-    public boolean getShowPicture() {
-        return showPicture;
-    }
-
-    public void setShowPicture(boolean showPicture) {
-        this.showPicture = showPicture;
-    }
-
-    public boolean getShowCheckbox() {
-        return showCheckbox;
-    }
-
-    public void setShowCheckbox(boolean showCheckbox) {
-        this.showCheckbox = showCheckbox;
-    }
-
-    public DataNeededListener getDataNeededListener() {
-        return dataNeededListener;
-    }
-
-    public void setDataNeededListener(DataNeededListener dataNeededListener) {
-        this.dataNeededListener = dataNeededListener;
-    }
-
-    public OnErrorListener getOnErrorListener() {
-        return onErrorListener;
-    }
-
-    public void setOnErrorListener(OnErrorListener onErrorListener) {
-        this.onErrorListener = onErrorListener;
-    }
-
-    public GraphObjectCursor<T> getCursor() {
-        return cursor;
-    }
-
-    public boolean changeCursor(GraphObjectCursor<T> cursor) {
-        if (this.cursor == cursor) {
-            return false;
-        }
-        if (this.cursor != null) {
-            this.cursor.close();
-        }
-        this.cursor = cursor;
-
-        rebuildAndNotify();
-        return true;
-    }
-
-    public void rebuildAndNotify() {
-        rebuildSections();
-        notifyDataSetChanged();
-    }
-
-    public void prioritizeViewRange(int firstVisibleItem, int lastVisibleItem, int prefetchBuffer) {
-        if ((lastVisibleItem < firstVisibleItem) || (sectionKeys.size() == 0)) {
-            return;
-        }
-
-        // We want to prioritize requests for items which are visible but do not have pictures
-        // loaded yet. We also want to pre-fetch pictures for items which are not yet visible
-        // but are within a buffer on either side of the visible items, on the assumption that
-        // they will be visible soon. For these latter items, we'll store the images in memory
-        // in the hopes we can immediately populate their image view when needed.
-
-        // Prioritize the requests in reverse order since each call to prioritizeRequest will just
-        // move it to the front of the queue. And we want the earliest ones in the range to be at
-        // the front of the queue, so all else being equal, the list will appear to populate from
-        // the top down.
-        for (int i = lastVisibleItem; i >= 0; i--) {
-            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
-            if (sectionAndItem.graphObject != null) {
-                String id = getIdOfGraphObject(sectionAndItem.graphObject);
-                ImageRequest request = pendingRequests.get(id);
-                if (request != null) {
-                    ImageDownloader.prioritizeRequest(request);
-                }
-            }
-        }
-
-        // For items which are not visible, but within the buffer on either side, we want to
-        // fetch those items and store them in a small in-memory cache of bitmaps.
-        int start = Math.max(0, firstVisibleItem - prefetchBuffer);
-        int end = Math.min(lastVisibleItem + prefetchBuffer, getCount() - 1);
-        ArrayList<T> graphObjectsToPrefetchPicturesFor = new ArrayList<T>();
-        // Add the IDs before and after the visible range.
-        for (int i = start; i < firstVisibleItem; ++i) {
-            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
-            if (sectionAndItem.graphObject != null) {
-                graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
-            }
-        }
-        for (int i = lastVisibleItem + 1; i <= end; ++i) {
-            SectionAndItem<T> sectionAndItem = getSectionAndItem(i);
-            if (sectionAndItem.graphObject != null) {
-                graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
-            }
-        }
-        for (T graphObject : graphObjectsToPrefetchPicturesFor) {
-            URI uri = getPictureUriOfGraphObject(graphObject);
-            final String id = getIdOfGraphObject(graphObject);
-
-            // This URL already have been requested for pre-fetching, but we want to act in an LRU manner, so move
-            // it to the end of the list regardless.
-            boolean alreadyPrefetching = prefetchedProfilePictureIds.remove(id);
-            prefetchedProfilePictureIds.add(id);
-
-            // If we've already requested it for pre-fetching, no need to do so again.
-            if (!alreadyPrefetching) {
-                downloadProfilePicture(id, uri, null);
-            }
-        }
-    }
-
-    protected String getSectionKeyOfGraphObject(T graphObject) {
-        String result = null;
-
-        if (groupByField != null) {
-            result = (String) graphObject.getProperty(groupByField);
-            if (result != null && result.length() > 0) {
-                result = result.substring(0, 1).toUpperCase();
-            }
-        }
-
-        return (result != null) ? result : "";
-    }
-
-    protected CharSequence getTitleOfGraphObject(T graphObject) {
-        return (String) graphObject.getProperty(NAME);
-    }
-
-    protected CharSequence getSubTitleOfGraphObject(T graphObject) {
-        return null;
-    }
-
-    protected URI getPictureUriOfGraphObject(T graphObject) {
-        String uri = null;
-        Object o = graphObject.getProperty(PICTURE);
-        if (o instanceof String) {
-            uri = (String) o;
-        } else if (o instanceof JSONObject) {
-            ItemPicture itemPicture = GraphObject.Factory.create((JSONObject) o).cast(ItemPicture.class);
-            ItemPictureData data = itemPicture.getData();
-            if (data != null) {
-                uri = data.getUrl();
-            }
-        }
-
-        if (uri != null) {
-            try {
-                return new URI(uri);
-            } catch (URISyntaxException e) {
-            }
-        }
-        return null;
-    }
-
-    protected View getSectionHeaderView(String sectionHeader, View convertView, ViewGroup parent) {
-        TextView result = (TextView) convertView;
-
-        if (result == null) {
-            result = (TextView) inflater.inflate(R.layout.com_facebook_picker_list_section_header, null);
-        }
-
-        result.setText(sectionHeader);
-
-        return result;
-    }
-
-    protected View getGraphObjectView(T graphObject, View convertView, ViewGroup parent) {
-        View result = convertView;
-
-        if (result == null) {
-            result = createGraphObjectView(graphObject);
-        }
-
-        populateGraphObjectView(result, graphObject);
-        return result;
-    }
-
-    private View getActivityCircleView(View convertView, ViewGroup parent) {
-        View result = convertView;
-
-        if (result == null) {
-            result = inflater.inflate(R.layout.com_facebook_picker_activity_circle_row, null);
-        }
-        ProgressBar activityCircle = (ProgressBar) result.findViewById(R.id.com_facebook_picker_row_activity_circle);
-        activityCircle.setVisibility(View.VISIBLE);
-
-        return result;
-    }
-
-    protected int getGraphObjectRowLayoutId(T graphObject) {
-        return R.layout.com_facebook_picker_list_row;
-    }
-
-    protected int getDefaultPicture() {
-        return R.drawable.com_facebook_profile_default_icon;
-    }
-
-    protected View createGraphObjectView(T graphObject) {
-        View result = inflater.inflate(getGraphObjectRowLayoutId(graphObject), null);
-
-        ViewStub checkboxStub = (ViewStub) result.findViewById(R.id.com_facebook_picker_checkbox_stub);
-        if (checkboxStub != null) {
-            if (!getShowCheckbox()) {
-                checkboxStub.setVisibility(View.GONE);
-            } else {
-                CheckBox checkBox = (CheckBox) checkboxStub.inflate();
-                updateCheckboxState(checkBox, false);
-            }
-        }
-
-        ViewStub profilePicStub = (ViewStub) result.findViewById(R.id.com_facebook_picker_profile_pic_stub);
-        if (!getShowPicture()) {
-            profilePicStub.setVisibility(View.GONE);
-        } else {
-            ImageView imageView = (ImageView) profilePicStub.inflate();
-            imageView.setVisibility(View.VISIBLE);
-        }
-
-        return result;
-    }
-
-    protected void populateGraphObjectView(View view, T graphObject) {
-        String id = getIdOfGraphObject(graphObject);
-        view.setTag(id);
-
-        CharSequence title = getTitleOfGraphObject(graphObject);
-        TextView titleView = (TextView) view.findViewById(R.id.com_facebook_picker_title);
-        if (titleView != null) {
-            titleView.setText(title, TextView.BufferType.SPANNABLE);
-        }
-
-        CharSequence subtitle = getSubTitleOfGraphObject(graphObject);
-        TextView subtitleView = (TextView) view.findViewById(R.id.picker_subtitle);
-        if (subtitleView != null) {
-            if (subtitle != null) {
-                subtitleView.setText(subtitle, TextView.BufferType.SPANNABLE);
-                subtitleView.setVisibility(View.VISIBLE);
-            } else {
-                subtitleView.setVisibility(View.GONE);
-            }
-        }
-
-        if (getShowCheckbox()) {
-            CheckBox checkBox = (CheckBox) view.findViewById(R.id.com_facebook_picker_checkbox);
-            updateCheckboxState(checkBox, isGraphObjectSelected(id));
-        }
-
-        if (getShowPicture()) {
-            URI pictureURI = getPictureUriOfGraphObject(graphObject);
-
-            if (pictureURI != null) {
-                ImageView profilePic = (ImageView) view.findViewById(R.id.com_facebook_picker_image);
-
-                // See if we have already pre-fetched this; if not, download it.
-                if (prefetchedPictureCache.containsKey(id)) {
-                    ImageResponse response = prefetchedPictureCache.get(id);
-                    profilePic.setImageBitmap(response.getBitmap());
-                    profilePic.setTag(response.getRequest().getImageUri());
-                } else {
-                    downloadProfilePicture(id, pictureURI, profilePic);
-                }
-            }
-        }
-    }
-
-    /**
-     * @throws FacebookException if the GraphObject doesn't have an ID.
-     */
-    String getIdOfGraphObject(T graphObject) {
-        if (graphObject.asMap().containsKey(ID)) {
-            Object obj = graphObject.getProperty(ID);
-            if (obj instanceof String) {
-                return (String) obj;
-            }
-        }
-        throw new FacebookException("Received an object without an ID.");
-    }
-
-    boolean filterIncludesItem(T graphObject) {
-        return filter == null || filter.includeItem(graphObject);
-    }
-
-    Filter<T> getFilter() {
-        return filter;
-    }
-
-    void setFilter(Filter<T> filter) {
-        this.filter = filter;
-    }
-
-    boolean isGraphObjectSelected(String graphObjectId) {
-        return false;
-    }
-
-    void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
-        // Default is no-op
-    }
-
-    String getPictureFieldSpecifier() {
-        // How big is our image?
-        View view = createGraphObjectView(null);
-        ImageView picture = (ImageView) view.findViewById(R.id.com_facebook_picker_image);
-        if (picture == null) {
-            return null;
-        }
-
-        // Note: these dimensions are in pixels, not dips
-        ViewGroup.LayoutParams layoutParams = picture.getLayoutParams();
-        return String.format("picture.height(%d).width(%d)", layoutParams.height, layoutParams.width);
-    }
-
-
-    private boolean shouldShowActivityCircleCell() {
-        // We show the "more data" activity circle cell if we have a listener to request more data,
-        // we are expecting more data, and we have some data already (i.e., not on a fresh query).
-        return (cursor != null) && cursor.areMoreObjectsAvailable() && (dataNeededListener != null) && !isEmpty();
-    }
-
-    private void rebuildSections() {
-        sectionKeys = new ArrayList<String>();
-        graphObjectsBySection = new HashMap<String, ArrayList<T>>();
-        graphObjectsById = new HashMap<String, T>();
-        displaySections = false;
-
-        if (cursor == null || cursor.getCount() == 0) {
-            return;
-        }
-
-        int objectsAdded = 0;
-        cursor.moveToFirst();
-        do {
-            T graphObject = cursor.getGraphObject();
-
-            if (!filterIncludesItem(graphObject)) {
-                continue;
-            }
-
-            objectsAdded++;
-
-            String sectionKeyOfItem = getSectionKeyOfGraphObject(graphObject);
-            if (!graphObjectsBySection.containsKey(sectionKeyOfItem)) {
-                sectionKeys.add(sectionKeyOfItem);
-                graphObjectsBySection.put(sectionKeyOfItem, new ArrayList<T>());
-            }
-            List<T> section = graphObjectsBySection.get(sectionKeyOfItem);
-            section.add(graphObject);
-
-            graphObjectsById.put(getIdOfGraphObject(graphObject), graphObject);
-        } while (cursor.moveToNext());
-
-        if (sortFields != null) {
-            final Collator collator = Collator.getInstance();
-            for (List<T> section : graphObjectsBySection.values()) {
-                Collections.sort(section, new Comparator<GraphObject>() {
-                    @Override
-                    public int compare(GraphObject a, GraphObject b) {
-                        return compareGraphObjects(a, b, sortFields, collator);
-                    }
-                });
-            }
-        }
-
-        Collections.sort(sectionKeys, Collator.getInstance());
-
-        displaySections = sectionKeys.size() > 1 && objectsAdded > DISPLAY_SECTIONS_THRESHOLD;
-    }
-
-    SectionAndItem<T> getSectionAndItem(int position) {
-        if (sectionKeys.size() == 0) {
-            return null;
-        }
-        String sectionKey = null;
-        T graphObject = null;
-
-        if (!displaySections) {
-            sectionKey = sectionKeys.get(0);
-            List<T> section = graphObjectsBySection.get(sectionKey);
-            if (position >= 0 && position < section.size()) {
-                graphObject = graphObjectsBySection.get(sectionKey).get(position);
-            } else {
-                // We are off the end; we must be adding an activity circle to indicate more data is coming.
-                assert dataNeededListener != null && cursor.areMoreObjectsAvailable();
-                // We return null for both to indicate this.
-                return new SectionAndItem<T>(null, null);
-            }
-        } else {
-            // Count through the sections; the "0" position in each section is the header. We decrement
-            // position each time we skip forward a certain number of elements, including the header.
-            for (String key : sectionKeys) {
-                // Decrement if we skip over the header
-                if (position-- == 0) {
-                    sectionKey = key;
-                    break;
-                }
-
-                List<T> section = graphObjectsBySection.get(key);
-                if (position < section.size()) {
-                    // The position is somewhere in this section. Get the corresponding graph object.
-                    sectionKey = key;
-                    graphObject = section.get(position);
-                    break;
-                }
-                // Decrement by as many items as we skipped over
-                position -= section.size();
-            }
-        }
-        if (sectionKey != null) {
-            // Note: graphObject will be null if this represents a section header.
-            return new SectionAndItem<T>(sectionKey, graphObject);
-        } else {
-            throw new IndexOutOfBoundsException("position");
-        }
-    }
-
-    int getPosition(String sectionKey, T graphObject) {
-        int position = 0;
-        boolean found = false;
-
-        // First find the section key and increment position one for each header we will render;
-        // increment by the size of each section prior to the one we want.
-        for (String key : sectionKeys) {
-            if (displaySections) {
-                position++;
-            }
-            if (key.equals(sectionKey)) {
-                found = true;
-                break;
-            } else {
-                position += graphObjectsBySection.get(key).size();
-            }
-        }
-
-        if (!found) {
-            return -1;
-        } else if (graphObject == null) {
-            // null represents the header for a section; we counted this header in position earlier,
-            // so subtract it back out.
-            return position - (displaySections ? 1 : 0);
-        }
-
-        // Now find index of this item within that section.
-        for (T t : graphObjectsBySection.get(sectionKey)) {
-            if (GraphObject.Factory.hasSameId(t, graphObject)) {
-                return position;
-            }
-            position++;
-        }
-        return -1;
-    }
-
-    @Override
-    public boolean isEmpty() {
-        // We'll never populate sectionKeys unless we have at least one object.
-        return sectionKeys.size() == 0;
-    }
-
-    @Override
-    public int getCount() {
-        if (sectionKeys.size() == 0) {
-            return 0;
-        }
-
-        // If we are not displaying sections, we don't display a header; otherwise, we have one header per item in
-        // addition to the actual items.
-        int count = (displaySections) ? sectionKeys.size() : 0;
-        for (List<T> section : graphObjectsBySection.values()) {
-            count += section.size();
-        }
-
-        // If we should show a cell with an activity circle indicating more data is coming, add it to the count.
-        if (shouldShowActivityCircleCell()) {
-            ++count;
-        }
-
-        return count;
-    }
-
-    @Override
-    public boolean areAllItemsEnabled() {
-        return displaySections;
-    }
-
-    @Override
-    public boolean hasStableIds() {
-        return true;
-    }
-
-    @Override
-    public boolean isEnabled(int position) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
-        return sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT;
-    }
-
-    @Override
-    public Object getItem(int position) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
-        return (sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT) ? sectionAndItem.graphObject : null;
-    }
-
-    @Override
-    public long getItemId(int position) {
-        // We assume IDs that can be converted to longs. If this is not the case for certain types of
-        // GraphObjects, subclasses should override this to return, e.g., position, and override hasStableIds
-        // to return false.
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
-        if (sectionAndItem != null && sectionAndItem.graphObject != null) {
-            String id = getIdOfGraphObject(sectionAndItem.graphObject);
-            if (id != null) {
-                return Long.parseLong(id);
-            }
-        }
-        return 0;
-    }
-
-    @Override
-    public int getViewTypeCount() {
-        return 3;
-    }
-
-    @Override
-    public int getItemViewType(int position) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
-        switch (sectionAndItem.getType()) {
-            case SECTION_HEADER:
-                return HEADER_VIEW_TYPE;
-            case GRAPH_OBJECT:
-                return GRAPH_OBJECT_VIEW_TYPE;
-            case ACTIVITY_CIRCLE:
-                return ACTIVITY_CIRCLE_VIEW_TYPE;
-            default:
-                throw new FacebookException("Unexpected type of section and item.");
-        }
-    }
-
-    @Override
-    public View getView(int position, View convertView, ViewGroup parent) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
-
-        switch (sectionAndItem.getType()) {
-            case SECTION_HEADER:
-                return getSectionHeaderView(sectionAndItem.sectionKey, convertView, parent);
-            case GRAPH_OBJECT:
-                return getGraphObjectView(sectionAndItem.graphObject, convertView, parent);
-            case ACTIVITY_CIRCLE:
-                // If we get a request for this view, it means we need more data.
-                assert cursor.areMoreObjectsAvailable() && (dataNeededListener != null);
-                dataNeededListener.onDataNeeded();
-                return getActivityCircleView(convertView, parent);
-            default:
-                throw new FacebookException("Unexpected type of section and item.");
-        }
-    }
-
-    @Override
-    public Object[] getSections() {
-        if (displaySections) {
-            return sectionKeys.toArray();
-        } else {
-            return new Object[0];
-        }
-    }
-
-    @Override
-    public int getPositionForSection(int section) {
-        if (displaySections) {
-            section = Math.max(0, Math.min(section, sectionKeys.size() - 1));
-            if (section < sectionKeys.size()) {
-                return getPosition(sectionKeys.get(section), null);
-            }
-        }
-        return 0;
-    }
-
-    @Override
-    public int getSectionForPosition(int position) {
-        SectionAndItem<T> sectionAndItem = getSectionAndItem(position);
-        if (sectionAndItem != null &&
-                sectionAndItem.getType() != SectionAndItem.Type.ACTIVITY_CIRCLE) {
-            return Math.max(0, Math.min(sectionKeys.indexOf(sectionAndItem.sectionKey), sectionKeys.size() - 1));
-        }
-        return 0;
-    }
-
-    public List<T> getGraphObjectsById(Collection<String> ids) {
-        Set<String> idSet = new HashSet<String>();
-        idSet.addAll(ids);
-
-        ArrayList<T> result = new ArrayList<T>(idSet.size());
-        for (String id : idSet) {
-            T graphObject = graphObjectsById.get(id);
-            if (graphObject != null) {
-                result.add(graphObject);
-            }
-        }
-
-        return result;
-    }
-
-    private void downloadProfilePicture(final String profileId, URI pictureURI, final ImageView imageView) {
-        if (pictureURI == null) {
-            return;
-        }
-
-        // If we don't have an imageView, we are pre-fetching this image to store in-memory because we
-        // think the user might scroll to its corresponding list row. If we do have an imageView, we
-        // only want to queue a download if the view's tag isn't already set to the URL (which would mean
-        // it's already got the correct picture).
-        boolean prefetching = imageView == null;
-        if (prefetching || !pictureURI.equals(imageView.getTag())) {
-            if (!prefetching) {
-                // Setting the tag to the profile ID indicates that we're currently downloading the
-                // picture for this profile; we'll set it to the actual picture URL when complete.
-                imageView.setTag(profileId);
-                imageView.setImageResource(getDefaultPicture());
-            }
-
-            ImageRequest.Builder builder = new ImageRequest.Builder(context.getApplicationContext(), pictureURI)
-                    .setCallerTag(this)
-                    .setCallback(
-                            new ImageRequest.Callback() {
-                                @Override
-                                public void onCompleted(ImageResponse response) {
-                                    processImageResponse(response, profileId, imageView);
-                                }
-                            });
-
-            ImageRequest newRequest = builder.build();
-            pendingRequests.put(profileId, newRequest);
-
-            ImageDownloader.downloadAsync(newRequest);
-        }
-    }
-
-    private void callOnErrorListener(Exception exception) {
-        if (onErrorListener != null) {
-            if (!(exception instanceof FacebookException)) {
-                exception = new FacebookException(exception);
-            }
-            onErrorListener.onError(this, (FacebookException) exception);
-        }
-    }
-
-    private void processImageResponse(ImageResponse response, String graphObjectId, ImageView imageView) {
-        pendingRequests.remove(graphObjectId);
-        if (response.getError() != null) {
-            callOnErrorListener(response.getError());
-        }
-
-        if (imageView == null) {
-            // This was a pre-fetch request.
-            if (response.getBitmap() != null) {
-                // Is the cache too big?
-                if (prefetchedPictureCache.size() >= MAX_PREFETCHED_PICTURES) {
-                    // Find the oldest one and remove it.
-                    String oldestId = prefetchedProfilePictureIds.remove(0);
-                    prefetchedPictureCache.remove(oldestId);
-                }
-                prefetchedPictureCache.put(graphObjectId, response);
-            }
-        } else if (graphObjectId.equals(imageView.getTag())) {
-            Exception error = response.getError();
-            Bitmap bitmap = response.getBitmap();
-            if (error == null && bitmap != null) {
-                imageView.setImageBitmap(bitmap);
-                imageView.setTag(response.getRequest().getImageUri());
-            }
-        }
-    }
-
-    private static int compareGraphObjects(GraphObject a, GraphObject b, Collection<String> sortFields,
-            Collator collator) {
-        for (String sortField : sortFields) {
-            String sa = (String) a.getProperty(sortField);
-            String sb = (String) b.getProperty(sortField);
-
-            if (sa != null && sb != null) {
-                int result = collator.compare(sa, sb);
-                if (result != 0) {
-                    return result;
-                }
-            } else if (!(sa == null && sb == null)) {
-                return (sa == null) ? -1 : 1;
-            }
-        }
-        return 0;
-    }
-
-
-    // Graph object type to navigate the JSON that sometimes comes back instead of a URL string
-    private interface ItemPicture extends GraphObject {
-        ItemPictureData getData();
-    }
-
-    // Graph object type to navigate the JSON that sometimes comes back instead of a URL string
-    private interface ItemPictureData extends GraphObject {
-        String getUrl();
-    }
-}
diff --git a/facebook/src/com/facebook/widget/LoginButton.java b/facebook/src/com/facebook/widget/LoginButton.java
deleted file mode 100644
index ce67f6955..000000000
--- a/facebook/src/com/facebook/widget/LoginButton.java
+++ /dev/null
@@ -1,746 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.res.TypedArray;
-import android.graphics.Typeface;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.util.TypedValue;
-import android.view.Gravity;
-import android.view.View;
-import android.widget.Button;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.internal.AnalyticsEvents;
-import com.facebook.model.GraphUser;
-import com.facebook.internal.SessionAuthorizationType;
-import com.facebook.internal.SessionTracker;
-import com.facebook.internal.Utility;
-
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * A Log In/Log Out button that maintains session state and logs
- * in/out for the app.
- * <p/>
- * This control will create and use the active session upon construction
- * if it has the available data (if the app ID is specified in the manifest).
- * It will also open the active session if it does not require user interaction
- * (i.e. if the session is in the {@link com.facebook.SessionState#CREATED_TOKEN_LOADED} state.
- * Developers can override the use of the active session by calling
- * the {@link #setSession(com.facebook.Session)} method.
- */
-public class LoginButton extends Button {
-
-    private static final String TAG = LoginButton.class.getName();
-    private String applicationId = null;
-    private SessionTracker sessionTracker;
-    private GraphUser user = null;
-    private Session userInfoSession = null; // the Session used to fetch the current user info
-    private boolean confirmLogout;
-    private boolean fetchUserInfo;
-    private String loginText;
-    private String logoutText;
-    private UserInfoChangedCallback userInfoChangedCallback;
-    private Fragment parentFragment;
-    private LoginButtonProperties properties = new LoginButtonProperties();
-    private String loginLogoutEventName = AnalyticsEvents.EVENT_LOGIN_VIEW_USAGE;
-
-    static class LoginButtonProperties {
-        private SessionDefaultAudience defaultAudience = SessionDefaultAudience.FRIENDS;
-        private List<String> permissions = Collections.<String>emptyList();
-        private SessionAuthorizationType authorizationType = null;
-        private OnErrorListener onErrorListener;
-        private SessionLoginBehavior loginBehavior = SessionLoginBehavior.SSO_WITH_FALLBACK;
-        private Session.StatusCallback sessionStatusCallback;
-
-        public void setOnErrorListener(OnErrorListener onErrorListener) {
-            this.onErrorListener = onErrorListener;
-        }
-
-        public OnErrorListener getOnErrorListener() {
-            return onErrorListener;
-        }
-
-        public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
-            this.defaultAudience = defaultAudience;
-        }
-
-        public SessionDefaultAudience getDefaultAudience() {
-            return defaultAudience;
-        }
-
-        public void setReadPermissions(List<String> permissions, Session session) {
-            if (SessionAuthorizationType.PUBLISH.equals(authorizationType)) {
-                throw new UnsupportedOperationException(
-                        "Cannot call setReadPermissions after setPublishPermissions has been called.");
-            }
-            if (validatePermissions(permissions, SessionAuthorizationType.READ, session)) {
-                this.permissions = permissions;
-                authorizationType = SessionAuthorizationType.READ;
-            }
-        }
-
-        public void setPublishPermissions(List<String> permissions, Session session) {
-            if (SessionAuthorizationType.READ.equals(authorizationType)) {
-                throw new UnsupportedOperationException(
-                        "Cannot call setPublishPermissions after setReadPermissions has been called.");
-            }
-            if (validatePermissions(permissions, SessionAuthorizationType.PUBLISH, session)) {
-                this.permissions = permissions;
-                authorizationType = SessionAuthorizationType.PUBLISH;
-            }
-        }
-
-        private boolean validatePermissions(List<String> permissions,
-                SessionAuthorizationType authType, Session currentSession) {
-            if (SessionAuthorizationType.PUBLISH.equals(authType)) {
-                if (Utility.isNullOrEmpty(permissions)) {
-                    throw new IllegalArgumentException("Permissions for publish actions cannot be null or empty.");
-                }
-            }
-            if (currentSession != null && currentSession.isOpened()) {
-                if (!Utility.isSubset(permissions, currentSession.getPermissions())) {
-                    Log.e(TAG, "Cannot set additional permissions when session is already open.");
-                    return false;
-                }
-            }
-            return true;
-        }
-
-        List<String> getPermissions() {
-            return permissions;
-        }
-
-        public void clearPermissions() {
-            permissions = null;
-            authorizationType = null;
-        }
-
-        public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
-            this.loginBehavior = loginBehavior;
-        }
-
-        public SessionLoginBehavior getLoginBehavior() {
-            return loginBehavior;
-        }
-
-        public void setSessionStatusCallback(Session.StatusCallback callback) {
-            this.sessionStatusCallback = callback;
-        }
-
-        public Session.StatusCallback getSessionStatusCallback() {
-            return sessionStatusCallback;
-        }
-    }
-
-    /**
-     * Specifies a callback interface that will be called when the button's notion of the current
-     * user changes (if the fetch_user_info attribute is true for this control).
-     */
-    public interface UserInfoChangedCallback {
-        /**
-         * Called when the current user changes.
-         * @param user  the current user, or null if there is no user
-         */
-        void onUserInfoFetched(GraphUser user);
-    }
-
-    /**
-     * Callback interface that will be called when a network or other error is encountered
-     * while logging in.
-     */
-    public interface OnErrorListener {
-        /**
-         * Called when a network or other error is encountered.
-         * @param error     a FacebookException representing the error that was encountered.
-         */
-        void onError(FacebookException error);
-    }
-
-    /**
-     * Create the LoginButton.
-     *
-     * @see View#View(Context)
-     */
-    public LoginButton(Context context) {
-        super(context);
-        initializeActiveSessionWithCachedToken(context);
-        // since onFinishInflate won't be called, we need to finish initialization ourselves
-        finishInit();
-    }
-
-    /**
-     * Create the LoginButton by inflating from XML
-     *
-     * @see View#View(Context, AttributeSet)
-     */
-    public LoginButton(Context context, AttributeSet attrs) {
-        super(context, attrs);
-
-        if (attrs.getStyleAttribute() == 0) {
-            // apparently there's no method of setting a default style in xml,
-            // so in case the users do not explicitly specify a style, we need
-            // to use sensible defaults.
-            this.setGravity(Gravity.CENTER);
-            this.setTextColor(getResources().getColor(R.color.com_facebook_loginview_text_color));
-            this.setTextSize(TypedValue.COMPLEX_UNIT_PX,
-                    getResources().getDimension(R.dimen.com_facebook_loginview_text_size));
-            this.setTypeface(Typeface.DEFAULT_BOLD);
-            if (isInEditMode()) {
-                // cannot use a drawable in edit mode, so setting the background color instead
-                // of a background resource.
-                this.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
-                // hardcoding in edit mode as getResources().getString() doesn't seem to work in IntelliJ
-                loginText = "Log in with Facebook";
-            } else {
-                this.setBackgroundResource(R.drawable.com_facebook_button_blue);
-                this.setCompoundDrawablesWithIntrinsicBounds(R.drawable.com_facebook_inverse_icon, 0, 0, 0);
-                this.setCompoundDrawablePadding(
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_compound_drawable_padding));
-                this.setPadding(getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_left),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_top),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_right),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_loginview_padding_bottom));
-            }
-        }
-        parseAttributes(attrs);
-        if (!isInEditMode()) {
-            initializeActiveSessionWithCachedToken(context);
-        }        
-    }
-
-    /**
-     * Create the LoginButton by inflating from XML and applying a style.
-     *
-     * @see View#View(Context, AttributeSet, int)
-     */
-    public LoginButton(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        parseAttributes(attrs);
-        initializeActiveSessionWithCachedToken(context);
-    }
-
-    /**
-     * Sets an OnErrorListener for this instance of LoginButton to call into when
-     * certain exceptions occur.
-     *
-     * @param onErrorListener The listener object to set
-     */
-    public void setOnErrorListener(OnErrorListener onErrorListener) {
-        properties.setOnErrorListener(onErrorListener);
-    }
-
-    /**
-     * Returns the current OnErrorListener for this instance of LoginButton.
-     *
-     * @return The OnErrorListener
-     */
-    public OnErrorListener getOnErrorListener() {
-        return properties.getOnErrorListener();
-    }
-
-    /**
-     * Sets the default audience to use when the session is opened.
-     * This value is only useful when specifying write permissions for the native
-     * login dialog.
-     *
-     * @param defaultAudience the default audience value to use
-     */
-    public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
-        properties.setDefaultAudience(defaultAudience);
-    }
-
-    /**
-     * Gets the default audience to use when the session is opened.
-     * This value is only useful when specifying write permissions for the native
-     * login dialog.
-     *
-     * @return the default audience value to use
-     */
-    public SessionDefaultAudience getDefaultAudience() {
-        return properties.getDefaultAudience();
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * can only be read permissions. If any publish permissions are included, the login
-     * attempt by the user will fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setPublishPermissions has been called
-     */
-    public void setReadPermissions(List<String> permissions) {
-        properties.setReadPermissions(permissions, sessionTracker.getSession());
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * can only be read permissions. If any publish permissions are included, the login
-     * attempt by the user will fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setPublishPermissions has been called
-     */
-    public void setReadPermissions(String... permissions) {
-        properties.setReadPermissions(Arrays.asList(permissions), sessionTracker.getSession());
-    }
-
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * should only be publish permissions. If any read permissions are included, the login
-     * attempt by the user may fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setReadPermissions has been called
-     * @throws IllegalArgumentException if permissions is null or empty
-     */
-    public void setPublishPermissions(List<String> permissions) {
-        properties.setPublishPermissions(permissions, sessionTracker.getSession());
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * should only be publish permissions. If any read permissions are included, the login
-     * attempt by the user may fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setReadPermissions has been called
-     * @throws IllegalArgumentException if permissions is null or empty
-     */
-    public void setPublishPermissions(String... permissions) {
-        properties.setPublishPermissions(Arrays.asList(permissions), sessionTracker.getSession());
-    }
-
-
-    /**
-     * Clears the permissions currently associated with this LoginButton.
-     */
-    public void clearPermissions() {
-        properties.clearPermissions();
-    }
-
-    /**
-     * Sets the login behavior for the session that will be opened. If null is specified,
-     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
-     * will be used.
-     *
-     * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *                      specifies what behaviors should be attempted during
-     *                      authorization.
-     */
-    public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
-        properties.setLoginBehavior(loginBehavior);
-    }
-
-    /**
-     * Gets the login behavior for the session that will be opened. If null is returned,
-     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
-     * will be used.
-     *
-     * @return loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *                      specifies what behaviors should be attempted during
-     *                      authorization.
-     */
-    public SessionLoginBehavior getLoginBehavior() {
-        return properties.getLoginBehavior();
-    }
-
-    /**
-     * Set the application ID to be used to open the session.
-     *
-     * @param applicationId the application ID to use
-     */
-    public void setApplicationId(String applicationId) {
-        this.applicationId = applicationId;
-    }
-
-    /**
-     * Gets the callback interface that will be called when the current user changes.
-     * @return the callback interface
-     */
-    public UserInfoChangedCallback getUserInfoChangedCallback() {
-        return userInfoChangedCallback;
-    }
-
-    /**
-     * Sets the callback interface that will be called when the current user changes.
-     *
-     * @param userInfoChangedCallback   the callback interface
-     */
-    public void setUserInfoChangedCallback(UserInfoChangedCallback userInfoChangedCallback) {
-        this.userInfoChangedCallback = userInfoChangedCallback;
-    }
-
-    /**
-     * Sets the callback interface that will be called whenever the status of the Session
-     * associated with this LoginButton changes. Note that updates will only be sent to the
-     * callback while the LoginButton is actually attached to a window.
-     *
-     * @param callback the callback interface
-     */
-    public void setSessionStatusCallback(Session.StatusCallback callback) {
-        properties.setSessionStatusCallback(callback);
-    }
-
-    /**
-     * Sets the callback interface that will be called whenever the status of the Session
-     * associated with this LoginButton changes.
-
-     * @return the callback interface
-     */
-    public Session.StatusCallback getSessionStatusCallback() {
-        return properties.getSessionStatusCallback();
-    }
-
-    /**
-     * Provides an implementation for {@link Activity#onActivityResult
-     * onActivityResult} that updates the Session based on information returned
-     * during the authorization flow. The Activity containing this view
-     * should forward the resulting onActivityResult call here to
-     * update the Session state based on the contents of the resultCode and
-     * data.
-     *
-     * @param requestCode
-     *            The requestCode parameter from the forwarded call. When this
-     *            onActivityResult occurs as part of Facebook authorization
-     *            flow, this value is the activityCode passed to open or
-     *            authorize.
-     * @param resultCode
-     *            An int containing the resultCode parameter from the forwarded
-     *            call.
-     * @param data
-     *            The Intent passed as the data parameter from the forwarded
-     *            call.
-     * @return A boolean indicating whether the requestCode matched a pending
-     *         authorization request for this Session.
-     * @see Session#onActivityResult(Activity, int, int, Intent)
-     */
-    public boolean onActivityResult(int requestCode, int resultCode, Intent data) {
-        Session session = sessionTracker.getSession();
-        if (session != null) {
-            return session.onActivityResult((Activity)getContext(), requestCode,
-                    resultCode, data);
-        } else {
-            return false;
-        }
-    }
-
-    /**
-     * Set the Session object to use instead of the active Session. Since a Session
-     * cannot be reused, if the user logs out from this Session, and tries to
-     * log in again, a new Active Session will be used instead.
-     * <p/>
-     * If the passed in session is currently opened, this method will also attempt to
-     * load some user information for display (if needed).
-     *
-     * @param newSession the Session object to use
-     * @throws FacebookException if errors occur during the loading of user information
-     */
-    public void setSession(Session newSession) {
-        sessionTracker.setSession(newSession);
-        fetchUserInfo();
-        setButtonText();
-    }
-
-    @Override
-    public void onFinishInflate() {
-        super.onFinishInflate();
-        finishInit();
-    }
-
-    private void finishInit() {
-        setOnClickListener(new LoginClickListener());
-        setButtonText();
-        if (!isInEditMode()) {
-            sessionTracker = new SessionTracker(getContext(), new LoginButtonCallback(), null, false);
-            fetchUserInfo();
-        }
-    }
-
-    /**
-     * Sets the fragment that contains this control. This allows the LoginButton to be
-     * embedded inside a Fragment, and will allow the fragment to receive the
-     * {@link Fragment#onActivityResult(int, int, android.content.Intent) onActivityResult}
-     * call rather than the Activity.
-     *
-     * @param fragment the fragment that contains this control
-     */
-    public void setFragment(Fragment fragment) {
-        parentFragment = fragment;
-    }
-
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-        if (sessionTracker != null && !sessionTracker.isTracking()) {
-            sessionTracker.startTracking();
-            fetchUserInfo();
-            setButtonText();
-        }
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        super.onDetachedFromWindow();
-        if (sessionTracker != null) {
-            sessionTracker.stopTracking();
-        }
-    }
-
-    // For testing purposes only
-    List<String> getPermissions() {
-        return properties.getPermissions();
-    }
-
-    void setProperties(LoginButtonProperties properties) {
-        this.properties = properties;
-    }
-
-    void setLoginLogoutEventName(String eventName) {
-        loginLogoutEventName = eventName;
-    }
-
-    private void parseAttributes(AttributeSet attrs) {
-        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.com_facebook_login_view);
-        confirmLogout = a.getBoolean(R.styleable.com_facebook_login_view_confirm_logout, true);
-        fetchUserInfo = a.getBoolean(R.styleable.com_facebook_login_view_fetch_user_info, true);
-        loginText = a.getString(R.styleable.com_facebook_login_view_login_text);
-        logoutText = a.getString(R.styleable.com_facebook_login_view_logout_text);
-        a.recycle();
-    }
-
-    private void setButtonText() {
-        if (sessionTracker != null && sessionTracker.getOpenSession() != null) {
-            setText((logoutText != null) ? logoutText :
-                    getResources().getString(R.string.com_facebook_loginview_log_out_button));
-        } else {
-            setText((loginText != null) ? loginText :
-                    getResources().getString(R.string.com_facebook_loginview_log_in_button));
-        }
-    }
-
-    private boolean initializeActiveSessionWithCachedToken(Context context) {
-        if (context == null) {
-            return false;
-        }
-
-        Session session = Session.getActiveSession();
-        if (session != null) {
-            return session.isOpened();
-        }
-
-        String applicationId = Utility.getMetadataApplicationId(context);
-        if (applicationId == null) {
-            return false;
-        }
-
-        return Session.openActiveSessionFromCache(context) != null;
-    }
-
-    private void fetchUserInfo() {
-        if (fetchUserInfo) {
-            final Session currentSession = sessionTracker.getOpenSession();
-            if (currentSession != null) {
-                if (currentSession != userInfoSession) {
-                    Request request = Request.newMeRequest(currentSession, new Request.GraphUserCallback() {
-                        @Override
-                        public void onCompleted(GraphUser me,  Response response) {
-                            if (currentSession == sessionTracker.getOpenSession()) {
-                                user = me;
-                                if (userInfoChangedCallback != null) {
-                                    userInfoChangedCallback.onUserInfoFetched(user);
-                                }
-                            }
-                            if (response.getError() != null) {
-                                handleError(response.getError().getException());
-                            }
-                        }
-                    });
-                    Request.executeBatchAsync(request);
-                    userInfoSession = currentSession;
-                }
-            } else {
-                user = null;
-                if (userInfoChangedCallback != null) {
-                    userInfoChangedCallback.onUserInfoFetched(user);
-                }
-            }
-        }
-    }
-
-    private class LoginClickListener implements OnClickListener {
-
-        @Override
-        public void onClick(View v) {
-            Context context = getContext();
-            final Session openSession = sessionTracker.getOpenSession();
-
-            if (openSession != null) {
-                // If the Session is currently open, it must mean we need to log out
-                if (confirmLogout) {
-                    // Create a confirmation dialog
-                    String logout = getResources().getString(R.string.com_facebook_loginview_log_out_action);
-                    String cancel = getResources().getString(R.string.com_facebook_loginview_cancel_action);
-                    String message;
-                    if (user != null && user.getName() != null) {
-                        message = String.format(getResources().getString(R.string.com_facebook_loginview_logged_in_as), user.getName());
-                    } else {
-                        message = getResources().getString(R.string.com_facebook_loginview_logged_in_using_facebook);
-                    }
-                    AlertDialog.Builder builder = new AlertDialog.Builder(context);
-                    builder.setMessage(message)
-                           .setCancelable(true)
-                           .setPositiveButton(logout, new DialogInterface.OnClickListener() {
-                               public void onClick(DialogInterface dialog, int which) {
-                                   openSession.closeAndClearTokenInformation();
-                               }
-                           })
-                           .setNegativeButton(cancel, null);
-                    builder.create().show();
-                } else {
-                    openSession.closeAndClearTokenInformation();
-                }
-            } else {
-                Session currentSession = sessionTracker.getSession();
-                if (currentSession == null || currentSession.getState().isClosed()) {
-                    sessionTracker.setSession(null);
-                    Session session = new Session.Builder(context).setApplicationId(applicationId).build();
-                    Session.setActiveSession(session);
-                    currentSession = session;
-                }
-                if (!currentSession.isOpened()) {
-                    Session.OpenRequest openRequest = null;
-                    if (parentFragment != null) {
-                        openRequest = new Session.OpenRequest(parentFragment);
-                    } else if (context instanceof Activity) {
-                        openRequest = new Session.OpenRequest((Activity)context);
-                    }
-
-                    if (openRequest != null) {
-                        openRequest.setDefaultAudience(properties.defaultAudience);
-                        openRequest.setPermissions(properties.permissions);
-                        openRequest.setLoginBehavior(properties.loginBehavior);
-
-                        if (SessionAuthorizationType.PUBLISH.equals(properties.authorizationType)) {
-                            currentSession.openForPublish(openRequest);
-                        } else {
-                            currentSession.openForRead(openRequest);
-                        }
-                    }
-                }
-            }
-
-            AppEventsLogger logger = AppEventsLogger.newLogger(getContext());
-
-            Bundle parameters = new Bundle();
-            parameters.putInt("logging_in", (openSession != null) ? 0 : 1);
-
-            logger.logSdkEvent(loginLogoutEventName, null, parameters);
-        }
-    }
-
-    private class LoginButtonCallback implements Session.StatusCallback {
-        @Override
-        public void call(Session session, SessionState state,
-                         Exception exception) {
-            fetchUserInfo();
-            setButtonText();
-
-            // if the client has a status callback registered, call it, otherwise
-            // call the default handleError method, but don't call both
-            if (properties.sessionStatusCallback != null) {
-                properties.sessionStatusCallback.call(session, state, exception);
-            } else if (exception != null) {
-                handleError(exception);
-            }
-        }
-    };
-
-    void handleError(Exception exception) {
-        if (properties.onErrorListener != null) {
-            if (exception instanceof FacebookException) {
-                properties.onErrorListener.onError((FacebookException)exception);
-            } else {
-                properties.onErrorListener.onError(new FacebookException(exception));
-            }
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/widget/PickerFragment.java b/facebook/src/com/facebook/widget/PickerFragment.java
deleted file mode 100644
index ca6258b4d..000000000
--- a/facebook/src/com/facebook/widget/PickerFragment.java
+++ /dev/null
@@ -1,1070 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.drawable.Drawable;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.support.v4.app.LoaderManager;
-import android.support.v4.content.Loader;
-import android.text.TextUtils;
-import android.util.AttributeSet;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.ViewStub;
-import android.view.animation.AlphaAnimation;
-import android.widget.*;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.model.GraphObject;
-import com.facebook.internal.SessionTracker;
-
-import java.util.*;
-
-/**
- * Provides functionality common to SDK UI elements that allow the user to pick one or more
- * graph objects (e.g., places, friends) from a list of possibilities. The UI is exposed as a
- * Fragment to allow to it to be included in an Activity along with other Fragments. The Fragments
- * can be configured by passing parameters as part of their Intent bundle, or (for certain
- * properties) by specifying attributes in their XML layout files.
- * <br/>
- * PickerFragments support callbacks that will be called in the event of an error, when the
- * underlying data has been changed, or when the set of selected graph objects changes.
- */
-public abstract class PickerFragment<T extends GraphObject> extends Fragment {
-    /**
-     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
-     * picker should show pictures (if available) for the graph objects.
-     */
-    public static final String SHOW_PICTURES_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ShowPictures";
-    /**
-     * The key for a String parameter in the fragment's Intent bundle to indicate which extra fields
-     * beyond the default fields should be retrieved for any graph objects in the results.
-     */
-    public static final String EXTRA_FIELDS_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ExtraFields";
-    /**
-     * The key for a boolean parameter in the fragment's Intent bundle to indicate whether the
-     * picker should display a title bar with a Done button.
-     */
-    public static final String SHOW_TITLE_BAR_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ShowTitleBar";
-    /**
-     * The key for a String parameter in the fragment's Intent bundle to indicate the text to
-     * display in the title bar.
-     */
-    public static final String TITLE_TEXT_BUNDLE_KEY = "com.facebook.widget.PickerFragment.TitleText";
-    /**
-     * The key for a String parameter in the fragment's Intent bundle to indicate the text to
-     * display in the Done btuton.
-     */
-    public static final String DONE_BUTTON_TEXT_BUNDLE_KEY = "com.facebook.widget.PickerFragment.DoneButtonText";
-
-    private static final String SELECTION_BUNDLE_KEY = "com.facebook.android.PickerFragment.Selection";
-    private static final String ACTIVITY_CIRCLE_SHOW_KEY = "com.facebook.android.PickerFragment.ActivityCircleShown";
-    private static final int PROFILE_PICTURE_PREFETCH_BUFFER = 5;
-
-    private final int layout;
-    private OnErrorListener onErrorListener;
-    private OnDataChangedListener onDataChangedListener;
-    private OnSelectionChangedListener onSelectionChangedListener;
-    private OnDoneButtonClickedListener onDoneButtonClickedListener;
-    private GraphObjectFilter<T> filter;
-    private boolean showPictures = true;
-    private boolean showTitleBar = true;
-    private ListView listView;
-    HashSet<String> extraFields = new HashSet<String>();
-    GraphObjectAdapter<T> adapter;
-    private final Class<T> graphObjectClass;
-    private LoadingStrategy loadingStrategy;
-    private SelectionStrategy selectionStrategy;
-    private ProgressBar activityCircle;
-    private SessionTracker sessionTracker;
-    private String titleText;
-    private String doneButtonText;
-    private TextView titleTextView;
-    private Button doneButton;
-    private Drawable titleBarBackground;
-    private Drawable doneButtonBackground;
-    private boolean appEventsLogged;
-
-    PickerFragment(Class<T> graphObjectClass, int layout, Bundle args) {
-        this.graphObjectClass = graphObjectClass;
-        this.layout = layout;
-
-        setPickerFragmentSettingsFromBundle(args);
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        adapter = createAdapter();
-        adapter.setFilter(new GraphObjectAdapter.Filter<T>() {
-            @Override
-            public boolean includeItem(T graphObject) {
-                return filterIncludesItem(graphObject);
-            }
-        });
-    }
-
-    @Override
-    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
-        super.onInflate(activity, attrs, savedInstanceState);
-        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_picker_fragment);
-
-        setShowPictures(a.getBoolean(R.styleable.com_facebook_picker_fragment_show_pictures, showPictures));
-        String extraFieldsString = a.getString(R.styleable.com_facebook_picker_fragment_extra_fields);
-        if (extraFieldsString != null) {
-            String[] strings = extraFieldsString.split(",");
-            setExtraFields(Arrays.asList(strings));
-        }
-
-        showTitleBar = a.getBoolean(R.styleable.com_facebook_picker_fragment_show_title_bar, showTitleBar);
-        titleText = a.getString(R.styleable.com_facebook_picker_fragment_title_text);
-        doneButtonText = a.getString(R.styleable.com_facebook_picker_fragment_done_button_text);
-        titleBarBackground = a.getDrawable(R.styleable.com_facebook_picker_fragment_title_bar_background);
-        doneButtonBackground = a.getDrawable(R.styleable.com_facebook_picker_fragment_done_button_background);
-
-        a.recycle();
-    }
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        ViewGroup view = (ViewGroup) inflater.inflate(layout, container, false);
-
-        listView = (ListView) view.findViewById(R.id.com_facebook_picker_list_view);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-            @Override
-            public void onItemClick(AdapterView<?> parent, View v, int position, long id) {
-                onListItemClick((ListView) parent, v, position);
-            }
-        });
-        listView.setOnLongClickListener(new View.OnLongClickListener() {
-            @Override
-            public boolean onLongClick(View v) {
-                // We don't actually do anything differently on long-clicks, but setting the listener
-                // enables the selector transition that we have for visual consistency with the
-                // Facebook app's pickers.
-                return false;
-            }
-        });
-        listView.setOnScrollListener(onScrollListener);
-
-        activityCircle = (ProgressBar) view.findViewById(R.id.com_facebook_picker_activity_circle);
-
-        setupViews(view);
-
-        listView.setAdapter(adapter);
-
-        return view;
-    }
-
-    @Override
-    public void onActivityCreated(final Bundle savedInstanceState) {
-        super.onActivityCreated(savedInstanceState);
-
-        sessionTracker = new SessionTracker(getActivity(), new Session.StatusCallback() {
-            @Override
-            public void call(Session session, SessionState state, Exception exception) {
-                if (!session.isOpened()) {
-                    // When a session is closed, we want to clear out our data so it is not visible to subsequent users
-                    clearResults();
-                }
-            }
-        });
-
-        setSettingsFromBundle(savedInstanceState);
-
-        loadingStrategy = createLoadingStrategy();
-        loadingStrategy.attach(adapter);
-
-        selectionStrategy = createSelectionStrategy();
-        selectionStrategy.readSelectionFromBundle(savedInstanceState, SELECTION_BUNDLE_KEY);
-
-        // Should we display a title bar? (We need to do this after we've retrieved our bundle settings.)
-        if (showTitleBar) {
-            inflateTitleBar((ViewGroup) getView());
-        }
-
-        if (activityCircle != null && savedInstanceState != null) {
-            boolean shown = savedInstanceState.getBoolean(ACTIVITY_CIRCLE_SHOW_KEY, false);
-            if (shown) {
-                displayActivityCircle();
-            } else {
-                // Should be hidden already, but just to be sure.
-                hideActivityCircle();
-            }
-        }
-    }
-
-    @Override
-    public void onDetach() {
-        super.onDetach();
-
-        listView.setOnScrollListener(null);
-        listView.setAdapter(null);
-
-        loadingStrategy.detach();
-        sessionTracker.stopTracking();
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-
-        saveSettingsToBundle(outState);
-        selectionStrategy.saveSelectionToBundle(outState, SELECTION_BUNDLE_KEY);
-        if (activityCircle != null) {
-            outState.putBoolean(ACTIVITY_CIRCLE_SHOW_KEY, activityCircle.getVisibility() == View.VISIBLE);
-        }
-    }
-
-    @Override
-    public void onStop() {
-        if (!appEventsLogged) {
-            logAppEvents(false);
-        }
-        super.onStop();
-    }
-
-    @Override
-    public void setArguments(Bundle args) {
-        super.setArguments(args);
-        setSettingsFromBundle(args);
-    }
-
-    /**
-     * Gets the current OnDataChangedListener for this fragment, which will be called whenever
-     * the underlying data being displaying in the picker has changed.
-     *
-     * @return the OnDataChangedListener, or null if there is none
-     */
-    public OnDataChangedListener getOnDataChangedListener() {
-        return onDataChangedListener;
-    }
-
-    /**
-     * Sets the current OnDataChangedListener for this fragment, which will be called whenever
-     * the underlying data being displaying in the picker has changed.
-     *
-     * @param onDataChangedListener the OnDataChangedListener, or null if there is none
-     */
-    public void setOnDataChangedListener(OnDataChangedListener onDataChangedListener) {
-        this.onDataChangedListener = onDataChangedListener;
-    }
-
-    /**
-     * Gets the current OnSelectionChangedListener for this fragment, which will be called
-     * whenever the user selects or unselects a graph object in the list.
-     *
-     * @return the OnSelectionChangedListener, or null if there is none
-     */
-    public OnSelectionChangedListener getOnSelectionChangedListener() {
-        return onSelectionChangedListener;
-    }
-
-    /**
-     * Sets the current OnSelectionChangedListener for this fragment, which will be called
-     * whenever the user selects or unselects a graph object in the list.
-     *
-     * @param onSelectionChangedListener the OnSelectionChangedListener, or null if there is none
-     */
-    public void setOnSelectionChangedListener(
-            OnSelectionChangedListener onSelectionChangedListener) {
-        this.onSelectionChangedListener = onSelectionChangedListener;
-    }
-
-    /**
-     * Gets the current OnDoneButtonClickedListener for this fragment, which will be called
-     * when the user clicks the Done button.
-     *
-     * @return the OnDoneButtonClickedListener, or null if there is none
-     */
-    public OnDoneButtonClickedListener getOnDoneButtonClickedListener() {
-        return onDoneButtonClickedListener;
-    }
-
-    /**
-     * Sets the current OnDoneButtonClickedListener for this fragment, which will be called
-     * when the user clicks the Done button. This will only be possible if the title bar is
-     * being shown in this fragment.
-     *
-     * @param onDoneButtonClickedListener the OnDoneButtonClickedListener, or null if there is none
-     */
-    public void setOnDoneButtonClickedListener(OnDoneButtonClickedListener onDoneButtonClickedListener) {
-        this.onDoneButtonClickedListener = onDoneButtonClickedListener;
-    }
-
-    /**
-     * Gets the current OnErrorListener for this fragment, which will be called in the event
-     * of network or other errors encountered while populating the graph objects in the list.
-     *
-     * @return the OnErrorListener, or null if there is none
-     */
-    public OnErrorListener getOnErrorListener() {
-        return onErrorListener;
-    }
-
-    /**
-     * Sets the current OnErrorListener for this fragment, which will be called in the event
-     * of network or other errors encountered while populating the graph objects in the list.
-     *
-     * @param onErrorListener the OnErrorListener, or null if there is none
-     */
-    public void setOnErrorListener(OnErrorListener onErrorListener) {
-        this.onErrorListener = onErrorListener;
-    }
-
-    /**
-     * Gets the current filter for this fragment, which will be called for each graph object
-     * returned from the service to determine if it should be displayed in the list.
-     * If no filter is specified, all retrieved graph objects will be displayed.
-     *
-     * @return the GraphObjectFilter, or null if there is none
-     */
-    public GraphObjectFilter<T> getFilter() {
-        return filter;
-    }
-
-    /**
-     * Sets the current filter for this fragment, which will be called for each graph object
-     * returned from the service to determine if it should be displayed in the list.
-     * If no filter is specified, all retrieved graph objects will be displayed.
-     *
-     * @param filter the GraphObjectFilter, or null if there is none
-     */
-    public void setFilter(GraphObjectFilter<T> filter) {
-        this.filter = filter;
-    }
-
-    /**
-     * Gets the Session to use for any Facebook requests this fragment will make.
-     *
-     * @return the Session that will be used for any Facebook requests, or null if there is none
-     */
-    public Session getSession() {
-        return sessionTracker.getSession();
-    }
-
-    /**
-     * Sets the Session to use for any Facebook requests this fragment will make. If the
-     * parameter is null, the fragment will use the current active session, if any.
-     *
-     * @param session the Session to use for Facebook requests, or null to use the active session
-     */
-    public void setSession(Session session) {
-        sessionTracker.setSession(session);
-    }
-
-    /**
-     * Gets whether to display pictures, if available, for displayed graph objects.
-     *
-     * @return true if pictures should be displayed, false if not
-     */
-    public boolean getShowPictures() {
-        return showPictures;
-    }
-
-    /**
-     * Sets whether to display pictures, if available, for displayed graph objects.
-     *
-     * @param showPictures true if pictures should be displayed, false if not
-     */
-    public void setShowPictures(boolean showPictures) {
-        this.showPictures = showPictures;
-    }
-
-    /**
-     * Gets the extra fields to request for the retrieved graph objects.
-     *
-     * @return the extra fields to request
-     */
-    public Set<String> getExtraFields() {
-        return new HashSet<String>(extraFields);
-    }
-
-    /**
-     * Sets the extra fields to request for the retrieved graph objects.
-     *
-     * @param fields the extra fields to request
-     */
-    public void setExtraFields(Collection<String> fields) {
-        extraFields = new HashSet<String>();
-        if (fields != null) {
-            extraFields.addAll(fields);
-        }
-    }
-
-    /**
-     * Sets whether to show a title bar with a Done button. This must be
-     * called prior to the Fragment going through its creation lifecycle to have an effect.
-     *
-     * @param showTitleBar true if a title bar should be displayed, false if not
-     */
-    public void setShowTitleBar(boolean showTitleBar) {
-        this.showTitleBar = showTitleBar;
-    }
-
-    /**
-     * Gets whether to show a title bar with a Done button. The default is true.
-     *
-     * @return true if a title bar will be shown, false if not.
-     */
-    public boolean getShowTitleBar() {
-        return showTitleBar;
-    }
-
-    /**
-     * Sets the text to show in the title bar, if a title bar is to be shown. This must be
-     * called prior to the Fragment going through its creation lifecycle to have an effect, or
-     * the default will be used.
-     *
-     * @param titleText the text to show in the title bar
-     */
-    public void setTitleText(String titleText) {
-        this.titleText = titleText;
-    }
-
-    /**
-     * Gets the text to show in the title bar, if a title bar is to be shown.
-     *
-     * @return the text to show in the title bar
-     */
-    public String getTitleText() {
-        if (titleText == null) {
-            titleText = getDefaultTitleText();
-        }
-        return titleText;
-    }
-
-    /**
-     * Sets the text to show in the Done button, if a title bar is to be shown. This must be
-     * called prior to the Fragment going through its creation lifecycle to have an effect, or
-     * the default will be used.
-     *
-     * @param doneButtonText the text to show in the Done button
-     */
-    public void setDoneButtonText(String doneButtonText) {
-        this.doneButtonText = doneButtonText;
-    }
-
-    /**
-     * Gets the text to show in the Done button, if a title bar is to be shown.
-     *
-     * @return the text to show in the Done button
-     */
-    public String getDoneButtonText() {
-        if (doneButtonText == null) {
-            doneButtonText = getDefaultDoneButtonText();
-        }
-        return doneButtonText;
-    }
-
-    /**
-     * Causes the picker to load data from the service and display it to the user.
-     *
-     * @param forceReload if true, data will be loaded even if there is already data being displayed (or loading);
-     *                    if false, data will not be re-loaded if it is already displayed (or loading)
-     */
-    public void loadData(boolean forceReload) {
-        if (!forceReload && loadingStrategy.isDataPresentOrLoading()) {
-            return;
-        }
-        loadDataSkippingRoundTripIfCached();
-    }
-
-    /**
-     * Updates the properties of the PickerFragment based on the contents of the supplied Bundle;
-     * calling Activities may use this to pass additional configuration information to the
-     * PickerFragment beyond what is specified in its XML layout.
-     *
-     * @param inState a Bundle containing keys corresponding to properties of the PickerFragment
-     */
-    public void setSettingsFromBundle(Bundle inState) {
-        setPickerFragmentSettingsFromBundle(inState);
-    }
-
-    void setupViews(ViewGroup view) {
-    }
-
-    boolean filterIncludesItem(T graphObject) {
-        if (filter != null) {
-            return filter.includeItem(graphObject);
-        }
-        return true;
-    }
-
-    List<T> getSelectedGraphObjects() {
-        return adapter.getGraphObjectsById(selectionStrategy.getSelectedIds());
-    }
-
-    void saveSettingsToBundle(Bundle outState) {
-        outState.putBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
-        if (!extraFields.isEmpty()) {
-            outState.putString(EXTRA_FIELDS_BUNDLE_KEY, TextUtils.join(",", extraFields));
-        }
-        outState.putBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
-        outState.putString(TITLE_TEXT_BUNDLE_KEY, titleText);
-        outState.putString(DONE_BUTTON_TEXT_BUNDLE_KEY, doneButtonText);
-    }
-
-    abstract Request getRequestForLoadData(Session session);
-
-    abstract PickerFragmentAdapter<T> createAdapter();
-
-    abstract LoadingStrategy createLoadingStrategy();
-
-    abstract SelectionStrategy createSelectionStrategy();
-
-    void onLoadingData() {
-    }
-
-    String getDefaultTitleText() {
-        return null;
-    }
-
-    String getDefaultDoneButtonText() {
-        return getString(R.string.com_facebook_picker_done_button_text);
-    }
-
-    void displayActivityCircle() {
-        if (activityCircle != null) {
-            layoutActivityCircle();
-            activityCircle.setVisibility(View.VISIBLE);
-        }
-    }
-
-    void layoutActivityCircle() {
-        // If we've got no data, make the activity circle full-opacity. Otherwise we'll dim it to avoid
-        //  cluttering the UI.
-        float alpha = (!adapter.isEmpty()) ? .25f : 1.0f;
-        setAlpha(activityCircle, alpha);
-    }
-
-    void hideActivityCircle() {
-        if (activityCircle != null) {
-            // We use an animation to dim the activity circle; need to clear this or it will remain visible.
-            activityCircle.clearAnimation();
-            activityCircle.setVisibility(View.INVISIBLE);
-        }
-    }
-
-    void setSelectionStrategy(SelectionStrategy selectionStrategy) {
-        if (selectionStrategy != this.selectionStrategy) {
-            this.selectionStrategy = selectionStrategy;
-            if (adapter != null) {
-                // Adapter should cause a re-render.
-                adapter.notifyDataSetChanged();
-            }
-        }
-    }
-
-    void logAppEvents(boolean doneButtonClicked) {
-    }
-
-    private static void setAlpha(View view, float alpha) {
-        // Set the alpha appropriately (setAlpha is API >= 11, this technique works on all API levels).
-        AlphaAnimation alphaAnimation = new AlphaAnimation(alpha, alpha);
-        alphaAnimation.setDuration(0);
-        alphaAnimation.setFillAfter(true);
-        view.startAnimation(alphaAnimation);
-    }
-
-
-    private void setPickerFragmentSettingsFromBundle(Bundle inState) {
-        // We do this in a separate non-overridable method so it is safe to call from the constructor.
-        if (inState != null) {
-            showPictures = inState.getBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
-            String extraFieldsString = inState.getString(EXTRA_FIELDS_BUNDLE_KEY);
-            if (extraFieldsString != null) {
-                String[] strings = extraFieldsString.split(",");
-                setExtraFields(Arrays.asList(strings));
-            }
-            showTitleBar = inState.getBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
-            String titleTextString = inState.getString(TITLE_TEXT_BUNDLE_KEY);
-            if (titleTextString != null) {
-                titleText = titleTextString;
-                if (titleTextView != null) {
-                    titleTextView.setText(titleText);
-                }
-            }
-            String doneButtonTextString = inState.getString(DONE_BUTTON_TEXT_BUNDLE_KEY);
-            if (doneButtonTextString != null) {
-                doneButtonText = doneButtonTextString;
-                if (doneButton != null) {
-                    doneButton.setText(doneButtonText);
-                }
-            }
-        }
-    }
-
-    private void inflateTitleBar(ViewGroup view) {
-        ViewStub stub = (ViewStub) view.findViewById(R.id.com_facebook_picker_title_bar_stub);
-        if (stub != null) {
-            View titleBar = stub.inflate();
-
-            final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
-                    RelativeLayout.LayoutParams.MATCH_PARENT,
-                    RelativeLayout.LayoutParams.MATCH_PARENT);
-            layoutParams.addRule(RelativeLayout.BELOW, R.id.com_facebook_picker_title_bar);
-            listView.setLayoutParams(layoutParams);
-
-            if (titleBarBackground != null) {
-                titleBar.setBackgroundDrawable(titleBarBackground);
-            }
-
-            doneButton = (Button) view.findViewById(R.id.com_facebook_picker_done_button);
-            if (doneButton != null) {
-                doneButton.setOnClickListener(new View.OnClickListener() {
-                    @Override
-                    public void onClick(View v) {
-                        logAppEvents(true);
-                        appEventsLogged = true;
-
-                        if (onDoneButtonClickedListener != null) {
-                            onDoneButtonClickedListener.onDoneButtonClicked(PickerFragment.this);
-                        }
-                    }
-                });
-
-                if (getDoneButtonText() != null) {
-                    doneButton.setText(getDoneButtonText());
-                }
-
-                if (doneButtonBackground != null) {
-                    doneButton.setBackgroundDrawable(doneButtonBackground);
-                }
-            }
-
-            titleTextView = (TextView) view.findViewById(R.id.com_facebook_picker_title);
-            if (titleTextView != null) {
-                if (getTitleText() != null) {
-                    titleTextView.setText(getTitleText());
-                }
-            }
-        }
-    }
-
-    private void onListItemClick(ListView listView, View v, int position) {
-        @SuppressWarnings("unchecked")
-        T graphObject = (T) listView.getItemAtPosition(position);
-        String id = adapter.getIdOfGraphObject(graphObject);
-        selectionStrategy.toggleSelection(id);
-        adapter.notifyDataSetChanged();
-
-        if (onSelectionChangedListener != null) {
-            onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
-        }
-    }
-
-    private void loadDataSkippingRoundTripIfCached() {
-        clearResults();
-
-        Request request = getRequestForLoadData(getSession());
-        if (request != null) {
-            onLoadingData();
-            loadingStrategy.startLoading(request);
-        }
-    }
-
-    private void clearResults() {
-        if (adapter != null) {
-            boolean wasSelection = !selectionStrategy.isEmpty();
-            boolean wasData = !adapter.isEmpty();
-
-            loadingStrategy.clearResults();
-            selectionStrategy.clear();
-            adapter.notifyDataSetChanged();
-
-            // Tell anyone who cares the data and selection has changed, if they have.
-            if (wasData && onDataChangedListener != null) {
-                onDataChangedListener.onDataChanged(PickerFragment.this);
-            }
-            if (wasSelection && onSelectionChangedListener != null) {
-                onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
-            }
-        }
-    }
-
-    void updateAdapter(SimpleGraphObjectCursor<T> data) {
-        if (adapter != null) {
-            // As we fetch additional results and add them to the table, we do not
-            // want the items displayed jumping around seemingly at random, frustrating the user's
-            // attempts at scrolling, etc. Since results may be added anywhere in
-            // the table, we choose to try to keep the first visible row in a fixed
-            // position (from the user's perspective). We try to keep it positioned at
-            // the same offset from the top of the screen so adding new items seems
-            // smoother, as opposed to having it "snap" to a multiple of row height
-
-            // We use the second row, to give context above and below it and avoid
-            // cases where the first row is only barely visible, thus providing little context.
-            // The exception is where the very first row is visible, in which case we use that.
-            View view = listView.getChildAt(1);
-            int anchorPosition = listView.getFirstVisiblePosition();
-            if (anchorPosition > 0) {
-                anchorPosition++;
-            }
-            GraphObjectAdapter.SectionAndItem<T> anchorItem = adapter.getSectionAndItem(anchorPosition);
-            final int top = (view != null &&
-                    anchorItem.getType() != GraphObjectAdapter.SectionAndItem.Type.ACTIVITY_CIRCLE) ?
-                    view.getTop() : 0;
-
-            // Now actually add the results.
-            boolean dataChanged = adapter.changeCursor(data);
-
-            if (view != null && anchorItem != null) {
-                // Put the item back in the same spot it was.
-                final int newPositionOfItem = adapter.getPosition(anchorItem.sectionKey, anchorItem.graphObject);
-                if (newPositionOfItem != -1) {
-                    listView.setSelectionFromTop(newPositionOfItem, top);
-                }
-            }
-
-            if (dataChanged && onDataChangedListener != null) {
-                onDataChangedListener.onDataChanged(PickerFragment.this);
-            }
-        }
-    }
-
-    private void reprioritizeDownloads() {
-        int lastVisibleItem = listView.getLastVisiblePosition();
-        if (lastVisibleItem >= 0) {
-            int firstVisibleItem = listView.getFirstVisiblePosition();
-            adapter.prioritizeViewRange(firstVisibleItem, lastVisibleItem, PROFILE_PICTURE_PREFETCH_BUFFER);
-        }
-    }
-
-    private ListView.OnScrollListener onScrollListener = new ListView.OnScrollListener() {
-        @Override
-        public void onScrollStateChanged(AbsListView view, int scrollState) {
-        }
-
-        @Override
-        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
-            reprioritizeDownloads();
-        }
-    };
-
-    /**
-     * Callback interface that will be called when a network or other error is encountered
-     * while retrieving graph objects.
-     */
-    public interface OnErrorListener {
-        /**
-         * Called when a network or other error is encountered.
-         *
-         * @param error a FacebookException representing the error that was encountered.
-         */
-        void onError(PickerFragment<?> fragment, FacebookException error);
-    }
-
-    /**
-     * Callback interface that will be called when the underlying data being displayed in the
-     * picker has been updated.
-     */
-    public interface OnDataChangedListener {
-        /**
-         * Called when the set of data being displayed in the picker has changed.
-         */
-        void onDataChanged(PickerFragment<?> fragment);
-    }
-
-    /**
-     * Callback interface that will be called when the user selects or unselects graph objects
-     * in the picker.
-     */
-    public interface OnSelectionChangedListener {
-        /**
-         * Called when the user selects or unselects graph objects in the picker.
-         */
-        void onSelectionChanged(PickerFragment<?> fragment);
-    }
-
-    /**
-     * Callback interface that will be called when the user clicks the Done button on the
-     * title bar.
-     */
-    public interface OnDoneButtonClickedListener {
-        /**
-         * Called when the user clicks the Done button.
-         */
-        void onDoneButtonClicked(PickerFragment<?> fragment);
-    }
-
-    /**
-     * Callback interface that will be called to determine if a graph object should be displayed.
-     *
-     * @param <T>
-     */
-    public interface GraphObjectFilter<T> {
-        /**
-         * Called to determine if a graph object should be displayed.
-         *
-         * @param graphObject the graph object
-         * @return true to display the graph object, false to hide it
-         */
-        boolean includeItem(T graphObject);
-    }
-
-    abstract class LoadingStrategy {
-        protected final static int CACHED_RESULT_REFRESH_DELAY = 2 * 1000;
-
-        protected GraphObjectPagingLoader<T> loader;
-        protected GraphObjectAdapter<T> adapter;
-
-        public void attach(GraphObjectAdapter<T> adapter) {
-            loader = (GraphObjectPagingLoader<T>) getLoaderManager().initLoader(0, null,
-                    new LoaderManager.LoaderCallbacks<SimpleGraphObjectCursor<T>>() {
-                        @Override
-                        public Loader<SimpleGraphObjectCursor<T>> onCreateLoader(int id, Bundle args) {
-                            return LoadingStrategy.this.onCreateLoader();
-                        }
-
-                        @Override
-                        public void onLoadFinished(Loader<SimpleGraphObjectCursor<T>> loader,
-                                SimpleGraphObjectCursor<T> data) {
-                            if (loader != LoadingStrategy.this.loader) {
-                                throw new FacebookException("Received callback for unknown loader.");
-                            }
-                            LoadingStrategy.this.onLoadFinished((GraphObjectPagingLoader<T>) loader, data);
-                        }
-
-                        @Override
-                        public void onLoaderReset(Loader<SimpleGraphObjectCursor<T>> loader) {
-                            if (loader != LoadingStrategy.this.loader) {
-                                throw new FacebookException("Received callback for unknown loader.");
-                            }
-                            LoadingStrategy.this.onLoadReset((GraphObjectPagingLoader<T>) loader);
-                        }
-                    });
-
-            loader.setOnErrorListener(new GraphObjectPagingLoader.OnErrorListener() {
-                @Override
-                public void onError(FacebookException error, GraphObjectPagingLoader<?> loader) {
-                    hideActivityCircle();
-                    if (onErrorListener != null) {
-                        onErrorListener.onError(PickerFragment.this, error);
-                    }
-                }
-            });
-
-            this.adapter = adapter;
-            // Tell the adapter about any data we might already have.
-            this.adapter.changeCursor(loader.getCursor());
-            this.adapter.setOnErrorListener(new GraphObjectAdapter.OnErrorListener() {
-                @Override
-                public void onError(GraphObjectAdapter<?> adapter, FacebookException error) {
-                    if (onErrorListener != null) {
-                        onErrorListener.onError(PickerFragment.this, error);
-                    }
-                }
-            });
-        }
-
-        public void detach() {
-            adapter.setDataNeededListener(null);
-            adapter.setOnErrorListener(null);
-            loader.setOnErrorListener(null);
-
-            loader = null;
-            adapter = null;
-        }
-
-        public void clearResults() {
-            if (loader != null) {
-                loader.clearResults();
-            }
-        }
-
-        public void startLoading(Request request) {
-            if (loader != null) {
-                loader.startLoading(request, true);
-                onStartLoading(loader, request);
-            }
-        }
-
-        public boolean isDataPresentOrLoading() {
-            return !adapter.isEmpty() || loader.isLoading();
-        }
-
-        protected GraphObjectPagingLoader<T> onCreateLoader() {
-            return new GraphObjectPagingLoader<T>(getActivity(), graphObjectClass);
-        }
-
-        protected void onStartLoading(GraphObjectPagingLoader<T> loader, Request request) {
-            displayActivityCircle();
-        }
-
-        protected void onLoadReset(GraphObjectPagingLoader<T> loader) {
-            adapter.changeCursor(null);
-        }
-
-        protected void onLoadFinished(GraphObjectPagingLoader<T> loader, SimpleGraphObjectCursor<T> data) {
-            updateAdapter(data);
-        }
-    }
-
-    abstract class SelectionStrategy {
-        abstract boolean isSelected(String id);
-
-        abstract void toggleSelection(String id);
-
-        abstract Collection<String> getSelectedIds();
-
-        abstract void clear();
-
-        abstract boolean isEmpty();
-
-        abstract boolean shouldShowCheckBoxIfUnselected();
-
-        abstract void saveSelectionToBundle(Bundle outBundle, String key);
-
-        abstract void readSelectionFromBundle(Bundle inBundle, String key);
-    }
-
-    class SingleSelectionStrategy extends SelectionStrategy {
-        private String selectedId;
-
-        public Collection<String> getSelectedIds() {
-            return Arrays.asList(new String[]{selectedId});
-        }
-
-        @Override
-        boolean isSelected(String id) {
-            return selectedId != null && id != null && selectedId.equals(id);
-        }
-
-        @Override
-        void toggleSelection(String id) {
-            if (selectedId != null && selectedId.equals(id)) {
-                selectedId = null;
-            } else {
-                selectedId = id;
-            }
-        }
-
-        @Override
-        void saveSelectionToBundle(Bundle outBundle, String key) {
-            if (!TextUtils.isEmpty(selectedId)) {
-                outBundle.putString(key, selectedId);
-            }
-        }
-
-        @Override
-        void readSelectionFromBundle(Bundle inBundle, String key) {
-            if (inBundle != null) {
-                selectedId = inBundle.getString(key);
-            }
-        }
-
-        @Override
-        public void clear() {
-            selectedId = null;
-        }
-
-        @Override
-        boolean isEmpty() {
-            return selectedId == null;
-        }
-
-        @Override
-        boolean shouldShowCheckBoxIfUnselected() {
-            return false;
-        }
-    }
-
-    class MultiSelectionStrategy extends SelectionStrategy {
-        private Set<String> selectedIds = new HashSet<String>();
-
-        public Collection<String> getSelectedIds() {
-            return selectedIds;
-        }
-
-        @Override
-        boolean isSelected(String id) {
-            return id != null && selectedIds.contains(id);
-        }
-
-        @Override
-        void toggleSelection(String id) {
-            if (id != null) {
-                if (selectedIds.contains(id)) {
-                    selectedIds.remove(id);
-                } else {
-                    selectedIds.add(id);
-                }
-            }
-        }
-
-        @Override
-        void saveSelectionToBundle(Bundle outBundle, String key) {
-            if (!selectedIds.isEmpty()) {
-                String ids = TextUtils.join(",", selectedIds);
-                outBundle.putString(key, ids);
-            }
-        }
-
-        @Override
-        void readSelectionFromBundle(Bundle inBundle, String key) {
-            if (inBundle != null) {
-                String ids = inBundle.getString(key);
-                if (ids != null) {
-                    String[] splitIds = TextUtils.split(ids, ",");
-                    selectedIds.clear();
-                    Collections.addAll(selectedIds, splitIds);
-                }
-            }
-        }
-
-        @Override
-        public void clear() {
-            selectedIds.clear();
-        }
-
-        @Override
-        boolean isEmpty() {
-            return selectedIds.isEmpty();
-        }
-
-        @Override
-        boolean shouldShowCheckBoxIfUnselected() {
-            return true;
-        }
-    }
-
-    abstract class PickerFragmentAdapter<U extends GraphObject> extends GraphObjectAdapter<T> {
-        public PickerFragmentAdapter(Context context) {
-            super(context);
-        }
-
-        @Override
-        boolean isGraphObjectSelected(String graphObjectId) {
-            return selectionStrategy.isSelected(graphObjectId);
-        }
-
-        @Override
-        void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
-            checkBox.setChecked(graphObjectSelected);
-            int visible = (graphObjectSelected || selectionStrategy
-                    .shouldShowCheckBoxIfUnselected()) ? View.VISIBLE : View.GONE;
-            checkBox.setVisibility(visible);
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/widget/PlacePickerFragment.java b/facebook/src/com/facebook/widget/PlacePickerFragment.java
deleted file mode 100644
index 58b277583..000000000
--- a/facebook/src/com/facebook/widget/PlacePickerFragment.java
+++ /dev/null
@@ -1,528 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.location.Location;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
-import android.text.Editable;
-import android.text.TextUtils;
-import android.text.TextWatcher;
-import android.util.AttributeSet;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.inputmethod.InputMethodManager;
-import android.widget.EditText;
-import android.widget.ListView;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.internal.AnalyticsEvents;
-import com.facebook.model.GraphPlace;
-import com.facebook.internal.Logger;
-import com.facebook.internal.Utility;
-
-import java.util.*;
-
-public class PlacePickerFragment extends PickerFragment<GraphPlace> {
-    /**
-     * The key for an int parameter in the fragment's Intent bundle to indicate the radius in meters around
-     * the center point to search. The default is 1000 meters.
-     */
-    public static final String RADIUS_IN_METERS_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.RadiusInMeters";
-    /**
-     * The key for an int parameter in the fragment's Intent bundle to indicate what how many results to
-     * return at a time. The default is 100 results.
-     */
-    public static final String RESULTS_LIMIT_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.ResultsLimit";
-    /**
-     * The key for a String parameter in the fragment's Intent bundle to indicate what search text should
-     * be sent to the service. The default is to have no search text.
-     */
-    public static final String SEARCH_TEXT_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.SearchText";
-    /**
-     * The key for a Location parameter in the fragment's Intent bundle to indicate what geographical
-     * location should be the center of the search.
-     */
-    public static final String LOCATION_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.Location";
-    /**
-     * The key for a boolean parameter in the fragment's Intent bundle to indicate that the fragment
-     * should display a search box and automatically update the search text as it changes.
-     */
-    public static final String SHOW_SEARCH_BOX_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.ShowSearchBox";
-
-    /**
-     * The default radius around the center point to search.
-     */
-    public static final int DEFAULT_RADIUS_IN_METERS = 1000;
-    /**
-     * The default number of results to retrieve.
-     */
-    public static final int DEFAULT_RESULTS_LIMIT = 100;
-
-    private static final int searchTextTimerDelayInMilliseconds = 2 * 1000;
-
-    private static final String ID = "id";
-    private static final String NAME = "name";
-    private static final String LOCATION = "location";
-    private static final String CATEGORY = "category";
-    private static final String WERE_HERE_COUNT = "were_here_count";
-    private static final String TAG = "PlacePickerFragment";
-
-    private Location location;
-    private int radiusInMeters = DEFAULT_RADIUS_IN_METERS;
-    private int resultsLimit = DEFAULT_RESULTS_LIMIT;
-    private String searchText;
-    private Timer searchTextTimer;
-    private boolean hasSearchTextChangedSinceLastQuery;
-    private boolean showSearchBox = true;
-    private EditText searchBox;
-
-    /**
-     * Default constructor. Creates a Fragment with all default properties.
-     */
-    public PlacePickerFragment() {
-        this(null);
-    }
-
-    /**
-     * Constructor.
-     *
-     * @param args a Bundle that optionally contains one or more values containing additional
-     *             configuration information for the Fragment.
-     */
-    public PlacePickerFragment(Bundle args) {
-        super(GraphPlace.class, R.layout.com_facebook_placepickerfragment, args);
-        setPlacePickerSettingsFromBundle(args);
-    }
-
-    /**
-     * Gets the location to search around. Either the location or the search text (or both) must be specified.
-     *
-     * @return the Location to search around
-     */
-    public Location getLocation() {
-        return location;
-    }
-
-    /**
-     * Sets the location to search around. Either the location or the search text (or both) must be specified.
-     *
-     * @param location the Location to search around
-     */
-    public void setLocation(Location location) {
-        this.location = location;
-    }
-
-    /**
-     * Gets the radius in meters around the location to search.
-     *
-     * @return the radius in meters
-     */
-    public int getRadiusInMeters() {
-        return radiusInMeters;
-    }
-
-    /**
-     * Sets the radius in meters around the location to search.
-     *
-     * @param radiusInMeters the radius in meters
-     */
-    public void setRadiusInMeters(int radiusInMeters) {
-        this.radiusInMeters = radiusInMeters;
-    }
-
-    /**
-     * Gets the number of results to retrieve.
-     *
-     * @return the number of results to retrieve
-     */
-    public int getResultsLimit() {
-        return resultsLimit;
-    }
-
-    /**
-     * Sets the number of results to retrieve.
-     *
-     * @param resultsLimit the number of results to retrieve
-     */
-    public void setResultsLimit(int resultsLimit) {
-        this.resultsLimit = resultsLimit;
-    }
-
-    /**
-     * Gets the search text (e.g., category, name) to search for. Either the location or the search
-     * text (or both) must be specified.
-     *
-     * @return the search text
-     */
-    public String getSearchText() {
-        return searchText;
-    }
-
-    /**
-     * Sets the search text (e.g., category, name) to search for. Either the location or the search
-     * text (or both) must be specified. If a search box is displayed, this will update its contents
-     * to the specified text.
-     *
-     * @param searchText the search text
-     */
-    public void setSearchText(String searchText) {
-        if (TextUtils.isEmpty(searchText)) {
-            searchText = null;
-        }
-        this.searchText = searchText;
-        if (this.searchBox != null) {
-            this.searchBox.setText(searchText);
-        }
-    }
-
-    /**
-     * Sets the search text and reloads the data in the control. This is used to provide search-box
-     * functionality where the user may be typing or editing text rapidly. It uses a timer to avoid repeated
-     * requerying, preferring to wait until the user pauses typing to refresh the data. Note that this
-     * method will NOT update the text in the search box, if any, as it is intended to be called as a result
-     * of changes to the search box (and is public to enable applications to provide their own search box
-     * UI instead of the default one).
-     *
-     * @param searchText                 the search text
-     * @param forceReloadEventIfSameText if true, will reload even if the search text has not changed; if false,
-     *                                   identical search text will not force a reload
-     */
-    public void onSearchBoxTextChanged(String searchText, boolean forceReloadEventIfSameText) {
-        if (!forceReloadEventIfSameText && Utility.stringsEqualOrEmpty(this.searchText, searchText)) {
-            return;
-        }
-
-        if (TextUtils.isEmpty(searchText)) {
-            searchText = null;
-        }
-        this.searchText = searchText;
-
-        // If search text is being set in response to user input, it is wasteful to send a new request
-        // with every keystroke. Send a request the first time the search text is set, then set up a 2-second timer
-        // and send whatever changes the user has made since then. (If nothing has changed
-        // in 2 seconds, we reset so the next change will cause an immediate re-query.)
-        hasSearchTextChangedSinceLastQuery = true;
-        if (searchTextTimer == null) {
-            searchTextTimer = createSearchTextTimer();
-        }
-    }
-
-    /**
-     * Gets the currently-selected place.
-     *
-     * @return the currently-selected place, or null if there is none
-     */
-    public GraphPlace getSelection() {
-        Collection<GraphPlace> selection = getSelectedGraphObjects();
-        return (selection != null && !selection.isEmpty()) ? selection.iterator().next() : null;
-    }
-
-    public void setSettingsFromBundle(Bundle inState) {
-        super.setSettingsFromBundle(inState);
-        setPlacePickerSettingsFromBundle(inState);
-    }
-
-    @Override
-    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
-        super.onInflate(activity, attrs, savedInstanceState);
-        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.com_facebook_place_picker_fragment);
-
-        setRadiusInMeters(a.getInt(R.styleable.com_facebook_place_picker_fragment_radius_in_meters, radiusInMeters));
-        setResultsLimit(a.getInt(R.styleable.com_facebook_place_picker_fragment_results_limit, resultsLimit));
-        if (a.hasValue(R.styleable.com_facebook_place_picker_fragment_results_limit)) {
-            setSearchText(a.getString(R.styleable.com_facebook_place_picker_fragment_search_text));
-        }
-        showSearchBox = a.getBoolean(R.styleable.com_facebook_place_picker_fragment_show_search_box, showSearchBox);
-
-        a.recycle();
-    }
-
-    @Override
-    void setupViews(ViewGroup view) {
-        if (showSearchBox) {
-            ListView listView = (ListView) view.findViewById(R.id.com_facebook_picker_list_view);
-
-            View searchHeaderView = getActivity().getLayoutInflater().inflate(
-                    R.layout.com_facebook_picker_search_box, listView, false);
-
-            listView.addHeaderView(searchHeaderView, null, false);
-
-            searchBox = (EditText) view.findViewById(R.id.com_facebook_picker_search_text);
-
-            searchBox.addTextChangedListener(new SearchTextWatcher());
-            if (!TextUtils.isEmpty(searchText)) {
-                searchBox.setText(searchText);
-            }
-        }
-    }
-
-    @Override
-    public void onAttach(Activity activity) {
-        super.onAttach(activity);
-
-        if (searchBox != null) {
-            InputMethodManager imm = (InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);
-            imm.showSoftInput(searchBox, InputMethodManager.SHOW_IMPLICIT);
-        }
-    }
-
-    @Override
-    public void onDetach() {
-        super.onDetach();
-
-        if (searchBox != null) {
-            InputMethodManager imm = (InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);
-            imm.hideSoftInputFromWindow(searchBox.getWindowToken(), 0);
-        }
-    }
-
-    void saveSettingsToBundle(Bundle outState) {
-        super.saveSettingsToBundle(outState);
-
-        outState.putInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters);
-        outState.putInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit);
-        outState.putString(SEARCH_TEXT_BUNDLE_KEY, searchText);
-        outState.putParcelable(LOCATION_BUNDLE_KEY, location);
-        outState.putBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
-    }
-
-    @Override
-    void onLoadingData() {
-        hasSearchTextChangedSinceLastQuery = false;
-    }
-
-    @Override
-    Request getRequestForLoadData(Session session) {
-        return createRequest(location, radiusInMeters, resultsLimit, searchText, extraFields, session);
-    }
-
-    @Override
-    String getDefaultTitleText() {
-        return getString(R.string.com_facebook_nearby);
-    }
-
-    @Override
-    void logAppEvents(boolean doneButtonClicked) {
-        AppEventsLogger logger = AppEventsLogger.newLogger(this.getActivity(), getSession());
-        Bundle parameters = new Bundle();
-
-        // If Done was clicked, we know this completed successfully. If not, we don't know (caller might have
-        // dismissed us in response to selection changing, or user might have hit back button). Either way
-        // we'll log the number of selections.
-        String outcome = doneButtonClicked ? AnalyticsEvents.PARAMETER_DIALOG_OUTCOME_VALUE_COMPLETED :
-                AnalyticsEvents.PARAMETER_DIALOG_OUTCOME_VALUE_UNKNOWN;
-        parameters.putString(AnalyticsEvents.PARAMETER_DIALOG_OUTCOME, outcome);
-        parameters.putInt("num_places_picked", (getSelection() != null) ? 1 : 0);
-
-        logger.logSdkEvent(AnalyticsEvents.EVENT_PLACE_PICKER_USAGE, null, parameters);
-    }
-
-    @Override
-    PickerFragmentAdapter<GraphPlace> createAdapter() {
-        PickerFragmentAdapter<GraphPlace> adapter = new PickerFragmentAdapter<GraphPlace>(
-                this.getActivity()) {
-            @Override
-            protected CharSequence getSubTitleOfGraphObject(GraphPlace graphObject) {
-                String category = graphObject.getCategory();
-                Integer wereHereCount = (Integer) graphObject.getProperty(WERE_HERE_COUNT);
-
-                String result = null;
-                if (category != null && wereHereCount != null) {
-                    result = getString(R.string.com_facebook_placepicker_subtitle_format, category, wereHereCount);
-                } else if (category == null && wereHereCount != null) {
-                    result = getString(R.string.com_facebook_placepicker_subtitle_were_here_only_format, wereHereCount);
-                } else if (category != null && wereHereCount == null) {
-                    result = getString(R.string.com_facebook_placepicker_subtitle_catetory_only_format, category);
-                }
-                return result;
-            }
-
-            @Override
-            protected int getGraphObjectRowLayoutId(GraphPlace graphObject) {
-                return R.layout.com_facebook_placepickerfragment_list_row;
-            }
-
-            @Override
-            protected int getDefaultPicture() {
-                return R.drawable.com_facebook_place_default_icon;
-            }
-
-        };
-        adapter.setShowCheckbox(false);
-        adapter.setShowPicture(getShowPictures());
-        return adapter;
-    }
-
-    @Override
-    LoadingStrategy createLoadingStrategy() {
-        return new AsNeededLoadingStrategy();
-    }
-
-    @Override
-    SelectionStrategy createSelectionStrategy() {
-        return new SingleSelectionStrategy();
-    }
-
-    private Request createRequest(Location location, int radiusInMeters, int resultsLimit, String searchText,
-            Set<String> extraFields,
-            Session session) {
-        Request request = Request.newPlacesSearchRequest(session, location, radiusInMeters, resultsLimit, searchText,
-                null);
-
-        Set<String> fields = new HashSet<String>(extraFields);
-        String[] requiredFields = new String[]{
-                ID,
-                NAME,
-                LOCATION,
-                CATEGORY,
-                WERE_HERE_COUNT
-        };
-        fields.addAll(Arrays.asList(requiredFields));
-
-        String pictureField = adapter.getPictureFieldSpecifier();
-        if (pictureField != null) {
-            fields.add(pictureField);
-        }
-
-        Bundle parameters = request.getParameters();
-        parameters.putString("fields", TextUtils.join(",", fields));
-        request.setParameters(parameters);
-
-        return request;
-    }
-
-    private void setPlacePickerSettingsFromBundle(Bundle inState) {
-        // We do this in a separate non-overridable method so it is safe to call from the constructor.
-        if (inState != null) {
-            setRadiusInMeters(inState.getInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters));
-            setResultsLimit(inState.getInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit));
-            if (inState.containsKey(SEARCH_TEXT_BUNDLE_KEY)) {
-                setSearchText(inState.getString(SEARCH_TEXT_BUNDLE_KEY));
-            }
-            if (inState.containsKey(LOCATION_BUNDLE_KEY)) {
-                Location location = inState.getParcelable(LOCATION_BUNDLE_KEY);
-                setLocation(location);
-            }
-            showSearchBox = inState.getBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
-        }
-    }
-
-    private Timer createSearchTextTimer() {
-        Timer timer = new Timer();
-        timer.schedule(new TimerTask() {
-            @Override
-            public void run() {
-                onSearchTextTimerTriggered();
-            }
-        }, 0, searchTextTimerDelayInMilliseconds);
-
-        return timer;
-    }
-
-    private void onSearchTextTimerTriggered() {
-        if (hasSearchTextChangedSinceLastQuery) {
-            Handler handler = new Handler(Looper.getMainLooper());
-            handler.post(new Runnable() {
-                @Override
-                public void run() {
-                    FacebookException error = null;
-                    try {
-                        loadData(true);
-                    } catch (FacebookException fe) {
-                        error = fe;
-                    } catch (Exception e) {
-                        error = new FacebookException(e);
-                    } finally {
-                        if (error != null) {
-                            OnErrorListener onErrorListener = getOnErrorListener();
-                            if (onErrorListener != null) {
-                                onErrorListener.onError(PlacePickerFragment.this, error);
-                            } else {
-                                Logger.log(LoggingBehavior.REQUESTS, TAG, "Error loading data : %s", error);
-                            }
-                        }
-                    }
-                }
-            });
-        } else {
-            // Nothing has changed in 2 seconds. Invalidate and forget about this timer.
-            // Next time the user types, we will fire a query immediately again.
-            searchTextTimer.cancel();
-            searchTextTimer = null;
-        }
-    }
-
-    private class AsNeededLoadingStrategy extends LoadingStrategy {
-        @Override
-        public void attach(GraphObjectAdapter<GraphPlace> adapter) {
-            super.attach(adapter);
-
-            this.adapter.setDataNeededListener(new GraphObjectAdapter.DataNeededListener() {
-                @Override
-                public void onDataNeeded() {
-                    // Do nothing if we are currently loading data . We will get notified again when that load finishes if the adapter still
-                    // needs more data. Otherwise, follow the next link.
-                    if (!loader.isLoading()) {
-                        loader.followNextLink();
-                    }
-                }
-            });
-        }
-
-        @Override
-        protected void onLoadFinished(GraphObjectPagingLoader<GraphPlace> loader,
-                SimpleGraphObjectCursor<GraphPlace> data) {
-            super.onLoadFinished(loader, data);
-
-            // We could be called in this state if we are clearing data or if we are being re-attached
-            // in the middle of a query.
-            if (data == null || loader.isLoading()) {
-                return;
-            }
-
-            hideActivityCircle();
-
-            if (data.isFromCache()) {
-                // Only the first page can be cached, since all subsequent pages will be round-tripped. Force
-                // a refresh of the first page before we allow paging to begin. If the first page produced
-                // no data, launch the refresh immediately, otherwise schedule it for later.
-                loader.refreshOriginalRequest(data.areMoreObjectsAvailable() ? CACHED_RESULT_REFRESH_DELAY : 0);
-            }
-        }
-    }
-
-    private class SearchTextWatcher implements TextWatcher {
-
-        @Override
-        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
-        }
-
-        @Override
-        public void onTextChanged(CharSequence s, int start, int before, int count) {
-            onSearchBoxTextChanged(s.toString(), false);
-        }
-
-        @Override
-        public void afterTextChanged(Editable s) {
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/widget/ProfilePictureView.java b/facebook/src/com/facebook/widget/ProfilePictureView.java
deleted file mode 100644
index fdc87288b..000000000
--- a/facebook/src/com/facebook/widget/ProfilePictureView.java
+++ /dev/null
@@ -1,538 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.os.Bundle;
-import android.os.Parcelable;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.ViewGroup;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-import com.facebook.FacebookException;
-import com.facebook.LoggingBehavior;
-import com.facebook.android.R;
-import com.facebook.internal.*;
-
-import java.net.URISyntaxException;
-
-/**
- * View that displays the profile photo of a supplied profile ID, while conforming
- * to user specified dimensions.
- */
-public class ProfilePictureView extends FrameLayout {
-
-    /**
-     * Callback interface that will be called when a network or other error is encountered
-     * while retrieving profile pictures.
-     */
-    public interface OnErrorListener {
-        /**
-         * Called when a network or other error is encountered.
-         * @param error     a FacebookException representing the error that was encountered.
-         */
-        void onError(FacebookException error);
-    }
-
-    /**
-     * Tag used when logging calls are made by ProfilePictureView
-     */
-    public static final String TAG = ProfilePictureView.class.getSimpleName();
-
-    /**
-     * Indicates that the specific size of the View will be set via layout params.
-     * ProfilePictureView will default to NORMAL X NORMAL, if the layout params set on
-     * this instance do not have a fixed size.
-     * Used in calls to setPresetSize() and getPresetSize().
-     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
-     */
-    public static final int CUSTOM = -1;
-
-    /**
-     * Indicates that the profile image should fit in a SMALL X SMALL space, regardless
-     * of whether the cropped or un-cropped version is chosen.
-     * Used in calls to setPresetSize() and getPresetSize().
-     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
-     */
-    public static final int SMALL = -2;
-
-    /**
-     * Indicates that the profile image should fit in a NORMAL X NORMAL space, regardless
-     * of whether the cropped or un-cropped version is chosen.
-     * Used in calls to setPresetSize() and getPresetSize().
-     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
-     */
-    public static final int NORMAL = -3;
-
-    /**
-     * Indicates that the profile image should fit in a LARGE X LARGE space, regardless
-     * of whether the cropped or un-cropped version is chosen.
-     * Used in calls to setPresetSize() and getPresetSize().
-     * Corresponds with the preset_size Xml attribute that can be set on ProfilePictureView.
-     */
-    public static final int LARGE = -4;
-
-    private static final int MIN_SIZE = 1;
-    private static final boolean IS_CROPPED_DEFAULT_VALUE = true;
-    private static final String SUPER_STATE_KEY = "ProfilePictureView_superState";
-    private static final String PROFILE_ID_KEY = "ProfilePictureView_profileId";
-    private static final String PRESET_SIZE_KEY = "ProfilePictureView_presetSize";
-    private static final String IS_CROPPED_KEY = "ProfilePictureView_isCropped";
-    private static final String BITMAP_KEY = "ProfilePictureView_bitmap";
-    private static final String BITMAP_WIDTH_KEY = "ProfilePictureView_width";
-    private static final String BITMAP_HEIGHT_KEY = "ProfilePictureView_height";
-    private static final String PENDING_REFRESH_KEY = "ProfilePictureView_refresh";
-
-    private String profileId;
-    private int queryHeight = ImageRequest.UNSPECIFIED_DIMENSION;
-    private int queryWidth = ImageRequest.UNSPECIFIED_DIMENSION;
-    private boolean isCropped = IS_CROPPED_DEFAULT_VALUE;
-    private Bitmap imageContents;
-    private ImageView image;
-    private int presetSizeType = CUSTOM;
-    private ImageRequest lastRequest;
-    private OnErrorListener onErrorListener;
-    private Bitmap customizedDefaultProfilePicture = null;
-
-    /**
-     * Constructor
-     *
-     * @param context Context for this View
-     */
-    public ProfilePictureView(Context context) {
-        super(context);
-        initialize(context);
-    }
-
-    /**
-     * Constructor
-     *
-     * @param context Context for this View
-     * @param attrs   AttributeSet for this View.
-     *                The attribute 'preset_size' is processed here
-     */
-    public ProfilePictureView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        initialize(context);
-        parseAttributes(attrs);
-    }
-
-    /**
-     * Constructor
-     *
-     * @param context  Context for this View
-     * @param attrs    AttributeSet for this View.
-     *                 The attribute 'preset_size' is processed here
-     * @param defStyle Default style for this View
-     */
-    public ProfilePictureView(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        initialize(context);
-        parseAttributes(attrs);
-    }
-
-    /**
-     * Gets the current preset size type
-     *
-     * @return The current preset size type, if set; CUSTOM if not
-     */
-    public final int getPresetSize() {
-        return presetSizeType;
-    }
-
-    /**
-     * Apply a preset size to this profile photo
-     *
-     * @param sizeType The size type to apply: SMALL, NORMAL or LARGE
-     */
-    public final void setPresetSize(int sizeType) {
-        switch (sizeType) {
-            case SMALL:
-            case NORMAL:
-            case LARGE:
-            case CUSTOM:
-                this.presetSizeType = sizeType;
-                break;
-
-            default:
-                throw new IllegalArgumentException("Must use a predefined preset size");
-        }
-
-        requestLayout();
-    }
-
-    /**
-     * Indicates whether the cropped version of the profile photo has been chosen
-     *
-     * @return True if the cropped version is chosen, false if not.
-     */
-    public final boolean isCropped() {
-        return isCropped;
-    }
-
-    /**
-     * Sets the profile photo to be the cropped version, or the original version
-     *
-     * @param showCroppedVersion True to select the cropped version
-     *                           False to select the standard version
-     */
-    public final void setCropped(boolean showCroppedVersion) {
-        isCropped = showCroppedVersion;
-        // No need to force the refresh since we will catch the change in required dimensions
-        refreshImage(false);
-    }
-
-    /**
-     * Returns the profile Id for the current profile photo
-     *
-     * @return The profile Id
-     */
-    public final String getProfileId() {
-        return profileId;
-    }
-
-    /**
-     * Sets the profile Id for this profile photo
-     *
-     * @param profileId The profileId
-     *               NULL/Empty String will show the blank profile photo
-     */
-    public final void setProfileId(String profileId) {
-        boolean force = false;
-        if (Utility.isNullOrEmpty(this.profileId) || !this.profileId.equalsIgnoreCase(profileId)) {
-            // Clear out the old profilePicture before requesting for the new one.
-            setBlankProfilePicture();
-            force = true;
-        }
-
-        this.profileId = profileId;
-        refreshImage(force);
-    }
-
-    /**
-     * Returns the current OnErrorListener for this instance of ProfilePictureView
-     *
-     * @return The OnErrorListener
-     */
-    public final OnErrorListener getOnErrorListener() {
-        return onErrorListener;
-    }
-
-    /**
-     * Sets an OnErrorListener for this instance of ProfilePictureView to call into when
-     * certain exceptions occur.
-     *
-     * @param onErrorListener The Listener object to set
-     */
-    public final void setOnErrorListener(OnErrorListener onErrorListener) {
-      this.onErrorListener = onErrorListener;
-    }
-
-    /**
-     * The ProfilePictureView will display the provided image while the specified
-     * profile is being loaded, or if the specified profile is not available.
-     *
-     * @param inputBitmap The bitmap to render until the actual profile is loaded.
-     */
-    public final void setDefaultProfilePicture(Bitmap inputBitmap) {
-        customizedDefaultProfilePicture = inputBitmap;
-    }
-
-    /**
-     * Overriding onMeasure to handle the case where WRAP_CONTENT might be
-     * specified in the layout. Since we don't know the dimensions of the profile
-     * photo, we need to handle this case specifically.
-     * <p/>
-     * The approach is to default to a NORMAL sized amount of space in the case that
-     * a preset size is not specified. This logic is applied to both width and height
-     */
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        ViewGroup.LayoutParams params = getLayoutParams();
-        boolean customMeasure = false;
-        int newHeight = MeasureSpec.getSize(heightMeasureSpec);
-        int newWidth = MeasureSpec.getSize(widthMeasureSpec);
-        if (MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY &&
-                params.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
-            newHeight = getPresetSizeInPixels(true); // Default to a preset size
-            heightMeasureSpec = MeasureSpec.makeMeasureSpec(newHeight, MeasureSpec.EXACTLY);
-            customMeasure = true;
-        }
-
-        if (MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY &&
-                params.width == ViewGroup.LayoutParams.WRAP_CONTENT) {
-            newWidth = getPresetSizeInPixels(true); // Default to a preset size
-            widthMeasureSpec = MeasureSpec.makeMeasureSpec(newWidth, MeasureSpec.EXACTLY);
-            customMeasure = true;
-        }
-
-        if (customMeasure) {
-            // Since we are providing custom dimensions, we need to handle the measure
-            // phase from here
-            setMeasuredDimension(newWidth, newHeight);
-            measureChildren(widthMeasureSpec, heightMeasureSpec);
-        } else {
-            // Rely on FrameLayout to do the right thing
-            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
-        }
-    }
-
-    /**
-     * In addition to calling super.Layout(), we also attempt to get a new image that
-     * is properly size for the layout dimensions
-     */
-    @Override
-    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-        super.onLayout(changed, left, top, right, bottom);
-
-        // See if the image needs redrawing
-        refreshImage(false);
-    }
-
-    /**
-     * Some of the current state is returned as a Bundle to allow quick restoration
-     * of the ProfilePictureView object in scenarios like orientation changes.
-     * @return a Parcelable containing the current state
-     */
-    @Override
-    protected Parcelable onSaveInstanceState() {
-        Parcelable superState = super.onSaveInstanceState();
-        Bundle instanceState = new Bundle();
-        instanceState.putParcelable(SUPER_STATE_KEY, superState);
-        instanceState.putString(PROFILE_ID_KEY, profileId);
-        instanceState.putInt(PRESET_SIZE_KEY, presetSizeType);
-        instanceState.putBoolean(IS_CROPPED_KEY, isCropped);
-        instanceState.putParcelable(BITMAP_KEY, imageContents);
-        instanceState.putInt(BITMAP_WIDTH_KEY, queryWidth);
-        instanceState.putInt(BITMAP_HEIGHT_KEY, queryHeight);
-        instanceState.putBoolean(PENDING_REFRESH_KEY, lastRequest != null);
-
-        return instanceState;
-    }
-
-    /**
-     * If the passed in state is a Bundle, an attempt is made to restore from it.
-     * @param state a Parcelable containing the current state
-     */
-    @Override
-    protected void onRestoreInstanceState(Parcelable state) {
-        if (state.getClass() != Bundle.class) {
-            super.onRestoreInstanceState(state);
-        } else {
-            Bundle instanceState = (Bundle)state;
-            super.onRestoreInstanceState(instanceState.getParcelable(SUPER_STATE_KEY));
-
-            profileId = instanceState.getString(PROFILE_ID_KEY);
-            presetSizeType = instanceState.getInt(PRESET_SIZE_KEY);
-            isCropped = instanceState.getBoolean(IS_CROPPED_KEY);
-            queryWidth = instanceState.getInt(BITMAP_WIDTH_KEY);
-            queryHeight = instanceState.getInt(BITMAP_HEIGHT_KEY);
-
-            setImageBitmap((Bitmap)instanceState.getParcelable(BITMAP_KEY));
-
-            if (instanceState.getBoolean(PENDING_REFRESH_KEY)) {
-                refreshImage(true);
-            }
-        }
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        super.onDetachedFromWindow();
-
-        // Null out lastRequest. This way, when the response is returned, we can ascertain
-        // that the view is detached and hence should not attempt to update its contents.
-        lastRequest = null;
-    }
-
-    private void initialize(Context context) {
-        // We only want our ImageView in here. Nothing else is permitted
-        removeAllViews();
-
-        image = new ImageView(context);
-
-        LayoutParams imageLayout = new LayoutParams(
-                LayoutParams.MATCH_PARENT,
-                LayoutParams.MATCH_PARENT);
-
-        image.setLayoutParams(imageLayout);
-
-        // We want to prevent up-scaling the image, but still have it fit within
-        // the layout bounds as best as possible.
-        image.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
-        addView(image);
-    }
-
-    private void parseAttributes(AttributeSet attrs) {
-        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.com_facebook_profile_picture_view);
-        setPresetSize(a.getInt(R.styleable.com_facebook_profile_picture_view_preset_size, CUSTOM));
-        isCropped = a.getBoolean(R.styleable.com_facebook_profile_picture_view_is_cropped, IS_CROPPED_DEFAULT_VALUE);
-        a.recycle();
-    }
-
-    private void refreshImage(boolean force) {
-        boolean changed = updateImageQueryParameters();
-        // Note: do not use Utility.isNullOrEmpty here as this will cause the Eclipse
-        // Graphical Layout editor to fail in some cases
-        if (profileId == null || profileId.length() == 0 ||
-                ((queryWidth == ImageRequest.UNSPECIFIED_DIMENSION) &&
-                        (queryHeight == ImageRequest.UNSPECIFIED_DIMENSION))) {
-            setBlankProfilePicture();
-        } else if (changed || force) {
-            sendImageRequest(true);
-        }
-    }
-
-    private void setBlankProfilePicture() {
-        if (customizedDefaultProfilePicture == null) {
-          int blankImageResource = isCropped() ?
-                  R.drawable.com_facebook_profile_picture_blank_square :
-                  R.drawable.com_facebook_profile_picture_blank_portrait;
-          setImageBitmap( BitmapFactory.decodeResource(getResources(), blankImageResource));
-	} else {
-          // Update profile image dimensions.
-          updateImageQueryParameters();
-          // Resize inputBitmap to new dimensions of queryWidth and queryHeight.
-          Bitmap scaledBitmap = Bitmap.createScaledBitmap(customizedDefaultProfilePicture, queryWidth, queryHeight, false);
-          setImageBitmap(scaledBitmap);
-	}
-    }
-
-    private void setImageBitmap(Bitmap imageBitmap) {
-        if (image != null && imageBitmap != null) {
-            imageContents = imageBitmap; // Hold for save-restore cycles
-            image.setImageBitmap(imageBitmap);
-        }
-    }
-
-    private void sendImageRequest(boolean allowCachedResponse) {
-        try {
-            ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
-                    getContext(),
-                    ImageRequest.getProfilePictureUrl(profileId, queryWidth,  queryHeight));
-
-            ImageRequest request = requestBuilder.setAllowCachedRedirects(allowCachedResponse)
-                    .setCallerTag(this)
-                    .setCallback(
-                    new ImageRequest.Callback() {
-                        @Override
-                        public void onCompleted(ImageResponse response) {
-                            processResponse(response);
-                        }
-                    })
-                    .build();
-
-            // Make sure to cancel the old request before sending the new one to prevent
-            // accidental cancellation of the new request. This could happen if the URL and
-            // caller tag stayed the same.
-            if (lastRequest != null) {
-                ImageDownloader.cancelRequest(lastRequest);
-            }
-            lastRequest = request;
-
-            ImageDownloader.downloadAsync(request);
-        } catch (URISyntaxException e) {
-            Logger.log(LoggingBehavior.REQUESTS, Log.ERROR, TAG, e.toString());
-        }
-    }
-
-    private void processResponse(ImageResponse response) {
-        // First check if the response is for the right request. We may have:
-        // 1. Sent a new request, thus super-ceding this one.
-        // 2. Detached this view, in which case the response should be discarded.
-        if (response.getRequest() == lastRequest) {
-            lastRequest = null;
-            Bitmap responseImage = response.getBitmap();
-            Exception error = response.getError();
-            if (error != null) {
-                OnErrorListener listener = onErrorListener;
-                if (listener != null) {
-                    listener.onError(new FacebookException(
-                            "Error in downloading profile picture for profileId: " + getProfileId(), error));
-                } else {
-                    Logger.log(LoggingBehavior.REQUESTS, Log.ERROR, TAG, error.toString());
-                }
-            } else if (responseImage != null) {
-                setImageBitmap(responseImage);
-
-                if (response.isCachedRedirect()) {
-                    sendImageRequest(false);
-                }
-            }
-        }
-    }
-
-    private boolean updateImageQueryParameters() {
-        int newHeightPx = getHeight();
-        int newWidthPx = getWidth();
-        if (newWidthPx < MIN_SIZE || newHeightPx < MIN_SIZE) {
-            // Not enough space laid out for this View yet. Or something else is awry.
-            return false;
-        }
-
-        int presetSize = getPresetSizeInPixels(false);
-        if (presetSize != ImageRequest.UNSPECIFIED_DIMENSION) {
-            newWidthPx = presetSize;
-            newHeightPx = presetSize;
-        }
-
-        // The cropped version is square
-        // If full version is desired, then only one dimension is required.
-        if (newWidthPx <= newHeightPx) {
-            newHeightPx = isCropped() ? newWidthPx : ImageRequest.UNSPECIFIED_DIMENSION;
-        } else {
-            newWidthPx = isCropped() ? newHeightPx : ImageRequest.UNSPECIFIED_DIMENSION;
-        }
-
-        boolean changed = (newWidthPx != queryWidth) || (newHeightPx != queryHeight);
-
-        queryWidth = newWidthPx;
-        queryHeight = newHeightPx;
-
-        return changed;
-    }
-
-    private int getPresetSizeInPixels(boolean forcePreset) {
-        int dimensionId;
-        switch (presetSizeType) {
-            case SMALL:
-                dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_small;
-                break;
-            case NORMAL:
-                dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_normal;
-                break;
-            case LARGE:
-                dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_large;
-                break;
-            case CUSTOM:
-                if (!forcePreset) {
-                    return ImageRequest.UNSPECIFIED_DIMENSION;
-                } else {
-                    dimensionId = R.dimen.com_facebook_profilepictureview_preset_size_normal;
-                    break;
-                }
-            default:
-                return ImageRequest.UNSPECIFIED_DIMENSION;
-        }
-
-        return getResources().getDimensionPixelSize(dimensionId);
-    }
-}
diff --git a/facebook/src/com/facebook/widget/UserSettingsFragment.java b/facebook/src/com/facebook/widget/UserSettingsFragment.java
deleted file mode 100644
index ed6cc9ceb..000000000
--- a/facebook/src/com/facebook/widget/UserSettingsFragment.java
+++ /dev/null
@@ -1,452 +0,0 @@
-/**
- * Copyright 2010-present Facebook.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.facebook.widget;
-
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.os.Bundle;
-import android.text.TextUtils;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.TextView;
-import com.facebook.*;
-import com.facebook.android.R;
-import com.facebook.internal.AnalyticsEvents;
-import com.facebook.internal.ImageDownloader;
-import com.facebook.internal.ImageRequest;
-import com.facebook.internal.ImageResponse;
-import com.facebook.model.GraphUser;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * A Fragment that displays a Login/Logout button as well as the user's
- * profile picture and name when logged in.
- * <p/>
- * This Fragment will create and use the active session upon construction
- * if it has the available data (if the app ID is specified in the manifest).
- * It will also open the active session if it does not require user interaction
- * (i.e. if the session is in the {@link com.facebook.SessionState#CREATED_TOKEN_LOADED} state.
- * Developers can override the use of the active session by calling
- * the {@link #setSession(com.facebook.Session)} method.
- */
-public class UserSettingsFragment extends FacebookFragment {
-
-    private static final String NAME = "name";
-    private static final String ID = "id";
-    private static final String PICTURE = "picture";
-    private static final String FIELDS = "fields";
-    
-    private static final String REQUEST_FIELDS = TextUtils.join(",", new String[] {ID, NAME, PICTURE});
-
-    private LoginButton loginButton;
-    private LoginButton.LoginButtonProperties loginButtonProperties = new LoginButton.LoginButtonProperties();
-    private TextView connectedStateLabel;
-    private GraphUser user;
-    private Session userInfoSession; // the Session used to fetch the current user info
-    private Drawable userProfilePic;
-    private String userProfilePicID;
-    private Session.StatusCallback sessionStatusCallback;
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        View view = inflater.inflate(R.layout.com_facebook_usersettingsfragment, container, false);
-        loginButton = (LoginButton) view.findViewById(R.id.com_facebook_usersettingsfragment_login_button);
-        loginButton.setProperties(loginButtonProperties);
-        loginButton.setFragment(this);
-        loginButton.setLoginLogoutEventName(AnalyticsEvents.EVENT_USER_SETTINGS_USAGE);
-
-        Session session = getSession();
-        if (session != null && !session.equals(Session.getActiveSession())) {
-            loginButton.setSession(session);
-        }
-        connectedStateLabel = (TextView) view.findViewById(R.id.com_facebook_usersettingsfragment_profile_name);
-        
-        // if no background is set for some reason, then default to Facebook blue
-        if (view.getBackground() == null) {
-            view.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
-        } else {
-            view.getBackground().setDither(true);
-        }
-        return view;
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setRetainInstance(true);
-    }
-
-    /**
-     * @throws com.facebook.FacebookException if errors occur during the loading of user information
-     */
-    @Override
-    public void onResume() {
-        super.onResume();
-        fetchUserInfo();
-        updateUI();
-    }
-
-    /**
-     * Set the Session object to use instead of the active Session. Since a Session
-     * cannot be reused, if the user logs out from this Session, and tries to
-     * log in again, a new Active Session will be used instead.
-     * <p/>
-     * If the passed in session is currently opened, this method will also attempt to
-     * load some user information for display (if needed).
-     *
-     * @param newSession the Session object to use
-     * @throws com.facebook.FacebookException if errors occur during the loading of user information
-     */
-    @Override
-    public void setSession(Session newSession) {
-        super.setSession(newSession);
-        if (loginButton != null) {
-            loginButton.setSession(newSession);
-        }
-        fetchUserInfo();
-        updateUI();
-    }
-
-    /**
-     * Sets the default audience to use when the session is opened.
-     * This value is only useful when specifying write permissions for the native
-     * login dialog.
-     *
-     * @param defaultAudience the default audience value to use
-     */
-    public void setDefaultAudience(SessionDefaultAudience defaultAudience) {
-        loginButtonProperties.setDefaultAudience(defaultAudience);
-    }
-
-    /**
-     * Gets the default audience to use when the session is opened.
-     * This value is only useful when specifying write permissions for the native
-     * login dialog.
-     *
-     * @return the default audience value to use
-     */
-    public SessionDefaultAudience getDefaultAudience() {
-        return loginButtonProperties.getDefaultAudience();
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * can only be read permissions. If any publish permissions are included, the login
-     * attempt by the user will fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the UserSettingsFragment is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setPublishPermissions has been called
-     */
-    public void setReadPermissions(List<String> permissions) {
-        loginButtonProperties.setReadPermissions(permissions, getSession());
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * can only be read permissions. If any publish permissions are included, the login
-     * attempt by the user will fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the UserSettingsFragment is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setPublishPermissions has been called
-     */
-    public void setReadPermissions(String... permissions) {
-        loginButtonProperties.setReadPermissions(Arrays.asList(permissions), getSession());
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * should only be publish permissions. If any read permissions are included, the login
-     * attempt by the user may fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setReadPermissions has been called
-     * @throws IllegalArgumentException if permissions is null or empty
-     */
-    public void setPublishPermissions(List<String> permissions) {
-        loginButtonProperties.setPublishPermissions(permissions, getSession());
-    }
-
-    /**
-     * Set the permissions to use when the session is opened. The permissions here
-     * should only be publish permissions. If any read permissions are included, the login
-     * attempt by the user may fail. The LoginButton can only be associated with either
-     * read permissions or publish permissions, but not both. Calling both
-     * setReadPermissions and setPublishPermissions on the same instance of LoginButton
-     * will result in an exception being thrown unless clearPermissions is called in between.
-     * <p/>
-     * This method is only meaningful if called before the session is open. If this is called
-     * after the session is opened, and the list of permissions passed in is not a subset
-     * of the permissions granted during the authorization, it will log an error.
-     * <p/>
-     * Since the session can be automatically opened when the LoginButton is constructed,
-     * it's important to always pass in a consistent set of permissions to this method, or
-     * manage the setting of permissions outside of the LoginButton class altogether
-     * (by managing the session explicitly).
-     *
-     * @param permissions the read permissions to use
-     *
-     * @throws UnsupportedOperationException if setReadPermissions has been called
-     * @throws IllegalArgumentException if permissions is null or empty
-     */
-    public void setPublishPermissions(String... permissions) {
-        loginButtonProperties.setPublishPermissions(Arrays.asList(permissions), getSession());
-    }
-
-
-    /**
-     * Clears the permissions currently associated with this LoginButton.
-     */
-    public void clearPermissions() {
-        loginButtonProperties.clearPermissions();
-    }
-
-    /**
-     * Sets the login behavior for the session that will be opened. If null is specified,
-     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
-     * will be used.
-     *
-     * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *                      specifies what behaviors should be attempted during
-     *                      authorization.
-     */
-    public void setLoginBehavior(SessionLoginBehavior loginBehavior) {
-        loginButtonProperties.setLoginBehavior(loginBehavior);
-    }
-
-    /**
-     * Gets the login behavior for the session that will be opened. If null is returned,
-     * the default ({@link SessionLoginBehavior SessionLoginBehavior.SSO_WITH_FALLBACK}
-     * will be used.
-     *
-     * @return loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
-     *                      specifies what behaviors should be attempted during
-     *                      authorization.
-     */
-    public SessionLoginBehavior getLoginBehavior() {
-        return loginButtonProperties.getLoginBehavior();
-    }
-
-    /**
-     * Sets an OnErrorListener for this instance of UserSettingsFragment to call into when
-     * certain exceptions occur.
-     *
-     * @param onErrorListener The listener object to set
-     */
-    public void setOnErrorListener(LoginButton.OnErrorListener onErrorListener) {
-        loginButtonProperties.setOnErrorListener(onErrorListener);
-    }
-
-    /**
-     * Returns the current OnErrorListener for this instance of UserSettingsFragment.
-     *
-     * @return The OnErrorListener
-     */
-    public LoginButton.OnErrorListener getOnErrorListener() {
-        return loginButtonProperties.getOnErrorListener();
-    }
-
-    /**
-     * Sets the callback interface that will be called whenever the status of the Session
-     * associated with this LoginButton changes.
-     *
-     * @param callback the callback interface
-     */
-    public void setSessionStatusCallback(Session.StatusCallback callback) {
-        this.sessionStatusCallback = callback;
-    }
-
-    /**
-     * Sets the callback interface that will be called whenever the status of the Session
-     * associated with this LoginButton changes.
-
-     * @return the callback interface
-     */
-    public Session.StatusCallback getSessionStatusCallback() {
-        return sessionStatusCallback;
-    }
-
-    @Override
-    protected void onSessionStateChange(SessionState state, Exception exception) {
-        fetchUserInfo();
-        updateUI();
-
-        if (sessionStatusCallback != null) {
-            sessionStatusCallback.call(getSession(), state, exception);
-        }
-    }
-
-    // For Testing Only
-    List<String> getPermissions() {
-        return loginButtonProperties.getPermissions();
-    }
-
-    private void fetchUserInfo() {
-        final Session currentSession = getSession();
-        if (currentSession != null && currentSession.isOpened()) {
-            if (currentSession != userInfoSession) {
-                Request request = Request.newMeRequest(currentSession, new Request.GraphUserCallback() {
-                    @Override
-                    public void onCompleted(GraphUser me, Response response) {
-                        if (currentSession == getSession()) {
-                            user = me;
-                            updateUI();
-                        }
-                        if (response.getError() != null) {
-                            loginButton.handleError(response.getError().getException());
-                        }
-                    }
-                });
-                Bundle parameters = new Bundle();
-                parameters.putString(FIELDS, REQUEST_FIELDS);
-                request.setParameters(parameters);
-                Request.executeBatchAsync(request);
-                userInfoSession = currentSession;
-            }
-        } else {
-            user = null;
-        }
-    }
-    
-    private void updateUI() {
-        if (!isAdded()) {
-            return;
-        }
-        if (isSessionOpen()) {
-            connectedStateLabel.setTextColor(getResources().getColor(R.color.com_facebook_usersettingsfragment_connected_text_color));
-            connectedStateLabel.setShadowLayer(1f, 0f, -1f,
-                    getResources().getColor(R.color.com_facebook_usersettingsfragment_connected_shadow_color));
-            
-            if (user != null) {
-                ImageRequest request = getImageRequest();
-                if (request != null) {
-                    URI requestUrl = request.getImageUri();
-                    // Do we already have the right picture? If so, leave it alone.
-                    if (!requestUrl.equals(connectedStateLabel.getTag())) {
-                        if (user.getId().equals(userProfilePicID)) {
-                            connectedStateLabel.setCompoundDrawables(null, userProfilePic, null, null);
-                            connectedStateLabel.setTag(requestUrl);
-                        } else {
-                            ImageDownloader.downloadAsync(request);
-                        }
-                    }
-                }
-                connectedStateLabel.setText(user.getName());
-            } else {
-                connectedStateLabel.setText(getResources().getString(
-                        R.string.com_facebook_usersettingsfragment_logged_in));
-                Drawable noProfilePic = getResources().getDrawable(R.drawable.com_facebook_profile_default_icon);
-                noProfilePic.setBounds(0, 0,
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height));
-                connectedStateLabel.setCompoundDrawables(null, noProfilePic, null, null);
-            }
-        } else {
-            int textColor = getResources().getColor(R.color.com_facebook_usersettingsfragment_not_connected_text_color);
-            connectedStateLabel.setTextColor(textColor);
-            connectedStateLabel.setShadowLayer(0f, 0f, 0f, textColor);
-            connectedStateLabel.setText(getResources().getString(
-                    R.string.com_facebook_usersettingsfragment_not_logged_in));
-            connectedStateLabel.setCompoundDrawables(null, null, null, null);
-            connectedStateLabel.setTag(null);
-        }
-    }
-
-    private ImageRequest getImageRequest() {
-        ImageRequest request = null;
-        try {
-            ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
-                    getActivity(),
-                    ImageRequest.getProfilePictureUrl(
-                            user.getId(),
-                            getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
-                            getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height)));
-
-            request = requestBuilder.setCallerTag(this)
-                    .setCallback(
-                            new ImageRequest.Callback() {
-                                @Override
-                                public void onCompleted(ImageResponse response) {
-                                    processImageResponse(user.getId(), response);
-                                }
-                            })
-                    .build();
-        } catch (URISyntaxException e) {
-        }
-        return request;
-    }
-
-    private void processImageResponse(String id, ImageResponse response) {
-        if (response != null) {
-            Bitmap bitmap = response.getBitmap();
-            if (bitmap != null) {
-                BitmapDrawable drawable = new BitmapDrawable(UserSettingsFragment.this.getResources(), bitmap);
-                drawable.setBounds(0, 0,
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_width),
-                        getResources().getDimensionPixelSize(R.dimen.com_facebook_usersettingsfragment_profile_picture_height));
-                userProfilePic = drawable;
-                userProfilePicID = id;
-                connectedStateLabel.setCompoundDrawables(null, drawable, null, null);
-                connectedStateLabel.setTag(response.getRequest().getImageUri());
-            }
-        }
-    }
-}
diff --git a/facebook/src/com/facebook/widget/WebDialog.java b/facebook/src/com/facebook/widget/WebDialog.java
index e4fb9f7bf..c9891a198 100644
--- a/facebook/src/com/facebook/widget/WebDialog.java
+++ b/facebook/src/com/facebook/widget/WebDialog.java
@@ -196,7 +196,8 @@ public void onCancel(DialogInterface dialogInterface) {
 
         spinner = new ProgressDialog(getContext());
         spinner.requestWindowFeature(Window.FEATURE_NO_TITLE);
-        spinner.setMessage(getContext().getString(R.string.com_facebook_loading));
+        //spinner.setMessage(getContext().getString(R.string.com_facebook_loading));
+        spinner.setMessage(getContext().getString(Utility.resId_loading));
         spinner.setOnCancelListener(new OnCancelListener() {
             @Override
             public void onCancel(DialogInterface dialogInterface) {
@@ -297,7 +298,8 @@ public void onClick(View v) {
                 WebDialog.this.dismiss();
             }
         });
-        Drawable crossDrawable = getContext().getResources().getDrawable(R.drawable.com_facebook_close);
+        //Drawable crossDrawable = getContext().getResources().getDrawable(R.drawable.com_facebook_close);
+        Drawable crossDrawable = getContext().getResources().getDrawable(Utility.resId_close);
         crossImageView.setImageDrawable(crossDrawable);
         /* 'x' should not be visible while webview is loading
          * make it visible only after webview has fully loaded
