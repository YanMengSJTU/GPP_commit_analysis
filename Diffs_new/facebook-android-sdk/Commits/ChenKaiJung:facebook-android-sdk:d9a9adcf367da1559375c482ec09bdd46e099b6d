diff --git a/funtown/src/tw/com/funtown/AccessToken.java b/funtown/src/tw/com/funtown/AccessToken.java
new file mode 100644
index 000000000..9895994e0
--- /dev/null
+++ b/funtown/src/tw/com/funtown/AccessToken.java
@@ -0,0 +1,359 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+import android.annotation.SuppressLint;
+import android.content.Intent;
+import android.os.Bundle;
+import android.text.TextUtils;
+import com.facebook.internal.Utility;
+import com.facebook.internal.Validate;
+
+import java.io.InvalidObjectException;
+import java.io.ObjectInputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+
+/**
+ * This class represents an access token returned by the Facebook Login service, along with associated
+ * metadata such as its expiration date and permissions. In general, the {@link Session} class will
+ * abstract away the need to worry about the details of an access token, but there are situations
+ * (such as handling native links, importing previously-obtained access tokens, etc.) where it is
+ * useful to deal with access tokens directly. Factory methods are provided to construct access tokens.
+ * <p/>
+ * For more information on access tokens, see
+ * https://developers.facebook.com/docs/concepts/login/access-tokens-and-types/.
+ */
+public final class AccessToken implements Serializable {
+    private static final long serialVersionUID = 1L;
+    static final String ACCESS_TOKEN_KEY = "access_token";
+    static final String EXPIRES_IN_KEY = "expires_in";
+    private static final Date MIN_DATE = new Date(Long.MIN_VALUE);
+    private static final Date MAX_DATE = new Date(Long.MAX_VALUE);
+    private static final Date DEFAULT_EXPIRATION_TIME = MAX_DATE;
+    private static final Date DEFAULT_LAST_REFRESH_TIME = new Date();
+    private static final AccessTokenSource DEFAULT_ACCESS_TOKEN_SOURCE = AccessTokenSource.FACEBOOK_APPLICATION_WEB;
+    private static final Date ALREADY_EXPIRED_EXPIRATION_TIME = MIN_DATE;
+
+    private final Date expires;
+    private final List<String> permissions;
+    private final String token;
+    private final AccessTokenSource source;
+    private final Date lastRefresh;
+
+    AccessToken(String token, Date expires, List<String> permissions, AccessTokenSource source, Date lastRefresh) {
+        if (permissions == null) {
+            permissions = Collections.emptyList();
+        }
+
+        this.expires = expires;
+        this.permissions = Collections.unmodifiableList(permissions);
+        this.token = token;
+        this.source = source;
+        this.lastRefresh = lastRefresh;
+    }
+
+    /**
+     * Gets the string representing the access token.
+     *
+     * @return the string representing the access token
+     */
+    public String getToken() {
+        return this.token;
+    }
+
+    /**
+     * Gets the date at which the access token expires.
+     *
+     * @return the expiration date of the token
+     */
+    public Date getExpires() {
+        return this.expires;
+    }
+
+    /**
+     * Gets the list of permissions associated with this access token. Note that the most up-to-date
+     * list of permissions is maintained by the Facebook service, so this list may be outdated if
+     * permissions have been added or removed since the time the AccessToken object was created. For
+     * more information on permissions, see https://developers.facebook.com/docs/reference/login/#permissions.
+     *
+     * @return a read-only list of strings representing the permissions granted via this access token
+     */
+    public List<String> getPermissions() {
+        return this.permissions;
+    }
+
+    /**
+     * Gets the {@link AccessTokenSource} indicating how this access token was obtained.
+     *
+     * @return the enum indicating how the access token was obtained
+     */
+    public AccessTokenSource getSource() {
+        return source;
+    }
+
+    /**
+     * Gets the date at which the token was last refreshed. Since tokens expire, the Facebook SDK
+     * will attempt to renew them periodically.
+     *
+     * @return the date at which this token was last refreshed
+     */
+    public Date getLastRefresh() {
+        return this.lastRefresh;
+    }
+
+    /**
+     * Creates a new AccessToken using the supplied information from a previously-obtained access
+     * token (for instance, from an already-cached access token obtained prior to integration with the
+     * Facebook SDK).
+     *
+     * @param accessToken       the access token string obtained from Facebook
+     * @param expirationTime    the expiration date associated with the token; if null, an infinite expiration time is
+     *                          assumed (but will become correct when the token is refreshed)
+     * @param lastRefreshTime   the last time the token was refreshed (or when it was first obtained); if null,
+     *                          the current time is used.
+     * @param accessTokenSource an enum indicating how the token was originally obtained (in most cases,
+     *                          this will be either AccessTokenSource.FACEBOOK_APPLICATION or
+     *                          AccessTokenSource.WEB_VIEW); if null, FACEBOOK_APPLICATION is assumed.
+     * @param permissions       the permissions that were requested when the token was obtained (or when
+     *                          it was last reauthorized); may be null if permission set is unknown
+     * @return a new AccessToken
+     */
+    public static AccessToken createFromExistingAccessToken(String accessToken, Date expirationTime,
+            Date lastRefreshTime, AccessTokenSource accessTokenSource, List<String> permissions) {
+        if (expirationTime == null) {
+            expirationTime = DEFAULT_EXPIRATION_TIME;
+        }
+        if (lastRefreshTime == null) {
+            lastRefreshTime = DEFAULT_LAST_REFRESH_TIME;
+        }
+        if (accessTokenSource == null) {
+            accessTokenSource = DEFAULT_ACCESS_TOKEN_SOURCE;
+        }
+
+        return new AccessToken(accessToken, expirationTime, permissions, accessTokenSource, lastRefreshTime);
+    }
+
+    /**
+     * Creates a new AccessToken using the information contained in an Intent populated by the Facebook
+     * application in order to launch a native link. For more information on native linking, please see
+     * https://developers.facebook.com/docs/mobile/android/deep_linking/.
+     *
+     * @param intent the Intent that was used to start an Activity; must not be null
+     * @return a new AccessToken, or null if the Intent did not contain enough data to create one
+     */
+    public static AccessToken createFromNativeLinkingIntent(Intent intent) {
+        Validate.notNull(intent, "intent");
+
+        if (intent.getExtras() == null) {
+            return null;
+        }
+
+        return createFromBundle(null, intent.getExtras(), AccessTokenSource.FACEBOOK_APPLICATION_WEB, new Date());
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder();
+
+        builder.append("{AccessToken");
+        builder.append(" token:").append(tokenToString());
+        appendPermissions(builder);
+        builder.append("}");
+
+        return builder.toString();
+    }
+
+    static AccessToken createEmptyToken(List<String> permissions) {
+        return new AccessToken("", ALREADY_EXPIRED_EXPIRATION_TIME, permissions, AccessTokenSource.NONE,
+                DEFAULT_LAST_REFRESH_TIME);
+    }
+
+    static AccessToken createFromString(String token, List<String> permissions, AccessTokenSource source) {
+        return new AccessToken(token, DEFAULT_EXPIRATION_TIME, permissions, source, DEFAULT_LAST_REFRESH_TIME);
+    }
+
+    static AccessToken createFromNativeLogin(Bundle bundle, AccessTokenSource source) {
+        Date expires = getBundleLongAsDate(
+                bundle, NativeProtocol.EXTRA_EXPIRES_SECONDS_SINCE_EPOCH, new Date(0));
+        ArrayList<String> permissions = bundle.getStringArrayList(NativeProtocol.EXTRA_PERMISSIONS);
+        String token = bundle.getString(NativeProtocol.EXTRA_ACCESS_TOKEN);
+
+        return createNew(permissions, token, expires, source);
+    }
+
+    static AccessToken createFromWebBundle(List<String> requestedPermissions, Bundle bundle, AccessTokenSource source) {
+        Date expires = getBundleLongAsDate(bundle, EXPIRES_IN_KEY, new Date());
+        String token = bundle.getString(ACCESS_TOKEN_KEY);
+
+        return createNew(requestedPermissions, token, expires, source);
+    }
+
+    @SuppressLint("FieldGetter")
+    static AccessToken createFromRefresh(AccessToken current, Bundle bundle) {
+        // Only tokens obtained via SSO support refresh. Token refresh returns the expiration date in
+        // seconds from the epoch rather than seconds from now.
+        assert (current.source == AccessTokenSource.FACEBOOK_APPLICATION_WEB ||
+                current.source == AccessTokenSource.FACEBOOK_APPLICATION_NATIVE ||
+                current.source == AccessTokenSource.FACEBOOK_APPLICATION_SERVICE);
+
+        Date expires = getBundleLongAsDate(bundle, EXPIRES_IN_KEY, new Date(0));
+        String token = bundle.getString(ACCESS_TOKEN_KEY);
+
+        return createNew(current.getPermissions(), token, expires, current.source);
+    }
+
+    static AccessToken createFromTokenWithRefreshedPermissions(AccessToken token, List<String> permissions) {
+        return new AccessToken(token.token, token.expires, permissions, token.source, token.lastRefresh);
+    }
+
+    private static AccessToken createNew(
+            List<String> requestedPermissions, String accessToken, Date expires, AccessTokenSource source) {
+        if (Utility.isNullOrEmpty(accessToken) || (expires == null)) {
+            return createEmptyToken(requestedPermissions);
+        } else {
+            return new AccessToken(accessToken, expires, requestedPermissions, source, new Date());
+        }
+    }
+
+    static AccessToken createFromCache(Bundle bundle) {
+        // Copy the list so we can guarantee immutable
+        List<String> originalPermissions = bundle.getStringArrayList(TokenCachingStrategy.PERMISSIONS_KEY);
+        List<String> permissions;
+        if (originalPermissions == null) {
+            permissions = Collections.emptyList();
+        } else {
+            permissions = Collections.unmodifiableList(new ArrayList<String>(originalPermissions));
+        }
+
+        return new AccessToken(bundle.getString(TokenCachingStrategy.TOKEN_KEY), TokenCachingStrategy.getDate(bundle,
+                TokenCachingStrategy.EXPIRATION_DATE_KEY), permissions, TokenCachingStrategy.getSource(bundle),
+                TokenCachingStrategy.getDate(bundle, TokenCachingStrategy.LAST_REFRESH_DATE_KEY));
+    }
+
+    Bundle toCacheBundle() {
+        Bundle bundle = new Bundle();
+
+        bundle.putString(TokenCachingStrategy.TOKEN_KEY, this.token);
+        TokenCachingStrategy.putDate(bundle, TokenCachingStrategy.EXPIRATION_DATE_KEY, expires);
+        bundle.putStringArrayList(TokenCachingStrategy.PERMISSIONS_KEY, new ArrayList<String>(permissions));
+        bundle.putSerializable(TokenCachingStrategy.TOKEN_SOURCE_KEY, source);
+        TokenCachingStrategy.putDate(bundle, TokenCachingStrategy.LAST_REFRESH_DATE_KEY, lastRefresh);
+
+        return bundle;
+    }
+
+    boolean isInvalid() {
+        return Utility.isNullOrEmpty(this.token) || new Date().after(this.expires);
+    }
+
+    private static AccessToken createFromBundle(List<String> requestedPermissions, Bundle bundle,
+            AccessTokenSource source,
+            Date expirationBase) {
+        String token = bundle.getString(ACCESS_TOKEN_KEY);
+        Date expires = getBundleLongAsDate(bundle, EXPIRES_IN_KEY, expirationBase);
+
+        if (Utility.isNullOrEmpty(token) || (expires == null)) {
+            return null;
+        }
+
+        return new AccessToken(token, expires, requestedPermissions, source, new Date());
+    }
+
+    private String tokenToString() {
+        if (this.token == null) {
+            return "null";
+        } else if (Settings.isLoggingBehaviorEnabled(LoggingBehavior.INCLUDE_ACCESS_TOKENS)) {
+            return this.token;
+        } else {
+            return "ACCESS_TOKEN_REMOVED";
+        }
+    }
+
+    private void appendPermissions(StringBuilder builder) {
+        builder.append(" permissions:");
+        if (this.permissions == null) {
+            builder.append("null");
+        } else {
+            builder.append("[");
+            builder.append(TextUtils.join(", ", permissions));
+            builder.append("]");
+        }
+    }
+
+    private static class SerializationProxyV1 implements Serializable {
+        private static final long serialVersionUID = -2488473066578201069L;
+        private final Date expires;
+        private final List<String> permissions;
+        private final String token;
+        private final AccessTokenSource source;
+        private final Date lastRefresh;
+
+        private SerializationProxyV1(String token, Date expires,
+                List<String> permissions, AccessTokenSource source, Date lastRefresh) {
+            this.expires = expires;
+            this.permissions = permissions;
+            this.token = token;
+            this.source = source;
+            this.lastRefresh = lastRefresh;
+        }
+
+        private Object readResolve() {
+            return new AccessToken(token, expires, permissions, source, lastRefresh);
+        }
+    }
+
+    private Object writeReplace() {
+        return new SerializationProxyV1(token, expires, permissions, source, lastRefresh);
+    }
+
+    // have a readObject that throws to prevent spoofing
+    private void readObject(ObjectInputStream stream) throws InvalidObjectException {
+        throw new InvalidObjectException("Cannot readObject, serialization proxy required");
+    }
+
+
+    private static Date getBundleLongAsDate(Bundle bundle, String key, Date dateBase) {
+        if (bundle == null) {
+            return null;
+        }
+
+        long secondsFromBase = Long.MIN_VALUE;
+
+        Object secondsObject = bundle.get(key);
+        if (secondsObject instanceof Long) {
+            secondsFromBase = (Long) secondsObject;
+        } else if (secondsObject instanceof String) {
+            try {
+                secondsFromBase = Long.parseLong((String) secondsObject);
+            } catch (NumberFormatException e) {
+                return null;
+            }
+        } else {
+            return null;
+        }
+
+        if (secondsFromBase == 0) {
+            return new Date(Long.MAX_VALUE);
+        } else {
+            return new Date(dateBase.getTime() + (secondsFromBase * 1000L));
+        }
+    }
+}
diff --git a/funtown/src/tw/com/funtown/AccessTokenSource.java b/funtown/src/tw/com/funtown/AccessTokenSource.java
new file mode 100644
index 000000000..7bce43bb0
--- /dev/null
+++ b/funtown/src/tw/com/funtown/AccessTokenSource.java
@@ -0,0 +1,67 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+/**
+ * Indicates where a Facebook access token was obtained from.
+ */
+public enum AccessTokenSource {
+    /**
+     * Indicates an access token has not been obtained, or is otherwise invalid.
+     */
+    NONE(false),
+    /**
+     * Indicates an access token was obtained by the user logging in through the
+     * Facebook app for Android using the web login dialog.
+     */
+    FACEBOOK_APPLICATION_WEB(true),
+    /**
+     * Indicates an access token was obtained by the user logging in through the
+     * Facebook app for Android using the native login dialog.
+     */
+    FACEBOOK_APPLICATION_NATIVE(true),
+    /**
+     * Indicates an access token was obtained by asking the Facebook app for the
+     * current token based on permissions the user has already granted to the app.
+     * No dialog was shown to the user in this case.
+     */
+    FACEBOOK_APPLICATION_SERVICE(true),
+    /**
+     * Indicates an access token was obtained by the user logging in through the
+     * Web-based dialog.
+     */
+    WEB_VIEW(false),
+    /**
+     * Indicates an access token is for a test user rather than an actual
+     * Facebook user.
+     */
+    TEST_USER(true),
+    /**
+     * Indicates an access token constructed with a Client Token.
+     */
+    CLIENT_TOKEN(true);
+
+    private final boolean canExtendToken;
+
+    AccessTokenSource(boolean canExtendToken) {
+        this.canExtendToken = canExtendToken;
+    }
+
+    boolean canExtendToken() {
+        return canExtendToken;
+    }
+}
diff --git a/funtown/src/tw/com/funtown/AuthorizationClient.java b/funtown/src/tw/com/funtown/AuthorizationClient.java
new file mode 100644
index 000000000..addc93697
--- /dev/null
+++ b/funtown/src/tw/com/funtown/AuthorizationClient.java
@@ -0,0 +1,854 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.webkit.CookieSyncManager;
+import com.facebook.android.R;
+import tw.com.funtown.internal.ServerProtocol;
+import tw.com.funtown.internal.Utility;
+import com.facebook.model.GraphMultiResult;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
+import com.facebook.model.GraphUser;
+import tw.com.funtown.widget.WebDialog;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+class AuthorizationClient implements Serializable {
+    private static final long serialVersionUID = 1L;
+    private static final String TAG = "Facebook-AuthorizationClient";
+    private static final String WEB_VIEW_AUTH_HANDLER_STORE =
+            "com.facebook.AuthorizationClient.WebViewAuthHandler.TOKEN_STORE_KEY";
+    private static final String WEB_VIEW_AUTH_HANDLER_TOKEN_KEY = "TOKEN";
+
+    List<AuthHandler> handlersToTry;
+    AuthHandler currentHandler;
+    transient Context context;
+    transient StartActivityDelegate startActivityDelegate;
+    transient OnCompletedListener onCompletedListener;
+    transient BackgroundProcessingListener backgroundProcessingListener;
+    transient boolean checkedInternetPermission;
+    AuthorizationRequest pendingRequest;
+
+    interface OnCompletedListener {
+        void onCompleted(Result result);
+    }
+
+    interface BackgroundProcessingListener {
+        void onBackgroundProcessingStarted();
+
+        void onBackgroundProcessingStopped();
+    }
+
+    interface StartActivityDelegate {
+        public void startActivityForResult(Intent intent, int requestCode);
+
+        public Activity getActivityContext();
+    }
+
+    void setContext(final Context context) {
+        this.context = context;
+        // We rely on individual requests to tell us how to start an activity.
+        startActivityDelegate = null;
+    }
+
+    void setContext(final Activity activity) {
+        this.context = activity;
+
+        // If we are used in the context of an activity, we will always use that activity to
+        // call startActivityForResult.
+        startActivityDelegate = new StartActivityDelegate() {
+            @Override
+            public void startActivityForResult(Intent intent, int requestCode) {
+                activity.startActivityForResult(intent, requestCode);
+            }
+
+            @Override
+            public Activity getActivityContext() {
+                return activity;
+            }
+        };
+    }
+
+    void startOrContinueAuth(AuthorizationRequest request) {
+        if (getInProgress()) {
+            continueAuth();
+        } else {
+            authorize(request);
+        }
+    }
+
+    void authorize(AuthorizationRequest request) {
+        if (request == null) {
+            return;
+        }
+
+        if (pendingRequest != null) {
+            throw new FuntownException("Attempted to authorize while a request is pending.");
+        }
+
+        if (request.needsNewTokenValidation() && !checkInternetPermission()) {
+            // We're going to need INTERNET permission later and don't have it, so fail early.
+            return;
+        }
+        pendingRequest = request;
+        handlersToTry = getHandlerTypes(request);
+        tryNextHandler();
+    }
+
+    void continueAuth() {
+        if (pendingRequest == null || currentHandler == null) {
+            throw new FuntownException("Attempted to continue authorization without a pending request.");
+        }
+
+        if (currentHandler.needsRestart()) {
+            currentHandler.cancel();
+            tryCurrentHandler();
+        }
+    }
+
+    boolean getInProgress() {
+        return pendingRequest != null && currentHandler != null;
+    }
+
+    void cancelCurrentHandler() {
+        if (currentHandler != null) {
+            currentHandler.cancel();
+        }
+    }
+
+    boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (requestCode == pendingRequest.getRequestCode()) {
+            return currentHandler.onActivityResult(requestCode, resultCode, data);
+        }
+        return false;
+    }
+
+    private List<AuthHandler> getHandlerTypes(AuthorizationRequest request) {
+        ArrayList<AuthHandler> handlers = new ArrayList<AuthHandler>();
+
+        final SessionLoginBehavior behavior = request.getLoginBehavior();
+        if (behavior.allowsKatanaAuth()) {
+            if (!request.isLegacy()) {
+                handlers.add(new GetTokenAuthHandler());
+                handlers.add(new KatanaLoginDialogAuthHandler());
+            }
+            handlers.add(new KatanaProxyAuthHandler());
+        }
+
+        if (behavior.allowsWebViewAuth()) {
+            handlers.add(new WebViewAuthHandler());
+        }
+
+        return handlers;
+    }
+
+    boolean checkInternetPermission() {
+        if (checkedInternetPermission) {
+            return true;
+        }
+
+        int permissionCheck = checkPermission(Manifest.permission.INTERNET);
+        if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
+            String errorType = context.getString(R.string.com_facebook_internet_permission_error_title);
+            String errorDescription = context.getString(R.string.com_facebook_internet_permission_error_message);
+            complete(Result.createErrorResult(errorType, errorDescription));
+
+            return false;
+        }
+
+        checkedInternetPermission = true;
+        return true;
+    }
+
+    void tryNextHandler() {
+        while (handlersToTry != null && !handlersToTry.isEmpty()) {
+            currentHandler = handlersToTry.remove(0);
+
+            boolean started = tryCurrentHandler();
+
+            if (started) {
+                return;
+            }
+        }
+
+        if (pendingRequest != null) {
+            // We went through all handlers without successfully attempting an auth.
+            completeWithFailure();
+        }
+    }
+
+    private void completeWithFailure() {
+        complete(Result.createErrorResult("Login attempt failed.", null));
+    }
+
+    boolean tryCurrentHandler() {
+        if (currentHandler.needsInternetPermission() && !checkInternetPermission()) {
+            return false;
+        }
+        return currentHandler.tryAuthorize(pendingRequest);
+    }
+
+    void completeAndValidate(Result outcome) {
+        // Do we need to validate a successful result (as in the case of a reauth)?
+        if (outcome.token != null && pendingRequest.needsNewTokenValidation()) {
+            validateSameFbidAndFinish(outcome);
+        } else {
+            // We're done, just notify the listener.
+            complete(outcome);
+        }
+    }
+
+    void complete(Result outcome) {
+        handlersToTry = null;
+        currentHandler = null;
+        pendingRequest = null;
+
+        notifyOnCompleteListener(outcome);
+    }
+
+    OnCompletedListener getOnCompletedListener() {
+        return onCompletedListener;
+    }
+
+    void setOnCompletedListener(OnCompletedListener onCompletedListener) {
+        this.onCompletedListener = onCompletedListener;
+    }
+
+    BackgroundProcessingListener getBackgroundProcessingListener() {
+        return backgroundProcessingListener;
+    }
+
+    void setBackgroundProcessingListener(BackgroundProcessingListener backgroundProcessingListener) {
+        this.backgroundProcessingListener = backgroundProcessingListener;
+    }
+
+    StartActivityDelegate getStartActivityDelegate() {
+        if (startActivityDelegate != null) {
+            return startActivityDelegate;
+        } else if (pendingRequest != null) {
+            // Wrap the request's delegate in our own.
+            return new StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    pendingRequest.getStartActivityDelegate().startActivityForResult(intent, requestCode);
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    return pendingRequest.getStartActivityDelegate().getActivityContext();
+                }
+            };
+        }
+        return null;
+    }
+
+    int checkPermission(String permission) {
+        return context.checkCallingOrSelfPermission(permission);
+    }
+
+    void validateSameFbidAndFinish(Result pendingResult) {
+        if (pendingResult.token == null) {
+            throw new FuntownException("Can't validate without a token");
+        }
+
+        RequestBatch batch = createReauthValidationBatch(pendingResult);
+
+        notifyBackgroundProcessingStart();
+
+        batch.executeAsync();
+    }
+
+    RequestBatch createReauthValidationBatch(final Result pendingResult) {
+        // We need to ensure that the token we got represents the same fbid as the old one. We issue
+        // a "me" request using the current token, a "me" request using the new token, and a "me/permissions"
+        // request using the current token to get the permissions of the user.
+
+        final ArrayList<String> fbids = new ArrayList<String>();
+        final ArrayList<String> tokenPermissions = new ArrayList<String>();
+        final String newToken = pendingResult.token.getToken();
+
+        Request.Callback meCallback = new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                try {
+                    GraphUser user = response.getGraphObjectAs(GraphUser.class);
+                    if (user != null) {
+                        fbids.add(user.getId());
+                    }
+                } catch (Exception ex) {
+                }
+            }
+        };
+
+        String validateSameFbidAsToken = pendingRequest.getPreviousAccessToken();
+        Request requestCurrentTokenMe = createGetProfileIdRequest(validateSameFbidAsToken);
+        requestCurrentTokenMe.setCallback(meCallback);
+
+        Request requestNewTokenMe = createGetProfileIdRequest(newToken);
+        requestNewTokenMe.setCallback(meCallback);
+
+        Request requestCurrentTokenPermissions = createGetPermissionsRequest(validateSameFbidAsToken);
+        requestCurrentTokenPermissions.setCallback(new Request.Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                try {
+                    GraphMultiResult result = response.getGraphObjectAs(GraphMultiResult.class);
+                    if (result != null) {
+                        GraphObjectList<GraphObject> data = result.getData();
+                        if (data != null && data.size() == 1) {
+                            GraphObject permissions = data.get(0);
+
+                            // The keys are the permission names.
+                            tokenPermissions.addAll(permissions.asMap().keySet());
+                        }
+                    }
+                } catch (Exception ex) {
+                }
+            }
+        });
+
+        RequestBatch batch = new RequestBatch(requestCurrentTokenMe, requestNewTokenMe,
+                requestCurrentTokenPermissions);
+        batch.setBatchApplicationId(pendingRequest.getApplicationId());
+        batch.addCallback(new RequestBatch.Callback() {
+            @Override
+            public void onBatchCompleted(RequestBatch batch) {
+                try {
+                    Result result = null;
+                    if (fbids.size() == 2 && fbids.get(0) != null && fbids.get(1) != null &&
+                            fbids.get(0).equals(fbids.get(1))) {
+                        // Modify the token to have the right permission set.
+                        AccessToken tokenWithPermissions = AccessToken
+                                .createFromTokenWithRefreshedPermissions(pendingResult.token,
+                                        tokenPermissions);
+                        result = Result.createTokenResult(tokenWithPermissions);
+                    } else {
+                        result = Result
+                                .createErrorResult("User logged in as different Facebook user.", null);
+                    }
+                    complete(result);
+                } catch (Exception ex) {
+                    complete(Result.createErrorResult("Caught exception", ex.getMessage()));
+                } finally {
+                    notifyBackgroundProcessingStop();
+                }
+            }
+        });
+
+        return batch;
+    }
+
+    Request createGetPermissionsRequest(String accessToken) {
+        Bundle parameters = new Bundle();
+        parameters.putString("fields", "id");
+        parameters.putString("access_token", accessToken);
+        return new Request(null, "me/permissions", parameters, HttpMethod.GET, null);
+    }
+
+    Request createGetProfileIdRequest(String accessToken) {
+        Bundle parameters = new Bundle();
+        parameters.putString("fields", "id");
+        parameters.putString("access_token", accessToken);
+        return new Request(null, "me", parameters, HttpMethod.GET, null);
+    }
+
+    private void notifyOnCompleteListener(Result outcome) {
+        if (onCompletedListener != null) {
+            onCompletedListener.onCompleted(outcome);
+        }
+    }
+
+    private void notifyBackgroundProcessingStart() {
+        if (backgroundProcessingListener != null) {
+            backgroundProcessingListener.onBackgroundProcessingStarted();
+        }
+    }
+
+    private void notifyBackgroundProcessingStop() {
+        if (backgroundProcessingListener != null) {
+            backgroundProcessingListener.onBackgroundProcessingStopped();
+        }
+    }
+
+    abstract class AuthHandler implements Serializable {
+        private static final long serialVersionUID = 1L;
+
+        abstract boolean tryAuthorize(AuthorizationRequest request);
+
+        boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+            return false;
+        }
+
+        boolean needsRestart() {
+            return false;
+        }
+
+        boolean needsInternetPermission() {
+            return false;
+        }
+
+        void cancel() {
+        }
+    }
+
+    class WebViewAuthHandler extends AuthHandler {
+        private static final long serialVersionUID = 1L;
+        private transient WebDialog loginDialog;
+
+        @Override
+        boolean needsRestart() {
+            // Because we are presenting WebView UI within the current context, we need to explicitly
+            // restart the process if the context goes away and is recreated.
+            return true;
+        }
+
+        @Override
+        boolean needsInternetPermission() {
+            return true;
+        }
+
+        @Override
+        void cancel() {
+            if (loginDialog != null) {
+                loginDialog.dismiss();
+                loginDialog = null;
+            }
+        }
+
+        @Override
+        boolean tryAuthorize(final AuthorizationRequest request) {
+            String applicationId = request.getApplicationId();
+            Bundle parameters = new Bundle();
+            if (!Utility.isNullOrEmpty(request.getPermissions())) {
+                parameters.putString(ServerProtocol.DIALOG_PARAM_SCOPE, TextUtils.join(",", request.getPermissions()));
+            }
+
+            String previousToken = request.getPreviousAccessToken();
+            if (!Utility.isNullOrEmpty(previousToken) && (previousToken.equals(loadCookieToken()))) {
+                parameters.putString(ServerProtocol.DIALOG_PARAM_ACCESS_TOKEN, previousToken);
+            } else {
+                // The call to clear cookies will create the first instance of CookieSyncManager if necessary
+                Utility.clearFuntownCookies(context);
+            }
+            
+            String redirectUri = request.getRedirectUri();
+            if (!Utility.isNullOrEmpty(redirectUri)) {
+                parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, redirectUri);
+            } else {
+                // The call to clear cookies will create the first instance of CookieSyncManager if necessary
+                parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, "ftconnect://success");
+            }   
+            
+            WebDialog.OnCompleteListener listener = new WebDialog.OnCompleteListener() {
+                @Override
+                public void onComplete(Bundle values, FuntownException error) {
+                    onWebDialogComplete(request, values, error);
+                }
+            };
+
+            WebDialog.Builder builder =
+                    new AuthDialogBuilder(getStartActivityDelegate().getActivityContext(), applicationId, parameters)
+                            .setOnCompleteListener(listener);
+            loginDialog = builder.build();
+            loginDialog.show();
+
+            return true;
+        }
+
+        void onWebDialogComplete(AuthorizationRequest request, Bundle values,
+        		FuntownException error) {
+            Result outcome;
+            if (values != null) {
+                AccessToken token = AccessToken
+                        .createFromWebBundle(request.getPermissions(), values, AccessTokenSource.WEB_VIEW);
+                outcome = Result.createTokenResult(token);
+
+                // Ensure any cookies set by the dialog are saved
+                // This is to work around a bug where CookieManager may fail to instantiate if CookieSyncManager
+                // has never been created.
+                CookieSyncManager syncManager = CookieSyncManager.createInstance(context);
+                syncManager.sync();
+                saveCookieToken(token.getToken());
+            } else {
+                if (error instanceof FuntownOperationCanceledException) {
+                    outcome = Result.createCancelResult("User canceled log in.");
+                } else {
+                    outcome = Result.createErrorResult(error.getMessage(), null);
+                }
+            }
+            completeAndValidate(outcome);
+        }
+
+        private void saveCookieToken(String token) {
+            Context context = getStartActivityDelegate().getActivityContext();
+            SharedPreferences sharedPreferences = context.getSharedPreferences(
+                    WEB_VIEW_AUTH_HANDLER_STORE,
+                    Context.MODE_PRIVATE);
+            SharedPreferences.Editor editor = sharedPreferences.edit();
+            editor.putString(WEB_VIEW_AUTH_HANDLER_TOKEN_KEY, token);
+            if (!editor.commit()) {
+                Utility.logd(TAG, "Could not update saved web view auth handler token.");
+            }
+        }
+
+        private String loadCookieToken() {
+            Context context = getStartActivityDelegate().getActivityContext();
+            SharedPreferences sharedPreferences = context.getSharedPreferences(
+                    WEB_VIEW_AUTH_HANDLER_STORE,
+                    Context.MODE_PRIVATE);
+            return sharedPreferences.getString(WEB_VIEW_AUTH_HANDLER_TOKEN_KEY, "");
+        }
+    }
+
+    class GetTokenAuthHandler extends AuthHandler {
+        private static final long serialVersionUID = 1L;
+        private transient GetTokenClient getTokenClient;
+
+        @Override
+        void cancel() {
+            if (getTokenClient != null) {
+                getTokenClient.cancel();
+                getTokenClient = null;
+            }
+        }
+
+        boolean tryAuthorize(final AuthorizationRequest request) {
+            getTokenClient = new GetTokenClient(context, request.getApplicationId());
+            if (!getTokenClient.start()) {
+                return false;
+            }
+
+            notifyBackgroundProcessingStart();
+
+            GetTokenClient.CompletedListener callback = new GetTokenClient.CompletedListener() {
+                @Override
+                public void completed(Bundle result) {
+                    getTokenCompleted(request, result);
+                }
+            };
+
+            getTokenClient.setCompletedListener(callback);
+            return true;
+        }
+
+        void getTokenCompleted(AuthorizationRequest request, Bundle result) {
+            getTokenClient = null;
+
+            notifyBackgroundProcessingStop();
+
+            if (result != null) {
+                ArrayList<String> currentPermissions = result.getStringArrayList(NativeProtocol.EXTRA_PERMISSIONS);
+                List<String> permissions = request.getPermissions();
+                if ((currentPermissions != null) &&
+                        ((permissions == null) || currentPermissions.containsAll(permissions))) {
+                    // We got all the permissions we needed, so we can complete the auth now.
+                    AccessToken token = AccessToken
+                            .createFromNativeLogin(result, AccessTokenSource.FACEBOOK_APPLICATION_SERVICE);
+                    Result outcome = Result.createTokenResult(token);
+                    completeAndValidate(outcome);
+                    return;
+                }
+
+                // We didn't get all the permissions we wanted, so update the request with just the permissions
+                // we still need.
+                ArrayList<String> newPermissions = new ArrayList<String>();
+                for (String permission : permissions) {
+                    if (!currentPermissions.contains(permission)) {
+                        newPermissions.add(permission);
+                    }
+                }
+                request.setPermissions(newPermissions);
+            }
+
+            tryNextHandler();
+        }
+    }
+
+    abstract class KatanaAuthHandler extends AuthHandler {
+        private static final long serialVersionUID = 1L;
+
+        protected boolean tryIntent(Intent intent, int requestCode) {
+            if (intent == null) {
+                return false;
+            }
+
+            try {
+                getStartActivityDelegate().startActivityForResult(intent, requestCode);
+            } catch (ActivityNotFoundException e) {
+                return false;
+            }
+
+            return true;
+        }
+    }
+
+    class KatanaLoginDialogAuthHandler extends KatanaAuthHandler {
+        private static final long serialVersionUID = 1L;
+
+        @Override
+        boolean tryAuthorize(AuthorizationRequest request) {
+            Intent intent = NativeProtocol.createLoginDialog20121101Intent(context, request.getApplicationId(),
+                    new ArrayList<String>(request.getPermissions()),
+                    request.getDefaultAudience().getNativeProtocolAudience());
+
+            return tryIntent(intent, request.getRequestCode());
+        }
+
+        @Override
+        boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+            Result outcome;
+
+            if (data == null) {
+                // This happens if the user presses 'Back'.
+                outcome = Result.createCancelResult("Operation canceled");
+            } else if (NativeProtocol.isServiceDisabledResult20121101(data)) {
+                outcome = null;
+            } else if (resultCode == Activity.RESULT_CANCELED) {
+                outcome = Result.createCancelResult(
+                        data.getStringExtra(NativeProtocol.STATUS_ERROR_DESCRIPTION));
+            } else if (resultCode != Activity.RESULT_OK) {
+                outcome = Result.createErrorResult("Unexpected resultCode from authorization.", null);
+            } else {
+                outcome = handleResultOk(data);
+            }
+
+            if (outcome != null) {
+                completeAndValidate(outcome);
+            } else {
+                tryNextHandler();
+            }
+
+            return true;
+        }
+
+        private Result handleResultOk(Intent data) {
+            Bundle extras = data.getExtras();
+            String errorType = extras.getString(NativeProtocol.STATUS_ERROR_TYPE);
+            if (errorType == null) {
+                return Result.createTokenResult(
+                        AccessToken.createFromNativeLogin(extras, AccessTokenSource.FACEBOOK_APPLICATION_NATIVE));
+            } else if (NativeProtocol.ERROR_SERVICE_DISABLED.equals(errorType)) {
+                return null;
+            } else if (NativeProtocol.ERROR_USER_CANCELED.equals(errorType)) {
+                return Result.createCancelResult(null);
+            } else {
+                return Result.createErrorResult(errorType, extras.getString("error_description"));
+            }
+        }
+    }
+
+    class KatanaProxyAuthHandler extends KatanaAuthHandler {
+        private static final long serialVersionUID = 1L;
+
+        @Override
+        boolean tryAuthorize(AuthorizationRequest request) {
+            Intent intent = NativeProtocol.createProxyAuthIntent(context,
+                    request.getApplicationId(), request.getPermissions());
+
+            return tryIntent(intent, request.getRequestCode());
+        }
+
+        @Override
+        boolean onActivityResult(int requestCode, int resultCode, Intent data) {
+            // Handle stuff
+            Result outcome;
+
+            if (data == null) {
+                // This happens if the user presses 'Back'.
+                outcome = Result.createCancelResult("Operation canceled");
+            } else if (resultCode == Activity.RESULT_CANCELED) {
+                outcome = Result.createCancelResult(data.getStringExtra("error"));
+            } else if (resultCode != Activity.RESULT_OK) {
+                outcome = Result.createErrorResult("Unexpected resultCode from authorization.", null);
+            } else {
+                outcome = handleResultOk(data);
+            }
+
+            if (outcome != null) {
+                completeAndValidate(outcome);
+            } else {
+                tryNextHandler();
+            }
+            return true;
+        }
+
+        private Result handleResultOk(Intent data) {
+            Bundle extras = data.getExtras();
+            String error = extras.getString("error");
+            if (error == null) {
+                error = extras.getString("error_type");
+            }
+
+            if (error == null) {
+                AccessToken token = AccessToken.createFromWebBundle(pendingRequest.getPermissions(), extras,
+                        AccessTokenSource.FACEBOOK_APPLICATION_WEB);
+                return Result.createTokenResult(token);
+            } else if (ServerProtocol.errorsProxyAuthDisabled.contains(error)) {
+                return null;
+            } else if (ServerProtocol.errorsUserCanceled.contains(error)) {
+                return Result.createCancelResult(null);
+            } else {
+                return Result.createErrorResult(error, extras.getString("error_description"));
+            }
+        }
+    }
+
+    static class AuthDialogBuilder extends WebDialog.Builder {
+        private static final String OAUTH_DIALOG = "oauth_mobile.php";
+        //static final String REDIRECT_URI = "fbconnect://success";
+        static final String RESPONSE_TYPE = "code";
+        
+        public AuthDialogBuilder(Context context, String applicationId, Bundle parameters) {
+            super(context, applicationId, OAUTH_DIALOG, parameters);
+        }
+
+        @Override
+        public WebDialog build() {
+            Bundle parameters = getParameters();
+            //parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, REDIRECT_URI);
+            parameters.putString(ServerProtocol.DIALOG_PARAM_CLIENT_ID, getApplicationId());
+            parameters.putString(ServerProtocol.DIALOG_PARAM_RESPONSE_TYPE, RESPONSE_TYPE);
+            
+            return new WebDialog(getContext(), OAUTH_DIALOG, parameters, getTheme(), getListener());
+        }
+    }
+
+    static class AuthorizationRequest implements Serializable {
+        private static final long serialVersionUID = 1L;
+
+        private transient final StartActivityDelegate startActivityDelegate;
+        private SessionLoginBehavior loginBehavior;
+        private int requestCode;
+        private boolean isLegacy = false;
+        private List<String> permissions;
+        private SessionDefaultAudience defaultAudience;
+        private String applicationId;
+        private String previousAccessToken;
+        private String redirectUri;
+        
+        AuthorizationRequest(SessionLoginBehavior loginBehavior, int requestCode, boolean isLegacy,
+                List<String> permissions, SessionDefaultAudience defaultAudience, String applicationId,String redirectUri,
+                String validateSameFbidAsToken, StartActivityDelegate startActivityDelegate) {
+            this.loginBehavior = loginBehavior;
+            this.requestCode = requestCode;
+            this.isLegacy = isLegacy;
+            this.permissions = permissions;
+            this.defaultAudience = defaultAudience;
+            this.applicationId = applicationId;
+            this.redirectUri=redirectUri;
+            this.previousAccessToken = validateSameFbidAsToken;
+            this.startActivityDelegate = startActivityDelegate;
+
+        }
+
+        StartActivityDelegate getStartActivityDelegate() {
+            return startActivityDelegate;
+        }
+
+        List<String> getPermissions() {
+            return permissions;
+        }
+
+        void setPermissions(List<String> permissions) {
+            this.permissions = permissions;
+        }
+
+        SessionLoginBehavior getLoginBehavior() {
+            return loginBehavior;
+        }
+
+        int getRequestCode() {
+            return requestCode;
+        }
+
+        SessionDefaultAudience getDefaultAudience() {
+            return defaultAudience;
+        }
+
+        String getApplicationId() {
+            return applicationId;
+        }
+        
+        String getRedirectUri() {
+            return redirectUri;
+        }
+        boolean isLegacy() {
+            return isLegacy;
+        }
+
+        void setIsLegacy(boolean isLegacy) {
+            this.isLegacy = isLegacy;
+        }
+
+        String getPreviousAccessToken() {
+            return previousAccessToken;
+        }
+
+        boolean needsNewTokenValidation() {
+            return previousAccessToken != null && !isLegacy;
+        }
+    }
+
+
+    static class Result implements Serializable {
+        private static final long serialVersionUID = 1L;
+
+        enum Code {
+            SUCCESS,
+            CANCEL,
+            ERROR
+        }
+
+        final Code code;
+        final AccessToken token;
+        final String errorMessage;
+
+        private Result(Code code, AccessToken token, String errorMessage) {
+            this.token = token;
+            this.errorMessage = errorMessage;
+            this.code = code;
+        }
+
+        static Result createTokenResult(AccessToken token) {
+            return new Result(Code.SUCCESS, token, null);
+        }
+
+        static Result createCancelResult(String message) {
+            return new Result(Code.CANCEL, null, message);
+        }
+
+        static Result createErrorResult(String errorType, String errorDescription) {
+            String message = errorType;
+            if (errorDescription != null) {
+                message += ": " + errorDescription;
+            }
+            return new Result(Code.ERROR, null, message);
+        }
+    }
+}
diff --git a/funtown/src/tw/com/funtown/FuntownAuthorizationException.java b/funtown/src/tw/com/funtown/FuntownAuthorizationException.java
new file mode 100644
index 000000000..ad9a5cbd8
--- /dev/null
+++ b/funtown/src/tw/com/funtown/FuntownAuthorizationException.java
@@ -0,0 +1,65 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+/**
+ * An Exception indicating that a Session failed to open or obtain new permissions.
+ */
+public class FuntownAuthorizationException extends FuntownException {
+    static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a FacebookAuthorizationException with no additional
+     * information.
+     */
+    public FuntownAuthorizationException() {
+        super();
+    }
+
+    /**
+     * Constructs a FacebookAuthorizationException with a message.
+     * 
+     * @param message
+     *            A String to be returned from getMessage.
+     */
+    public FuntownAuthorizationException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a FacebookAuthorizationException with a message and inner
+     * error.
+     * 
+     * @param message
+     *            A String to be returned from getMessage.
+     * @param throwable
+     *            A Throwable to be returned from getCause.
+     */
+    public FuntownAuthorizationException(String message, Throwable throwable) {
+        super(message, throwable);
+    }
+
+    /**
+     * Constructs a FacebookAuthorizationException with an inner error.
+     * 
+     * @param throwable
+     *            A Throwable to be returned from getCause.
+     */
+    public FuntownAuthorizationException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/funtown/src/tw/com/funtown/FuntownDialogException.java b/funtown/src/tw/com/funtown/FuntownDialogException.java
new file mode 100644
index 000000000..07c6adfa6
--- /dev/null
+++ b/funtown/src/tw/com/funtown/FuntownDialogException.java
@@ -0,0 +1,53 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+/**
+ * Represents an error condition relating to displaying a Facebook Web dialog.
+ */
+public class FuntownDialogException extends FuntownException {
+    static final long serialVersionUID = 1;
+    private int errorCode;
+    private String failingUrl;
+
+    /**
+     * Constructs a new FacebookException.
+     */
+    public FuntownDialogException(String message, int errorCode, String failingUrl) {
+        super(message);
+        this.errorCode = errorCode;
+        this.failingUrl = failingUrl;
+    }
+
+    /**
+     * Gets the error code received by the WebView. See:
+     * http://developer.android.com/reference/android/webkit/WebViewClient.html
+     *
+     * @return the error code
+     */
+    public int getErrorCode() {
+        return errorCode;
+    }
+
+    /**
+     * Gets the URL that the dialog was trying to load.
+     * @return the URL
+     */
+    public String getFailingUrl() {
+        return failingUrl;
+    }
+}
diff --git a/funtown/src/tw/com/funtown/FuntownException.java b/funtown/src/tw/com/funtown/FuntownException.java
new file mode 100644
index 000000000..607f2e8c2
--- /dev/null
+++ b/funtown/src/tw/com/funtown/FuntownException.java
@@ -0,0 +1,47 @@
+package tw.com.funtown;
+
+/**
+ * Represents an error condition specific to the Facebook SDK for Android.
+ */
+public class FuntownException extends RuntimeException {
+    static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a new FuntownException.
+     */
+    public FuntownException() {
+        super();
+    }
+
+    /**
+     * Constructs a new FuntownException.
+     * 
+     * @param message
+     *            the detail message of this exception
+     */
+    public FuntownException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a new FuntownException.
+     * 
+     * @param message
+     *            the detail message of this exception
+     * @param throwable
+     *            the cause of this exception
+     */
+    public FuntownException(String message, Throwable throwable) {
+        super(message, throwable);
+    }
+
+    /**
+     * Constructs a new FuntownException.
+     * 
+     * @param throwable
+     *            the cause of this exception
+     */
+    public FuntownException(Throwable throwable) {
+        super(throwable);
+    }
+}
\ No newline at end of file
diff --git a/funtown/src/tw/com/funtown/FuntownOperationCanceledException.java b/funtown/src/tw/com/funtown/FuntownOperationCanceledException.java
new file mode 100644
index 000000000..c54de36cb
--- /dev/null
+++ b/funtown/src/tw/com/funtown/FuntownOperationCanceledException.java
@@ -0,0 +1,59 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+/**
+ * An Exception indicating that an operation was canceled before it completed.
+ */
+public class FuntownOperationCanceledException extends FuntownException {
+    static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a FacebookOperationCanceledException with no additional information.
+     */
+    public FuntownOperationCanceledException() {
+        super();
+    }
+
+    /**
+     * Constructs a FacebookOperationCanceledException with a message.
+     *
+     * @param message A String to be returned from getMessage.
+     */
+    public FuntownOperationCanceledException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a FacebookOperationCanceledException with a message and inner error.
+     *
+     * @param message   A String to be returned from getMessage.
+     * @param throwable A Throwable to be returned from getCause.
+     */
+    public FuntownOperationCanceledException(String message, Throwable throwable) {
+        super(message, throwable);
+    }
+
+    /**
+     * Constructs a FacebookOperationCanceledException with an inner error.
+     *
+     * @param throwable A Throwable to be returned from getCause.
+     */
+    public FuntownOperationCanceledException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/funtown/src/tw/com/funtown/FuntownRequestError.java b/funtown/src/tw/com/funtown/FuntownRequestError.java
new file mode 100644
index 000000000..b24cc55db
--- /dev/null
+++ b/funtown/src/tw/com/funtown/FuntownRequestError.java
@@ -0,0 +1,437 @@
+package tw.com.funtown;
+
+import com.facebook.android.R;
+import tw.com.funtown.internal.Utility;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.net.HttpURLConnection;
+
+/**
+ * This class represents an error that occurred during a Facebook request.
+ * <p/>
+ * In general, one would call {@link #getCategory()} to determine the type
+ * of error that occurred, and act accordingly. The app can also call
+ * {@link #getUserActionMessageId()} in order to get the resource id for a
+ * string that can be displayed to the user. For more information on error
+ * handling, see <a href="https://developers.facebook.com/docs/reference/api/errors/">
+ * https://developers.facebook.com/docs/reference/api/errors/</a>
+ */
+public final class FuntownRequestError {
+
+    /** Represents an invalid or unknown error code from the server. */
+    public static final int INVALID_ERROR_CODE = -1;
+
+    /**
+     * Indicates that there was no valid HTTP status code returned, indicating
+     * that either the error occurred locally, before the request was sent, or
+     * that something went wrong with the HTTP connection. Check the exception
+     * from {@link #getException()};
+     */
+    public static final int INVALID_HTTP_STATUS_CODE = -1;
+
+    private static final int INVALID_MESSAGE_ID = 0;
+
+    private static final String CODE_KEY = "code";
+    private static final String BODY_KEY = "body";
+    private static final String ERROR_KEY = "error";
+    private static final String ERROR_TYPE_FIELD_KEY = "type";
+    private static final String ERROR_CODE_FIELD_KEY = "code";
+    private static final String ERROR_MESSAGE_FIELD_KEY = "message";
+    private static final String ERROR_CODE_KEY = "error_code";
+    private static final String ERROR_SUB_CODE_KEY = "error_subcode";
+    private static final String ERROR_MSG_KEY = "error_msg";
+    private static final String ERROR_REASON_KEY = "error_reason";
+
+    private static class Range {
+        private final int start, end;
+
+        private Range(int start, int end) {
+            this.start = start;
+            this.end = end;
+        }
+
+        boolean contains(int value) {
+            return start <= value && value <= end;
+        }
+    }
+
+    private static final int EC_UNKNOWN_ERROR = 1;
+    private static final int EC_SERVICE_UNAVAILABLE = 2;
+    private static final int EC_APP_TOO_MANY_CALLS = 4;
+    private static final int EC_USER_TOO_MANY_CALLS = 17;
+    private static final int EC_PERMISSION_DENIED = 10;
+    private static final int EC_INVALID_SESSION = 102;
+    private static final int EC_INVALID_TOKEN = 190;
+    private static final Range EC_RANGE_PERMISSION = new Range(200, 299);
+    private static final int EC_APP_NOT_INSTALLED = 458;
+    private static final int EC_USER_CHECKPOINTED = 459;
+    private static final int EC_PASSWORD_CHANGED = 460;
+    private static final int EC_EXPIRED = 463;
+    private static final int EC_UNCONFIRMED_USER = 464;
+
+    private static final Range HTTP_RANGE_SUCCESS = new Range(200, 299);
+    private static final Range HTTP_RANGE_CLIENT_ERROR = new Range(400, 499);
+    private static final Range HTTP_RANGE_SERVER_ERROR = new Range(500, 599);
+
+    private final int userActionMessageId;
+    private final boolean shouldNotifyUser;
+    private final Category category;
+    private final int requestStatusCode;
+    private final int errorCode;
+    private final int subErrorCode;
+    private final String errorType;
+    private final String errorMessage;
+    private final JSONObject requestResult;
+    private final JSONObject requestResultBody;
+    private final Object batchRequestResult;
+    private final HttpURLConnection connection;
+    private final FuntownException exception;
+
+    private FuntownRequestError(int requestStatusCode, int errorCode,
+            int subErrorCode, String errorType, String errorMessage, JSONObject requestResultBody,
+            JSONObject requestResult, Object batchRequestResult, HttpURLConnection connection,
+            FuntownException exception) {
+        this.requestStatusCode = requestStatusCode;
+        this.errorCode = errorCode;
+        this.subErrorCode = subErrorCode;
+        this.errorType = errorType;
+        this.errorMessage = errorMessage;
+        this.requestResultBody = requestResultBody;
+        this.requestResult = requestResult;
+        this.batchRequestResult = batchRequestResult;
+        this.connection = connection;
+
+        boolean isLocalException = false;
+        if (exception != null) {
+            this.exception = exception;
+            isLocalException =  true;
+        } else {
+            this.exception = new FuntownServiceException(this, errorMessage);
+        }
+
+        // Initializes the error categories based on the documented error codes as outlined here
+        // https://developers.facebook.com/docs/reference/api/errors/
+        Category errorCategory = null;
+        int messageId = INVALID_MESSAGE_ID;
+        boolean shouldNotify = false;
+        if (isLocalException) {
+            errorCategory = Category.CLIENT;
+            messageId = INVALID_MESSAGE_ID;
+        } else {
+            if (errorCode == EC_UNKNOWN_ERROR || errorCode == EC_SERVICE_UNAVAILABLE) {
+                errorCategory = Category.SERVER;
+            } else if (errorCode == EC_APP_TOO_MANY_CALLS || errorCode == EC_USER_TOO_MANY_CALLS) {
+                errorCategory = Category.THROTTLING;
+            } else if (errorCode == EC_PERMISSION_DENIED || EC_RANGE_PERMISSION.contains(errorCode)) {
+                errorCategory = Category.PERMISSION;
+                messageId = R.string.com_facebook_requesterror_permissions;
+            } else if (errorCode == EC_INVALID_SESSION || errorCode == EC_INVALID_TOKEN) {
+                if (subErrorCode == EC_USER_CHECKPOINTED || subErrorCode == EC_UNCONFIRMED_USER) {
+                    errorCategory = Category.AUTHENTICATION_RETRY;
+                    messageId = R.string.com_facebook_requesterror_web_login;
+                    shouldNotify = true;
+                } else {
+                    errorCategory = Category.AUTHENTICATION_REOPEN_SESSION;
+
+                    if ((subErrorCode == EC_APP_NOT_INSTALLED) || (subErrorCode == EC_EXPIRED)) {
+                        messageId = R.string.com_facebook_requesterror_relogin;
+                    } else if (subErrorCode == EC_PASSWORD_CHANGED) {
+                        messageId = R.string.com_facebook_requesterror_password_changed;
+                    } else {
+                        messageId = R.string.com_facebook_requesterror_reconnect;
+                        shouldNotify = true;
+                    }
+                }
+            }
+
+            if (errorCategory == null) {
+                if (HTTP_RANGE_CLIENT_ERROR.contains(requestStatusCode)) {
+                    errorCategory = Category.BAD_REQUEST;
+                } else if (HTTP_RANGE_SERVER_ERROR.contains(requestStatusCode)) {
+                    errorCategory = Category.SERVER;
+                } else {
+                    errorCategory = Category.OTHER;
+                }
+            }
+        }
+
+        this.category = errorCategory;
+        this.userActionMessageId = messageId;
+        this.shouldNotifyUser = shouldNotify;
+    }
+
+    private FuntownRequestError(int requestStatusCode, int errorCode,
+            int subErrorCode, String errorType, String errorMessage, JSONObject requestResultBody,
+            JSONObject requestResult, Object batchRequestResult, HttpURLConnection connection) {
+        this(requestStatusCode, errorCode, subErrorCode, errorType, errorMessage,
+                requestResultBody, requestResult, batchRequestResult, connection, null);
+    }
+
+    FuntownRequestError(HttpURLConnection connection, Exception exception) {
+        this(INVALID_HTTP_STATUS_CODE, INVALID_ERROR_CODE, INVALID_ERROR_CODE,
+                null, null, null, null, null, connection,
+                (exception instanceof FuntownException) ?
+                        (FuntownException) exception : new FuntownException(exception));
+    }
+
+    public FuntownRequestError(int errorCode, String errorType, String errorMessage) {
+        this(INVALID_HTTP_STATUS_CODE, errorCode, INVALID_ERROR_CODE, errorType, errorMessage,
+                null, null, null, null, null);
+    }
+
+    /**
+     * Returns the resource id for a user-friendly message for the application to
+     * present to the user.
+     *
+     * @return a user-friendly message to present to the user
+     */
+    public int getUserActionMessageId() {
+        return userActionMessageId;
+    }
+
+    /**
+     * Returns whether direct user action is required to successfully continue with the Facebook
+     * operation. If user action is required, apps can also call {@link #getUserActionMessageId()}
+     * in order to get a resource id for a message to show the user.
+     *
+     * @return whether direct user action is required
+     */
+    public boolean shouldNotifyUser() {
+        return shouldNotifyUser;
+    }
+
+    /**
+     * Returns the category in which the error belongs. Applications can use the category
+     * to determine how best to handle the errors (e.g. exponential backoff for retries if
+     * being throttled).
+     *
+     * @return the category in which the error belong
+     */
+    public Category getCategory() {
+        return category;
+    }
+
+    /**
+     * Returns the HTTP status code for this particular request.
+     *
+     * @return the HTTP status code for the request
+     */
+    public int getRequestStatusCode() {
+        return requestStatusCode;
+    }
+
+    /**
+     * Returns the error code returned from Facebook.
+     *
+     * @return the error code returned from Facebook
+     */
+    public int getErrorCode() {
+        return errorCode;
+    }
+
+    /**
+     * Returns the sub-error code returned from Facebook.
+     *
+     * @return the sub-error code returned from Facebook
+     */
+    public int getSubErrorCode() {
+        return subErrorCode;
+    }
+
+    /**
+     * Returns the type of error as a raw string. This is generally less useful
+     * than using the {@link #getCategory()} method, but can provide further details
+     * on the error.
+     *
+     * @return the type of error as a raw string
+     */
+    public String getErrorType() {
+        return errorType;
+    }
+
+    /**
+     * Returns the error message returned from Facebook.
+     *
+     * @return the error message returned from Facebook
+     */
+    public String getErrorMessage() {
+        if (errorMessage != null) {
+            return errorMessage;
+        } else {
+            return exception.getLocalizedMessage();
+        }
+    }
+
+    /**
+     * Returns the body portion of the response corresponding to the request from Facebook.
+     *
+     * @return the body of the response for the request
+     */
+    public JSONObject getRequestResultBody() {
+        return requestResultBody;
+    }
+
+    /**
+     * Returns the full JSON response for the corresponding request. In a non-batch request,
+     * this would be the raw response in the form of a JSON object. In a batch request, this
+     * result will contain the body of the response as well as the HTTP headers that pertain
+     * to the specific request (in the form of a "headers" JSONArray).
+     *
+     * @return the full JSON response for the request
+     */
+    public JSONObject getRequestResult() {
+        return requestResult;
+    }
+
+    /**
+     * Returns the full JSON response for the batch request. If the request was not a batch
+     * request, then the result from this method is the same as {@link #getRequestResult()}.
+     * In case of a batch request, the result will be a JSONArray where the elements
+     * correspond to the requests in the batch. Callers should check the return type against
+     * either JSONObject or JSONArray and cast accordingly.
+     *
+     * @return the full JSON response for the batch
+     */
+    public Object getBatchRequestResult() {
+        return batchRequestResult;
+    }
+
+    /**
+     * Returns the HTTP connection that was used to make the request.
+     *
+     * @return the HTTP connection used to make the request
+     */
+    public HttpURLConnection getConnection() {
+        return connection;
+    }
+
+    /**
+     * Returns the exception associated with this request, if any.
+     *
+     * @return the exception associated with this request
+     */
+    public FuntownException getException() {
+        return exception;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder("{HttpStatus: ")
+                .append(requestStatusCode)
+                .append(", errorCode: ")
+                .append(errorCode)
+                .append(", errorType: ")
+                .append(errorType)
+                .append(", errorMessage: ")
+                .append(errorMessage)
+                .append("}")
+                .toString();
+    }
+
+    static FuntownRequestError checkResponseAndCreateError(JSONObject singleResult,
+            Object batchResult, HttpURLConnection connection) {
+        try {
+            if (singleResult.has(CODE_KEY)) {
+                int responseCode = singleResult.getInt(CODE_KEY);
+                Object body = Utility.getStringPropertyAsJSON(singleResult, BODY_KEY,
+                        Response.NON_JSON_RESPONSE_PROPERTY);
+
+                if (body != null && body instanceof JSONObject) {
+                    JSONObject jsonBody = (JSONObject) body;
+                    // Does this response represent an error from the service? We might get either an "error"
+                    // with several sub-properties, or else one or more top-level fields containing error info.
+                    String errorType = null;
+                    String errorMessage = null;
+                    int errorCode = INVALID_ERROR_CODE;
+                    int errorSubCode = INVALID_ERROR_CODE;
+
+                    boolean hasError = false;
+                    if (jsonBody.has(ERROR_KEY)) {
+                        // We assume the error object is correctly formatted.
+                        JSONObject error = (JSONObject) Utility.getStringPropertyAsJSON(jsonBody, ERROR_KEY, null);
+
+                        errorType = error.optString(ERROR_TYPE_FIELD_KEY, null);
+                        errorMessage = error.optString(ERROR_MESSAGE_FIELD_KEY, null);
+                        errorCode = error.optInt(ERROR_CODE_FIELD_KEY, INVALID_ERROR_CODE);
+                        errorSubCode = error.optInt(ERROR_SUB_CODE_KEY, INVALID_ERROR_CODE);
+                        hasError = true;
+                    } else if (jsonBody.has(ERROR_CODE_KEY) || jsonBody.has(ERROR_MSG_KEY)
+                            || jsonBody.has(ERROR_REASON_KEY)) {
+                        errorType = jsonBody.optString(ERROR_REASON_KEY, null);
+                        errorMessage = jsonBody.optString(ERROR_MSG_KEY, null);
+                        errorCode = jsonBody.optInt(ERROR_CODE_KEY, INVALID_ERROR_CODE);
+                        errorSubCode = jsonBody.optInt(ERROR_SUB_CODE_KEY, INVALID_ERROR_CODE);
+                        hasError = true;
+                    }
+
+                    if (hasError) {
+                        return new FuntownRequestError(responseCode, errorCode, errorSubCode,
+                                errorType, errorMessage, jsonBody, singleResult, batchResult, connection);
+                    }
+                }
+
+                // If we didn't get error details, but we did get a failure response code, report it.
+                if (!HTTP_RANGE_SUCCESS.contains(responseCode)) {
+                    return new FuntownRequestError(responseCode, INVALID_ERROR_CODE,
+                            INVALID_ERROR_CODE, null, null,
+                            singleResult.has(BODY_KEY) ?
+                                    (JSONObject) Utility.getStringPropertyAsJSON(
+                                            singleResult, BODY_KEY, Response.NON_JSON_RESPONSE_PROPERTY) : null,
+                            singleResult, batchResult, connection);
+                }
+            }
+        } catch (JSONException e) {
+            // defer the throwing of a JSONException to the graph object proxy
+        }
+        return null;
+    }
+
+    /**
+     * An enum that represents the Facebook SDK classification for the error that occurred.
+     */
+    public enum Category {
+        /**
+         * Indicates that the error is authentication related, and that the app should retry
+         * the request after some user action.
+         */
+        AUTHENTICATION_RETRY,
+
+        /**
+         * Indicates that the error is authentication related, and that the app should close
+         * the session and reopen it.
+         */
+        AUTHENTICATION_REOPEN_SESSION,
+
+        /** Indicates that the error is permission related. */
+        PERMISSION,
+
+        /**
+         * Indicates that the error implies the server had an unexpected failure or may be
+         * temporarily unavailable.
+         */
+        SERVER,
+
+        /** Indicates that the error results from the server throttling the client. */
+        THROTTLING,
+
+        /**
+         * Indicates that the error is Facebook-related but cannot be categorized at this time,
+         * and is likely newer than the current version of the SDK.
+         */
+        OTHER,
+
+        /**
+         * Indicates that the error is an application error resulting in a bad or malformed
+         * request to the server.
+         */
+        BAD_REQUEST,
+
+        /**
+         * Indicates that this is a client-side error. Examples of this can include, but are
+         * not limited to, JSON parsing errors or {@link java.io.IOException}s.
+         */
+        CLIENT
+    };
+
+}
\ No newline at end of file
diff --git a/funtown/src/tw/com/funtown/FuntownSdkVersion.java b/funtown/src/tw/com/funtown/FuntownSdkVersion.java
new file mode 100644
index 000000000..87e34901a
--- /dev/null
+++ b/funtown/src/tw/com/funtown/FuntownSdkVersion.java
@@ -0,0 +1,7 @@
+package tw.com.funtown;
+
+final class FuntownSdkVersion {
+    public static final String BUILD = "3.0.0";
+    public static final String MIGRATION_BUNDLE = "fbsdk:20121026";
+}
+
diff --git a/funtown/src/tw/com/funtown/FuntownServiceException.java b/funtown/src/tw/com/funtown/FuntownServiceException.java
new file mode 100644
index 000000000..6f5a23426
--- /dev/null
+++ b/funtown/src/tw/com/funtown/FuntownServiceException.java
@@ -0,0 +1,63 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+/**
+ * Represents an error returned from the Facebook service in response to a request.
+ */
+public class FuntownServiceException extends FuntownException {
+
+    private final FuntownRequestError error;
+
+    private static final long serialVersionUID = 1;
+
+    /**
+     * Constructs a new FacebookServiceException.
+     *
+     * @param error the error from the request
+     */
+    public FuntownServiceException(FuntownRequestError error, String errorMessage) {
+        super(errorMessage);
+        this.error = error;
+    }
+
+    /**
+     * Returns an object that encapsulates complete information representing the error returned by Facebook.
+     *
+     * @return complete information representing the error.
+     */
+    public final FuntownRequestError getRequestError() {
+        return error;
+    }
+
+    @Override
+    public final String toString() {
+        return new StringBuilder()
+                .append("{FacebookServiceException: ")
+                .append("httpResponseCode: ")
+                .append(error.getRequestStatusCode())
+                .append(", facebookErrorCode: ")
+                .append(error.getErrorCode())
+                .append(", facebookErrorType: ")
+                .append(error.getErrorType())
+                .append(", message: ")
+                .append(error.getErrorMessage())
+                .append("}")
+                .toString();
+    }
+
+}
diff --git a/funtown/src/tw/com/funtown/GetTokenClient.java b/funtown/src/tw/com/funtown/GetTokenClient.java
new file mode 100644
index 000000000..bbd98dbed
--- /dev/null
+++ b/funtown/src/tw/com/funtown/GetTokenClient.java
@@ -0,0 +1,128 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.*;
+
+final class GetTokenClient implements ServiceConnection {
+    final Context context;
+    final String applicationId;
+    final Handler handler;
+    CompletedListener listener;
+    boolean running;
+    Messenger sender;
+
+    GetTokenClient(Context context, String applicationId) {
+        Context applicationContext = context.getApplicationContext();
+
+        this.context = (applicationContext != null) ? applicationContext : context;
+        this.applicationId = applicationId;
+
+        handler = new Handler() {
+            @Override
+            public void handleMessage(Message message) {
+                GetTokenClient.this.handleMessage(message);
+            }
+        };
+    }
+
+    void setCompletedListener(CompletedListener listener) {
+        this.listener = listener;
+    }
+
+    boolean start() {
+        Intent intent = new Intent(NativeProtocol.INTENT_ACTION_PLATFORM_SERVICE);
+        intent.addCategory(Intent.CATEGORY_DEFAULT);
+        intent = NativeProtocol.validateKatanaServiceIntent(context, intent);
+
+        if (intent == null) {
+            callback(null);
+            return false;
+        } else {
+            running = true;
+            context.bindService(intent, this, Context.BIND_AUTO_CREATE);
+            return true;
+        }
+    }
+
+    void cancel() {
+        running = false;
+    }
+
+    @Override
+    public void onServiceConnected(ComponentName name, IBinder service) {
+        sender = new Messenger(service);
+        getToken();
+    }
+
+    @Override
+    public void onServiceDisconnected(ComponentName name) {
+        sender = null;
+        context.unbindService(this);
+        callback(null);
+    }
+
+    private void getToken() {
+        Bundle data = new Bundle();
+        data.putString(NativeProtocol.EXTRA_APPLICATION_ID, applicationId);
+
+        Message request = Message.obtain(null, NativeProtocol.MESSAGE_GET_ACCESS_TOKEN_REQUEST);
+        request.arg1 = NativeProtocol.PROTOCOL_VERSION_20121101;
+        request.setData(data);
+        request.replyTo = new Messenger(handler);
+
+        try {
+            sender.send(request);
+        } catch (RemoteException e) {
+            callback(null);
+        }
+    }
+
+    private void handleMessage(Message message) {
+        if (message.what == NativeProtocol.MESSAGE_GET_ACCESS_TOKEN_REPLY) {
+            Bundle extras = message.getData();
+            String errorType = extras.getString(NativeProtocol.STATUS_ERROR_TYPE);
+            if (errorType != null) {
+                callback(null);
+            } else {
+                callback(extras);
+            }
+            context.unbindService(this);
+        }
+    }
+
+    private void callback(Bundle result) {
+        if (!running) {
+            return;
+        }
+        running = false;
+
+        CompletedListener callback = listener;
+        if (callback != null) {
+            callback.completed(result);
+        }
+    }
+
+    interface CompletedListener {
+        void completed(Bundle result);
+    }
+}
diff --git a/funtown/src/tw/com/funtown/HttpMethod.java b/funtown/src/tw/com/funtown/HttpMethod.java
new file mode 100644
index 000000000..8a8b0b8c7
--- /dev/null
+++ b/funtown/src/tw/com/funtown/HttpMethod.java
@@ -0,0 +1,37 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+/**
+ * Enumeration of HTTP methods supported by Request
+ */
+public enum HttpMethod {
+    /**
+     * Use HTTP method "GET" for the request
+     */
+    GET,
+
+    /**
+     * Use HTTP method "POST" for the request
+     */
+    POST,
+
+    /**
+     * Use HTTP method "DELETE" for the request
+     */
+    DELETE,
+}
diff --git a/funtown/src/tw/com/funtown/LoggingBehavior.java b/funtown/src/tw/com/funtown/LoggingBehavior.java
new file mode 100644
index 000000000..bd63ff3c6
--- /dev/null
+++ b/funtown/src/tw/com/funtown/LoggingBehavior.java
@@ -0,0 +1,45 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+/**
+ * Specifies different categories of logging messages that can be generated.
+ *
+ * @see Settings#addLoggingBehavior(LoggingBehavior)
+ */
+public enum LoggingBehavior {
+    /**
+     * Indicates that HTTP requests and a summary of responses should be logged.
+     */
+    REQUESTS,
+    /**
+     * Indicates that access tokens should be logged as part of the request logging; normally they are not.
+     */
+    INCLUDE_ACCESS_TOKENS,
+    /**
+     * Indicates that the entire raw HTTP response for each request should be logged.
+     */
+    INCLUDE_RAW_RESPONSES,
+    /**
+     * Indicates that cache operations should be logged.
+     */
+    CACHE,
+    /**
+     * Indicates that likely developer errors should be logged.  (This is set by default in LoggingBehavior.)
+     */
+    DEVELOPER_ERRORS
+}
diff --git a/funtown/src/tw/com/funtown/LoginActivity.java b/funtown/src/tw/com/funtown/LoginActivity.java
new file mode 100644
index 000000000..ba4ab1675
--- /dev/null
+++ b/funtown/src/tw/com/funtown/LoginActivity.java
@@ -0,0 +1,142 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import com.facebook.android.R;
+
+/**
+ * This Activity is a necessary part of the overall Facebook login process
+ * but is not meant to be used directly. Add this activity to your
+ * AndroidManifest.xml to ensure proper handling of Facebook login.
+ * <pre>
+ * {@code
+ * <activity android:name="com.facebook.LoginActivity"
+ *           android:theme="@android:style/Theme.Translucent.NoTitleBar"
+ *           android:label="@string/app_name" />
+ * }
+ * </pre>
+ * Do not start this activity directly.
+ */
+public class LoginActivity extends Activity {
+    static final String RESULT_KEY = "com.facebook.LoginActivity:Result";
+
+    private static final String NULL_CALLING_PKG_ERROR_MSG =
+            "Cannot call LoginActivity with a null calling package. " +
+                    "This can occur if the launchMode of the caller is singleInstance.";
+    private static final String SAVED_CALLING_PKG_KEY = "callingPackage";
+    private static final String SAVED_AUTH_CLIENT = "authorizationClient";
+    private static final String EXTRA_REQUEST = "request";
+
+    private String callingPackage;
+    private AuthorizationClient authorizationClient;
+    private AuthorizationClient.AuthorizationRequest request;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.com_facebook_login_activity_layout);
+
+        if (savedInstanceState != null) {
+            callingPackage = savedInstanceState.getString(SAVED_CALLING_PKG_KEY);
+            authorizationClient = (AuthorizationClient) savedInstanceState.getSerializable(SAVED_AUTH_CLIENT);
+        } else {
+            callingPackage = getCallingPackage();
+            authorizationClient = new AuthorizationClient();
+            request = (AuthorizationClient.AuthorizationRequest) getIntent().getSerializableExtra(EXTRA_REQUEST);
+        }
+
+        authorizationClient.setContext(this);
+        authorizationClient.setOnCompletedListener(new AuthorizationClient.OnCompletedListener() {
+            @Override
+            public void onCompleted(AuthorizationClient.Result outcome) {
+                onAuthClientCompleted(outcome);
+            }
+        });
+        authorizationClient.setBackgroundProcessingListener(new AuthorizationClient.BackgroundProcessingListener() {
+            @Override
+            public void onBackgroundProcessingStarted() {
+                findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.VISIBLE);
+            }
+
+            @Override
+            public void onBackgroundProcessingStopped() {
+                findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.GONE);
+            }
+        });
+    }
+
+    private void onAuthClientCompleted(AuthorizationClient.Result outcome) {
+        request = null;
+
+        int resultCode = (outcome.code == AuthorizationClient.Result.Code.CANCEL) ?
+                RESULT_CANCELED : RESULT_OK;
+
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(RESULT_KEY, outcome);
+
+        Intent resultIntent = new Intent();
+        resultIntent.putExtras(bundle);
+        setResult(resultCode, resultIntent);
+
+        finish();
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+
+        // If the calling package is null, this generally means that the callee was started
+        // with a launchMode of singleInstance. Unfortunately, Android does not allow a result
+        // to be set when the callee is a singleInstance, so we throw an exception here.
+        if (callingPackage == null) {
+            throw new FuntownException(NULL_CALLING_PKG_ERROR_MSG);
+        }
+
+        authorizationClient.startOrContinueAuth(request);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+
+        authorizationClient.cancelCurrentHandler();
+        findViewById(R.id.com_facebook_login_activity_progress_bar).setVisibility(View.GONE);
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        outState.putString(SAVED_CALLING_PKG_KEY, callingPackage);
+        outState.putSerializable(SAVED_AUTH_CLIENT, authorizationClient);
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        authorizationClient.onActivityResult(requestCode, resultCode, data);
+    }
+
+    static Bundle populateIntentExtras(AuthorizationClient.AuthorizationRequest request) {
+        Bundle extras = new Bundle();
+        extras.putSerializable(EXTRA_REQUEST, request);
+        return extras;
+    }
+}
diff --git a/funtown/src/tw/com/funtown/NativeProtocol.java b/funtown/src/tw/com/funtown/NativeProtocol.java
new file mode 100644
index 000000000..4982a21ea
--- /dev/null
+++ b/funtown/src/tw/com/funtown/NativeProtocol.java
@@ -0,0 +1,254 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.pm.Signature;
+import android.os.Bundle;
+import android.text.TextUtils;
+import com.facebook.internal.Utility;
+
+import java.util.ArrayList;
+import java.util.List;
+
+final class NativeProtocol {
+    static final String KATANA_PACKAGE = "com.facebook.katana";
+    static final String KATANA_PROXY_AUTH_ACTIVITY = "com.facebook.katana.ProxyAuth";
+    static final String KATANA_TOKEN_REFRESH_ACTIVITY = "com.facebook.katana.platform.TokenRefreshService";
+    static final String KATANA_SIGNATURE =
+            "30820268308201d102044a9c4610300d06092a864886f70d0101040500307a310"
+                    + "b3009060355040613025553310b30090603550408130243413112301006035504"
+                    + "07130950616c6f20416c746f31183016060355040a130f46616365626f6f6b204"
+                    + "d6f62696c653111300f060355040b130846616365626f6f6b311d301b06035504"
+                    + "03131446616365626f6f6b20436f72706f726174696f6e3020170d30393038333"
+                    + "13231353231365a180f32303530303932353231353231365a307a310b30090603"
+                    + "55040613025553310b30090603550408130243413112301006035504071309506"
+                    + "16c6f20416c746f31183016060355040a130f46616365626f6f6b204d6f62696c"
+                    + "653111300f060355040b130846616365626f6f6b311d301b06035504031314466"
+                    + "16365626f6f6b20436f72706f726174696f6e30819f300d06092a864886f70d01"
+                    + "0101050003818d0030818902818100c207d51df8eb8c97d93ba0c8c1002c928fa"
+                    + "b00dc1b42fca5e66e99cc3023ed2d214d822bc59e8e35ddcf5f44c7ae8ade50d7"
+                    + "e0c434f500e6c131f4a2834f987fc46406115de2018ebbb0d5a3c261bd97581cc"
+                    + "fef76afc7135a6d59e8855ecd7eacc8f8737e794c60a761c536b72b11fac8e603"
+                    + "f5da1a2d54aa103b8a13c0dbc10203010001300d06092a864886f70d010104050"
+                    + "0038181005ee9be8bcbb250648d3b741290a82a1c9dc2e76a0af2f2228f1d9f9c"
+                    + "4007529c446a70175c5a900d5141812866db46be6559e2141616483998211f4a6"
+                    + "73149fb2232a10d247663b26a9031e15f84bc1c74d141ff98a02d76f85b2c8ab2"
+                    + "571b6469b232d8e768a7f7ca04f7abe4a775615916c07940656b58717457b42bd"
+                    + "928a2";
+    private static final String BASIC_INFO = "basic_info";
+    public static final String KATANA_PROXY_AUTH_PERMISSIONS_KEY = "scope";
+    public static final String KATANA_PROXY_AUTH_APP_ID_KEY = "client_id";
+
+    static final boolean validateSignature(Context context, String packageName) {
+        PackageInfo packageInfo = null;
+        try {
+            packageInfo = context.getPackageManager().getPackageInfo(packageName,
+                    PackageManager.GET_SIGNATURES);
+        } catch (PackageManager.NameNotFoundException e) {
+            return false;
+        }
+
+        for (Signature signature : packageInfo.signatures) {
+            if (signature.toCharsString().equals(KATANA_SIGNATURE)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    static Intent validateKatanaActivityIntent(Context context, Intent intent) {
+        if (intent == null) {
+            return null;
+        }
+
+        ResolveInfo resolveInfo = context.getPackageManager().resolveActivity(intent, 0);
+        if (resolveInfo == null) {
+            return null;
+        }
+
+        if (!validateSignature(context, resolveInfo.activityInfo.packageName)) {
+            return null;
+        }
+
+        return intent;
+    }
+
+    static Intent validateKatanaServiceIntent(Context context, Intent intent) {
+        if (intent == null) {
+            return null;
+        }
+
+        ResolveInfo resolveInfo = context.getPackageManager().resolveService(intent, 0);
+        if (resolveInfo == null) {
+            return null;
+        }
+
+        if (!validateSignature(context, resolveInfo.serviceInfo.packageName)) {
+            return null;
+        }
+
+        return intent;
+    }
+
+    static Intent createProxyAuthIntent(Context context, String applicationId, List<String> permissions) {
+        Intent intent = new Intent()
+                .setClassName(KATANA_PACKAGE, KATANA_PROXY_AUTH_ACTIVITY)
+                .putExtra(KATANA_PROXY_AUTH_APP_ID_KEY, applicationId);
+
+        if (!Utility.isNullOrEmpty(permissions)) {
+            intent.putExtra(KATANA_PROXY_AUTH_PERMISSIONS_KEY, TextUtils.join(",", permissions));
+        }
+
+        return validateKatanaActivityIntent(context, intent);
+    }
+
+    static Intent createTokenRefreshIntent(Context context) {
+        Intent intent = new Intent();
+        intent.setClassName(KATANA_PACKAGE, KATANA_TOKEN_REFRESH_ACTIVITY);
+
+        return validateKatanaServiceIntent(context, intent);
+    }
+
+    // ---------------------------------------------------------------------------------------------
+    // Native Protocol updated 2012-11
+
+    static final String INTENT_ACTION_PLATFORM_ACTIVITY = "com.facebook.platform.PLATFORM_ACTIVITY";
+    static final String INTENT_ACTION_PLATFORM_SERVICE = "com.facebook.platform.PLATFORM_SERVICE";
+
+    static final int PROTOCOL_VERSION_20121101 = 20121101;
+    static final String EXTRA_PROTOCOL_VERSION = "com.facebook.platform.protocol.PROTOCOL_VERSION";
+    static final String EXTRA_PROTOCOL_ACTION = "com.facebook.platform.protocol.PROTOCOL_ACTION";
+
+    // Messages supported by PlatformService:
+    static final int MESSAGE_GET_ACCESS_TOKEN_REQUEST = 0x10000;
+    static final int MESSAGE_GET_ACCESS_TOKEN_REPLY   = 0x10001;
+
+    // MESSAGE_ERROR_REPLY data keys:
+    // See STATUS_*
+
+    // MESSAGE_GET_ACCESS_TOKEN_REQUEST data keys:
+    // EXTRA_APPLICATION_ID
+
+    // MESSAGE_GET_ACCESS_TOKEN_REPLY data keys:
+    // EXTRA_ACCESS_TOKEN
+    // EXTRA_EXPIRES_SECONDS_SINCE_EPOCH
+    // EXTRA_PERMISSIONS
+
+    // Values of EXTRA_PROTOCOL_ACTION supported by PlatformActivity:
+    static final String ACTION_LOGIN_DIALOG = "com.facebook.platform.action.request.LOGIN_DIALOG";
+
+    // Values of EXTRA_PROTOCOL_ACTION values returned by PlatformActivity:
+    static final String ACTION_LOGIN_DIALOG_REPLY =
+            "com.facebook.platform.action.reply.LOGIN_DIALOG";
+
+    // Extras supported for ACTION_LOGIN_DIALOG:
+    static final String EXTRA_PERMISSIONS = "com.facebook.platform.extra.PERMISSIONS";
+    static final String EXTRA_WRITE_PRIVACY = "com.facebook.platform.extra.WRITE_PRIVACY";
+    static final String EXTRA_APPLICATION_ID = "com.facebook.platform.extra.APPLICATION_ID";
+
+    // Extras returned by setResult() for ACTION_LOGIN_DIALOG
+    static final String EXTRA_ACCESS_TOKEN = "com.facebook.platform.extra.ACCESS_TOKEN";
+    static final String EXTRA_EXPIRES_SECONDS_SINCE_EPOCH =
+            "com.facebook.platform.extra.EXPIRES_SECONDS_SINCE_EPOCH";
+    // EXTRA_PERMISSIONS
+
+    // Keys for status data in MESSAGE_ERROR_REPLY from PlatformService and for error
+    // extras returned by PlatformActivity's setResult() in case of errors:
+    static final String STATUS_ERROR_TYPE = "com.facebook.platform.status.ERROR_TYPE";
+    static final String STATUS_ERROR_DESCRIPTION =
+            "com.facebook.platform.status.ERROR_DESCRIPTION";
+    static final String STATUS_ERROR_CODE = "com.facebook.platform.status.ERROR_CODE";
+    static final String STATUS_ERROR_SUBCODE = "com.facebook.platform.status.ERROR_SUBCODE";
+    static final String STATUS_ERROR_JSON = "com.facebook.platform.status.ERROR_JSON";
+
+    // Expected values for ERROR_KEY_TYPE.  Clients should tolerate other values:
+    static final String ERROR_UNKNOWN_ERROR = "UnknownError";
+    static final String ERROR_PROTOCOL_ERROR = "ProtocolError";
+    static final String ERROR_USER_CANCELED = "UserCanceled";
+    static final String ERROR_APPLICATION_ERROR = "ApplicationError";
+    static final String ERROR_NETWORK_ERROR = "NetworkError";
+    static final String ERROR_PERMISSION_DENIED = "PermissionDenied";
+    static final String ERROR_SERVICE_DISABLED = "ServiceDisabled";
+
+    static final String AUDIENCE_ME = "SELF";
+    static final String AUDIENCE_FRIENDS = "ALL_FRIENDS";
+    static final String AUDIENCE_EVERYONE = "EVERYONE";
+
+    static Intent createLoginDialog20121101Intent(Context context, String applicationId, ArrayList<String> permissions,
+            String audience) {
+        Intent intent = new Intent()
+                    .setAction(INTENT_ACTION_PLATFORM_ACTIVITY)
+                    .addCategory(Intent.CATEGORY_DEFAULT)
+                    .putExtra(EXTRA_PROTOCOL_VERSION, PROTOCOL_VERSION_20121101)
+                    .putExtra(EXTRA_PROTOCOL_ACTION, ACTION_LOGIN_DIALOG)
+                    .putExtra(EXTRA_APPLICATION_ID, applicationId)
+                    .putStringArrayListExtra(EXTRA_PERMISSIONS, ensureDefaultPermissions(permissions))
+                    .putExtra(EXTRA_WRITE_PRIVACY, ensureDefaultAudience(audience));
+        return validateKatanaActivityIntent(context, intent);
+    }
+
+    private static String ensureDefaultAudience(String audience) {
+        if (Utility.isNullOrEmpty(audience)) {
+            return AUDIENCE_ME;
+        } else {
+            return audience;
+        }
+    }
+
+    private static ArrayList<String> ensureDefaultPermissions(ArrayList<String> permissions) {
+        ArrayList<String> updated;
+
+        // Return if we are doing publish, or if basic_info is already included
+        if (Utility.isNullOrEmpty(permissions)) {
+            updated = new ArrayList<String>();
+        } else {
+            for (String permission : permissions) {
+                if (Session.isPublishPermission(permission) || BASIC_INFO.equals(permission)) {
+                    return permissions;
+                }
+            }
+            updated = new ArrayList<String>(permissions);
+        }
+
+        updated.add(BASIC_INFO);
+        return updated;
+    }
+
+    static boolean isServiceDisabledResult20121101(Intent data) {
+        int protocolVersion = data.getIntExtra(EXTRA_PROTOCOL_VERSION, 0);
+        String errorType = data.getStringExtra(STATUS_ERROR_TYPE);
+
+        return ((PROTOCOL_VERSION_20121101 == protocolVersion) && ERROR_SERVICE_DISABLED.equals(errorType));
+    }
+
+    static AccessTokenSource getAccessTokenSourceFromNative(Bundle extras) {
+        long expected = PROTOCOL_VERSION_20121101;
+        long actual = extras.getInt(EXTRA_PROTOCOL_VERSION, 0);
+
+        if (expected == actual) {
+            return AccessTokenSource.FACEBOOK_APPLICATION_NATIVE;
+        } else {
+            return AccessTokenSource.FACEBOOK_APPLICATION_WEB;
+        }
+    }
+}
diff --git a/funtown/src/tw/com/funtown/NonCachingTokenCachingStrategy.java b/funtown/src/tw/com/funtown/NonCachingTokenCachingStrategy.java
new file mode 100644
index 000000000..cebebf32b
--- /dev/null
+++ b/funtown/src/tw/com/funtown/NonCachingTokenCachingStrategy.java
@@ -0,0 +1,39 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+import android.os.Bundle;
+
+/**
+ * Implements a trivial {@link TokenCachingStrategy} that does not actually cache any tokens.
+ * It is intended for use when an access token may be used on a temporary basis but should not be
+ * cached for future use (for instance, when handling a deep link).
+ */
+public class NonCachingTokenCachingStrategy extends TokenCachingStrategy {
+    @Override
+    public Bundle load() {
+        return null;
+    }
+
+    @Override
+    public void save(Bundle bundle) {
+    }
+
+    @Override
+    public void clear() {
+    }
+}
diff --git a/funtown/src/tw/com/funtown/Request.java b/funtown/src/tw/com/funtown/Request.java
new file mode 100644
index 000000000..d28615b2a
--- /dev/null
+++ b/funtown/src/tw/com/funtown/Request.java
@@ -0,0 +1,1823 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+import android.graphics.Bitmap;
+import android.location.Location;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.ParcelFileDescriptor;
+import android.text.TextUtils;
+import android.util.Pair;
+import com.facebook.model.*;
+import tw.com.funtown.internal.ServerProtocol;
+import tw.com.funtown.internal.Logger;
+import tw.com.funtown.internal.Utility;
+import tw.com.funtown.internal.Validate;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.*;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.text.SimpleDateFormat;
+import java.util.*;
+import java.util.Map.Entry;
+
+/**
+ * A single request to be sent to the Facebook Platform through either the <a
+ * href="https://developers.facebook.com/docs/reference/api/">Graph API</a> or <a
+ * href="https://developers.facebook.com/docs/reference/rest/">REST API</a>. The Request class provides functionality
+ * relating to serializing and deserializing requests and responses, making calls in batches (with a single round-trip
+ * to the service) and making calls asynchronously.
+ *
+ * The particular service endpoint that a request targets is determined by either a graph path (see the
+ * {@link #setGraphPath(String) setGraphPath} method) or a REST method name (see the {@link #setRestMethod(String)
+ * setRestMethod} method); a single request may not target both.
+ *
+ * A Request can be executed either anonymously or representing an authenticated user. In the former case, no Session
+ * needs to be specified, while in the latter, a Session that is in an opened state must be provided. If requests are
+ * executed in a batch, a Facebook application ID must be associated with the batch, either by supplying a Session for
+ * at least one of the requests in the batch (the first one found in the batch will be used) or by calling the
+ * {@link #setDefaultBatchApplicationId(String) setDefaultBatchApplicationId} method.
+ *
+ * After completion of a request, its Session, if any, will be checked to determine if its Facebook access token needs
+ * to be extended; if so, a request to extend it will be issued in the background.
+ */
+public class Request {
+    /**
+     * The maximum number of requests that can be submitted in a single batch. This limit is enforced on the service
+     * side by the Facebook platform, not by the Request class.
+     */
+    public static final int MAXIMUM_BATCH_SIZE = 50;
+
+    private static final String ME = "me";
+    private static final String MY_FRIENDS = "me/friends";
+    private static final String MY_PHOTOS = "me/photos";
+    private static final String MY_VIDEOS = "me/videos";
+    private static final String SEARCH = "search";
+    private static final String MY_FEED = "me/feed";
+
+    private static final String USER_AGENT_BASE = "FBAndroidSDK";
+    private static final String USER_AGENT_HEADER = "User-Agent";
+    private static final String CONTENT_TYPE_HEADER = "Content-Type";
+
+    // Parameter names/values
+    private static final String PICTURE_PARAM = "picture";
+    private static final String FORMAT_PARAM = "format";
+    private static final String FORMAT_JSON = "json";
+    private static final String SDK_PARAM = "sdk";
+    private static final String SDK_ANDROID = "android";
+    private static final String ACCESS_TOKEN_PARAM = "access_token";
+    private static final String BATCH_ENTRY_NAME_PARAM = "name";
+    private static final String BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM = "omit_response_on_success";
+    private static final String BATCH_ENTRY_DEPENDS_ON_PARAM = "depends_on";
+    private static final String BATCH_APP_ID_PARAM = "batch_app_id";
+    private static final String BATCH_RELATIVE_URL_PARAM = "relative_url";
+    private static final String BATCH_BODY_PARAM = "body";
+    private static final String BATCH_METHOD_PARAM = "method";
+    private static final String BATCH_PARAM = "batch";
+    private static final String ATTACHMENT_FILENAME_PREFIX = "file";
+    private static final String ATTACHED_FILES_PARAM = "attached_files";
+    private static final String MIGRATION_BUNDLE_PARAM = "migration_bundle";
+    private static final String ISO_8601_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ssZ";
+
+    private static final String MIME_BOUNDARY = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f";
+
+    private static String defaultBatchApplicationId;
+
+    private Session session;
+    private HttpMethod httpMethod;
+    private String graphPath;
+    private GraphObject graphObject;
+    private String restMethod;
+    private String batchEntryName;
+    private String batchEntryDependsOn;
+    private boolean batchEntryOmitResultOnSuccess = true;
+    private Bundle parameters;
+    private Callback callback;
+    private String overriddenURL;
+
+    /**
+     * Constructs a request without a session, graph path, or any other parameters.
+     */
+    public Request() {
+        this(null, null, null, null, null);
+    }
+
+    /**
+     * Constructs a request with a Session to retrieve a particular graph path. A Session need not be provided, in which
+     * case the request is sent without an access token and thus is not executed in the context of any particular user.
+     * Only certain graph requests can be expected to succeed in this case. If a Session is provided, it must be in an
+     * opened state or the request will fail.
+     *
+     * @param session
+     *            the Session to use, or null
+     * @param graphPath
+     *            the graph path to retrieve
+     */
+    public Request(Session session, String graphPath) {
+        this(session, graphPath, null, null, null);
+    }
+
+    /**
+     * Constructs a request with a specific Session, graph path, parameters, and HTTP method. A Session need not be
+     * provided, in which case the request is sent without an access token and thus is not executed in the context of
+     * any particular user. Only certain graph requests can be expected to succeed in this case. If a Session is
+     * provided, it must be in an opened state or the request will fail.
+     *
+     * Depending on the httpMethod parameter, the object at the graph path may be retrieved, created, or deleted.
+     *
+     * @param session
+     *            the Session to use, or null
+     * @param graphPath
+     *            the graph path to retrieve, create, or delete
+     * @param parameters
+     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
+     *            Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod
+     *            the {@link HttpMethod} to use for the request, or null for default (HttpMethod.GET)
+     */
+    public Request(Session session, String graphPath, Bundle parameters, HttpMethod httpMethod) {
+        this(session, graphPath, parameters, httpMethod, null);
+    }
+
+    /**
+     * Constructs a request with a specific Session, graph path, parameters, and HTTP method. A Session need not be
+     * provided, in which case the request is sent without an access token and thus is not executed in the context of
+     * any particular user. Only certain graph requests can be expected to succeed in this case. If a Session is
+     * provided, it must be in an opened state or the request will fail.
+     *
+     * Depending on the httpMethod parameter, the object at the graph path may be retrieved, created, or deleted.
+     *
+     * @param session
+     *            the Session to use, or null
+     * @param graphPath
+     *            the graph path to retrieve, create, or delete
+     * @param parameters
+     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
+     *            Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod
+     *            the {@link HttpMethod} to use for the request, or null for default (HttpMethod.GET)
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     */
+    public Request(Session session, String graphPath, Bundle parameters, HttpMethod httpMethod, Callback callback) {
+        this.session = session;
+        this.graphPath = graphPath;
+        this.callback = callback;
+
+        setHttpMethod(httpMethod);
+
+        if (parameters != null) {
+            this.parameters = new Bundle(parameters);
+        } else {
+            this.parameters = new Bundle();
+        }
+
+        if (!this.parameters.containsKey(MIGRATION_BUNDLE_PARAM)) {
+            this.parameters.putString(MIGRATION_BUNDLE_PARAM, FuntownSdkVersion.MIGRATION_BUNDLE);
+        }
+    }
+
+    Request(Session session, URL overriddenURL) {
+        this.session = session;
+        this.overriddenURL = overriddenURL.toString();
+
+        setHttpMethod(HttpMethod.GET);
+
+        this.parameters = new Bundle();
+    }
+
+    /**
+     * Creates a new Request configured to post a GraphObject to a particular graph path, to either create or update the
+     * object at that path.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param graphPath
+     *            the graph path to retrieve, create, or delete
+     * @param graphObject
+     *            the GraphObject to create or update
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newPostRequest(Session session, String graphPath, GraphObject graphObject, Callback callback) {
+        Request request = new Request(session, graphPath, null, HttpMethod.POST , callback);
+        request.setGraphObject(graphObject);
+        return request;
+    }
+
+    /**
+     * Creates a new Request configured to make a call to the Facebook REST API.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param restMethod
+     *            the method in the Facebook REST API to execute
+     * @param parameters
+     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
+     *            Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod
+     *            the HTTP method to use for the request; must be one of GET, POST, or DELETE
+     * @return a Request that is ready to execute
+     */
+    public static Request newRestRequest(Session session, String restMethod, Bundle parameters, HttpMethod httpMethod) {
+        Request request = new Request(session, null, parameters, httpMethod);
+        request.setRestMethod(restMethod);
+        return request;
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's own profile.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newMeRequest(Session session, final GraphUserCallback callback) {
+        Callback wrapper = new Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                if (callback != null) {
+                    callback.onCompleted(response.getGraphObjectAs(GraphUser.class), response);
+                }
+            }
+        };
+        return new Request(session, ME, null, null, wrapper);
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's friend list.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newMyFriendsRequest(Session session, final GraphUserListCallback callback) {
+        Callback wrapper = new Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                if (callback != null) {
+                    callback.onCompleted(typedListFromResponse(response, GraphUser.class), response);
+                }
+            }
+        };
+        return new Request(session, MY_FRIENDS, null, null, wrapper);
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param image
+     *            the image to upload
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newUploadPhotoRequest(Session session, Bitmap image, Callback callback) {
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(PICTURE_PARAM, image);
+
+        return new Request(session, MY_PHOTOS, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album. The photo
+     * will be read from the specified stream.
+     *
+     * @param session  the Session to use, or null; if non-null, the session must be in an opened state
+     * @param file     the file containing the photo to upload
+     * @param callback a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newUploadPhotoRequest(Session session, File file,
+            Callback callback) throws FileNotFoundException {
+        ParcelFileDescriptor descriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(PICTURE_PARAM, descriptor);
+
+        return new Request(session, MY_PHOTOS, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album. The photo
+     * will be read from the specified file descriptor.
+     *
+     * @param session  the Session to use, or null; if non-null, the session must be in an opened state
+     * @param file     the file to upload
+     * @param callback a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newUploadVideoRequest(Session session, File file,
+            Callback callback) throws FileNotFoundException {
+        ParcelFileDescriptor descriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+        Bundle parameters = new Bundle(1);
+        parameters.putParcelable(file.getName(), descriptor);
+
+        return new Request(session, MY_VIDEOS, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a particular graph path.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param graphPath
+     *            the graph path to retrieve
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newGraphPathRequest(Session session, String graphPath, Callback callback) {
+        return new Request(session, graphPath, null, null, callback);
+    }
+
+    /**
+     * Creates a new Request that is configured to perform a search for places near a specified location via the Graph
+     * API. At least one of location or searchText must be specified.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param location
+     *            the location around which to search; only the latitude and longitude components of the location are
+     *            meaningful
+     * @param radiusInMeters
+     *            the radius around the location to search, specified in meters; this is ignored if
+     *            no location is specified
+     * @param resultsLimit
+     *            the maximum number of results to return
+     * @param searchText
+     *            optional text to search for as part of the name or type of an object
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     *
+     * @throws FacebookException If neither location nor searchText is specified
+     */
+    public static Request newPlacesSearchRequest(Session session, Location location, int radiusInMeters,
+            int resultsLimit, String searchText, final GraphPlaceListCallback callback) {
+        if (location == null && Utility.isNullOrEmpty(searchText)) {
+            throw new FuntownException("Either location or searchText must be specified.");
+        }
+
+        Bundle parameters = new Bundle(5);
+        parameters.putString("type", "place");
+        parameters.putInt("limit", resultsLimit);
+        if (location != null) {
+            parameters.putString("center",
+                    String.format(Locale.US, "%f,%f", location.getLatitude(), location.getLongitude()));
+            parameters.putInt("distance", radiusInMeters);
+        }
+        if (!Utility.isNullOrEmpty(searchText)) {
+            parameters.putString("q", searchText);
+        }
+
+        Callback wrapper = new Callback() {
+            @Override
+            public void onCompleted(Response response) {
+                if (callback != null) {
+                    callback.onCompleted(typedListFromResponse(response, GraphPlace.class), response);
+                }
+            }
+        };
+
+        return new Request(session, SEARCH, parameters, HttpMethod.GET, wrapper);
+    }
+
+    /**
+     * Creates a new Request configured to post a status update to a user's feed.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param message
+     *            the text of the status update
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a Request that is ready to execute
+     */
+    public static Request newStatusUpdateRequest(Session session, String message, Callback callback) {
+        Bundle parameters = new Bundle();
+        parameters.putString("message", message);
+
+        return new Request(session, MY_FEED, parameters, HttpMethod.POST, callback);
+    }
+
+    /**
+     * Returns the GraphObject, if any, associated with this request.
+     *
+     * @return the GraphObject associated with this requeset, or null if there is none
+     */
+    public final GraphObject getGraphObject() {
+        return this.graphObject;
+    }
+
+    /**
+     * Sets the GraphObject associated with this request. This is meaningful only for POST requests.
+     *
+     * @param graphObject
+     *            the GraphObject to upload along with this request
+     */
+    public final void setGraphObject(GraphObject graphObject) {
+        this.graphObject = graphObject;
+    }
+
+    /**
+     * Returns the graph path of this request, if any.
+     *
+     * @return the graph path of this request, or null if there is none
+     */
+    public final String getGraphPath() {
+        return this.graphPath;
+    }
+
+    /**
+     * Sets the graph path of this request. A graph path may not be set if a REST method has been specified.
+     *
+     * @param graphPath
+     *            the graph path for this request
+     */
+    public final void setGraphPath(String graphPath) {
+        this.graphPath = graphPath;
+    }
+
+    /**
+     * Returns the {@link HttpMethod} to use for this request.
+     *
+     * @return the HttpMethod
+     */
+    public final HttpMethod getHttpMethod() {
+        return this.httpMethod;
+    }
+
+    /**
+     * Sets the {@link HttpMethod} to use for this request.
+     *
+     * @param httpMethod
+     *            the HttpMethod, or null for the default (HttpMethod.GET).
+     */
+    public final void setHttpMethod(HttpMethod httpMethod) {
+        if (overriddenURL != null && httpMethod != HttpMethod.GET) {
+            throw new FuntownException("Can't change HTTP method on request with overridden URL.");
+            }
+        this.httpMethod = (httpMethod != null) ? httpMethod : HttpMethod.GET;
+    }
+
+    /**
+     * Returns the parameters for this request.
+     *
+     * @return the parameters
+     */
+    public final Bundle getParameters() {
+        return this.parameters;
+    }
+
+    /**
+     * Sets the parameters for this request.
+     *
+     * @param parameters
+     *            the parameters
+     */
+    public final void setParameters(Bundle parameters) {
+        this.parameters = parameters;
+    }
+
+    /**
+     * Returns the REST method to call for this request.
+     *
+     * @return the REST method
+     */
+    public final String getRestMethod() {
+        return this.restMethod;
+    }
+
+    /**
+     * Sets the REST method to call for this request. A REST method may not be set if a graph path has been specified.
+     *
+     * @param restMethod
+     *            the REST method to call
+     */
+    public final void setRestMethod(String restMethod) {
+        this.restMethod = restMethod;
+    }
+
+    /**
+     * Returns the Session associated with this request.
+     *
+     * @return the Session associated with this request, or null if none has been specified
+     */
+    public final Session getSession() {
+        return this.session;
+    }
+
+    /**
+     * Sets the Session to use for this request. The Session does not need to be opened at the time it is specified, but
+     * it must be opened by the time the request is executed.
+     *
+     * @param session
+     *            the Session to use for this request
+     */
+    public final void setSession(Session session) {
+        this.session = session;
+    }
+
+    /**
+     * Returns the name of this request's entry in a batched request.
+     *
+     * @return the name of this request's batch entry, or null if none has been specified
+     */
+    public final String getBatchEntryName() {
+        return this.batchEntryName;
+    }
+
+    /**
+     * Sets the name of this request's entry in a batched request. This value is only used if this request is submitted
+     * as part of a batched request. It can be used to specified dependencies between requests. See <a
+     * href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in the Graph API
+     * documentation for more details.
+     *
+     * @param batchEntryName
+     *            the name of this request's entry in a batched request, which must be unique within a particular batch
+     *            of requests
+     */
+    public final void setBatchEntryName(String batchEntryName) {
+        this.batchEntryName = batchEntryName;
+    }
+
+    /**
+     * Returns the name of the request that this request entry explicitly depends on in a batched request.
+     *
+     * @return the name of this request's dependency, or null if none has been specified
+     */
+    public final String getBatchEntryDependsOn() {
+        return this.batchEntryDependsOn;
+    }
+
+    /**
+     * Sets the name of the request entry that this request explicitly depends on in a batched request. This value is
+     * only used if this request is submitted as part of a batched request. It can be used to specified dependencies
+     * between requests. See <a href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in
+     * the Graph API documentation for more details.
+     *
+     * @param batchEntryDependsOn
+     *            the name of the request entry that this entry depends on in a batched request
+     */
+    public final void setBatchEntryDependsOn(String batchEntryDependsOn) {
+        this.batchEntryDependsOn = batchEntryDependsOn;
+    }
+
+
+    /**
+     * Returns whether or not this batch entry will return a response if it is successful. Only applies if another
+     * request entry in the batch specifies this entry as a dependency.
+     *
+     * @return the name of this request's dependency, or null if none has been specified
+     */
+    public final boolean getBatchEntryOmitResultOnSuccess() {
+        return this.batchEntryOmitResultOnSuccess;
+    }
+
+    /**
+     * Sets whether or not this batch entry will return a response if it is successful. Only applies if another
+     * request entry in the batch specifies this entry as a dependency. See
+     * <a href="https://developers.facebook.com/docs/reference/api/batch/">Batch Requests</a> in the Graph API
+     * documentation for more details.
+     *
+     * @param batchEntryOmitResultOnSuccess
+     *            the name of the request entry that this entry depends on in a batched request
+     */
+    public final void setBatchEntryOmitResultOnSuccess(boolean batchEntryOmitResultOnSuccess) {
+        this.batchEntryOmitResultOnSuccess = batchEntryOmitResultOnSuccess;
+    }
+
+    /**
+     * Gets the default Facebook application ID that will be used to submit batched requests if none of those requests
+     * specifies a Session. Batched requests require an application ID, so either at least one request in a batch must
+     * specify a Session or the application ID must be specified explicitly.
+     *
+     * @return the Facebook application ID to use for batched requests if none can be determined
+     */
+    public static final String getDefaultBatchApplicationId() {
+        return Request.defaultBatchApplicationId;
+    }
+
+    /**
+     * Sets the default application ID that will be used to submit batched requests if none of those requests specifies
+     * a Session. Batched requests require an application ID, so either at least one request in a batch must specify a
+     * Session or the application ID must be specified explicitly.
+     *
+     * @param applicationId
+     *            the Facebook application ID to use for batched requests if none can be determined
+     */
+    public static final void setDefaultBatchApplicationId(String applicationId) {
+        Request.defaultBatchApplicationId = applicationId;
+    }
+
+    /**
+     * Returns the callback which will be called when the request finishes.
+     *
+     * @return the callback
+     */
+    public final Callback getCallback() {
+        return callback;
+    }
+
+    /**
+     * Sets the callback which will be called when the request finishes.
+     *
+     * @param callback
+     *            the callback
+     */
+    public final void setCallback(Callback callback) {
+        this.callback = callback;
+    }
+
+    /**
+     * Starts a new Request configured to post a GraphObject to a particular graph path, to either create or update the
+     * object at that path.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param graphPath
+     *            the graph path to retrieve, create, or delete
+     * @param graphObject
+     *            the GraphObject to create or update
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executePostRequestAsync(Session session, String graphPath, GraphObject graphObject,
+            Callback callback) {
+        return newPostRequest(session, graphPath, graphObject, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to make a call to the Facebook REST API.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param restMethod
+     *            the method in the Facebook REST API to execute
+     * @param parameters
+     *            additional parameters to pass along with the Graph API request; parameters must be Strings, Numbers,
+     *            Bitmaps, Dates, or Byte arrays.
+     * @param httpMethod
+     *            the HTTP method to use for the request; must be one of GET, POST, or DELETE
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeRestRequestAsync(Session session, String restMethod, Bundle parameters,
+            HttpMethod httpMethod) {
+        return newRestRequest(session, restMethod, parameters, httpMethod).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's own profile.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeMeRequestAsync(Session session, GraphUserCallback callback) {
+        return newMeRequest(session, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a user's friend list.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeMyFriendsRequestAsync(Session session, GraphUserListCallback callback) {
+        return newMyFriendsRequest(session, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param image
+     *            the image to upload
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeUploadPhotoRequestAsync(Session session, Bitmap image, Callback callback) {
+        return newUploadPhotoRequest(session, image, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to upload a photo to the user's default photo album. The photo
+     * will be read from the specified stream.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session  the Session to use, or null; if non-null, the session must be in an opened state
+     * @param file     the file containing the photo to upload
+     * @param callback a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeUploadPhotoRequestAsync(Session session, File file,
+            Callback callback) throws FileNotFoundException {
+        return newUploadPhotoRequest(session, file, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to retrieve a particular graph path.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param graphPath
+     *            the graph path to retrieve
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeGraphPathRequestAsync(Session session, String graphPath, Callback callback) {
+        return newGraphPathRequest(session, graphPath, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request that is configured to perform a search for places near a specified location via the Graph
+     * API.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param location
+     *            the location around which to search; only the latitude and longitude components of the location are
+     *            meaningful
+     * @param radiusInMeters
+     *            the radius around the location to search, specified in meters
+     * @param resultsLimit
+     *            the maximum number of results to return
+     * @param searchText
+     *            optional text to search for as part of the name or type of an object
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws FacebookException If neither location nor searchText is specified
+     */
+    public static RequestAsyncTask executePlacesSearchRequestAsync(Session session, Location location, int radiusInMeters,
+            int resultsLimit, String searchText, GraphPlaceListCallback callback) {
+        return newPlacesSearchRequest(session, location, radiusInMeters, resultsLimit, searchText, callback).executeAsync();
+    }
+
+    /**
+     * Creates a new Request configured to post a status update to a user's feed.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param session
+     *            the Session to use, or null; if non-null, the session must be in an opened state
+     * @param message
+     *            the text of the status update
+     * @param callback
+     *            a callback that will be called when the request is completed to handle success or error conditions
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeStatusUpdateRequestAsync(Session session, String message, Callback callback) {
+        return newStatusUpdateRequest(session, message, callback).executeAsync();
+    }
+
+    /**
+     * Executes this request and returns the response.
+     * <p/>
+     * This should only be called if you have transitioned off the UI thread.
+     *
+     * @return the Response object representing the results of the request
+     *
+     * @throws FuntownException
+     *            If there was an error in the protocol used to communicate with the service
+     * @throws IllegalArgumentException
+     */
+    public final Response executeAndWait() {
+        return Request.executeAndWait(this);
+    }
+
+    /**
+     * Executes this request and returns the response.
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws IllegalArgumentException
+     */
+    public final RequestAsyncTask executeAsync() {
+        return Request.executeBatchAsync(this);
+    }
+
+    /**
+     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection can be executed
+     * explicitly by the caller.
+     *
+     * @param requests
+     *            one or more Requests to serialize
+     * @return an HttpURLConnection which is ready to execute
+     *
+     * @throws FuntownException
+     *            If any of the requests in the batch are badly constructed or if there are problems
+     *            contacting the service
+     * @throws IllegalArgumentException if the passed in array is zero-length
+     * @throws NullPointerException if the passed in array or any of its contents are null
+     */
+    public static HttpURLConnection toHttpConnection(Request... requests) {
+        return toHttpConnection(Arrays.asList(requests));
+    }
+
+    /**
+     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection can be executed
+     * explicitly by the caller.
+     *
+     * @param requests
+     *            one or more Requests to serialize
+     * @return an HttpURLConnection which is ready to execute
+     *
+     * @throws FuntownException
+     *            If any of the requests in the batch are badly constructed or if there are problems
+     *            contacting the service
+     * @throws IllegalArgumentException if the passed in collection is empty
+     * @throws NullPointerException if the passed in collection or any of its contents are null
+     */
+    public static HttpURLConnection toHttpConnection(Collection<Request> requests) {
+        Validate.notEmptyAndContainsNoNulls(requests, "requests");
+
+        return toHttpConnection(new RequestBatch(requests));
+    }
+
+
+    /**
+     * Serializes one or more requests but does not execute them. The resulting HttpURLConnection can be executed
+     * explicitly by the caller.
+     *
+     * @param requests
+     *            a RequestBatch to serialize
+     * @return an HttpURLConnection which is ready to execute
+     *
+     * @throws FuntownException
+     *            If any of the requests in the batch are badly constructed or if there are problems
+     *            contacting the service
+     * @throws IllegalArgumentException
+     */
+    public static HttpURLConnection toHttpConnection(RequestBatch requests) {
+
+        for (Request request : requests) {
+            request.validate();
+        }
+
+        URL url = null;
+        try {
+            if (requests.size() == 1) {
+                // Single request case.
+                Request request = requests.get(0);
+                // In the non-batch case, the URL we use really is the same one returned by getUrlForSingleRequest.
+                url = new URL(request.getUrlForSingleRequest());
+            } else {
+                // Batch case -- URL is just the graph API base, individual request URLs are serialized
+                // as relative_url parameters within each batch entry.
+                url = new URL(ServerProtocol.GRAPH_URL);
+            }
+        } catch (MalformedURLException e) {
+            throw new FuntownException("could not construct URL for request", e);
+        }
+
+        HttpURLConnection connection;
+        try {
+            connection = createConnection(url);
+
+            serializeToUrlConnection(requests, connection);
+        } catch (IOException e) {
+            throw new FuntownException("could not construct request body", e);
+        } catch (JSONException e) {
+            throw new FuntownException("could not construct request body", e);
+        }
+
+        return connection;
+    }
+
+    /**
+     * Executes a single request on the current thread and returns the response.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param request
+     *            the Request to execute
+     *
+     * @return the Response object representing the results of the request
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static Response executeAndWait(Request request) {
+        List<Response> responses = executeBatchAndWait(request);
+
+        if (responses == null || responses.size() != 1) {
+            throw new FuntownException("invalid state: expected a single response");
+        }
+
+        return responses.get(0);
+    }
+
+    /**
+     * Executes requests on the current thread as a single batch and returns the responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param requests
+     *            the Requests to execute
+     *
+     * @return a list of Response objects representing the results of the requests; responses are returned in the same
+     *         order as the requests were specified.
+     *
+     * @throws NullPointerException
+     *            In case of a null request
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static List<Response> executeBatchAndWait(Request... requests) {
+        Validate.notNull(requests, "requests");
+
+        return executeBatchAndWait(Arrays.asList(requests));
+    }
+
+    /**
+     * Executes requests as a single batch on the current thread and returns the responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param requests
+     *            the Requests to execute
+     *
+     * @return a list of Response objects representing the results of the requests; responses are returned in the same
+     *         order as the requests were specified.
+     *
+     * @throws FuntownException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static List<Response> executeBatchAndWait(Collection<Request> requests) {
+        return executeBatchAndWait(new RequestBatch(requests));
+    }
+
+    /**
+     * Executes requests on the current thread as a single batch and returns the responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @param requests
+     *            the batch of Requests to execute
+     *
+     * @return a list of Response objects representing the results of the requests; responses are returned in the same
+     *         order as the requests were specified.
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     * @throws IllegalArgumentException if the passed in RequestBatch is empty
+     * @throws NullPointerException if the passed in RequestBatch or any of its contents are null
+     */
+    public static List<Response> executeBatchAndWait(RequestBatch requests) {
+        Validate.notEmptyAndContainsNoNulls(requests, "requests");
+
+        HttpURLConnection connection = null;
+        try {
+            connection = toHttpConnection(requests);
+        } catch (Exception ex) {
+            List<Response> responses = Response.constructErrorResponses(requests.getRequests(), null, new FuntownException(ex));
+            runCallbacks(requests, responses);
+            return responses;
+        }
+
+        List<Response> responses = executeConnectionAndWait(connection, requests);
+        return responses;
+    }
+
+    /**
+     * Executes requests as a single batch asynchronously. This function will return immediately, and the requests will
+     * be processed on a separate thread. In order to process results of a request, or determine whether a request
+     * succeeded or failed, a callback must be specified (see the {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param requests
+     *            the Requests to execute
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws NullPointerException
+     *            If a null request is passed in
+     */
+    public static RequestAsyncTask executeBatchAsync(Request... requests) {
+        Validate.notNull(requests, "requests");
+
+        return executeBatchAsync(Arrays.asList(requests));
+    }
+
+    /**
+     * Executes requests as a single batch asynchronously. This function will return immediately, and the requests will
+     * be processed on a separate thread. In order to process results of a request, or determine whether a request
+     * succeeded or failed, a callback must be specified (see the {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param requests
+     *            the Requests to execute
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws IllegalArgumentException if the passed in collection is empty
+     * @throws NullPointerException if the passed in collection or any of its contents are null
+     */
+    public static RequestAsyncTask executeBatchAsync(Collection<Request> requests) {
+        return executeBatchAsync(new RequestBatch(requests));
+    }
+
+    /**
+     * Executes requests as a single batch asynchronously. This function will return immediately, and the requests will
+     * be processed on a separate thread. In order to process results of a request, or determine whether a request
+     * succeeded or failed, a callback must be specified (see the {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param requests
+     *            the RequestBatch to execute
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws IllegalArgumentException if the passed in RequestBatch is empty
+     * @throws NullPointerException if the passed in RequestBatch or any of its contents are null
+     */
+    public static RequestAsyncTask executeBatchAsync(RequestBatch requests) {
+        Validate.notEmptyAndContainsNoNulls(requests, "requests");
+
+        RequestAsyncTask asyncTask = new RequestAsyncTask(requests);
+        asyncTask.executeOnSettingsExecutor();
+        return asyncTask;
+    }
+
+    /**
+     * Executes requests that have already been serialized into an HttpURLConnection. No validation is done that the
+     * contents of the connection actually reflect the serialized requests, so it is the caller's responsibility to
+     * ensure that it will correctly generate the desired responses.
+     * <p/>
+     * This should only be called if you have transitioned off the UI thread.
+     *
+     * @param connection
+     *            the HttpURLConnection that the requests were serialized into
+     * @param requests
+     *            the requests represented by the HttpURLConnection
+     * @return a list of Responses corresponding to the requests
+     *
+     * @throws FuntownException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static List<Response> executeConnectionAndWait(HttpURLConnection connection, Collection<Request> requests) {
+        return executeConnectionAndWait(connection, new RequestBatch(requests));
+    }
+
+    /**
+     * Executes requests that have already been serialized into an HttpURLConnection. No validation is done that the
+     * contents of the connection actually reflect the serialized requests, so it is the caller's responsibility to
+     * ensure that it will correctly generate the desired responses.
+     * <p/>
+     * This should only be called if you have transitioned off the UI thread.
+     *
+     * @param connection
+     *            the HttpURLConnection that the requests were serialized into
+     * @param requests
+     *            the RequestBatch represented by the HttpURLConnection
+     * @return a list of Responses corresponding to the requests
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     */
+    public static List<Response> executeConnectionAndWait(HttpURLConnection connection, RequestBatch requests) {
+        List<Response> responses = Response.fromHttpConnection(connection, requests);
+
+        Utility.disconnectQuietly(connection);
+
+        int numRequests = requests.size();
+        if (numRequests != responses.size()) {
+            throw new FuntownException(String.format("Received %d responses while expecting %d", responses.size(),
+                    numRequests));
+        }
+
+        runCallbacks(requests, responses);
+
+        // See if any of these sessions needs its token to be extended. We do this after issuing the request so as to
+        // reduce network contention.
+        HashSet<Session> sessions = new HashSet<Session>();
+        for (Request request : requests) {
+            if (request.session != null) {
+                sessions.add(request.session);
+            }
+        }
+        for (Session session : sessions) {
+            session.extendAccessTokenIfNeeded();
+        }
+
+        return responses;
+    }
+
+    /**
+     * Asynchronously executes requests that have already been serialized into an HttpURLConnection. No validation is
+     * done that the contents of the connection actually reflect the serialized requests, so it is the caller's
+     * responsibility to ensure that it will correctly generate the desired responses. This function will return
+     * immediately, and the requests will be processed on a separate thread. In order to process results of a request,
+     * or determine whether a request succeeded or failed, a callback must be specified (see the
+     * {@link #setCallback(Callback) setCallback} method).
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param connection
+     *            the HttpURLConnection that the requests were serialized into
+     * @param requests
+     *            the requests represented by the HttpURLConnection
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeConnectionAsync(HttpURLConnection connection, RequestBatch requests) {
+        return executeConnectionAsync(null, connection, requests);
+    }
+
+    /**
+     * Asynchronously executes requests that have already been serialized into an HttpURLConnection. No validation is
+     * done that the contents of the connection actually reflect the serialized requests, so it is the caller's
+     * responsibility to ensure that it will correctly generate the desired responses. This function will return
+     * immediately, and the requests will be processed on a separate thread. In order to process results of a request,
+     * or determine whether a request succeeded or failed, a callback must be specified (see the
+     * {@link #setCallback(Callback) setCallback} method)
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @param callbackHandler
+     *            a Handler that will be used to post calls to the callback for each request; if null, a Handler will be
+     *            instantiated on the calling thread
+     * @param connection
+     *            the HttpURLConnection that the requests were serialized into
+     * @param requests
+     *            the requests represented by the HttpURLConnection
+     * @return a RequestAsyncTask that is executing the request
+     */
+    public static RequestAsyncTask executeConnectionAsync(Handler callbackHandler, HttpURLConnection connection,
+            RequestBatch requests) {
+        Validate.notNull(connection, "connection");
+
+        RequestAsyncTask asyncTask = new RequestAsyncTask(connection, requests);
+        requests.setCallbackHandler(callbackHandler);
+        asyncTask.executeOnSettingsExecutor();
+        return asyncTask;
+    }
+
+    /**
+     * Returns a string representation of this Request, useful for debugging.
+     *
+     * @return the debugging information
+     */
+    @Override
+    public String toString() {
+        return new StringBuilder().append("{Request: ").append(" session: ").append(session).append(", graphPath: ")
+                .append(graphPath).append(", graphObject: ").append(graphObject).append(", restMethod: ")
+                .append(restMethod).append(", httpMethod: ").append(httpMethod).append(", parameters: ")
+                .append(parameters).append("}").toString();
+    }
+
+    static void runCallbacks(final RequestBatch requests, List<Response> responses) {
+        int numRequests = requests.size();
+
+        // Compile the list of callbacks to call and then run them either on this thread or via the Handler we received
+        final ArrayList<Pair<Callback, Response>> callbacks = new ArrayList<Pair<Callback, Response>>();
+        for (int i = 0; i < numRequests; ++i) {
+            Request request = requests.get(i);
+            if (request.callback != null) {
+                callbacks.add(new Pair<Callback, Response>(request.callback, responses.get(i)));
+            }
+        }
+
+        if (callbacks.size() > 0) {
+            Runnable runnable = new Runnable() {
+                public void run() {
+                    for (Pair<Callback, Response> pair : callbacks) {
+                        pair.first.onCompleted(pair.second);
+                    }
+
+                    List<RequestBatch.Callback> batchCallbacks = requests.getCallbacks();
+                    for (RequestBatch.Callback batchCallback : batchCallbacks) {
+                        batchCallback.onBatchCompleted(requests);
+                    }
+                }
+            };
+
+            Handler callbackHandler = requests.getCallbackHandler();
+            if (callbackHandler == null) {
+                // Run on this thread.
+                runnable.run();
+            } else {
+                // Post to the handler.
+                callbackHandler.post(runnable);
+            }
+        }
+    }
+
+    static HttpURLConnection createConnection(URL url) throws IOException {
+        HttpURLConnection connection;
+        connection = (HttpURLConnection) url.openConnection();
+
+        connection.setRequestProperty(USER_AGENT_HEADER, getUserAgent());
+        connection.setRequestProperty(CONTENT_TYPE_HEADER, getMimeContentType());
+
+        connection.setChunkedStreamingMode(0);
+        return connection;
+    }
+
+
+    private void addCommonParameters() {
+        if (this.session != null) {
+            if (!this.session.isOpened()) {
+                throw new FuntownException("Session provided to a Request in un-opened state.");
+            } else if (!this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
+                String accessToken = this.session.getAccessToken();
+                Logger.registerAccessToken(accessToken);
+                this.parameters.putString(ACCESS_TOKEN_PARAM, accessToken);
+            }
+        }
+        this.parameters.putString(SDK_PARAM, SDK_ANDROID);
+        this.parameters.putString(FORMAT_PARAM, FORMAT_JSON);
+    }
+
+    private String appendParametersToBaseUrl(String baseUrl) {
+        Uri.Builder uriBuilder = new Uri.Builder().encodedPath(baseUrl);
+
+        Set<String> keys = this.parameters.keySet();
+        for (String key : keys) {
+            Object value = this.parameters.get(key);
+
+            if (value == null) {
+                value = "";
+            }
+
+            if (isSupportedParameterType(value)) {
+                value = parameterToString(value);
+            } else {
+                if (httpMethod == HttpMethod.GET) {
+                    throw new IllegalArgumentException(String.format("Unsupported parameter type for GET request: %s",
+                                    value.getClass().getSimpleName()));
+                }
+                continue;
+            }
+
+            uriBuilder.appendQueryParameter(key, value.toString());
+        }
+
+        return uriBuilder.toString();
+    }
+
+    final String getUrlForBatchedRequest() {
+        if (overriddenURL != null) {
+            throw new FuntownException("Can't override URL for a batch request");
+        }
+
+        String baseUrl;
+        if (this.restMethod != null) {
+            baseUrl = ServerProtocol.BATCHED_REST_METHOD_URL_BASE + this.restMethod;
+        } else {
+            baseUrl = this.graphPath;
+        }
+
+        addCommonParameters();
+        return appendParametersToBaseUrl(baseUrl);
+    }
+
+    final String getUrlForSingleRequest() {
+        if (overriddenURL != null) {
+            return overriddenURL.toString();
+        }
+
+        String baseUrl;
+        if (this.restMethod != null) {
+            baseUrl = ServerProtocol.REST_URL_BASE + this.restMethod;
+        } else {
+            baseUrl = ServerProtocol.GRAPH_URL_BASE + this.graphPath;
+        }
+
+        addCommonParameters();
+        return appendParametersToBaseUrl(baseUrl);
+    }
+
+
+    private void serializeToBatch(JSONArray batch, Bundle attachments) throws JSONException, IOException {
+        JSONObject batchEntry = new JSONObject();
+
+        if (this.batchEntryName != null) {
+            batchEntry.put(BATCH_ENTRY_NAME_PARAM, this.batchEntryName);
+            batchEntry.put(BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM, this.batchEntryOmitResultOnSuccess);
+        }
+        if (this.batchEntryDependsOn != null) {
+            batchEntry.put(BATCH_ENTRY_DEPENDS_ON_PARAM, this.batchEntryDependsOn);
+        }
+
+        String relativeURL = getUrlForBatchedRequest();
+        batchEntry.put(BATCH_RELATIVE_URL_PARAM, relativeURL);
+        batchEntry.put(BATCH_METHOD_PARAM, httpMethod);
+        if (this.session != null) {
+            String accessToken = this.session.getAccessToken();
+            Logger.registerAccessToken(accessToken);
+        }
+
+        // Find all of our attachments. Remember their names and put them in the attachment map.
+        ArrayList<String> attachmentNames = new ArrayList<String>();
+        Set<String> keys = this.parameters.keySet();
+        for (String key : keys) {
+            Object value = this.parameters.get(key);
+            if (isSupportedAttachmentType(value)) {
+                // Make the name unique across this entire batch.
+                String name = String.format("%s%d", ATTACHMENT_FILENAME_PREFIX, attachments.size());
+                attachmentNames.add(name);
+                Utility.putObjectInBundle(attachments, name, value);
+            }
+        }
+
+        if (!attachmentNames.isEmpty()) {
+            String attachmentNamesString = TextUtils.join(",", attachmentNames);
+            batchEntry.put(ATTACHED_FILES_PARAM, attachmentNamesString);
+        }
+
+        if (this.graphObject != null) {
+            // Serialize the graph object into the "body" parameter.
+            final ArrayList<String> keysAndValues = new ArrayList<String>();
+            processGraphObject(this.graphObject, relativeURL, new KeyValueSerializer() {
+                @Override
+                public void writeString(String key, String value) throws IOException {
+                    keysAndValues.add(String.format("%s=%s", key, URLEncoder.encode(value, "UTF-8")));
+                }
+            });
+            String bodyValue = TextUtils.join("&", keysAndValues);
+            batchEntry.put(BATCH_BODY_PARAM, bodyValue);
+        }
+
+        batch.put(batchEntry);
+    }
+
+    private void validate() {
+        if (graphPath != null && restMethod != null) {
+            throw new IllegalArgumentException("Only one of a graph path or REST method may be specified per request.");
+        }
+    }
+
+    final static void serializeToUrlConnection(RequestBatch requests, HttpURLConnection connection)
+    throws IOException, JSONException {
+        Logger logger = new Logger(LoggingBehavior.REQUESTS, "Request");
+
+        int numRequests = requests.size();
+
+        HttpMethod connectionHttpMethod = (numRequests == 1) ? requests.get(0).httpMethod : HttpMethod.POST;
+        connection.setRequestMethod(connectionHttpMethod.name());
+
+        URL url = connection.getURL();
+        logger.append("Request:\n");
+        logger.appendKeyValue("Id", requests.getId());
+        logger.appendKeyValue("URL", url);
+        logger.appendKeyValue("Method", connection.getRequestMethod());
+        logger.appendKeyValue("User-Agent", connection.getRequestProperty("User-Agent"));
+        logger.appendKeyValue("Content-Type", connection.getRequestProperty("Content-Type"));
+
+        connection.setConnectTimeout(requests.getTimeout());
+        connection.setReadTimeout(requests.getTimeout());
+
+        // If we have a single non-POST request, don't try to serialize anything or HttpURLConnection will
+        // turn it into a POST.
+        boolean isPost = (connectionHttpMethod == HttpMethod.POST);
+        if (!isPost) {
+            logger.log();
+            return;
+        }
+
+        connection.setDoOutput(true);
+
+        BufferedOutputStream outputStream = new BufferedOutputStream(connection.getOutputStream());
+        try {
+            Serializer serializer = new Serializer(outputStream, logger);
+
+            if (numRequests == 1) {
+                Request request = requests.get(0);
+
+                logger.append("  Parameters:\n");
+                serializeParameters(request.parameters, serializer);
+
+                logger.append("  Attachments:\n");
+                serializeAttachments(request.parameters, serializer);
+
+                if (request.graphObject != null) {
+                    processGraphObject(request.graphObject, url.getPath(), serializer);
+                }
+            } else {
+                String batchAppID = getBatchAppId(requests);
+                if (Utility.isNullOrEmpty(batchAppID)) {
+                    throw new FuntownException("At least one request in a batch must have an open Session, or a "
+                            + "default app ID must be specified.");
+                }
+
+                serializer.writeString(BATCH_APP_ID_PARAM, batchAppID);
+
+                // We write out all the requests as JSON, remembering which file attachments they have, then
+                // write out the attachments.
+                Bundle attachments = new Bundle();
+                serializeRequestsAsJSON(serializer, requests, attachments);
+
+                logger.append("  Attachments:\n");
+                serializeAttachments(attachments, serializer);
+            }
+        } finally {
+            outputStream.close();
+        }
+
+        logger.log();
+    }
+
+    private static void processGraphObject(GraphObject graphObject, String path, KeyValueSerializer serializer)
+            throws IOException {
+        // In general, graph objects are passed by reference (ID/URL). But if this is an OG Action,
+        // we need to pass the entire values of the contents of the 'image' property, as they
+        // contain important metadata beyond just a URL. We don't have a 100% foolproof way of knowing
+        // if we are posting an OG Action, given that batched requests can have parameter substitution,
+        // but passing the OG Action type as a substituted parameter is unlikely.
+        // It looks like an OG Action if it's posted to me/namespace:action[?other=stuff].
+        boolean isOGAction = false;
+        if (path.startsWith("me/") || path.startsWith("/me/")) {
+            int colonLocation = path.indexOf(":");
+            int questionMarkLocation = path.indexOf("?");
+            isOGAction = colonLocation > 3 && (questionMarkLocation == -1 || colonLocation < questionMarkLocation);
+        }
+
+        Set<Entry<String, Object>> entries = graphObject.asMap().entrySet();
+        for (Entry<String, Object> entry : entries) {
+            boolean passByValue = isOGAction && entry.getKey().equalsIgnoreCase("image");
+            processGraphObjectProperty(entry.getKey(), entry.getValue(), serializer, passByValue);
+        }
+    }
+
+    private static void processGraphObjectProperty(String key, Object value, KeyValueSerializer serializer,
+            boolean passByValue) throws IOException {
+        Class<?> valueClass = value.getClass();
+        if (GraphObject.class.isAssignableFrom(valueClass)) {
+            value = ((GraphObject) value).getInnerJSONObject();
+            valueClass = value.getClass();
+        } else if (GraphObjectList.class.isAssignableFrom(valueClass)) {
+            value = ((GraphObjectList<?>) value).getInnerJSONArray();
+            valueClass = value.getClass();
+        }
+
+        if (JSONObject.class.isAssignableFrom(valueClass)) {
+            JSONObject jsonObject = (JSONObject) value;
+            if (passByValue) {
+                // We need to pass all properties of this object in key[propertyName] format.
+                @SuppressWarnings("unchecked")
+                Iterator<String> keys = jsonObject.keys();
+                while (keys.hasNext()) {
+                    String propertyName = keys.next();
+                    String subKey = String.format("%s[%s]", key, propertyName);
+                    processGraphObjectProperty(subKey, jsonObject.opt(propertyName), serializer, passByValue);
+                }
+            } else {
+                // Normal case is passing objects by reference, so just pass the ID or URL, if any, as the value
+                // for "key"
+                if (jsonObject.has("id")) {
+                    processGraphObjectProperty(key, jsonObject.optString("id"), serializer, passByValue);
+                } else if (jsonObject.has("url")) {
+                    processGraphObjectProperty(key, jsonObject.optString("url"), serializer, passByValue);
+                }
+            }
+        } else if (JSONArray.class.isAssignableFrom(valueClass)) {
+            JSONArray jsonArray = (JSONArray) value;
+            int length = jsonArray.length();
+            for (int i = 0; i < length; ++i) {
+                String subKey = String.format("%s[%d]", key, i);
+                processGraphObjectProperty(subKey, jsonArray.opt(i), serializer, passByValue);
+            }
+        } else if (String.class.isAssignableFrom(valueClass) ||
+                Number.class.isAssignableFrom(valueClass) ||
+                Boolean.class.isAssignableFrom(valueClass)) {
+            serializer.writeString(key, value.toString());
+        } else if (Date.class.isAssignableFrom(valueClass)) {
+            Date date = (Date) value;
+            // The "Events Timezone" platform migration affects what date/time formats Facebook accepts and returns.
+            // Apps created after 8/1/12 (or apps that have explicitly enabled the migration) should send/receive
+            // dates in ISO-8601 format. Pre-migration apps can send as Unix timestamps. Since the future is ISO-8601,
+            // that is what we support here. Apps that need pre-migration behavior can explicitly send these as
+            // integer timestamps rather than Dates.
+            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(ISO_8601_FORMAT_STRING, Locale.US);
+            serializer.writeString(key, iso8601DateFormat.format(date));
+        }
+    }
+
+    private static void serializeParameters(Bundle bundle, Serializer serializer) throws IOException {
+        Set<String> keys = bundle.keySet();
+
+        for (String key : keys) {
+            Object value = bundle.get(key);
+            if (isSupportedParameterType(value)) {
+                serializer.writeObject(key, value);
+            }
+        }
+    }
+
+    private static void serializeAttachments(Bundle bundle, Serializer serializer) throws IOException {
+        Set<String> keys = bundle.keySet();
+
+        for (String key : keys) {
+            Object value = bundle.get(key);
+            if (isSupportedAttachmentType(value)) {
+                serializer.writeObject(key, value);
+            }
+        }
+    }
+
+    private static void serializeRequestsAsJSON(Serializer serializer, Collection<Request> requests, Bundle attachments)
+            throws JSONException, IOException {
+        JSONArray batch = new JSONArray();
+        for (Request request : requests) {
+            request.serializeToBatch(batch, attachments);
+        }
+
+        String batchAsString = batch.toString();
+        serializer.writeString(BATCH_PARAM, batchAsString);
+    }
+
+    private static String getMimeContentType() {
+        return String.format("multipart/form-data; boundary=%s", MIME_BOUNDARY);
+    }
+
+    private static volatile String userAgent;
+
+    private static String getUserAgent() {
+        if (userAgent == null) {
+            userAgent = String.format("%s.%s", USER_AGENT_BASE, FuntownSdkVersion.BUILD);
+        }
+
+        return userAgent;
+    }
+
+    private static String getBatchAppId(RequestBatch batch) {
+        if (!Utility.isNullOrEmpty(batch.getBatchApplicationId())) {
+            return batch.getBatchApplicationId();
+        }
+
+        for (Request request : batch) {
+            Session session = request.session;
+            if (session != null) {
+                return session.getApplicationId();
+            }
+        }
+        return Request.defaultBatchApplicationId;
+    }
+
+    private static <T extends GraphObject> List<T> typedListFromResponse(Response response, Class<T> clazz) {
+        GraphMultiResult multiResult = response.getGraphObjectAs(GraphMultiResult.class);
+        if (multiResult == null) {
+            return null;
+        }
+
+        GraphObjectList<GraphObject> data = multiResult.getData();
+        if (data == null) {
+            return null;
+        }
+
+        return data.castToListOf(clazz);
+    }
+
+    private static boolean isSupportedAttachmentType(Object value) {
+        return value instanceof Bitmap || value instanceof byte[] || value instanceof ParcelFileDescriptor;
+    }
+
+    private static boolean isSupportedParameterType(Object value) {
+        return value instanceof String || value instanceof Boolean || value instanceof Number ||
+                value instanceof Date;
+    }
+
+    private static String parameterToString(Object value) {
+        if (value instanceof String) {
+            return (String) value;
+        } else if (value instanceof Boolean || value instanceof Number) {
+            return value.toString();
+        } else if (value instanceof Date) {
+            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(ISO_8601_FORMAT_STRING, Locale.US);
+            return iso8601DateFormat.format(value);
+        }
+        throw new IllegalArgumentException("Unsupported parameter type.");
+    }
+
+    private interface KeyValueSerializer {
+        void writeString(String key, String value) throws IOException;
+    }
+
+    private static class Serializer implements KeyValueSerializer {
+        private final BufferedOutputStream outputStream;
+        private final Logger logger;
+        private boolean firstWrite = true;
+
+        public Serializer(BufferedOutputStream outputStream, Logger logger) {
+            this.outputStream = outputStream;
+            this.logger = logger;
+        }
+
+        public void writeObject(String key, Object value) throws IOException {
+            if (isSupportedParameterType(value)) {
+                writeString(key, parameterToString(value));
+            } else if (value instanceof Bitmap) {
+                writeBitmap(key, (Bitmap) value);
+            } else if (value instanceof byte[]) {
+                writeBytes(key, (byte[]) value);
+            } else if (value instanceof ParcelFileDescriptor) {
+                writeFile(key, (ParcelFileDescriptor) value);
+            } else {
+                throw new IllegalArgumentException("value is not a supported type: String, Bitmap, byte[]");
+            }
+        }
+
+        public void writeString(String key, String value) throws IOException {
+            writeContentDisposition(key, null, null);
+            writeLine("%s", value);
+            writeRecordBoundary();
+            if (logger != null) {
+                logger.appendKeyValue("    " + key, value);
+            }
+        }
+
+        public void writeBitmap(String key, Bitmap bitmap) throws IOException {
+            writeContentDisposition(key, key, "image/png");
+            // Note: quality parameter is ignored for PNG
+            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
+            writeLine("");
+            writeRecordBoundary();
+            logger.appendKeyValue("    " + key, "<Image>");
+        }
+
+        public void writeBytes(String key, byte[] bytes) throws IOException {
+            writeContentDisposition(key, key, "content/unknown");
+            this.outputStream.write(bytes);
+            writeLine("");
+            writeRecordBoundary();
+            logger.appendKeyValue("    " + key, String.format("<Data: %d>", bytes.length));
+        }
+
+        public void writeFile(String key, ParcelFileDescriptor descriptor) throws IOException {
+            writeContentDisposition(key, key, "content/unknown");
+
+            ParcelFileDescriptor.AutoCloseInputStream inputStream = null;
+            BufferedInputStream bufferedInputStream = null;
+            int totalBytes = 0;
+            try {
+                inputStream = new ParcelFileDescriptor.AutoCloseInputStream(descriptor);
+                bufferedInputStream = new BufferedInputStream(inputStream);
+
+                byte[] buffer = new byte[8192];
+                int bytesRead;
+                while ((bytesRead = bufferedInputStream.read(buffer)) != -1) {
+                    this.outputStream.write(buffer, 0, bytesRead);
+                    totalBytes += bytesRead;
+                }
+            } finally {
+                if (bufferedInputStream != null) {
+                    bufferedInputStream.close();
+                }
+                if (inputStream != null) {
+                    inputStream.close();
+                }
+            }
+            writeLine("");
+            writeRecordBoundary();
+            logger.appendKeyValue("    " + key, String.format("<Data: %d>", totalBytes));
+        }
+
+        public void writeRecordBoundary() throws IOException {
+            writeLine("--%s", MIME_BOUNDARY);
+        }
+
+        public void writeContentDisposition(String name, String filename, String contentType) throws IOException {
+            write("Content-Disposition: form-data; name=\"%s\"", name);
+            if (filename != null) {
+                write("; filename=\"%s\"", filename);
+            }
+            writeLine(""); // newline after Content-Disposition
+            if (contentType != null) {
+                writeLine("%s: %s", CONTENT_TYPE_HEADER, contentType);
+            }
+            writeLine(""); // blank line before content
+        }
+
+        public void write(String format, Object... args) throws IOException {
+            if (firstWrite) {
+                // Prepend all of our output with a boundary string.
+                this.outputStream.write("--".getBytes());
+                this.outputStream.write(MIME_BOUNDARY.getBytes());
+                this.outputStream.write("\r\n".getBytes());
+                firstWrite = false;
+            }
+            this.outputStream.write(String.format(format, args).getBytes());
+        }
+
+        public void writeLine(String format, Object... args) throws IOException {
+            write(format, args);
+            write("\r\n");
+        }
+
+    }
+
+    /**
+     * Specifies the interface that consumers of the Request class can implement in order to be notified when a
+     * particular request completes, either successfully or with an error.
+     */
+    public interface Callback {
+        /**
+         * The method that will be called when a request completes.
+         *
+         * @param response
+         *            the Response of this request, which may include error information if the request was unsuccessful
+         */
+        void onCompleted(Response response);
+    }
+
+    /**
+     * Specifies the interface that consumers of
+     * {@link Request#executeMeRequestAsync(Session, com.facebook.Request.GraphUserCallback)}
+     * can use to be notified when the request completes, either successfully or with an error.
+     */
+    public interface GraphUserCallback {
+        /**
+         * The method that will be called when the request completes.
+         *
+         * @param user     the GraphObject representing the returned user, or null
+         * @param response the Response of this request, which may include error information if the request was unsuccessful
+         */
+        void onCompleted(GraphUser user, Response response);
+    }
+
+    /**
+     * Specifies the interface that consumers of
+     * {@link Request#executeMyFriendsRequestAsync(Session, com.facebook.Request.GraphUserListCallback)}
+     * can use to be notified when the request completes, either successfully or with an error.
+     */
+    public interface GraphUserListCallback {
+        /**
+         * The method that will be called when the request completes.
+         *
+         * @param users    the list of GraphObjects representing the returned friends, or null
+         * @param response the Response of this request, which may include error information if the request was unsuccessful
+         */
+        void onCompleted(List<GraphUser> users, Response response);
+    }
+
+    /**
+     * Specifies the interface that consumers of
+     * {@link Request#executePlacesSearchRequestAsync(Session, android.location.Location, int, int, String, com.facebook.Request.GraphPlaceListCallback)}
+     * can use to be notified when the request completes, either successfully or with an error.
+     */
+    public interface GraphPlaceListCallback {
+        /**
+         * The method that will be called when the request completes.
+         *
+         * @param places   the list of GraphObjects representing the returned places, or null
+         * @param response the Response of this request, which may include error information if the request was unsuccessful
+         */
+        void onCompleted(List<GraphPlace> places, Response response);
+    }
+}
diff --git a/funtown/src/tw/com/funtown/RequestAsyncTask.java b/funtown/src/tw/com/funtown/RequestAsyncTask.java
new file mode 100644
index 000000000..05c7bf781
--- /dev/null
+++ b/funtown/src/tw/com/funtown/RequestAsyncTask.java
@@ -0,0 +1,189 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+import android.annotation.TargetApi;
+import android.os.AsyncTask;
+import android.os.Handler;
+import android.util.Log;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.HttpURLConnection;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.Executor;
+
+/**
+ * Defines an AsyncTask suitable for executing a Request in the background. May be subclassed
+ * by applications having unique threading model needs.
+ */
+@TargetApi(3)
+public class RequestAsyncTask extends AsyncTask<Void, Void, List<Response>> {
+    private static final String TAG = RequestAsyncTask.class.getCanonicalName();
+    private static Method executeOnExecutorMethod;
+
+    private final HttpURLConnection connection;
+    private final RequestBatch requests;
+
+    private Exception exception;
+
+    static {
+        for (Method method : AsyncTask.class.getMethods()) {
+            if ("executeOnExecutor".equals(method.getName())) {
+                Class<?>[] parameters = method.getParameterTypes();
+                if ((parameters.length == 2) && (parameters[0] == Executor.class) && parameters[1].isArray()) {
+                    executeOnExecutorMethod = method;
+                    break;
+                }
+            }
+        }
+    }
+
+    /**
+     * Constructor. Serialization of the requests will be done in the background, so any serialization-
+     * related errors will be returned via the Response.getException() method.
+     *
+     * @param requests the requests to execute
+     */
+    public RequestAsyncTask(Request... requests) {
+        this(null, new RequestBatch(requests));
+    }
+
+    /**
+     * Constructor. Serialization of the requests will be done in the background, so any serialization-
+     * related errors will be returned via the Response.getException() method.
+     *
+     * @param requests the requests to execute
+     */
+    public RequestAsyncTask(Collection<Request> requests) {
+        this(null, new RequestBatch(requests));
+    }
+
+    /**
+     * Constructor. Serialization of the requests will be done in the background, so any serialization-
+     * related errors will be returned via the Response.getException() method.
+     *
+     * @param requests the requests to execute
+     */
+    public RequestAsyncTask(RequestBatch requests) {
+        this(null, requests);
+    }
+
+    /**
+     * Constructor that allows specification of an HTTP connection to use for executing
+     * the requests. No validation is done that the contents of the connection actually
+     * reflect the serialized requests, so it is the caller's responsibility to ensure
+     * that it will correctly generate the desired responses.
+     *
+     * @param connection the HTTP connection to use to execute the requests
+     * @param requests   the requests to execute
+     */
+    public RequestAsyncTask(HttpURLConnection connection, Request... requests) {
+        this(connection, new RequestBatch(requests));
+    }
+
+    /**
+     * Constructor that allows specification of an HTTP connection to use for executing
+     * the requests. No validation is done that the contents of the connection actually
+     * reflect the serialized requests, so it is the caller's responsibility to ensure
+     * that it will correctly generate the desired responses.
+     *
+     * @param connection the HTTP connection to use to execute the requests
+     * @param requests   the requests to execute
+     */
+    public RequestAsyncTask(HttpURLConnection connection, Collection<Request> requests) {
+        this(connection, new RequestBatch(requests));
+    }
+
+    /**
+     * Constructor that allows specification of an HTTP connection to use for executing
+     * the requests. No validation is done that the contents of the connection actually
+     * reflect the serialized requests, so it is the caller's responsibility to ensure
+     * that it will correctly generate the desired responses.
+     *
+     * @param connection the HTTP connection to use to execute the requests
+     * @param requests   the requests to execute
+     */
+    public RequestAsyncTask(HttpURLConnection connection, RequestBatch requests) {
+        this.requests = requests;
+        this.connection = connection;
+    }
+
+    protected final Exception getException() {
+        return exception;
+    }
+
+    protected final RequestBatch getRequests() {
+        return requests;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder().append("{RequestAsyncTask: ").append(" connection: ").append(connection)
+                .append(", requests: ").append(requests).append("}").toString();
+    }
+
+    @Override
+    protected void onPreExecute() {
+        super.onPreExecute();
+
+        if (requests.getCallbackHandler() == null) {
+            // We want any callbacks to go to a handler on this thread unless a handler has already been specified.
+            requests.setCallbackHandler(new Handler());
+        }
+    }
+
+    @Override
+    protected void onPostExecute(List<Response> result) {
+        super.onPostExecute(result);
+
+        if (exception != null) {
+            Log.d(TAG, String.format("onPostExecute: exception encountered during request: %s", exception.getMessage()));
+        }
+    }
+
+    @Override
+    protected List<Response> doInBackground(Void... params) {
+        try {
+            if (connection == null) {
+                return requests.executeAndWait();
+            } else {
+                return Request.executeConnectionAndWait(connection, requests);
+            }
+        } catch (Exception e) {
+            exception = e;
+            return null;
+        }
+    }
+
+    RequestAsyncTask executeOnSettingsExecutor() {
+        try {
+            if (executeOnExecutorMethod != null) {
+                executeOnExecutorMethod.invoke(this, Settings.getExecutor(), null);
+                return this;
+            }
+        } catch (InvocationTargetException e) {
+            // fall-through
+        } catch (IllegalAccessException e) {
+            // fall-through
+        }
+
+        this.execute();
+        return this;
+    }
+}
diff --git a/funtown/src/tw/com/funtown/RequestBatch.java b/funtown/src/tw/com/funtown/RequestBatch.java
new file mode 100644
index 000000000..29d7397a1
--- /dev/null
+++ b/funtown/src/tw/com/funtown/RequestBatch.java
@@ -0,0 +1,227 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+import android.os.Handler;
+
+import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * RequestBatch contains a list of Request objects that can be sent to Facebook in a single round-trip.
+ */
+public class RequestBatch extends AbstractList<Request> {
+    private static AtomicInteger idGenerator = new AtomicInteger();
+
+    private Handler callbackHandler;
+    private List<Request> requests = new ArrayList<Request>();
+    private int timeoutInMilliseconds = 0;
+    private final String id = Integer.valueOf(idGenerator.incrementAndGet()).toString();
+    private List<Callback> callbacks = new ArrayList<Callback>();
+    private String batchApplicationId;
+
+    /**
+     * Constructor. Creates an empty batch.
+     */
+    public RequestBatch() {
+        this.requests = new ArrayList<Request>();
+    }
+
+    /**
+     * Constructor.
+     * @param requests the requests to add to the batch
+     */
+    public RequestBatch(Collection<Request> requests) {
+        this.requests = new ArrayList<Request>(requests);
+    }
+
+    /**
+     * Constructor.
+     * @param requests the requests to add to the batch
+     */
+    public RequestBatch(Request... requests) {
+        this.requests = Arrays.asList(requests);
+    }
+
+    /**
+     * Constructor.
+     * @param requests the requests to add to the batch
+     */
+    public RequestBatch(RequestBatch requests) {
+        this.requests = new ArrayList<Request>(requests);
+        this.callbackHandler = requests.callbackHandler;
+        this.timeoutInMilliseconds = requests.timeoutInMilliseconds;
+        this.callbacks = new ArrayList<Callback>(requests.callbacks);
+    }
+
+    /**
+     * Gets the timeout to wait for responses from the server before a timeout error occurs.
+     * @return the timeout, in milliseconds; 0 (the default) means do not timeout
+     */
+    public int getTimeout() {
+        return timeoutInMilliseconds;
+    }
+
+    /**
+     * Sets the timeout to wait for responses from the server before a timeout error occurs.
+     * @param timeoutInMilliseconds the timeout, in milliseconds; 0 means do not timeout
+     */
+    public void setTimeout(int timeoutInMilliseconds) {
+        if (timeoutInMilliseconds < 0) {
+            throw new IllegalArgumentException("Argument timeoutInMilliseconds must be >= 0.");
+        }
+        this.timeoutInMilliseconds = timeoutInMilliseconds;
+    }
+
+    /**
+     * Adds a batch-level callback which will be called when the entire batch has finished executing.
+     *
+     * @param callback the callback
+     */
+    public void addCallback(Callback callback) {
+        if (!callbacks.contains(callback)) {
+            callbacks.add(callback);
+        }
+    }
+
+    /**
+     * Removes a batch-level callback.
+     *
+     * @param callback the callback
+     */
+    public void removeCallback(Callback callback) {
+        callbacks.remove(callback);
+    }
+
+    @Override
+    public final boolean add(Request request) {
+        return requests.add(request);
+    }
+
+    @Override
+    public final void add(int location, Request request) {
+        requests.add(location, request);
+    }
+
+    @Override
+    public final void clear() {
+        requests.clear();
+    }
+
+    @Override
+    public final Request get(int i) {
+        return requests.get(i);
+    }
+
+    @Override
+    public final Request remove(int location) {
+        return requests.remove(location);
+    }
+
+    @Override
+    public final Request set(int location, Request request) {
+        return requests.set(location, request);
+    }
+
+    @Override
+    public final int size() {
+        return requests.size();
+    }
+
+    final String getId() {
+        return id;
+    }
+
+    final Handler getCallbackHandler() {
+        return callbackHandler;
+    }
+
+    final void setCallbackHandler(Handler callbackHandler) {
+        this.callbackHandler = callbackHandler;
+    }
+
+    final List<Request> getRequests() {
+        return requests;
+    }
+
+    final List<Callback> getCallbacks() {
+        return callbacks;
+    }
+
+    final String getBatchApplicationId() {
+        return batchApplicationId;
+    }
+
+    final void setBatchApplicationId(String batchApplicationId) {
+        this.batchApplicationId = batchApplicationId;
+    }
+
+    /**
+     * Executes this batch on the current thread and returns the responses.
+     * <p/>
+     * This should only be used if you have transitioned off the UI thread.
+     *
+     * @return a list of Response objects representing the results of the requests; responses are returned in the same
+     *         order as the requests were specified.
+     *
+     * @throws FacebookException
+     *            If there was an error in the protocol used to communicate with the service
+     * @throws IllegalArgumentException if the passed in RequestBatch is empty
+     * @throws NullPointerException if the passed in RequestBatch or any of its contents are null
+     */
+    public final List<Response> executeAndWait() {
+        return executeAndWaitImpl();
+    }
+
+    /**
+     * Executes this batch asynchronously. This function will return immediately, and the batch will
+     * be processed on a separate thread. In order to process results of a request, or determine
+     * whether a request succeeded or failed, a callback must be specified (see
+     * {@link Request#setCallback(com.facebook.Request.Callback)})
+     * <p/>
+     * This should only be called from the UI thread.
+     *
+     * @return a RequestAsyncTask that is executing the request
+     *
+     * @throws IllegalArgumentException if this batch is empty
+     * @throws NullPointerException if any of the contents of this batch are null
+     */
+    public final RequestAsyncTask executeAsync() {
+        return executeAsyncImpl();
+    }
+
+    /**
+     * Specifies the interface that consumers of the RequestBatch class can implement in order to be notified when the
+     * entire batch completes execution. It will be called after all per-Request callbacks are called.
+     */
+    public interface Callback {
+        /**
+         * The method that will be called when a batch completes.
+         *
+         * @param batch     the RequestBatch containing the Requests which were executed
+         */
+        void onBatchCompleted(RequestBatch batch);
+    }
+
+    List<Response> executeAndWaitImpl() {
+        return Request.executeBatchAndWait(this);
+    }
+
+    RequestAsyncTask executeAsyncImpl() {
+        return Request.executeBatchAsync(this);
+    }
+}
diff --git a/funtown/src/tw/com/funtown/Response.java b/funtown/src/tw/com/funtown/Response.java
new file mode 100644
index 000000000..500ba8fc0
--- /dev/null
+++ b/funtown/src/tw/com/funtown/Response.java
@@ -0,0 +1,466 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+import android.content.Context;
+import tw.com.funtown.internal.*;
+import com.facebook.model.GraphObject;
+import com.facebook.model.GraphObjectList;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Encapsulates the response, successful or otherwise, of a call to the Facebook platform.
+ */
+public class Response {
+    private final HttpURLConnection connection;
+    private final GraphObject graphObject;
+    private final GraphObjectList<GraphObject> graphObjectList;
+    private final boolean isFromCache;
+    private final FuntownRequestError error;
+    private final Request request;
+
+    /**
+     * Property name of non-JSON results in the GraphObject. Certain calls to Facebook result in a non-JSON response
+     * (e.g., the string literal "true" or "false"). To present a consistent way of accessing results, these are
+     * represented as a GraphObject with a single string property with this name.
+     */
+    public static final String NON_JSON_RESPONSE_PROPERTY = "FACEBOOK_NON_JSON_RESULT";
+
+    private static final int INVALID_SESSION_FACEBOOK_ERROR_CODE = 190;
+
+    private static final String CODE_KEY = "code";
+    private static final String BODY_KEY = "body";
+
+    private static final String RESPONSE_LOG_TAG = "Response";
+
+    private static final String RESPONSE_CACHE_TAG = "ResponseCache";
+    private static FileLruCache responseCache;
+
+    Response(Request request, HttpURLConnection connection, GraphObject graphObject, boolean isFromCache) {
+        this.request = request;
+        this.connection = connection;
+        this.graphObject = graphObject;
+        this.graphObjectList = null;
+        this.isFromCache = isFromCache;
+        this.error = null;
+    }
+
+    Response(Request request, HttpURLConnection connection, GraphObjectList<GraphObject> graphObjects,
+            boolean isFromCache) {
+        this.request = request;
+        this.connection = connection;
+        this.graphObject = null;
+        this.graphObjectList = graphObjects;
+        this.isFromCache = isFromCache;
+        this.error = null;
+    }
+
+    Response(Request request, HttpURLConnection connection, FuntownRequestError error) {
+        this.request = request;
+        this.connection = connection;
+        this.graphObject = null;
+        this.graphObjectList = null;
+        this.isFromCache = false;
+        this.error = error;
+    }
+
+    /**
+     * Returns information about any errors that may have occurred during the request.
+     *
+     * @return the error from the server, or null if there was no server error
+     */
+    public final FuntownRequestError getError() {
+        return error;
+    }
+
+    /**
+     * The single graph object returned for this request, if any.
+     *
+     * @return the graph object returned, or null if none was returned (or if the result was a list)
+     */
+    public final GraphObject getGraphObject() {
+        return graphObject;
+    }
+
+    /**
+     * The single graph object returned for this request, if any, cast into a particular type of GraphObject.
+     *
+     * @param graphObjectClass the GraphObject-derived interface to cast the graph object into
+     * @return the graph object returned, or null if none was returned (or if the result was a list)
+     * @throws FuntownException If the passed in Class is not a valid GraphObject interface
+     */
+    public final <T extends GraphObject> T getGraphObjectAs(Class<T> graphObjectClass) {
+        if (graphObject == null) {
+            return null;
+        }
+        if (graphObjectClass == null) {
+            throw new NullPointerException("Must pass in a valid interface that extends GraphObject");
+        }
+        return graphObject.cast(graphObjectClass);
+    }
+
+    /**
+     * The list of graph objects returned for this request, if any.
+     *
+     * @return the list of graph objects returned, or null if none was returned (or if the result was not a list)
+     */
+    public final GraphObjectList<GraphObject> getGraphObjectList() {
+        return graphObjectList;
+    }
+
+    /**
+     * The list of graph objects returned for this request, if any, cast into a particular type of GraphObject.
+     *
+     * @param graphObjectClass the GraphObject-derived interface to cast the graph objects into
+     * @return the list of graph objects returned, or null if none was returned (or if the result was not a list)
+     * @throws FuntownException If the passed in Class is not a valid GraphObject interface
+     */
+    public final <T extends GraphObject> GraphObjectList<T> getGraphObjectListAs(Class<T> graphObjectClass) {
+        if (graphObjectList == null) {
+            return null;
+        }
+        return graphObjectList.castToListOf(graphObjectClass);
+    }
+
+    /**
+     * Returns the HttpURLConnection that this response was generated from. If the response was retrieved
+     * from the cache, this will be null.
+     *
+     * @return the connection, or null
+     */
+    public final HttpURLConnection getConnection() {
+        return connection;
+    }
+
+    /**
+     * Returns the request that this response is for.
+     *
+     * @return the request that this response is for
+     */
+    public Request getRequest() {
+        return request;
+    }
+
+    /**
+     * Indicates whether paging is being done forward or backward.
+     */
+    public enum PagingDirection {
+        /**
+         * Indicates that paging is being performed in the forward direction.
+         */
+        NEXT,
+        /**
+         * Indicates that paging is being performed in the backward direction.
+         */
+        PREVIOUS
+    }
+
+    /**
+     * If a Response contains results that contain paging information, returns a new
+     * Request that will retrieve the next page of results, in whichever direction
+     * is desired. If no paging information is available, returns null.
+     *
+     * @param direction enum indicating whether to page forward or backward
+     * @return a Request that will retrieve the next page of results in the desired
+     *         direction, or null if no paging information is available
+     */
+    public Request getRequestForPagedResults(PagingDirection direction) {
+        String link = null;
+        if (graphObject != null) {
+            PagedResults pagedResults = graphObject.cast(PagedResults.class);
+            PagingInfo pagingInfo = pagedResults.getPaging();
+            if (pagingInfo != null) {
+                if (direction == PagingDirection.NEXT) {
+                    link = pagingInfo.getNext();
+                } else {
+                    link = pagingInfo.getPrevious();
+                }
+            }
+        }
+        if (Utility.isNullOrEmpty(link)) {
+            return null;
+        }
+
+        if (link != null && link.equals(request.getUrlForSingleRequest())) {
+            // We got the same "next" link as we just tried to retrieve. This could happen if cached
+            // data is invalid. All we can do in this case is pretend we have finished.
+            return null;
+        }
+
+        Request pagingRequest;
+        try {
+            pagingRequest = new Request(request.getSession(), new URL(link));
+        } catch (MalformedURLException e) {
+            return null;
+        }
+
+        return pagingRequest;
+    }
+
+    /**
+     * Provides a debugging string for this response.
+     */
+    @Override
+    public String toString() {
+        String responseCode;
+        try {
+            responseCode = String.format("%d", (connection != null) ? connection.getResponseCode() : 200);
+        } catch (IOException e) {
+            responseCode = "unknown";
+        }
+
+        return new StringBuilder().append("{Response: ").append(" responseCode: ").append(responseCode)
+                .append(", graphObject: ").append(graphObject).append(", error: ").append(error)
+                .append(", isFromCache:").append(isFromCache).append("}")
+                .toString();
+    }
+
+    /**
+     * Indicates whether the response was retrieved from a local cache or from the server.
+     *
+     * @return true if the response was cached locally, false if it was retrieved from the server
+     */
+    public final boolean getIsFromCache() {
+        return isFromCache;
+    }
+
+    static FileLruCache getResponseCache() {
+        if (responseCache == null) {
+            Context applicationContext = Session.getStaticContext();
+            if (applicationContext != null) {
+                responseCache = new FileLruCache(applicationContext, RESPONSE_CACHE_TAG, new FileLruCache.Limits());
+            }
+        }
+
+        return responseCache;
+    }
+
+    @SuppressWarnings("resource")
+    static List<Response> fromHttpConnection(HttpURLConnection connection, RequestBatch requests) {
+        InputStream stream = null;
+
+        FileLruCache cache = null;
+        String cacheKey = null;
+        if (requests instanceof CacheableRequestBatch) {
+            CacheableRequestBatch cacheableRequestBatch = (CacheableRequestBatch) requests;
+            cache = getResponseCache();
+            cacheKey = cacheableRequestBatch.getCacheKeyOverride();
+            if (Utility.isNullOrEmpty(cacheKey)) {
+                if (requests.size() == 1) {
+                    // Default for single requests is to use the URL.
+                    cacheKey = requests.get(0).getUrlForSingleRequest();
+                } else {
+                    Logger.log(LoggingBehavior.REQUESTS, RESPONSE_CACHE_TAG,
+                            "Not using cache for cacheable request because no key was specified");
+                }
+            }
+
+            // Try loading from cache.  If that fails, load from the network.
+            if (!cacheableRequestBatch.getForceRoundTrip() && cache != null && !Utility.isNullOrEmpty(cacheKey)) {
+                try {
+                    stream = cache.get(cacheKey);
+                    if (stream != null) {
+                        return createResponsesFromStream(stream, null, requests, true);
+                    }
+                } catch (FuntownException exception) { // retry via roundtrip below
+                } catch (JSONException exception) {
+                } catch (IOException exception) {
+                } finally {
+                    Utility.closeQuietly(stream);
+                }
+            }
+        }
+
+        // Load from the network, and cache the result if not an error.
+        try {
+            if (connection.getResponseCode() >= 400) {
+                stream = connection.getErrorStream();
+            } else {
+                stream = connection.getInputStream();
+                if ((cache != null) && (cacheKey != null) && (stream != null)) {
+                    InputStream interceptStream = cache.interceptAndPut(cacheKey, stream);
+                    if (interceptStream != null) {
+                        stream = interceptStream;
+                    }
+                }
+            }
+
+            return createResponsesFromStream(stream, connection, requests, false);
+        } catch (FuntownException facebookException) {
+            Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", facebookException);
+            return constructErrorResponses(requests, connection, facebookException);
+        } catch (JSONException exception) {
+            Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", exception);
+            return constructErrorResponses(requests, connection, new FuntownException(exception));
+        } catch (IOException exception) {
+            Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response <Error>: %s", exception);
+            return constructErrorResponses(requests, connection, new FuntownException(exception));
+        } finally {
+            Utility.closeQuietly(stream);
+        }
+    }
+
+    static List<Response> createResponsesFromStream(InputStream stream, HttpURLConnection connection,
+            RequestBatch requests, boolean isFromCache) throws FuntownException, JSONException, IOException {
+
+        String responseString = Utility.readStreamToString(stream);
+        Logger.log(LoggingBehavior.INCLUDE_RAW_RESPONSES, RESPONSE_LOG_TAG,
+                "Response (raw)\n  Size: %d\n  Response:\n%s\n", responseString.length(),
+                responseString);
+
+        return createResponsesFromString(responseString, connection, requests, isFromCache);
+    }
+
+    static List<Response> createResponsesFromString(String responseString, HttpURLConnection connection,
+            RequestBatch requests, boolean isFromCache) throws FuntownException, JSONException, IOException {
+        JSONTokener tokener = new JSONTokener(responseString);
+        Object resultObject = tokener.nextValue();
+
+        List<Response> responses = createResponsesFromObject(connection, requests, resultObject, isFromCache);
+        Logger.log(LoggingBehavior.REQUESTS, RESPONSE_LOG_TAG, "Response\n  Id: %s\n  Size: %d\n  Responses:\n%s\n",
+                requests.getId(), responseString.length(), responses);
+
+        return responses;
+    }
+
+    private static List<Response> createResponsesFromObject(HttpURLConnection connection, List<Request> requests,
+            Object object, boolean isFromCache) throws FuntownException, JSONException {
+        assert (connection != null) || isFromCache;
+
+        int numRequests = requests.size();
+        List<Response> responses = new ArrayList<Response>(numRequests);
+        Object originalResult = object;
+
+        if (numRequests == 1) {
+            Request request = requests.get(0);
+            try {
+                // Single request case -- the entire response is the result, wrap it as "body" so we can handle it
+                // the same as we do in the batched case. We get the response code from the actual HTTP response,
+                // as opposed to the batched case where it is returned as a "code" element.
+                JSONObject jsonObject = new JSONObject();
+                jsonObject.put(BODY_KEY, object);
+                int responseCode = (connection != null) ? connection.getResponseCode() : 200;
+                jsonObject.put(CODE_KEY, responseCode);
+
+                JSONArray jsonArray = new JSONArray();
+                jsonArray.put(jsonObject);
+
+                // Pretend we got an array of 1 back.
+                object = jsonArray;
+            } catch (JSONException e) {
+                responses.add(new Response(request, connection, new FuntownRequestError(connection, e)));
+            } catch (IOException e) {
+                responses.add(new Response(request, connection, new FuntownRequestError(connection, e)));
+            }
+        }
+
+        if (!(object instanceof JSONArray) || ((JSONArray) object).length() != numRequests) {
+        	FuntownException exception = new FuntownException("Unexpected number of results");
+            throw exception;
+        }
+
+        JSONArray jsonArray = (JSONArray) object;
+
+        for (int i = 0; i < jsonArray.length(); ++i) {
+            Request request = requests.get(i);
+            try {
+                Object obj = jsonArray.get(i);
+                responses.add(createResponseFromObject(request, connection, obj, isFromCache, originalResult));
+            } catch (JSONException e) {
+                responses.add(new Response(request, connection, new FuntownRequestError(connection, e)));
+            } catch (FuntownException e) {
+                responses.add(new Response(request, connection, new FuntownRequestError(connection, e)));
+            }
+        }
+
+        return responses;
+    }
+
+    private static Response createResponseFromObject(Request request, HttpURLConnection connection, Object object,
+            boolean isFromCache, Object originalResult) throws JSONException {
+        if (object instanceof JSONObject) {
+            JSONObject jsonObject = (JSONObject) object;
+
+            FuntownRequestError error =
+            		FuntownRequestError.checkResponseAndCreateError(jsonObject, originalResult, connection);
+            if (error != null) {
+                if (error.getErrorCode() == INVALID_SESSION_FACEBOOK_ERROR_CODE) {
+                    Session session = request.getSession();
+                    if (session != null) {
+                        session.closeAndClearTokenInformation();
+                    }
+                }
+                return new Response(request, connection, error);
+            }
+
+            Object body = Utility.getStringPropertyAsJSON(jsonObject, BODY_KEY, NON_JSON_RESPONSE_PROPERTY);
+
+            if (body instanceof JSONObject) {
+                GraphObject graphObject = GraphObject.Factory.create((JSONObject) body);
+                return new Response(request, connection, graphObject, isFromCache);
+            } else if (body instanceof JSONArray) {
+                GraphObjectList<GraphObject> graphObjectList = GraphObject.Factory.createList(
+                        (JSONArray) body, GraphObject.class);
+                return new Response(request, connection, graphObjectList, isFromCache);
+            }
+            // We didn't get a body we understand how to handle, so pretend we got nothing.
+            object = JSONObject.NULL;
+        }
+
+        if (object == JSONObject.NULL) {
+            return new Response(request, connection, (GraphObject)null, isFromCache);
+        } else {
+            throw new FuntownException("Got unexpected object type in response, class: "
+                    + object.getClass().getSimpleName());
+        }
+    }
+
+    static List<Response> constructErrorResponses(List<Request> requests, HttpURLConnection connection,
+    		FuntownException error) {
+        int count = requests.size();
+        List<Response> responses = new ArrayList<Response>(count);
+        for (int i = 0; i < count; ++i) {
+            Response response = new Response(requests.get(i), connection, new FuntownRequestError(connection, error));
+            responses.add(response);
+        }
+        return responses;
+    }
+
+    interface PagingInfo extends GraphObject {
+        String getNext();
+
+        String getPrevious();
+    }
+
+    interface PagedResults extends GraphObject {
+        GraphObjectList<GraphObject> getData();
+
+        PagingInfo getPaging();
+    }
+
+}
diff --git a/funtown/src/tw/com/funtown/Session.java b/funtown/src/tw/com/funtown/Session.java
new file mode 100644
index 000000000..d8fdd02fe
--- /dev/null
+++ b/funtown/src/tw/com/funtown/Session.java
@@ -0,0 +1,1915 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+import android.app.Activity;
+import android.content.*;
+import android.content.pm.ResolveInfo;
+import android.os.*;
+import android.support.v4.app.Fragment;
+import android.support.v4.content.LocalBroadcastManager;
+import android.util.Log;
+import tw.com.funtown.internal.SessionAuthorizationType;
+import tw.com.funtown.internal.Utility;
+import tw.com.funtown.internal.Validate;
+
+import java.io.*;
+import java.lang.ref.WeakReference;
+import java.util.*;
+
+/**
+ * <p>
+ * Session is used to authenticate a user and manage the user's session with
+ * Facebook.
+ * </p>
+ * <p>
+ * Sessions must be opened before they can be used to make a Request. When a
+ * Session is created, it attempts to initialize itself from a TokenCachingStrategy.
+ * Closing the session can optionally clear this cache.  The Session lifecycle
+ * uses {@link SessionState SessionState} to indicate its state.
+ * </p>
+ * <p>
+ * Instances of Session provide state change notification via a callback
+ * interface, {@link Session.StatusCallback StatusCallback}.
+ * </p>
+ */
+public class Session implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * The logging tag used by Session.
+     */
+    public static final String TAG = Session.class.getCanonicalName();
+
+    /**
+     * The default activity code used for authorization.
+     *
+     * @see #openForRead(OpenRequest)
+     *      open
+     */
+    public static final int DEFAULT_AUTHORIZE_ACTIVITY_CODE = 0xface;
+
+    /**
+     * If Session authorization fails and provides a web view error code, the
+     * web view error code is stored in the Bundle returned from
+     * {@link #getAuthorizationBundle getAuthorizationBundle} under this key.
+     */
+    public static final String WEB_VIEW_ERROR_CODE_KEY = "tw.com.funtown.sdk.WebViewErrorCode";
+
+    /**
+     * If Session authorization fails and provides a failing url, the failing
+     * url is stored in the Bundle returned from {@link #getAuthorizationBundle
+     * getAuthorizationBundle} under this key.
+     */
+    public static final String WEB_VIEW_FAILING_URL_KEY = "tw.com.funtown.sdk.FailingUrl";
+
+    /**
+     * The action used to indicate that the active session has been set. This should
+     * be used as an action in an IntentFilter and BroadcastReceiver registered with
+     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     */
+    public static final String ACTION_ACTIVE_SESSION_SET = "tw.com.funtown.sdk.ACTIVE_SESSION_SET";
+
+    /**
+     * The action used to indicate that the active session has been set to null. This should
+     * be used as an action in an IntentFilter and BroadcastReceiver registered with
+     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     */
+    public static final String ACTION_ACTIVE_SESSION_UNSET = "tw.com.funtown.sdk.ACTIVE_SESSION_UNSET";
+
+    /**
+     * The action used to indicate that the active session has been opened. This should
+     * be used as an action in an IntentFilter and BroadcastReceiver registered with
+     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     */
+    public static final String ACTION_ACTIVE_SESSION_OPENED = "tw.com.funtown.sdk.ACTIVE_SESSION_OPENED";
+
+    /**
+     * The action used to indicate that the active session has been closed. This should
+     * be used as an action in an IntentFilter and BroadcastReceiver registered with
+     * the {@link android.support.v4.content.LocalBroadcastManager}.
+     */
+    public static final String ACTION_ACTIVE_SESSION_CLOSED = "tw.com.funtown.sdk.ACTIVE_SESSION_CLOSED";
+
+    /**
+     * Session takes application id as a constructor parameter. If this is null,
+     * Session will attempt to load the application id from
+     * application/meta-data using this String as the key.
+     */
+    public static final String CLIENT_ID_PROPERTY = "tw.com.funtown.sdk.ClientId";
+    public static final String REDIRECT_URI_PROPERTY = "tw.com.funtown.sdk.RedirectUri";
+
+    private static final Object STATIC_LOCK = new Object();
+    private static Session activeSession;
+    private static volatile Context staticContext;
+
+    // Token extension constants
+    private static final int TOKEN_EXTEND_THRESHOLD_SECONDS = 24 * 60 * 60; // 1
+    // day
+    private static final int TOKEN_EXTEND_RETRY_SECONDS = 60 * 60; // 1 hour
+
+    private static final String SESSION_BUNDLE_SAVE_KEY = "tw.com.funtown.sdk.Session.saveSessionKey";
+    private static final String AUTH_BUNDLE_SAVE_KEY = "tw.com.funtown.sdk.Session.authBundleKey";
+    private static final String PUBLISH_PERMISSION_PREFIX = "publish";
+    private static final String MANAGE_PERMISSION_PREFIX = "manage";
+
+    @SuppressWarnings("serial")
+    private static final Set<String> OTHER_PUBLISH_PERMISSIONS = new HashSet<String>() {{
+        add("ads_management");
+        add("create_event");
+        add("rsvp_event");
+    }};
+
+    private String clientId;
+    private SessionState state;
+    private AccessToken tokenInfo;
+    private Date lastAttemptedTokenExtendDate = new Date(0);
+    private String redirectUri;
+    
+    private AuthorizationRequest pendingRequest;
+    private AuthorizationClient authorizationClient;
+
+    // The following are not serialized with the Session object
+    private volatile Bundle authorizationBundle;
+    private final List<StatusCallback> callbacks;
+    private Handler handler;
+    private AutoPublishAsyncTask autoPublishAsyncTask;
+    // This is the object that synchronizes access to state and tokenInfo
+    private final Object lock = new Object();
+    private TokenCachingStrategy tokenCachingStrategy;
+    private volatile TokenRefreshRequest currentTokenRefreshRequest;
+
+    /**
+     * Serialization proxy for the Session class. This is version 1 of
+     * serialization. Future serializations may differ in format. This
+     * class should not be modified. If serializations formats change,
+     * create a new class SerializationProxyVx.
+     */
+    private static class SerializationProxyV1 implements Serializable {
+        private static final long serialVersionUID = 7663436173185080063L;
+        private final String applicationId;
+        private final SessionState state;
+        private final AccessToken tokenInfo;
+        private final Date lastAttemptedTokenExtendDate;
+        private final boolean shouldAutoPublish;
+        private final AuthorizationRequest pendingRequest;
+
+        SerializationProxyV1(String applicationId, SessionState state,
+                AccessToken tokenInfo, Date lastAttemptedTokenExtendDate,
+                boolean shouldAutoPublish, AuthorizationRequest pendingRequest) {
+            this.applicationId = applicationId;
+            this.state = state;
+            this.tokenInfo = tokenInfo;
+            this.lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate;
+            this.shouldAutoPublish = shouldAutoPublish;
+            this.pendingRequest = pendingRequest;
+        }
+
+        private Object readResolve() {
+            return new Session(applicationId, state, tokenInfo,
+                    lastAttemptedTokenExtendDate, shouldAutoPublish, pendingRequest);
+        }
+    }
+
+    /**
+     * Used by version 1 of the serialization proxy, do not modify.
+     */
+    private Session(String applicationId, SessionState state,
+            AccessToken tokenInfo, Date lastAttemptedTokenExtendDate,
+            boolean shouldAutoPublish, AuthorizationRequest pendingRequest) {
+        this.clientId = applicationId;
+        this.state = state;
+        this.tokenInfo = tokenInfo;
+        this.lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate;
+        this.pendingRequest = pendingRequest;
+        handler = new Handler(Looper.getMainLooper());
+        currentTokenRefreshRequest = null;
+        tokenCachingStrategy = null;
+        callbacks = new ArrayList<StatusCallback>();
+    }
+
+    /**
+     * Initializes a new Session with the specified context.
+     *
+     * @param currentContext The Activity or Service creating this Session.
+     */
+    public Session(Context currentContext) {
+        this(currentContext, null, null, true);
+    }
+
+    Session(Context context, String applicationId, TokenCachingStrategy tokenCachingStrategy) {
+        this(context, applicationId, tokenCachingStrategy, true);
+    }
+
+    Session(Context context, String applicationId, TokenCachingStrategy tokenCachingStrategy,
+            boolean loadTokenFromCache) {
+        // if the application ID passed in is null, try to get it from the
+        // meta-data in the manifest.
+        if ((context != null) && (applicationId == null)) {
+            applicationId = Utility.getMetadataClientId(context);
+        }
+
+        Validate.notNull(applicationId, "applicationId");
+
+        if ((context != null) && (this.redirectUri == null)) {
+        	this.redirectUri = Utility.getMetadataRedirctUri(context);
+        }        
+        
+        initializeStaticContext(context);
+
+        if (tokenCachingStrategy == null) {
+            tokenCachingStrategy = new SharedPreferencesTokenCachingStrategy(staticContext);
+        }
+
+        this.clientId = applicationId;
+        this.tokenCachingStrategy = tokenCachingStrategy;
+        this.state = SessionState.CREATED;
+        this.pendingRequest = null;
+        this.callbacks = new ArrayList<StatusCallback>();
+        this.handler = new Handler(Looper.getMainLooper());
+
+        Bundle tokenState = loadTokenFromCache ? tokenCachingStrategy.load() : null;
+        if (TokenCachingStrategy.hasTokenInformation(tokenState)) {
+            Date cachedExpirationDate = TokenCachingStrategy
+                    .getDate(tokenState, TokenCachingStrategy.EXPIRATION_DATE_KEY);
+            Date now = new Date();
+
+            if ((cachedExpirationDate == null) || cachedExpirationDate.before(now)) {
+                // If expired or we require new permissions, clear out the
+                // current token cache.
+                tokenCachingStrategy.clear();
+                this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
+            } else {
+                // Otherwise we have a valid token, so use it.
+                this.tokenInfo = AccessToken.createFromCache(tokenState);
+                this.state = SessionState.CREATED_TOKEN_LOADED;
+            }
+        } else {
+            this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
+        }
+    }
+
+    /**
+     * Returns a Bundle containing data that was returned from Facebook during
+     * authorization.
+     *
+     * @return a Bundle containing data that was returned from Facebook during
+     *         authorization.
+     */
+    public final Bundle getAuthorizationBundle() {
+        synchronized (this.lock) {
+            return this.authorizationBundle;
+        }
+    }
+
+    /**
+     * Returns a boolean indicating whether the session is opened.
+     *
+     * @return a boolean indicating whether the session is opened.
+     */
+    public final boolean isOpened() {
+        synchronized (this.lock) {
+            return this.state.isOpened();
+        }
+    }
+
+    public final boolean isClosed() {
+        synchronized (this.lock) {
+            return this.state.isClosed();
+        }
+    }
+
+    /**
+     * Returns the current state of the Session.
+     * See {@link SessionState} for details.
+     *
+     * @return the current state of the Session.
+     */
+    public final SessionState getState() {
+        synchronized (this.lock) {
+            return this.state;
+        }
+    }
+
+    /**
+     * Returns the application id associated with this Session.
+     *
+     * @return the application id associated with this Session.
+     */
+    public final String getApplicationId() {
+        return this.clientId;
+    }
+
+    /**
+     * Returns the access token String.
+     *
+     * @return the access token String, or null if there is no access token
+     */
+    public final String getAccessToken() {
+        synchronized (this.lock) {
+            return (this.tokenInfo == null) ? null : this.tokenInfo.getToken();
+        }
+    }
+
+    /**
+     * <p>
+     * Returns the Date at which the current token will expire.
+     * </p>
+     * <p>
+     * Note that Session automatically attempts to extend the lifetime of Tokens
+     * as needed when Facebook requests are made.
+     * </p>
+     *
+     * @return the Date at which the current token will expire, or null if there is no access token
+     */
+    public final Date getExpirationDate() {
+        synchronized (this.lock) {
+            return (this.tokenInfo == null) ? null : this.tokenInfo.getExpires();
+        }
+    }
+
+    /**
+     * <p>
+     * Returns the list of permissions associated with the session.
+     * </p>
+     * <p>
+     * If there is a valid token, this represents the permissions granted by
+     * that token. This can change during calls to
+     * {@link #requestNewReadPermissions}
+     * or {@link #requestNewPublishPermissions}.
+     * </p>
+     *
+     * @return the list of permissions associated with the session, or null if there is no access token
+     */
+    public final List<String> getPermissions() {
+        synchronized (this.lock) {
+            return (this.tokenInfo == null) ? null : this.tokenInfo.getPermissions();
+        }
+    }
+
+    /**
+     * <p>
+     * Logs a user in to Facebook.
+     * </p>
+     * <p>
+     * A session may not be used with {@link Request Request} and other classes
+     * in the SDK until it is open. If, prior to calling open, the session is in
+     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
+     * state, and the requested permissions are a subset of the previously authorized
+     * permissions, then the Session becomes usable immediately with no user interaction.
+     * </p>
+     * <p>
+     * The permissions associated with the openRequest passed to this method must
+     * be read permissions only (or null/empty). It is not allowed to pass publish
+     * permissions to this method and will result in an exception being thrown.
+     * </p>
+     * <p>
+     * Any open method must be called at most once, and cannot be called after the
+     * Session is closed. Calling the method at an invalid time will result in
+     * UnsuportedOperationException.
+     * </p>
+     *
+     * @param openRequest the open request, can be null only if the Session is in the
+     *                    {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
+     * @throws FuntownException if any publish or manage permissions are requested
+     */
+    public final void openForRead(OpenRequest openRequest) {
+        open(openRequest, SessionAuthorizationType.READ);
+    }
+
+    /**
+     * <p>
+     * Logs a user in to Facebook.
+     * </p>
+     * <p>
+     * A session may not be used with {@link Request Request} and other classes
+     * in the SDK until it is open. If, prior to calling open, the session is in
+     * the {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED}
+     * state, and the requested permissions are a subset of the previously authorized
+     * permissions, then the Session becomes usable immediately with no user interaction.
+     * </p>
+     * <p>
+     * The permissions associated with the openRequest passed to this method must
+     * be publish or manage permissions only and must be non-empty. Any read permissions
+     * will result in a warning, and may fail during server-side authorization.
+     * </p>
+     * <p>
+     * Any open method must be called at most once, and cannot be called after the
+     * Session is closed. Calling the method at an invalid time will result in
+     * UnsuportedOperationException.
+     * </p>
+     *
+     * @param openRequest the open request, can be null only if the Session is in the
+     *                    {@link SessionState#CREATED_TOKEN_LOADED CREATED_TOKEN_LOADED} state
+     * @throws FuntownException if the passed in request is null or has no permissions set.
+     */
+    public final void openForPublish(OpenRequest openRequest) {
+        open(openRequest, SessionAuthorizationType.PUBLISH);
+    }
+
+    /**
+     * Opens a session based on an existing Facebook access token. This method should be used
+     * only in instances where an application has previously obtained an access token and wishes
+     * to import it into the Session/TokenCachingStrategy-based session-management system. An
+     * example would be an application which previously did not use the Facebook SDK for Android
+     * and implemented its own session-management scheme, but wishes to implement an upgrade path
+     * for existing users so they do not need to log in again when upgrading to a version of
+     * the app that uses the SDK.
+     * <p/>
+     * No validation is done that the token, token source, or permissions are actually valid.
+     * It is the caller's responsibility to ensure that these accurately reflect the state of
+     * the token that has been passed in, or calls to the Facebook API may fail.
+     *
+     * @param accessToken the access token obtained from Facebook
+     * @param callback    a callback that will be called when the session status changes; may be null
+     */
+    public final void open(AccessToken accessToken, StatusCallback callback) {
+        synchronized (this.lock) {
+            if (pendingRequest != null) {
+                throw new UnsupportedOperationException(
+                        "Session: an attempt was made to open a session that has a pending request.");
+            }
+
+            if (state != SessionState.CREATED && state != SessionState.CREATED_TOKEN_LOADED) {
+                throw new UnsupportedOperationException(
+                        "Session: an attempt was made to open an already opened session.");
+            }
+
+            if (callback != null) {
+                addCallback(callback);
+            }
+
+            this.tokenInfo = accessToken;
+
+            if (this.tokenCachingStrategy != null) {
+                this.tokenCachingStrategy.save(accessToken.toCacheBundle());
+            }
+
+            final SessionState oldState = state;
+            state = SessionState.OPENED;
+            this.postStateChange(oldState, state, null);
+        }
+
+        autoPublishAsync();
+    }
+
+    /**
+     * <p>
+     * Issues a request to add new read permissions to the Session.
+     * </p>
+     * <p>
+     * If successful, this will update the set of permissions on this session to
+     * match the newPermissions. If this fails, the Session remains unchanged.
+     * </p>
+     * <p>
+     * The permissions associated with the newPermissionsRequest passed to this method must
+     * be read permissions only (or null/empty). It is not allowed to pass publish
+     * permissions to this method and will result in an exception being thrown.
+     * </p>
+     *
+     * @param newPermissionsRequest the new permissions request
+     */
+    public final void requestNewReadPermissions(NewPermissionsRequest newPermissionsRequest) {
+        requestNewPermissions(newPermissionsRequest, SessionAuthorizationType.READ);
+    }
+
+    /**
+     * <p>
+     * Issues a request to add new publish or manage permissions to the Session.
+     * </p>
+     * <p>
+     * If successful, this will update the set of permissions on this session to
+     * match the newPermissions. If this fails, the Session remains unchanged.
+     * </p>
+     * <p>
+     * The permissions associated with the newPermissionsRequest passed to this method must
+     * be publish or manage permissions only and must be non-empty. Any read permissions
+     * will result in a warning, and may fail during server-side authorization.
+     * </p>
+     *
+     * @param newPermissionsRequest the new permissions request
+     */
+    public final void requestNewPublishPermissions(NewPermissionsRequest newPermissionsRequest) {
+        requestNewPermissions(newPermissionsRequest, SessionAuthorizationType.PUBLISH);
+    }
+
+    /**
+     * Provides an implementation for {@link Activity#onActivityResult
+     * onActivityResult} that updates the Session based on information returned
+     * during the authorization flow. The Activity that calls open or
+     * requestNewPermissions should forward the resulting onActivityResult call here to
+     * update the Session state based on the contents of the resultCode and
+     * data.
+     *
+     * @param currentActivity The Activity that is forwarding the onActivityResult call.
+     * @param requestCode     The requestCode parameter from the forwarded call. When this
+     *                        onActivityResult occurs as part of Facebook authorization
+     *                        flow, this value is the activityCode passed to open or
+     *                        authorize.
+     * @param resultCode      An int containing the resultCode parameter from the forwarded
+     *                        call.
+     * @param data            The Intent passed as the data parameter from the forwarded
+     *                        call.
+     * @return A boolean indicating whether the requestCode matched a pending
+     *         authorization request for this Session.
+     */
+    public final boolean onActivityResult(Activity currentActivity, int requestCode, int resultCode, Intent data) {
+        Validate.notNull(currentActivity, "currentActivity");
+
+        initializeStaticContext(currentActivity);
+
+        synchronized (lock) {
+            if (pendingRequest == null || (requestCode != pendingRequest.getRequestCode())) {
+                return false;
+            }
+        }
+
+        AccessToken newToken = null;
+        Exception exception = null;
+
+        if (data != null) {
+            AuthorizationClient.Result result = (AuthorizationClient.Result) data.getSerializableExtra(
+                    LoginActivity.RESULT_KEY);
+            if (result != null) {
+                // This came from LoginActivity.
+                handleAuthorizationResult(resultCode, result);
+                return true;
+            } else if (authorizationClient != null) {
+                // Delegate to the auth client.
+                authorizationClient.onActivityResult(requestCode, resultCode, data);
+                return true;
+            }
+        } else if (resultCode == Activity.RESULT_CANCELED) {
+            exception = new FuntownOperationCanceledException("User canceled operation.");
+        }
+
+        finishAuthOrReauth(newToken, exception);
+        return true;
+    }
+
+    /**
+     * Closes the local in-memory Session object, but does not clear the
+     * persisted token cache.
+     */
+    @SuppressWarnings("incomplete-switch")
+    public final void close() {
+        synchronized (this.lock) {
+            final SessionState oldState = this.state;
+
+            switch (this.state) {
+                case CREATED:
+                case OPENING:
+                    this.state = SessionState.CLOSED_LOGIN_FAILED;
+                    postStateChange(oldState, this.state, new FuntownException(
+                            "Log in attempt aborted."));
+                    break;
+
+                case CREATED_TOKEN_LOADED:
+                case OPENED:
+                case OPENED_TOKEN_UPDATED:
+                    this.state = SessionState.CLOSED;
+                    postStateChange(oldState, this.state, null);
+                    break;
+            }
+        }
+    }
+
+    /**
+     * Closes the local in-memory Session object and clears any persisted token
+     * cache related to the Session.
+     */
+    public final void closeAndClearTokenInformation() {
+        if (this.tokenCachingStrategy != null) {
+            this.tokenCachingStrategy.clear();
+        }
+        Utility.clearFuntownCookies(staticContext);
+        close();
+    }
+
+    /**
+     * Adds a callback that will be called when the state of this Session changes.
+     *
+     * @param callback the callback
+     */
+    public final void addCallback(StatusCallback callback) {
+        synchronized (callbacks) {
+            if (callback != null && !callbacks.contains(callback)) {
+                callbacks.add(callback);
+            }
+        }
+    }
+
+    /**
+     * Removes a StatusCallback from this Session.
+     *
+     * @param callback the callback
+     */
+    public final void removeCallback(StatusCallback callback) {
+        synchronized (callbacks) {
+            callbacks.remove(callback);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder().append("{Session").append(" state:").append(this.state).append(", token:")
+                .append((this.tokenInfo == null) ? "null" : this.tokenInfo).append(", appId:")
+                .append((this.clientId == null) ? "null" : this.clientId).append("}").toString();
+    }
+
+    void extendTokenCompleted(Bundle bundle) {
+        synchronized (this.lock) {
+            final SessionState oldState = this.state;
+
+            switch (this.state) {
+                case OPENED:
+                    this.state = SessionState.OPENED_TOKEN_UPDATED;
+                    postStateChange(oldState, this.state, null);
+                    break;
+                case OPENED_TOKEN_UPDATED:
+                    break;
+                default:
+                    // Silently ignore attempts to refresh token if we are not open
+                    Log.d(TAG, "refreshToken ignored in state " + this.state);
+                    return;
+            }
+            this.tokenInfo = AccessToken.createFromRefresh(this.tokenInfo, bundle);
+            if (this.tokenCachingStrategy != null) {
+                this.tokenCachingStrategy.save(this.tokenInfo.toCacheBundle());
+            }
+        }
+    }
+
+    private Object writeReplace() {
+        return new SerializationProxyV1(clientId, state, tokenInfo,
+                lastAttemptedTokenExtendDate, false, pendingRequest);
+    }
+
+    // have a readObject that throws to prevent spoofing
+    private void readObject(ObjectInputStream stream) throws InvalidObjectException {
+        throw new InvalidObjectException("Cannot readObject, serialization proxy required");
+    }
+
+    /**
+     * Save the Session object into the supplied Bundle.
+     *
+     * @param session the Session to save
+     * @param bundle  the Bundle to save the Session to
+     */
+    public static final void saveSession(Session session, Bundle bundle) {
+        if (bundle != null && session != null && !bundle.containsKey(SESSION_BUNDLE_SAVE_KEY)) {
+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+            try {
+                new ObjectOutputStream(outputStream).writeObject(session);
+            } catch (IOException e) {
+                throw new FuntownException("Unable to save session.", e);
+            }
+            bundle.putByteArray(SESSION_BUNDLE_SAVE_KEY, outputStream.toByteArray());
+            bundle.putBundle(AUTH_BUNDLE_SAVE_KEY, session.authorizationBundle);
+        }
+    }
+
+    /**
+     * Restores the saved session from a Bundle, if any. Returns the restored Session or
+     * null if it could not be restored.
+     *
+     * @param context         the Activity or Service creating the Session, must not be null
+     * @param cachingStrategy the TokenCachingStrategy to use to load and store the token. If this is
+     *                        null, a default token cachingStrategy that stores data in
+     *                        SharedPreferences will be used
+     * @param callback        the callback to notify for Session state changes, can be null
+     * @param bundle          the bundle to restore the Session from
+     * @return the restored Session, or null
+     */
+    public static final Session restoreSession(
+            Context context, TokenCachingStrategy cachingStrategy, StatusCallback callback, Bundle bundle) {
+        if (bundle == null) {
+            return null;
+        }
+        byte[] data = bundle.getByteArray(SESSION_BUNDLE_SAVE_KEY);
+        if (data != null) {
+            ByteArrayInputStream is = new ByteArrayInputStream(data);
+            try {
+                Session session = (Session) (new ObjectInputStream(is)).readObject();
+                initializeStaticContext(context);
+                if (cachingStrategy != null) {
+                    session.tokenCachingStrategy = cachingStrategy;
+                } else {
+                    session.tokenCachingStrategy = new SharedPreferencesTokenCachingStrategy(context);
+                }
+                if (callback != null) {
+                    session.addCallback(callback);
+                }
+                session.authorizationBundle = bundle.getBundle(AUTH_BUNDLE_SAVE_KEY);
+                return session;
+            } catch (ClassNotFoundException e) {
+                Log.w(TAG, "Unable to restore session", e);
+            } catch (IOException e) {
+                Log.w(TAG, "Unable to restore session.", e);
+            }
+        }
+        return null;
+    }
+
+
+    /**
+     * Returns the current active Session, or null if there is none.
+     *
+     * @return the current active Session, or null if there is none.
+     */
+    public static final Session getActiveSession() {
+        synchronized (Session.STATIC_LOCK) {
+            return Session.activeSession;
+        }
+    }
+
+    /**
+     * <p>
+     * Sets the current active Session.
+     * </p>
+     * <p>
+     * The active Session is used implicitly by predefined Request factory
+     * methods as well as optionally by UI controls in the sdk.
+     * </p>
+     * <p>
+     * It is legal to set this to null, or to a Session that is not yet open.
+     * </p>
+     *
+     * @param session A Session to use as the active Session, or null to indicate
+     *                that there is no active Session.
+     */
+    public static final void setActiveSession(Session session) {
+        synchronized (Session.STATIC_LOCK) {
+            if (session != Session.activeSession) {
+                Session oldSession = Session.activeSession;
+
+                if (oldSession != null) {
+                    oldSession.close();
+                }
+
+                Session.activeSession = session;
+
+                if (oldSession != null) {
+                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+                }
+
+                if (session != null) {
+                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_SET);
+
+                    if (session.isOpened()) {
+                        postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Create a new Session, and if a token cache is available, open the
+     * Session and make it active without any user interaction.
+     *
+     * @param context The Context creating this session
+     * @return The new session or null if one could not be created
+     */
+    public static Session openActiveSessionFromCache(Context context) {
+        return openActiveSession(context, false, null);
+    }
+
+    /**
+     * If allowLoginUI is true, this will create a new Session, make it active, and
+     * open it. If the default token cache is not available, then this will request
+     * basic permissions. If the default token cache is available and cached tokens
+     * are loaded, this will use the cached token and associated permissions.
+     * <p/>
+     * If allowedLoginUI is false, this will only create the active session and open
+     * it if it requires no user interaction (i.e. the token cache is available and
+     * there are cached tokens).
+     *
+     * @param activity     The Activity that is opening the new Session.
+     * @param allowLoginUI if false, only sets the active session and opens it if it
+     *                     does not require user interaction
+     * @param callback     The {@link StatusCallback SessionStatusCallback} to
+     *                     notify regarding Session state changes. May be null.
+     * @return The new Session or null if one could not be created
+     */
+    public static Session openActiveSession(Activity activity, boolean allowLoginUI,
+            StatusCallback callback) {
+        return openActiveSession(activity, allowLoginUI, new OpenRequest(activity).setCallback(callback));
+    }
+
+    /**
+     * If allowLoginUI is true, this will create a new Session, make it active, and
+     * open it. If the default token cache is not available, then this will request
+     * basic permissions. If the default token cache is available and cached tokens
+     * are loaded, this will use the cached token and associated permissions.
+     * <p/>
+     * If allowedLoginUI is false, this will only create the active session and open
+     * it if it requires no user interaction (i.e. the token cache is available and
+     * there are cached tokens).
+     *
+     * @param context      The Activity or Service creating this Session
+     * @param fragment     The Fragment that is opening the new Session.
+     * @param allowLoginUI if false, only sets the active session and opens it if it
+     *                     does not require user interaction
+     * @param callback     The {@link StatusCallback SessionStatusCallback} to
+     *                     notify regarding Session state changes.
+     * @return The new Session or null if one could not be created
+     */
+    public static Session openActiveSession(Context context, Fragment fragment,
+            boolean allowLoginUI, StatusCallback callback) {
+        return openActiveSession(context, allowLoginUI, new OpenRequest(fragment).setCallback(callback));
+    }
+
+    /**
+     * Opens a session based on an existing Facebook access token, and also makes this session
+     * the currently active session. This method should be used
+     * only in instances where an application has previously obtained an access token and wishes
+     * to import it into the Session/TokenCachingStrategy-based session-management system. A primary
+     * example would be an application which previously did not use the Facebook SDK for Android
+     * and implemented its own session-management scheme, but wishes to implement an upgrade path
+     * for existing users so they do not need to log in again when upgrading to a version of
+     * the app that uses the SDK. In general, this method will be called only once, when the app
+     * detects that it has been upgraded -- after that, the usual Session lifecycle methods
+     * should be used to manage the session and its associated token.
+     * <p/>
+     * No validation is done that the token, token source, or permissions are actually valid.
+     * It is the caller's responsibility to ensure that these accurately reflect the state of
+     * the token that has been passed in, or calls to the Facebook API may fail.
+     *
+     * @param context     the Context to use for creation the session
+     * @param accessToken the access token obtained from Facebook
+     * @param callback    a callback that will be called when the session status changes; may be null
+     * @return The new Session or null if one could not be created
+     */
+    public static Session openActiveSessionWithAccessToken(Context context, AccessToken accessToken,
+            StatusCallback callback) {
+        Session session = new Session(context, null, null, false);
+
+        setActiveSession(session);
+        session.open(accessToken, callback);
+
+        return session;
+    }
+
+    private static Session openActiveSession(Context context, boolean allowLoginUI, OpenRequest openRequest) {
+        Session session = new Builder(context).build();
+        if (SessionState.CREATED_TOKEN_LOADED.equals(session.getState()) || allowLoginUI) {
+            setActiveSession(session);
+            session.openForRead(openRequest);
+            return session;
+        }
+        return null;
+    }
+
+    static Context getStaticContext() {
+        return staticContext;
+    }
+
+    static void initializeStaticContext(Context currentContext) {
+        if ((currentContext != null) && (staticContext == null)) {
+            Context applicationContext = currentContext.getApplicationContext();
+            staticContext = (applicationContext != null) ? applicationContext : currentContext;
+        }
+    }
+
+    void authorize(AuthorizationRequest request) {
+        boolean started = false;
+
+        request.setApplicationId(clientId);
+        request.setRedirectUri(redirectUri);
+        
+        autoPublishAsync();
+
+        started = tryLoginActivity(request);
+
+        if (!started && request.isLegacy) {
+            started = tryLegacyAuth(request);
+        }
+
+        if (!started) {
+            synchronized (this.lock) {
+                final SessionState oldState = this.state;
+
+                switch (this.state) {
+                    case CLOSED:
+                    case CLOSED_LOGIN_FAILED:
+                        return;
+
+                    default:
+                        this.state = SessionState.CLOSED_LOGIN_FAILED;
+                        postStateChange(oldState, this.state, new FuntownException("Log in attempt failed."));
+                }
+            }
+        }
+    }
+
+    private void open(OpenRequest openRequest, SessionAuthorizationType authType) {
+        validatePermissions(openRequest, authType);
+        validateLoginBehavior(openRequest);
+
+        SessionState newState;
+        synchronized (this.lock) {
+            if (pendingRequest != null) {
+                postStateChange(state, state, new UnsupportedOperationException(
+                        "Session: an attempt was made to open a session that has a pending request."));
+                return;
+            }
+            final SessionState oldState = this.state;
+
+            switch (this.state) {
+                case CREATED:
+                    this.state = newState = SessionState.OPENING;
+                    if (openRequest == null) {
+                        throw new IllegalArgumentException("openRequest cannot be null when opening a new Session");
+                    }
+                    pendingRequest = openRequest;
+                    break;
+                case CREATED_TOKEN_LOADED:
+                    if (openRequest != null && !Utility.isNullOrEmpty(openRequest.getPermissions())) {
+                        if (!Utility.isSubset(openRequest.getPermissions(), getPermissions())) {
+                            pendingRequest = openRequest;
+                        }
+                    }
+                    if (pendingRequest == null) {
+                        this.state = newState = SessionState.OPENED;
+                    } else {
+                        this.state = newState = SessionState.OPENING;
+                    }
+                    break;
+                default:
+                    throw new UnsupportedOperationException(
+                            "Session: an attempt was made to open an already opened session.");
+            }
+            if (openRequest != null) {
+                addCallback(openRequest.getCallback());
+            }
+            this.postStateChange(oldState, newState, null);
+        }
+
+        if (newState == SessionState.OPENING) {
+            authorize(openRequest);
+        }
+    }
+
+    private void requestNewPermissions(NewPermissionsRequest newPermissionsRequest, SessionAuthorizationType authType) {
+        validatePermissions(newPermissionsRequest, authType);
+        validateLoginBehavior(newPermissionsRequest);
+
+        if (newPermissionsRequest != null) {
+            synchronized (this.lock) {
+                if (pendingRequest != null) {
+                    throw new UnsupportedOperationException(
+                            "Session: an attempt was made to request new permissions for a session that has a pending request.");
+                }
+                switch (this.state) {
+                    case OPENED:
+                    case OPENED_TOKEN_UPDATED:
+                        pendingRequest = newPermissionsRequest;
+                        break;
+                    default:
+                        throw new UnsupportedOperationException(
+                                "Session: an attempt was made to request new permissions for a session that is not currently open.");
+                }
+            }
+
+            newPermissionsRequest.setValidateSameFbidAsToken(getAccessToken());
+            authorize(newPermissionsRequest);
+        }
+    }
+
+    private void validateLoginBehavior(AuthorizationRequest request) {
+        if (request != null && !request.isLegacy) {
+            Intent intent = new Intent();
+            intent.setClass(getStaticContext(), LoginActivity.class);
+            if (!resolveIntent(intent)) {
+                throw new FuntownException(String.format(
+                        "Cannot use SessionLoginBehavior %s when %s is not declared as an activity in AndroidManifest.xml",
+                        request.getLoginBehavior(), LoginActivity.class.getName()));
+            }
+        }
+    }
+
+    private void validatePermissions(AuthorizationRequest request, SessionAuthorizationType authType) {
+        if (request == null || Utility.isNullOrEmpty(request.getPermissions())) {
+            if (SessionAuthorizationType.PUBLISH.equals(authType)) {
+                throw new FuntownException("Cannot request publish or manage authorization with no permissions.");
+            }
+            return; // nothing to check
+        }
+        for (String permission : request.getPermissions()) {
+            if (isPublishPermission(permission)) {
+                if (SessionAuthorizationType.READ.equals(authType)) {
+                    throw new FuntownException(
+                            String.format(
+                                    "Cannot pass a publish or manage permission (%s) to a request for read authorization",
+                                    permission));
+                }
+            } else {
+                if (SessionAuthorizationType.PUBLISH.equals(authType)) {
+                    Log.w(TAG,
+                            String.format(
+                                    "Should not pass a read permission (%s) to a request for publish or manage authorization",
+                                    permission));
+                }
+            }
+        }
+    }
+
+    static boolean isPublishPermission(String permission) {
+        return permission != null &&
+                (permission.startsWith(PUBLISH_PERMISSION_PREFIX) ||
+                        permission.startsWith(MANAGE_PERMISSION_PREFIX) ||
+                        OTHER_PUBLISH_PERMISSIONS.contains(permission));
+
+    }
+
+    private void handleAuthorizationResult(int resultCode, AuthorizationClient.Result result) {
+        AccessToken newToken = null;
+        Exception exception = null;
+        if (resultCode == Activity.RESULT_OK) {
+            if (result.code == AuthorizationClient.Result.Code.SUCCESS) {
+                newToken = result.token;
+            } else {
+                exception = new FuntownAuthorizationException(result.errorMessage);
+            }
+        } else if (resultCode == Activity.RESULT_CANCELED) {
+            exception = new FuntownOperationCanceledException(result.errorMessage);
+        }
+
+        authorizationClient = null;
+        finishAuthOrReauth(newToken, exception);
+    }
+
+    private boolean tryLoginActivity(AuthorizationRequest request) {
+        Intent intent = getLoginActivityIntent(request);
+
+        if (!resolveIntent(intent)) {
+            return false;
+        }
+
+        try {
+            request.getStartActivityDelegate().startActivityForResult(intent, request.getRequestCode());
+        } catch (ActivityNotFoundException e) {
+            return false;
+        }
+
+        return true;
+    }
+
+    private boolean resolveIntent(Intent intent) {
+        ResolveInfo resolveInfo = getStaticContext().getPackageManager().resolveActivity(intent, 0);
+        if (resolveInfo == null) {
+            return false;
+        }
+        return true;
+    }
+
+    private Intent getLoginActivityIntent(AuthorizationRequest request) {
+        Intent intent = new Intent();
+        intent.setClass(getStaticContext(), LoginActivity.class);
+        intent.setAction(request.getLoginBehavior().toString());
+
+        // Let LoginActivity populate extras appropriately
+        AuthorizationClient.AuthorizationRequest authClientRequest = request.getAuthorizationClientRequest();
+        Bundle extras = LoginActivity.populateIntentExtras(authClientRequest);
+        intent.putExtras(extras);
+
+        return intent;
+    }
+
+    private boolean tryLegacyAuth(final AuthorizationRequest request) {
+        authorizationClient = new AuthorizationClient();
+        authorizationClient.setOnCompletedListener(new AuthorizationClient.OnCompletedListener() {
+            @Override
+            public void onCompleted(AuthorizationClient.Result result) {
+                int activityResult;
+                if (result.code == AuthorizationClient.Result.Code.CANCEL) {
+                    activityResult = Activity.RESULT_CANCELED;
+                } else {
+                    activityResult = Activity.RESULT_OK;
+                }
+                handleAuthorizationResult(activityResult, result);
+            }
+        });
+        authorizationClient.setContext(getStaticContext());
+        authorizationClient.startOrContinueAuth(request.getAuthorizationClientRequest());
+
+        return true;
+    }
+
+    @SuppressWarnings("incomplete-switch")
+    void finishAuthOrReauth(AccessToken newToken, Exception exception) {
+        // If the token we came up with is expired/invalid, then auth failed.
+        if ((newToken != null) && newToken.isInvalid()) {
+            newToken = null;
+            exception = new FuntownException("Invalid access token.");
+        }
+
+        synchronized (this.lock) {
+            switch (this.state) {
+                case OPENING:
+                    // This means we are authorizing for the first time in this Session.
+                    finishAuthorization(newToken, exception);
+                    break;
+
+                case OPENED:
+                case OPENED_TOKEN_UPDATED:
+                    // This means we are reauthorizing.
+                    finishReauthorization(newToken, exception);
+
+                    break;
+            }
+        }
+    }
+
+    private void finishAuthorization(AccessToken newToken, Exception exception) {
+        final SessionState oldState = state;
+        if (newToken != null) {
+            tokenInfo = newToken;
+            saveTokenToCache(newToken);
+
+            state = SessionState.OPENED;
+        } else if (exception != null) {
+            state = SessionState.CLOSED_LOGIN_FAILED;
+        }
+        pendingRequest = null;
+        postStateChange(oldState, state, exception);
+    }
+
+    private void finishReauthorization(final AccessToken newToken, Exception exception) {
+        final SessionState oldState = state;
+
+        if (newToken != null) {
+            tokenInfo = newToken;
+            saveTokenToCache(newToken);
+
+            state = SessionState.OPENED_TOKEN_UPDATED;
+        }
+
+        pendingRequest = null;
+        postStateChange(oldState, state, exception);
+    }
+
+    private void saveTokenToCache(AccessToken newToken) {
+        if (newToken != null && tokenCachingStrategy != null) {
+            tokenCachingStrategy.save(newToken.toCacheBundle());
+        }
+    }
+
+    void postStateChange(final SessionState oldState, final SessionState newState, final Exception exception) {
+        // When we request new permissions, we stay in SessionState.OPENED_TOKEN_UPDATED,
+        // but we still want notifications of the state change since permissions are
+        // different now.
+        if ((oldState == newState) &&
+                (oldState != SessionState.OPENED_TOKEN_UPDATED) &&
+                (exception == null)) {
+            return;
+        }
+
+        if (newState.isClosed()) {
+            this.tokenInfo = AccessToken.createEmptyToken(Collections.<String>emptyList());
+        }
+
+        synchronized (callbacks) {
+            // Need to schedule the callbacks inside the same queue to preserve ordering.
+            // Otherwise these callbacks could have been added to the queue before the SessionTracker
+            // gets the ACTIVE_SESSION_SET action.
+            Runnable runCallbacks = new Runnable() {
+                public void run() {
+                    for (final StatusCallback callback : callbacks) {
+                        Runnable closure = new Runnable() {
+                            public void run() {
+                                // This can be called inside a synchronized block.
+                                callback.call(Session.this, newState, exception);
+                            }
+                        };
+
+                        runWithHandlerOrExecutor(handler, closure);
+                    }
+                }
+            };
+            runWithHandlerOrExecutor(handler, runCallbacks);
+        }
+
+        if (this == Session.activeSession) {
+            if (oldState.isOpened() != newState.isOpened()) {
+                if (newState.isOpened()) {
+                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_OPENED);
+                } else {
+                    postActiveSessionAction(Session.ACTION_ACTIVE_SESSION_CLOSED);
+                }
+            }
+        }
+    }
+
+    static void postActiveSessionAction(String action) {
+        final Intent intent = new Intent(action);
+
+        LocalBroadcastManager.getInstance(getStaticContext()).sendBroadcast(intent);
+    }
+
+    private static void runWithHandlerOrExecutor(Handler handler, Runnable runnable) {
+        if (handler != null) {
+            handler.post(runnable);
+        } else {
+            Settings.getExecutor().execute(runnable);
+        }
+    }
+
+    void extendAccessTokenIfNeeded() {
+        if (shouldExtendAccessToken()) {
+            extendAccessToken();
+        }
+    }
+
+    void extendAccessToken() {
+        TokenRefreshRequest newTokenRefreshRequest = null;
+        synchronized (this.lock) {
+            if (currentTokenRefreshRequest == null) {
+                newTokenRefreshRequest = new TokenRefreshRequest();
+                currentTokenRefreshRequest = newTokenRefreshRequest;
+            }
+        }
+
+        if (newTokenRefreshRequest != null) {
+            newTokenRefreshRequest.bind();
+        }
+    }
+
+    boolean shouldExtendAccessToken() {
+        if (currentTokenRefreshRequest != null) {
+            return false;
+        }
+
+        boolean result = false;
+
+        Date now = new Date();
+
+        if (state.isOpened() && tokenInfo.getSource().canExtendToken()
+                && now.getTime() - lastAttemptedTokenExtendDate.getTime() > TOKEN_EXTEND_RETRY_SECONDS * 1000
+                && now.getTime() - tokenInfo.getLastRefresh().getTime() > TOKEN_EXTEND_THRESHOLD_SECONDS * 1000) {
+            result = true;
+        }
+
+        return result;
+    }
+
+    AccessToken getTokenInfo() {
+        return tokenInfo;
+    }
+
+    void setTokenInfo(AccessToken tokenInfo) {
+        this.tokenInfo = tokenInfo;
+    }
+
+    Date getLastAttemptedTokenExtendDate() {
+        return lastAttemptedTokenExtendDate;
+    }
+
+    void setLastAttemptedTokenExtendDate(Date lastAttemptedTokenExtendDate) {
+        this.lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate;
+    }
+
+    void setCurrentTokenRefreshRequest(TokenRefreshRequest request) {
+        this.currentTokenRefreshRequest = request;
+    }
+
+    class TokenRefreshRequest implements ServiceConnection {
+
+        final Messenger messageReceiver = new Messenger(
+                new TokenRefreshRequestHandler(Session.this, this));
+
+        Messenger messageSender = null;
+
+        public void bind() {
+            Intent intent = NativeProtocol.createTokenRefreshIntent(getStaticContext());
+            if (intent != null
+                    && staticContext.bindService(intent, new TokenRefreshRequest(), Context.BIND_AUTO_CREATE)) {
+                setLastAttemptedTokenExtendDate(new Date());
+            } else {
+                cleanup();
+            }
+        }
+
+        @Override
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            messageSender = new Messenger(service);
+            refreshToken();
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName arg) {
+            cleanup();
+
+            // We returned an error so there's no point in
+            // keeping the binding open.
+            staticContext.unbindService(TokenRefreshRequest.this);
+        }
+
+        private void cleanup() {
+            if (currentTokenRefreshRequest == this) {
+                currentTokenRefreshRequest = null;
+            }
+        }
+
+        private void refreshToken() {
+            Bundle requestData = new Bundle();
+            requestData.putString(AccessToken.ACCESS_TOKEN_KEY, getTokenInfo().getToken());
+
+            Message request = Message.obtain();
+            request.setData(requestData);
+            request.replyTo = messageReceiver;
+
+            try {
+                messageSender.send(request);
+            } catch (RemoteException e) {
+                cleanup();
+            }
+        }
+
+    }
+
+    // Creating a static Handler class to reduce the possibility of a memory leak.
+    // Handler objects for the same thread all share a common Looper object, which they post messages
+    // to and read from. As messages contain target Handler, as long as there are messages with target
+    // handler in the message queue, the handler cannot be garbage collected. If handler is not static,
+    // the instance of the containing class also cannot be garbage collected even if it is destroyed.
+    static class TokenRefreshRequestHandler extends Handler {
+
+        private WeakReference<Session> sessionWeakReference;
+        private WeakReference<TokenRefreshRequest> refreshRequestWeakReference;
+
+        TokenRefreshRequestHandler(Session session, TokenRefreshRequest refreshRequest) {
+            super(Looper.getMainLooper());
+            sessionWeakReference = new WeakReference<Session>(session);
+            refreshRequestWeakReference = new WeakReference<TokenRefreshRequest>(refreshRequest);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            String token = msg.getData().getString(AccessToken.ACCESS_TOKEN_KEY);
+            Session session = sessionWeakReference.get();
+
+            if (session != null && token != null) {
+                session.extendTokenCompleted(msg.getData());
+            }
+
+            TokenRefreshRequest request = refreshRequestWeakReference.get();
+            if (request != null) {
+                // The refreshToken function should be called rarely,
+                // so there is no point in keeping the binding open.
+                staticContext.unbindService(request);
+                request.cleanup();
+            }
+        }
+    }
+
+    /**
+     * Provides asynchronous notification of Session state changes.
+     *
+     * @see Session#open open
+     */
+    public interface StatusCallback {
+        public void call(Session session, SessionState state, Exception exception);
+    }
+
+    @Override
+    public int hashCode() {
+        return 0;
+    }
+
+    @Override
+    public boolean equals(Object otherObj) {
+        if (!(otherObj instanceof Session)) {
+            return false;
+        }
+        Session other = (Session) otherObj;
+
+        return areEqual(other.clientId, clientId) &&
+                areEqual(other.authorizationBundle, authorizationBundle) &&
+                areEqual(other.state, state) &&
+                areEqual(other.getExpirationDate(), getExpirationDate());
+    }
+
+    private static boolean areEqual(Object a, Object b) {
+        if (a == null) {
+            return b == null;
+        } else {
+            return a.equals(b);
+        }
+    }
+
+    /**
+     * Builder class used to create a Session.
+     */
+    public static final class Builder {
+        private final Context context;
+        private String applicationId;
+        private TokenCachingStrategy tokenCachingStrategy;
+
+        /**
+         * Constructs a new Builder associated with the context.
+         *
+         * @param context the Activity or Service starting the Session
+         */
+        public Builder(Context context) {
+            this.context = context;
+        }
+
+        /**
+         * Sets the application id for the Session.
+         *
+         * @param applicationId the application id
+         * @return the Builder instance
+         */
+        public Builder setApplicationId(final String applicationId) {
+            this.applicationId = applicationId;
+            return this;
+        }
+
+        /**
+         * Sets the TokenCachingStrategy for the Session.
+         *
+         * @param tokenCachingStrategy the token cache to use
+         * @return the Builder instance
+         */
+        public Builder setTokenCachingStrategy(final TokenCachingStrategy tokenCachingStrategy) {
+            this.tokenCachingStrategy = tokenCachingStrategy;
+            return this;
+        }
+
+        /**
+         * Build the Session.
+         *
+         * @return a new Session
+         */
+        public Session build() {
+            return new Session(context, applicationId, tokenCachingStrategy);
+        }
+    }
+
+    interface StartActivityDelegate {
+        public void startActivityForResult(Intent intent, int requestCode);
+
+        public Activity getActivityContext();
+    }
+
+    private void autoPublishAsync() {
+        AutoPublishAsyncTask asyncTask = null;
+        synchronized (this) {
+            if (autoPublishAsyncTask == null && Settings.getShouldAutoPublishInstall()) {
+                // copy the application id to guarantee thread safety against our container.
+                String applicationId = Session.this.clientId;
+
+                // skip publish if we don't have an application id.
+                if (applicationId != null) {
+                    asyncTask = autoPublishAsyncTask = new AutoPublishAsyncTask(applicationId, staticContext);
+                }
+            }
+        }
+
+        if (asyncTask != null) {
+            asyncTask.execute();
+        }
+    }
+
+    /**
+     * Async implementation to allow auto publishing to not block the ui thread.
+     */
+    private class AutoPublishAsyncTask extends AsyncTask<Void, Void, Void> {
+        private final String mApplicationId;
+        private final Context mApplicationContext;
+
+        public AutoPublishAsyncTask(String applicationId, Context context) {
+            mApplicationId = applicationId;
+            mApplicationContext = context.getApplicationContext();
+        }
+
+        @Override
+        protected Void doInBackground(Void... voids) {
+            try {
+                Settings.publishInstallAndWait(mApplicationContext, mApplicationId);
+            } catch (Exception e) {
+                Utility.logd("Facebook-publish", e);
+            }
+            return null;
+        }
+
+        @Override
+        protected void onPostExecute(Void result) {
+            // always clear out the publisher to allow other invocations.
+            synchronized (Session.this) {
+                autoPublishAsyncTask = null;
+            }
+        }
+    }
+
+    /**
+     * Base class for authorization requests {@link OpenRequest} and {@link NewPermissionsRequest}.
+     */
+    public static class AuthorizationRequest implements Serializable {
+
+        private static final long serialVersionUID = 1L;
+
+        private final StartActivityDelegate startActivityDelegate;
+     //   private SessionLoginBehavior loginBehavior = SessionLoginBehavior.SSO_WITH_FALLBACK;
+        private SessionLoginBehavior loginBehavior = SessionLoginBehavior.SUPPRESS_SSO;
+        private int requestCode = DEFAULT_AUTHORIZE_ACTIVITY_CODE;
+        private StatusCallback statusCallback;
+        private boolean isLegacy = false;
+        private List<String> permissions = Collections.emptyList();
+        private SessionDefaultAudience defaultAudience = SessionDefaultAudience.FRIENDS;
+        private String applicationId;
+        private String redirectUri;        
+        private String validateSameFbidAsToken;
+
+        AuthorizationRequest(final Activity activity) {
+            startActivityDelegate = new StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    activity.startActivityForResult(intent, requestCode);
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    return activity;
+                }
+            };
+        }
+
+        AuthorizationRequest(final Fragment fragment) {
+            startActivityDelegate = new StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    fragment.startActivityForResult(intent, requestCode);
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    return fragment.getActivity();
+                }
+            };
+        }
+
+        /**
+         * Constructor to be used for V1 serialization only, DO NOT CHANGE.
+         */
+        private AuthorizationRequest(SessionLoginBehavior loginBehavior, int requestCode,
+                List<String> permissions, String defaultAudience, boolean isLegacy, String applicationId,
+                String validateSameFbidAsToken) {
+            startActivityDelegate = new StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    throw new UnsupportedOperationException(
+                            "Cannot create an AuthorizationRequest without a valid Activity or Fragment");
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    throw new UnsupportedOperationException(
+                            "Cannot create an AuthorizationRequest without a valid Activity or Fragment");
+                }
+            };
+            this.loginBehavior = loginBehavior;
+            this.requestCode = requestCode;
+            this.permissions = permissions;
+            this.defaultAudience = SessionDefaultAudience.valueOf(defaultAudience);
+            this.isLegacy = isLegacy;
+            this.applicationId = applicationId;
+            this.validateSameFbidAsToken = validateSameFbidAsToken;
+        }
+
+        /**
+         * Used for backwards compatibility with Facebook.java only, DO NOT USE.
+         *
+         * @param isLegacy
+         */
+        public void setIsLegacy(boolean isLegacy) {
+            this.isLegacy = isLegacy;
+        }
+
+        boolean isLegacy() {
+            return isLegacy;
+        }
+
+        AuthorizationRequest setCallback(StatusCallback statusCallback) {
+            this.statusCallback = statusCallback;
+            return this;
+        }
+
+        StatusCallback getCallback() {
+            return statusCallback;
+        }
+
+        AuthorizationRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
+            if (loginBehavior != null) {
+                this.loginBehavior = loginBehavior;
+            }
+            return this;
+        }
+
+        SessionLoginBehavior getLoginBehavior() {
+            return loginBehavior;
+        }
+
+        AuthorizationRequest setRequestCode(int requestCode) {
+            if (requestCode >= 0) {
+                this.requestCode = requestCode;
+            }
+            return this;
+        }
+
+        int getRequestCode() {
+            return requestCode;
+        }
+
+        AuthorizationRequest setPermissions(List<String> permissions) {
+            if (permissions != null) {
+                this.permissions = permissions;
+            }
+            return this;
+        }
+
+        List<String> getPermissions() {
+            return permissions;
+        }
+
+        AuthorizationRequest setDefaultAudience(SessionDefaultAudience defaultAudience) {
+            if (defaultAudience != null) {
+                this.defaultAudience = defaultAudience;
+            }
+            return this;
+        }
+
+        SessionDefaultAudience getDefaultAudience() {
+            return defaultAudience;
+        }
+
+        StartActivityDelegate getStartActivityDelegate() {
+            return startActivityDelegate;
+        }
+
+        String getApplicationId() {
+            return applicationId;
+        }
+
+        void setApplicationId(String applicationId) {
+            this.applicationId = applicationId;
+        }
+
+        String getRedirectUri() {
+            return redirectUri;
+        }
+
+        void setRedirectUri(String redirectUri) {
+            this.redirectUri = redirectUri;
+        }        
+        
+        String getValidateSameFbidAsToken() {
+            return validateSameFbidAsToken;
+        }
+
+        void setValidateSameFbidAsToken(String validateSameFbidAsToken) {
+            this.validateSameFbidAsToken = validateSameFbidAsToken;
+        }
+
+        AuthorizationClient.AuthorizationRequest getAuthorizationClientRequest() {
+            AuthorizationClient.StartActivityDelegate delegate = new AuthorizationClient.StartActivityDelegate() {
+                @Override
+                public void startActivityForResult(Intent intent, int requestCode) {
+                    startActivityDelegate.startActivityForResult(intent, requestCode);
+                }
+
+                @Override
+                public Activity getActivityContext() {
+                    return startActivityDelegate.getActivityContext();
+                }
+            };
+            return new AuthorizationClient.AuthorizationRequest(loginBehavior, requestCode, isLegacy,
+                    permissions, defaultAudience, applicationId, redirectUri, validateSameFbidAsToken, delegate);
+        }
+
+        // package private so subclasses can use it
+        Object writeReplace() {
+            return new AuthRequestSerializationProxyV1(
+                    loginBehavior, requestCode, permissions, defaultAudience.name(), isLegacy, applicationId, validateSameFbidAsToken);
+        }
+
+        // have a readObject that throws to prevent spoofing
+        // package private so subclasses can use it
+        void readObject(ObjectInputStream stream) throws InvalidObjectException {
+            throw new InvalidObjectException("Cannot readObject, serialization proxy required");
+        }
+
+        private static class AuthRequestSerializationProxyV1 implements Serializable {
+            private static final long serialVersionUID = -8748347685113614927L;
+            private final SessionLoginBehavior loginBehavior;
+            private final int requestCode;
+            private boolean isLegacy;
+            private final List<String> permissions;
+            private final String defaultAudience;
+            private final String applicationId;
+            private final String validateSameFbidAsToken;
+
+            private AuthRequestSerializationProxyV1(SessionLoginBehavior loginBehavior,
+                    int requestCode, List<String> permissions, String defaultAudience, boolean isLegacy,
+                    String applicationId, String validateSameFbidAsToken) {
+                this.loginBehavior = loginBehavior;
+                this.requestCode = requestCode;
+                this.permissions = permissions;
+                this.defaultAudience = defaultAudience;
+                this.isLegacy = isLegacy;
+                this.applicationId = applicationId;
+                this.validateSameFbidAsToken = validateSameFbidAsToken;
+            }
+
+            private Object readResolve() {
+                return new AuthorizationRequest(loginBehavior, requestCode, permissions, defaultAudience, isLegacy,
+                        applicationId, validateSameFbidAsToken);
+            }
+        }
+    }
+
+    /**
+     * A request used to open a Session.
+     */
+    public static final class OpenRequest extends AuthorizationRequest {
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Constructs an OpenRequest.
+         *
+         * @param activity the Activity to use to open the Session
+         */
+        public OpenRequest(Activity activity) {
+            super(activity);
+        }
+
+        /**
+         * Constructs an OpenRequest.
+         *
+         * @param fragment the Fragment to use to open the Session
+         */
+        public OpenRequest(Fragment fragment) {
+            super(fragment);
+        }
+
+        /**
+         * Sets the StatusCallback for the OpenRequest.
+         *
+         * @param statusCallback The {@link StatusCallback SessionStatusCallback} to
+         *                       notify regarding Session state changes.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setCallback(StatusCallback statusCallback) {
+            super.setCallback(statusCallback);
+            return this;
+        }
+
+        /**
+         * Sets the login behavior for the OpenRequest.
+         *
+         * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+         *                      specifies what behaviors should be attempted during
+         *                      authorization.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
+            super.setLoginBehavior(loginBehavior);
+            return this;
+        }
+
+        /**
+         * Sets the request code for the OpenRequest.
+         *
+         * @param requestCode An integer that identifies this request. This integer will be used
+         *                    as the request code in {@link Activity#onActivityResult
+         *                    onActivityResult}. This integer should be >= 0. If a value < 0 is
+         *                    passed in, then a default value will be used.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setRequestCode(int requestCode) {
+            super.setRequestCode(requestCode);
+            return this;
+        }
+
+        /**
+         * Sets the permissions for the OpenRequest.
+         *
+         * @param permissions A List&lt;String&gt; representing the permissions to request
+         *                    during the authentication flow. A null or empty List
+         *                    represents basic permissions.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setPermissions(List<String> permissions) {
+            super.setPermissions(permissions);
+            return this;
+        }
+
+        /**
+         * Sets the defaultAudience for the OpenRequest.
+         * <p/>
+         * This is only used during Native login using a sufficiently recent facebook app.
+         *
+         * @param defaultAudience A SessionDefaultAudience representing the default audience setting to request.
+         * @return the OpenRequest object to allow for chaining
+         */
+        public final OpenRequest setDefaultAudience(SessionDefaultAudience defaultAudience) {
+            super.setDefaultAudience(defaultAudience);
+            return this;
+        }
+    }
+
+    /**
+     * A request to be used to request new permissions for a Session.
+     */
+    public static final class NewPermissionsRequest extends AuthorizationRequest {
+        private static final long serialVersionUID = 1L;
+
+        /**
+         * Constructs a NewPermissionsRequest.
+         *
+         * @param activity    the Activity used to issue the request
+         * @param permissions additional permissions to request
+         */
+        public NewPermissionsRequest(Activity activity, List<String> permissions) {
+            super(activity);
+            setPermissions(permissions);
+        }
+
+        /**
+         * Constructs a NewPermissionsRequest.
+         *
+         * @param fragment    the Fragment used to issue the request
+         * @param permissions additional permissions to request
+         */
+        public NewPermissionsRequest(Fragment fragment, List<String> permissions) {
+            super(fragment);
+            setPermissions(permissions);
+        }
+
+        /**
+         * Sets the StatusCallback for the NewPermissionsRequest.
+         *
+         * @param statusCallback The {@link StatusCallback SessionStatusCallback} to
+         *                       notify regarding Session state changes.
+         * @return the NewPermissionsRequest object to allow for chaining
+         */
+        public final NewPermissionsRequest setCallback(StatusCallback statusCallback) {
+            super.setCallback(statusCallback);
+            return this;
+        }
+
+        /**
+         * Sets the login behavior for the NewPermissionsRequest.
+         *
+         * @param loginBehavior The {@link SessionLoginBehavior SessionLoginBehavior} that
+         *                      specifies what behaviors should be attempted during
+         *                      authorization.
+         * @return the NewPermissionsRequest object to allow for chaining
+         */
+        public final NewPermissionsRequest setLoginBehavior(SessionLoginBehavior loginBehavior) {
+            super.setLoginBehavior(loginBehavior);
+            return this;
+        }
+
+        /**
+         * Sets the request code for the NewPermissionsRequest.
+         *
+         * @param requestCode An integer that identifies this request. This integer will be used
+         *                    as the request code in {@link Activity#onActivityResult
+         *                    onActivityResult}. This integer should be >= 0. If a value < 0 is
+         *                    passed in, then a default value will be used.
+         * @return the NewPermissionsRequest object to allow for chaining
+         */
+        public final NewPermissionsRequest setRequestCode(int requestCode) {
+            super.setRequestCode(requestCode);
+            return this;
+        }
+
+        /**
+         * Sets the defaultAudience for the OpenRequest.
+         *
+         * @param defaultAudience A SessionDefaultAudience representing the default audience setting to request.
+         * @return the NewPermissionsRequest object to allow for chaining
+         */
+        public final NewPermissionsRequest setDefaultAudience(SessionDefaultAudience defaultAudience) {
+            super.setDefaultAudience(defaultAudience);
+            return this;
+        }
+    }
+}
diff --git a/funtown/src/tw/com/funtown/SessionDefaultAudience.java b/funtown/src/tw/com/funtown/SessionDefaultAudience.java
new file mode 100644
index 000000000..f1ac49af6
--- /dev/null
+++ b/funtown/src/tw/com/funtown/SessionDefaultAudience.java
@@ -0,0 +1,55 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+/**
+ * Certain operations such as publishing a status or publishing a photo require an audience. When the user
+ * grants an application permission to perform a publish operation, a default audience is selected as the
+ * publication ceiling for the application. This enumerated value allows the application to select which
+ * audience to ask the user to grant publish permission for.
+ */
+public enum SessionDefaultAudience {
+    /**
+     * Represents an invalid default audience value, can be used when only reading.
+     */
+    NONE(null),
+
+    /**
+     * Indicates only the user is able to see posts made by the application.
+     */
+    ONLY_ME(NativeProtocol.AUDIENCE_ME),
+
+    /**
+     * Indicates that the user's friends are able to see posts made by the application.
+     */
+    FRIENDS(NativeProtocol.AUDIENCE_FRIENDS),
+
+    /**
+     * Indicates that all Facebook users are able to see posts made by the application.
+     */
+    EVERYONE(NativeProtocol.AUDIENCE_EVERYONE);
+
+    private final String nativeProtocolAudience;
+
+    private SessionDefaultAudience(String protocol) {
+        nativeProtocolAudience = protocol;
+    }
+
+    String getNativeProtocolAudience() {
+        return nativeProtocolAudience;
+    }
+}
diff --git a/funtown/src/tw/com/funtown/SessionLoginBehavior.java b/funtown/src/tw/com/funtown/SessionLoginBehavior.java
new file mode 100644
index 000000000..14441f045
--- /dev/null
+++ b/funtown/src/tw/com/funtown/SessionLoginBehavior.java
@@ -0,0 +1,59 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+/**
+ * Specifies the behaviors to try during
+ * {@link Session#openForRead(com.facebook.Session.OpenRequest) openForRead},
+ * {@link Session#openForPublish(com.facebook.Session.OpenRequest) openForPublish},
+ * {@link Session#requestNewReadPermissions(com.facebook.Session.NewPermissionsRequest) requestNewReadPermissions}, or
+ * {@link Session#requestNewPublishPermissions(com.facebook.Session.NewPermissionsRequest) requestNewPublishPermissions}.
+ */
+public enum SessionLoginBehavior {
+    /**
+     * Specifies that Session should attempt Single Sign On (SSO), and if that
+     * does not work fall back to dialog auth. This is the default behavior.
+     */
+    SSO_WITH_FALLBACK(true, true),
+
+    /**
+     * Specifies that Session should only attempt SSO. If SSO fails, then the
+     * open or new permissions call fails.
+     */
+    SSO_ONLY(true, false),
+
+    /**
+     * Specifies that SSO should not be attempted, and to only use dialog auth.
+     */
+    SUPPRESS_SSO(false, true);
+
+    private final boolean allowsKatanaAuth;
+    private final boolean allowsWebViewAuth;
+
+    private SessionLoginBehavior(boolean allowsKatanaAuth, boolean allowsWebViewAuth) {
+        this.allowsKatanaAuth = allowsKatanaAuth;
+        this.allowsWebViewAuth = allowsWebViewAuth;
+    }
+
+    boolean allowsKatanaAuth() {
+        return allowsKatanaAuth;
+    }
+
+    boolean allowsWebViewAuth() {
+        return allowsWebViewAuth;
+    }
+}
diff --git a/funtown/src/tw/com/funtown/SessionState.java b/funtown/src/tw/com/funtown/SessionState.java
new file mode 100644
index 000000000..78536e9f2
--- /dev/null
+++ b/funtown/src/tw/com/funtown/SessionState.java
@@ -0,0 +1,117 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+/**
+ * <p>
+ * Identifies the state of a Session.
+ * </p>
+ * <p>
+ * Session objects implement a state machine that controls their lifecycle. This
+ * enum represents the states of the state machine.
+ * </p>
+ */
+public enum SessionState {
+    /**
+     * Indicates that the Session has not yet been opened and has no cached
+     * token. Opening a Session in this state will involve user interaction.
+     */
+    CREATED(Category.CREATED_CATEGORY),
+
+    /**
+     * <p>
+     * Indicates that the Session has not yet been opened and has a cached
+     * token. Opening a Session in this state will not involve user interaction.
+     * </p>
+     * <p>
+     * If you are using Session from an Android Service, you must provide a
+     * TokenCachingStrategy implementation that contains a valid token to the Session
+     * constructor. The resulting Session will be created in this state, and you
+     * can then safely call open, passing null for the Activity.
+     * </p>
+     */
+    CREATED_TOKEN_LOADED(Category.CREATED_CATEGORY),
+
+    /**
+     * Indicates that the Session is in the process of opening.
+     */
+    OPENING(Category.CREATED_CATEGORY),
+
+    /**
+     * Indicates that the Session is opened. In this state, the Session may be
+     * used with a {@link Request}.
+     */
+    OPENED(Category.OPENED_CATEGORY),
+
+    /**
+     * <p>
+     * Indicates that the Session is opened and that the token has changed. In
+     * this state, the Session may be used with {@link Request}.
+     * </p>
+     * <p>
+     * Every time the token is updated, {@link Session.StatusCallback
+     * StatusCallback} is called with this value.
+     * </p>
+     */
+    OPENED_TOKEN_UPDATED(Category.OPENED_CATEGORY),
+
+    /**
+     * Indicates that the Session is closed, and that it was not closed
+     * normally. Typically this means that the open call failed, and the
+     * Exception parameter to {@link Session.StatusCallback StatusCallback} will
+     * be non-null.
+     */
+    CLOSED_LOGIN_FAILED(Category.CLOSED_CATEGORY),
+
+    /**
+     * Indicates that the Session was closed normally.
+     */
+    CLOSED(Category.CLOSED_CATEGORY);
+
+    private final Category category;
+
+    SessionState(Category category) {
+        this.category = category;
+    }
+
+    /**
+     * Returns a boolean indicating whether the state represents a successfully
+     * opened state in which the Session can be used with a {@link Request}.
+     * 
+     * @return a boolean indicating whether the state represents a successfully
+     *         opened state in which the Session can be used with a
+     *         {@link Request}.
+     */
+    public boolean isOpened() {
+        return this.category == Category.OPENED_CATEGORY;
+    }
+
+    /**
+     * Returns a boolean indicating whether the state represents a closed
+     * Session that can no longer be used with a {@link Request}.
+     * 
+     * @return a boolean indicating whether the state represents a closed
+     * Session that can no longer be used with a {@link Request}.
+     */
+    public boolean isClosed() {
+        return this.category == Category.CLOSED_CATEGORY;
+    }
+
+    private enum Category {
+        CREATED_CATEGORY, OPENED_CATEGORY, CLOSED_CATEGORY
+    }
+}
diff --git a/funtown/src/tw/com/funtown/Settings.java b/funtown/src/tw/com/funtown/Settings.java
new file mode 100644
index 000000000..f46c09424
--- /dev/null
+++ b/funtown/src/tw/com/funtown/Settings.java
@@ -0,0 +1,390 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Handler;
+import android.os.Looper;
+import com.facebook.android.BuildConfig;
+import tw.com.funtown.internal.Utility;
+import com.facebook.model.GraphObject;
+import tw.com.funtown.internal.Validate;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Allows some customization of sdk behavior.
+ */
+public final class Settings {
+    private static final HashSet<LoggingBehavior> loggingBehaviors =
+            new HashSet<LoggingBehavior>(Arrays.asList(LoggingBehavior.DEVELOPER_ERRORS));
+    private static volatile Executor executor;
+    private static volatile boolean shouldAutoPublishInstall;
+
+    private static final int DEFAULT_CORE_POOL_SIZE = 5;
+    private static final int DEFAULT_MAXIMUM_POOL_SIZE = 128;
+    private static final int DEFAULT_KEEP_ALIVE = 1;
+    private static final Object LOCK = new Object();
+
+    private static final Uri ATTRIBUTION_ID_CONTENT_URI =
+            Uri.parse("content://com.facebook.katana.provider.AttributionIdProvider");
+    private static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
+
+    private static final String ATTRIBUTION_PREFERENCES = "com.facebook.sdk.attributionTracking";
+    private static final String PUBLISH_ACTIVITY_PATH = "%s/activities";
+    private static final String MOBILE_INSTALL_EVENT = "MOBILE_APP_INSTALL";
+    private static final String ANALYTICS_EVENT = "event";
+    private static final String ATTRIBUTION_KEY = "attribution";
+
+    private static final BlockingQueue<Runnable> DEFAULT_WORK_QUEUE = new LinkedBlockingQueue<Runnable>(10);
+
+    private static final ThreadFactory DEFAULT_THREAD_FACTORY = new ThreadFactory() {
+        private final AtomicInteger counter = new AtomicInteger(0);
+
+        public Thread newThread(Runnable runnable) {
+            return new Thread(runnable, "FuntownSdk #" + counter.incrementAndGet());
+        }
+    };
+
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Returns the types of extended logging that are currently enabled.
+     *
+     * @return a set containing enabled logging behaviors
+     */
+    public static final Set<LoggingBehavior> getLoggingBehaviors() {
+        synchronized (loggingBehaviors) {
+            return Collections.unmodifiableSet(new HashSet<LoggingBehavior>(loggingBehaviors));
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Enables a particular extended logging in the sdk.
+     *
+     * @param behavior
+     *          The LoggingBehavior to enable
+     */
+    public static final void addLoggingBehavior(LoggingBehavior behavior) {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.add(behavior);
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Disables a particular extended logging behavior in the sdk.
+     *
+     * @param behavior
+     *          The LoggingBehavior to disable
+     */
+    public static final void removeLoggingBehavior(LoggingBehavior behavior) {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.remove(behavior);
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Disables all extended logging behaviors.
+     */
+    public static final void clearLoggingBehaviors() {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.clear();
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Checks if a particular extended logging behavior is enabled.
+     *
+     * @param behavior
+     *          The LoggingBehavior to check
+     * @return whether behavior is enabled
+     */
+    public static final boolean isLoggingBehaviorEnabled(LoggingBehavior behavior) {
+        synchronized (loggingBehaviors) {
+            return BuildConfig.DEBUG && loggingBehaviors.contains(behavior);
+        }
+    }
+
+    /**
+     * Returns the Executor used by the SDK for non-AsyncTask background work.
+     *
+     * By default this uses AsyncTask Executor via reflection if the API level is high enough.
+     * Otherwise this creates a new Executor with defaults similar to those used in AsyncTask.
+     *
+     * @return an Executor used by the SDK.  This will never be null.
+     */
+    public static Executor getExecutor() {
+        synchronized (LOCK) {
+            if (Settings.executor == null) {
+                Executor executor = getAsyncTaskExecutor();
+                if (executor == null) {
+                    executor = new ThreadPoolExecutor(DEFAULT_CORE_POOL_SIZE, DEFAULT_MAXIMUM_POOL_SIZE,
+                            DEFAULT_KEEP_ALIVE, TimeUnit.SECONDS, DEFAULT_WORK_QUEUE, DEFAULT_THREAD_FACTORY);
+                }
+                Settings.executor = executor;
+            }
+        }
+        return Settings.executor;
+    }
+
+    /**
+     * Sets the Executor used by the SDK for non-AsyncTask background work.
+     *
+     * @param executor
+     *          the Executor to use; must not be null.
+     */
+    public static void setExecutor(Executor executor) {
+        Validate.notNull(executor, "executor");
+        synchronized (LOCK) {
+            Settings.executor = executor;
+        }
+    }
+
+    private static Executor getAsyncTaskExecutor() {
+        Field executorField = null;
+        try {
+            executorField = AsyncTask.class.getField("THREAD_POOL_EXECUTOR");
+        } catch (NoSuchFieldException e) {
+            return null;
+        }
+
+        if (executorField == null) {
+            return null;
+        }
+
+        Object executorObject = null;
+        try {
+            executorObject = executorField.get(null);
+        } catch (IllegalAccessException e) {
+            return null;
+        }
+
+        if (executorObject == null) {
+            return null;
+        }
+
+        if (!(executorObject instanceof Executor)) {
+            return null;
+        }
+
+        return (Executor) executorObject;
+    }
+
+    /**
+     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
+     * multiple installs being published to the graph.
+     * @param context the current Context
+     * @param applicationId the fb application being published.
+     */
+    public static void publishInstallAsync(final Context context, final String applicationId) {
+       publishInstallAsync(context, applicationId, null);
+    }
+
+    /**
+     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
+     * multiple installs being published to the graph.
+     * @param context the current Context
+     * @param applicationId the fb application being published.
+     * @param callback a callback to invoke with a Response object, carrying the server response, or an error.
+     */
+    public static void publishInstallAsync(final Context context, final String applicationId,
+        final Request.Callback callback) {
+        // grab the application context ahead of time, since we will return to the caller immediately.
+        final Context applicationContext = context.getApplicationContext();
+        Settings.getExecutor().execute(new Runnable() {
+            @Override
+            public void run() {
+                final Response response = Settings.publishInstallAndWaitForResponse(applicationContext, applicationId);
+                if (callback != null) {
+                    // invoke the callback on the main thread.
+                    Handler handler = new Handler(Looper.getMainLooper());
+                    handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onCompleted(response);
+                        }
+                    });
+                }
+            }
+        });
+    }
+
+    /**
+     * Sets whether opening a Session should automatically publish install attribution to the Facebook graph.
+     *
+     * @param shouldAutoPublishInstall true to automatically publish, false to not
+     */
+    public static void setShouldAutoPublishInstall(boolean shouldAutoPublishInstall) {
+        Settings.shouldAutoPublishInstall = shouldAutoPublishInstall;
+    }
+
+    /**
+     * Gets whether opening a Session should automatically publish install attribution to the Facebook graph.
+     *
+     * @return true to automatically publish, false to not
+     */
+    public static boolean getShouldAutoPublishInstall() {
+        return shouldAutoPublishInstall;
+    }
+
+    /**
+     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
+     * multiple installs being published to the graph.
+     * @param context the current Context
+     * @param applicationId the fb application being published.
+     * @return returns false on error.  Applications should retry until true is returned.  Safe to call again after
+     * true is returned.
+     */
+    public static boolean publishInstallAndWait(final Context context, final String applicationId) {
+        Response response = publishInstallAndWaitForResponse(context, applicationId);
+        return response != null && response.getError() == null;
+    }
+
+    /**
+     * Manually publish install attribution to the Facebook graph.  Internally handles caching repeat calls to prevent
+     * multiple installs being published to the graph.
+     * @param context the current Context
+     * @param applicationId the fb application being published.
+     * @return returns a Response object, carrying the server response, or an error.
+     */
+    public static Response publishInstallAndWaitForResponse(final Context context, final String applicationId) {
+        try {
+            if (context == null || applicationId == null) {
+                throw new IllegalArgumentException("Both context and applicationId must be non-null");
+            }
+            String attributionId = Settings.getAttributionId(context.getContentResolver());
+            SharedPreferences preferences = context.getSharedPreferences(ATTRIBUTION_PREFERENCES, Context.MODE_PRIVATE);
+            String pingKey = applicationId+"ping";
+            String jsonKey = applicationId+"json";
+            long lastPing = preferences.getLong(pingKey, 0);
+            String lastResponseJSON = preferences.getString(jsonKey, null);
+
+            GraphObject publishParams = GraphObject.Factory.create();
+            publishParams.setProperty(ANALYTICS_EVENT, MOBILE_INSTALL_EVENT);
+            publishParams.setProperty(ATTRIBUTION_KEY, attributionId);
+
+            String publishUrl = String.format(PUBLISH_ACTIVITY_PATH, applicationId);
+            Request publishRequest = Request.newPostRequest(null, publishUrl, publishParams, null);
+
+            if (lastPing != 0) {
+                GraphObject graphObject = null;
+                try {
+                    if (lastResponseJSON != null) {
+                        graphObject = GraphObject.Factory.create(new JSONObject(lastResponseJSON));
+                    }
+                }
+                catch (JSONException je) {
+                    // return the default graph object if there is any problem reading the data.
+                }
+                if (graphObject == null) {
+                    return Response.createResponsesFromString("true", null, new RequestBatch(publishRequest), true).get(0);
+                } else {
+                    return new Response(null, null, graphObject, true);
+                }
+            } else if (attributionId == null) {
+                throw new FuntownException("No attribution id returned from the Facebook application");
+            } else {
+
+                if (!Utility.queryAppAttributionSupportAndWait(applicationId)) {
+                    throw new FuntownException("Install attribution has been disabled on the server.");
+                }
+
+                Response publishResponse = publishRequest.executeAndWait();
+
+                // denote success since no error threw from the post.
+                SharedPreferences.Editor editor = preferences.edit();
+                lastPing = System.currentTimeMillis();
+                editor.putLong(pingKey, lastPing);
+
+                // if we got an object response back, cache the string of the JSON.
+                if (publishResponse.getGraphObject() != null &&
+                    publishResponse.getGraphObject().getInnerJSONObject() != null) {
+                    editor.putString(jsonKey, publishResponse.getGraphObject().getInnerJSONObject().toString());
+                }
+                editor.commit();
+
+                return publishResponse;
+            }
+        } catch (Exception e) {
+            // if there was an error, fall through to the failure case.
+            Utility.logd("Facebook-publish", e);
+            return new Response(null, null, new FuntownRequestError(null, e));
+        }
+    }
+
+    /**
+     * Acquire the current attribution id from the facebook app.
+     * @return returns null if the facebook app is not present on the phone.
+     */
+    public static String getAttributionId(ContentResolver contentResolver) {
+        String [] projection = {ATTRIBUTION_ID_COLUMN_NAME};
+        Cursor c = contentResolver.query(ATTRIBUTION_ID_CONTENT_URI, projection, null, null, null);
+        if (c == null || !c.moveToFirst()) {
+            return null;
+        }
+        String attributionId = c.getString(c.getColumnIndex(ATTRIBUTION_ID_COLUMN_NAME));
+        c.close();
+        return attributionId;
+    }
+
+    /**
+     * Gets the current version of the Facebook SDK for Android as a string.
+     *
+     * @return the current version of the SDK
+     */
+    public static String getSdkVersion() {
+        return FuntownSdkVersion.BUILD;
+    }
+
+    /**
+     * Gets the current Facebook migration bundle string; this string can be passed to Graph API
+     * endpoints to specify a set of platform migrations that are explicitly turned on or off for
+     * that call, in order to ensure compatibility between a given version of the SDK and the
+     * Graph API.
+     * @return the migration bundle supported by this version of the SDK
+     */
+    public static String getMigrationBundle() {
+        return FuntownSdkVersion.MIGRATION_BUNDLE;
+    }
+}
diff --git a/funtown/src/tw/com/funtown/SharedPreferencesTokenCachingStrategy.java b/funtown/src/tw/com/funtown/SharedPreferencesTokenCachingStrategy.java
new file mode 100644
index 000000000..3c0a4d3b9
--- /dev/null
+++ b/funtown/src/tw/com/funtown/SharedPreferencesTokenCachingStrategy.java
@@ -0,0 +1,403 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.util.Log;
+import tw.com.funtown.internal.Logger;
+import tw.com.funtown.internal.Utility;
+import tw.com.funtown.internal.Validate;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/*
+ * <p>
+ * An implementation of {@link TokenCachingStrategy TokenCachingStrategy} that uses Android SharedPreferences
+ * to persist information.
+ * </p>
+ * <p>
+ * The data to be cached is passed in via a Bundle. Only non-null key-value-pairs where
+ * the value is one of the following types (or an array of the same) are persisted:
+ * boolean, byte, int, long, float, double, char. In addition, String and List<String>
+ * are also supported.
+ * </p>
+ */
+public class SharedPreferencesTokenCachingStrategy extends TokenCachingStrategy {
+
+    private static final String DEFAULT_CACHE_KEY = "com.facebook.SharedPreferencesTokenCachingStrategy.DEFAULT_KEY";
+    private static final String TAG = SharedPreferencesTokenCachingStrategy.class.getSimpleName();
+
+    private static final String JSON_VALUE_TYPE = "valueType";
+    private static final String JSON_VALUE = "value";
+    private static final String JSON_VALUE_ENUM_TYPE = "enumType";
+
+    private static final String TYPE_BOOLEAN = "bool";
+    private static final String TYPE_BOOLEAN_ARRAY = "bool[]";
+    private static final String TYPE_BYTE = "byte";
+    private static final String TYPE_BYTE_ARRAY = "byte[]";
+    private static final String TYPE_SHORT = "short";
+    private static final String TYPE_SHORT_ARRAY = "short[]";
+    private static final String TYPE_INTEGER = "int";
+    private static final String TYPE_INTEGER_ARRAY = "int[]";
+    private static final String TYPE_LONG = "long";
+    private static final String TYPE_LONG_ARRAY = "long[]";
+    private static final String TYPE_FLOAT = "float";
+    private static final String TYPE_FLOAT_ARRAY = "float[]";
+    private static final String TYPE_DOUBLE = "double";
+    private static final String TYPE_DOUBLE_ARRAY = "double[]";
+    private static final String TYPE_CHAR = "char";
+    private static final String TYPE_CHAR_ARRAY = "char[]";
+    private static final String TYPE_STRING = "string";
+    private static final String TYPE_STRING_LIST = "stringList";
+    private static final String TYPE_ENUM = "enum";
+
+    private String cacheKey;
+    private SharedPreferences cache;
+
+    /**
+     * Creates a default {@link SharedPreferencesTokenCachingStrategy SharedPreferencesTokenCachingStrategy}
+     * instance that provides access to a single set of token information.
+     *
+     * @param context
+     *              The Context object to use to get the SharedPreferences object.
+     *
+     * @throws NullPointerException if the passed in Context is null
+     */
+    public SharedPreferencesTokenCachingStrategy(Context context) {
+        this(context, null);
+    }
+
+    /**
+     * Creates a {@link SharedPreferencesTokenCachingStrategy SharedPreferencesTokenCachingStrategy} instance
+     * that is distinct for the passed in cacheKey.
+     *
+     * @param context
+     *              The Context object to use to get the SharedPreferences object.
+     *
+     * @param cacheKey
+     *              Identifies a distinct set of token information.
+     *
+     * @throws NullPointerException if the passed in Context is null
+     */
+    public SharedPreferencesTokenCachingStrategy(Context context, String cacheKey) {
+        Validate.notNull(context, "context");
+
+        this.cacheKey = Utility.isNullOrEmpty(cacheKey) ? DEFAULT_CACHE_KEY : cacheKey;
+
+        // If the application context is available, use that. However, if it isn't
+        // available (possibly because of a context that was created manually), use
+        // the passed in context directly.
+        Context applicationContext = context.getApplicationContext();
+        context = applicationContext != null ? applicationContext : context;
+
+        this.cache = context.getSharedPreferences(
+                this.cacheKey,
+                Context.MODE_PRIVATE);
+    }
+
+    /**
+     * Returns a Bundle that contains the information stored in this cache
+     *
+     * @return A Bundle with the information contained in this cache
+     */
+    public Bundle load() {
+        Bundle settings = new Bundle();
+
+        Map<String, ?> allCachedEntries = cache.getAll();
+
+        for (String key : allCachedEntries.keySet()) {
+            try {
+                deserializeKey(key, settings);
+            } catch (JSONException e) {
+                // Error in the cache. So consider it corrupted and return null
+                Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG,
+                        "Error reading cached value for key: '" + key + "' -- " + e);
+                return null;
+            }
+        }
+
+        return settings;
+    }
+
+    /**
+     * Persists all supported data types present in the passed in Bundle, to the
+     * cache
+     *
+     * @param bundle
+     *          The Bundle containing information to be cached
+     */
+    public void save(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+
+        SharedPreferences.Editor editor = cache.edit();
+
+        for (String key : bundle.keySet()) {
+            try {
+                serializeKey(key, bundle, editor);
+            } catch (JSONException e) {
+                // Error in the bundle. Don't store a partial cache.
+                Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "Error processing value for key: '" + key + "' -- " + e);
+
+                // Bypass the commit and just return. This cancels the entire edit transaction
+                return;
+            }
+        }
+
+        boolean successfulCommit = editor.commit();
+        if (!successfulCommit) {
+            Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "SharedPreferences.Editor.commit() was not successful");
+        }
+    }
+
+    /**
+     * Clears out all token information stored in this cache.
+     */
+    public void clear() {
+        cache.edit().clear().commit();
+    }
+
+    private void serializeKey(String key, Bundle bundle, SharedPreferences.Editor editor)
+        throws JSONException {
+        Object value = bundle.get(key);
+        if (value == null) {
+            // Cannot serialize null values.
+            return;
+        }
+
+        String supportedType = null;
+        JSONArray jsonArray = null;
+        JSONObject json = new JSONObject();
+
+        if (value instanceof Byte) {
+            supportedType = TYPE_BYTE;
+            json.put(JSON_VALUE, ((Byte)value).intValue());
+        } else if (value instanceof Short) {
+            supportedType = TYPE_SHORT;
+            json.put(JSON_VALUE, ((Short)value).intValue());
+        } else if (value instanceof Integer) {
+            supportedType = TYPE_INTEGER;
+            json.put(JSON_VALUE, ((Integer)value).intValue());
+        } else if (value instanceof Long) {
+            supportedType = TYPE_LONG;
+            json.put(JSON_VALUE, ((Long)value).longValue());
+        } else if (value instanceof Float) {
+            supportedType = TYPE_FLOAT;
+            json.put(JSON_VALUE, ((Float)value).doubleValue());
+        } else if (value instanceof Double) {
+            supportedType = TYPE_DOUBLE;
+            json.put(JSON_VALUE, ((Double)value).doubleValue());
+        } else if (value instanceof Boolean) {
+            supportedType = TYPE_BOOLEAN;
+            json.put(JSON_VALUE, ((Boolean)value).booleanValue());
+        } else if (value instanceof Character) {
+            supportedType = TYPE_CHAR;
+            json.put(JSON_VALUE, value.toString());
+        } else if (value instanceof String) {
+            supportedType = TYPE_STRING;
+            json.put(JSON_VALUE, (String)value);
+        } else if (value instanceof Enum<?>) {
+            supportedType = TYPE_ENUM;
+            json.put(JSON_VALUE, value.toString());
+            json.put(JSON_VALUE_ENUM_TYPE, value.getClass().getName());
+        } else {
+            // Optimistically create a JSONArray. If not an array type, we can null
+            // it out later
+            jsonArray = new JSONArray();
+            if (value instanceof byte[]) {
+                supportedType = TYPE_BYTE_ARRAY;
+                for (byte v : (byte[])value) {
+                    jsonArray.put((int)v);
+                }
+            } else if (value instanceof short[]) {
+                supportedType = TYPE_SHORT_ARRAY;
+                for (short v : (short[])value) {
+                    jsonArray.put((int)v);
+                }
+            } else if (value instanceof int[]) {
+                supportedType = TYPE_INTEGER_ARRAY;
+                for (int v : (int[])value) {
+                    jsonArray.put(v);
+                }
+            } else if (value instanceof long[]) {
+                supportedType = TYPE_LONG_ARRAY;
+                for (long v : (long[])value) {
+                    jsonArray.put(v);
+                }
+            } else if (value instanceof float[]) {
+                supportedType = TYPE_FLOAT_ARRAY;
+                for (float v : (float[])value) {
+                    jsonArray.put((double)v);
+                }
+            } else if (value instanceof double[]) {
+                supportedType = TYPE_DOUBLE_ARRAY;
+                for (double v : (double[])value) {
+                    jsonArray.put(v);
+                }
+            } else if (value instanceof boolean[]) {
+                supportedType = TYPE_BOOLEAN_ARRAY;
+                for (boolean v : (boolean[])value) {
+                    jsonArray.put(v);
+                }
+            } else if (value instanceof char[]) {
+                supportedType = TYPE_CHAR_ARRAY;
+                for (char v : (char[])value) {
+                    jsonArray.put(String.valueOf(v));
+                }
+            } else if (value instanceof List<?>) {
+                supportedType = TYPE_STRING_LIST;
+                @SuppressWarnings("unchecked")
+                List<String> stringList = (List<String>)value;
+                for (String v : stringList) {
+                    jsonArray.put((v == null) ? JSONObject.NULL : v);
+                }
+            } else {
+                // Unsupported type. Clear out the array as a precaution even though
+                // it is redundant with the null supportedType.
+                jsonArray = null;
+            }
+        }
+
+        if (supportedType != null) {
+            json.put(JSON_VALUE_TYPE, supportedType);
+            if (jsonArray != null) {
+                // If we have an array, it has already been converted to JSON. So use
+                // that instead.
+                json.putOpt(JSON_VALUE, jsonArray);
+            }
+
+            String jsonString = json.toString();
+            editor.putString(key, jsonString);
+        }
+    }
+
+    private void deserializeKey(String key, Bundle bundle)
+            throws JSONException {
+        String jsonString = cache.getString(key, "{}");
+        JSONObject json = new JSONObject(jsonString);
+
+        String valueType = json.getString(JSON_VALUE_TYPE);
+
+        if (valueType.equals(TYPE_BOOLEAN)) {
+            bundle.putBoolean(key, json.getBoolean(JSON_VALUE));
+        } else if (valueType.equals(TYPE_BOOLEAN_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            boolean[] array = new boolean[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = jsonArray.getBoolean(i);
+            }
+            bundle.putBooleanArray(key, array);
+        } else if (valueType.equals(TYPE_BYTE)) {
+            bundle.putByte(key, (byte)json.getInt(JSON_VALUE));
+        } else if (valueType.equals(TYPE_BYTE_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            byte[] array = new byte[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = (byte)jsonArray.getInt(i);
+            }
+            bundle.putByteArray(key, array);
+        } else if (valueType.equals(TYPE_SHORT)) {
+            bundle.putShort(key, (short)json.getInt(JSON_VALUE));
+        } else if (valueType.equals(TYPE_SHORT_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            short[] array = new short[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = (short)jsonArray.getInt(i);
+            }
+            bundle.putShortArray(key, array);
+        } else if (valueType.equals(TYPE_INTEGER)) {
+            bundle.putInt(key, json.getInt(JSON_VALUE));
+        } else if (valueType.equals(TYPE_INTEGER_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            int[] array = new int[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = jsonArray.getInt(i);
+            }
+            bundle.putIntArray(key, array);
+        } else if (valueType.equals(TYPE_LONG)) {
+            bundle.putLong(key, json.getLong(JSON_VALUE));
+        } else if (valueType.equals(TYPE_LONG_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            long[] array = new long[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = jsonArray.getLong(i);
+            }
+            bundle.putLongArray(key, array);
+        } else if (valueType.equals(TYPE_FLOAT)) {
+            bundle.putFloat(key, (float)json.getDouble(JSON_VALUE));
+        } else if (valueType.equals(TYPE_FLOAT_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            float[] array = new float[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = (float)jsonArray.getDouble(i);
+            }
+            bundle.putFloatArray(key, array);
+        } else if (valueType.equals(TYPE_DOUBLE)) {
+            bundle.putDouble(key, json.getDouble(JSON_VALUE));
+        } else if (valueType.equals(TYPE_DOUBLE_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            double[] array = new double[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                array[i] = jsonArray.getDouble(i);
+            }
+            bundle.putDoubleArray(key, array);
+        } else if (valueType.equals(TYPE_CHAR)) {
+            String charString = json.getString(JSON_VALUE);
+            if (charString != null && charString.length() == 1) {
+                bundle.putChar(key, charString.charAt(0));
+            }
+        } else if (valueType.equals(TYPE_CHAR_ARRAY)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            char[] array = new char[jsonArray.length()];
+            for (int i = 0; i < array.length; i++) {
+                String charString = jsonArray.getString(i);
+                if (charString != null && charString.length() == 1) {
+                    array[i] = charString.charAt(0);
+                }
+            }
+            bundle.putCharArray(key, array);
+        } else if (valueType.equals(TYPE_STRING)) {
+            bundle.putString(key, json.getString(JSON_VALUE));
+        } else if (valueType.equals(TYPE_STRING_LIST)) {
+            JSONArray jsonArray = json.getJSONArray(JSON_VALUE);
+            int numStrings = jsonArray.length();
+            ArrayList<String> stringList = new ArrayList<String>(numStrings);
+            for (int i = 0; i < numStrings; i++) {
+                Object jsonStringValue = jsonArray.get(i);
+                stringList.add(i, jsonStringValue == JSONObject.NULL ? null : (String)jsonStringValue);
+            }
+            bundle.putStringArrayList(key, stringList);
+        } else if (valueType.equals(TYPE_ENUM)) {
+            try {
+                String enumType = json.getString(JSON_VALUE_ENUM_TYPE);
+                @SuppressWarnings({ "unchecked", "rawtypes" })
+                Class<? extends Enum> enumClass = (Class<? extends Enum>) Class.forName(enumType);
+                @SuppressWarnings("unchecked")
+                Enum<?> enumValue = Enum.valueOf(enumClass, json.getString(JSON_VALUE));
+                bundle.putSerializable(key, enumValue);
+            } catch (ClassNotFoundException e) {
+            } catch (IllegalArgumentException e) {
+            }
+        }
+    }
+}
diff --git a/funtown/src/tw/com/funtown/TokenCachingStrategy.java b/funtown/src/tw/com/funtown/TokenCachingStrategy.java
new file mode 100644
index 000000000..8d5a6bf37
--- /dev/null
+++ b/funtown/src/tw/com/funtown/TokenCachingStrategy.java
@@ -0,0 +1,378 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown;
+
+import android.os.Bundle;
+import com.facebook.internal.Validate;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+/**
+ * <p>
+ * A base class for implementations of a {@link Session Session} token cache.
+ * </p>
+ * <p>
+ * The Session constructor optionally takes a TokenCachingStrategy, from which it will
+ * attempt to load a cached token during construction. Also, whenever the
+ * Session updates its token, it will also save the token and associated state
+ * to the TokenCachingStrategy.
+ * </p>
+ * <p>
+ * This is the only mechanism supported for an Android service to use Session.
+ * The service can create a custom TokenCachingStrategy that returns the Session provided
+ * by an Activity through which the user logged in to Facebook.
+ * </p>
+ */
+public abstract class TokenCachingStrategy {
+    /**
+     * The key used by Session to store the token value in the Bundle during
+     * load and save.
+     */
+    public static final String TOKEN_KEY = "com.facebook.TokenCachingStrategy.Token";
+
+    /**
+     * The key used by Session to store the expiration date value in the Bundle
+     * during load and save.
+     */
+    public static final String EXPIRATION_DATE_KEY = "com.facebook.TokenCachingStrategy.ExpirationDate";
+
+    /**
+     * The key used by Session to store the last refresh date value in the
+     * Bundle during load and save.
+     */
+    public static final String LAST_REFRESH_DATE_KEY = "com.facebook.TokenCachingStrategy.LastRefreshDate";
+
+    /**
+     * The key used by Session to store the user's id value in the Bundle during
+     * load and save.
+     */
+    public static final String USER_FBID_KEY = "com.facebook.TokenCachingStrategy.UserFBID";
+
+    /**
+     * The key used by Session to store an enum indicating the source of the token
+     * in the Bundle during load and save.
+     */
+    public static final String TOKEN_SOURCE_KEY = "com.facebook.TokenCachingStrategy.AccessTokenSource";
+
+    /**
+     * The key used by Session to store the list of permissions granted by the
+     * token in the Bundle during load and save.
+     */
+    public static final String PERMISSIONS_KEY = "com.facebook.TokenCachingStrategy.Permissions";
+
+    private static final long INVALID_BUNDLE_MILLISECONDS = Long.MIN_VALUE;
+    private static final String IS_SSO_KEY = "com.facebook.TokenCachingStrategy.IsSSO";
+
+    /**
+     * Called during Session construction to get the token state. Typically this
+     * is loaded from a persistent store that was previously initialized via
+     * save.  The caller may choose to keep a reference to the returned Bundle
+     * indefinitely.  Therefore the TokenCachingStrategy should not store the returned Bundle
+     * and should return a new Bundle on every call to this method.
+     *
+     * @return A Bundle that represents the token state that was loaded.
+     */
+    public abstract Bundle load();
+
+    /**
+     * Called when a Session updates its token. This is passed a Bundle of
+     * values that should be stored durably for the purpose of being returned
+     * from a later call to load.  Some implementations may choose to store
+     * bundle beyond the scope of this call, so the caller should keep no
+     * references to the bundle to ensure that it is not modified later.
+     * 
+     * @param bundle
+     *            A Bundle that represents the token state to be saved.
+     */
+    public abstract void save(Bundle bundle);
+
+    /**
+     * Called when a Session learns its token is no longer valid or during a
+     * call to {@link Session#closeAndClearTokenInformation
+     * closeAndClearTokenInformation} to clear the durable state associated with
+     * the token.
+     */
+    public abstract void clear();
+
+    /**
+     * Returns a boolean indicating whether a Bundle contains properties that
+     * could be a valid saved token.
+     * 
+     * @param bundle
+     *            A Bundle to check for token information.
+     * @return a boolean indicating whether a Bundle contains properties that
+     *         could be a valid saved token.
+     */
+    public static boolean hasTokenInformation(Bundle bundle) {
+        if (bundle == null) {
+            return false;
+        }
+
+        String token = bundle.getString(TOKEN_KEY);
+        if ((token == null) || (token.length() == 0)) {
+            return false;
+        }
+
+        long expiresMilliseconds = bundle.getLong(EXPIRATION_DATE_KEY, 0L);
+        if (expiresMilliseconds == 0L) {
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Gets the cached token value from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the token value was stored.
+     * @return the cached token value, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static String getToken(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getString(TOKEN_KEY);
+    }
+
+    /**
+     * Puts the token value into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the token value should be stored.
+     * @param value
+     *            The String representing the token value, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle or token value are null
+     */
+    public static void putToken(Bundle bundle, String value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+        bundle.putString(TOKEN_KEY, value);
+    }
+
+    /**
+     * Gets the cached expiration date from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the expiration date was stored.
+     * @return the cached expiration date, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static Date getExpirationDate(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return getDate(bundle, EXPIRATION_DATE_KEY);
+    }
+
+    /**
+     * Puts the expiration date into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the expiration date should be stored.
+     * @param value
+     *            The Date representing the expiration date.
+     *
+     * @throws NullPointerException if the passed in Bundle or date value are null
+     */
+    public static void putExpirationDate(Bundle bundle, Date value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+        putDate(bundle, EXPIRATION_DATE_KEY, value);
+    }
+
+    /**
+     * Gets the cached expiration date from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the expiration date was stored.
+     * @return the long representing the cached expiration date in milliseconds
+     *         since the epoch, or 0.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static long getExpirationMilliseconds(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getLong(EXPIRATION_DATE_KEY);
+    }
+
+    /**
+     * Puts the expiration date into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the expiration date should be stored.
+     * @param value
+     *            The long representing the expiration date in milliseconds
+     *            since the epoch.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static void putExpirationMilliseconds(Bundle bundle, long value) {
+        Validate.notNull(bundle, "bundle");
+        bundle.putLong(EXPIRATION_DATE_KEY, value);
+    }
+
+    /**
+     * Gets the cached list of permissions from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the list of permissions was stored.
+     * @return the cached list of permissions.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static List<String> getPermissions(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getStringArrayList(PERMISSIONS_KEY);
+    }
+
+    /**
+     * Puts the list of permissions into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the list of permissions should be stored.
+     * @param value
+     *            The List&lt;String&gt; representing the list of permissions,
+     *            or null.
+     *
+     * @throws NullPointerException if the passed in Bundle or permissions list are null
+     */
+    public static void putPermissions(Bundle bundle, List<String> value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+
+        ArrayList<String> arrayList;
+        if (value instanceof ArrayList<?>) {
+            arrayList = (ArrayList<String>) value;
+        } else {
+            arrayList = new ArrayList<String>(value);
+        }
+        bundle.putStringArrayList(PERMISSIONS_KEY, arrayList);
+    }
+
+    /**
+     * Gets the cached enum indicating the source of the token from the Bundle.
+     *
+     * @param bundle
+     *            A Bundle in which the enum was stored.
+     * @return enum indicating the source of the token
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static AccessTokenSource getSource(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        if (bundle.containsKey(TokenCachingStrategy.TOKEN_SOURCE_KEY)) {
+            return (AccessTokenSource) bundle.getSerializable(TokenCachingStrategy.TOKEN_SOURCE_KEY);
+        } else {
+            boolean isSSO = bundle.getBoolean(TokenCachingStrategy.IS_SSO_KEY);
+            return isSSO ? AccessTokenSource.FACEBOOK_APPLICATION_WEB : AccessTokenSource.WEB_VIEW;
+        }
+    }
+    /**
+     * Puts the enum indicating the source of the token into a Bundle.
+     *
+     * @param bundle
+     *            A Bundle in which the enum should be stored.
+     * @param value
+     *            enum indicating the source of the token
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static void putSource(Bundle bundle, AccessTokenSource value) {
+        Validate.notNull(bundle, "bundle");
+        bundle.putSerializable(TOKEN_SOURCE_KEY, value);
+    }
+
+    /**
+     * Gets the cached last refresh date from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the last refresh date was stored.
+     * @return the cached last refresh Date, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static Date getLastRefreshDate(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return getDate(bundle, LAST_REFRESH_DATE_KEY);
+    }
+
+    /**
+     * Puts the last refresh date into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the last refresh date should be stored.
+     * @param value
+     *            The Date representing the last refresh date, or null.
+     *
+     * @throws NullPointerException if the passed in Bundle or date value are null
+     */
+    public static void putLastRefreshDate(Bundle bundle, Date value) {
+        Validate.notNull(bundle, "bundle");
+        Validate.notNull(value, "value");
+        putDate(bundle, LAST_REFRESH_DATE_KEY, value);
+    }
+
+    /**
+     * Gets the cached last refresh date from a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the last refresh date was stored.
+     * @return the cached last refresh date in milliseconds since the epoch.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static long getLastRefreshMilliseconds(Bundle bundle) {
+        Validate.notNull(bundle, "bundle");
+        return bundle.getLong(LAST_REFRESH_DATE_KEY);
+    }
+
+    /**
+     * Puts the last refresh date into a Bundle.
+     * 
+     * @param bundle
+     *            A Bundle in which the last refresh date should be stored.
+     * @param value
+     *            The long representing the last refresh date in milliseconds
+     *            since the epoch.
+     *
+     * @throws NullPointerException if the passed in Bundle is null
+     */
+    public static void putLastRefreshMilliseconds(Bundle bundle, long value) {
+        Validate.notNull(bundle, "bundle");
+        bundle.putLong(LAST_REFRESH_DATE_KEY, value);
+    }
+
+    static Date getDate(Bundle bundle, String key) {
+        if (bundle == null) {
+            return null;
+        }
+
+        long n = bundle.getLong(key, INVALID_BUNDLE_MILLISECONDS);
+        if (n == INVALID_BUNDLE_MILLISECONDS) {
+            return null;
+        }
+
+        return new Date(n);
+    }
+
+    static void putDate(Bundle bundle, String key, Date date) {
+        bundle.putLong(key, date.getTime());
+    }
+}
diff --git a/funtown/src/tw/com/funtown/internal/CacheableRequestBatch.java b/funtown/src/tw/com/funtown/internal/CacheableRequestBatch.java
new file mode 100644
index 000000000..6864f7f08
--- /dev/null
+++ b/funtown/src/tw/com/funtown/internal/CacheableRequestBatch.java
@@ -0,0 +1,57 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown.internal;
+
+import tw.com.funtown.Request;
+import tw.com.funtown.RequestBatch;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class CacheableRequestBatch extends RequestBatch {
+    private String cacheKey;
+    private boolean forceRoundTrip;
+
+    public CacheableRequestBatch() {
+    }
+
+    public CacheableRequestBatch(Request... requests) {
+        super(requests);
+    }
+
+    public final String getCacheKeyOverride() {
+        return cacheKey;
+    }
+
+    // If this is set, the provided string will override the default key (the URL) for single requests.
+    // There is no default for multi-request batches, so no caching will be done unless the override is
+    // specified.
+    public final void setCacheKeyOverride(String cacheKey) {
+        this.cacheKey = cacheKey;
+    }
+
+    public final boolean getForceRoundTrip() {
+        return forceRoundTrip;
+    }
+
+    public final void setForceRoundTrip(boolean forceRoundTrip) {
+        this.forceRoundTrip = forceRoundTrip;
+    }
+
+}
diff --git a/funtown/src/tw/com/funtown/internal/FileLruCache.java b/funtown/src/tw/com/funtown/internal/FileLruCache.java
new file mode 100644
index 000000000..0ad44ac37
--- /dev/null
+++ b/funtown/src/tw/com/funtown/internal/FileLruCache.java
@@ -0,0 +1,606 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown.internal;
+
+import android.content.Context;
+import android.util.Log;
+import tw.com.funtown.LoggingBehavior;
+import tw.com.funtown.Settings;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.*;
+import java.security.InvalidParameterException;
+import java.util.Date;
+import java.util.PriorityQueue;
+import java.util.concurrent.atomic.AtomicLong;
+
+// This class is intended to be thread-safe.
+//
+// There are two classes of files:  buffer files and cache files:
+// - A buffer file is in the process of being written, and there is an open stream on the file.  These files are
+//   named as "bufferN" where N is an incrementing integer.  On startup, we delete all existing files of this form.
+//   Once the stream is closed, we rename the buffer file to a cache file or attempt to delete if this fails.  We
+//   do not otherwise ever attempt to delete these files.
+// - A cache file is a non-changing file that is named by the md5 hash of the cache key.  We monitor the size of
+//   these files in aggregate and remove the oldest one(s) to stay under quota.  This process does not block threads
+//   calling into this class, so theoretically we could go arbitrarily over quota but in practice this should not
+//   happen because deleting files should be much cheaper than downloading new file content.
+//
+// Since there can only ever be one thread accessing a particular buffer file, we do not synchronize access to these.
+// We do assume that file rename is atomic when converting a buffer file to a cache file, and that if multiple files
+// are renamed to a single target that exactly one of them continues to exist.
+//
+// Standard POSIX file semantics guarantee being able to continue to use a file handle even after the
+// corresponding file has been deleted.  Given this and that cache files never change other than deleting in trim(),
+// we only have to ensure that there is at most one trim() process deleting files at any given time.
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public final class FileLruCache {
+    static final String TAG = FileLruCache.class.getSimpleName();
+    private static final String HEADER_CACHEKEY_KEY = "key";
+    private static final String HEADER_CACHE_CONTENT_TAG_KEY = "tag";
+
+    private static final AtomicLong bufferIndex = new AtomicLong();
+
+    private final String tag;
+    private final Limits limits;
+    private final File directory;
+    private boolean isTrimPending;
+    private final Object lock;
+
+    // The value of tag should be a final String that works as a directory name.
+    public FileLruCache(Context context, String tag, Limits limits) {
+        this.tag = tag;
+        this.limits = limits;
+        this.directory = new File(context.getCacheDir(), tag);
+        this.lock = new Object();
+
+        // Ensure the cache dir exists
+        this.directory.mkdirs();
+
+        // Remove any stale partially-written files from a previous run
+        BufferFile.deleteAll(this.directory);
+    }
+
+    // Other code in this class is not necessarily robust to having buffer files deleted concurrently.
+    // If this is ever used for non-test code, we should make sure the synchronization is correct.  See
+    // the threading notes at the top of this class.
+    public void clearForTest() throws IOException {
+        for (File file : this.directory.listFiles()) {
+            file.delete();
+        }
+    }
+
+    // This is not robust to files changing dynamically underneath it and should therefore only be used
+    // for test code.  If we ever need this for product code we need to think through synchronization.
+    // See the threading notes at the top of this class.
+    //
+    // Also, since trim() runs asynchronously now, this blocks until any pending trim has completed.
+    long sizeInBytesForTest() {
+        synchronized (lock) {
+            while (isTrimPending) {
+                try {
+                    lock.wait();
+                } catch (InterruptedException e) {
+                    // intentional no-op
+                }
+            }
+        }
+
+        File[] files = this.directory.listFiles();
+        long total = 0;
+        for (File file : files) {
+            total += file.length();
+        }
+        return total;
+    }
+
+    public InputStream get(String key) throws IOException {
+        return get(key, null);
+    }
+
+    public InputStream get(String key, String contentTag) throws IOException {
+        File file = new File(this.directory, Utility.md5hash(key));
+
+        FileInputStream input = null;
+        try {
+            input = new FileInputStream(file);
+        } catch (IOException e) {
+            return null;
+        }
+
+        BufferedInputStream buffered = new BufferedInputStream(input, Utility.DEFAULT_STREAM_BUFFER_SIZE);
+        boolean success = false;
+
+        try {
+            JSONObject header = StreamHeader.readHeader(buffered);
+            if (header == null) {
+                return null;
+            }
+
+            String foundKey = header.optString(HEADER_CACHEKEY_KEY);
+            if ((foundKey == null) || !foundKey.equals(key)) {
+                return null;
+            }
+
+            String headerContentTag = header.optString(HEADER_CACHE_CONTENT_TAG_KEY, null);
+
+            if ((contentTag == null && headerContentTag != null) ||
+                    (contentTag != null && !contentTag.equals(headerContentTag))) {
+                return null;
+            }
+
+            long accessTime = new Date().getTime();
+            Logger.log(LoggingBehavior.CACHE, TAG, "Setting lastModified to " + Long.valueOf(accessTime) + " for "
+                    + file.getName());
+            file.setLastModified(accessTime);
+
+            success = true;
+            return buffered;
+        } finally {
+            if (!success) {
+                buffered.close();
+            }
+        }
+    }
+
+    OutputStream openPutStream(final String key) throws IOException {
+        return openPutStream(key, null);
+    }
+
+    public OutputStream openPutStream(final String key, String contentTag) throws IOException {
+        final File buffer = BufferFile.newFile(this.directory);
+        buffer.delete();
+        if (!buffer.createNewFile()) {
+            throw new IOException("Could not create file at " + buffer.getAbsolutePath());
+        }
+
+        FileOutputStream file = null;
+        try {
+            file = new FileOutputStream(buffer);
+        } catch (FileNotFoundException e) {
+            Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "Error creating buffer output stream: " + e);
+            throw new IOException(e.getMessage());
+        }
+
+        StreamCloseCallback renameToTargetCallback = new StreamCloseCallback() {
+            @Override
+            public void onClose() {
+                renameToTargetAndTrim(key, buffer);
+            }
+        };
+
+        CloseCallbackOutputStream cleanup = new CloseCallbackOutputStream(file, renameToTargetCallback);
+        BufferedOutputStream buffered = new BufferedOutputStream(cleanup, Utility.DEFAULT_STREAM_BUFFER_SIZE);
+        boolean success = false;
+
+        try {
+            // Prefix the stream with the actual key, since there could be collisions
+            JSONObject header = new JSONObject();
+            header.put(HEADER_CACHEKEY_KEY, key);
+            if (!Utility.isNullOrEmpty(contentTag)) {
+                header.put(HEADER_CACHE_CONTENT_TAG_KEY, contentTag);
+            }
+
+            StreamHeader.writeHeader(buffered, header);
+
+            success = true;
+            return buffered;
+        } catch (JSONException e) {
+            // JSON is an implementation detail of the cache, so don't let JSON exceptions out.
+            Logger.log(LoggingBehavior.CACHE, Log.WARN, TAG, "Error creating JSON header for cache file: " + e);
+            throw new IOException(e.getMessage());
+        } finally {
+            if (!success) {
+                buffered.close();
+            }
+        }
+    }
+
+    private void renameToTargetAndTrim(String key, File buffer) {
+        final File target = new File(directory, Utility.md5hash(key));
+
+        // This is triggered by close().  By the time close() returns, the file should be cached, so this needs to
+        // happen synchronously on this thread.
+        //
+        // However, it does not need to be synchronized, since in the race we will just start an unnecesary trim
+        // operation.  Avoiding the cost of holding the lock across the file operation seems worth this cost.
+        if (!buffer.renameTo(target)) {
+            buffer.delete();
+        }
+
+        postTrim();
+    }
+
+    // Opens an output stream for the key, and creates an input stream wrapper to copy
+    // the contents of input into the new output stream.  The effect is to store a
+    // copy of input, and associate that data with key.
+    public InputStream interceptAndPut(String key, InputStream input) throws IOException {
+        OutputStream output = openPutStream(key);
+        return new CopyingInputStream(input, output);
+    }
+
+    public String toString() {
+        return "{FileLruCache:" + " tag:" + this.tag + " file:" + this.directory.getName() + "}";
+    }
+
+    private void postTrim() {
+        synchronized (lock) {
+            if (!isTrimPending) {
+                isTrimPending = true;
+                Settings.getExecutor().execute(new Runnable() {
+                    @Override
+                    public void run() {
+                        trim();
+                    }
+                });
+            }
+        }
+    }
+
+    private void trim() {
+        try {
+            Logger.log(LoggingBehavior.CACHE, TAG, "trim started");
+            PriorityQueue<ModifiedFile> heap = new PriorityQueue<ModifiedFile>();
+            long size = 0;
+            long count = 0;
+            for (File file : this.directory.listFiles(BufferFile.excludeBufferFiles())) {
+                ModifiedFile modified = new ModifiedFile(file);
+                heap.add(modified);
+                Logger.log(LoggingBehavior.CACHE, TAG, "  trim considering time=" + Long.valueOf(modified.getModified())
+                        + " name=" + modified.getFile().getName());
+
+                size += file.length();
+                count++;
+            }
+
+            while ((size > limits.getByteCount()) || (count > limits.getFileCount())) {
+                File file = heap.remove().getFile();
+                Logger.log(LoggingBehavior.CACHE, TAG, "  trim removing " + file.getName());
+                size -= file.length();
+                count--;
+                file.delete();
+            }
+        } finally {
+            synchronized (lock) {
+                isTrimPending = false;
+                lock.notifyAll();
+            }
+        }
+    }
+
+    private static class BufferFile {
+        private static final String FILE_NAME_PREFIX = "buffer";
+        private static final FilenameFilter filterExcludeBufferFiles = new FilenameFilter() {
+            @Override
+            public boolean accept(File dir, String filename) {
+                return !filename.startsWith(FILE_NAME_PREFIX);
+            }
+        };
+        private static final FilenameFilter filterExcludeNonBufferFiles = new FilenameFilter() {
+            @Override
+            public boolean accept(File dir, String filename) {
+                return filename.startsWith(FILE_NAME_PREFIX);
+            }
+        };
+
+        static void deleteAll(final File root) {
+            for (File file : root.listFiles(excludeNonBufferFiles())) {
+                file.delete();
+            }
+        }
+
+        static FilenameFilter excludeBufferFiles() {
+            return filterExcludeBufferFiles;
+        }
+
+        static FilenameFilter excludeNonBufferFiles() {
+            return filterExcludeNonBufferFiles;
+        }
+
+        static File newFile(final File root) {
+            String name = FILE_NAME_PREFIX + Long.valueOf(bufferIndex.incrementAndGet()).toString();
+            return new File(root, name);
+        }
+    }
+
+    // Treats the first part of a stream as a header, reads/writes it as a JSON blob, and
+    // leaves the stream positioned exactly after the header.
+    //
+    // The format is as follows:
+    //     byte: meaning
+    // ---------------------------------
+    //        0: version number
+    //      1-3: big-endian JSON header blob size
+    // 4-size+4: UTF-8 JSON header blob
+    //      ...: stream data
+    private static final class StreamHeader {
+        private static final int HEADER_VERSION = 0;
+
+        static void writeHeader(OutputStream stream, JSONObject header) throws IOException {
+            String headerString = header.toString();
+            byte[] headerBytes = headerString.getBytes();
+
+            // Write version number and big-endian header size
+            stream.write(HEADER_VERSION);
+            stream.write((headerBytes.length >> 16) & 0xff);
+            stream.write((headerBytes.length >> 8) & 0xff);
+            stream.write((headerBytes.length >> 0) & 0xff);
+
+            stream.write(headerBytes);
+        }
+
+        static JSONObject readHeader(InputStream stream) throws IOException {
+            int version = stream.read();
+            if (version != HEADER_VERSION) {
+                return null;
+            }
+
+            int headerSize = 0;
+            for (int i = 0; i < 3; i++) {
+                int b = stream.read();
+                if (b == -1) {
+                    Logger.log(LoggingBehavior.CACHE, TAG,
+                            "readHeader: stream.read returned -1 while reading header size");
+                    return null;
+                }
+                headerSize <<= 8;
+                headerSize += b & 0xff;
+            }
+
+            byte[] headerBytes = new byte[headerSize];
+            int count = 0;
+            while (count < headerBytes.length) {
+                int readCount = stream.read(headerBytes, count, headerBytes.length - count);
+                if (readCount < 1) {
+                    Logger.log(LoggingBehavior.CACHE, TAG,
+                            "readHeader: stream.read stopped at " + Integer.valueOf(count) + " when expected "
+                                    + headerBytes.length);
+                    return null;
+                }
+                count += readCount;
+            }
+
+            String headerString = new String(headerBytes);
+            JSONObject header = null;
+            JSONTokener tokener = new JSONTokener(headerString);
+            try {
+                Object parsed = tokener.nextValue();
+                if (!(parsed instanceof JSONObject)) {
+                    Logger.log(LoggingBehavior.CACHE, TAG, "readHeader: expected JSONObject, got " + parsed.getClass().getCanonicalName());
+                    return null;
+                }
+                header = (JSONObject) parsed;
+            } catch (JSONException e) {
+                throw new IOException(e.getMessage());
+            }
+
+            return header;
+        }
+    }
+
+    private static class CloseCallbackOutputStream extends OutputStream {
+        final OutputStream innerStream;
+        final StreamCloseCallback callback;
+
+        CloseCallbackOutputStream(OutputStream innerStream, StreamCloseCallback callback) {
+            this.innerStream = innerStream;
+            this.callback = callback;
+        }
+
+        @Override
+        public void close() throws IOException {
+            try {
+                this.innerStream.close();
+            } finally {
+                this.callback.onClose();
+            }
+        }
+
+        @Override
+        public void flush() throws IOException {
+            this.innerStream.flush();
+        }
+
+        @Override
+        public void write(byte[] buffer, int offset, int count) throws IOException {
+            this.innerStream.write(buffer, offset, count);
+        }
+
+        @Override
+        public void write(byte[] buffer) throws IOException {
+            this.innerStream.write(buffer);
+        }
+
+        @Override
+        public void write(int oneByte) throws IOException {
+            this.innerStream.write(oneByte);
+        }
+    }
+
+    private static final class CopyingInputStream extends InputStream {
+        final InputStream input;
+        final OutputStream output;
+
+        CopyingInputStream(final InputStream input, final OutputStream output) {
+            this.input = input;
+            this.output = output;
+        }
+
+        @Override
+        public int available() throws IOException {
+            return input.available();
+        }
+
+        @Override
+        public void close() throws IOException {
+            // According to http://www.cs.cornell.edu/andru/javaspec/11.doc.html:
+            //  "If a finally clause is executed because of abrupt completion of a try block and the finally clause
+            //   itself completes abruptly, then the reason for the abrupt completion of the try block is discarded
+            //   and the new reason for abrupt completion is propagated from there."
+            //
+            // Android does appear to behave like this.
+            try {
+                this.input.close();
+            } finally {
+                this.output.close();
+            }
+        }
+
+        @Override
+        public void mark(int readlimit) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean markSupported() {
+            return false;
+        }
+
+        @Override
+        public int read(byte[] buffer) throws IOException {
+            int count = input.read(buffer);
+            if (count > 0) {
+                output.write(buffer, 0, count);
+            }
+            return count;
+        }
+
+        @Override
+        public int read() throws IOException {
+            int b = input.read();
+            if (b >= 0) {
+                output.write(b);
+            }
+            return b;
+        }
+
+        @Override
+        public int read(byte[] buffer, int offset, int length) throws IOException {
+            int count = input.read(buffer, offset, length);
+            if (count > 0) {
+                output.write(buffer, offset, count);
+            }
+            return count;
+        }
+
+        @Override
+        public synchronized void reset() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public long skip(long byteCount) throws IOException {
+            byte[] buffer = new byte[1024];
+            long total = 0;
+            while (total < byteCount) {
+                int count = read(buffer, 0, (int)Math.min(byteCount - total, buffer.length));
+                if (count < 0) {
+                    return total;
+                }
+                total += count;
+            }
+            return total;
+        }
+    }
+
+    public static final class Limits {
+        private int byteCount;
+        private int fileCount;
+
+        public Limits() {
+            // A Samsung Galaxy Nexus can create 1k files in half a second.  By the time
+            // it gets to 5k files it takes 5 seconds.  10k files took 15 seconds.  This
+            // continues to slow down as files are added.  This assumes all files are in
+            // a single directory.
+            //
+            // Following a git-like strategy where we partition MD5-named files based on
+            // the first 2 characters is slower across the board.
+            this.fileCount = 1024;
+            this.byteCount = 1024 * 1024;
+        }
+
+        int getByteCount() {
+            return byteCount;
+        }
+
+        int getFileCount() {
+            return fileCount;
+        }
+
+        void setByteCount(int n) {
+            if (n < 0) {
+                throw new InvalidParameterException("Cache byte-count limit must be >= 0");
+            }
+            byteCount = n;
+        }
+
+        void setFileCount(int n) {
+            if (n < 0) {
+                throw new InvalidParameterException("Cache file count limit must be >= 0");
+            }
+            fileCount = n;
+        }
+    }
+
+    // Caches the result of lastModified during sort/heap operations
+    private final static class ModifiedFile implements Comparable<ModifiedFile> {
+        private final File file;
+        private final long modified;
+
+        ModifiedFile(File file) {
+            this.file = file;
+            this.modified = file.lastModified();
+        }
+
+        File getFile() {
+            return file;
+        }
+
+        long getModified() {
+            return modified;
+        }
+
+        @Override
+        public int compareTo(ModifiedFile another) {
+            if (getModified() < another.getModified()) {
+                return -1;
+            } else if (getModified() > another.getModified()) {
+                return 1;
+            } else {
+                return getFile().compareTo(another.getFile());
+            }
+        }
+
+        @Override
+        public boolean equals(Object another) {
+            return
+                    (another instanceof ModifiedFile) &&
+                    (compareTo((ModifiedFile)another) == 0);
+        }
+    }
+
+    private interface StreamCloseCallback {
+        void onClose();
+    }
+}
diff --git a/funtown/src/tw/com/funtown/internal/Logger.java b/funtown/src/tw/com/funtown/internal/Logger.java
new file mode 100644
index 000000000..dc6182dde
--- /dev/null
+++ b/funtown/src/tw/com/funtown/internal/Logger.java
@@ -0,0 +1,144 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown.internal;
+
+import android.util.Log;
+import tw.com.funtown.LoggingBehavior;
+import tw.com.funtown.Settings;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class Logger {
+    public static final String LOG_TAG_BASE = "FuntownSDK.";
+    private static final HashMap<String, String> stringsToReplace = new HashMap<String, String>();
+
+    private final LoggingBehavior behavior;
+    private final String tag;
+    private StringBuilder contents;
+    private int priority = Log.DEBUG;
+
+    // Note that the mapping of replaced strings is never emptied, so it should be used only for things that
+    // are not expected to be too numerous, such as access tokens.
+    public synchronized static void registerStringToReplace(String original, String replace) {
+        stringsToReplace.put(original, replace);
+    }
+
+    public synchronized static void registerAccessToken(String accessToken) {
+        if (Settings.isLoggingBehaviorEnabled(LoggingBehavior.INCLUDE_ACCESS_TOKENS) == false) {
+            registerStringToReplace(accessToken, "ACCESS_TOKEN_REMOVED");
+        }
+    }
+
+    public static void log(LoggingBehavior behavior, String tag, String string) {
+        log(behavior, Log.DEBUG, tag, string);
+    }
+
+    public static void log(LoggingBehavior behavior, String tag, String format, Object... args) {
+        if (Settings.isLoggingBehaviorEnabled(behavior)) {
+            String string = String.format(format, args);
+            log(behavior, Log.DEBUG, tag, string);
+        }
+    }
+
+    public static void log(LoggingBehavior behavior, int priority, String tag, String string) {
+        if (Settings.isLoggingBehaviorEnabled(behavior)) {
+            string = replaceStrings(string);
+            if (tag.startsWith(LOG_TAG_BASE) == false) {
+                tag = LOG_TAG_BASE + tag;
+            }
+            Log.println(priority, tag, string);
+
+            // Developer errors warrant special treatment by printing out a stack trace, to make both more noticeable,
+            // and let the source of the problem be more easily pinpointed.
+            if (behavior == LoggingBehavior.DEVELOPER_ERRORS) {
+                (new Exception()).printStackTrace();
+            }
+        }
+    }
+
+    private synchronized static String replaceStrings(String string) {
+        for (Map.Entry<String, String> entry : stringsToReplace.entrySet()) {
+            string = string.replace(entry.getKey(), entry.getValue());
+        }
+        return string;
+    }
+
+    public Logger(LoggingBehavior behavior, String tag) {
+        Validate.notNullOrEmpty(tag, "tag");
+
+        this.behavior = behavior;
+        this.tag = LOG_TAG_BASE + tag;
+        this.contents = new StringBuilder();
+    }
+
+    public int getPriority() {
+        return priority;
+    }
+
+    public void setPriority(int value) {
+        Validate.oneOf(value, "value", Log.ASSERT, Log.DEBUG, Log.ERROR, Log.INFO, Log.VERBOSE, Log.WARN);
+
+        priority = value;
+    }
+
+    public String getContents() {
+        return replaceStrings(contents.toString());
+    }
+
+    // Writes the accumulated contents, then clears contents to start again.
+    public void log() {
+        logString(contents.toString());
+        contents = new StringBuilder();
+    }
+
+    // Immediately logs a string, ignoring any accumulated contents, which are left unchanged.
+    public void logString(String string) {
+        log(behavior, priority, tag, string);
+    }
+
+    public void append(StringBuilder stringBuilder) {
+        if (shouldLog()) {
+            contents.append(stringBuilder);
+        }
+    }
+
+    public void append(String string) {
+        if (shouldLog()) {
+            contents.append(string);
+        }
+    }
+
+    public void append(String format, Object... args) {
+        if (shouldLog()) {
+            contents.append(String.format(format, args));
+        }
+    }
+
+    public void appendKeyValue(String key, Object value) {
+        append("  %s:\t%s\n", key, value);
+    }
+
+    private boolean shouldLog() {
+        return Settings.isLoggingBehaviorEnabled(behavior);
+    }
+}
diff --git a/funtown/src/tw/com/funtown/internal/ServerProtocol.java b/funtown/src/tw/com/funtown/internal/ServerProtocol.java
new file mode 100644
index 000000000..03520bc38
--- /dev/null
+++ b/funtown/src/tw/com/funtown/internal/ServerProtocol.java
@@ -0,0 +1,51 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown.internal;
+
+import com.facebook.internal.Utility;
+
+import java.util.Collection;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public final class ServerProtocol {
+    static final String FUNTOWN_COM = "funtown.com.tw";
+    public static final String DIALOG_AUTHORITY = "weblogin." + FUNTOWN_COM;
+    public static final String DIALOG_PATH = "oauth/";
+    public static final String DIALOG_PARAM_SCOPE = "scope";
+    public static final String DIALOG_PARAM_CLIENT_ID = "client_id";
+    public static final String DIALOG_PARAM_VIEW = "view";
+    public static final String DIALOG_PARAM_REDIRECT_URI = "redirect_uri";
+    public static final String DIALOG_PARAM_RESPONSE_TYPE = "response_type";
+    public static final String DIALOG_PARAM_TYPE = "type";    
+    public static final String DIALOG_PARAM_ACCESS_TOKEN = "access_token";
+    public static final String DIALOG_PARAM_APP_ID = "app_id";
+
+    // URL components
+    public static final String GRAPH_URL = "https://graph." + FUNTOWN_COM;
+    public static final String GRAPH_URL_BASE = "https://graph." + FUNTOWN_COM + "/";
+    public static final String REST_URL_BASE = "https://api." + FUNTOWN_COM + "/method/";
+    public static final String BATCHED_REST_METHOD_URL_BASE = "method/";
+
+    public static final Collection<String> errorsProxyAuthDisabled =
+            Utility.unmodifiableCollection("service_disabled", "AndroidAuthKillSwitchException");
+    public static final Collection<String> errorsUserCanceled =
+            Utility.unmodifiableCollection("access_denied", "OAuthAccessDeniedException");
+}
diff --git a/funtown/src/tw/com/funtown/internal/SessionAuthorizationType.java b/funtown/src/tw/com/funtown/internal/SessionAuthorizationType.java
new file mode 100644
index 000000000..543cba253
--- /dev/null
+++ b/funtown/src/tw/com/funtown/internal/SessionAuthorizationType.java
@@ -0,0 +1,27 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown.internal;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public enum SessionAuthorizationType {
+    READ,
+    PUBLISH
+}
diff --git a/funtown/src/tw/com/funtown/internal/SessionTracker.java b/funtown/src/tw/com/funtown/internal/SessionTracker.java
new file mode 100644
index 000000000..77269460a
--- /dev/null
+++ b/funtown/src/tw/com/funtown/internal/SessionTracker.java
@@ -0,0 +1,239 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown.internal;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.support.v4.content.LocalBroadcastManager;
+import tw.com.funtown.Session;
+import tw.com.funtown.SessionState;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public class SessionTracker {
+
+    private Session session;
+    private final Session.StatusCallback callback;
+    private final BroadcastReceiver receiver;
+    private final LocalBroadcastManager broadcastManager;
+    private boolean isTracking = false;
+
+    /**
+     * Constructs a SessionTracker to track the active Session object.
+     * 
+     * @param context the context object.
+     * @param callback the callback to use whenever the active Session's 
+     *                 state changes
+     */
+    public SessionTracker(Context context, Session.StatusCallback callback) {
+        this(context, callback, null);
+    }
+    
+    /**
+     * Constructs a SessionTracker to track the Session object passed in.
+     * If the Session is null, then it will track the active Session instead.
+     * 
+     * @param context the context object.
+     * @param callback the callback to use whenever the Session's state changes
+     * @param session the Session object to track
+     */
+    SessionTracker(Context context, Session.StatusCallback callback, Session session) {
+        this(context, callback, session, true);
+    }
+    
+    /**
+     * Constructs a SessionTracker to track the Session object passed in.
+     * If the Session is null, then it will track the active Session instead.
+     * 
+     * @param context the context object.
+     * @param callback the callback to use whenever the Session's state changes
+     * @param session the Session object to track
+     * @param startTracking whether to start tracking the Session right away
+     */
+    public SessionTracker(Context context, Session.StatusCallback callback, Session session, boolean startTracking) {
+        this.callback = new CallbackWrapper(callback);
+        this.session = session;
+        this.receiver = new ActiveSessionBroadcastReceiver();
+        this.broadcastManager = LocalBroadcastManager.getInstance(context);
+
+        if (startTracking) {
+            startTracking();
+        }
+    }
+
+    /**
+     * Returns the current Session that's being tracked.
+     * 
+     * @return the current Session associated with this tracker
+     */
+    public Session getSession() {
+        return (session == null) ? Session.getActiveSession() : session;
+    }
+
+    /**
+     * Returns the current Session that's being tracked if it's open, 
+     * otherwise returns null.
+     * 
+     * @return the current Session if it's open, otherwise returns null
+     */
+    public Session getOpenSession() {
+        Session openSession = getSession();
+        if (openSession != null && openSession.isOpened()) {
+            return openSession;
+        }
+        return null;
+    }
+
+    /**
+     * Set the Session object to track.
+     * 
+     * @param newSession the new Session object to track
+     */
+    public void setSession(Session newSession) {
+        if (newSession == null) {
+            if (session != null) {
+                // We're current tracking a Session. Remove the callback
+                // and start tracking the active Session.
+                session.removeCallback(callback);
+                session = null;
+                addBroadcastReceiver();
+                if (getSession() != null) {
+                    getSession().addCallback(callback);
+                }
+            }
+        } else {
+            if (session == null) {
+                // We're currently tracking the active Session, but will be
+                // switching to tracking a different Session object.
+                Session activeSession = Session.getActiveSession();
+                if (activeSession != null) {
+                    activeSession.removeCallback(callback);
+                }
+                broadcastManager.unregisterReceiver(receiver);
+            } else {
+                // We're currently tracking a Session, but are now switching 
+                // to a new Session, so we remove the callback from the old 
+                // Session, and add it to the new one.
+                session.removeCallback(callback);
+            }
+            session = newSession;
+            session.addCallback(callback);
+        }
+    }
+
+    /**
+     * Start tracking the Session (either active or the one given). 
+     */
+    public void startTracking() {
+        if (isTracking) {
+            return;
+        }
+        if (this.session == null) {
+            addBroadcastReceiver();
+        }        
+        // if the session is not null, then add the callback to it right away
+        if (getSession() != null) {
+            getSession().addCallback(callback);
+        }
+        isTracking = true;
+    }
+
+    /**
+     * Stop tracking the Session and remove any callbacks attached
+     * to those sessions.
+     */
+    public void stopTracking() {
+        if (!isTracking) {
+            return;
+        }
+        Session session = getSession();
+        if (session != null) {
+            session.removeCallback(callback);
+        }
+        broadcastManager.unregisterReceiver(receiver);
+        isTracking = false;
+    }
+    
+    /**
+     * Returns whether it's currently tracking the Session.
+     * 
+     * @return true if currently tracking the Session
+     */
+    public boolean isTracking() {
+        return isTracking;
+    }
+
+    /**
+     * Returns whether it's currently tracking the active Session.
+     *
+     * @return true if the currently tracked session is the active Session.
+     */
+    public boolean isTrackingActiveSession() {
+        return session == null;
+    }
+    
+    private void addBroadcastReceiver() {
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_SET);
+        filter.addAction(Session.ACTION_ACTIVE_SESSION_UNSET);
+        
+        // Add a broadcast receiver to listen to when the active Session
+        // is set or unset, and add/remove our callback as appropriate    
+        broadcastManager.registerReceiver(receiver, filter);
+    }
+
+    /**
+     * The BroadcastReceiver implementation that either adds or removes the callback
+     * from the active Session object as it's SET or UNSET.
+     */
+    private class ActiveSessionBroadcastReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (Session.ACTION_ACTIVE_SESSION_SET.equals(intent.getAction())) {
+                Session session = Session.getActiveSession();
+                if (session != null) {
+                    session.addCallback(SessionTracker.this.callback);
+                }
+            }
+        }
+    }
+
+    private class CallbackWrapper implements Session.StatusCallback {
+
+        private final Session.StatusCallback wrapped;
+        public CallbackWrapper(Session.StatusCallback wrapped) {
+            this.wrapped = wrapped;
+        }
+
+        @Override
+        public void call(Session session, SessionState state, Exception exception) {
+            if (wrapped != null && isTracking()) {
+                wrapped.call(session, state, exception);
+            }
+            // if we're not tracking the Active Session, and the current session
+            // is closed, then start tracking the Active Session.
+            if (session == SessionTracker.this.session && state.isClosed()) {
+                setSession(null);
+            }
+        }
+    }
+}
diff --git a/funtown/src/tw/com/funtown/internal/Utility.java b/funtown/src/tw/com/funtown/internal/Utility.java
new file mode 100644
index 000000000..f493948af
--- /dev/null
+++ b/funtown/src/tw/com/funtown/internal/Utility.java
@@ -0,0 +1,361 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown.internal;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Parcelable;
+import android.text.TextUtils;
+import android.util.Log;
+import android.webkit.CookieManager;
+import android.webkit.CookieSyncManager;
+import tw.com.funtown.*;
+import com.facebook.android.BuildConfig;
+import com.facebook.model.GraphObject;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.*;
+import java.net.HttpURLConnection;
+import java.net.URLConnection;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.*;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public final class Utility {
+    static final String LOG_TAG = "FacebookSDK";
+    private static final String HASH_ALGORITHM_MD5 = "MD5";
+    private static final String URL_SCHEME = "https";
+    private static final String SUPPORTS_ATTRIBUTION = "supports_attribution";
+    private static final String APPLICATION_FIELDS = "fields";
+
+    // This is the default used by the buffer streams, but they trace a warning if you do not specify.
+    public static final int DEFAULT_STREAM_BUFFER_SIZE = 8192;
+
+    private static final Object LOCK = new Object();
+    private static volatile boolean attributionAllowedForLastAppChecked = false;
+    private static volatile String lastAppCheckedForAttributionStatus = "";
+
+    // Returns true iff all items in subset are in superset, treating null and
+    // empty collections as
+    // the same.
+    public static <T> boolean isSubset(Collection<T> subset, Collection<T> superset) {
+        if ((superset == null) || (superset.size() == 0)) {
+            return ((subset == null) || (subset.size() == 0));
+        }
+
+        HashSet<T> hash = new HashSet<T>(superset);
+        for (T t : subset) {
+            if (!hash.contains(t)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public static <T> boolean isNullOrEmpty(Collection<T> c) {
+        return (c == null) || (c.size() == 0);
+    }
+
+    public static boolean isNullOrEmpty(String s) {
+        return (s == null) || (s.length() == 0);
+    }
+
+    public static <T> Collection<T> unmodifiableCollection(T... ts) {
+        return Collections.unmodifiableCollection(Arrays.asList(ts));
+    }
+
+    public static <T> ArrayList<T> arrayList(T... ts) {
+        ArrayList<T> arrayList = new ArrayList<T>(ts.length);
+        for (T t : ts) {
+            arrayList.add(t);
+        }
+        return arrayList;
+    }
+
+    static String md5hash(String key) {
+        MessageDigest hash = null;
+        try {
+            hash = MessageDigest.getInstance(HASH_ALGORITHM_MD5);
+        } catch (NoSuchAlgorithmException e) {
+            return null;
+        }
+
+        hash.update(key.getBytes());
+        byte[] digest = hash.digest();
+        StringBuilder builder = new StringBuilder();
+        for (int b : digest) {
+            builder.append(Integer.toHexString((b >> 4) & 0xf));
+            builder.append(Integer.toHexString((b >> 0) & 0xf));
+        }
+        return builder.toString();
+    }
+
+    public static Uri buildUri(String authority, String path, Bundle parameters) {
+        Uri.Builder builder = new Uri.Builder();
+        builder.scheme(URL_SCHEME);
+        builder.authority(authority);
+        builder.path(path);
+        for (String key : parameters.keySet()) {
+            Object parameter = parameters.get(key);
+            if (parameter instanceof String) {
+                builder.appendQueryParameter(key, (String) parameter);
+            }
+        }
+        return builder.build();
+    }
+
+    public static void putObjectInBundle(Bundle bundle, String key, Object value) {
+        if (value instanceof String) {
+            bundle.putString(key, (String) value);
+        } else if (value instanceof Parcelable) {
+            bundle.putParcelable(key, (Parcelable) value);
+        } else if (value instanceof byte[]) {
+            bundle.putByteArray(key, (byte[]) value);
+        } else {
+            throw new FuntownException("attempted to add unsupported type to Bundle");
+        }
+    }
+
+    public static void closeQuietly(Closeable closeable) {
+        try {
+            if (closeable != null) {
+                closeable.close();
+            }
+        } catch (IOException ioe) {
+            // ignore
+        }
+    }
+
+    public static void disconnectQuietly(URLConnection connection) {
+        if (connection instanceof HttpURLConnection) {
+            ((HttpURLConnection)connection).disconnect();
+        }
+    }
+
+//    public static String getMetadataApplicationId(Context context) {
+//        try {
+//            ApplicationInfo ai = context.getPackageManager().getApplicationInfo(
+//                    context.getPackageName(), PackageManager.GET_META_DATA);
+//           if (ai.metaData != null) {
+//                return ai.metaData.getString(Session.APPLICATION_ID_PROPERTY);
+//            }
+//        } catch (PackageManager.NameNotFoundException e) {
+//            // if we can't find it in the manifest, just return null
+//        }
+//
+//        return null;
+//    }
+
+    public static String getMetadataClientId(Context context) {
+        try {
+            ApplicationInfo ai = context.getPackageManager().getApplicationInfo(
+                    context.getPackageName(), PackageManager.GET_META_DATA);
+            if (ai.metaData != null) {
+                return ai.metaData.getString(Session.CLIENT_ID_PROPERTY);
+            }
+        } catch (PackageManager.NameNotFoundException e) {
+            // if we can't find it in the manifest, just return null
+        }
+
+        return null;
+    }
+    public static String getMetadataRedirctUri(Context context) {
+        try {
+            ApplicationInfo ai = context.getPackageManager().getApplicationInfo(
+                    context.getPackageName(), PackageManager.GET_META_DATA);
+            if (ai.metaData != null) {
+                return ai.metaData.getString(Session.REDIRECT_URI_PROPERTY);
+            }
+        } catch (PackageManager.NameNotFoundException e) {
+            // if we can't find it in the manifest, just return null
+        }
+
+        return null;
+    }    
+    static Map<String, Object> convertJSONObjectToHashMap(JSONObject jsonObject) {
+        HashMap<String, Object> map = new HashMap<String, Object>();
+        JSONArray keys = jsonObject.names();
+        for (int i = 0; i < keys.length(); ++i) {
+            String key;
+            try {
+                key = keys.getString(i);
+                Object value = jsonObject.get(key);
+                if (value instanceof JSONObject) {
+                    value = convertJSONObjectToHashMap((JSONObject) value);
+                }
+                map.put(key, value);
+            } catch (JSONException e) {
+            }
+        }
+        return map;
+    }
+
+    // Returns either a JSONObject or JSONArray representation of the 'key' property of 'jsonObject'.
+    public static Object getStringPropertyAsJSON(JSONObject jsonObject, String key, String nonJSONPropertyKey)
+            throws JSONException {
+        Object value = jsonObject.opt(key);
+        if (value != null && value instanceof String) {
+            JSONTokener tokener = new JSONTokener((String) value);
+            value = tokener.nextValue();
+        }
+
+        if (value != null && !(value instanceof JSONObject || value instanceof JSONArray)) {
+            if (nonJSONPropertyKey != null) {
+                // Facebook sometimes gives us back a non-JSON value such as
+                // literal "true" or "false" as a result.
+                // If we got something like that, we present it to the caller as
+                // a GraphObject with a single
+                // property. We only do this if the caller wants that behavior.
+                jsonObject = new JSONObject();
+                jsonObject.putOpt(nonJSONPropertyKey, value);
+                return jsonObject;
+            } else {
+                throw new FuntownException("Got an unexpected non-JSON object.");
+            }
+        }
+
+        return value;
+
+    }
+
+    public static String readStreamToString(InputStream inputStream) throws IOException {
+        BufferedInputStream bufferedInputStream = null;
+        InputStreamReader reader = null;
+        try {
+            bufferedInputStream = new BufferedInputStream(inputStream);
+            reader = new InputStreamReader(bufferedInputStream);
+            StringBuilder stringBuilder = new StringBuilder();
+
+            final int bufferSize = 1024 * 2;
+            char[] buffer = new char[bufferSize];
+            int n = 0;
+            while ((n = reader.read(buffer)) != -1) {
+                stringBuilder.append(buffer, 0, n);
+            }
+
+            return stringBuilder.toString();
+        } finally {
+            closeQuietly(bufferedInputStream);
+            closeQuietly(reader);
+        }
+    }
+
+    public static boolean stringsEqualOrEmpty(String a, String b) {
+        boolean aEmpty = TextUtils.isEmpty(a);
+        boolean bEmpty = TextUtils.isEmpty(b);
+
+        if (aEmpty && bEmpty) {
+            // Both null or empty, they match.
+            return true;
+        }
+        if (!aEmpty && !bEmpty) {
+            // Both non-empty, check equality.
+            return a.equals(b);
+        }
+        // One empty, one non-empty, can't match.
+        return false;
+    }
+
+    private static void clearCookiesForDomain(Context context, String domain) {
+        // This is to work around a bug where CookieManager may fail to instantiate if CookieSyncManager
+        // has never been created.
+        CookieSyncManager syncManager = CookieSyncManager.createInstance(context);
+        syncManager.sync();
+
+        CookieManager cookieManager = CookieManager.getInstance();
+
+        String cookies = cookieManager.getCookie(domain);
+        if (cookies == null) {
+            return;
+        }
+
+        String[] splitCookies = cookies.split(";");
+        for (String cookie : splitCookies) {
+            String[] cookieParts = cookie.split("=");
+            if (cookieParts.length > 0) {
+                String newCookie = cookieParts[0].trim() + "=;expires=Sat, 1 Jan 2000 00:00:01 UTC;";
+                cookieManager.setCookie(domain, newCookie);
+            }
+        }
+        cookieManager.removeExpiredCookie();
+    }
+
+    public static void clearFuntownCookies(Context context) {
+        // setCookie acts differently when trying to expire cookies between builds of Android that are using
+        // Chromium HTTP stack and those that are not. Using both of these domains to ensure it works on both.
+        clearCookiesForDomain(context, "funtown.com.tw");
+        clearCookiesForDomain(context, ".funtown.com.tw");
+        clearCookiesForDomain(context, "https://funtown.com.tw");
+        clearCookiesForDomain(context, "https://.funtown.com.tw");
+    }
+
+    public static void logd(String tag, Exception e) {
+        if (BuildConfig.DEBUG && tag != null && e != null) {
+            Log.d(tag, e.getClass().getSimpleName() + ": " + e.getMessage());
+        }
+    }
+
+    public static void logd(String tag, String msg) {
+        if (BuildConfig.DEBUG && tag != null && msg != null) {
+            Log.d(tag, msg);
+        }
+    }
+
+    public static boolean queryAppAttributionSupportAndWait(final String applicationId) {
+
+        synchronized (LOCK) {
+
+            // Cache the last app checked results.
+            if (applicationId.equals(lastAppCheckedForAttributionStatus)) {
+                return attributionAllowedForLastAppChecked;
+            }
+
+            Bundle supportsAttributionParams = new Bundle();
+            supportsAttributionParams.putString(APPLICATION_FIELDS, SUPPORTS_ATTRIBUTION);
+            Request pingRequest = Request.newGraphPathRequest(null, applicationId, null);
+            pingRequest.setParameters(supportsAttributionParams);
+
+            GraphObject supportResponse = pingRequest.executeAndWait().getGraphObject();
+
+            Object doesSupportAttribution = false;
+            if (supportResponse != null) {
+                doesSupportAttribution = supportResponse.getProperty(SUPPORTS_ATTRIBUTION);
+            }
+
+            if (!(doesSupportAttribution instanceof Boolean)) {
+                // Should never happen, but be safe in case server returns non-Boolean
+                doesSupportAttribution = false;
+            }
+
+            lastAppCheckedForAttributionStatus = applicationId;
+            attributionAllowedForLastAppChecked = ((Boolean)doesSupportAttribution == true);
+            return attributionAllowedForLastAppChecked;
+        }
+    }
+
+}
diff --git a/funtown/src/tw/com/funtown/internal/Validate.java b/funtown/src/tw/com/funtown/internal/Validate.java
new file mode 100644
index 000000000..19b42f1dd
--- /dev/null
+++ b/funtown/src/tw/com/funtown/internal/Validate.java
@@ -0,0 +1,73 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown.internal;
+
+import java.util.Collection;
+
+/**
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public final class Validate {
+    public static void notNull(Object arg, String name) {
+        if (arg == null) {
+            throw new NullPointerException("Argument '" + name + "' cannot be null");
+        }
+    }
+
+    public static <T> void notEmpty(Collection<T> container, String name) {
+        if (container.isEmpty()) {
+            throw new IllegalArgumentException("Container '" + name + "' cannot be empty");
+        }
+    }
+
+    public static <T> void containsNoNulls(Collection<T> container, String name) {
+        Validate.notNull(container, name);
+        for (T item : container) {
+            if (item == null) {
+                throw new NullPointerException("Container '" + name + "' cannot contain null values");
+            }
+        }
+    }
+
+    public static <T> void notEmptyAndContainsNoNulls(Collection<T> container, String name) {
+        Validate.containsNoNulls(container, name);
+        Validate.notEmpty(container, name);
+    }
+
+    public static void notNullOrEmpty(String arg, String name) {
+        if (Utility.isNullOrEmpty(arg)) {
+            throw new IllegalArgumentException("Argument '" + name + "' cannot be null or empty");
+        }
+    }
+
+    public static void oneOf(Object arg, String name, Object... values) {
+        for (Object value : values) {
+            if (value != null) {
+                if (value.equals(arg)) {
+                    return;
+                }
+            } else {
+                if (arg == null) {
+                    return;
+                }
+            }
+        }
+        throw new IllegalArgumentException("Argument '" + name + "' was not one of the allowed values");
+    }
+}
diff --git a/funtown/src/tw/com/funtown/widget/WebDialog.java b/funtown/src/tw/com/funtown/widget/WebDialog.java
new file mode 100644
index 000000000..f0bbd6eec
--- /dev/null
+++ b/funtown/src/tw/com/funtown/widget/WebDialog.java
@@ -0,0 +1,735 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package tw.com.funtown.widget;
+
+import android.annotation.SuppressLint;
+import android.app.Dialog;
+import android.app.ProgressDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.net.http.SslError;
+import android.os.Bundle;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.webkit.SslErrorHandler;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import com.facebook.android.*;
+import tw.com.funtown.internal.Logger;
+import tw.com.funtown.internal.Utility;
+import tw.com.funtown.internal.Validate;
+import tw.com.funtown.internal.ServerProtocol;
+import tw.com.funtown.*;
+/**
+ * This class provides a mechanism for displaying Facebook Web dialogs inside a Dialog. Helper
+ * methods are provided to construct commonly-used dialogs, or a caller can specify arbitrary
+ * parameters to call other dialogs.
+ */
+public class WebDialog extends Dialog {
+    private static final String LOG_TAG = Logger.LOG_TAG_BASE + "WebDialog";
+    private static final String DISPLAY_TOUCH = "touch";
+    private static final String VIEW_REG = "reg_mobile";    
+    private static final String USER_AGENT = "user_agent";
+    static final String REDIRECT_URI = "ftconnect://success";
+    static final String CANCEL_URI = "ftconnect://cancel";
+    static final boolean DISABLE_SSL_CHECK_FOR_TESTING = false;
+
+    public static final int DEFAULT_THEME = android.R.style.Theme_Translucent_NoTitleBar;
+
+    private String url;
+    private OnCompleteListener onCompleteListener;
+    private WebView webView;
+    private ProgressDialog spinner;
+    private ImageView crossImageView;
+    private FrameLayout contentFrameLayout;
+    private boolean listenerCalled = false;
+    private boolean isDetached = false;
+
+    /**
+     * Interface that implements a listener to be called when the user's interaction with the
+     * dialog completes, whether because the dialog finished successfully, or it was cancelled,
+     * or an error was encountered.
+     */
+    public interface OnCompleteListener {
+        /**
+         * Called when the dialog completes.
+         *
+         * @param values on success, contains the values returned by the dialog
+         * @param error  on an error, contains an exception describing the error
+         */
+        void onComplete(Bundle values, FuntownException error);
+    }
+
+    /**
+     * Constructor which can be used to display a dialog with an already-constructed URL.
+     *
+     * @param context the context to use to display the dialog
+     * @param url     the URL of the Web Dialog to display; no validation is done on this URL, but it should
+     *                be a valid URL pointing to a Facebook Web Dialog
+     */
+    public WebDialog(Context context, String url) {
+        this(context, url, DEFAULT_THEME);
+    }
+
+    /**
+     * Constructor which can be used to display a dialog with an already-constructed URL and a custom theme.
+     *
+     * @param context the context to use to display the dialog
+     * @param url     the URL of the Web Dialog to display; no validation is done on this URL, but it should
+     *                be a valid URL pointing to a Facebook Web Dialog
+     * @param theme   identifier of a theme to pass to the Dialog class
+     */
+    public WebDialog(Context context, String url, int theme) {
+        super(context, theme);
+        this.url = url;
+    }
+
+    /**
+     * Constructor which will construct the URL of the Web dialog based on the specified parameters.
+     *
+     * @param context    the context to use to display the dialog
+     * @param action     the portion of the dialog URL following "dialog/"
+     * @param parameters parameters which will be included as part of the URL
+     * @param theme      identifier of a theme to pass to the Dialog class
+     * @param listener the listener to notify, or null if no notification is desired
+     */
+    public WebDialog(Context context, String action, Bundle parameters, int theme, OnCompleteListener listener) {
+        super(context, theme);
+
+        if (parameters == null) {
+            parameters = new Bundle();
+        }
+        parameters.putString(ServerProtocol.DIALOG_PARAM_VIEW, VIEW_REG);
+        parameters.putString(ServerProtocol.DIALOG_PARAM_TYPE, USER_AGENT);
+
+        Uri uri = Utility.buildUri(ServerProtocol.DIALOG_AUTHORITY, ServerProtocol.DIALOG_PATH + action, parameters);
+        this.url = uri.toString();
+        onCompleteListener = listener;
+    }
+
+    /**
+     * Sets the listener which will be notified when the dialog finishes.
+     *
+     * @param listener the listener to notify, or null if no notification is desired
+     */
+    public void setOnCompleteListener(OnCompleteListener listener) {
+        onCompleteListener = listener;
+    }
+
+    /**
+     * Gets the listener which will be notified when the dialog finishes.
+     *
+     * @return the listener, or null if none has been specified
+     */
+    public OnCompleteListener getOnCompleteListener() {
+        return onCompleteListener;
+    }
+
+    @Override
+    public void dismiss() {
+        if (webView != null) {
+            webView.stopLoading();
+        }
+        if (!isDetached) {
+            if (spinner.isShowing()) {
+                spinner.dismiss();
+            }
+            super.dismiss();
+        }
+    }
+
+    @Override
+    public void onDetachedFromWindow() {
+        isDetached = true;
+        super.onDetachedFromWindow();
+    }
+
+    @Override
+    public void onAttachedToWindow() {
+        isDetached = false;
+        super.onAttachedToWindow();
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        setOnCancelListener(new OnCancelListener() {
+            @Override
+            public void onCancel(DialogInterface dialogInterface) {
+                sendCancelToListener();
+            }
+        });
+
+        spinner = new ProgressDialog(getContext());
+        spinner.requestWindowFeature(Window.FEATURE_NO_TITLE);
+        spinner.setMessage(getContext().getString(R.string.com_facebook_loading));
+        spinner.setOnCancelListener(new OnCancelListener() {
+            @Override
+            public void onCancel(DialogInterface dialogInterface) {
+                sendCancelToListener();
+                WebDialog.this.dismiss();
+            }
+        });
+
+        requestWindowFeature(Window.FEATURE_NO_TITLE);
+        contentFrameLayout = new FrameLayout(getContext());
+
+        /* Create the 'x' image, but don't add to the contentFrameLayout layout yet
+         * at this point, we only need to know its drawable width and height
+         * to place the webview
+         */
+        createCrossImage();
+
+        /* Now we know 'x' drawable width and height,
+        * layout the webivew and add it the contentFrameLayout layout
+        */
+        int crossWidth = crossImageView.getDrawable().getIntrinsicWidth();
+        setUpWebView(crossWidth / 2);
+
+        /* Finally add the 'x' image to the contentFrameLayout layout and
+        * add contentFrameLayout to the Dialog view
+        */
+        contentFrameLayout.addView(crossImageView, new ViewGroup.LayoutParams(
+                ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
+        addContentView(contentFrameLayout,
+                new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
+    }
+
+    private void sendSuccessToListener(Bundle values) {
+        if (onCompleteListener != null && !listenerCalled) {
+            listenerCalled = true;
+            onCompleteListener.onComplete(values, null);
+        }
+    }
+
+    private void sendErrorToListener(Throwable error) {
+        if (onCompleteListener != null && !listenerCalled) {
+            listenerCalled = true;
+            FuntownException funtownException = null;
+            if (error instanceof FuntownException) {
+                funtownException = (FuntownException) error;
+            } else {
+                funtownException = new FuntownException(error);
+            }
+            onCompleteListener.onComplete(null, funtownException);
+        }
+    }
+
+    private void sendCancelToListener() {
+        sendErrorToListener(new FuntownOperationCanceledException());
+    }
+
+    private void createCrossImage() {
+        crossImageView = new ImageView(getContext());
+        // Dismiss the dialog when user click on the 'x'
+        crossImageView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                sendCancelToListener();
+                WebDialog.this.dismiss();
+            }
+        });
+        Drawable crossDrawable = getContext().getResources().getDrawable(R.drawable.com_facebook_close);
+        crossImageView.setImageDrawable(crossDrawable);
+        /* 'x' should not be visible while webview is loading
+         * make it visible only after webview has fully loaded
+        */
+        crossImageView.setVisibility(View.INVISIBLE);
+    }
+
+    @SuppressLint("SetJavaScriptEnabled")
+    private void setUpWebView(int margin) {
+        LinearLayout webViewContainer = new LinearLayout(getContext());
+        webView = new WebView(getContext());
+        webView.setVerticalScrollBarEnabled(false);
+        webView.setHorizontalScrollBarEnabled(false);
+        webView.setWebViewClient(new DialogWebViewClient());
+        webView.getSettings().setJavaScriptEnabled(true);
+        webView.loadUrl(url);
+        webView.setLayoutParams(new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
+                ViewGroup.LayoutParams.MATCH_PARENT));
+        webView.setVisibility(View.INVISIBLE);
+        webView.getSettings().setSavePassword(false);
+
+        webViewContainer.setPadding(margin, margin, margin, margin);
+        webViewContainer.addView(webView);
+        contentFrameLayout.addView(webViewContainer);
+    }
+
+    private class DialogWebViewClient extends WebViewClient {
+        @Override
+        @SuppressWarnings("deprecation")
+        public boolean shouldOverrideUrlLoading(WebView view, String url) {
+            Utility.logd(LOG_TAG, "Redirect URL: " + url);
+            if (url.startsWith(WebDialog.REDIRECT_URI)) {
+                Bundle values = Util.parseUrl(url);
+
+                String error = values.getString("error");
+                if (error == null) {
+                    error = values.getString("error_type");
+                }
+
+                String errorMessage = values.getString("error_msg");
+                if (errorMessage == null) {
+                    errorMessage = values.getString("error_description");
+                }
+                String errorCodeString = values.getString("error_code");
+                int errorCode = FuntownRequestError.INVALID_ERROR_CODE;
+                if (!Utility.isNullOrEmpty(errorCodeString)) {
+                    try {
+                        errorCode = Integer.parseInt(errorCodeString);
+                    } catch (NumberFormatException ex) {
+                        errorCode = FuntownRequestError.INVALID_ERROR_CODE;
+                    }
+                }
+
+                if (Utility.isNullOrEmpty(error) && Utility
+                        .isNullOrEmpty(errorMessage) && errorCode == FuntownRequestError.INVALID_ERROR_CODE) {
+                    sendSuccessToListener(values);
+                } else if (error != null && (error.equals("access_denied") ||
+                        error.equals("OAuthAccessDeniedException"))) {
+                    sendCancelToListener();
+                } else {
+                	FuntownRequestError requestError = new FuntownRequestError(errorCode, error, errorMessage);
+                    sendErrorToListener(new FuntownServiceException(requestError, errorMessage));
+                }
+
+                WebDialog.this.dismiss();
+                return true;
+            } else if (url.startsWith(WebDialog.CANCEL_URI)) {
+                sendCancelToListener();
+                WebDialog.this.dismiss();
+                return true;
+            } else if (url.contains(DISPLAY_TOUCH)) {
+                return false;
+            }
+            // launch non-dialog URLs in a full browser
+            getContext().startActivity(
+                    new Intent(Intent.ACTION_VIEW, Uri.parse(url)));
+            return true;
+        }
+
+        @Override
+        public void onReceivedError(WebView view, int errorCode,
+                String description, String failingUrl) {
+            super.onReceivedError(view, errorCode, description, failingUrl);
+            sendErrorToListener(new FuntownDialogException(description, errorCode, failingUrl));
+            WebDialog.this.dismiss();
+        }
+
+        @Override
+        public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
+            if (DISABLE_SSL_CHECK_FOR_TESTING) {
+                handler.proceed();
+            } else {
+                super.onReceivedSslError(view, handler, error);
+
+                sendErrorToListener(new FuntownDialogException(null, ERROR_FAILED_SSL_HANDSHAKE, null));
+                handler.cancel();
+                WebDialog.this.dismiss();
+            }
+        }
+
+        @Override
+        public void onPageStarted(WebView view, String url, Bitmap favicon) {
+            Utility.logd(LOG_TAG, "Webview loading URL: " + url);
+            super.onPageStarted(view, url, favicon);
+            if (!isDetached) {
+                spinner.show();
+            }
+        }
+
+        @Override
+        public void onPageFinished(WebView view, String url) {
+            super.onPageFinished(view, url);
+            if (!isDetached) {
+                spinner.dismiss();
+            }
+            /*
+             * Once web view is fully loaded, set the contentFrameLayout background to be transparent
+             * and make visible the 'x' image.
+             */
+            contentFrameLayout.setBackgroundColor(Color.TRANSPARENT);
+            webView.setVisibility(View.VISIBLE);
+            crossImageView.setVisibility(View.VISIBLE);
+        }
+    }
+
+    private static class BuilderBase<CONCRETE extends BuilderBase<?>> {
+        private Context context;
+        private Session session;
+        private String applicationId;
+        private String action;
+        private int theme = DEFAULT_THEME;
+        private OnCompleteListener listener;
+        private Bundle parameters;
+
+        protected BuilderBase(Context context, Session session, String action, Bundle parameters) {
+            Validate.notNull(session, "session");
+            if (!session.isOpened()) {
+                throw new FuntownException("Attempted to use a Session that was not open.");
+            }
+            this.session = session;
+
+            finishInit(context, action, parameters);
+        }
+
+        protected BuilderBase(Context context, String applicationId, String action, Bundle parameters) {
+            Validate.notNullOrEmpty(applicationId, "applicationId");
+            this.applicationId = applicationId;
+
+            finishInit(context, action, parameters);
+        }
+
+        /**
+         * Sets a theme identifier which will be passed to the underlying Dialog.
+         *
+         * @param theme a theme identifier which will be passed to the Dialog class
+         * @return the builder
+         */
+        public CONCRETE setTheme(int theme) {
+            this.theme = theme;
+            @SuppressWarnings("unchecked")
+            CONCRETE result = (CONCRETE) this;
+            return result;
+        }
+
+        /**
+         * Sets the listener which will be notified when the dialog finishes.
+         *
+         * @param listener the listener to notify, or null if no notification is desired
+         * @return the builder
+         */
+        public CONCRETE setOnCompleteListener(OnCompleteListener listener) {
+            this.listener = listener;
+            @SuppressWarnings("unchecked")
+            CONCRETE result = (CONCRETE) this;
+            return result;
+        }
+
+        /**
+         * Constructs a WebDialog using the parameters provided. The dialog is not shown,
+         * but is ready to be shown by calling Dialog.show().
+         *
+         * @return the WebDialog
+         */
+        public WebDialog build() {
+            if (session != null && session.isOpened()) {
+                parameters.putString(ServerProtocol.DIALOG_PARAM_APP_ID, session.getApplicationId());
+                parameters.putString(ServerProtocol.DIALOG_PARAM_ACCESS_TOKEN, session.getAccessToken());
+            } else {
+                parameters.putString(ServerProtocol.DIALOG_PARAM_APP_ID, applicationId);
+            }
+
+            //if (!parameters.containsKey(ServerProtocol.DIALOG_PARAM_REDIRECT_URI)) {
+            //    parameters.putString(ServerProtocol.DIALOG_PARAM_REDIRECT_URI, REDIRECT_URI);
+            //}
+
+            return new WebDialog(context, action, parameters, theme, listener);
+        }
+
+        protected String getApplicationId() {
+            return applicationId;
+        }
+
+        protected Context getContext() {
+            return context;
+        }
+
+        protected int getTheme() {
+            return theme;
+        }
+
+        protected Bundle getParameters() {
+            return parameters;
+        }
+
+        protected WebDialog.OnCompleteListener getListener() {
+            return listener;
+        }
+
+        private void finishInit(Context context, String action, Bundle parameters) {
+            this.context = context;
+            this.action = action;
+            if (parameters != null) {
+                this.parameters = parameters;
+            } else {
+                this.parameters = new Bundle();
+            }
+        }
+    }
+
+    /**
+     * Provides a builder that allows construction of an arbitary Facebook web dialog.
+     */
+    public static class Builder extends BuilderBase<Builder> {
+        /**
+         * Constructor that builds a dialog for an authenticated user.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param session the Session representing an authenticating user to use for
+         *                showing the dialog; must not be null, and must be opened.
+         * @param action the portion of the dialog URL following www.facebook.com/dialog/.
+         *               See https://developers.facebook.com/docs/reference/dialogs/ for details.
+         * @param parameters a Bundle containing parameters to pass as part of the URL.
+         */
+        public Builder(Context context, Session session, String action, Bundle parameters) {
+            super(context, session, action, parameters);
+        }
+
+        /**
+         * Constructor that builds a dialog without an authenticated user.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param applicationId the application ID to be included in the dialog URL.
+         * @param action the portion of the dialog URL following www.facebook.com/dialog/.
+         *               See https://developers.facebook.com/docs/reference/dialogs/ for details.
+         * @param parameters a Bundle containing parameters to pass as part of the URL.
+         */
+        public Builder(Context context, String applicationId, String action, Bundle parameters) {
+            super(context, applicationId, action, parameters);
+        }
+    }
+
+    /**
+     * Provides a builder that allows construction of the parameters for showing
+     * the Feed Dialog (https://developers.facebook.com/docs/reference/dialogs/feed/).
+     */
+    public static class FeedDialogBuilder extends BuilderBase<FeedDialogBuilder> {
+        private static final String FEED_DIALOG = "feed";
+        private static final String FROM_PARAM = "from";
+        private static final String TO_PARAM = "to";
+        private static final String LINK_PARAM = "link";
+        private static final String PICTURE_PARAM = "picture";
+        private static final String SOURCE_PARAM = "source";
+        private static final String NAME_PARAM = "name";
+        private static final String CAPTION_PARAM = "caption";
+        private static final String DESCRIPTION_PARAM = "description";
+
+        /**
+         * Constructor.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param session the Session representing an authenticating user to use for
+         *                showing the dialog; must not be null, and must be opened.
+         */
+        public FeedDialogBuilder(Context context, Session session) {
+            super(context, session, FEED_DIALOG, null);
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param context    the Context within which the dialog will be shown.
+         * @param parameters a Bundle containing parameters to pass as part of the
+         *                   dialog URL. No validation is done on these parameters; it is
+         *                   the caller's responsibility to ensure they are valid.
+         * @param session    the Session representing an authenticating user to use for
+         *                   showing the dialog; must not be null, and must be opened.
+         */
+        public FeedDialogBuilder(Context context, Session session, Bundle parameters) {
+            super(context, session, FEED_DIALOG, parameters);
+        }
+
+        /**
+         * Sets the ID of the profile that is posting to Facebook. If none is specified,
+         * the default is "me". This profile must be either the authenticated user or a
+         * Page that the user is an administrator of.
+         *
+         * @param id Facebook ID of the profile to post from
+         * @return the builder
+         */
+        public FeedDialogBuilder setFrom(String id) {
+            getParameters().putString(FROM_PARAM, id);
+            return this;
+        }
+
+        /**
+         * Sets the ID of the profile that the story will be published to. If not specified, it
+         * will default to the same profile that the story is being published from.
+         *
+         * @param id Facebook ID of the profile to post to
+         * @return the builder
+         */
+        public FeedDialogBuilder setTo(String id) {
+            getParameters().putString(TO_PARAM, id);
+            return this;
+        }
+
+        /**
+         * Sets the URL of a link to be shared.
+         *
+         * @param link the URL
+         * @return the builder
+         */
+        public FeedDialogBuilder setLink(String link) {
+            getParameters().putString(LINK_PARAM, link);
+            return this;
+        }
+
+        /**
+         * Sets the URL of a picture to be shared.
+         *
+         * @param picture the URL of the picture
+         * @return the builder
+         */
+        public FeedDialogBuilder setPicture(String picture) {
+            getParameters().putString(PICTURE_PARAM, picture);
+            return this;
+        }
+
+        /**
+         * Sets the URL of a media file attached to this post. If this is set, any picture
+         * set via setPicture will be ignored.
+         *
+         * @param source the URL of the media file
+         * @return the builder
+         */
+        public FeedDialogBuilder setSource(String source) {
+            getParameters().putString(SOURCE_PARAM, source);
+            return this;
+        }
+
+        /**
+         * Sets the name of the item being shared.
+         *
+         * @param name the name
+         * @return the builder
+         */
+        public FeedDialogBuilder setName(String name) {
+            getParameters().putString(NAME_PARAM, name);
+            return this;
+        }
+
+        /**
+         * Sets the caption to be displayed.
+         *
+         * @param caption the caption
+         * @return the builder
+         */
+        public FeedDialogBuilder setCaption(String caption) {
+            getParameters().putString(CAPTION_PARAM, caption);
+            return this;
+        }
+
+        /**
+         * Sets the description to be displayed.
+         *
+         * @param description the description
+         * @return the builder
+         */
+        public FeedDialogBuilder setDescription(String description) {
+            getParameters().putString(DESCRIPTION_PARAM, description);
+            return this;
+        }
+    }
+
+    /**
+     * Provides a builder that allows construction of the parameters for showing
+     * the Feed Dialog (https://developers.facebook.com/docs/reference/dialogs/feed/).
+     */
+    public static class RequestsDialogBuilder extends BuilderBase<RequestsDialogBuilder> {
+        private static final String APPREQUESTS_DIALOG = "apprequests";
+        private static final String MESSAGE_PARAM = "message";
+        private static final String TO_PARAM = "to";
+        private static final String DATA_PARAM = "data";
+        private static final String TITLE_PARAM = "title";
+
+        /**
+         * Constructor.
+         *
+         * @param context the Context within which the dialog will be shown.
+         * @param session the Session representing an authenticating user to use for
+         *                showing the dialog; must not be null, and must be opened.
+         */
+        public RequestsDialogBuilder(Context context, Session session) {
+            super(context, session, APPREQUESTS_DIALOG, null);
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param context    the Context within which the dialog will be shown.
+         * @param parameters a Bundle containing parameters to pass as part of the
+         *                   dialog URL. No validation is done on these parameters; it is
+         *                   the caller's responsibility to ensure they are valid.
+         * @param session    the Session representing an authenticating user to use for
+         *                   showing the dialog; must not be null, and must be opened.
+         */
+        public RequestsDialogBuilder(Context context, Session session, Bundle parameters) {
+            super(context, session, APPREQUESTS_DIALOG, parameters);
+        }
+
+        /**
+         * Sets the string users receiving the request will see. The maximum length
+         * is 60 characters.
+         *
+         * @param message the message
+         * @return the builder
+         */
+        public RequestsDialogBuilder setMessage(String message) {
+            getParameters().putString(MESSAGE_PARAM, message);
+            return this;
+        }
+
+        /**
+         * Sets the user ID or user name the request will be sent to. If this is not
+         * specified, a friend selector will be displayed and the user can select up
+         * to 50 friends.
+         *
+         * @param id the id or user name to send the request to
+         * @return the builder
+         */
+        public RequestsDialogBuilder setTo(String id) {
+            getParameters().putString(TO_PARAM, id);
+            return this;
+        }
+
+        /**
+         * Sets optional data which can be used for tracking; maximum length is 255
+         * characters.
+         *
+         * @param data the data
+         * @return the builder
+         */
+        public RequestsDialogBuilder setData(String data) {
+            getParameters().putString(DATA_PARAM, data);
+            return this;
+        }
+
+        /**
+         * Sets an optional title for the dialog; maximum length is 50 characters.
+         *
+         * @param title the title
+         * @return the builder
+         */
+        public RequestsDialogBuilder setTitle(String title) {
+            getParameters().putString(TITLE_PARAM, title);
+            return this;
+        }
+    }
+}
