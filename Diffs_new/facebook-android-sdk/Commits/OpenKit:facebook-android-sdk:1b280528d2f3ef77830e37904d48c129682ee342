diff --git a/facebook/src/com/facebook/internal/package-info.java b/facebook/src/com/facebook/internal/package-info.java
deleted file mode 100644
index b3d145ce4..000000000
--- a/facebook/src/com/facebook/internal/package-info.java
+++ /dev/null
@@ -1,6 +0,0 @@
-/**
- * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
- * any of the classes in this package is unsupported, and they may be modified or removed without warning at
- * any time.
- */
-package com.facebook.internal;
diff --git a/facebook/src/com/facebook/InsightsLogger.java b/facebook/src/io/openkit/facebook/InsightsLogger.java
similarity index 98%
rename from facebook/src/com/facebook/InsightsLogger.java
rename to facebook/src/io/openkit/facebook/InsightsLogger.java
index 4634f4ed0..f07dbb98d 100644
--- a/facebook/src/com/facebook/InsightsLogger.java
+++ b/facebook/src/io/openkit/facebook/InsightsLogger.java
@@ -14,14 +14,14 @@
  * limitations under the License.
  */
 
-package com.facebook;
+package io.openkit.facebook;
 
 import android.content.Context;
 import android.os.Bundle;
-import com.facebook.internal.Logger;
-import com.facebook.internal.Utility;
-import com.facebook.internal.Validate;
-import com.facebook.model.GraphObject;
+import io.openkit.facebook.internal.Logger;
+import io.openkit.facebook.internal.Utility;
+import io.openkit.facebook.internal.Validate;
+import io.openkit.facebook.model.GraphObject;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
diff --git a/facebook/src/io/openkit/facebook/Settings.java b/facebook/src/io/openkit/facebook/Settings.java
index efc1dded0..1695856eb 100644
--- a/facebook/src/io/openkit/facebook/Settings.java
+++ b/facebook/src/io/openkit/facebook/Settings.java
@@ -24,10 +24,10 @@
 import android.os.AsyncTask;
 import android.os.Handler;
 import android.os.Looper;
-import com.facebook.android.BuildConfig;
-import com.facebook.internal.Utility;
-import com.facebook.model.GraphObject;
-import com.facebook.internal.Validate;
+import io.openkit.facebook.android.BuildConfig;
+import io.openkit.facebook.internal.Utility;
+import io.openkit.facebook.model.GraphObject;
+import io.openkit.facebook.internal.Validate;
 import org.json.JSONException;
 import org.json.JSONObject;
 
diff --git a/facebook/src/io/openkit/facebook/Settings.java.orig b/facebook/src/io/openkit/facebook/Settings.java.orig
new file mode 100644
index 000000000..9e6490903
--- /dev/null
+++ b/facebook/src/io/openkit/facebook/Settings.java.orig
@@ -0,0 +1,398 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.openkit.facebook;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.AsyncTask;
+<<<<<<< HEAD
+import android.os.Bundle;
+import io.openkit.facebook.android.BuildConfig;
+import io.openkit.facebook.internal.Utility;
+import io.openkit.facebook.model.GraphObject;
+import io.openkit.facebook.internal.Validate;
+=======
+import android.os.Handler;
+import android.os.Looper;
+import com.facebook.android.BuildConfig;
+import com.facebook.internal.Utility;
+import com.facebook.model.GraphObject;
+import com.facebook.internal.Validate;
+>>>>>>> upstream/master
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Allows some customization of sdk behavior.
+ */
+public final class Settings {
+    private static final HashSet<LoggingBehavior> loggingBehaviors =
+            new HashSet<LoggingBehavior>(Arrays.asList(LoggingBehavior.DEVELOPER_ERRORS));
+    private static volatile Executor executor;
+    private static volatile boolean shouldAutoPublishInstall;
+
+    private static final int DEFAULT_CORE_POOL_SIZE = 5;
+    private static final int DEFAULT_MAXIMUM_POOL_SIZE = 128;
+    private static final int DEFAULT_KEEP_ALIVE = 1;
+    private static final Object LOCK = new Object();
+
+    private static final Uri ATTRIBUTION_ID_CONTENT_URI =
+            Uri.parse("content://io.openkit.facebook.katana.provider.AttributionIdProvider");
+    private static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
+
+    private static final String ATTRIBUTION_PREFERENCES = "io.openkit.facebook.sdk.attributionTracking";
+    private static final String PUBLISH_ACTIVITY_PATH = "%s/activities";
+    private static final String MOBILE_INSTALL_EVENT = "MOBILE_APP_INSTALL";
+    private static final String ANALYTICS_EVENT = "event";
+    private static final String ATTRIBUTION_KEY = "attribution";
+
+    private static final BlockingQueue<Runnable> DEFAULT_WORK_QUEUE = new LinkedBlockingQueue<Runnable>(10);
+
+    private static final ThreadFactory DEFAULT_THREAD_FACTORY = new ThreadFactory() {
+        private final AtomicInteger counter = new AtomicInteger(0);
+
+        public Thread newThread(Runnable runnable) {
+            return new Thread(runnable, "FacebookSdk #" + counter.incrementAndGet());
+        }
+    };
+
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Returns the types of extended logging that are currently enabled.
+     *
+     * @return a set containing enabled logging behaviors
+     */
+    public static final Set<LoggingBehavior> getLoggingBehaviors() {
+        synchronized (loggingBehaviors) {
+            return Collections.unmodifiableSet(new HashSet<LoggingBehavior>(loggingBehaviors));
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Enables a particular extended logging in the sdk.
+     *
+     * @param behavior
+     *          The LoggingBehavior to enable
+     */
+    public static final void addLoggingBehavior(LoggingBehavior behavior) {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.add(behavior);
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Disables a particular extended logging behavior in the sdk.
+     *
+     * @param behavior
+     *          The LoggingBehavior to disable
+     */
+    public static final void removeLoggingBehavior(LoggingBehavior behavior) {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.remove(behavior);
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Disables all extended logging behaviors.
+     */
+    public static final void clearLoggingBehaviors() {
+        synchronized (loggingBehaviors) {
+            loggingBehaviors.clear();
+        }
+    }
+
+    /**
+     * Certain logging behaviors are available for debugging beyond those that should be
+     * enabled in production.
+     *
+     * Checks if a particular extended logging behavior is enabled.
+     *
+     * @param behavior
+     *          The LoggingBehavior to check
+     * @return whether behavior is enabled
+     */
+    public static final boolean isLoggingBehaviorEnabled(LoggingBehavior behavior) {
+        synchronized (loggingBehaviors) {
+            return BuildConfig.DEBUG && loggingBehaviors.contains(behavior);
+        }
+    }
+
+    /**
+     * Returns the Executor used by the SDK for non-AsyncTask background work.
+     *
+     * By default this uses AsyncTask Executor via reflection if the API level is high enough.
+     * Otherwise this creates a new Executor with defaults similar to those used in AsyncTask.
+     *
+     * @return an Executor used by the SDK.  This will never be null.
+     */
+    public static Executor getExecutor() {
+        synchronized (LOCK) {
+            if (Settings.executor == null) {
+                Executor executor = getAsyncTaskExecutor();
+                if (executor == null) {
+                    executor = new ThreadPoolExecutor(DEFAULT_CORE_POOL_SIZE, DEFAULT_MAXIMUM_POOL_SIZE,
+                            DEFAULT_KEEP_ALIVE, TimeUnit.SECONDS, DEFAULT_WORK_QUEUE, DEFAULT_THREAD_FACTORY);
+                }
+                Settings.executor = executor;
+            }
+        }
+        return Settings.executor;
+    }
+
+    /**
+     * Sets the Executor used by the SDK for non-AsyncTask background work.
+     *
+     * @param executor
+     *          the Executor to use; must not be null.
+     */
+    public static void setExecutor(Executor executor) {
+        Validate.notNull(executor, "executor");
+        synchronized (LOCK) {
+            Settings.executor = executor;
+        }
+    }
+
+    private static Executor getAsyncTaskExecutor() {
+        Field executorField = null;
+        try {
+            executorField = AsyncTask.class.getField("THREAD_POOL_EXECUTOR");
+        } catch (NoSuchFieldException e) {
+            return null;
+        }
+
+        if (executorField == null) {
+            return null;
+        }
+
+        Object executorObject = null;
+        try {
+            executorObject = executorField.get(null);
+        } catch (IllegalAccessException e) {
+            return null;
+        }
+
+        if (executorObject == null) {
+            return null;
+        }
+
+        if (!(executorObject instanceof Executor)) {
+            return null;
+        }
+
+        return (Executor) executorObject;
+    }
+
+    /**
+     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
+     * multiple installs being published to the graph.
+     * @param context the current Context
+     * @param applicationId the fb application being published.
+     */
+    public static void publishInstallAsync(final Context context, final String applicationId) {
+       publishInstallAsync(context, applicationId, null);
+    }
+
+    /**
+     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
+     * multiple installs being published to the graph.
+     * @param context the current Context
+     * @param applicationId the fb application being published.
+     * @param callback a callback to invoke with a Response object, carrying the server response, or an error.
+     */
+    public static void publishInstallAsync(final Context context, final String applicationId,
+        final Request.Callback callback) {
+        // grab the application context ahead of time, since we will return to the caller immediately.
+        final Context applicationContext = context.getApplicationContext();
+        Settings.getExecutor().execute(new Runnable() {
+            @Override
+            public void run() {
+                final Response response = Settings.publishInstallAndWaitForResponse(applicationContext, applicationId);
+                if (callback != null) {
+                    // invoke the callback on the main thread.
+                    Handler handler = new Handler(Looper.getMainLooper());
+                    handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onCompleted(response);
+                        }
+                    });
+                }
+            }
+        });
+    }
+
+    /**
+     * Sets whether opening a Session should automatically publish install attribution to the Facebook graph.
+     *
+     * @param shouldAutoPublishInstall true to automatically publish, false to not
+     */
+    public static void setShouldAutoPublishInstall(boolean shouldAutoPublishInstall) {
+        Settings.shouldAutoPublishInstall = shouldAutoPublishInstall;
+    }
+
+    /**
+     * Gets whether opening a Session should automatically publish install attribution to the Facebook graph.
+     *
+     * @return true to automatically publish, false to not
+     */
+    public static boolean getShouldAutoPublishInstall() {
+        return shouldAutoPublishInstall;
+    }
+
+    /**
+     * Manually publish install attribution to the Facebook graph.  Internally handles tracking repeat calls to prevent
+     * multiple installs being published to the graph.
+     * @param context the current Context
+     * @param applicationId the fb application being published.
+     * @return returns false on error.  Applications should retry until true is returned.  Safe to call again after
+     * true is returned.
+     */
+    public static boolean publishInstallAndWait(final Context context, final String applicationId) {
+        Response response = publishInstallAndWaitForResponse(context, applicationId);
+        return response != null && response.getError() == null;
+    }
+
+    /**
+     * Manually publish install attribution to the Facebook graph.  Internally handles caching repeat calls to prevent
+     * multiple installs being published to the graph.
+     * @param context the current Context
+     * @param applicationId the fb application being published.
+     * @return returns a Response object, carrying the server response, or an error.
+     */
+    public static Response publishInstallAndWaitForResponse(final Context context, final String applicationId) {
+        try {
+            if (context == null || applicationId == null) {
+                throw new IllegalArgumentException("Both context and applicationId must be non-null");
+            }
+            String attributionId = Settings.getAttributionId(context.getContentResolver());
+            SharedPreferences preferences = context.getSharedPreferences(ATTRIBUTION_PREFERENCES, Context.MODE_PRIVATE);
+            String pingKey = applicationId+"ping";
+            String jsonKey = applicationId+"json";
+            long lastPing = preferences.getLong(pingKey, 0);
+            String lastResponseJSON = preferences.getString(jsonKey, null);
+
+            GraphObject publishParams = GraphObject.Factory.create();
+            publishParams.setProperty(ANALYTICS_EVENT, MOBILE_INSTALL_EVENT);
+            publishParams.setProperty(ATTRIBUTION_KEY, attributionId);
+
+            String publishUrl = String.format(PUBLISH_ACTIVITY_PATH, applicationId);
+            Request publishRequest = Request.newPostRequest(null, publishUrl, publishParams, null);
+
+            if (lastPing != 0) {
+                GraphObject graphObject = null;
+                try {
+                    if (lastResponseJSON != null) {
+                        graphObject = GraphObject.Factory.create(new JSONObject(lastResponseJSON));
+                    }
+                }
+                catch (JSONException je) {
+                    // return the default graph object if there is any problem reading the data.
+                }
+                if (graphObject == null) {
+                    return Response.createResponsesFromString("true", null, new RequestBatch(publishRequest), true).get(0);
+                } else {
+                    return new Response(null, null, graphObject, true);
+                }
+            } else if (attributionId == null) {
+                throw new FacebookException("No attribution id returned from the Facebook application");
+            } else {
+
+                if (!Utility.queryAppAttributionSupportAndWait(applicationId)) {
+                    throw new FacebookException("Install attribution has been disabled on the server.");
+                }
+
+                Response publishResponse = publishRequest.executeAndWait();
+
+                // denote success since no error threw from the post.
+                SharedPreferences.Editor editor = preferences.edit();
+                lastPing = System.currentTimeMillis();
+                editor.putLong(pingKey, lastPing);
+
+                // if we got an object response back, cache the string of the JSON.
+                if (publishResponse.getGraphObject() != null &&
+                    publishResponse.getGraphObject().getInnerJSONObject() != null) {
+                    editor.putString(jsonKey, publishResponse.getGraphObject().getInnerJSONObject().toString());
+                }
+                editor.commit();
+
+                return publishResponse;
+            }
+        } catch (Exception e) {
+            // if there was an error, fall through to the failure case.
+            Utility.logd("Facebook-publish", e);
+            return new Response(null, null, new FacebookRequestError(null, e));
+        }
+    }
+
+    /**
+     * Acquire the current attribution id from the facebook app.
+     * @return returns null if the facebook app is not present on the phone.
+     */
+    public static String getAttributionId(ContentResolver contentResolver) {
+        String [] projection = {ATTRIBUTION_ID_COLUMN_NAME};
+        Cursor c = contentResolver.query(ATTRIBUTION_ID_CONTENT_URI, projection, null, null, null);
+        if (c == null || !c.moveToFirst()) {
+            return null;
+        }
+        String attributionId = c.getString(c.getColumnIndex(ATTRIBUTION_ID_COLUMN_NAME));
+        c.close();
+        return attributionId;
+    }
+
+    /**
+     * Gets the current version of the Facebook SDK for Android as a string.
+     *
+     * @return the current version of the SDK
+     */
+    public static String getSdkVersion() {
+        return FacebookSdkVersion.BUILD;
+    }
+
+    /**
+     * Gets the current Facebook migration bundle string; this string can be passed to Graph API
+     * endpoints to specify a set of platform migrations that are explicitly turned on or off for
+     * that call, in order to ensure compatibility between a given version of the SDK and the
+     * Graph API.
+     * @return the migration bundle supported by this version of the SDK
+     */
+    public static String getMigrationBundle() {
+        return FacebookSdkVersion.MIGRATION_BUNDLE;
+    }
+}
diff --git a/facebook/src/io/openkit/facebook/internal/Utility.java b/facebook/src/io/openkit/facebook/internal/Utility.java
index 1d4e0b651..5fef560a2 100644
--- a/facebook/src/io/openkit/facebook/internal/Utility.java
+++ b/facebook/src/io/openkit/facebook/internal/Utility.java
@@ -26,9 +26,9 @@
 import android.util.Log;
 import android.webkit.CookieManager;
 import android.webkit.CookieSyncManager;
-import com.facebook.*;
-import com.facebook.android.BuildConfig;
-import com.facebook.model.GraphObject;
+import io.openkit.facebook.*;
+import io.openkit.facebook.android.BuildConfig;
+import io.openkit.facebook.model.GraphObject;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
diff --git a/facebook/src/io/openkit/facebook/internal/Utility.java.orig b/facebook/src/io/openkit/facebook/internal/Utility.java.orig
new file mode 100644
index 000000000..ed13988fc
--- /dev/null
+++ b/facebook/src/io/openkit/facebook/internal/Utility.java.orig
@@ -0,0 +1,341 @@
+/**
+ * Copyright 2010-present Facebook.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.openkit.facebook.internal;
+
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Parcelable;
+import android.text.TextUtils;
+import android.util.Log;
+import android.webkit.CookieManager;
+import android.webkit.CookieSyncManager;
+<<<<<<< HEAD
+import io.openkit.facebook.FacebookException;
+import io.openkit.facebook.Session;
+import io.openkit.facebook.android.BuildConfig;
+=======
+import com.facebook.*;
+import com.facebook.android.BuildConfig;
+import com.facebook.model.GraphObject;
+>>>>>>> upstream/master
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.json.JSONTokener;
+
+import java.io.*;
+import java.net.HttpURLConnection;
+import java.net.URLConnection;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.*;
+
+/**
+ * io.openkit.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * any of the classes in this package is unsupported, and they may be modified or removed without warning at
+ * any time.
+ */
+public final class Utility {
+    static final String LOG_TAG = "FacebookSDK";
+    private static final String HASH_ALGORITHM_MD5 = "MD5";
+    private static final String URL_SCHEME = "https";
+    private static final String SUPPORTS_ATTRIBUTION = "supports_attribution";
+    private static final String APPLICATION_FIELDS = "fields";
+
+    // This is the default used by the buffer streams, but they trace a warning if you do not specify.
+    public static final int DEFAULT_STREAM_BUFFER_SIZE = 8192;
+
+    private static final Object LOCK = new Object();
+    private static volatile boolean attributionAllowedForLastAppChecked = false;
+    private static volatile String lastAppCheckedForAttributionStatus = "";
+
+    // Returns true iff all items in subset are in superset, treating null and
+    // empty collections as
+    // the same.
+    public static <T> boolean isSubset(Collection<T> subset, Collection<T> superset) {
+        if ((superset == null) || (superset.size() == 0)) {
+            return ((subset == null) || (subset.size() == 0));
+        }
+
+        HashSet<T> hash = new HashSet<T>(superset);
+        for (T t : subset) {
+            if (!hash.contains(t)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public static <T> boolean isNullOrEmpty(Collection<T> c) {
+        return (c == null) || (c.size() == 0);
+    }
+
+    public static boolean isNullOrEmpty(String s) {
+        return (s == null) || (s.length() == 0);
+    }
+
+    public static <T> Collection<T> unmodifiableCollection(T... ts) {
+        return Collections.unmodifiableCollection(Arrays.asList(ts));
+    }
+
+    public static <T> ArrayList<T> arrayList(T... ts) {
+        ArrayList<T> arrayList = new ArrayList<T>(ts.length);
+        for (T t : ts) {
+            arrayList.add(t);
+        }
+        return arrayList;
+    }
+
+    static String md5hash(String key) {
+        MessageDigest hash = null;
+        try {
+            hash = MessageDigest.getInstance(HASH_ALGORITHM_MD5);
+        } catch (NoSuchAlgorithmException e) {
+            return null;
+        }
+
+        hash.update(key.getBytes());
+        byte[] digest = hash.digest();
+        StringBuilder builder = new StringBuilder();
+        for (int b : digest) {
+            builder.append(Integer.toHexString((b >> 4) & 0xf));
+            builder.append(Integer.toHexString((b >> 0) & 0xf));
+        }
+        return builder.toString();
+    }
+
+    public static Uri buildUri(String authority, String path, Bundle parameters) {
+        Uri.Builder builder = new Uri.Builder();
+        builder.scheme(URL_SCHEME);
+        builder.authority(authority);
+        builder.path(path);
+        for (String key : parameters.keySet()) {
+            Object parameter = parameters.get(key);
+            if (parameter instanceof String) {
+                builder.appendQueryParameter(key, (String) parameter);
+            }
+        }
+        return builder.build();
+    }
+
+    public static void putObjectInBundle(Bundle bundle, String key, Object value) {
+        if (value instanceof String) {
+            bundle.putString(key, (String) value);
+        } else if (value instanceof Parcelable) {
+            bundle.putParcelable(key, (Parcelable) value);
+        } else if (value instanceof byte[]) {
+            bundle.putByteArray(key, (byte[]) value);
+        } else {
+            throw new FacebookException("attempted to add unsupported type to Bundle");
+        }
+    }
+
+    public static void closeQuietly(Closeable closeable) {
+        try {
+            if (closeable != null) {
+                closeable.close();
+            }
+        } catch (IOException ioe) {
+            // ignore
+        }
+    }
+
+    public static void disconnectQuietly(URLConnection connection) {
+        if (connection instanceof HttpURLConnection) {
+            ((HttpURLConnection)connection).disconnect();
+        }
+    }
+
+    public static String getMetadataApplicationId(Context context) {
+        try {
+            ApplicationInfo ai = context.getPackageManager().getApplicationInfo(
+                    context.getPackageName(), PackageManager.GET_META_DATA);
+            if (ai.metaData != null) {
+                return ai.metaData.getString(Session.APPLICATION_ID_PROPERTY);
+            }
+        } catch (PackageManager.NameNotFoundException e) {
+            // if we can't find it in the manifest, just return null
+        }
+
+        return null;
+    }
+
+    static Map<String, Object> convertJSONObjectToHashMap(JSONObject jsonObject) {
+        HashMap<String, Object> map = new HashMap<String, Object>();
+        JSONArray keys = jsonObject.names();
+        for (int i = 0; i < keys.length(); ++i) {
+            String key;
+            try {
+                key = keys.getString(i);
+                Object value = jsonObject.get(key);
+                if (value instanceof JSONObject) {
+                    value = convertJSONObjectToHashMap((JSONObject) value);
+                }
+                map.put(key, value);
+            } catch (JSONException e) {
+            }
+        }
+        return map;
+    }
+
+    // Returns either a JSONObject or JSONArray representation of the 'key' property of 'jsonObject'.
+    public static Object getStringPropertyAsJSON(JSONObject jsonObject, String key, String nonJSONPropertyKey)
+            throws JSONException {
+        Object value = jsonObject.opt(key);
+        if (value != null && value instanceof String) {
+            JSONTokener tokener = new JSONTokener((String) value);
+            value = tokener.nextValue();
+        }
+
+        if (value != null && !(value instanceof JSONObject || value instanceof JSONArray)) {
+            if (nonJSONPropertyKey != null) {
+                // Facebook sometimes gives us back a non-JSON value such as
+                // literal "true" or "false" as a result.
+                // If we got something like that, we present it to the caller as
+                // a GraphObject with a single
+                // property. We only do this if the caller wants that behavior.
+                jsonObject = new JSONObject();
+                jsonObject.putOpt(nonJSONPropertyKey, value);
+                return jsonObject;
+            } else {
+                throw new FacebookException("Got an unexpected non-JSON object.");
+            }
+        }
+
+        return value;
+
+    }
+
+    public static String readStreamToString(InputStream inputStream) throws IOException {
+        BufferedInputStream bufferedInputStream = null;
+        InputStreamReader reader = null;
+        try {
+            bufferedInputStream = new BufferedInputStream(inputStream);
+            reader = new InputStreamReader(bufferedInputStream);
+            StringBuilder stringBuilder = new StringBuilder();
+
+            final int bufferSize = 1024 * 2;
+            char[] buffer = new char[bufferSize];
+            int n = 0;
+            while ((n = reader.read(buffer)) != -1) {
+                stringBuilder.append(buffer, 0, n);
+            }
+
+            return stringBuilder.toString();
+        } finally {
+            closeQuietly(bufferedInputStream);
+            closeQuietly(reader);
+        }
+    }
+
+    public static boolean stringsEqualOrEmpty(String a, String b) {
+        boolean aEmpty = TextUtils.isEmpty(a);
+        boolean bEmpty = TextUtils.isEmpty(b);
+
+        if (aEmpty && bEmpty) {
+            // Both null or empty, they match.
+            return true;
+        }
+        if (!aEmpty && !bEmpty) {
+            // Both non-empty, check equality.
+            return a.equals(b);
+        }
+        // One empty, one non-empty, can't match.
+        return false;
+    }
+
+    private static void clearCookiesForDomain(Context context, String domain) {
+        // This is to work around a bug where CookieManager may fail to instantiate if CookieSyncManager
+        // has never been created.
+        CookieSyncManager syncManager = CookieSyncManager.createInstance(context);
+        syncManager.sync();
+
+        CookieManager cookieManager = CookieManager.getInstance();
+
+        String cookies = cookieManager.getCookie(domain);
+        if (cookies == null) {
+            return;
+        }
+
+        String[] splitCookies = cookies.split(";");
+        for (String cookie : splitCookies) {
+            String[] cookieParts = cookie.split("=");
+            if (cookieParts.length > 0) {
+                String newCookie = cookieParts[0].trim() + "=;expires=Sat, 1 Jan 2000 00:00:01 UTC;";
+                cookieManager.setCookie(domain, newCookie);
+            }
+        }
+        cookieManager.removeExpiredCookie();
+    }
+
+    public static void clearFacebookCookies(Context context) {
+        // setCookie acts differently when trying to expire cookies between builds of Android that are using
+        // Chromium HTTP stack and those that are not. Using both of these domains to ensure it works on both.
+        clearCookiesForDomain(context, "facebook.com");
+        clearCookiesForDomain(context, ".facebook.com");
+        clearCookiesForDomain(context, "https://facebook.com");
+        clearCookiesForDomain(context, "https://.facebook.com");
+    }
+
+    public static void logd(String tag, Exception e) {
+        if (BuildConfig.DEBUG && tag != null && e != null) {
+            Log.d(tag, e.getClass().getSimpleName() + ": " + e.getMessage());
+        }
+    }
+
+    public static void logd(String tag, String msg) {
+        if (BuildConfig.DEBUG && tag != null && msg != null) {
+            Log.d(tag, msg);
+        }
+    }
+
+    public static boolean queryAppAttributionSupportAndWait(final String applicationId) {
+
+        synchronized (LOCK) {
+
+            // Cache the last app checked results.
+            if (applicationId.equals(lastAppCheckedForAttributionStatus)) {
+                return attributionAllowedForLastAppChecked;
+            }
+
+            Bundle supportsAttributionParams = new Bundle();
+            supportsAttributionParams.putString(APPLICATION_FIELDS, SUPPORTS_ATTRIBUTION);
+            Request pingRequest = Request.newGraphPathRequest(null, applicationId, null);
+            pingRequest.setParameters(supportsAttributionParams);
+
+            GraphObject supportResponse = pingRequest.executeAndWait().getGraphObject();
+
+            Object doesSupportAttribution = false;
+            if (supportResponse != null) {
+                doesSupportAttribution = supportResponse.getProperty(SUPPORTS_ATTRIBUTION);
+            }
+
+            if (!(doesSupportAttribution instanceof Boolean)) {
+                // Should never happen, but be safe in case server returns non-Boolean
+                doesSupportAttribution = false;
+            }
+
+            lastAppCheckedForAttributionStatus = applicationId;
+            attributionAllowedForLastAppChecked = ((Boolean)doesSupportAttribution == true);
+            return attributionAllowedForLastAppChecked;
+        }
+    }
+
+}
diff --git a/facebook/src/io/openkit/facebook/internal/package-info.java b/facebook/src/io/openkit/facebook/internal/package-info.java
index 3fb470dc7..aad3f06fc 100644
--- a/facebook/src/io/openkit/facebook/internal/package-info.java
+++ b/facebook/src/io/openkit/facebook/internal/package-info.java
@@ -1,6 +1,6 @@
 /**
- * io.openkit.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
+ * com.facebook.internal is solely for the use of other packages within the Facebook SDK for Android. Use of
  * any of the classes in this package is unsupported, and they may be modified or removed without warning at
  * any time.
  */
-package io.openkit.facebook.internal;
\ No newline at end of file
+package io.openkit.facebook.internal;
