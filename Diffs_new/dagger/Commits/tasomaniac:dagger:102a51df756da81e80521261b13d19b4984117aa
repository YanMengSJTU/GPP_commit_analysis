diff --git a/faq.md b/faq.md
new file mode 100755
index 000000000..56b059c2a
--- /dev/null
+++ b/faq.md
@@ -0,0 +1,81 @@
+---
+layout: default
+title: Frequently Asked Questions
+---
+
+<!-- note that due to b/28762248 this is rendering weirdly small -->
+# [`@Binds`]
+
+## Why is `@Binds` different from `@Provides`?
+
+`@Provides`, the most common construct for configuring a binding, serves three
+functions:
+
+1.  Declare which type (possibly qualified) is being provided — this is the
+    return type
+2.  Declare dependencies — these are the method parameters
+3.  Provide an implementation for exactly _how_ the instance is provided —
+     this is the method body
+
+While the first two fuctions are unique and critical to _every_ `@Provides`
+method, the third can often be tedious and repetitive. So, whenever there is a
+`@Provides` whose implementation is simple and common enough to be inferred by
+Dagger, it makes sense to just declare that as a method without a body (an
+abstract method) and have Dagger apply the behavior.
+
+But, if we were to just say that abstract `@Provides` methods should be treated
+as we do for `@Binds` methods, the specification of `@Provides` would basically
+be two specifications with a bunch of conditional logic.  For example, a
+`@Provides` method can have any number of parameters of any type, but a `@Binds`
+method can only have a single parameter whose type is assignable to the return
+type.  Separating those specifications makes it easier to reason about
+correctness because the annotation determines the constraints.
+
+<!-- This is an h2 tag instead of ## because there is no way to have a header
+     that spans multiple lines in markdown -->
+<h2>Why can't I put [`@Binds`] methods and instance [`@Provides`] methods in
+    the same module?</h2>
+
+Because `@Binds` methods are _just_ a method _declaration_, they are expressed
+as `abstract` methods — no implementation is ever created and nothing is never
+invoked. On the other hand, a `@Provides` method _does_ have an implmentation
+and _will_ be invoked.
+
+Since `@Binds` methods are never implemented, no concrete class is ever created
+that implements those methods.  However, instance `@Provides` methods _require_
+a concrete class in order to construct an instance on which the method can be
+invoked.
+
+### What do I do instead?
+
+The easiest change is to make the provides method `static`.  In addition to
+being compatible with `@Binds`, they often perform better than instance provides
+methods.
+
+If the method _must_ be an instance method (e.g. returns a value from a field),
+the easiest fix is to separate your `@Provides` methods and `@Binds` methods
+into two separate modules and include one from the other.  A simple example that
+provides an `HttpServletRequest` and binds `ServletRequest` might look like:
+
+```java
+@Module(includes = Declarations.class)
+final class HttpServletRequestModule {
+  @Module
+  interface Declarations {
+    @Binds ServletRequest bindServletRequest(HttpServletRequet httpRequest);
+  }
+
+  private final HttpServletRequet httpRequest;
+
+  HttpServletRequestModule(HttpServletRequet httpRequest) {
+    this.httpRequest = httpRequest;
+  }
+}
+```
+
+
+[`@Binds`]: http://google.github.io/dagger/api/latest/dagger/Binds.html
+[`@Provides`]: http://google.github.io/dagger/api/latest/dagger/Provides.html
+
+
+
diff --git a/multibindings.md b/multibindings.md
old mode 100644
new mode 100755
index 538b2f867..3e42c5c0c
--- a/multibindings.md
+++ b/multibindings.md
@@ -316,31 +316,26 @@ class MyProviderMapModule {
 
 ## Declaring multibindings
 
-You can declare that a multibound set or map is bound by nesting a
-[`@Multibindings`]-annotated interface within a module, with methods that return
-the sets or maps you want to declare.
+You can declare that a multibound set or map is bound by adding an abstract
+[`@Multibinds`]-annotated method to a module that returns the set or map you
+want to declare.
+
+You do not have to use [`@Multibinds`] for sets or maps that have at least one
+[`@IntoSet`], [`@ElementsIntoSet`], or [`@IntoMap`] binding, but you do have to
+declare them if they may be empty.
 
-You do not have to use [`@Multibindings`] for sets or maps that have at least
-one contribution, but you do have to declare them if they may be empty.
-    
 ```java
 @Module
-class MyModule {
-  @Multibindings
-  interface MyMultibindings {
-    Set<Foo> aSet();
-    @MyQualifier Set<Foo> aQualifiedSet();
-    Map<String, Foo> aMap();
-    @MyQualifier Map<String, Foo> aQualifiedMap();
-  }
+abstract class MyModule {
+  @Multibinds abstract Set<Foo> aSet();
+  @Multibinds @MyQualifier abstract Set<Foo> aQualifiedSet();
+  @Multibinds abstract Map<String, Foo> aMap();
+  @Multibinds @MyQualifier abstract Map<String, Foo> aQualifiedMap();
 }
 ```
 
-All methods on the interface and any supertypes (except for methods on `Object`)
-are used to declare multibindings. The names of the interface and its methods
-are ignored. A given set or map multibinding can be declared any number of times
-without error. Dagger never implements the interface or calls any of its
-methods.
+A given set or map multibinding can be declared any number of times without
+error. Dagger never implements or calls any [`@Multibinds`] methods.
 
 <!-- TODO(dpb): Render as footnote once Github supports them. -->
 
@@ -461,7 +456,7 @@ class ChildModule {
 [`@IntoMap`]: http://google.github.io/dagger/api/latest/dagger/multibindings/IntoMap.html
 [`@IntoSet`]: http://google.github.io/dagger/api/latest/dagger/multibindings/IntoSet.html
 [`@MapKey`]: http://google.github.io/dagger/api/latest/dagger/MapKey.html
-[`@Multibindings`]: http://google.github.io/dagger/api/latest/dagger/Multibindings.html
+[`@Multibinds`]: http://google.github.io/dagger/api/latest/dagger/multibindings/Multibinds.html
 
 
 
diff --git a/producers.md b/producers.md
old mode 100644
new mode 100755
index e28e95ba4..9d920f2cd
--- a/producers.md
+++ b/producers.md
@@ -189,15 +189,19 @@ final class DispatchModule {
 
   @Produces
   static ListenableFuture<Html> dispatch(
-      Map<DispatchPath, Producer<Html>> dispatchers, Url url) {
+      Map<String, Producer<Html>> dispatchers, Url url) {
     return dispatchers.get(url.path()).get();
   }
 }
 ```
 
-Note that here, `dispatch()` is requesting
-`Map<DispatchPath, Producer<Html>>`; this ensures that only the dispatch
-handler that was requested will be executed.
+Note that here, `dispatch()` is requesting map values of the type
+`Producer<Html>`; this ensures that only the dispatch handler that was
+requested will be executed.
+
+Also note that `DispatchPath` is a [simple map key]
+(multibindings.md#simple-map-keys), but that [complex map keys]
+(multibindings.md#complex-map-keys) are supported as well.
 
 ## Scoping
 
diff --git a/release.md b/release.md
old mode 100644
new mode 100755
index d12e4e73d..faa8a45a8
--- a/release.md
+++ b/release.md
@@ -117,6 +117,13 @@ mvn versions:set versions:commit -DnewVersion=2.1
 git commit
 ```
 
+Make sure to also update any not-yet-released version numbers in Javadoc to
+the the upcoming version.
+
+```shell
+sed -i s/"@since 2.NEXT"/"@since 2.<new version>"/g $(find . | grep \\\\.java)
+```
+
 This will set all versions of projects connected in <module> sections from
 the parent pom - in short, all the parts of dagger will be set to be (and
 depend on) `2.1`.
diff --git a/releases-and-versioning.md b/releases-and-versioning.md
old mode 100644
new mode 100755
index 0d3ab17e3..ed838ca1a
--- a/releases-and-versioning.md
+++ b/releases-and-versioning.md
@@ -46,6 +46,12 @@ breaking change will happen *at least* 6 months after warning documentation
 (typically via `@Deprecated`) is added, and will always include migration
 instructions.
 
+### Version "`NEXT`"
+
+For features that will be introduced in the upcoming release, use NEXT as the
+[`API`][#version-policy] version. These will be updated as part of the release
+process.
+
 ## Release schedule
 
 As of March 2016, the Dagger team is aiming to produce a versioned release every
diff --git a/testing.md b/testing.md
old mode 100644
new mode 100755
index 9a7a65f92..f9cf01eed
--- a/testing.md
+++ b/testing.md
@@ -106,6 +106,7 @@ But there are limitations to this approach:
     their module instances cannot be [elided][elide-static-module-instances].
 
 <a name="separate-component-configurations"></a>
+
 ### Option 2: Separate component configurations
 
 Another approach requires more up-front design of the modules in your
