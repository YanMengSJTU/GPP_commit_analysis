diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index f649c7a24..e8fb60eeb 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -37,7 +37,7 @@
    *
    * <p><b>Warning: Do Not use! This flag is for internal, experimental use only!</b>
    *
-   * <p> Issues related to this flag will not be supported. This flag could break your build, cause
+   * <p>Issues related to this flag will not be supported. This flag could break your build, cause
    * memory leaks in your app, or cause other unknown issues at runtime.
    *
    * <p>If enabled, the generated code will attempt to more aggressively inline creation logic for
@@ -47,7 +47,9 @@
    * classloading on Android, these trade-offs are potentially advantageous.
    */
   abstract boolean experimentalAndroidMode();
+
   abstract boolean writeProducerNameInToken();
+
   abstract Diagnostic.Kind nullableValidationKind();
 
   boolean doCheckForNulls() {
@@ -55,10 +57,15 @@ boolean doCheckForNulls() {
   }
 
   abstract Diagnostic.Kind privateMemberValidationKind();
+
   abstract Diagnostic.Kind staticMemberValidationKind();
+
   abstract boolean ignorePrivateAndStaticInjectionForComponent();
+
   abstract ValidationType scopeCycleValidationType();
+
   abstract boolean warnIfInjectionFactoryNotGeneratedUpstream();
+
   abstract boolean headerCompilation();
 
   static Builder builder() {
@@ -70,37 +77,48 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, DaggerElement
         .usesProducers(elements.getTypeElement(Produces.class) != null)
         .headerCompilation(processingEnv.getOptions().containsKey(HEADER_COMPILATION))
         .experimentalAndroidMode(
-            experimentalAndroidMode(processingEnv).equals(FeatureStatus.ENABLED))
+            experimentalAndroidModeFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
         .writeProducerNameInToken(
-            writeProducerNameInToken(processingEnv).equals(FeatureStatus.ENABLED))
+            writeProducerNameInTokenFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
         .nullableValidationKind(nullableValidationType(processingEnv).diagnosticKind().get())
         .privateMemberValidationKind(
             privateMemberValidationType(processingEnv).diagnosticKind().get())
         .staticMemberValidationKind(
             staticMemberValidationType(processingEnv).diagnosticKind().get())
         .ignorePrivateAndStaticInjectionForComponent(
-            ignorePrivateAndStaticInjectionForComponent(processingEnv)
+            ignorePrivateAndStaticInjectionForComponentFeatureStatus(processingEnv)
                 .equals(FeatureStatus.DISABLED))
         .scopeCycleValidationType(scopeValidationType(processingEnv))
         .warnIfInjectionFactoryNotGeneratedUpstream(
-            warnIfInjectionFactoryNotGeneratedUpstream(processingEnv).equals(FeatureStatus.ENABLED))
+            warnIfInjectionFactoryNotGeneratedUpstreamFeatureStatus(processingEnv)
+                .equals(FeatureStatus.ENABLED))
         .build();
   }
 
   @AutoValue.Builder
   interface Builder {
     Builder usesProducers(boolean usesProduces);
+
     Builder headerCompilation(boolean headerCompilation);
+
     Builder experimentalAndroidMode(boolean experimentalAndroidMode);
+
     Builder writeProducerNameInToken(boolean writeProducerNameInToken);
+
     Builder nullableValidationKind(Diagnostic.Kind kind);
+
     Builder privateMemberValidationKind(Diagnostic.Kind kind);
+
     Builder staticMemberValidationKind(Diagnostic.Kind kind);
+
     Builder ignorePrivateAndStaticInjectionForComponent(
         boolean ignorePrivateAndStaticInjectionForComponent);
+
     Builder scopeCycleValidationType(ValidationType type);
+
     Builder warnIfInjectionFactoryNotGeneratedUpstream(
         boolean warnIfInjectionFactoryNotGeneratedUpstream);
+
     CompilerOptions build();
   }
 
@@ -123,8 +141,8 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
       "dagger.warnIfInjectionFactoryNotGeneratedUpstream";
 
   /**
-   * If true, Dagger will generate factories and components even if some members-injected types
-   * have private or static {@code @Inject}-annotated members.
+   * If true, Dagger will generate factories and components even if some members-injected types have
+   * private or static {@code @Inject}-annotated members.
    *
    * <p>This defaults to false, and should only ever be enabled by the TCK tests. Disabling this
    * validation could lead to generating code that does not compile.
@@ -144,7 +162,8 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
           WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
           IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT);
 
-  private static FeatureStatus experimentalAndroidMode(ProcessingEnvironment processingEnv) {
+  private static FeatureStatus experimentalAndroidModeFeatureStatus(
+      ProcessingEnvironment processingEnv) {
     return valueOf(
         processingEnv,
         EXPERIMENTAL_ANDROID_MODE,
@@ -152,7 +171,8 @@ private static FeatureStatus experimentalAndroidMode(ProcessingEnvironment proce
         EnumSet.allOf(FeatureStatus.class));
   }
 
-  private static FeatureStatus writeProducerNameInToken(ProcessingEnvironment processingEnv) {
+  private static FeatureStatus writeProducerNameInTokenFeatureStatus(
+      ProcessingEnvironment processingEnv) {
     return valueOf(
         processingEnv,
         WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
@@ -192,7 +212,7 @@ private static ValidationType staticMemberValidationType(ProcessingEnvironment p
         EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
   }
 
-  private static FeatureStatus ignorePrivateAndStaticInjectionForComponent(
+  private static FeatureStatus ignorePrivateAndStaticInjectionForComponentFeatureStatus(
       ProcessingEnvironment processingEnv) {
     return valueOf(
         processingEnv,
@@ -201,7 +221,7 @@ private static FeatureStatus ignorePrivateAndStaticInjectionForComponent(
         EnumSet.allOf(FeatureStatus.class));
   }
 
-  private static FeatureStatus warnIfInjectionFactoryNotGeneratedUpstream(
+  private static FeatureStatus warnIfInjectionFactoryNotGeneratedUpstreamFeatureStatus(
       ProcessingEnvironment processingEnv) {
     return valueOf(
         processingEnv,
diff --git a/java/dagger/internal/codegen/DaggerKythePlugin.java b/java/dagger/internal/codegen/DaggerKythePlugin.java
index d479cfd03..eedd909f1 100644
--- a/java/dagger/internal/codegen/DaggerKythePlugin.java
+++ b/java/dagger/internal/codegen/DaggerKythePlugin.java
@@ -20,9 +20,9 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.collect.ImmutableSet.toImmutableSet;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.devtools.kythe.analyzers.base.EdgeKind.DEFINES_BINDING;
+import static com.google.devtools.kythe.analyzers.base.EdgeKind.PARAM;
 import static com.google.devtools.kythe.analyzers.base.EdgeKind.REF;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
@@ -36,18 +36,18 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.service.AutoService;
-import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableList;
 import com.google.devtools.kythe.analyzers.base.CorpusPath;
-import com.google.devtools.kythe.analyzers.base.EdgeKind;
 import com.google.devtools.kythe.analyzers.base.EntrySet;
 import com.google.devtools.kythe.analyzers.base.FactEmitter;
 import com.google.devtools.kythe.analyzers.base.KytheEntrySets;
+import com.google.devtools.kythe.analyzers.base.KytheEntrySets.NodeBuilder;
+import com.google.devtools.kythe.analyzers.base.NodeKind;
 import com.google.devtools.kythe.analyzers.java.Plugin;
 import com.google.devtools.kythe.proto.Storage.VName;
 import com.google.devtools.kythe.util.Span;
 import com.sun.source.tree.Tree;
 import com.sun.tools.javac.api.JavacTrees;
-import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.model.JavacElements;
 import com.sun.tools.javac.model.JavacTypes;
 import com.sun.tools.javac.tree.JCTree;
@@ -62,6 +62,7 @@
 import dagger.MembersInjector;
 import dagger.Provides;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.multibindings.Multibinds;
@@ -96,6 +97,7 @@
   @Inject BindingFactory bindingFactory;
   @Inject DelegateDeclaration.Factory delegateDeclarationFactory;
   @Inject MultibindingDeclaration.Factory multibindingDeclarationFactory;
+  @Inject OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory;
   @Inject SubcomponentDeclaration.Factory subcomponentDeclarationFactory;
   @Inject KeyFactory keyFactory;
   @Inject DaggerTypes types;
@@ -159,12 +161,8 @@ public Void visitMethodDef(JCMethodDecl tree, Void p) {
         addBindingDeclarationEdge(
             multibindingDeclarationFactory.forMultibindsMethod(element, enclosingType));
       } else if (isAnnotationPresent(element, BindsOptionalOf.class)) {
-        Key key = keyFactory.forBindsOptionalOfMethod(element, enclosingType);
-        for (Class<?> optionalClass : optionalClasses()) {
-          Key wrappedOptionalKey =
-              key.toBuilder().type(types.wrapType(key.type(), optionalClass)).build();
-          addBindingDeclarationEdge(wrappedOptionalKey, element);
-        }
+        addOptionalBindingDeclarationEdge(
+            optionalBindingDeclarationFactory.forMethod(element, enclosingType));
       } else if (isAnnotationPresent(element, BindsInstance.class)) {
         VariableElement parameter = getOnlyElement(element.getParameters());
         Key key = Key.builder(parameter.asType()).qualifier(getQualifier(parameter)).build();
@@ -179,6 +177,14 @@ private void addNodesForGraph(BindingGraph graph) {
         graph.componentDescriptor().componentMethods()) {
       componentMethod.dependencyRequest().ifPresent(this::addDependencyEdge);
     }
+
+    graph
+        .contributionBindings()
+        .values()
+        .stream()
+        .flatMap(resolvedBindings -> resolvedBindings.contributionBindings().stream())
+        .filter(binding -> binding.kind().equals(BindingKind.OPTIONAL))
+        .forEach(this::addOptionalBindingJoinsEdge);
   }
 
   private void addBindingAndDependencyEdges(Binding binding) {
@@ -191,16 +197,13 @@ private void addBindingDeclarationEdge(BindingDeclaration declaration) {
   }
 
   /**
-   * Adds a {@code defines/binding} edge between {@code bindingElement} and the node for {@code
-   * key}.
+   * Adds a {@code defines/binding} edge from {@code bindingElement} to the node for {@code key}.
    */
   private void addBindingDeclarationEdge(Key key, Element bindingElement) {
     if (hasTypeVariable(key.type())) {
       return;
     }
-    EntrySet bindingAnchor =
-        entrySets.newAnchorAndEmit(fileVName, bindingElementSpan(bindingElement), null);
-
+    EntrySet bindingAnchor = anchor(bindingElementSpan(bindingElement));
     entrySets.emitEdge(bindingAnchor, DEFINES_BINDING, keyNode(key));
   }
 
@@ -213,16 +216,15 @@ private Span bindingElementSpan(Element bindingElement) {
   }
 
   /**
-   * Adds a {@code ref} edge between {@code dependencyRequest} and it's {@link
-   * DependencyRequest#key() key's} node.
+   * Adds a {@code ref} edge from {@code dependencyRequest} to its {@link DependencyRequest#key()
+   * key's} node.
    */
   private void addDependencyEdge(DependencyRequest dependencyRequest) {
     if (!dependencyRequest.requestElement().isPresent()
         || hasTypeVariable(dependencyRequest.key().type())) {
       return;
     }
-    EntrySet dependencyRequestAnchor =
-        entrySets.newAnchorAndEmit(fileVName, dependencyRequestSpan(dependencyRequest), null);
+    EntrySet dependencyRequestAnchor = anchor(dependencyRequestSpan(dependencyRequest));
     entrySets.emitEdge(dependencyRequestAnchor, REF, keyNode(dependencyRequest.key()));
   }
 
@@ -231,57 +233,108 @@ private Span dependencyRequestSpan(DependencyRequest dependency) {
     return span(requestElement.getSimpleName(), trees.getTree(requestElement));
   }
 
+  /**
+   * Adds a {@code defines/binding} edge from {@code declaration}'s {@link
+   * OptionalBindingDeclaration#bindingElement()} to {@link #bindsOptionalOfKeyNode(Key)}. When a
+   * binding is resolved to {@code declaration}, a {@code /dagger/joins} edge will be added from the
+   * binding's key to the {@link #bindsOptionalOfKeyNode(Key)}. Kythe's post-processing will "merge"
+   * the {@code /dagger/joins} edge so that tools see edges from the {@code @BindsOptionalOf} method
+   * directly to the dependency requests that are resolved by this declaration and the bindings (if
+   * any) that satisfy it.
+   *
+   * <p>This process is used because {@code @BindsOptionalOf} methods may bind several binding keys,
+   * some of which may reference optional types (like {@link com.google.common.base.Optional}) that
+   * are not present in the current compilation, but will be when a component is resolved.
+   */
+  private void addOptionalBindingDeclarationEdge(OptionalBindingDeclaration declaration) {
+    EntrySet declarationAnchor = anchor(bindingElementSpan(declaration.bindingElement().get()));
+    entrySets.emitEdge(
+        declarationAnchor, DEFINES_BINDING, bindsOptionalOfKeyNode(declaration.key()));
+  }
+
+  /**
+   * Adds a {@code /dagger/joins} edge from {@code binding}'s key to the synthetic
+   * {@code @BindsOptionalOf} node created in {@link
+   * #addOptionalBindingDeclarationEdge(OptionalBindingDeclaration)}.
+   */
+  private void addOptionalBindingJoinsEdge(ContributionBinding binding) {
+    emitDaggerJoinsEdge(
+        keyNode(binding.key()),
+        bindsOptionalOfKeyNode(keyFactory.unwrapOptional(binding.key()).get()));
+  }
+
+  /** A synthetic node for a {@link BindsOptionalOf} method. */
+  private EntrySet bindsOptionalOfKeyNode(Key key) {
+    EntrySet node = newInjectNode("key", String.format("@BindsOptionalOf %s", formatKey(key)));
+    entrySets.emitEdge(node, PARAM, bindsOptionalOfTypeApplication(key), 0);
+    addEdgeFromKeyToQualifier(node, key);
+    return node;
+  }
+
+  private EntrySet bindsOptionalOfTypeApplication(Key optionalBindingDeclarationKey) {
+    EntrySet genericBindsOptionalOfNode = newNode(NodeKind.ABS, "abs for @BindsOptionalOf");
+    EntrySet bindsOptionalOfTypeVariable = newNode(NodeKind.ABS_VAR, "absvar for @BindsOptionalOf");
+    entrySets.emitEdge(genericBindsOptionalOfNode, PARAM, bindsOptionalOfTypeVariable, 0);
+
+    return entrySets.newTApplyAndEmit(
+        genericBindsOptionalOfNode.getVName(),
+        hasTypeVariable(optionalBindingDeclarationKey.type())
+            ? ImmutableList.of() /* // TODO(ronshapiro): should this have a /dagger/joins edge?
+             Or should it reuse bindsOptionalOfTypeVariable?*/
+            : ImmutableList.of(keys.vname(optionalBindingDeclarationKey)));
+  }
+
   private Span span(Name name, JCTree tree) {
     return kytheGraph.findIdentifier(name, tree.getPreferredPosition()).get();
   }
 
   private EntrySet keyNode(Key key) {
-    EntrySet keyNode = newNode("key", formatKey(key));
+    EntrySet keyNode = newInjectNode("key", formatKey(key));
 
-    entrySets.emitEdge(keyNode.getVName(), EdgeKind.PARAM, keys.vname(key), 0);
-    key.qualifier()
-        .ifPresent(
-            qualifier -> {
-              entrySets.emitEdge(
-                  keyNode.getVName(), EdgeKind.PARAM, qualifierNode(qualifier).getVName(), 1);
-            });
+    entrySets.emitEdge(keyNode.getVName(), PARAM, keys.vname(key), 0);
+    addEdgeFromKeyToQualifier(keyNode, key);
 
     return keyNode;
   }
 
-  private EntrySet qualifierNode(AnnotationMirror qualifier) {
-    return newNode("qualifier", formatAnnotation(qualifier));
+  private void addEdgeFromKeyToQualifier(EntrySet source, Key key) {
+    key.qualifier()
+        .map(qualifier -> newInjectNode("qualifier", formatAnnotation(qualifier)))
+        .ifPresent(qualifier -> entrySets.emitEdge(source, PARAM, qualifier, 1));
   }
 
-  private EntrySet newNode(String nodeKind, String format) {
-    EntrySet node = entrySets
-        .newNode("inject/" + nodeKind)
-        .setCorpusPath(corpusPath)
-        .setSignature(String.format("inject_%s:%s", nodeKind, format))
-        .build();
-    node.emit(emitter);
-    return node;
+  /** Adds a new node in the {@code inject/} namespace. */
+  private EntrySet newInjectNode(String nodeKind, String format) {
+    return completeNodeAndEmit(
+        entrySets
+            .newNode("inject/" + nodeKind)
+            .setSignature(String.format("inject_%s:%s", nodeKind, format)));
   }
 
-  private ImmutableSet<Class<?>> optionalClasses() {
-    // TODO(user): Can the plugin infrastructure be modified to guarantee certain types are
-    // always available to plugins via kytheGraph.getNode() even if they haven't been scanned yet?
-    return ImmutableSet.of(java.util.Optional.class, com.google.common.base.Optional.class)
-        .stream()
-        .filter(this::isClassAvailable)
-        .collect(toImmutableSet());
+  private EntrySet newNode(NodeKind nodeKind, String signature) {
+    return completeNodeAndEmit(entrySets.newNode(nodeKind).setSignature(signature));
   }
 
-  private boolean isClassAvailable(Class<?> clazz) {
-    return kytheGraph
-        .getNode((Symbol) elements.getTypeElement(clazz.getCanonicalName()))
-        .isPresent();
+  private EntrySet completeNodeAndEmit(NodeBuilder nodeBuilder) {
+    EntrySet node = nodeBuilder.setCorpusPath(corpusPath).build();
+    node.emit(emitter);
+    return node;
+  }
+
+  private EntrySet anchor(Span location) {
+    return entrySets.newAnchorAndEmit(fileVName, location, null);
   }
 
   private Element getElement(Tree tree) {
     return trees.getElement(trees.getPath(compilationUnit, tree));
   }
 
+  private void emitDaggerJoinsEdge(EntrySet source, EntrySet target) {
+    new EntrySet.Builder(source.getVName(), "/dagger/joins", target.getVName())
+        .build()
+        .emit(emitter);
+  }
+
   @Override
   public void run(
       JCCompilationUnit compilationUnit, KytheEntrySets entrySets, KytheGraph kytheGraph) {
diff --git a/java/dagger/internal/codegen/KeyVNameFactory.java b/java/dagger/internal/codegen/KeyVNameFactory.java
index e22c7a14a..9849b0a69 100644
--- a/java/dagger/internal/codegen/KeyVNameFactory.java
+++ b/java/dagger/internal/codegen/KeyVNameFactory.java
@@ -84,7 +84,11 @@ public VName visitDeclared(DeclaredType declaredType, Key key) {
       // the *type*? Also, this seems to return null for all boxed primitive types if boxed
       // primitive is not mentioned in the compilation (i.e. if you @Provides int and then request
       // int from a binding, but never java.lang.Integer) - we have to synthesize those
-      VName rawType = kytheGraph.getNode(classSymbol).get().getVName();
+      VName rawType =
+          kytheGraph
+              .getNode(classSymbol)
+              .orElseThrow(() -> new TypeNotPresentException(classSymbol.toString(), null))
+              .getVName();
       if (classSymbol.getTypeParameters().isEmpty()) {
         return rawType;
       }
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index 7521b4428..8a1f70360 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -22,6 +22,7 @@
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
@@ -98,8 +99,9 @@ Expression getDependencyExpression(ClassName requestingClass) {
         instantiation
             .add("$T.", isImmutableMapAvailable ? ImmutableMap.class : MapBuilder.class)
             .add(maybeTypeParameters(requestingClass));
-        if (isImmutableMapAvailable) {
-          // TODO(ronshapiro): builderWithExpectedSize
+        if (isImmutableMapBuilderWithExpectedSizeAvailable()) {
+          instantiation.add("builderWithExpectedSize($L)", dependencies.size());
+        } else if (isImmutableMapAvailable) {
           instantiation.add("builder()");
         } else {
           instantiation.add("newMapBuilder($L)", dependencies.size());
@@ -147,6 +149,15 @@ private CodeBlock maybeTypeParameters(ClassName requestingClass) {
         : CodeBlock.of("");
   }
 
+  private boolean isImmutableMapBuilderWithExpectedSizeAvailable() {
+    if (isImmutableMapAvailable()) {
+      return methodsIn(elements.getTypeElement(ImmutableMap.class).getEnclosedElements())
+          .stream()
+          .anyMatch(method -> method.getSimpleName().contentEquals("builderWithExpectedSize"));
+    }
+    return false;
+  }
+
   private boolean isImmutableMapAvailable() {
     return elements.getTypeElement(ImmutableMap.class) != null;
   }
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
index 860df769b..2409541c0 100644
--- a/java/dagger/internal/codegen/SetBindingExpression.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -19,6 +19,7 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
@@ -97,7 +98,9 @@ Expression getDependencyExpression(ClassName requestingClass) {
         instantiation
             .add("$T.", isImmutableSetAvailable ? ImmutableSet.class : SetBuilder.class)
             .add(maybeTypeParameter(requestingClass));
-        if (isImmutableSetAvailable) {
+        if (isImmutableSetBuilderWithExpectedSizeAvailable()) {
+          instantiation.add("builderWithExpectedSize($L)", binding.dependencies().size());
+        } else if (isImmutableSetAvailable) {
           instantiation.add("builder()");
         } else {
           instantiation.add("newSetBuilder($L)", binding.dependencies().size());
@@ -153,6 +156,15 @@ private boolean isSingleValue(DependencyRequest dependency) {
         .equals(ContributionType.SET);
   }
 
+  private boolean isImmutableSetBuilderWithExpectedSizeAvailable() {
+    if (isImmutableSetAvailable()) {
+      return methodsIn(elements.getTypeElement(ImmutableSet.class).getEnclosedElements())
+          .stream()
+          .anyMatch(method -> method.getSimpleName().contentEquals("builderWithExpectedSize"));
+    }
+    return false;
+  }
+
   private boolean isImmutableSetAvailable() {
     return elements.getTypeElement(ImmutableSet.class) != null;
   }
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
index 0d0e050fa..b17472914 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
@@ -173,7 +173,7 @@ public void mapBindings() {
                 "",
                 "    @Override",
                 "    public Map<Long, Long> longs() {",
-                "      return ImmutableMap.<Long, Long>builder()",
+                "      return ImmutableMap.<Long, Long>builderWithExpectedSize(6)",
                 "          .put(0L, MapModule.provideLong0())",
                 "          .put(1L, MapModule.provideLong1())",
                 "          .put(2L, MapModule.provideLong2())",
@@ -185,7 +185,7 @@ public void mapBindings() {
                 "",
                 "    @Override",
                 "    public Map<Long, Provider<Long>> providerLongs() {",
-                "      return ImmutableMap.<Long, Provider<Long>>builder()",
+                "      return ImmutableMap.<Long, Provider<Long>>builderWithExpectedSize(6)",
                 "          .put(0L, MapModule_ProvideLong0Factory.create())",
                 "          .put(1L, MapModule_ProvideLong1Factory.create())",
                 "          .put(2L, MapModule_ProvideLong2Factory.create())",
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index d321f48bd..32ddf8d52 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -107,7 +107,7 @@ public void setBindings() {
             "public final class DaggerTestComponent implements TestComponent {",
             "  @Override",
             "  public Set<String> strings() {",
-            "    return ImmutableSet.<String>builder()",
+            "    return ImmutableSet.<String>builderWithExpectedSize(2)",
             "        .addAll(EmptySetModule_EmptySetFactory.proxyEmptySet())",
             "        .add(SetModule_StringFactory.proxyString())",
             "        .build();",
