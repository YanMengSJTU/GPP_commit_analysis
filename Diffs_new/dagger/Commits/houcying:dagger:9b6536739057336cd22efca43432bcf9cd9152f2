diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index d03d00bf3..2daf5e64a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -292,30 +292,25 @@ public String apply(TypeElement input) {
               Joiner.on(",\n").join(setFactoryParameters.build()));
         } else if ((mapBinding = ProvisionBinding.isMapBindingCollection(bindings)) == true) {
           ImmutableList.Builder<String> mapFactoryParameters = ImmutableList.builder();
-          mapFactoryParameters.add(providerNames.get(key)); 
          
           boolean isFirstBinding = true;
           for (ProvisionBinding binding : bindings) {
             ExecutableElement e = (ExecutableElement) binding.bindingElement();
             ImmutableSet<? extends AnnotationMirror> annotationmirrors = getMapKey(e);
             Map<? extends ExecutableElement, ? extends AnnotationValue> map = annotationmirrors.iterator().next().getElementValues();
+            //get the key and value type of the map 
             if (isFirstBinding) {
-              Key s = binding.providedKey();
-              TypeVisitor<Object, Void> typeVisitor =  new SimpleTypeVisitor6<Object, Void>(){
-                @Override public List<? extends TypeMirror> visitDeclared(DeclaredType t,
-                    Void p) {
-                      return t.getTypeArguments();
-                }
-              };
-              String size = Integer.toString(bindings.size());
-              List<? extends TypeMirror> mapArgs = (List<? extends TypeMirror>) s.type().accept(typeVisitor, null);
+              DeclaredType declaredMapType = (DeclaredType) binding.providedKey().type();
+              List<? extends TypeMirror> mapArgs = declaredMapType.getTypeArguments();
               TypeMirror keyType =  mapArgs.get(0);
-              List<? extends TypeMirror> mapValueArgs = (List<? extends TypeMirror>) mapArgs.get(1).accept(typeVisitor, null);
+              DeclaredType declaredValueType = (DeclaredType) mapArgs.get(1);
+              List<? extends TypeMirror> mapValueArgs = declaredValueType.getTypeArguments();
               TypeMirror valueType = mapValueArgs.get(0);
 
+              mapFactoryParameters.add(providerNames.get(key)); 
               mapFactoryParameters.add(keyType.toString());
               mapFactoryParameters.add(valueType.toString()); 
-              mapFactoryParameters.add(size);
+              mapFactoryParameters.add(Integer.toString(bindings.size()));
 
               isFirstBinding = false;
             }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 683f593a5..3e08bbabc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -130,14 +130,16 @@ static boolean isMapBindingCollection(Iterable<ProvisionBinding> bindings) {
   /**
    * Returns {@code true} if the given bindings is not a collection.
    *
-   * @throws IllegalArgumentException if the bindings in the collection are not supported in Dagger.
+   * @throws IllegalArgumentException if the bindings in the collection are not supported in Dagger (Not setBinding or mapBinding).
    */
   static boolean isNotACollection(boolean setBinding, boolean mapBinding, Iterable<ProvisionBinding> bindings) {
+    checkNotNull(bindings);
     Iterator<ProvisionBinding> iterator = bindings.iterator();
+    checkArgument(iterator.hasNext(), "no bindings");
     ProvisionBinding temp = iterator.next();
     if (iterator.hasNext()) {
       checkArgument(mapBinding || setBinding,
-          "more than one binding present, but found a invalid binding");
+          "more than one binding present, but found an invalid binding");
     }
     return !(mapBinding || setBinding);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index dbd2fac8a..7441d2136 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -31,14 +31,18 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.SetMultimap;
+
 import com.squareup.javawriter.JavaWriter;
+
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.internal.DoubleCheckLazy;
+
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
+
 import javax.inject.Provider;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -194,11 +198,13 @@
     for (Entry<Key, Collection<ProvisionBinding>> entry : bindings.asMap().entrySet()) {
       Collection<ProvisionBinding> bindingsForKey = entry.getValue();
       final String name;
-      if (ProvisionBinding.isSetBindingCollection(bindingsForKey)) {
+      boolean setBinding;
+      boolean mapBinding;
+      if ((setBinding = ProvisionBinding.isSetBindingCollection(bindingsForKey)) == true) {
         name = new KeyVariableNamer().apply(entry.getKey()) + "Provider";
-      } else if (ProvisionBinding.isMapBindingCollection(bindingsForKey)) {
+      } else if ((mapBinding = ProvisionBinding.isMapBindingCollection(bindingsForKey)) == true) {
         name = new KeyVariableNamer().apply(entry.getKey()) + "Provider";
-      } else {
+      } else if (ProvisionBinding.isNotACollection(setBinding, mapBinding, bindingsForKey)) {
         ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
         name = binding.bindingElement().accept(
             new ElementKindVisitor6<String, Void>() {
@@ -218,6 +224,8 @@ public String visitType(TypeElement e, Void p) {
                     e.getSimpleName().toString());
               }
             }, null) + "Provider";
+      } else {
+        name = null;
       }
       providerNames.put(entry.getKey(), name);
     }
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
index a403fdfbe..431c52f36 100644
--- a/core/src/main/java/dagger/internal/MapProviderFactory.java
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -5,36 +5,51 @@
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.Set;
 
 import javax.inject.Provider;
 
 /**
- * TODO: Insert description here. (generated by houcy)
+ * A {@link Factory} implementation used to implement {@link Map} bindings. This factory always
+ * returns a new {@link Map<K, Provider<V>>} instance for each call to {@link #get} (as required by {@link Factory})
+ * whose elements are populated by subsequent calls to their {@link Provider#get} methods.
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ * 
  * @param <V>
  * @param <K>
  */
 public class MapProviderFactory<K, V> implements Factory<Map<K, Provider<V>>> {
   private final LinkedHashMap<K, Provider<V>> contributingMap;
 
-
+  /**
+   * A builder to help build the {@link MapProviderFactory}
+   */
   public static class Builder<K, V> {
-    private final int size;
     private final LinkedHashMap<K, Provider<V>> mapBuilder;
-
+    
     public Builder(int size) {
-      this.size = size;
       this.mapBuilder = new LinkedHashMap<K, Provider<V>>(size);
     }
+    /**
+     * Returns a new {@link MapProviderFactory} 
+     */
     public MapProviderFactory<K, V> build() {
       return new MapProviderFactory<K, V>(this.mapBuilder);
     }
-
-    public Builder<K, V> put(K k, Provider<V> pv) {
-      this.mapBuilder.put(k, pv);
+    /**
+     * Associate k with providerOfValue in {@link Builder}
+     */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      this.mapBuilder.put(key, providerOfValue);
       return this;
     }
   }
 
+  /**
+   * Returns a new {@link Builder} 
+   */
   public static <K, V> Builder<K, V> builder(int size) {
     return new Builder<K, V>(size);
   }
@@ -43,6 +58,11 @@ private MapProviderFactory(LinkedHashMap<K, Provider<V>> contributingMap) {
     this.contributingMap = contributingMap;
   }
 
+  /**
+   * Returns a {@link Map<K, Provider<V>>} whose iteration order is that of the elements given by each of the
+   * providers, which are invoked in the order given at creation.
+   *
+   */
   @Override
   public Map<K, Provider<V>> get() {
     return Collections.unmodifiableMap(contributingMap);
diff --git a/examples/simple/src/main/java/coffee/MilkFlavorModule.java b/examples/simple/src/main/java/coffee/MilkFlavorModule.java
index cf804bbd0..607b8eb65 100644
--- a/examples/simple/src/main/java/coffee/MilkFlavorModule.java
+++ b/examples/simple/src/main/java/coffee/MilkFlavorModule.java
@@ -4,7 +4,7 @@
 
 import dagger.Module;
 import dagger.Provides;
-// 
+
 @Module
 class MilkFlavorModule {
   @Provides(type = MAP)
