diff --git a/java/dagger/internal/codegen/DependencyRequest.java b/java/dagger/internal/codegen/DependencyRequest.java
index 2f69eb261..36b426380 100644
--- a/java/dagger/internal/codegen/DependencyRequest.java
+++ b/java/dagger/internal/codegen/DependencyRequest.java
@@ -108,12 +108,6 @@ boolean requestsPrimitiveType() {
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
 
-  /**
-   * An optional name for this request when it's referred to in generated code. If empty, it will
-   * use a name derived from {@link #requestElement}.
-   */
-  abstract Optional<String> overriddenVariableName();
-
   private static DependencyRequest.Builder builder() {
     return new AutoValue_DependencyRequest.Builder().isNullable(false);
   }
@@ -223,8 +217,6 @@ TypeMirror type() {
 
     abstract Builder isNullable(boolean isNullable);
 
-    abstract Builder overriddenVariableName(Optional<String> overriddenVariableName);
-
     @CheckReturnValue
     abstract DependencyRequest build();
   }
@@ -252,20 +244,6 @@ TypeMirror type() {
       return builder.build();
     }
 
-    /**
-     * Creates a implicit {@link DependencyRequest} for a {@link Provider} of {@code
-     * mapOfFactoryKey}.
-     *
-     * @param mapOfFactoryKey a key equivalent to {@code mapOfValueRequest}'s key, whose type is
-     *     {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}
-     */
-    DependencyRequest providerForImplicitMapBinding(Key mapOfFactoryKey) {
-      return DependencyRequest.builder()
-          .kind(PROVIDER)
-          .key(mapOfFactoryKey)
-          .build();
-    }
-
     /**
      * Creates synthetic dependency requests for each individual multibinding contribution in {@code
      * multibindingContributions}.
@@ -320,23 +298,12 @@ private RequestKind multibindingContributionRequestKind(
       }
     }
 
-    DependencyRequest forRequiredVariable(VariableElement variableElement) {
-      return forRequiredVariable(variableElement, Optional.empty());
-    }
-
-    DependencyRequest forRequiredVariable(VariableElement variableElement, Optional<String> name) {
-      checkNotNull(variableElement);
-      TypeMirror type = variableElement.asType();
-      Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, type, qualifier, name);
-    }
-
     DependencyRequest forRequiredResolvedVariable(
         VariableElement variableElement, TypeMirror resolvedType) {
       checkNotNull(variableElement);
       checkNotNull(resolvedType);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, resolvedType, qualifier, Optional.empty());
+      return newDependencyRequest(variableElement, resolvedType, qualifier);
     }
 
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
@@ -348,8 +315,7 @@ DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
           "Component provision methods must be empty: %s",
           provisionMethod);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
-      return newDependencyRequest(
-          provisionMethod, provisionMethodType.getReturnType(), qualifier, Optional.empty());
+      return newDependencyRequest(provisionMethod, provisionMethodType.getReturnType(), qualifier);
     }
 
     DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod,
@@ -370,7 +336,7 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
             .requestElement(productionMethod)
             .build();
       } else {
-        return newDependencyRequest(productionMethod, type, qualifier, Optional.empty());
+        return newDependencyRequest(productionMethod, type, qualifier);
       }
     }
 
@@ -403,12 +369,9 @@ DependencyRequest forProductionImplementationExecutor() {
     }
 
     DependencyRequest forProductionComponentMonitor() {
-      Key key = keyFactory.forProductionComponentMonitor();
       return DependencyRequest.builder()
           .kind(PROVIDER)
-          .key(key)
-          .requestElement(MoreTypes.asElement(key.type()))
-          .overriddenVariableName(Optional.of("monitor"))
+          .key(keyFactory.forProductionComponentMonitor())
           .build();
     }
 
@@ -432,8 +395,7 @@ DependencyRequest forSyntheticPresentOptionalBinding(Key requestKey, RequestKind
     private DependencyRequest newDependencyRequest(
         Element requestElement,
         TypeMirror type,
-        Optional<AnnotationMirror> qualifier,
-        Optional<String> name) {
+        Optional<AnnotationMirror> qualifier) {
       KindAndType kindAndType = extractKindAndType(type);
       if (kindAndType.kind().equals(MEMBERS_INJECTOR)) {
         checkArgument(!qualifier.isPresent());
@@ -443,7 +405,6 @@ private DependencyRequest newDependencyRequest(
           .key(keyFactory.forQualifiedType(qualifier, kindAndType.type()))
           .requestElement(requestElement)
           .isNullable(allowsNull(kindAndType.kind(), getNullableType(requestElement)))
-          .overriddenVariableName(name)
           .build();
     }
 
diff --git a/java/dagger/internal/codegen/DependencyVariableNamer.java b/java/dagger/internal/codegen/DependencyVariableNamer.java
index 161d5705f..a47e3a900 100644
--- a/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -16,8 +16,9 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Ascii;
 import com.google.common.base.CaseFormat;
 import dagger.Lazy;
@@ -39,10 +40,10 @@
   private static final Pattern LAZY_PROVIDER_PATTERN = Pattern.compile("lazy(\\w+)Provider");
 
   static String name(DependencyRequest dependency) {
-    if (dependency.overriddenVariableName().isPresent()) {
-      return dependency.overriddenVariableName().get();
+    if (!dependency.requestElement().isPresent()) {
+      return simpleVariableName(MoreTypes.asTypeElement(dependency.key().type()));
     }
-    checkArgument(dependency.requestElement().isPresent());
+
     String variableName = dependency.requestElement().get().getSimpleName().toString();
     if (Ascii.isUpperCase(variableName.charAt(0))) {
       variableName = toLowerCamel(variableName);
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 4b3effbcf..ace50e46f 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -372,18 +372,19 @@ public void publicModuleNonPublicIncludes() {
             "    implements AsyncFunction<Void, String>, Executor {",
             "  private final TestModule module;",
             "  private final Provider<Executor> executorProvider;",
-            "  private final Provider<ProductionComponentMonitor> monitorProvider;",
+            "  private final ",
+            "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider;",
             "",
             "  public TestModule_ProduceStringFactory(",
             "      TestModule module,",
             "      Provider<Executor> executorProvider,",
-            "      Provider<ProductionComponentMonitor> monitorProvider) {",
+            "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider) {",
             "    super(",
-            "        monitorProvider,",
+            "        productionComponentMonitorProvider,",
             "        ProducerToken.create(TestModule_ProduceStringFactory.class));",
             "    this.module = module;",
             "    this.executorProvider = executorProvider;",
-            "    this.monitorProvider = monitorProvider;",
+            "    this.productionComponentMonitorProvider = productionComponentMonitorProvider;",
             "  }",
             "",
             "  @Override protected ListenableFuture<String> compute() {",
@@ -454,18 +455,19 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "    implements AsyncFunction<Void, String>, Executor {",
             "  private final TestModule module;",
             "  private final Provider<Executor> executorProvider;",
-            "  private final Provider<ProductionComponentMonitor> monitorProvider;",
+            "  private final ",
+            "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider;",
             "",
             "  public TestModule_ProduceStringFactory(",
             "      TestModule module,",
             "      Provider<Executor> executorProvider,",
-            "      Provider<ProductionComponentMonitor> monitorProvider) {",
+            "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider) {",
             "    super(",
-            "        monitorProvider,",
+            "        productionComponentMonitorProvider,",
             "        ProducerToken.create(\"test.TestModule#produceString\"));",
             "    this.module = module;",
             "    this.executorProvider = executorProvider;",
-            "    this.monitorProvider = monitorProvider;",
+            "    this.productionComponentMonitorProvider = productionComponentMonitorProvider;",
             "  }",
             "",
             "  @Override protected ListenableFuture<String> compute() {",
