diff --git a/java/dagger/internal/codegen/BindingRequest.java b/java/dagger/internal/codegen/BindingRequest.java
index 85f231ec3..432e76f8d 100644
--- a/java/dagger/internal/codegen/BindingRequest.java
+++ b/java/dagger/internal/codegen/BindingRequest.java
@@ -97,4 +97,12 @@ final String kindName() {
             : frameworkType().get().frameworkClass().getSimpleName();
     return requestKindObject.toString();
   }
+
+  /** Returns {@code true} if this request can be satisfied by a production binding. */
+  final boolean canBeSatisfiedByProductionBinding() {
+    if (requestKind().isPresent()) {
+      return RequestKinds.canBeSatisfiedByProductionBinding(requestKind().get());
+    }
+    return frameworkType().get().equals(FrameworkType.PRODUCER_NODE);
+  }
 }
diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index a03275e71..61af7159a 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -765,7 +765,7 @@ protected void addInterfaceMethods() {
             superclassImplementation.getModifiableBindingMethods()) {
           bindingExpressions
               .modifiableBindingExpressions()
-              .reimplementedModifiableBindingMethod(superclassModifiableBindingMethod)
+              .possiblyReimplementedMethod(superclassModifiableBindingMethod)
               .ifPresent(componentImplementation::addImplementedModifiableBindingMethod);
         }
       } else {
diff --git a/java/dagger/internal/codegen/MissingBindingValidator.java b/java/dagger/internal/codegen/MissingBindingValidator.java
index bee1cfa43..642f7a4ad 100644
--- a/java/dagger/internal/codegen/MissingBindingValidator.java
+++ b/java/dagger/internal/codegen/MissingBindingValidator.java
@@ -20,7 +20,7 @@
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
 import static dagger.internal.codegen.Keys.isValidMembersInjectionKey;
-import static dagger.internal.codegen.RequestKinds.entryPointCanUseProduction;
+import static dagger.internal.codegen.RequestKinds.canBeSatisfiedByProductionBinding;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 import dagger.model.BindingGraph;
@@ -107,10 +107,12 @@ private boolean allIncomingDependenciesCanUseProduction(
         .allMatch(edge -> dependencyCanBeProduction(edge, graph));
   }
 
+  // TODO(ronshapiro): merge with
+  // ProvisionDependencyOnProduerBindingValidator.dependencyCanUseProduction
   private boolean dependencyCanBeProduction(DependencyEdge edge, BindingGraph graph) {
     Node source = graph.network().incidentNodes(edge).source();
     if (source instanceof ComponentNode) {
-      return entryPointCanUseProduction(edge.dependencyRequest().kind());
+      return canBeSatisfiedByProductionBinding(edge.dependencyRequest().kind());
     }
     if (source instanceof dagger.model.Binding) {
       return ((dagger.model.Binding) source).isProduction();
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index 4fc8b8977..8919ed7d4 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -84,14 +84,36 @@ ModifiableBindingType registerComponentMethodIfModifiable(
    * implementation of this subcomponent. Returns {@link Optional#empty()} when the binding cannot
    * or should not be modified by the current binding graph.
    */
-  Optional<ModifiableBindingMethod> reimplementedModifiableBindingMethod(
+  Optional<ModifiableBindingMethod> possiblyReimplementedMethod(
       ModifiableBindingMethod modifiableBindingMethod) {
     checkState(componentImplementation.superclassImplementation().isPresent());
-    ModifiableBindingType newModifiableBindingType =
-        getModifiableBindingType(modifiableBindingMethod.request());
+    BindingRequest request = modifiableBindingMethod.request();
+    ModifiableBindingType newModifiableBindingType = getModifiableBindingType(request);
     ModifiableBindingType oldModifiableBindingType = modifiableBindingMethod.type();
     boolean modifiableBindingTypeChanged =
         !newModifiableBindingType.equals(oldModifiableBindingType);
+
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
+    // Don't reimplement modifiable bindings that were perceived to be provision bindings in a
+    // superclass implementation but are now production bindings.
+    if ((modifiableBindingTypeChanged
+            // Optional bindings don't need the same treatment since the only transition they can
+            // make is empty -> present. In that case, the Producer<Optional<T>> will be overridden
+            // and the absentOptionalProvider() will be a dangling reference that is never attempted
+            // to be overridden.
+            || newModifiableBindingType.equals(ModifiableBindingType.MULTIBINDING))
+        && resolvedBindings != null
+        && resolvedBindings.bindingType().equals(BindingType.PRODUCTION)
+        && !request.canBeSatisfiedByProductionBinding()) {
+      return oldModifiableBindingType.hasBaseClassImplementation()
+          ? Optional.empty()
+          : Optional.of(
+              reimplementedMethod(
+                  modifiableBindingMethod,
+                  new PrunedConcreteMethodBindingExpression(),
+                  componentImplementation.isAbstract()));
+    }
+
     if (modifiableBindingTypeChanged
         && !newModifiableBindingType.hasBaseClassImplementation()
         && (oldModifiableBindingType.hasBaseClassImplementation()
@@ -103,32 +125,43 @@ ModifiableBindingType registerComponentMethodIfModifiable(
     }
 
     if (modifiableBindingTypeChanged
-        || shouldModifyImplementation(
-            newModifiableBindingType, modifiableBindingMethod.request())) {
-      MethodSpec baseMethod = modifiableBindingMethod.methodSpec();
+        || shouldModifyImplementation(newModifiableBindingType, request)) {
       boolean markMethodFinal =
           knownModifiableBindingWillBeFinalized(modifiableBindingMethod)
               // no need to mark the method final if the component implementation will be final
               && componentImplementation.isAbstract();
       return Optional.of(
-          ModifiableBindingMethod.implement(
+          reimplementedMethod(
               modifiableBindingMethod,
-              MethodSpec.methodBuilder(baseMethod.name)
-                  .addModifiers(baseMethod.modifiers.contains(PUBLIC) ? PUBLIC : PROTECTED)
-                  .addModifiers(markMethodFinal ? ImmutableSet.of(FINAL) : ImmutableSet.of())
-                  .returns(baseMethod.returnType)
-                  .addAnnotation(Override.class)
-                  .addCode(
-                      bindingExpressions
-                          .getBindingExpression(modifiableBindingMethod.request())
-                          .getModifiableBindingMethodImplementation(
-                              modifiableBindingMethod, componentImplementation, types))
-                  .build(),
+              bindingExpressions.getBindingExpression(request),
               markMethodFinal));
     }
     return Optional.empty();
   }
 
+  /**
+   * Returns a new {@link ModifiableBindingMethod} that overrides {@code supertypeMethod} and is
+   * implemented with {@code bindingExpression}.
+   */
+  private ModifiableBindingMethod reimplementedMethod(
+      ModifiableBindingMethod supertypeMethod,
+      BindingExpression bindingExpression,
+      boolean markMethodFinal) {
+    MethodSpec baseMethod = supertypeMethod.methodSpec();
+    return ModifiableBindingMethod.implement(
+        supertypeMethod,
+        MethodSpec.methodBuilder(baseMethod.name)
+            .addModifiers(baseMethod.modifiers.contains(PUBLIC) ? PUBLIC : PROTECTED)
+            .addModifiers(markMethodFinal ? ImmutableSet.of(FINAL) : ImmutableSet.of())
+            .returns(baseMethod.returnType)
+            .addAnnotation(Override.class)
+            .addCode(
+                bindingExpression.getModifiableBindingMethodImplementation(
+                    supertypeMethod, componentImplementation, types))
+            .build(),
+        markMethodFinal);
+  }
+
   /**
    * Returns true if a modifiable binding method that was registered in a superclass implementation
    * of this subcomponent should be marked as "finalized" if it is being overridden by this
@@ -329,16 +362,29 @@ ModifiableBindingType getModifiableBindingType(BindingRequest request) {
    */
   private boolean shouldModifyImplementation(
       ModifiableBindingType modifiableBindingType, BindingRequest request) {
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
     if (request.requestKind().isPresent()) {
       switch (request.requestKind().get()) {
         case FUTURE:
-          // Futures are always requested by a Producer.get() call, so if the binding is modifiable,
-          // the producer will be wrapped in a modifiable method and the future can refer to that
-          // method; even if the producer binding is modified, getModifiableProducer().get() will
-          // never need to be modified. Furthermore, because cancellation is treated by wrapped
-          // producers, and those producers point to the modifiable producer wrapper methods, we
-          // never need or want to change the access of these wrapped producers for entry
-          // methods
+          // Futures backed by production bindings are always requested by a Producer.get() call, so
+          // if the binding is modifiable, the producer will be wrapped in a modifiable method and
+          // the future can refer to that  method; even if the producer binding is modified,
+          // getModifiableProducer().get() will never need to be modified. Furthermore, because
+          // cancellation is treated by wrapped producers, and those producers point to the
+          // modifiable producer wrapper methods, we never need or want to change the access of
+          // these wrapped producers for entry methods
+          //
+          // Futures backed by provision bindings are inlined and contain no wrapping producer, so
+          // if the binding is modifiable and is resolved as a provision binding in a superclass
+          // but later resolved as a production binding, we can't take the same shortcut as before.
+          if (componentImplementation.superclassImplementation().isPresent()) {
+            BindingGraph superclassGraph =
+                componentImplementation.superclassImplementation().get().graph();
+            ResolvedBindings superclassBindings = superclassGraph.resolvedBindings(request);
+            return superclassBindings != null
+                && resolvedBindings != null
+                && !superclassBindings.bindingType().equals(resolvedBindings.bindingType());
+          }
           return false;
 
         case LAZY:
@@ -365,7 +411,6 @@ private boolean shouldModifyImplementation(
       }
     }
 
-    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
     switch (modifiableBindingType) {
       case GENERATED_INSTANCE:
         return !componentImplementation.isAbstract();
diff --git a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
index ce918624f..2fb1a0e2a 100644
--- a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
+++ b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
@@ -19,7 +19,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
-import static dagger.internal.codegen.RequestKinds.entryPointCanUseProduction;
+import static dagger.internal.codegen.RequestKinds.canBeSatisfiedByProductionBinding;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 import dagger.model.BindingGraph;
@@ -74,9 +74,10 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
         .flatMap(instancesOf(DependencyEdge.class));
   }
 
+  // TODO(ronshapiro): merge with MissingBindingValidator.dependencyCanUseProduction
   private boolean dependencyCanUseProduction(DependencyEdge edge, BindingGraph bindingGraph) {
     return edge.isEntryPoint()
-        ? entryPointCanUseProduction(edge.dependencyRequest().kind())
+        ? canBeSatisfiedByProductionBinding(edge.dependencyRequest().kind())
         : bindingRequestingDependency(edge, bindingGraph).isProduction();
   }
 
diff --git a/java/dagger/internal/codegen/RequestKinds.java b/java/dagger/internal/codegen/RequestKinds.java
index ab0197371..3c6b2f0b2 100644
--- a/java/dagger/internal/codegen/RequestKinds.java
+++ b/java/dagger/internal/codegen/RequestKinds.java
@@ -165,10 +165,10 @@ static TypeMirror extractKeyType(RequestKind requestKind, TypeMirror type) {
   }
 
   /**
-   * Returns {@code true} if entry points with the given request kind may be satisfied with a
-   * production binding.
+   * Returns {@code true} if requests for {@code requestKind} can be satisfied by a production
+   * binding.
    */
-  static boolean entryPointCanUseProduction(RequestKind requestKind) {
+  static boolean canBeSatisfiedByProductionBinding(RequestKind requestKind) {
     switch (requestKind) {
       case INSTANCE:
       case PROVIDER:
diff --git a/javatests/dagger/functional/producers/BUILD b/javatests/dagger/functional/producers/BUILD
index 2b3db633f..36c970197 100644
--- a/javatests/dagger/functional/producers/BUILD
+++ b/javatests/dagger/functional/producers/BUILD
@@ -38,6 +38,7 @@ GenJavaTests(
         "@google_bazel_common//third_party/java/junit",
         "@google_bazel_common//third_party/java/mockito",
         "@google_bazel_common//third_party/java/truth",
+        "@google_bazel_common//third_party/java/truth:truth8",
     ],
 )
 
diff --git a/javatests/dagger/functional/producers/aot/ProducesMethodShadowsInjectConstructorTest.java b/javatests/dagger/functional/producers/aot/ProducesMethodShadowsInjectConstructorTest.java
new file mode 100644
index 000000000..ef37df216
--- /dev/null
+++ b/javatests/dagger/functional/producers/aot/ProducesMethodShadowsInjectConstructorTest.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.aot;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth8.assertThat;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.BindsOptionalOf;
+import dagger.Provides;
+import dagger.multibindings.IntoSet;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import javax.inject.Inject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ProducesMethodShadowsInjectConstructorTest {
+  static class Multibound {}
+  static class Maybe {}
+
+  static class HasInjectConstructor {
+    @Inject HasInjectConstructor() {}
+  }
+
+  static class DependsOnShadowingProducer {}
+
+  @ProducerModule
+  abstract static class LeafModule {
+    @Produces
+    static DependsOnShadowingProducer dependsOnShadowingProducer(
+        // When viewed just within the leaf, this will resolve HasInjectConstructor to the @Inject
+        // constructor (and will receive a producerFromProvider), but when viewed within an ancestor
+        // that defines a @Produces method for HasInjectConstructor, the binding will be a regular
+        // Producer
+        HasInjectConstructor hasInjectConstructor,
+        Optional<Maybe> maybe) {
+      return new DependsOnShadowingProducer();
+    }
+
+    @Provides
+    @IntoSet
+    static Multibound provisionContribution() {
+      return new Multibound();
+    }
+
+    @BindsOptionalOf
+    abstract Maybe maybe();
+  }
+
+  @ProductionSubcomponent(modules = LeafModule.class)
+  interface Leaf {
+    ListenableFuture<DependsOnShadowingProducer> dependsOnShadowingProducer();
+    ListenableFuture<Set<Multibound>> shadowedProvisionMultibinding();
+    ListenableFuture<Optional<Maybe>> emptyProvisionBindingToPresentProductionBinding();
+  }
+
+  @ProducerModule
+  static class RootModule {
+    @Produces
+    static HasInjectConstructor shadowInjectConstructor() {
+      return new HasInjectConstructor();
+    }
+
+    @Produces
+    @IntoSet
+    static Multibound productionContribution() {
+      return new Multibound();
+    }
+
+    @Provides
+    @Production
+    static Executor executor() {
+      return MoreExecutors.directExecutor();
+    }
+
+    @Produces
+    static Maybe presentMaybeInParent() {
+      return new Maybe();
+    }
+  }
+
+  @ProductionComponent(modules = RootModule.class)
+  interface Root {
+    Leaf leaf();
+  }
+
+  @Test
+  public void shadowedInjectConstructorDoesNotCauseClassCast() throws Exception {
+    Leaf leaf = DaggerProducesMethodShadowsInjectConstructorTest_Root.create().leaf();
+    leaf.dependsOnShadowingProducer().get();
+    assertThat(leaf.shadowedProvisionMultibinding().get()).hasSize(2);
+    assertThat(leaf.emptyProvisionBindingToPresentProductionBinding().get()).isPresent();
+  }
+}
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index aa9a7c509..0b623621d 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -5403,6 +5403,187 @@ public void castModifiableMethodAccessedInFinalImplementation() {
         .containsElementsIn(generatedRoot);
   }
 
+  @Test
+  public void injectInLeaf_ProductionInRoot() {
+    // most of this is also covered in ProducesMethodShadowsInjectConstructorTest, but this test
+    // asserts that the correct PrunedConcreteBindingExpression is used
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createSimplePackagePrivateClasses(filesToCompile, "Dependency", "Missing");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Injected",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Injected {",
+            "  @Inject Injected(Dependency dependency, Missing missing) {}",
+            "",
+            "  Injected(Dependency dependency) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "interface LeafModule {",
+            "  @Produces",
+            "  static Object dependsOnInjectReplacedWithProduces(Injected injected) {",
+            "    return new Object();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Producer<Object> objectProducer();",
+            "}"));
+
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            GENERATION_OPTIONS_ANNOTATION,
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf, CancellationListener {",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.injectedProvider = Injected_Factory.create(",
+            "        getDependencyProvider(), getMissingProvider());",
+            "    this.injectedProducer = Producers.producerFromProvider(getInjectedProvider());",
+            "    this.dependsOnInjectReplacedWithProducesProducer =",
+            "        LeafModule_DependsOnInjectReplacedWithProducesFactory.create(",
+            "            getProductionImplementationExecutorProvider(),",
+            "            getProductionComponentMonitorProvider(),",
+            "            getInjectedProducer());",
+            "    this.objectProducerEntryPoint =",
+            "        Producers.entryPointViewOf(",
+            "            dependsOnInjectReplacedWithProducesProducer, this);",
+            "  }",
+            "",
+            "  protected abstract Provider getDependencyProvider();",
+            "  protected abstract Provider getMissingProvider();",
+            "",
+            "  protected Provider getInjectedProvider() {",
+            "    return injectedProvider;",
+            "  }",
+            "",
+            "  protected Producer getInjectedProducer() {",
+            "    return injectedProducer;",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .containsElementsIn(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.RootModule",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.MoreExecutors;",
+            "import dagger.Provides;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.Production;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@ProducerModule",
+            "interface RootModule {",
+            "  @Produces",
+            "  static Injected replaceInjectWithProduces(Dependency dependency) {",
+            "    return new Injected(dependency);",
+            "  }",
+            "",
+            "  @Produces",
+            "  static Dependency dependency() {",
+            "    return new Dependency();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @Production",
+            "  static Executor executor() {",
+            "    return MoreExecutors.directExecutor();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent(modules = RootModule.class)",
+            "interface Root {",
+            "  Leaf leaf();",
+            "}"));
+
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root, CancellationListener {",
+            "  private Producer<Dependency> dependencyProducer;",
+            "  private Producer<Injected> replaceInjectWithProducesProducer;",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.productionImplementationExecutorProvider =",
+            "        DoubleCheck.provider((Provider) RootModule_ExecutorFactory.create());",
+            "    this.rootProvider = InstanceFactory.create((Root) this);",
+            "    this.monitorProvider =",
+            "        DoubleCheck.provider(",
+            "            Root_MonitoringModule_MonitorFactory.create(",
+            "                rootProvider,",
+            "                SetFactory.<ProductionComponentMonitor.Factory>empty()));",
+            "    this.dependencyProducer =",
+            "        RootModule_DependencyFactory.create(",
+            "            productionImplementationExecutorProvider, monitorProvider);",
+            "    this.replaceInjectWithProducesProducer =",
+            "        RootModule_ReplaceInjectWithProducesFactory.create(",
+            "            productionImplementationExecutorProvider,",
+            "            monitorProvider,",
+            "            dependencyProducer);",
+            "  }",
+            "",
+            "  protected final class LeafImpl extends DaggerLeaf",
+            "      implements CancellationListener {",
+            "    @Override",
+            "    protected Provider getDependencyProvider() {",
+            "      return MissingBindingFactory.create();",
+            "    }",
+            "",
+            "    @Override",
+            "    protected Provider getMissingProvider() {",
+            "      return MissingBindingFactory.create();",
+            "    }",
+            "",
+            "    @Override",
+            "    protected Producer getInjectedProducer() {",
+            "      return DaggerRoot.this.replaceInjectWithProducesProducer;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .containsElementsIn(generatedRoot);
+  }
+
   // TODO(ronshapiro): remove copies from AheadOfTimeSubcomponents*Test classes
   private void createSimplePackagePrivateClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
