diff --git a/multibindings.md b/multibindings.md
index d9199c5fb..dd6f6e227 100644
--- a/multibindings.md
+++ b/multibindings.md
@@ -22,7 +22,7 @@ several modules contribute individual service providers to a map, keyed by name.
 
 In order to contribute one element to an injectable multibound set, add a method
 to a module that returns an element and is annotated with
-[`@Provides(type = SET)`][PTS]:
+[`@Provides(type = SET)`]:
 
 ```java
 @Module
@@ -35,8 +35,7 @@ class MyModuleA {
 ```
 
 You can also contribute several elements at one time by adding a module method
-that returns a subset and is annotated with
-[`@Provides(type = SET_VALUES)`][PTSV]:
+that returns a subset and is annotated with [`@Provides(type = SET_VALUES)`]:
 
 ```java
 @Module
@@ -118,10 +117,10 @@ Dagger lets you use multibindings to contribute entries to an injectable map as
 long as the map keys are known at compile time.
 
 To contribute an entry to a multibound map, add a method to a module that
-returns the value and is annotated with [`@Provides(type = MAP)`][PTM] and with
+returns the value and is annotated with [`@Provides(type = MAP)`] and with
 another custom annotation that specifies the map key for that entry. To
-contribute an entry to a qualified multibound map, annotate each
-`@Provides(type = MAP)` method with the qualifier.
+contribute an entry to a qualified multibound map, annotate each `@Provides(type
+= MAP)` method with the qualifier.
 
 Then you can inject either the map itself (`Map<K, V>`) or a map containing
 value providers (`Map<K, Provider<V>>`). The latter is useful when you don't
@@ -131,9 +130,42 @@ value each time you query the map.
 
 ### Simple map keys
 
-For maps with keys that are strings, enums, classes, or boxed primitives, write
-an annotation type with one member whose type is the (unboxed if necessary) map
-key type, and annotate it with [`@MapKey`][MapKey]:
+For maps with keys that are strings, `Class<?>`, or boxed primitives, use one of
+the standard annotations in [`dagger.mapkeys`]:
+
+```java
+@Module
+class MyModule {
+  @Provides(type = MAP)
+  @StringKey("foo")
+  Long provideFooValue() {
+    return 100L;
+  }
+
+  @Provides(type = MAP)
+  @ClassKey(Thing.class)
+  String provideThingValue() {
+    return "value for Thing";
+  }
+}
+
+@Component(modules = MyModule.class)
+interface MyComponent {
+  Map<String, Long> longsByString();
+  Map<Class<?>, String> stringsByClass();
+}
+
+@Test void testMyComponent() {
+  MyComponent myComponent = DaggerMyComponent.create();
+  assertThat(myComponent.longsByString.get("foo")).isEqualTo(100L);
+  assertThat(myComponent.stringsByClass.get(Thing.class))
+      .isEqualTo("value for Thing");
+}
+```
+
+For maps with keys that are enums or a more specifically parameterized class,
+write an annotation type with one member whose type is the map key type, and
+annotate it with [`@MapKey`]:
 
 ```java
 enum MyEnum {
@@ -145,11 +177,6 @@ enum MyEnum {
   MyEnum value();
 }
 
-@MapKey
-@interface MyLongKey {
-  long value();
-}
-
 @MapKey
 @interface MyNumberClassKey {
   Class<? extends Number> value();
@@ -163,12 +190,6 @@ class MyModule {
     return "value for ABC";
   }
 
-  @Provides(type = MAP)
-  @MyLongKey(100L)
-  String provide100Value() {
-    return "value for 100";
-  }
-
   @Provides(type = MAP)
   @MyNumberClassKey(BigDecimal.class)
   String provideBigDecimalValue() {
@@ -179,15 +200,13 @@ class MyModule {
 @Component(modules = MyModule.class)
 interface MyComponent {
   Map<MyEnum, String> myEnumStringMap();
-  Map<Long, String> longStringMap();
-  Map<Class<? extends Number>, String> numberClassStringMap();
+  Map<Class<? extends Number>, String> stringsByNumberClass();
 }
 
 @Test void testMyComponent() {
   MyComponent myComponent = DaggerMyComponent.create();
-  assertThat(myEnumStringMap.get(MyEnum.ABC)).isEqualTo("value for ABC");
-  assertThat(longStringMap.get(100L)).isEqualTo("value for 100");
-  assertThat(numberClassStringMap.get(BigDecimal.class))
+  assertThat(myComponent.myEnumStringMap().get(MyEnum.ABC)).isEqualTo("value for ABC");
+  assertThat(myComponent.stringsByNumberClass.get(BigDecimal.class))
       .isEqualTo("value for BigDecimal");
 }
 ```
@@ -231,7 +250,7 @@ If your map uses complex keys, then you may need to create an instance of your
 `@MapKey` annotation at run-time to pass to the map's `get(Object)` method. The
 easiest way to do that is to use the `@AutoAnnotation` annotation to create a
 static method that instantiates your annotation. See
-`@AutoAnnotation`'s [documentation][AutoAnnotation] for more details.
+`@AutoAnnotation`'s [documentation][`@AutoAnnotation`] for more details.
 
 ```java
 class MyComponentTest {
@@ -408,15 +427,16 @@ class ChildModule {
 <!-- references & footnotes -->
 
 [^AutoAnnotation]:
-    You can use [`@AutoAnnotation`][AutoAnnotation] to create annotation
-    instances to pass to the map's `get(Object)` method.
+    You can use [`@AutoAnnotation`] to create annotation instances to pass to
+    the map's `get(Object)` method.
 
-[PTS]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#SET
 
-[PTS]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#SET_VALUES
+[`@AutoAnnotation`]: https://github.com/google/auto/blob/master/value/src/main/java/com/google/auto/value/AutoAnnotation.java
+[`dagger.mapkeys`]: http://google.github.io/dagger/api/latest/dagger/mapkeys/package-summary.html
+[`@MapKey`]: http://google.github.io/dagger/api/latest/dagger/MapKey.html
+[`@Provides(type = MAP)`]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#MAP
+[`@Provides(type = SET)`]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#SET
+[`@Provides(type = SET_VALUES)`]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#SET_VALUES
 
-[PTM]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#MAP
 
-[AutoAnnotation]: https://github.com/google/auto/blob/master/value/src/main/java/com/google/auto/value/AutoAnnotation.java
 
-[MapKey]: http://google.github.io/dagger/api/latest/dagger/MapKey.html
