diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index e1e25ad8f..c13ebaee3 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -223,6 +223,12 @@ TypeElement componentTypeElement() {
         .toSet();
   }
 
+  /**
+   * {@code true} if this graph contains all bindings installed in the component; {@code false} if
+   * it contains only those bindings that are reachable from at least one entry point.
+   */
+  abstract boolean isFullBindingGraph();
+
   @Memoized
   @Override
   public abstract int hashCode();
@@ -236,7 +242,8 @@ static BindingGraph create(
       ImmutableMap<Key, ResolvedBindings> resolvedMembersInjectionBindings,
       ImmutableList<BindingGraph> subgraphs,
       ImmutableSet<ModuleDescriptor> ownedModules,
-      Optional<ExecutableElement> factoryMethod) {
+      Optional<ExecutableElement> factoryMethod,
+      boolean isFullBindingGraph) {
     checkForDuplicates(subgraphs);
     return new AutoValue_BindingGraph(
         componentDescriptor,
@@ -244,7 +251,8 @@ static BindingGraph create(
         resolvedMembersInjectionBindings,
         subgraphs,
         ownedModules,
-        factoryMethod);
+        factoryMethod,
+        isFullBindingGraph);
   }
 
   private static final void checkForDuplicates(Iterable<BindingGraph> graphs) {
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index 4ea1bb888..a7b7983a4 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -57,11 +57,8 @@
   /**
    * Creates the external {@link dagger.model.BindingGraph} representing the given internal {@link
    * dagger.internal.codegen.BindingGraph}.
-   *
-   * @param fullBindingGraph if {@code true}, include bindings that are not reachable from any entry
-   *     points
    */
-  dagger.model.BindingGraph convert(BindingGraph bindingGraph, boolean fullBindingGraph) {
+  dagger.model.BindingGraph convert(BindingGraph bindingGraph) {
     Traverser traverser = new Traverser(bindingGraph);
     traverser.traverseComponents();
 
@@ -69,13 +66,13 @@
     // multibindings or optional bindings, the parent-owned binding is still there. If that
     // parent-owned binding is not reachable from its component, it doesn't need to be in the graph
     // because it will never be used. So remove all nodes that are not reachable from the root
-    // component—unless we're building a full binding graph.
-    if (!fullBindingGraph) {
+    // component—unless we're converting a full binding graph.
+    if (!bindingGraph.isFullBindingGraph()) {
       unreachableNodes(traverser.network.asGraph(), rootComponentNode(traverser.network))
           .forEach(traverser.network::removeNode);
     }
 
-    return BindingGraphProxies.bindingGraph(traverser.network, fullBindingGraph);
+    return BindingGraphProxies.bindingGraph(traverser.network, bindingGraph.isFullBindingGraph());
   }
 
   // TODO(dpb): Example of BindingGraph logic applied to derived networks.
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index b417e8684..5109f0ff8 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -76,7 +76,6 @@
   private final InjectBindingRegistry injectBindingRegistry;
   private final KeyFactory keyFactory;
   private final BindingFactory bindingFactory;
-  private final CompilerOptions compilerOptions;
   private final ModuleDescriptor.Factory moduleDescriptorFactory;
   private final Map<Key, ImmutableSet<Key>> keysMatchingRequestCache = new HashMap<>();
 
@@ -86,25 +85,28 @@
       InjectBindingRegistry injectBindingRegistry,
       KeyFactory keyFactory,
       BindingFactory bindingFactory,
-      ModuleDescriptor.Factory moduleDescriptorFactory,
-      CompilerOptions compilerOptions) {
+      ModuleDescriptor.Factory moduleDescriptorFactory) {
     this.elements = elements;
     this.injectBindingRegistry = injectBindingRegistry;
     this.keyFactory = keyFactory;
     this.bindingFactory = bindingFactory;
     this.moduleDescriptorFactory = moduleDescriptorFactory;
-    this.compilerOptions = compilerOptions;
   }
 
-  /** Creates a binding graph for a root component. */
-  BindingGraph create(ComponentDescriptor componentDescriptor) {
-    checkArgument(
-        !componentDescriptor.isSubcomponent() || compilerOptions.aheadOfTimeSubcomponents());
-    return create(Optional.empty(), componentDescriptor);
+  /**
+   * Creates a binding graph for a component.
+   *
+   * @param createFullBindingGraph if {@code true}, the binding graph will include all bindings;
+   *     otherwise it will include only bindings reachable from at least one entry point
+   */
+  BindingGraph create(ComponentDescriptor componentDescriptor, boolean createFullBindingGraph) {
+    return create(Optional.empty(), componentDescriptor, createFullBindingGraph);
   }
 
   private BindingGraph create(
-      Optional<Resolver> parentResolver, ComponentDescriptor componentDescriptor) {
+      Optional<Resolver> parentResolver,
+      ComponentDescriptor componentDescriptor,
+      boolean createFullBindingGraph) {
     ImmutableSet.Builder<ContributionBinding> explicitBindingsBuilder = ImmutableSet.builder();
     ImmutableSet.Builder<DelegateDeclaration> delegatesBuilder = ImmutableSet.builder();
     ImmutableSet.Builder<OptionalBindingDeclaration> optionalsBuilder = ImmutableSet.builder();
@@ -187,9 +189,9 @@ private BindingGraph create(
               }
             });
 
-    if (!requestResolver.rootComponent().isRealComponent()) {
-      // For module-binding validation, resolve the keys for all bindings in all modules, stripping
-      // any multibinding contribution identifier so that the multibinding itself is resolved.
+    if (createFullBindingGraph) {
+      // Resolve the keys for all bindings in all modules, stripping any multibinding contribution
+      // identifier so that the multibinding itself is resolved.
       modules(componentDescriptor, parentResolver).stream()
           .flatMap(module -> module.allBindingKeys().stream())
           .map(key -> key.toBuilder().multibindingContributionIdentifier(Optional.empty()).build())
@@ -206,7 +208,7 @@ private BindingGraph create(
     for (ComponentDescriptor subcomponent :
         Iterables.consumingIterable(requestResolver.subcomponentsToResolve)) {
       if (resolvedSubcomponents.add(subcomponent)) {
-        subgraphs.add(create(Optional.of(requestResolver), subcomponent));
+        subgraphs.add(create(Optional.of(requestResolver), subcomponent, createFullBindingGraph));
       }
     }
 
@@ -226,7 +228,8 @@ private BindingGraph create(
         requestResolver.getResolvedMembersInjectionBindings(),
         subgraphs.build(),
         requestResolver.getOwnedModules(),
-        requestResolver.getFactoryMethod());
+        requestResolver.getFactoryMethod(),
+        createFullBindingGraph);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
index b49072292..848125f54 100644
--- a/java/dagger/internal/codegen/ComponentImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -112,7 +112,7 @@ ComponentImplementation findChildSuperclassImplementation(
     // Otherwise, the superclass implementation is top-level, so we must recreate the
     // implementation object for the base implementation of the child by truncating the binding
     // graph at the child.
-    BindingGraph truncatedBindingGraph = bindingGraphFactory.create(child);
+    BindingGraph truncatedBindingGraph = bindingGraphFactory.create(child, false);
     return createComponentImplementation(truncatedBindingGraph);
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentNodeImpl.java b/java/dagger/internal/codegen/ComponentNodeImpl.java
index 3534102a5..3a31ec7d8 100644
--- a/java/dagger/internal/codegen/ComponentNodeImpl.java
+++ b/java/dagger/internal/codegen/ComponentNodeImpl.java
@@ -38,6 +38,11 @@ public final boolean isSubcomponent() {
     return componentDescriptor().isSubcomponent();
   }
 
+  @Override
+  public boolean isRealComponent() {
+    return componentDescriptor().isRealComponent();
+  }
+
   @Override
   public final ImmutableSet<DependencyRequest> entryPoints() {
     return componentDescriptor().entryPointMethods().stream()
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 646e50e26..a25a55955 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -132,7 +132,7 @@ protected void process(
       if (!componentDescriptorReport.isClean()) {
         return;
       }
-      BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+      BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor, false);
       if (isValid(bindingGraph)) {
         generateComponent(bindingGraph);
       }
@@ -144,7 +144,7 @@ protected void process(
       }
       ComponentDescriptor componentDescriptor =
           componentDescriptorFactory.subcomponentDescriptor(element);
-      BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+      BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor, false);
       if (isValid(bindingGraph)) {
         generateComponent(bindingGraph);
       }
@@ -152,8 +152,7 @@ protected void process(
   }
 
   private boolean isValid(BindingGraph bindingGraph) {
-    dagger.model.BindingGraph modelGraph = bindingGraphConverter.convert(bindingGraph, false);
-    return bindingGraphValidator.isValid(modelGraph);
+    return bindingGraphValidator.isValid(bindingGraphConverter.convert(bindingGraph));
   }
 
   private void generateComponent(BindingGraph bindingGraph) {
diff --git a/java/dagger/internal/codegen/DaggerKythePlugin.java b/java/dagger/internal/codegen/DaggerKythePlugin.java
index bfdbc1227..238a50a0f 100644
--- a/java/dagger/internal/codegen/DaggerKythePlugin.java
+++ b/java/dagger/internal/codegen/DaggerKythePlugin.java
@@ -61,7 +61,8 @@ public Void visitClassDef(JCClassDecl tree, Void p) {
     if (tree.sym != null
         && isAnyAnnotationPresent(tree.sym, Component.class, ProductionComponent.class)) {
       addNodesForGraph(
-          bindingGraphFactory.create(componentDescriptorFactory.rootComponentDescriptor(tree.sym)));
+          bindingGraphFactory.create(
+              componentDescriptorFactory.rootComponentDescriptor(tree.sym), false));
     }
     return super.visitClassDef(tree, p);
   }
diff --git a/java/dagger/internal/codegen/DependencyCycleValidator.java b/java/dagger/internal/codegen/DependencyCycleValidator.java
index dd947ca4a..d5d4b629e 100644
--- a/java/dagger/internal/codegen/DependencyCycleValidator.java
+++ b/java/dagger/internal/codegen/DependencyCycleValidator.java
@@ -106,14 +106,14 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
   /**
    * Reports a dependency cycle at the dependency into the cycle that is closest to an entry point.
    *
-   * <p>For cycles found in standard components, looks for the shortest path from the component that
-   * contains the cycle (all bindings in a cycle must be in the same component; see below) to some
-   * binding in the cycle. Then looks for the last dependency in that path that is not in the cycle;
-   * that is the dependency that will be reported, so that the dependency trace will end just before
-   * the cycle.
+   * <p>For cycles found in reachable binding graphs, looks for the shortest path from the component
+   * that contains the cycle (all bindings in a cycle must be in the same component; see below) to
+   * some binding in the cycle. Then looks for the last dependency in that path that is not in the
+   * cycle; that is the dependency that will be reported, so that the dependency trace will end just
+   * before the cycle.
    *
-   * <p>For cycles found during module binding validation, just reports the component that contains
-   * the cycle.
+   * <p>For cycles found during full binding graph validation, just reports the component that
+   * contains the cycle.
    *
    * <p>Proof (by counterexample) that all bindings in a cycle must be in the same component: Assume
    * one binding in the cycle is in a parent component. Bindings cannot depend on bindings in child
@@ -121,7 +121,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
    */
   private void reportCycle(
       Cycle<Node> cycle, BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    if (bindingGraph.isModuleBindingGraph()) {
+    if (bindingGraph.isFullBindingGraph()) {
       diagnosticReporter.reportComponent(
           ERROR,
           bindingGraph.componentNode(cycle.nodes().asList().get(0).componentPath()).get(),
diff --git a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
index 984b686e1..7bbbd07ef 100644
--- a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
+++ b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
@@ -70,9 +70,9 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
                 ComponentNode componentNode =
                     bindingGraph.componentNode(binding.componentPath()).get();
                 if (!componentNode.scopes().contains(scope)) {
-                  // @Inject bindings in module binding graphs will appear at the properly scoped
+                  // @Inject bindings in full binding graphs will appear at the properly scoped
                   // ancestor component, so ignore them here.
-                  if (binding.kind().equals(INJECTION) && bindingGraph.isModuleBindingGraph()) {
+                  if (binding.kind().equals(INJECTION) && bindingGraph.isFullBindingGraph()) {
                     return;
                   }
                   incompatibleBindings.put(componentNode, binding);
@@ -80,23 +80,20 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
               });
     }
     Multimaps.asMap(incompatibleBindings.build())
-        .forEach(
-            (componentNode, bindings) ->
-                report(componentNode, bindings, bindingGraph, diagnosticReporter));
+        .forEach((componentNode, bindings) -> report(componentNode, bindings, diagnosticReporter));
   }
 
   private void report(
       ComponentNode componentNode,
       Set<Binding> bindings,
-      BindingGraph bindingGraph,
       DiagnosticReporter diagnosticReporter) {
     Diagnostic.Kind diagnosticKind = ERROR;
     StringBuilder message =
         new StringBuilder(componentNode.componentPath().currentComponent().getQualifiedName());
 
-    if (bindingGraph.isModuleBindingGraph() && componentNode.componentPath().atRoot()) {
-      // The root "component" of a module binding graph is a module, which will have no scopes
-      // attached. We want to report if there is more than one scope in that component.
+    if (!componentNode.isRealComponent()) {
+      // If the "component" is really a module, it will have no scopes attached. We want to report
+      // if there is more than one scope in that component.
       if (bindings.stream().map(Binding::scope).map(Optional::get).distinct().count() <= 1) {
         return;
       }
diff --git a/java/dagger/internal/codegen/MissingBindingValidator.java b/java/dagger/internal/codegen/MissingBindingValidator.java
index f927294c0..bee1cfa43 100644
--- a/java/dagger/internal/codegen/MissingBindingValidator.java
+++ b/java/dagger/internal/codegen/MissingBindingValidator.java
@@ -54,9 +54,9 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
-    // Don't report missing bindings when validating a binding graph based on a subcomponent or
-    // module.
-    if (graph.isModuleBindingGraph() || graph.rootComponentNode().isSubcomponent()) {
+    // Don't report missing bindings when validating a full graph or a graph built from a
+    // subcomponent.
+    if (graph.isFullBindingGraph() || graph.rootComponentNode().isSubcomponent()) {
       return;
     }
     graph
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index fdd0551d4..c801ec300 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -588,8 +588,7 @@ private void validateModuleBindings(
     BindingGraph bindingGraph =
         bindingGraphConverter.convert(
             bindingGraphFactory.create(
-                componentDescriptorFactory.moduleComponentDescriptor(module)),
-            true);
+                componentDescriptorFactory.moduleComponentDescriptor(module), true));
     if (!bindingGraphValidator.isValid(bindingGraph)) {
       // Since the validator uses a DiagnosticReporter to report errors, the ValdiationReport won't
       // have any Items for them. We have to tell the ValidationReport that some errors were
diff --git a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
index 2f79b0157..7d95ee411 100644
--- a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
+++ b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
@@ -61,8 +61,10 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    if (bindingGraph.isModuleBindingGraph() || bindingGraph.rootComponentNode().isSubcomponent()) {
-      // We don't know all the modules that might be owned by the child until we know the root.
+    if (!bindingGraph.rootComponentNode().isRealComponent()
+        || bindingGraph.rootComponentNode().isSubcomponent()) {
+      // We don't know all the modules that might be owned by the child until we know the real root
+      // component, which we don't if the root component node is really a module or a subcomponent.
       return;
     }
     bindingGraph.network().edges().stream()
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 0f82b31b4..581458228 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -55,9 +55,10 @@
  * </ul>
  *
  * In the case of a {@link BindingGraph} representing a module, the root {@link ComponentNode} will
- * actually represent the module type, and there will be an entry point edge (with no request
- * element) for every binding (except multibinding contributions) in the module, including its
- * transitively included modules.
+ * actually represent the module type. The graph will also be a {@linkplain #isFullBindingGraph()
+ * full binding graph}, which means it will contain all bindings in all modules, as well as nodes
+ * for their dependencies. Otherwise it will contain only bindings that are reachable from at least
+ * one {@linkplain #entryPointEdges() entry point}.
  *
  * <h3>Nodes</h3>
  *
@@ -89,8 +90,8 @@
 @AutoValue
 public abstract class BindingGraph {
 
-  static BindingGraph create(Network<Node, Edge> network, boolean isModuleBindingGraph) {
-    return new AutoValue_BindingGraph(ImmutableNetwork.copyOf(network), isModuleBindingGraph);
+  static BindingGraph create(Network<Node, Edge> network, boolean isFullBindingGraph) {
+    return new AutoValue_BindingGraph(ImmutableNetwork.copyOf(network), isFullBindingGraph);
   }
 
   BindingGraph() {}
@@ -108,8 +109,22 @@ public final String toString() {
    *
    * @see <a href="https://google.github.io/dagger/compiler-options#module-binding-validation">Module binding
    *     validation</a>
+   * @deprecated use {@link #isFullBindingGraph()} to tell if this is a full binding graph, or
+   *     {@link ComponentNode#isRealComponent() rootComponentNode().isRealComponent()} to tell if
+   *     the root component node is really a component or derived from a module. Dagger will soon
+   *     generate full binding graphs for components and subcomponents as well as modules.
    */
-  public abstract boolean isModuleBindingGraph();
+  @Deprecated
+  public final boolean isModuleBindingGraph() {
+    return !rootComponentNode().isRealComponent();
+  }
+
+  /**
+   * Returns {@code true} if this is a full binding graph, which contains all bindings installed in
+   * the component, or {@code false} if it is a reachable binding graph, which contains only
+   * bindings that are reachable from at least one {@linkplain #entryPointEdges() entry point}.
+   */
+  public abstract boolean isFullBindingGraph();
 
   /**
    * Returns {@code true} if the {@link #rootComponentNode()} is a subcomponent. This occurs in
@@ -413,6 +428,12 @@ public final String toString() {
      */
     boolean isSubcomponent();
 
+    /**
+     * Returns {@code true} if the component is a real component, or {@code false} if it is a
+     * fictional component based on a module.
+     */
+    boolean isRealComponent();
+
     /** The entry points on this component. */
     ImmutableSet<DependencyRequest> entryPoints();
 
diff --git a/java/dagger/model/BindingGraphProxies.java b/java/dagger/model/BindingGraphProxies.java
index 4d514f328..c4504759b 100644
--- a/java/dagger/model/BindingGraphProxies.java
+++ b/java/dagger/model/BindingGraphProxies.java
@@ -28,9 +28,8 @@
  */
 public final class BindingGraphProxies {
   /** Creates a new {@link BindingGraph}. */
-  public static BindingGraph bindingGraph(
-      Network<Node, Edge> network, boolean isModuleBindingGraph) {
-    return BindingGraph.create(network, isModuleBindingGraph);
+  public static BindingGraph bindingGraph(Network<Node, Edge> network, boolean isFullBindingGraph) {
+    return BindingGraph.create(network, isFullBindingGraph);
   }
 
   /** Creates a new {@link MissingBinding}. */
