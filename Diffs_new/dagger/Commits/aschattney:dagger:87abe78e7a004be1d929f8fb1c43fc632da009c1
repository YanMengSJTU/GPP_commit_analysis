diff --git a/BUILD b/BUILD
index 6167e63e8..876e647c4 100644
--- a/BUILD
+++ b/BUILD
@@ -73,6 +73,15 @@ jarjar_library(
     ],
 )
 
+jarjar_library(
+    name = "shaded_grpc_server_processor",
+    rules_file = "shade_rules.txt",
+    deps = [
+        "//java/dagger/grpc/server/processor",
+        "@com_google_auto_auto_common//jar",
+    ],
+)
+
 load("//tools:javadoc.bzl", "javadoc_library")
 
 # coalesced javadocs used for the gh-pages site
@@ -82,6 +91,8 @@ javadoc_library(
         "//java/dagger:javadoc-srcs",
         "//java/dagger/android:android-srcs",
         "//java/dagger/android/support:support-srcs",
+        "//java/dagger/grpc/server:javadoc-srcs",
+        "//java/dagger/grpc/server/processor:javadoc-srcs",
         "//java/dagger/producers:producers-srcs",
     ],
     android_api_level = 25,
@@ -97,6 +108,8 @@ javadoc_library(
         "//java/dagger:core",
         "//java/dagger/android",
         "//java/dagger/android/support",
+        "//java/dagger/grpc/server",
+        "//java/dagger/grpc/server/processor",
         "//java/dagger/producers",
     ],
 )
diff --git a/WORKSPACE b/WORKSPACE
index 61e33ef0a..729e0290f 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -155,6 +155,62 @@ maven_jar(
     sha1 = "4fdcf1fc27c1a8f55d1109df986c923152f07759",
 )
 
+maven_jar(
+    name = "io_grpc_grpc_core",
+    artifact = "io.grpc:grpc-core:1.2.0",
+    sha1 = "f12a213e2b59a0615df2cc9bed35dc15fd2fee37",
+)
+
+maven_jar(
+    name = "io_grpc_grpc_netty",
+    artifact = "io.grpc:grpc-netty:1.2.0",
+    sha1 = "e2682d2dc052898f87433e7a6d03d104ef98df74",
+)
+
+maven_jar(
+    name = "io_grpc_grpc_context",
+    artifact = "io.grpc:grpc-context:1.2.0",
+    sha1 = "1932db544cbb427bc18f902c7ebbb3f7e44991df",
+)
+
+maven_jar(
+    name = "io_grpc_grpc_protobuf",
+    artifact = "io.grpc:grpc-protobuf:1.2.0",
+    sha1 = "2676852d2dbd20155d9b1a940a456eae5b7445f0",
+)
+
+maven_jar(
+    name = "io_grpc_grpc_stub",
+    artifact = "io.grpc:grpc-stub:1.2.0",
+    sha1 = "964dda53b3085bfd17c7aaf51495f9efc8bda36c",
+)
+
+maven_jar(
+    name = "io_grpc_grpc_all",
+    artifact = "io.grpc:grpc-all:1.2.0",
+    sha1 = "f32006a1245dfa2d68bf92a1b4cc01831889c95b",
+)
+
+maven_jar(
+    name = "com_google_protobuf_protobuf_java",
+    artifact = "com.google.protobuf:protobuf-java:3.2.0",
+    sha1 = "62ccf171a106ff6791507f2d5364c275f9a3131d",
+)
+
+http_archive(
+    name = "com_google_protobuf",
+    sha256 = "ff771a662fb6bd4d3cc209bcccedef3e93980a49f71df1e987f6afa3bcdcba3a",
+    strip_prefix = "protobuf-b4b0e304be5a68de3d0ee1af9b286f958750f5e4",
+    urls = ["https://github.com/google/protobuf/archive/b4b0e304be5a68de3d0ee1af9b286f958750f5e4.zip"],
+)
+
+http_archive(
+    name = "com_google_protobuf_java",
+    sha256 = "ff771a662fb6bd4d3cc209bcccedef3e93980a49f71df1e987f6afa3bcdcba3a",
+    strip_prefix = "protobuf-b4b0e304be5a68de3d0ee1af9b286f958750f5e4",
+    urls = ["https://github.com/google/protobuf/archive/b4b0e304be5a68de3d0ee1af9b286f958750f5e4.zip"],
+)
+
 load("//tools:jarjar.bzl", "jarjar_deps")
 
 jarjar_deps()
diff --git a/java/dagger/grpc/server/BUILD b/java/dagger/grpc/server/BUILD
new file mode 100644
index 000000000..f3e2d023e
--- /dev/null
+++ b/java/dagger/grpc/server/BUILD
@@ -0,0 +1,61 @@
+# A framework supporting Dagger-injected gRPC servers.
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
+
+ANNOTATIONS_SRCS = [
+    "CallScoped.java",
+    "ForGrpcService.java",
+    "GrpcService.java",
+]
+
+java_library(
+    name = "annotations",
+    srcs = ANNOTATIONS_SRCS,
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//third_party:jsr330_inject",
+    ],
+)
+
+# TODO(dpb): Split out the grpc:inprocess and grpc:netty deps into separate libraries.
+java_library(
+    name = "server",
+    srcs = glob(
+        ["*.java"],
+        exclude = ANNOTATIONS_SRCS,
+    ),
+    exported_plugins = ["//java/dagger/grpc/server/processor:plugin"],
+    javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    exports = [":annotations"],
+    deps = [
+        "//:dagger_with_compiler",
+        "//third_party:auto_value",
+        "//third_party:grpc_context",
+        "//third_party:grpc_core",
+        "//third_party:grpc_netty",
+        "//third_party:grpc_protobuf",
+        "//third_party:guava",
+        "//third_party:jsr305_annotations",
+        "//third_party:jsr330_inject",
+        "//third_party:protobuf",
+    ],
+)
+
+filegroup(
+    name = "javadoc-srcs",
+    srcs = glob(["*.java"]),
+)
+
+load("//tools:javadoc.bzl", "javadoc_library")
+
+javadoc_library(
+    name = "javadoc",
+    srcs = [":javadoc-srcs"],
+    root_packages = ["dagger.grpc.server"],
+    deps = [
+        ":annotations",
+        ":server",
+    ],
+)
diff --git a/java/dagger/grpc/server/CallScoped.java b/java/dagger/grpc/server/CallScoped.java
new file mode 100644
index 000000000..a477f9d29
--- /dev/null
+++ b/java/dagger/grpc/server/CallScoped.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import java.lang.annotation.Documented;
+import javax.inject.Scope;
+
+/**
+ * A scope that lasts as long as a single gRPC {@link io.grpc.ServerCall}.
+ */
+@Scope
+@Documented
+public @interface CallScoped {}
diff --git a/java/dagger/grpc/server/CurrentContextModule.java b/java/dagger/grpc/server/CurrentContextModule.java
new file mode 100644
index 000000000..c11753762
--- /dev/null
+++ b/java/dagger/grpc/server/CurrentContextModule.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import dagger.Module;
+import dagger.Provides;
+import io.grpc.Context;
+
+/**
+ * Provides the current {@link Context}.
+ */
+@Module
+public final class CurrentContextModule {
+
+  @Provides
+  static Context currentContext() {
+    return Context.current();
+  }
+}
diff --git a/java/dagger/grpc/server/ForGrpcService.java b/java/dagger/grpc/server/ForGrpcService.java
new file mode 100644
index 000000000..33a83ad73
--- /dev/null
+++ b/java/dagger/grpc/server/ForGrpcService.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import java.lang.annotation.Documented;
+import javax.inject.Qualifier;
+
+/**
+ * Qualifies some per-service types provided by {@link dagger.Module}s generated by {@link
+ * GrpcService}.
+ */
+@Documented
+@Qualifier
+public @interface ForGrpcService {
+
+  /** The gRPC service class. */
+  Class<?> value();
+}
diff --git a/java/dagger/grpc/server/GrpcCallMetadataModule.java b/java/dagger/grpc/server/GrpcCallMetadataModule.java
new file mode 100644
index 000000000..8d474d965
--- /dev/null
+++ b/java/dagger/grpc/server/GrpcCallMetadataModule.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import dagger.Module;
+import dagger.Provides;
+import io.grpc.Metadata;
+
+/**
+ * Provides {@link Metadata} about a gRPC call.
+ */
+@Module
+public final class GrpcCallMetadataModule {
+  private final Metadata metadata;
+
+  public GrpcCallMetadataModule(Metadata metadata) {
+    this.metadata = checkNotNull(metadata);
+  }
+
+  @Provides
+  Metadata provideHeaders() {
+    return metadata;
+  }
+}
diff --git a/java/dagger/grpc/server/GrpcService.java b/java/dagger/grpc/server/GrpcService.java
new file mode 100644
index 000000000..a7461951d
--- /dev/null
+++ b/java/dagger/grpc/server/GrpcService.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Target;
+
+/**
+ * Annotates a class that implements a gRPC service.
+ *
+ * <p>Generates several types when annotating a class {@code Foo}:
+ *
+ * <ul>
+ * <li>Interfaces {@code FooComponent} and {@code FooComponent.Factory}.
+ * <li>{@linkplain dagger.Module Modules} {@code FooGrpcProxyModule} and {@code
+ *     FooGrpcServiceModule}.
+ * </ul>
+ *
+ * <p>To use these types to configure a server:
+ *
+ * <ol>
+ * <li>Create a {@linkplain dagger.Subcomponent subcomponent} that implements {@code FooComponent}
+ *     and installs {@code FooGrpcServiceModule}.
+ * <li>Install {@link NettyServerModule} or another {@link ServerModule} subclass and {@code
+ *     FooGrpcProxyModule} into your {@link javax.inject.Singleton @Singleton} {@linkplain
+ *     dagger.Component component}.
+ * <li>Bind an implementation of {@code FooComponent.Factory} in your {@link
+ *     javax.inject.Singleton @Singleton} {@linkplain dagger.Component component}. The
+ *     implementation will typically inject the {@link javax.inject.Singleton @Singleton}
+ *     {@linkplain dagger.Component component} and call subcomponent factory methods to instantiate
+ *     the correct subcomponent.
+ * </ol>
+ */
+@Documented
+@Target(ElementType.TYPE)
+public @interface GrpcService {
+  /** The class that gRPC generates from the proto service definition. */
+  Class<?> grpcClass();
+}
diff --git a/java/dagger/grpc/server/InProcessServerModule.java b/java/dagger/grpc/server/InProcessServerModule.java
new file mode 100644
index 000000000..fd93382f2
--- /dev/null
+++ b/java/dagger/grpc/server/InProcessServerModule.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import dagger.Module;
+import dagger.Provides;
+import io.grpc.Server;
+import io.grpc.ServerBuilder;
+import io.grpc.inprocess.InProcessServerBuilder;
+import javax.inject.Singleton;
+
+/**
+ * Installing this module into a {@link Singleton @Singleton} component means the component can
+ * provide a {@link Server} that serves {@linkplain InProcessServerBuilder in-process} requests.
+ */
+@Module(includes = ServerModule.class)
+public final class InProcessServerModule {
+
+  private final String name;
+
+  private InProcessServerModule(String name) {
+    this.name = checkNotNull(name);
+  }
+
+  /**
+   * Creates a module that provides a server that binds to a given name
+   *
+   * @param name the identity of the server for clients to connect to
+   */
+  public static InProcessServerModule serverNamed(String name) {
+    return new InProcessServerModule(name);
+  }
+
+  @Provides
+  ServerBuilder<?> serverBuilder() {
+    return InProcessServerBuilder.forName(name);
+  }
+}
diff --git a/java/dagger/grpc/server/NettyServerModule.java b/java/dagger/grpc/server/NettyServerModule.java
new file mode 100644
index 000000000..4361d6229
--- /dev/null
+++ b/java/dagger/grpc/server/NettyServerModule.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import dagger.Module;
+import dagger.Provides;
+import io.grpc.Server;
+import io.grpc.ServerBuilder;
+import io.grpc.netty.NettyServerBuilder;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import javax.inject.Singleton;
+
+/**
+ * Installing this module into a {@link Singleton @Singleton} component means the component can
+ * provide a {@linkplain NettyServerBuilder Netty}-based {@link Server}.
+ */
+@Module(includes = ServerModule.class)
+public final class NettyServerModule {
+
+  private final SocketAddress socketAddress;
+
+  private NettyServerModule(SocketAddress socketAddress) {
+    this.socketAddress = socketAddress;
+  }
+
+  /**
+   * A module that binds to {@code port} on the wildcard address.
+   */
+  public static NettyServerModule bindingToPort(int port) {
+    return new NettyServerModule(new InetSocketAddress(port));
+  }
+
+  /**
+   * A module that binds to {@code socketAddress}.
+   */
+  public static NettyServerModule bindingTo(SocketAddress socketAddress) {
+    return new NettyServerModule(socketAddress);
+  }
+
+  @Provides
+  ServerBuilder<?> serverBuilder() {
+    return NettyServerBuilder.forAddress(socketAddress);
+  }
+}
diff --git a/java/dagger/grpc/server/ProxyServerCallHandler.java b/java/dagger/grpc/server/ProxyServerCallHandler.java
new file mode 100644
index 000000000..751d8cae0
--- /dev/null
+++ b/java/dagger/grpc/server/ProxyServerCallHandler.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import io.grpc.Metadata;
+import io.grpc.MethodDescriptor;
+import io.grpc.MethodDescriptor.Marshaller;
+import io.grpc.ServerCall;
+import io.grpc.ServerCall.Listener;
+import io.grpc.ServerCallHandler;
+import io.grpc.ServerMethodDefinition;
+import io.grpc.ServerServiceDefinition;
+import io.grpc.Status;
+import java.io.InputStream;
+
+/**
+ * A {@link ServerCallHandler} that handles calls for a particular method by delegating to a handler
+ * in a {@link ServerServiceDefinition} returned by a factory.
+ *
+ * @param <RequestT> the type of the request payloads
+ * @param <ResponseT> the type of the response payloads
+ */
+public final class ProxyServerCallHandler<RequestT, ResponseT>
+    implements ServerCallHandler<InputStream, InputStream> {
+
+  /**
+   * A factory for the {@link ServerServiceDefinition} that a {@link ProxyServerCallHandler}
+   * delegates to.
+   */
+  public interface ServiceDefinitionFactory {
+    /**
+     * Returns a service definition that contains a {@link ServerCallHandler} for the
+     * {@link ProxyServerCallHandler}'s method.
+     */
+    ServerServiceDefinition getServiceDefinition(Metadata headers);
+  }
+
+  private final MethodDescriptor<RequestT, ResponseT> delegateMethodDescriptor;
+  private final ServiceDefinitionFactory delegateServiceDefinitionFactory;
+
+  /**
+   * Returns a proxy method definition for {@code methodDescriptor}.
+   *
+   * @param delegateServiceDefinitionFactory factory for the delegate service definition
+   */
+  public static <RequestT, ResponseT> ServerMethodDefinition<InputStream, InputStream> proxyMethod(
+      MethodDescriptor<RequestT, ResponseT> delegateMethodDescriptor,
+      ServiceDefinitionFactory delegateServiceDefinitionFactory) {
+    return ServerMethodDefinition.create(
+        MethodDescriptor.create(
+            delegateMethodDescriptor.getType(),
+            delegateMethodDescriptor.getFullMethodName(),
+            IDENTITY_MARSHALLER,
+            IDENTITY_MARSHALLER),
+        new ProxyServerCallHandler<>(delegateMethodDescriptor, delegateServiceDefinitionFactory));
+  }
+
+  ProxyServerCallHandler(
+      MethodDescriptor<RequestT, ResponseT> delegateMethodDescriptor,
+      ServiceDefinitionFactory delegateServiceDefinitionFactory) {
+    this.delegateMethodDescriptor = delegateMethodDescriptor;
+    this.delegateServiceDefinitionFactory = delegateServiceDefinitionFactory;
+  }
+
+  @Override
+  public Listener<InputStream> startCall(
+      ServerCall<InputStream, InputStream> call,
+      Metadata headers) {
+    ServerMethodDefinition<RequestT, ResponseT> delegateMethod = getMethodDefinition(headers);
+    Listener<RequestT> delegateListener =
+        delegateMethod
+            .getServerCallHandler()
+            .startCall(new ServerCallAdapter(call, delegateMethod.getMethodDescriptor()), headers);
+    return new ServerCallListenerAdapter(delegateListener);
+  }
+
+  @SuppressWarnings("unchecked") // Method definition is the correct type.
+  private ServerMethodDefinition<RequestT, ResponseT> getMethodDefinition(Metadata headers) {
+    String fullMethodName = delegateMethodDescriptor.getFullMethodName();
+    for (ServerMethodDefinition<?, ?> methodDefinition :
+        delegateServiceDefinitionFactory.getServiceDefinition(headers).getMethods()) {
+      if (methodDefinition.getMethodDescriptor().getFullMethodName().equals(fullMethodName)) {
+        return (ServerMethodDefinition<RequestT, ResponseT>) methodDefinition;
+      }
+    }
+    throw new IllegalStateException("Could not find " + fullMethodName);
+  }
+
+  private static final Marshaller<InputStream> IDENTITY_MARSHALLER =
+      new Marshaller<InputStream>() {
+        @Override
+        public InputStream stream(InputStream value) {
+          return value;
+        }
+
+        @Override
+        public InputStream parse(InputStream stream) {
+          return stream;
+        }
+      };
+
+  /** A {@link Listener} that adapts {@code Listener<RequestT>} to {@code Listener<InputStream>}. */
+  private final class ServerCallListenerAdapter extends Listener<InputStream> {
+
+    private final Listener<RequestT> delegate;
+
+    public ServerCallListenerAdapter(Listener<RequestT> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public void onMessage(InputStream message) {
+      delegate.onMessage(delegateMethodDescriptor.parseRequest(message));
+    }
+
+    @Override
+    public void onHalfClose() {
+      delegate.onHalfClose();
+    }
+
+    @Override
+    public void onCancel() {
+      delegate.onCancel();
+    }
+
+    @Override
+    public void onComplete() {
+      delegate.onComplete();
+    }
+  }
+
+  /**
+   * A {@link ServerCall} that adapts {@code ServerCall<InputStream>} to {@code
+   * ServerCall<ResponseT>}.
+   */
+  final class ServerCallAdapter extends ServerCall<RequestT, ResponseT> {
+
+    private final ServerCall<InputStream, InputStream> delegate;
+    private final MethodDescriptor<RequestT, ResponseT> method;
+
+    ServerCallAdapter(ServerCall<InputStream, InputStream> delegate,
+        MethodDescriptor<RequestT, ResponseT> method) {
+      this.delegate = delegate;
+      this.method = method;
+    }
+
+    @Override
+    public MethodDescriptor<RequestT, ResponseT> getMethodDescriptor() {
+      return method;
+    }
+
+    @Override
+    public void request(int numMessages) {
+      delegate.request(numMessages);
+    }
+
+    @Override
+    public void sendHeaders(Metadata headers) {
+      delegate.sendHeaders(headers);
+    }
+
+    @Override
+    public void sendMessage(ResponseT message) {
+      delegate.sendMessage(delegateMethodDescriptor.streamResponse(message));
+    }
+
+    @Override
+    public void close(Status status, Metadata trailers) {
+      delegate.close(status, trailers);
+    }
+
+    @Override
+    public boolean isCancelled() {
+      return delegate.isCancelled();
+    }
+  }
+}
diff --git a/java/dagger/grpc/server/README.md b/java/dagger/grpc/server/README.md
new file mode 100644
index 000000000..ffcfd0d19
--- /dev/null
+++ b/java/dagger/grpc/server/README.md
@@ -0,0 +1,10 @@
+# Dagger-gRPC on the Server
+
+This package contains the public types used to create gRPC server applications
+using google.github.io/dagger.
+
+It is maintained by the Dagger team.
+
+It is in development, and is planned for open-source release as part of Dagger.
+
+See user documentation at google.github.io/dagger-grpc.
diff --git a/java/dagger/grpc/server/ServerModule.java b/java/dagger/grpc/server/ServerModule.java
new file mode 100644
index 000000000..f03f99797
--- /dev/null
+++ b/java/dagger/grpc/server/ServerModule.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import dagger.Module;
+import dagger.Provides;
+import io.grpc.Server;
+import io.grpc.ServerBuilder;
+import io.grpc.ServerServiceDefinition;
+import java.util.Set;
+import javax.inject.Singleton;
+
+/**
+ * Provides a {@link Singleton @Singleton} {@link Server}.
+ */
+@Module
+public final class ServerModule {
+
+  @Provides
+  @Singleton
+  static Server provideServer(
+      ServerBuilder<?> serverBuilder, Set<ServerServiceDefinition> serviceDefinitions) {
+    for (ServerServiceDefinition serverServiceDefinition : serviceDefinitions) {
+      serverBuilder.addService(serverServiceDefinition);
+    }
+    return serverBuilder.build();
+  }
+}
diff --git a/java/dagger/grpc/server/processor/BUILD b/java/dagger/grpc/server/processor/BUILD
new file mode 100644
index 000000000..7220f851a
--- /dev/null
+++ b/java/dagger/grpc/server/processor/BUILD
@@ -0,0 +1,39 @@
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+
+java_library(
+    name = "processor",
+    srcs = glob(["*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//:dagger_with_compiler",
+        "//java/dagger/grpc/server:annotations",
+        "//third_party:auto_common",
+        "//third_party:auto_service",
+        "//third_party:google_java_format",
+        "//third_party:guava",
+        "//third_party:javapoet",
+    ],
+)
+
+java_plugin(
+    name = "plugin",
+    generates_api = 1,
+    processor_class = "dagger.grpc.server.processor.GrpcServiceProcessor",
+    deps = [":processor"],
+)
+
+filegroup(
+    name = "javadoc-srcs",
+    srcs = glob(["*.java"]),
+)
+
+load("//tools:javadoc.bzl", "javadoc_library")
+
+javadoc_library(
+    name = "javadoc",
+    srcs = [":javadoc-srcs"],
+    root_packages = ["dagger.grpc.server.processor"],
+    deps = [":processor"],
+)
diff --git a/java/dagger/grpc/server/processor/GrpcServiceModel.java b/java/dagger/grpc/server/processor/GrpcServiceModel.java
new file mode 100644
index 000000000..5188b61a1
--- /dev/null
+++ b/java/dagger/grpc/server/processor/GrpcServiceModel.java
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import dagger.grpc.server.ForGrpcService;
+import dagger.grpc.server.GrpcService;
+import dagger.grpc.server.processor.SourceGenerator.IoGrpc;
+import javax.annotation.Generated;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleAnnotationValueVisitor7;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
+
+class GrpcServiceModel {
+
+  private static final String GRPC_SERVICE_PARAMETER_NAME = "grpcClass";
+
+  private final Types types;
+  private final Elements elements;
+  private final Messager messager;
+  final TypeElement serviceImplementation;
+  final ClassName serviceImplementationClassName;
+  final ClassName serviceDefinitionTypeName;
+  final ClassName proxyModuleName;
+  final ClassName serviceDefinitionTypeFactoryName;
+  final ClassName serviceModuleName;
+  final ClassName unscopedServiceModuleName;
+
+  GrpcServiceModel(ProcessingEnvironment processingEnv, TypeElement serviceImplementation) {
+    this.types = processingEnv.getTypeUtils();
+    this.elements = processingEnv.getElementUtils();
+    this.messager = processingEnv.getMessager();
+    this.serviceImplementation = serviceImplementation;
+    this.serviceImplementationClassName = ClassName.get(serviceImplementation);
+    this.serviceDefinitionTypeName = peerClassWithSuffix("ServiceDefinition");
+    this.serviceDefinitionTypeFactoryName = serviceDefinitionTypeName.nestedClass("Factory");
+    this.proxyModuleName = peerClassWithSuffix("GrpcProxyModule");
+    this.serviceModuleName = peerClassWithSuffix("GrpcServiceModule");
+    this.unscopedServiceModuleName = peerClassWithSuffix("UnscopedGrpcServiceModule");
+  }
+
+  /**
+   * Returns the name of a top-level class in the same package as the service implementation
+   * class, whose name is the simple name of the service implementation class and its enclosing
+   * classes, joined with underscores, and appended with {@code suffix}.
+   */
+  private ClassName peerClassWithSuffix(String suffix) {
+    return serviceImplementationClassName.peerClass(
+        Joiner.on('_').join(serviceImplementationClassName.simpleNames()) + suffix);
+  }
+
+  String packageName() {
+    return serviceImplementationClassName.packageName();
+  }
+
+  public boolean validate() {
+    AnnotationValue argument =
+        getAnnotationValue(grpcServiceAnnotation(), GRPC_SERVICE_PARAMETER_NAME);
+    return argument.accept(
+        new SimpleAnnotationValueVisitor7<Boolean, AnnotationValue>(false) {
+          @Override
+          public Boolean visitType(TypeMirror type, AnnotationValue value) {
+            return validateGrpcClass(type, value);
+          }
+        },
+        argument);
+  }
+
+  private AnnotationMirror grpcServiceAnnotation() {
+    return getAnnotationMirror(serviceImplementation, GrpcService.class).get();
+  }
+
+  /** Returns the gRPC service class declared by {@link GrpcService#grpcClass()}. */
+  protected final TypeElement grpcClass() {
+    AnnotationValue argument =
+        getAnnotationValue(grpcServiceAnnotation(), GRPC_SERVICE_PARAMETER_NAME);
+    return GET_TYPE_ELEMENT_FROM_VALUE.visit(argument, argument);
+  }
+
+  /**
+   * Returns the annotation spec for the {@link Generated @Generated} annotation to add to any
+   * type generated by this processor.
+   */
+  protected final AnnotationSpec generatedAnnotation() {
+    return AnnotationSpec.builder(Generated.class)
+        .addMember(
+            "value",
+            "$S",
+            String.format(
+                "@%s annotation on %s",
+                GrpcService.class.getCanonicalName(), serviceImplementationClassName))
+        .build();
+  }
+
+  /**
+   * Returns the annotation spec for a {@link ForGrpcService} annotation whose value is the
+   * gRPC-generated service class.
+   */
+  protected final AnnotationSpec forGrpcService() {
+    return AnnotationSpec.builder(ForGrpcService.class)
+        .addMember("value", "$T.class", grpcClass())
+        .build();
+  }
+
+  protected final String subcomponentServiceDefinitionMethodName() {
+    return UPPER_CAMEL.to(LOWER_CAMEL, simpleServiceName()) + "ServiceDefinition";
+  }
+
+  private String simpleServiceName() {
+    return grpcClass().getSimpleName().toString().replaceFirst("Grpc$", "");
+  }
+
+  private TypeElement serviceImplBase(TypeMirror service) {
+    ClassName serviceClassName = ClassName.get(MoreTypes.asTypeElement(service));
+    ClassName serviceImplBaseName = serviceClassName.nestedClass(simpleServiceName() + "ImplBase");
+    return elements.getTypeElement(serviceImplBaseName.toString());
+  }
+
+  private boolean validateGrpcClass(TypeMirror type, AnnotationValue value) {
+    TypeElement serviceImplBase = serviceImplBase(type);
+    if (serviceImplBase == null || !types.isSubtype(serviceImplBase.asType(), bindableService())) {
+      messager.printMessage(
+          Kind.ERROR,
+          String.format("%s is not a gRPC service class", type),
+          serviceImplementation,
+          grpcServiceAnnotation(),
+          value);
+      return false;
+    }
+    if (!(types.isSubtype(serviceImplementation.asType(), serviceImplBase.asType()))) {
+      messager.printMessage(
+          Kind.ERROR,
+          String.format(
+              "%s must extend %s", serviceImplementation, serviceImplBase.getQualifiedName()),
+          serviceImplementation,
+          grpcServiceAnnotation(),
+          value);
+      return false;
+    }
+    return true;
+  }
+
+  private TypeMirror bindableService() {
+    return elements.getTypeElement(IoGrpc.BINDABLE_SERVICE.toString()).asType();
+  }
+
+  static final AnnotationValueVisitor<TypeElement, AnnotationValue> GET_TYPE_ELEMENT_FROM_VALUE =
+      new SimpleAnnotationValueVisitor7<TypeElement, AnnotationValue>() {
+        @Override
+        public TypeElement visitType(TypeMirror t, AnnotationValue p) {
+          return MoreTypes.asTypeElement(t);
+        }
+
+        @Override
+        protected TypeElement defaultAction(Object o, AnnotationValue p) {
+          throw new IllegalArgumentException("Expected " + p + " to be a class");
+        }
+      };
+}
diff --git a/java/dagger/grpc/server/processor/GrpcServiceModuleGenerator.java b/java/dagger/grpc/server/processor/GrpcServiceModuleGenerator.java
new file mode 100644
index 000000000..ab8bcafc9
--- /dev/null
+++ b/java/dagger/grpc/server/processor/GrpcServiceModuleGenerator.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static com.squareup.javapoet.WildcardTypeName.subtypeOf;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.grpc.server.GrpcService;
+import java.util.List;
+
+/**
+ * An object that generates the non-proxying service definition module for a {@link
+ * GrpcService}-annotated service implementation.
+ */
+final class GrpcServiceModuleGenerator extends SourceGenerator {
+
+  private static final TypeName LIST_OF_INTERCEPTORS = ParameterizedTypeName.get(
+      ClassName.get(List.class), subtypeOf(IoGrpc.SERVER_INTERCEPTOR));
+  
+  private final GrpcServiceModel grpcServiceModel;
+
+  GrpcServiceModuleGenerator(GrpcServiceModel grpcServiceModel) {
+    super(grpcServiceModel.packageName());
+    this.grpcServiceModel = grpcServiceModel;
+  }
+
+  @Override
+  protected TypeSpec createType() {
+    return classBuilder(grpcServiceModel.serviceModuleName)
+        .addJavadoc(
+            "Install this module in the {@link $T @Singleton} server component\n",
+            JavaxInject.singleton().type)
+        .addJavadoc(
+            "or in the subcomponent that implements {@link $T}.\n",
+            grpcServiceModel.serviceDefinitionTypeName)
+        .addAnnotation(grpcServiceModel.generatedAnnotation())
+        .addAnnotation(Dagger.module())
+        .addModifiers(PUBLIC, FINAL)
+        .addMethod(provideServiceDefinition())
+        .build();
+  }
+
+  /**
+   * Returns the {@link dagger.Provides @Provides} method for the {@link
+   * io.grpc.ServerServiceDefinition} for the service.
+   */
+  private MethodSpec provideServiceDefinition() {
+    return methodBuilder("serviceDefinition")
+        .addAnnotation(Dagger.provides())
+        .addAnnotation(grpcServiceModel.forGrpcService())
+        .addModifiers(STATIC)
+        .returns(IoGrpc.SERVER_SERVICE_DEFINITION)
+        .addParameter(grpcServiceModel.serviceImplementationClassName, "implementation")
+        .addParameter(
+            ParameterSpec.builder(LIST_OF_INTERCEPTORS, "interceptors")
+                .addAnnotation(grpcServiceModel.forGrpcService())
+                .build())
+        .addStatement(
+            "$T serviceDefinition = implementation.bindService()", IoGrpc.SERVER_SERVICE_DEFINITION)
+        .addStatement(
+            "return $T.intercept(serviceDefinition, interceptors)", IoGrpc.SERVER_INTERCEPTORS)
+        .build();
+  }
+}
diff --git a/java/dagger/grpc/server/processor/GrpcServiceProcessor.java b/java/dagger/grpc/server/processor/GrpcServiceProcessor.java
new file mode 100644
index 000000000..917d99365
--- /dev/null
+++ b/java/dagger/grpc/server/processor/GrpcServiceProcessor.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import com.google.googlejavaformat.java.filer.FormattingFiler;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.JavaFile;
+import dagger.grpc.server.GrpcService;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Processor;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.tools.Diagnostic.Kind;
+
+/**
+ * Generates code from types annotated with {@link GrpcService @GrpcService}.
+ *
+ * @see <a href="google.github.io/dagger-grpc">google.github.io/dagger-grpc</a>
+ */
+@AutoService(Processor.class)
+public class GrpcServiceProcessor extends BasicAnnotationProcessor implements ProcessingStep {
+
+  @Override
+  protected ImmutableList<GrpcServiceProcessor> initSteps() {
+    return ImmutableList.of(this);
+  }
+
+  @Override
+  public ImmutableSet<Class<GrpcService>> annotations() {
+    return ImmutableSet.of(GrpcService.class);
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latest();
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (TypeElement element : typesIn(elementsByAnnotation.get(GrpcService.class))) {
+      GrpcServiceModel grpcServiceModel = new GrpcServiceModel(processingEnv, element);
+      if (grpcServiceModel.validate()) {
+        write(new ServiceDefinitionTypeGenerator(grpcServiceModel), element);
+        write(new ProxyModuleGenerator(grpcServiceModel), element);
+        write(new GrpcServiceModuleGenerator(grpcServiceModel), element);
+        write(new UnscopedGrpcServiceModuleGenerator(grpcServiceModel), element);
+      }
+    }
+    return ImmutableSet.of();
+  }
+
+  private void write(SourceGenerator grpcServiceTypeWriter, final TypeElement element) {
+    JavaFile javaFile = grpcServiceTypeWriter.javaFile();
+    ClassName outputClassName = ClassName.get(javaFile.packageName, javaFile.typeSpec.name);
+    try {
+      javaFile.writeTo(new FormattingFiler(processingEnv.getFiler()));
+    } catch (IOException e) {
+      processingEnv
+          .getMessager()
+          .printMessage(
+              Kind.ERROR, String.format("Error writing %s: %s", outputClassName, e), element);
+    }
+  }
+}
diff --git a/java/dagger/grpc/server/processor/ProxyModuleGenerator.java b/java/dagger/grpc/server/processor/ProxyModuleGenerator.java
new file mode 100644
index 000000000..68fb6ce46
--- /dev/null
+++ b/java/dagger/grpc/server/processor/ProxyModuleGenerator.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import static com.google.auto.common.MoreElements.hasModifiers;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.fieldsIn;
+
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.grpc.server.GrpcService;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * An object that generates the proxying service definition module for a {@link
+ * GrpcService}-annotated service implementation.
+ */
+final class ProxyModuleGenerator extends SourceGenerator {
+
+  private final GrpcServiceModel grpcServiceModel;
+
+  ProxyModuleGenerator(GrpcServiceModel grpcServiceModel) {
+    super(grpcServiceModel.packageName());
+    this.grpcServiceModel = grpcServiceModel;
+  }
+
+  @Override
+  protected TypeSpec createType() {
+    return classBuilder(grpcServiceModel.proxyModuleName)
+        .addModifiers(PUBLIC, FINAL)
+        .addJavadoc(
+            "Install this module in the {@link $T @Singleton} server component.\n",
+            JavaxInject.singleton().type)
+        .addAnnotation(grpcServiceModel.generatedAnnotation())
+        .addAnnotation(Dagger.module())
+        .addMethod(provideServiceDefinitionContribution())
+        .addMethod(provideServiceDefinitionFactory())
+        .build();
+  }
+
+  /**
+   * Returns the {@link dagger.Provides @Provides} method for the proxying {@link
+   * io.grpc.ServerServiceDefinition}.
+   */
+  private MethodSpec provideServiceDefinitionContribution() {
+    MethodSpec.Builder method =
+        methodBuilder("serviceDefinition")
+            .addAnnotation(Dagger.provides())
+            .addAnnotation(Dagger.intoSet())
+            .addAnnotation(JavaxInject.singleton())
+            .addModifiers(STATIC)
+            .returns(IoGrpc.SERVER_SERVICE_DEFINITION)
+            .addParameter(
+                ParameterSpec.builder(
+                        Dagger.GrpcServer.SERVICE_DEFINITION_FACTORY, "serviceDefinitionFactory")
+                    .addAnnotation(grpcServiceModel.forGrpcService())
+                    .build())
+            .addCode(
+                "return $T.builder($T.SERVICE_NAME)",
+                IoGrpc.SERVER_SERVICE_DEFINITION,
+                grpcServiceModel.grpcClass());
+    for (VariableElement methodDescriptorField : methodDescriptorFields()) {
+      method.addCode(
+          ".addMethod($T.proxyMethod($T.$N, serviceDefinitionFactory))",
+          Dagger.GrpcServer.PROXY_SERVER_CALL_HANDLER,
+          grpcServiceModel.grpcClass(),
+          methodDescriptorField.getSimpleName());
+    }
+    method.addCode(".build();");
+    return method.build();
+  }
+
+  /**
+   * Returns he {@link io.grpc.MethodDescriptor} {@code *_METHOD} fields on the class enclosing the
+   * service interface.
+   */
+  private FluentIterable<VariableElement> methodDescriptorFields() {
+    return FluentIterable.from(fieldsIn(grpcServiceModel.grpcClass().getEnclosedElements()))
+        .filter(hasModifiers(PUBLIC, STATIC))
+        .filter(
+            new Predicate<VariableElement>() {
+              @Override
+              public boolean apply(VariableElement element) {
+                TypeName typeName = TypeName.get(element.asType());
+                return typeName instanceof ParameterizedTypeName
+                    && ((ParameterizedTypeName) typeName).rawType.equals(IoGrpc.METHOD_DESCRIPTOR);
+              }
+            });
+  }
+
+  /**
+   * Returns the {@link dagger.Provides @Provides} method for the {@link
+   * dagger.grpc.server.ProxyServerCallHandler.ServiceDefinitionFactory} used by the proxy.
+   */
+  private MethodSpec provideServiceDefinitionFactory() {
+    return methodBuilder("serviceDefinitionFactory")
+        .addAnnotation(Dagger.provides())
+        .addAnnotation(grpcServiceModel.forGrpcService())
+        .addModifiers(STATIC)
+        .returns(Dagger.GrpcServer.SERVICE_DEFINITION_FACTORY)
+        .addParameter(grpcServiceModel.serviceDefinitionTypeFactoryName, "factory", FINAL)
+        .addStatement("return $L", anonymousServiceDefinitionFactory())
+        .build();
+  }
+
+  /**
+   * Returns the anonymous inner class that implements the {@link
+   * dagger.grpc.server.ProxyServerCallHandler.ServiceDefinitionFactory} used by the proxy.
+   */
+  private TypeSpec anonymousServiceDefinitionFactory() {
+    return anonymousClassBuilder("")
+        .addSuperinterface(Dagger.GrpcServer.SERVICE_DEFINITION_FACTORY)
+        .addMethod(
+            methodBuilder("getServiceDefinition")
+                .addAnnotation(Override.class)
+                .addModifiers(PUBLIC)
+                .returns(IoGrpc.SERVER_SERVICE_DEFINITION)
+                .addParameter(IoGrpc.METADATA, "headers")
+                .addStatement(
+                    "return factory.grpcService(new $T(headers)).$N()",
+                    Dagger.GrpcServer.GRPC_CALL_METADATA_MODULE,
+                    grpcServiceModel.subcomponentServiceDefinitionMethodName())
+                .build())
+        .build();
+  }
+}
diff --git a/java/dagger/grpc/server/processor/ServiceDefinitionTypeGenerator.java b/java/dagger/grpc/server/processor/ServiceDefinitionTypeGenerator.java
new file mode 100644
index 000000000..5d5ccbd98
--- /dev/null
+++ b/java/dagger/grpc/server/processor/ServiceDefinitionTypeGenerator.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.interfaceBuilder;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.squareup.javapoet.TypeSpec;
+import dagger.grpc.server.GrpcService;
+
+/**
+ * An object that generates the component supertype interface for a {@link GrpcService}-annotated
+ * service implementation.
+ */
+final class ServiceDefinitionTypeGenerator extends SourceGenerator {
+
+  private final GrpcServiceModel grpcServiceModel;
+
+  ServiceDefinitionTypeGenerator(GrpcServiceModel grpcServiceModel) {
+    super(grpcServiceModel.packageName());
+    this.grpcServiceModel = grpcServiceModel;
+  }
+
+  @Override
+  protected TypeSpec createType() {
+    TypeSpec.Builder type =
+        interfaceBuilder(grpcServiceModel.serviceDefinitionTypeName.simpleName())
+            .addJavadoc("A component must implement this interface.\n")
+            .addAnnotation(grpcServiceModel.generatedAnnotation())
+            .addModifiers(PUBLIC);
+    type.addType(
+        interfaceBuilder(grpcServiceModel.serviceDefinitionTypeFactoryName.simpleName())
+            .addModifiers(PUBLIC, STATIC)
+            .addMethod(
+                methodBuilder("grpcService")
+                    .addModifiers(PUBLIC, ABSTRACT)
+                    .returns(grpcServiceModel.serviceDefinitionTypeName)
+                    .addParameter(
+                        Dagger.GrpcServer.GRPC_CALL_METADATA_MODULE, "grpcCallMetadataModule")
+                    .build())
+            .build());
+    type.addMethod(
+        methodBuilder(grpcServiceModel.subcomponentServiceDefinitionMethodName())
+            .addModifiers(PUBLIC, ABSTRACT)
+            .returns(IoGrpc.SERVER_SERVICE_DEFINITION)
+            .addAnnotation(grpcServiceModel.forGrpcService())
+            .build());
+    return type.build();
+  }
+}
diff --git a/java/dagger/grpc/server/processor/SourceGenerator.java b/java/dagger/grpc/server/processor/SourceGenerator.java
new file mode 100644
index 000000000..806d6e6f1
--- /dev/null
+++ b/java/dagger/grpc/server/processor/SourceGenerator.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.TypeSpec;
+
+/**
+ * An object that generates one top-level type.
+ */
+abstract class SourceGenerator {
+
+  private final String packageName;
+
+  protected SourceGenerator(String packageName) {
+    this.packageName = packageName;
+  }
+
+  public JavaFile javaFile() {
+    return JavaFile.builder(packageName, createType()).build();
+  }
+
+  /**
+   * Creates the type to write.
+   */
+  protected abstract TypeSpec createType();
+
+  /** Class names and annotation specs for types in the {@link dagger} package. */
+  protected static final class Dagger {
+    private Dagger() {}
+
+    static AnnotationSpec binds() {
+      return AnnotationSpec.builder(ClassName.get("dagger", "Binds")).build();
+    }
+
+    static AnnotationSpec intoSet() {
+      return AnnotationSpec.builder(ClassName.get("dagger.multibindings", "IntoSet")).build();
+    }
+
+    static AnnotationSpec provides() {
+      return AnnotationSpec.builder(ClassName.get("dagger", "Provides")).build();
+    }
+
+    /** A {@code @dagger.Module} annotation that includes the given module classes. */
+    static AnnotationSpec module(ClassName... includedModules) {
+      AnnotationSpec.Builder module = AnnotationSpec.builder(ClassName.get("dagger", "Module"));
+      for (ClassName includedModule : includedModules) {
+        module.addMember("includes", "$T.class", includedModule);
+      }
+      return module.build();
+    }
+
+    /** Class names and annotation specs for types in the {@link dagger.grpc} package. */
+    protected static final class GrpcServer {
+      private GrpcServer() {}
+
+      static final ClassName PROXY_SERVER_CALL_HANDLER =
+          ClassName.get("dagger.grpc.server", "ProxyServerCallHandler");
+
+      static final ClassName GRPC_CALL_METADATA_MODULE =
+          ClassName.get("dagger.grpc.server", "GrpcCallMetadataModule");
+
+      static final ClassName SERVICE_DEFINITION_FACTORY =
+          PROXY_SERVER_CALL_HANDLER.nestedClass("ServiceDefinitionFactory");
+    }
+  }
+
+  /** Class names and annotation specs for types in the {@link io.grpc} package. */
+  protected static final class IoGrpc {
+    private IoGrpc() {}
+
+    static final ClassName BINDABLE_SERVICE = ClassName.get("io.grpc", "BindableService");
+    static final ClassName METADATA = ClassName.get("io.grpc", "Metadata");
+    static final ClassName METHOD_DESCRIPTOR = ClassName.get("io.grpc", "MethodDescriptor");
+    static final ClassName SERVER_INTERCEPTOR =
+        ClassName.get("io.grpc", "ServerInterceptor");
+    static final ClassName SERVER_INTERCEPTORS =
+        ClassName.get("io.grpc", "ServerInterceptors");
+    static final ClassName SERVER_SERVICE_DEFINITION =
+        ClassName.get("io.grpc", "ServerServiceDefinition");
+  }
+
+  /** Class names and annotation specs for types in the {@link javax.inject} package. */
+  protected static final class JavaxInject {
+    private JavaxInject() {}
+
+    static AnnotationSpec inject() {
+      return AnnotationSpec.builder(ClassName.get("javax.inject", "Inject")).build();
+    }
+
+    static AnnotationSpec singleton() {
+      return AnnotationSpec.builder(ClassName.get("javax.inject", "Singleton")).build();
+    }
+  }
+}
diff --git a/java/dagger/grpc/server/processor/UnscopedGrpcServiceModuleGenerator.java b/java/dagger/grpc/server/processor/UnscopedGrpcServiceModuleGenerator.java
new file mode 100644
index 000000000..12f93e459
--- /dev/null
+++ b/java/dagger/grpc/server/processor/UnscopedGrpcServiceModuleGenerator.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+import dagger.grpc.server.GrpcService;
+
+/**
+ * An object that generates the unscoped-proxying service definition module for a {@link
+ * GrpcService}-annotated service implementation.
+ */
+final class UnscopedGrpcServiceModuleGenerator extends SourceGenerator {
+
+  private final GrpcServiceModel grpcServiceModel;
+
+  UnscopedGrpcServiceModuleGenerator(GrpcServiceModel grpcServiceModel) {
+    super(grpcServiceModel.packageName());
+    this.grpcServiceModel = grpcServiceModel;
+  }
+
+  @Override
+  protected TypeSpec createType() {
+    ClassName unscopedComponentFactory =
+        grpcServiceModel.unscopedServiceModuleName.nestedClass(
+            grpcServiceModel.serviceImplementationClassName.simpleName() + "ComponentFactory");
+    return classBuilder(grpcServiceModel.unscopedServiceModuleName)
+        .addJavadoc(
+            "Install this module in the {@link $T @Singleton} server component\n",
+            JavaxInject.singleton().type)
+        .addJavadoc("if it implements {@link $T}.\n", grpcServiceModel.serviceDefinitionTypeName)
+        .addAnnotation(grpcServiceModel.generatedAnnotation())
+        .addAnnotation(
+            Dagger.module(grpcServiceModel.proxyModuleName, grpcServiceModel.serviceModuleName))
+        .addModifiers(PUBLIC, ABSTRACT)
+        .addType(unscopedComponentFactory(unscopedComponentFactory.simpleName()))
+        .addMethod(bindSubcomponentFactory(unscopedComponentFactory))
+        .addMethod(constructorBuilder().addModifiers(PRIVATE).build())
+        .build();
+  }
+  
+  /**
+   * Returns the class that implements the component factory type by returning the singleton
+   * component itself.
+   */
+  private TypeSpec unscopedComponentFactory(String simpleName) {
+    return TypeSpec.classBuilder(simpleName)
+        .addModifiers(STATIC, FINAL)
+        .addSuperinterface(grpcServiceModel.serviceDefinitionTypeFactoryName)
+        .addField(grpcServiceModel.serviceDefinitionTypeName, "component", PRIVATE, FINAL)
+        .addMethod(
+            MethodSpec.constructorBuilder()
+                .addAnnotation(JavaxInject.inject())
+                .addParameter(grpcServiceModel.serviceDefinitionTypeName, "component")
+                .addStatement("this.component = component")
+                .build())
+        .addMethod(
+            MethodSpec.methodBuilder("grpcService")
+                .addAnnotation(Override.class)
+                .addModifiers(PUBLIC)
+                .returns(grpcServiceModel.serviceDefinitionTypeName)
+                .addParameter(Dagger.GrpcServer.GRPC_CALL_METADATA_MODULE, "grpcCallMetadataModule")
+                .addStatement("return component")
+                .build())
+        .build();
+  }
+
+  /**
+   * Returns the {@link dagger.Binds @Binds} method that binds the component factory type to the
+   * {@linkplain #unscopedComponentFactory(String) unscoped component factory implementation class}.
+   */
+  private MethodSpec bindSubcomponentFactory(ClassName unscopedComponentFactory) {
+    return MethodSpec.methodBuilder(
+            UPPER_CAMEL.to(
+                LOWER_CAMEL, grpcServiceModel.serviceDefinitionTypeFactoryName.simpleName()))
+        .addAnnotation(Dagger.binds())
+        .addModifiers(ABSTRACT)
+        .returns(grpcServiceModel.serviceDefinitionTypeFactoryName)
+        .addParameter(unscopedComponentFactory, "factory")
+        .build();
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/BUILD b/javatests/dagger/grpc/functional/server/BUILD
new file mode 100644
index 000000000..1e8c2e6e8
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/BUILD
@@ -0,0 +1,19 @@
+# Functional tests for Dagger-gRPC
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
+load("//:test_defs.bzl", "GenJavaTests")
+
+# TODO(dpb): enable tests once java_grpc_library is ready in bazel:
+# https://github.com/grpc/grpc-java/issues/2756
+
+java_proto_library(
+    name = "coffee_service_java_proto",
+    deps = [":protos"],
+)
+
+proto_library(
+    name = "protos",
+    srcs = glob(["*.proto"]),
+)
diff --git a/javatests/dagger/grpc/functional/server/BaristaTest.java b/javatests/dagger/grpc/functional/server/BaristaTest.java
new file mode 100644
index 000000000..d6c5b429c
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/BaristaTest.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.util.concurrent.Futures.getUnchecked;
+import static com.google.protos.test.CoffeeService.CoffeeType.AMERICANO;
+import static com.google.protos.test.CoffeeService.CoffeeType.DRIP;
+import static com.google.protos.test.CoffeeService.CoffeeType.ESPRESSO;
+import static com.google.protos.test.CoffeeService.CoffeeType.LATTE;
+import static com.google.protos.test.CoffeeService.CoffeeType.POUR_OVER;
+import static java.util.Arrays.asList;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.SettableFuture;
+import com.google.protos.test.BaristaGrpc;
+import com.google.protos.test.BaristaGrpc.BaristaStub;
+import com.google.protos.test.CoffeeService.CoffeeRequest;
+import com.google.protos.test.CoffeeService.CoffeeResponse;
+import com.google.protos.test.CoffeeService.CoffeeType;
+import io.grpc.inprocess.InProcessChannelBuilder;
+import io.grpc.stub.StreamObserver;
+import java.util.ArrayList;
+import java.util.List;
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class BaristaTest {
+
+  private static final class CoffeeResponseObserver implements StreamObserver<CoffeeResponse> {
+    private final SettableFuture<Void> completion = SettableFuture.create();
+    private final List<CoffeeResponse> responses = new ArrayList<>();
+
+    List<CoffeeResponse> responses() {
+      getUnchecked(completion);
+      return responses;
+    }
+
+    @Override
+    public void onNext(CoffeeResponse value) {
+      responses.add(value);
+    }
+
+    @Override
+    public void onError(Throwable t) {
+      completion.setException(t);
+    }
+
+    @Override
+    public void onCompleted() {
+      completion.set(null);
+    }
+  }
+
+  @ClassRule
+  public static CoffeeServerResource coffeeServerWithCallScope =
+      new CoffeeServerResource("CallScope", DaggerCoffeeServerWithCallScopeService.builder());
+
+  @ClassRule
+  public static CoffeeServerResource coffeeServerWithSingletonScope =
+      new CoffeeServerResource("Unscoped", DaggerCoffeeServerWithUnscopedService.builder());
+
+  @Parameters(name = "{0}")
+  public static Iterable<Object[]> coffeeServers() {
+    return ImmutableList.copyOf(
+        new Object[][] {{coffeeServerWithCallScope}, {coffeeServerWithSingletonScope}});
+  }
+
+  @Rule public final VerifyInterceptor verifyCount;
+  private final CoffeeServerResource coffeeServer;
+  private final CoffeeResponseObserver responseObserver = new CoffeeResponseObserver();
+
+  private BaristaStub barista;
+
+  public BaristaTest(CoffeeServerResource coffeeServer) {
+    this.coffeeServer = coffeeServer;
+    this.verifyCount = new VerifyInterceptor(coffeeServer);
+  }
+
+  @Before
+  public void setUp() {
+    barista = BaristaGrpc.newStub(InProcessChannelBuilder.forName(coffeeServer.name()).build());
+  }
+
+  @Test
+  public void testUnaryGetCoffee() {
+    barista.unaryGetCoffee(request(POUR_OVER, LATTE), responseObserver);
+    assertThat(responseObserver.responses())
+        .containsExactly(response("Here you go!", POUR_OVER, LATTE));
+  }
+
+  @Test
+  public void testClientStreamingGetCoffee() {
+    StreamObserver<CoffeeRequest> requestObserver =
+        barista.clientStreamingGetCoffee(responseObserver);
+    requestObserver.onNext(request(POUR_OVER, LATTE));
+    requestObserver.onNext(request(AMERICANO));
+    requestObserver.onNext(request(DRIP, ESPRESSO));
+    requestObserver.onCompleted();
+    assertThat(responseObserver.responses())
+        .containsExactly(response("All yours!", POUR_OVER, LATTE, AMERICANO, DRIP, ESPRESSO));
+  }
+
+  @Test
+  public void testServerStreamingGetCoffee() {
+    barista.serverStreamingGetCoffee(request(DRIP, AMERICANO), responseObserver);
+    assertThat(responseObserver.responses())
+        .containsExactly(
+            response("Here's a DRIP", DRIP), response("Here's a AMERICANO", AMERICANO));
+  }
+
+  @Test
+  public void testBidiStreamingGetCoffee() {
+    StreamObserver<CoffeeRequest> requestObserver =
+        barista.bidiStreamingGetCoffee(responseObserver);
+    requestObserver.onNext(request(POUR_OVER, LATTE));
+    requestObserver.onNext(request(AMERICANO));
+    requestObserver.onNext(request(DRIP, ESPRESSO));
+    requestObserver.onCompleted();
+    assertThat(responseObserver.responses())
+        .containsExactly(
+            response("Enjoy!", POUR_OVER, LATTE),
+            response("Enjoy!", AMERICANO),
+            response("Enjoy!", DRIP, ESPRESSO));
+  }
+
+  private CoffeeRequest request(CoffeeType... types) {
+    return CoffeeRequest.newBuilder().addAllType(asList(types)).build();
+  }
+
+  private CoffeeResponse response(String message, CoffeeType... types) {
+    return CoffeeResponse.newBuilder().setMessage(message).addAllCup(asList(types)).build();
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/CoffeeServer.java b/javatests/dagger/grpc/functional/server/CoffeeServer.java
new file mode 100644
index 000000000..10a0fd225
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/CoffeeServer.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import dagger.grpc.server.InProcessServerModule;
+import io.grpc.Server;
+import java.io.IOException;
+
+abstract class CoffeeServer<T extends CoffeeServer<T>> {
+  protected abstract Server server();
+
+  public void start() throws IOException {
+    server().start();
+  }
+
+  public void shutdown() {
+    server().shutdownNow();
+  }
+
+  abstract CountingInterceptor countingInterceptor();
+
+  interface Builder<T extends CoffeeServer<T>> {
+    Builder<T> inProcessServerModule(InProcessServerModule serverModule);
+
+    T build();
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/CoffeeServerResource.java b/javatests/dagger/grpc/functional/server/CoffeeServerResource.java
new file mode 100644
index 000000000..dc449fb16
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/CoffeeServerResource.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import dagger.grpc.server.InProcessServerModule;
+import java.io.IOException;
+import org.junit.rules.ExternalResource;
+
+final class CoffeeServerResource extends ExternalResource {
+  private final String name;
+  private final CoffeeServer<?> coffeeServer;
+
+  CoffeeServerResource(String name, CoffeeServer.Builder<?> coffeeServerBuilder) {
+    this.name = name;
+    this.coffeeServer =
+        coffeeServerBuilder.inProcessServerModule(InProcessServerModule.serverNamed(name)).build();
+  }
+
+  public String name() {
+    return name;
+  }
+
+  public int methodCount(String methodName) {
+    return coffeeServer.countingInterceptor().countCalls(methodName);
+  }
+
+  @Override
+  protected void before() throws IOException, InterruptedException {
+    coffeeServer.start();
+  }
+
+  @Override
+  protected void after() {
+    coffeeServer.shutdown();
+  }
+
+  @Override
+  public String toString() {
+    return name;
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/CoffeeServerWithCallScopeService.java b/javatests/dagger/grpc/functional/server/CoffeeServerWithCallScopeService.java
new file mode 100644
index 000000000..5fb06b64d
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/CoffeeServerWithCallScopeService.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.grpc.functional.server.CoffeeServerWithCallScopeService.CallScopeServiceModule;
+import dagger.grpc.functional.server.CountingInterceptor.CountingInterceptorModule;
+import dagger.grpc.server.CallScoped;
+import dagger.grpc.server.GrpcCallMetadataModule;
+import dagger.grpc.server.InProcessServerModule;
+import javax.inject.Singleton;
+
+@Singleton
+@Component(modules = {InProcessServerModule.class, CallScopeServiceModule.class})
+abstract class CoffeeServerWithCallScopeService
+    extends CoffeeServer<CoffeeServerWithCallScopeService> {
+
+  @Component.Builder
+  interface Builder extends CoffeeServer.Builder<CoffeeServerWithCallScopeService> {}
+
+  abstract BaristaCallScope baristaCallScope(GrpcCallMetadataModule callMetadataModule);
+
+  @CallScoped
+  @Subcomponent(
+    modules = {
+      GrpcCallMetadataModule.class,
+      FriendlyBaristaGrpcServiceModule.class,
+      CountingInterceptorModule.class
+    }
+  )
+  interface BaristaCallScope extends FriendlyBaristaServiceDefinition {}
+
+  @Module(includes = FriendlyBaristaGrpcProxyModule.class)
+  static class CallScopeServiceModule {
+    @Provides
+    static FriendlyBaristaServiceDefinition.Factory friendlyBaristaServiceDefinitionFactory(
+        final CoffeeServerWithCallScopeService testServer) {
+      return new FriendlyBaristaServiceDefinition.Factory() {
+        @Override
+        public FriendlyBaristaServiceDefinition grpcService(
+            GrpcCallMetadataModule grpcCallMetadataModule) {
+          return testServer.baristaCallScope(grpcCallMetadataModule);
+        }
+      };
+    }
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/CoffeeServerWithUnscopedService.java b/javatests/dagger/grpc/functional/server/CoffeeServerWithUnscopedService.java
new file mode 100644
index 000000000..3346f8486
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/CoffeeServerWithUnscopedService.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.grpc.functional.server.CoffeeServerWithUnscopedService.UnscopedServiceModule;
+import dagger.grpc.functional.server.CountingInterceptor.CountingInterceptorModule;
+import dagger.grpc.server.InProcessServerModule;
+import javax.inject.Singleton;
+
+@Singleton
+@Component(
+  modules = {
+    InProcessServerModule.class,
+    UnscopedServiceModule.class,
+    CountingInterceptorModule.class
+  }
+)
+abstract class CoffeeServerWithUnscopedService extends CoffeeServer<CoffeeServerWithUnscopedService>
+    implements FriendlyBaristaServiceDefinition {
+
+  @Component.Builder
+  interface Builder extends CoffeeServer.Builder<CoffeeServerWithUnscopedService> {}
+
+  @Module(includes = FriendlyBaristaUnscopedGrpcServiceModule.class)
+  abstract static class UnscopedServiceModule {
+    @Binds
+    abstract FriendlyBaristaServiceDefinition friendlyBaristaServiceDefinition(
+        CoffeeServerWithUnscopedService testServer);
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/CountingInterceptor.java b/javatests/dagger/grpc/functional/server/CountingInterceptor.java
new file mode 100644
index 000000000..4d537826d
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/CountingInterceptor.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import static java.util.Arrays.asList;
+
+import com.google.common.collect.ConcurrentHashMultiset;
+import com.google.common.collect.Multiset;
+import com.google.protos.test.BaristaGrpc;
+import dagger.Module;
+import dagger.Provides;
+import dagger.grpc.server.ForGrpcService;
+import io.grpc.Metadata;
+import io.grpc.ServerCall;
+import io.grpc.ServerCall.Listener;
+import io.grpc.ServerCallHandler;
+import io.grpc.ServerInterceptor;
+import java.util.List;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton
+class CountingInterceptor implements ServerInterceptor {
+  private final Multiset<String> calls = ConcurrentHashMultiset.create();
+
+  @Inject
+  CountingInterceptor() {}
+
+  @Override
+  public <RequestT, ResponseT> Listener<RequestT> interceptCall(
+      ServerCall<RequestT, ResponseT> call,
+      Metadata headers,
+      ServerCallHandler<RequestT, ResponseT> next) {
+    calls.add(call.getMethodDescriptor().getFullMethodName());
+    return next.startCall(call, headers);
+  }
+
+  public int countCalls(String methodName) {
+    return calls.count(methodName);
+  }
+
+  @Module
+  static class CountingInterceptorModule {
+    @Provides
+    @ForGrpcService(BaristaGrpc.class)
+    static List<? extends ServerInterceptor> testServiceInterceptors(
+        CountingInterceptor countingInterceptor) {
+      return asList(countingInterceptor);
+    }
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/FriendlyBarista.java b/javatests/dagger/grpc/functional/server/FriendlyBarista.java
new file mode 100644
index 000000000..2c0246f8e
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/FriendlyBarista.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import static java.util.Collections.singletonList;
+
+import com.google.protos.test.BaristaGrpc;
+import com.google.protos.test.BaristaGrpc.BaristaImplBase;
+import com.google.protos.test.CoffeeService.CoffeeRequest;
+import com.google.protos.test.CoffeeService.CoffeeResponse;
+import com.google.protos.test.CoffeeService.CoffeeType;
+import dagger.grpc.server.GrpcService;
+import io.grpc.stub.StreamObserver;
+import java.util.List;
+import javax.inject.Inject;
+
+@GrpcService(grpcClass = BaristaGrpc.class)
+class FriendlyBarista extends BaristaImplBase {
+
+  @Inject
+  FriendlyBarista() {}
+
+  @Override
+  public void unaryGetCoffee(
+      CoffeeRequest request, StreamObserver<CoffeeResponse> responseObserver) {
+    responseObserver.onNext(response("Here you go!", request.getTypeList()));
+    responseObserver.onCompleted();
+  }
+
+  @Override
+  public StreamObserver<CoffeeRequest> clientStreamingGetCoffee(
+      final StreamObserver<CoffeeResponse> responseObserver) {
+    return new StreamObserver<CoffeeRequest>() {
+
+      private final CoffeeResponse.Builder response = CoffeeResponse.newBuilder();
+
+      @Override
+      public void onNext(CoffeeRequest value) {
+        response.addAllCup(value.getTypeList());
+      }
+
+      @Override
+      public void onError(Throwable t) {}
+
+      @Override
+      public void onCompleted() {
+        response.setMessage("All yours!");
+        responseObserver.onNext(response.build());
+        responseObserver.onCompleted();
+      }
+    };
+  }
+
+  @Override
+  public void serverStreamingGetCoffee(
+      CoffeeRequest request, StreamObserver<CoffeeResponse> responseObserver) {
+    for (CoffeeType type : request.getTypeList()) {
+      responseObserver.onNext(response("Here's a " + type, singletonList(type)));
+    }
+    responseObserver.onCompleted();
+  }
+
+  @Override
+  public StreamObserver<CoffeeRequest> bidiStreamingGetCoffee(
+      final StreamObserver<CoffeeResponse> responseObserver) {
+    return new StreamObserver<CoffeeRequest>() {
+
+      private int responses;
+
+      @Override
+      public void onNext(CoffeeRequest value) {
+        responseObserver.onNext(response("Enjoy!", value.getTypeList()));
+        if (responses++ > 10) {
+          responseObserver.onNext(CoffeeResponse.newBuilder().setMessage("We're done.").build());
+          responseObserver.onCompleted();
+        }
+      }
+
+      @Override
+      public void onError(Throwable t) {}
+
+      @Override
+      public void onCompleted() {
+        responseObserver.onCompleted();
+      }
+    };
+  }
+
+  private CoffeeResponse response(String message, List<CoffeeType> types) {
+    return CoffeeResponse.newBuilder().addAllCup(types).setMessage(message).build();
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/VerifyInterceptor.java b/javatests/dagger/grpc/functional/server/VerifyInterceptor.java
new file mode 100644
index 000000000..99ecedb4e
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/VerifyInterceptor.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import static com.google.common.truth.Truth.assertWithMessage;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.protos.test.BaristaGrpc;
+import io.grpc.MethodDescriptor;
+import java.lang.annotation.Retention;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+final class VerifyInterceptor implements TestRule {
+
+  @Retention(RUNTIME)
+  @interface MethodName {
+    String value();
+  }
+
+  private final CoffeeServerResource coffeeServer;
+
+  VerifyInterceptor(CoffeeServerResource coffeeServer) {
+    this.coffeeServer = coffeeServer;
+  }
+
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    MethodName annotation = description.getAnnotation(MethodName.class);
+    if (annotation == null) {
+      return base;
+    }
+    final String fullMethodName =
+        MethodDescriptor.generateFullMethodName(BaristaGrpc.SERVICE_NAME, annotation.value());
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        int calls = coffeeServer.methodCount(fullMethodName);
+        base.evaluate();
+        assertWithMessage("Calls to %s", fullMethodName)
+            .that(coffeeServer.methodCount(fullMethodName))
+            .isEqualTo(calls + 1);
+      }
+    };
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/coffee_service.proto b/javatests/dagger/grpc/functional/server/coffee_service.proto
new file mode 100644
index 000000000..a14c79482
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/coffee_service.proto
@@ -0,0 +1,50 @@
+// Copyright (C) 2016 The Dagger Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package test;
+
+enum CoffeeType {
+  UNKNOWN = 0;
+  DRIP = 1;
+  POUR_OVER = 2;
+  ESPRESSO = 3;
+  AMERICANO = 4;
+  LATTE = 5;
+}
+
+message CoffeeRequest {
+  repeated CoffeeType type = 1;
+}
+
+message CoffeeResponse {
+  repeated CoffeeType cup = 1;
+  string message = 2;
+}
+
+service Barista {
+  rpc UnaryGetCoffee(CoffeeRequest) returns (CoffeeResponse) {
+  }
+
+  rpc ClientStreamingGetCoffee(stream CoffeeRequest) returns (CoffeeResponse) {
+  }
+
+  rpc ServerStreamingGetCoffee(CoffeeRequest) returns (stream CoffeeResponse) {
+  }
+
+  rpc BidiStreamingGetCoffee(stream CoffeeRequest)
+      returns (stream CoffeeResponse) {
+  }
+}
diff --git a/third_party/BUILD b/third_party/BUILD
index da55423a3..d2e6d52c4 100644
--- a/third_party/BUILD
+++ b/third_party/BUILD
@@ -182,6 +182,41 @@ java_library(
     ],
 )
 
+java_library(
+    name = "grpc",
+    exports = ["@io_grpc_grpc_all//jar"],
+)
+
+java_library(
+    name = "grpc_core",
+    exports = ["@io_grpc_grpc_core//jar"],
+)
+
+java_library(
+    name = "grpc_netty",
+    exports = ["@io_grpc_grpc_netty//jar"],
+)
+
+java_library(
+    name = "grpc_context",
+    exports = ["@io_grpc_grpc_context//jar"],
+)
+
+java_library(
+    name = "grpc_protobuf",
+    exports = ["@io_grpc_grpc_protobuf//jar"],
+)
+
+java_library(
+    name = "grpc_stub",
+    exports = ["@io_grpc_grpc_stub//jar"],
+)
+
+java_library(
+    name = "protobuf",
+    exports = ["@com_google_protobuf_protobuf_java//jar"],
+)
+
 java_library(
     name = "compile_testing",
     testonly = 1,
diff --git a/util/execute-deploy.sh b/util/execute-deploy.sh
index 33607be23..ff6feed93 100755
--- a/util/execute-deploy.sh
+++ b/util/execute-deploy.sh
@@ -12,7 +12,10 @@ python $(dirname $0)/maven/generate_poms.py $VERSION_NAME \
   //java/dagger/producers:producers \
   //java/dagger/android:android \
   //java/dagger/android/support:support \
-  //java/dagger/android/processor:processor
+  //java/dagger/android/processor:processor \
+  //java/dagger/grpc/server:server \
+  //java/dagger/grpc/server:annotations \
+  //java/dagger/grpc/server/processor:processor
 
 library_output_file() {
   library=$1
@@ -78,3 +81,21 @@ deploy_library \
   java/dagger/android/processor/libprocessor-src.jar \
   java/dagger/android/processor/processor-javadoc.jar \
   dagger-android-processor.pom.xml
+
+deploy_library \
+  java/dagger/grpc/server/libserver.jar \
+  java/dagger/grpc/server/libserver-src.jar \
+  java/dagger/grpc/server/javadoc.jar \
+  dagger-grpc-server.pom.xml
+
+deploy_library \
+  java/dagger/grpc/server/libannotations.jar \
+  java/dagger/grpc/server/libannotations-src.jar \
+  java/dagger/grpc/server/javadoc.jar \
+  dagger-grpc-server-annotations.pom.xml
+
+deploy_library \
+  shaded_grpc_server_processor.jar \
+  java/dagger/grpc/server/processor/libprocessor-src.jar \
+  java/dagger/grpc/server/processor/javadoc.jar \
+  dagger-grpc-server-processor.pom.xml
diff --git a/util/maven/generate_poms.py b/util/maven/generate_poms.py
index 3beb3f78a..20cd7bd34 100644
--- a/util/maven/generate_poms.py
+++ b/util/maven/generate_poms.py
@@ -80,6 +80,18 @@ def pom_deps(label):
         'name': 'Dagger Android Processor',
         'artifact': 'dagger-android-processor',
     },
+    '//java/dagger/grpc/server:server': {
+        'name': 'Dagger gRPC Server',
+        'artifact': 'dagger-grpc-server',
+    },
+    '//java/dagger/grpc/server:annotations': {
+        'name': 'Dagger gRPC Server annotations',
+        'artifact': 'dagger-grpc-server-annotations',
+    },
+    '//java/dagger/grpc/server/processor:processor': {
+        'name': 'Dagger gRPC Server processor',
+        'artifact': 'dagger-grpc-server-processor',
+    },
 }
 
 
