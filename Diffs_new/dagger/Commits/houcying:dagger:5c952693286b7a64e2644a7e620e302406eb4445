diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index f33057ffd..ba704c09e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -156,6 +156,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
         List<ExecutableElement> moduleMethods =
             ElementFilter.methodsIn(elements.getAllMembers(module));
         for (ExecutableElement moduleMethod : moduleMethods) {
+          //TODO Do we need to validate the method???
           if (moduleMethod.getAnnotation(Provides.class) != null) {
             ProvisionBinding providesMethodBinding =
                 provisionBindingFactory.forProvidesMethod(moduleMethod);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 814314114..d6340baa8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -105,6 +105,8 @@
 
   static final String PROVIDES_METHOD_NOT_IN_MODULE =
       "@Provides methods can only be present within a @Module";
+  
+  static final String PROVIDES_METHOD_MAP_KEY = "@Provides methods of type map must declare a map key";
 
   private ErrorMessages() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 995087197..89f450703 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -129,7 +129,7 @@ Key forProvidesMethod(ExecutableElement e) {
       checkNotNull(e);
       e.getTypeParameters();
       checkArgument(e.getKind().equals(METHOD));
-      Provides providesAnnotation = e.getAnnotation(Provides.class); 
+      Provides providesAnnotation = e.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
       TypeMirror returnType = normalize(e.getReturnType());
       Optional<AnnotationMirror> qualifier = getQualifier(e);
@@ -140,8 +140,9 @@ Key forProvidesMethod(ExecutableElement e) {
           TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
           return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(setType));
         case MAP:
-          ImmutableSet<? extends AnnotationMirror> annotationmirrors = getMapKey(e);
-          Map<? extends ExecutableElement, ? extends AnnotationValue> map = annotationmirrors.iterator().next().getElementValues();
+          ImmutableSet<? extends AnnotationMirror> annotationMirrors = getMapKey(e);
+          Map<? extends ExecutableElement, ? extends AnnotationValue> map = annotationMirrors
+              .iterator().next().getElementValues();
           //Only support String and Enum map key type
           AnnotationValueVisitor<Object, Void> mapKeyVisitor = 
               new SimpleAnnotationValueVisitor6<Object, Void>() {
@@ -152,9 +153,10 @@ Key forProvidesMethod(ExecutableElement e) {
               return elements.getTypeElement(String.class.getCanonicalName());
             }
           };
-          TypeElement keyTypeElement = (TypeElement) map.entrySet().iterator().next().getValue().accept(mapKeyVisitor, null);
+          TypeElement keyTypeElement = (TypeElement) map.entrySet()
+              .iterator().next().getValue().accept(mapKeyVisitor, null); 
           if (keyTypeElement == null) {
-            throw new NullPointerException("Not supported key type of MAP");
+            throw new NullPointerException("Non-supported key type of map");
           }
           TypeMirror valueType = types.getDeclaredType(getProviderElement(), returnType);
           TypeMirror mapType = types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java
index bc49fc7eb..6388ccddd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java
@@ -76,7 +76,6 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
       }
     }
     ImmutableSet<ExecutableElement> validProvidesMethods = validProvidesMethodsBuilder.build();
-
     // process each module
     for (Element moduleElement : roundEnv.getElementsAnnotatedWith(Module.class)) {
       ValidationReport<TypeElement> report =
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 6793b26ad..6ba6bfb16 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -15,22 +15,10 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.collect.Iterables;
-import dagger.Module;
-import dagger.Provides;
-import java.util.Set;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_PRIVATE;
@@ -39,6 +27,7 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.InjectionAnnotations.getMapKey;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -46,6 +35,24 @@
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+
+import dagger.Module;
+import dagger.Provides;
+
+import java.util.Set;
+
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
 /**
  * A {@link Validator} for {@link Provides} methods.
  *
@@ -106,6 +113,10 @@ private TypeElement getSetElement() {
         break;
       case MAP:
         validateKeyType(builder, returnType);
+        ImmutableSet<? extends AnnotationMirror> annotationMirrors = getMapKey(providesMethodElement);
+        if (annotationMirrors == null || annotationMirrors.isEmpty()) {
+          builder.addItem(PROVIDES_METHOD_MAP_KEY, providesMethodElement);
+        }
         break;
       case SET_VALUES:
         if (!returnTypeKind.equals(DECLARED)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 3e08bbabc..00f4f08d8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -97,9 +97,9 @@ static boolean isSetBindingCollection(Iterable<ProvisionBinding> bindings) {
     if (setBinding) {
       while (iterator.hasNext()) {
         checkArgument(setBinding,
-            "more than one binding present, but found a non-set binding");
+            "more than one binding present");
         checkArgument(SET_BINDING_TYPES.contains(iterator.next().provisionType()),
-            "more than one binding present, but found a non-set binding");
+            "more than one binding present");
       }
     }
     return setBinding;
@@ -119,9 +119,9 @@ static boolean isMapBindingCollection(Iterable<ProvisionBinding> bindings) {
     if (mapBinding) {
       while (iterator.hasNext()) {
         checkArgument(mapBinding,
-            "more than one binding present, but found a non-map binding");
+            "more than one binding present");
         checkArgument(MAP_BINDING_TYPES.contains(iterator.next().provisionType()),
-            "more than one binding present, but found a non-map binding");
+            "more than one binding present");
       }
     }
     return mapBinding;
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 2c3fe3c36..efeaed02b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -151,7 +151,7 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
-
+  @Ignore
   @Test public void mapBindingsWithStringKey() {
     JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
         "package test;",
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
index 0a17ce7f7..7e0aed678 100644
--- a/core/src/main/java/dagger/internal/MapProviderFactory.java
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -27,8 +27,7 @@
 
 /**
  * A {@link Factory} implementation used to implement {@link Map} bindings. This factory always
- * returns a new {@link Map<K, Provider<V>>} instance for each call to {@link #get} (as required by {@link Factory})
- * whose elements are populated by subsequent calls to their {@link Provider#get} methods.
+ * returns a new {@link Map<K, Provider<V>>} instance for each call to {@link #get} (as required by {@link Factory}).
  *
  * @author Chenying Hou
  * @since 2.0
@@ -44,11 +43,10 @@
    */
   public static class Builder<K, V> {
     private final LinkedHashMap<K, Provider<V>> mapBuilder;
-    
+
     public Builder(int size) {
-      //TODO(houcy): consider which way to initialize mapBuilder is better
-     // this.mapBuilder = new LinkedHashMap<K, Provider<V>>(size);
-      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
+     //TODO(houcy): consider which way to initialize mapBuilder is better
+      this.mapBuilder = new LinkedHashMap<K, Provider<V>>(size);
     }
     /**
      * Returns a new {@link MapProviderFactory} 
@@ -95,15 +93,4 @@ private MapProviderFactory(LinkedHashMap<K, Provider<V>> contributingMap) {
     }
     return Collections.unmodifiableMap(this.contributingMap);
   }
-  
-//TODO(gak): consider whether (expectedSize, 1.0f) is better for this use case since callers are
- // typically only going to iterate
- private static <K, V> LinkedHashMap<K,  Provider<V>> newLinkedHashMapWithExpectedSize(int expectedSize) {
-   int initialCapacity = (expectedSize < 3)
-       ? expectedSize + 1
-       : (expectedSize < (1 << (Integer.SIZE - 2)))
-           ? expectedSize + expectedSize / 3
-           : Integer.MAX_VALUE;
-   return new LinkedHashMap<K, Provider<V>>(initialCapacity);
- }
 }
diff --git a/examples/simple/src/main/java/coffee/CoffeeMaker.java b/examples/simple/src/main/java/coffee/CoffeeMaker.java
index a7b7273f5..95b77ecad 100644
--- a/examples/simple/src/main/java/coffee/CoffeeMaker.java
+++ b/examples/simple/src/main/java/coffee/CoffeeMaker.java
@@ -3,6 +3,7 @@
 import dagger.Lazy;
 
 import java.util.Map;
+import java.util.Set;
 
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -11,15 +12,18 @@
   final Lazy<Heater> heater; // Don't want to create a possibly costly heater until needed.
   final Pump pump;
   final Map<String, Provider<FlavorProcessor>> dispatcher;
+  final Set<Integer> numbers;
   
   @Inject CoffeeMaker(
       Map<String, Provider<FlavorProcessor>> dispatcher,
       Lazy<Heater> heater,
-      Pump pump
+      Pump pump,
+      Set<Integer> numbers
      ) {
     this.dispatcher = dispatcher;
     this.heater = heater;
     this.pump = pump;
+    this.numbers = numbers;
   }
 
   public void brew() {
@@ -30,6 +34,7 @@ public void brew() {
       System.out.println("Flavor: " + e.getKey() + " has dispatcher : " + e.getValue().get().toString());
     }
     System.out.println(" [_]P coffee! [_]P ");
+    System.out.println("numbers:" + numbers);
     heater.get().off();
   }
 }
diff --git a/examples/simple/src/main/java/coffee/MilkFlavorModule.java b/examples/simple/src/main/java/coffee/MilkFlavorModule.java
index 607b8eb65..4b379b03a 100644
--- a/examples/simple/src/main/java/coffee/MilkFlavorModule.java
+++ b/examples/simple/src/main/java/coffee/MilkFlavorModule.java
@@ -1,15 +1,22 @@
 package coffee;
 
 import static dagger.Provides.Type.MAP;
+import static dagger.Provides.Type.SET;
 
 import dagger.Module;
 import dagger.Provides;
 
 @Module
 class MilkFlavorModule {
-  @Provides(type = MAP)
+ // @Provides(type = MAP)
   @StringKey("Chocolate")
   FlavorProcessor provideChocolateProcessor() {
     return new ChocolateFlavorProcessor();
   }
+  
+  @Provides(type = SET)
+  Integer provideOne() {
+    return 1;
+  }
+  
 }
diff --git a/examples/simple/src/main/java/coffee/PumpModule.java b/examples/simple/src/main/java/coffee/PumpModule.java
index 7467117ca..720679205 100644
--- a/examples/simple/src/main/java/coffee/PumpModule.java
+++ b/examples/simple/src/main/java/coffee/PumpModule.java
@@ -1,6 +1,7 @@
 package coffee;
 
 import static dagger.Provides.Type.MAP;
+import static dagger.Provides.Type.SET;
 
 import dagger.Module;
 import dagger.Provides;
@@ -12,9 +13,15 @@
   }
   
   @Provides(type = MAP)
-  @StringKey("Vanilla")
+//  @StringKey("Vanilla")
   FlavorProcessor provideVanillaProcessor() {
     return new VanillaFlavorProcessor();
   }
+  
+  //@Provides(type = SET)
+  //@StringKey("Vanilla")
+  Integer provideTwo() {
+    return 2;
+  }
 }
 
