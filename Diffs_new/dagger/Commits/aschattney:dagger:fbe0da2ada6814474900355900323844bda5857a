diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index a925f8d56..f5eeaeb89 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -318,9 +318,6 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
     component.addMethod(constructor.build());
     if (graph.componentDescriptor().kind().isTopLevel()) {
       optionalFactories.addMembers(component);
-    }
-    for (MethodSpec initializationMethod : initializationMethods) {
-
     }
     done = true;
     return component;
diff --git a/compiler/src/main/java/dagger/internal/codegen/AppConfig.java b/compiler/src/main/java/dagger/internal/codegen/AppConfig.java
index ec23dac0a..f396cc8f7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AppConfig.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AppConfig.java
@@ -2,11 +2,16 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.sun.jdi.Mirror;
 import dagger.Config;
 
+import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.MirroredTypeException;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import java.util.Set;
 
 public class AppConfig {
 
@@ -61,4 +66,61 @@ private TypeElement extractBaseAppClassElement(Config config) {
         }
     }
 
+    static class Validator {
+
+        private final Elements elements;
+        private Types types;
+
+        public Validator(Elements elements, Types types) {
+            this.elements = elements;
+            this.types = types;
+        }
+
+        public ValidationReport<Element> validate(Set<Element> elements) {
+            Element configElement = getConfigType();
+            final ValidationReport.Builder<Element> reportBuilder = ValidationReport.about(configElement);
+            if (elements.isEmpty()) {
+                reportBuilder.addError(String.format("No class is annotated with @%s!", Config.class.getName()));
+            }else if(elements.size() > 1) {
+                 reportBuilder.addError(String.format("Only one Annotation of type %s is allowed!", Config.class.getName()));
+            }else {
+                Element element = elements.iterator().next();
+                final Config config = element.getAnnotation(Config.class);
+                TypeMirror appClass = getApplicationClass(config);
+                /*if (!isSubtypeOfApplicationType(appClass)) {
+                    reportBuilder.addError(String.format("Class %s is not a subtype of android.app.Application!", appClass.toString()));
+                }*/
+                TypeMirror baseAppClass = getBaseApplicationClass(config);
+                final String baseAppClassName = config.baseApplicationClass();
+                if (baseAppClass == null) {
+                    reportBuilder.addError(String.format("baseApplicationClass: %s not found!", baseAppClassName));
+                }else if (!isSubtypeOfApplicationType(baseAppClass)){
+                    reportBuilder.addError(String.format("Class %s is not a subtype of android.app.Application!", baseAppClassName));
+                }
+            }
+            return reportBuilder.build();
+        }
+
+        private TypeMirror getBaseApplicationClass(Config config) {
+            final TypeElement typeElement = elements.getTypeElement(config.baseApplicationClass());
+            return typeElement != null ? typeElement.asType() : null;
+        }
+
+        protected boolean isSubtypeOfApplicationType(TypeMirror appClass) {
+            return types.isAssignable(appClass, this.elements.getTypeElement("android.app.Application").asType());
+        }
+
+        private TypeMirror getApplicationClass(Config config) {
+            try{
+                return (elements.getTypeElement(config.applicationClass().getName())).asType();
+            }catch(MirroredTypeException e) {
+                return e.getTypeMirror();
+            }
+        }
+
+        private Element getConfigType() {
+            return elements.getTypeElement(Config.class.getName());
+        }
+    }
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AppConfigProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/AppConfigProcessingStep.java
new file mode 100644
index 000000000..4d4b19c27
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AppConfigProcessingStep.java
@@ -0,0 +1,43 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.Config;
+
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+
+/**
+ * Created by Andy on 26.05.2017.
+ */
+public class AppConfigProcessingStep implements BasicAnnotationProcessor.ProcessingStep{
+
+    private final Messager messager;
+    private final Elements elements;
+    private final Types types;
+    private AppConfig.Validator validator;
+
+    public AppConfigProcessingStep(Messager messager, Elements elements, Types types, AppConfig.Validator validator) {
+        this.messager = messager;
+        this.elements = elements;
+        this.types = types;
+        this.validator = validator;
+    }
+
+    @Override
+    public Set<? extends Class<? extends Annotation>> annotations() {
+        return ImmutableSet.of(Config.class);
+    }
+
+    @Override
+    public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> set) {
+        final Set<Element> elements = set.get(Config.class);
+        validator.validate(elements).printMessagesTo(messager);
+        return ImmutableSet.of();
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index b8bdcd4a5..9c2189428 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -219,6 +219,7 @@ public SourceVersion getSupportedSourceVersion() {
             keyFactory);
 
     return ImmutableList.of(
+        new AppConfigProcessingStep(messager, elements, types, new AppConfig.Validator(elements, types)),
         new MapKeyProcessingStep(
                 messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
         new ForReleasableReferencesValidator(messager),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index d2401056b..cd63ecea6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -50,11 +50,8 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
+import java.util.stream.Collectors;
+import javax.lang.model.element.*;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
@@ -149,6 +146,12 @@ public ComponentValidationReport validate(
 
     ImmutableList<DeclaredType> builders =
         enclosedBuilders(subject, componentKind.builderAnnotationType());
+
+    if (builders.isEmpty()) {
+      final String subjectName = subject.getQualifiedName().toString();
+      builder.addError(String.format(ErrorMessages.builderMsgsFor(componentKind).noBuilderPresent(), subjectName));
+    }
+
     if (builders.size() > 1) {
       builder.addError(
           String.format(ErrorMessages.builderMsgsFor(componentKind).moreThanOne(), builders),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 9e398c4a6..10d60dd71 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -522,6 +522,10 @@ final String inheritedMethodsMayNotHaveTypeParameters() {
       return process(
           "@Component.Builder methods must not have type parameters. Inherited method: %s");
     }
+
+    public String noBuilderPresent() {
+      return process("Each Component and Subcomponent needs a @Component.Builder or @Subcomponent.Builder declaration. Declaration is missing for: %s");
+    }
   }
 
   static final class SubcomponentBuilderMessages extends ComponentBuilderMessages {
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
index 0f47293d0..da59ef2b5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
@@ -29,8 +29,9 @@ public void process(TypeSpec.Builder builder) {
 
         List<ParameterSpec> parameterSpecs = new ArrayList<>();
         if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
-            final TypeElement component = descriptor.getParentDescriptor().componentDefinitionType();
-            parameterSpecs.add(ParameterSpec.builder(ClassName.get(component), simpleVariableName(component)).build());
+            //final TypeElement component = descriptor.getParentDescriptor().componentDefinitionType();
+            final TypeElement subcomponentTypeBuilder = descriptor.builderSpec().get().builderDefinitionType();
+            parameterSpecs.add(ParameterSpec.builder(ClassName.get(subcomponentTypeBuilder), "builder").build());
         }
 
         if (descriptor.builderSpec().isPresent()) {
@@ -110,6 +111,9 @@ public void process(TypeSpec.Builder builder) {
 
     private CodeBlock getBuilderInitStatement(ComponentDescriptor descriptor, ComponentDescriptor parentDescriptor) {
         if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            if (true) {
+                return CodeBlock.of("$L", "builder");
+            }
             final ImmutableSet<ComponentDescriptor.ComponentMethodDescriptor> componentMethodDescriptors = parentDescriptor.componentMethods();
             for (ComponentDescriptor.ComponentMethodDescriptor componentMethodDescriptor : componentMethodDescriptors) {
                 final ExecutableElement executableElement = componentMethodDescriptor.methodElement();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index e11537526..7f3f7086f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -87,7 +87,7 @@ public BindingType bindingType() {
   private static Builder builder() {
     return new AutoValue_ProvisionBinding.Builder()
         .genericParameter(false)
-        .ignoreStubGeneration(false)
+        .ignoreStubGeneration(true)
         .explicitDependencies(ImmutableSet.<DependencyRequest>of());
   }
   
diff --git a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
index 669c05d01..e224a303a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
@@ -106,8 +106,14 @@ private static String internalResolveClassName(String parentClassName,
             return classNameToString(daggerComponentClassName);
         }else if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
             final String name = subcomponentNamesMap.get(descriptor);
-            parentClassName = builderImplString(parentClassName, name);
-            return internalResolveClassName(parentClassName, subcomponentNamesMap, descriptor.getParentDescriptor());
+            String newParentClass = builderImplString(parentClassName, name);
+            final String resolvedClassName = internalResolveClassName(newParentClass,
+                    subcomponentNamesMap, descriptor.getParentDescriptor());
+            StringBuilder sb = new StringBuilder(resolvedClassName);
+            sb.append(".");
+            sb.append(name);
+            sb.append("Impl");
+            return sb.toString();
         }else {
             throw new IllegalStateException(String.format("Unknown component kind: %s", descriptor.kind()));
         }
diff --git a/examples/simple/src/main/java/coffee/AModule.java b/examples/simple/src/main/java/coffee/AModule.java
index 57aaa9372..af10c2a89 100644
--- a/examples/simple/src/main/java/coffee/AModule.java
+++ b/examples/simple/src/main/java/coffee/AModule.java
@@ -6,7 +6,7 @@
 /**
  * Created by Andy on 06.05.2017.
  */
-@Module
+@Module(subcomponents = CoffeeApp.Bleu2.class)
 public class AModule {
 
     @Provides
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index 0116bb75d..bfdae9ac7 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -14,7 +14,6 @@
   public interface Coffee {
     CoffeeMaker maker();
     Thermosiphon thermosiphon();
-    Bleu.Builder bleu();
     @Component.Builder
     interface Builder {
       Builder dripCoffeeModule(DripCoffeeModule module);
@@ -27,7 +26,7 @@
   @Subcomponent(modules = {AModule.class, BModule.class})
   public interface Bleu {
     Integer integer();
-    Bleu2.Builder someComponent();
+    SomeCoffee someCoffee();
     @Subcomponent.Builder
     interface Builder {
       Builder moduleA(AModule module);
diff --git a/examples/simple/src/main/java/coffee/DripCoffeeModule.java b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
index 99df0114c..7f78d7817 100644
--- a/examples/simple/src/main/java/coffee/DripCoffeeModule.java
+++ b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
@@ -4,7 +4,7 @@
 import dagger.Provides;
 import javax.inject.Singleton;
 
-@Module(includes = PumpModule.class)
+@Module(includes = PumpModule.class, subcomponents = {CoffeeApp.Bleu.class})
 public class DripCoffeeModule {
   @Provides @Singleton Heater provideHeater() {
     return new ElectricHeater();
diff --git a/examples/simple/src/main/java/coffee/SomeCoffee.java b/examples/simple/src/main/java/coffee/SomeCoffee.java
new file mode 100644
index 000000000..bdac51eee
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/SomeCoffee.java
@@ -0,0 +1,15 @@
+package coffee;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+public class SomeCoffee {
+
+    private Provider<CoffeeApp.Bleu2.Builder> builderProvider;
+
+    @Inject
+    public SomeCoffee(Provider<CoffeeApp.Bleu2.Builder> builderProvider) {
+        this.builderProvider = builderProvider;
+    }
+
+}
diff --git a/examples/simple/src/main/java/coffee/Thermosiphon.java b/examples/simple/src/main/java/coffee/Thermosiphon.java
index a20033ee3..dfff1ccba 100644
--- a/examples/simple/src/main/java/coffee/Thermosiphon.java
+++ b/examples/simple/src/main/java/coffee/Thermosiphon.java
@@ -7,7 +7,7 @@
   private final Provider<Heater> heater;
 
   @Inject
-  Thermosiphon(Provider<Heater> heater) {
+  Thermosiphon(Provider<Heater> heater, Provider<CoffeeApp.Bleu.Builder> bleuProvider) {
     this.heater = heater;
   }
 
