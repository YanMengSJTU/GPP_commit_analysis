diff --git a/javatests/dagger/functional/multibindings/ComplexMapKeysInDifferentOrderTest.java b/javatests/dagger/functional/multibindings/ComplexMapKeysInDifferentOrderTest.java
new file mode 100644
index 000000000..f2b5598ac
--- /dev/null
+++ b/javatests/dagger/functional/multibindings/ComplexMapKeysInDifferentOrderTest.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multibindings;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.auto.value.AutoAnnotation;
+import dagger.Component;
+import dagger.MapKey;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoMap;
+import java.util.Map;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ComplexMapKeysInDifferentOrderTest {
+  @MapKey(unwrapValue = false)
+  @interface ComplexMapKey {
+    int i();
+    int j();
+  }
+
+  @Module
+  interface TestModule {
+    @Provides
+    @IntoMap
+    @ComplexMapKey(i = 1, j = 2)
+    static int inOrder() {
+      return 3;
+    }
+
+    @Provides
+    @IntoMap
+    @ComplexMapKey(j = 4, i = 5)
+    static int backwardsOrder() {
+      return 6;
+    }
+  }
+
+  @Component(modules = TestModule.class)
+  interface TestComponent {
+    Map<ComplexMapKey, Integer> map();
+  }
+
+  @Test
+  public void test() {
+    Map<ComplexMapKey, Integer> map =
+        DaggerComplexMapKeysInDifferentOrderTest_TestComponent.create().map();
+    assertThat(map.get(mapKey(1, 2))).isEqualTo(3);
+    assertThat(map.get(mapKey(5, 4))).isEqualTo(6);
+  }
+
+  @AutoAnnotation
+  static ComplexMapKey mapKey(int i, int j) {
+    return new AutoAnnotation_ComplexMapKeysInDifferentOrderTest_mapKey(i, j);
+  }
+}
diff --git a/javatests/dagger/functional/multibindings/MapKeyWithDefaultTest.java b/javatests/dagger/functional/multibindings/MapKeyWithDefaultTest.java
new file mode 100644
index 000000000..f1884052a
--- /dev/null
+++ b/javatests/dagger/functional/multibindings/MapKeyWithDefaultTest.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multibindings;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.auto.value.AutoAnnotation;
+import dagger.Component;
+import dagger.MapKey;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoMap;
+import java.util.Map;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class MapKeyWithDefaultTest {
+  @MapKey(unwrapValue = false)
+  @interface MapKeyWithDefault {
+    boolean hasDefault() default true;
+    boolean required();
+  }
+
+  @Module
+  interface TestModule {
+    @Provides
+    @IntoMap
+    @MapKeyWithDefault(required = false)
+    static int justRequired() {
+      return 1;
+    }
+
+    @Provides
+    @IntoMap
+    @MapKeyWithDefault(required = false, hasDefault = false)
+    static int both() {
+      return 2;
+    }
+  }
+
+  @Component(modules = TestModule.class)
+  interface TestComponent {
+    Map<MapKeyWithDefault, Integer> map();
+  }
+
+  @Test
+  public void test() {
+    Map<MapKeyWithDefault, Integer> map = DaggerMapKeyWithDefaultTest_TestComponent.create().map();
+    assertThat(map).hasSize(2);
+    assertThat(map.get(mapKey(true, false))).isEqualTo(1);
+    assertThat(map.get(mapKey(false, false))).isEqualTo(2);
+  }
+
+  @AutoAnnotation
+  static MapKeyWithDefault mapKey(boolean hasDefault, boolean required) {
+    return new AutoAnnotation_MapKeyWithDefaultTest_mapKey(hasDefault, required);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
index 0121acc59..962e5e11d 100644
--- a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
+++ b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
@@ -285,31 +285,7 @@ public void componentInstances() {
                 "        dep.object(), " + NPE_FROM_COMPONENT_METHOD + " );",
                 "  }",
                 "",
-                "  @Override",
-                "  public TestSubcomponent subcomponent() {",
-                "    return new TestSubcomponentImpl();",
-                "  }",
-                "",
-                "  public static final class Builder {",
-                "    private Dep dep;",
-                "",
-                "    public TestComponent build() {",
-                "      if (dep == null) {",
-                "        throw new IllegalStateException(",
-                "            Dep.class.getCanonicalName() + \" must be set\");",
-                "      }",
-                "      return new DaggerTestComponent(this);",
-                "    }",
-                "",
-                "    public Builder dep(Dep dep) {",
-                "      this.dep = Preconditions.checkNotNull(dep);",
-                "      return this;",
-                "    }",
-                "  }",
-                "",
                 "  private final class TestSubcomponentImpl implements TestSubcomponent {",
-                "    private TestSubcomponentImpl() {}",
-                "",
                 "    @Override",
                 "    public TestComponent parent() {",
                 "      return DaggerTestComponent.this;",
@@ -402,11 +378,6 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
                 "    this.parentModule = builder.parentModule;",
                 "  }",
                 "",
-                "  @Override",
-                "  public TestSubcomponent subcomponent() {",
-                "    return new TestSubcomponentImpl();",
-                "  }",
-                "",
                 "  private final class TestSubcomponentImpl implements TestSubcomponent {",
                 "    private Set<Object> getSetOfObject() {",
                 "      return ImmutableSet.<Object>of(",
@@ -443,11 +414,6 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
                 "    this.parentModule = builder.parentModule;",
                 "  }",
                 "",
-                "  @Override",
-                "  public TestSubcomponent subcomponent() {",
-                "    return new TestSubcomponentImpl();",
-                "  }",
-                "",
                 "  private final class TestSubcomponentImpl implements TestSubcomponent {",
                 "    @SuppressWarnings(\"unchecked\")",
                 "    private void initialize() {",
diff --git a/javatests/dagger/internal/codegen/ErrorMessagesTest.java b/javatests/dagger/internal/codegen/DiagnosticFormattingTest.java
similarity index 91%
rename from javatests/dagger/internal/codegen/ErrorMessagesTest.java
rename to javatests/dagger/internal/codegen/DiagnosticFormattingTest.java
index 4d50d4413..a2da92f57 100644
--- a/javatests/dagger/internal/codegen/ErrorMessagesTest.java
+++ b/javatests/dagger/internal/codegen/DiagnosticFormattingTest.java
@@ -23,9 +23,10 @@
 import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
-public class ErrorMessagesTest {
+public class DiagnosticFormattingTest {
   @Test public void stripCommonTypePrefixes() {
     String typeName = "com.google.common.collect.ImmutableList<java.lang.Boolean>";
-    assertThat(DiagnosticFormatting.stripCommonTypePrefixes(typeName)).isEqualTo("ImmutableList<Boolean>");
+    assertThat(DiagnosticFormatting.stripCommonTypePrefixes(typeName))
+        .isEqualTo("ImmutableList<Boolean>");
   }
 }
diff --git a/javatests/dagger/internal/codegen/InaccessibleTypeTest.java b/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
deleted file mode 100644
index 79d69951f..000000000
--- a/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
+++ /dev/null
@@ -1,240 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
-import com.google.common.collect.FluentIterable;
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import java.util.Collection;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class InaccessibleTypeTest {
-  @Parameters(name = "{0}")
-  public static Collection<Object[]> parameters() {
-    return CompilerMode.TEST_PARAMETERS;
-  }
-
-  private final CompilerMode compilerMode;
-
-  public InaccessibleTypeTest(CompilerMode compilerMode) {
-    this.compilerMode = compilerMode;
-  }
-
-  @Test public void basicInjectedType() {
-    JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("foreign.NoDepClass",
-        "package foreign;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public final class NoDepClass {",
-        "  @Inject NoDepClass() {}",
-        "}");
-    JavaFileObject publicClassFile = JavaFileObjects.forSourceLines("foreign.PublicClass",
-        "package foreign;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public final class PublicClass {",
-        "  @Inject PublicClass(NonPublicClass1 dep1, NonPublicClass2 dep2, NoDepClass dep3) {}",
-        "}");
-    JavaFileObject nonPublicClass1File = JavaFileObjects.forSourceLines("foreign.NonPublicClass1",
-        "package foreign;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class NonPublicClass1 {",
-        "  @Inject NonPublicClass1(NoDepClass dep) {}",
-        "}");
-    JavaFileObject nonPublicClass2File = JavaFileObjects.forSourceLines("foreign.NonPublicClass2",
-        "package foreign;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class NonPublicClass2 {",
-        "  @Inject NonPublicClass2(NoDepClass dep) {}",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import foreign.PublicClass;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  PublicClass publicClass();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import foreign.NoDepClass_Factory;",
-            "import foreign.NonPublicClass1_Factory;",
-            "import foreign.NonPublicClass2_Factory;",
-            "import foreign.PublicClass;",
-            "import foreign.PublicClass_Factory;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Object getNonPublicClass1() {",
-            "    return NonPublicClass1_Factory.newNonPublicClass1(",
-            "        NoDepClass_Factory.newNoDepClass());",
-            "  }",
-            "",
-            "  private Object getNonPublicClass2() {",
-            "    return NonPublicClass2_Factory.newNonPublicClass2(",
-            "        NoDepClass_Factory.newNoDepClass());",
-            "  }",
-            "",
-            "  @Override",
-            "  public PublicClass publicClass() {",
-            "    return PublicClass_Factory.newPublicClass(",
-            "        getNonPublicClass1(), ",
-            "        getNonPublicClass2(), ",
-            "        NoDepClass_Factory.newNoDepClass());",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(
-                FluentIterable.from(compilerMode.javacopts())
-                    .append(
-                        "-Xlint:-processing",
-                        "-Xlint:rawtypes",
-                        "-Xlint:unchecked",
-                        "-Xlint:-classfile"))
-            .compile(
-                noDepClassFile,
-                publicClassFile,
-                nonPublicClass1File,
-                nonPublicClass2File,
-                componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .containsElementsIn(generatedComponent);
-  }
-
-  @Test public void memberInjectedType() {
-    JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("test.NoDepClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public final class NoDepClass {",
-        "  @Inject NoDepClass() {}",
-        "}");
-    JavaFileObject aClassFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import foreign.B;",
-        "import javax.inject.Inject;",
-        "",
-        "final class A extends B {",
-        "  @Inject NoDepClass dep;",
-        "}");
-    JavaFileObject bClassFile = JavaFileObjects.forSourceLines("foreign.B",
-        "package foreign;",
-        "",
-        "import test.NoDepClass;",
-        "import javax.inject.Inject;",
-        "",
-        "public class B extends C {",
-        "  @Inject NoDepClass dep;",
-        "}");
-    JavaFileObject cClassFile = JavaFileObjects.forSourceLines("foreign.C",
-        "package foreign;",
-        "",
-        "import test.D;",
-        "import test.NoDepClass;",
-        "import javax.inject.Inject;",
-        "",
-        "class C extends D {",
-        "  @Inject NoDepClass dep;",
-        "}");
-    JavaFileObject dClassFile = JavaFileObjects.forSourceLines("test.D",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public class D {",
-        "  @Inject NoDepClass dep;",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  void injectA(A a);",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import foreign.B_MembersInjector;",
-            "import foreign.C_MembersInjector;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  @Override",
-            "  public void injectA(A a) {",
-            "    injectA2(a);",
-            "  }",
-            "",
-            "  @CanIgnoreReturnValue",
-            "  private A injectA2(A instance) {",
-            "    D_MembersInjector.injectDep(instance, new NoDepClass());",
-            "    C_MembersInjector.injectDep(instance, new NoDepClass());",
-            "    B_MembersInjector.injectDep(instance, new NoDepClass());",
-            "    A_MembersInjector.injectDep(instance, new NoDepClass());",
-            "    return instance;",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(
-                FluentIterable.from(compilerMode.javacopts())
-                    .append(
-                        "-Xlint:-processing",
-                        "-Xlint:rawtypes",
-                        "-Xlint:unchecked",
-                        "-Xlint:-classfile"))
-            .compile(
-                noDepClassFile,
-                aClassFile, bClassFile, cClassFile, dClassFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .containsElementsIn(generatedComponent);
-  }
-}
diff --git a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 7941803af..f8baa6059 100644
--- a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -1101,54 +1101,6 @@
         .generatesSources(expectedFactory);
   }
 
-  @Test
-  public void neitherTypeNorSupertypeRequiresMemberInjection() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "class A {}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class B extends A {",
-        "  @Inject B() {}",
-        "}");
-    JavaFileObject expectedFactory =
-        JavaFileObjects.forSourceLines(
-            "test.B_Factory",
-            "package test;",
-            "",
-            "import dagger.internal.Factory;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public final class B_Factory implements Factory<B> {",
-            "  private static final B_Factory INSTANCE = new B_Factory();",
-            "",
-            "  @Override public B get() {",
-            "    return provideInstance();",
-            "  }",
-            "",
-            "  public static B provideInstance() {",
-            "    return new B();",
-            "  }",
-            "",
-            "  public static B_Factory create() {",
-            "    return INSTANCE;",
-            "  }",
-            "",
-            "  public static B newB() {",
-            "    return new B();",
-            "  }",
-            "}");
-    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(expectedFactory);
-  }
-
   @Test
   public void wildcardDependency() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
@@ -1454,10 +1406,6 @@ public void noDeps() {
         "  static class B {",
         "    @Inject A a;",
         "  }",
-        "  @Component interface SimpleComponent {",
-        "    A a();",
-        "    void inject(B b);",
-        "  }",
         "}");
     JavaFileObject aFactory =
         JavaFileObjects.forSourceLines(
diff --git a/javatests/dagger/internal/codegen/MapKeyProcessorTest.java b/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
index 9d0c50b36..746c60d17 100644
--- a/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -17,18 +17,12 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
-import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
 import com.google.auto.value.processor.AutoAnnotationProcessor;
 import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
@@ -147,299 +141,4 @@ public void nestedMapKeyCreatorFile() {
         .and()
         .generatesSources(generatedKeyCreator);
   }
-
-  @Test
-  public void mapKeyComponentFileWithDisorderedKeyField() {
-    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleOne {",
-        "  @Provides",
-        "  @IntoMap",
-        "  @PathKey(relativePath = \"AdminPath\", value = PathEnum.ADMIN)",
-        "  Handler provideAdminHandler() {",
-        "    return new AdminHandler();",
-        "  }",
-        "}");
-    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleTwo {",
-        "  @Provides",
-        "  @IntoMap",
-        "  @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
-        "  Handler provideLoginHandler() {",
-        "    return new LoginHandler();",
-        "  }",
-        "}");
-    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "@MapKey(unwrapValue = false)",
-        "@Retention(RUNTIME)",
-        "public @interface PathKey {",
-        "  PathEnum value();",
-        "  String relativePath() default \"DefaultPath\";",
-        "}");
-    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
-        "package test;",
-        "",
-        "public enum PathEnum {",
-        "    ADMIN,",
-        "    LOGIN;",
-        "}");
-    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
-        "package test;",
-        "",
-        "interface Handler {}");
-    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
-        "package test;",
-        "",
-        "class LoginHandler implements Handler {",
-        "  public LoginHandler() {}",
-        "}");
-    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
-        "package test;",
-        "",
-        "class AdminHandler implements Handler {",
-        "  public AdminHandler() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.Map;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
-        "interface TestComponent {",
-        "  Map<PathKey, Provider<Handler>> dispatcher();",
-        "}");
-    JavaFileObject generatedComponent =
-        new JavaFileBuilder(compilerMode, "test.DaggerTestComponent")
-            .addLines(
-                "package test;",
-                "",
-                GENERATED_ANNOTATION,
-                "public final class DaggerTestComponent implements TestComponent {")
-            .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
-                "  @Override",
-                "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-                "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
-                "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
-                "        getMapOfPathKeyAndProviderOfHandlerProvider(),",
-                "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-                "        getMapOfPathKeyAndProviderOfHandlerProvider2());",
-                "  }")
-            .addLinesIn(
-                DEFAULT_MODE,
-                "  @Override",
-                "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-                "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
-                "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
-                "        provideAdminHandlerProvider,",
-                "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-                "        provideLoginHandlerProvider);",
-                "  }")
-            .addLines("}")
-            .build();
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(
-                mapModuleOneFile,
-                mapModuleTwoFile,
-                enumKeyFile,
-                pathEnumFile,
-                handlerFile,
-                loginHandlerFile,
-                adminHandlerFile,
-                componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .containsElementsIn(generatedComponent);
-  }
-
-  @Test
-  public void mapKeyComponentFileWithDefaultField() {
-    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleOne {",
-        "  @Provides",
-        "  @IntoMap",
-        "  @PathKey(value = PathEnum.ADMIN) Handler provideAdminHandler() {",
-        "    return new AdminHandler();",
-        "  }",
-        "}");
-    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleTwo {",
-        "  @Provides",
-        "  @IntoMap",
-        "  @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
-        "  Handler provideLoginHandler() {",
-        "    return new LoginHandler();",
-        "  }",
-        "}");
-    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "@MapKey(unwrapValue = false)",
-        "@Retention(RUNTIME)",
-        "public @interface PathKey {",
-        "  PathEnum value();",
-        "  String relativePath() default \"DefaultPath\";",
-        "}");
-    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
-        "package test;",
-        "",
-        "public enum PathEnum {",
-        "    ADMIN,",
-        "    LOGIN;",
-        "}");
-    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
-        "package test;",
-        "",
-        "interface Handler {}");
-    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
-        "package test;",
-        "",
-        "class LoginHandler implements Handler {",
-        "  public LoginHandler() {}",
-        "}");
-    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
-        "package test;",
-        "",
-        "class AdminHandler implements Handler {",
-        "  public AdminHandler() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.Map;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
-        "interface TestComponent {",
-        "  Map<PathKey, Provider<Handler>> dispatcher();",
-        "}");
-    JavaFileObject generatedComponent =
-        new JavaFileBuilder(compilerMode, "test.DaggerTestComponent")
-            .addLines(
-                "package test;",
-                "",
-                GENERATED_ANNOTATION,
-                "public final class DaggerTestComponent implements TestComponent {")
-            .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
-                "  @Override",
-                "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-                "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
-                "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
-                "        getMapOfPathKeyAndProviderOfHandlerProvider(),",
-                "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-                "        getMapOfPathKeyAndProviderOfHandlerProvider2());",
-                "  }")
-            .addLinesIn(
-                DEFAULT_MODE,
-                "  @Override",
-                "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-                "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
-                "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
-                "        provideAdminHandlerProvider,",
-                "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-                "        provideLoginHandlerProvider);",
-                "  }")
-            .addLines("}")
-            .build();
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions(compilerMode.javacopts())
-            .compile(
-                mapModuleOneFile,
-                mapModuleTwoFile,
-                enumKeyFile,
-                pathEnumFile,
-                handlerFile,
-                loginHandlerFile,
-                adminHandlerFile,
-                componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .containsElementsIn(generatedComponent);
-  }
-
-  @Test
-  public void mapKeyWithDefaultValue() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.MapModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "",
-            "@Module",
-            "final class MapModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @BoolKey int provideFalseValue() {",
-            "    return -1;",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoMap",
-            "  @BoolKey(true) int provideTrueValue() {",
-            "    return 1;",
-            "  }",
-            "}");
-    JavaFileObject mapKey =
-        JavaFileObjects.forSourceLines(
-            "test.BoolKey",
-            "package test;",
-            "",
-            "import dagger.MapKey;",
-            "",
-            "@MapKey",
-            "@interface BoolKey {",
-            "  boolean value() default false;",
-            "}");
-    assertThat(module, mapKey)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-        .compilesWithoutError();
-  }
 }
