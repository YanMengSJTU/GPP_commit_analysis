diff --git a/android/pom.xml b/android/pom.xml
index 510ecd1ec..b57b6428c 100644
--- a/android/pom.xml
+++ b/android/pom.xml
@@ -59,6 +59,11 @@
       <groupId>com.android.support</groupId>
       <artifactId>support-annotations</artifactId>
     </dependency>
+      <dependency>
+          <groupId>com.google.android</groupId>
+          <artifactId>android</artifactId>
+          <version>4.1.1.4</version>
+      </dependency>
   </dependencies>
 
   <build>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index e266539e5..58e262f26 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -829,8 +829,8 @@ private void implementInterfaceMethods() {
               if (supportsTestDelegate) {
                 final ClassName delegateTypeName = Util.getDelegateTypeName(interfaceRequest.key());
                 final String fieldName = Util.getDelegateFieldName(interfaceRequest.key());
-                builder.beginControlFlow("if ($S != null)", fieldName)
-                        .add("return $S.get($L)", fieldName, codeBlock)
+                builder.beginControlFlow("if ($L != null)", CodeBlock.of(fieldName))
+                        .add("return $L.get($L)", CodeBlock.of(fieldName), codeBlock)
                         .nextControlFlow("else");
               }
               interfaceMethod.addStatement("return $L", codeBlock);
diff --git a/compiler/src/main/java/dagger/internal/codegen/DI.java b/compiler/src/main/java/dagger/internal/codegen/DI.java
index 3e3c04816..2713b07e6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DI.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DI.java
@@ -1,9 +1,8 @@
 package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
 
-import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import java.util.List;
 
@@ -12,23 +11,29 @@
  */
 public class DI {
     private final TypeElement injector;
-    private final List<InjectorType> injectors;
+    private List<ExecutableElement> methods;
+    private List<InjectorType> injectorTypes;
 
-    public DI(TypeElement injector, List<InjectorType> injectors) {
+    public DI(TypeElement injector, List<ExecutableElement> methods, List<InjectorType> injectorTypes) {
         this.injector = injector;
-        this.injectors = injectors;
+        this.methods = methods;
+        this.injectorTypes = injectorTypes;
     }
 
     public TypeElement getInjector() {
         return injector;
     }
 
-    public List<InjectorType> getInjectors() {
-        return ImmutableList.copyOf(injectors);
-    }
-
     public ClassName getClassName() {
         final ClassName className = ClassName.bestGuess(injector.asType().toString());
         return ClassName.bestGuess(className.packageName() + "." + "Test" + className.simpleName());
     }
+
+    public List<ExecutableElement> getMethods() {
+        return methods;
+    }
+
+    public List<InjectorType> getInjectorTypes() {
+        return injectorTypes;
+    }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 1f79703a1..a207aaa3f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -246,10 +246,11 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             .addAnnotation(Override.class)
             .addModifiers(PUBLIC);
 
+    final CodeBlock codeBlock = CodeBlock.of(getDelegateFieldName(binding.key()));
     if (binding.bindingKind().equals(PROVISION)) {
       final String delegateFieldName = Util.getDelegateFieldName(binding.key());
-      getMethodBuilder.beginControlFlow("if ($S != null)", delegateFieldName);
-      getMethodBuilder.addStatement("return $S.get($L)", delegateFieldName, parametersCodeBlock);
+      getMethodBuilder.beginControlFlow("if ($L != null)", CodeBlock.of(delegateFieldName));
+      getMethodBuilder.addStatement("return $L.get($L)", CodeBlock.of(delegateFieldName), parametersCodeBlock);
       getMethodBuilder.nextControlFlow("else");
       CodeBlock.Builder providesMethodInvocationBuilder = CodeBlock.builder();
       if (binding.requiresModuleInstance()) {
@@ -279,11 +280,12 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
       }*/
     } else if (binding.membersInjectionRequest().isPresent()) {
 
-      getMethodBuilder.beginControlFlow("if (delegate != null)");
+      getMethodBuilder.beginControlFlow("if ($L != null)", codeBlock);
       getMethodBuilder.addStatement(
-              "return $T.injectMembers($N, delegate.get($L))",
+              "return $T.injectMembers($N, $L.get($L))",
               MembersInjectors.class,
               fields.get(binding.membersInjectionRequest().get().bindingKey()),
+              codeBlock,
               parametersCodeBlock);
       getMethodBuilder.nextControlFlow("else");
       getMethodBuilder.addStatement(
@@ -294,8 +296,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           parametersCodeBlock);
       getMethodBuilder.endControlFlow();
     } else {
-      getMethodBuilder.beginControlFlow("if (delegate != null)");
-      getMethodBuilder.addStatement("return delegate.get($L)", parametersCodeBlock);
+      getMethodBuilder.beginControlFlow("if ($L != null)", codeBlock);
+      getMethodBuilder.addStatement("return $L.get($L)", codeBlock, parametersCodeBlock);
       getMethodBuilder.nextControlFlow("else");
       getMethodBuilder.addStatement("return new $T($L)", providedTypeName, parametersCodeBlock);
       getMethodBuilder.endControlFlow();
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
index edcc0b69c..f642b728a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
@@ -2,11 +2,21 @@
 
 import com.google.common.base.Optional;
 import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
 
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Consumer;
+
+import static dagger.internal.codegen.Util.createDelegateFieldAndMethod;
 
 /**
  * Created by Andy on 05.05.2017.
@@ -29,7 +39,30 @@ ClassName nameGeneratedType(DI input) {
 
     @Override
     Optional<TypeSpec.Builder> write(ClassName generatedTypeName, DI input) {
-        return null;
+        final TypeElement injector = input.getInjector();
+        final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName)
+                .superclass(ClassName.get(injector))
+                .addModifiers(Modifier.PUBLIC);
+
+
+        for (ExecutableElement executableElement : input.getMethods()) {
+            final MethodSpec.Builder method = MethodSpec.overriding(executableElement);
+            method.addStatement("return null");
+            builder.addMethod(method.build());
+        }
+
+        Map<Key, String> delegateFieldNames = new HashMap<>();
+        for (InjectorType injectorType : input.getInjectorTypes()) {
+            injectorType.getBindingGraph().resolvedBindings().values().forEach(resolvedBindings -> {
+                if (resolvedBindings.bindingType() == BindingType.PROVISION) {
+                    if (!delegateFieldNames.containsKey(resolvedBindings.key())) {
+                        createDelegateFieldAndMethod(generatedTypeName, builder, resolvedBindings, delegateFieldNames);
+                    }
+                }
+            });
+        }
+
+        return Optional.of(builder);
     }
 
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
index b78779497..98a783f57 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
@@ -1,30 +1,76 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
+import dagger.Component;
 import dagger.Injector;
 import dagger.ProvidesComponent;
 
 import javax.annotation.processing.Messager;
+import javax.inject.Inject;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import java.lang.annotation.Annotation;
-import java.util.Set;
+import java.lang.reflect.Executable;
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
 
 /**
  * Created by Andy on 05.05.2017.
  */
 public class InjectorProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+
+    private final Messager messager;
+    private final InjectorGenerator injectorGenerator;
+    private final ComponentDescriptor.Kind component;
+    private final BindingGraph.Factory bindingGraphFactory;
+    private final ComponentDescriptor.Factory componentDescriptorFactory;
+
     public InjectorProcessingStep(Messager messager, InjectorGenerator injectorGenerator, ComponentDescriptor.Kind component, BindingGraph.Factory bindingGraphFactory, ComponentDescriptor.Factory componentDescriptorFactory) {
+        this.messager = messager;
+        this.injectorGenerator = injectorGenerator;
+        this.component = component;
+        this.bindingGraphFactory = bindingGraphFactory;
+        this.componentDescriptorFactory = componentDescriptorFactory;
     }
 
     @Override
     public Set<? extends Class<? extends Annotation>> annotations() {
-        return ImmutableSet.of(ProvidesComponent.class, Injector.class);
+        return ImmutableSet.of(ProvidesComponent.class, Injector.class, Component.class);
     }
 
     @Override
-    public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> setMultimap) {
-        return null;
+    public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+        final Iterator<Element> it = elementsByAnnotation.get(Injector.class).iterator();
+        if (!it.hasNext()) {
+            return ImmutableSet.of();
+        }
+        final Set<Element> elements = elementsByAnnotation.get(ProvidesComponent.class);
+        final List<ExecutableElement> methods = elements.stream()
+                .map(element -> (ExecutableElement) element)
+                .collect(Collectors.toList());
+
+        TypeElement injector = MoreElements.asType(it.next());
+        Set<Element> rejectedElements = new LinkedHashSet<>();
+        List<InjectorType> injectorTypeList = new ArrayList<>();
+        for (Element element : elementsByAnnotation.get(component.annotationType())) {
+            TypeElement componentTypeElement = MoreElements.asType(element);
+            try {
+                ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(componentTypeElement);
+                BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+                InjectorType injectorType = new InjectorType(componentTypeElement, bindingGraph);
+                injectorTypeList.add(injectorType);
+            } catch (TypeNotPresentException e) {
+                rejectedElements.add(componentTypeElement);
+            }
+        }
+        final DI di = new DI(injector, methods, injectorTypeList);
+        this.injectorGenerator.generate(di, messager);
+        return rejectedElements;
     }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorType.java b/compiler/src/main/java/dagger/internal/codegen/InjectorType.java
index 7670aec62..9bca59b73 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorType.java
@@ -1,17 +1,25 @@
 package dagger.internal.codegen;
 
+import javax.lang.model.element.TypeElement;
+
 /**
  * Created by Andy on 05.05.2017.
  */
 public class InjectorType {
 
+    private TypeElement element;
     private BindingGraph bindingGraph;
 
-    public InjectorType(BindingGraph bindingGraph) {
+    public InjectorType(TypeElement element, BindingGraph bindingGraph) {
+        this.element = element;
         this.bindingGraph = bindingGraph;
     }
 
     public BindingGraph getBindingGraph() {
         return bindingGraph;
     }
+
+    public TypeElement getElement() {
+        return element;
+    }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
index fe9f1b920..7a23b068b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
@@ -2,16 +2,19 @@
 
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.*;
 
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import java.lang.annotation.Annotation;
-import java.util.Set;
+import java.util.*;
+
+import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 
 
 public class StubGenerator extends SourceFileGenerator<ProvisionBinding> {
@@ -35,6 +38,24 @@ ClassName nameGeneratedType(ProvisionBinding input) {
 
     @Override
     Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProvisionBinding input) {
-        return null;
+        final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("get");
+        methodBuilder.addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);
+        methodBuilder.returns(ClassName.get(input.contributedType()));
+        List<ParameterSpec> parameterSpecList = new ArrayList<>();
+        HashMap<BindingKey, FrameworkField> fields = new HashMap<>();
+        for (Map.Entry<BindingKey, FrameworkField> entry : generateBindingFieldsForDependencies(input).entrySet()) {
+            FrameworkField bindingField = entry.getValue();
+            fields.put(entry.getKey(), bindingField);
+        }
+
+        for (DependencyRequest request : input.explicitDependencies()) {
+            final FrameworkField frameworkField = fields.get(request.bindingKey());
+            TypeName typeName = request.kind() == DependencyRequest.Kind.INSTANCE ? frameworkField.type().typeArguments.get(0) : frameworkField.type();
+            parameterSpecList.add(ParameterSpec.builder(typeName, frameworkField.name()).build());
+        }
+
+        return Optional.of(TypeSpec.interfaceBuilder(generatedTypeName)
+                .addModifiers(Modifier.PUBLIC)
+                .addMethod(methodBuilder.addParameters(parameterSpecList).build()));
     }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 309f4c319..d97287bd6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -34,10 +34,7 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.FieldSpec;
-import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.*;
 import dagger.Binds;
 import dagger.Provides;
 import dagger.producers.Produces;
@@ -242,7 +239,7 @@ static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
 
   static ClassName getDelegateTypeName(Key key) {
     final ClassName topLevelClassName = getTopLevelClassName(key.type());
-    if (key.qualifier().isPresent()) {
+    if (key.qualifier().isPresent() && key.qualifier().get().getAnnotationType().asElement().asType().toString().equals(Named.class.getName())) {
       final AnnotationMirror annotationMirror = key.qualifier().get();
       String value = "";
       for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationMirror.getElementValues().entrySet()) {
@@ -259,7 +256,7 @@ static ClassName getDelegateTypeName(Key key) {
 
   static String getDelegateFieldName(Key key) {
 
-    if (key.qualifier().isPresent()) {
+    if (key.qualifier().isPresent() && key.qualifier().get().getAnnotationType().asElement().asType().toString().equals(Named.class.getName())) {
       final AnnotationMirror annotationMirror = key.qualifier().get();
       String value = "";
       for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationMirror.getElementValues().entrySet()) {
@@ -347,21 +344,37 @@ public static void createDelegateFieldAndMethod(ClassName generatedTypeName, Typ
           final FrameworkField contributionBindingField = FrameworkField.forResolvedBindings(resolvedBindings, Optional.absent());
           ContributionBinding binding = resolvedBindings.contributionBinding();
           if (supportsTestDelegate(binding)) {
-              final String delegateFieldName = contributionBindingField.name() + "Delegate";
+              final String delegateFieldName = Util.getDelegateFieldName(resolvedBindings.binding().key());
               final ClassName delegateType = getDelegateTypeName(resolvedBindings.binding().key());
               final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
               delegateFieldNames.put(resolvedBindings.key(), delegateFieldName);
               final FieldSpec fieldSpec = builder.build();
               classBuilder.addField(fieldSpec);
-              final String methodName = "with" + delegateType.simpleName().toString();
+            final String methodName = "with" + delegateType.simpleName();
               classBuilder.addMethod(MethodSpec.methodBuilder(methodName)
                       .addModifiers(Modifier.PUBLIC)
                       .returns(generatedTypeName)
-                      .addParameter(delegateType, "delegate")
-                      .addStatement("this.$N = delegate", fieldSpec)
+                      .addParameter(delegateType, delegateFieldName)
+                      .addStatement("this.$N = $L", fieldSpec, CodeBlock.of(delegateFieldName))
                       .addStatement("return this")
                       .build());
           }
       }catch(Exception e) {}
   }
+
+  public static String getFieldName(Key key) {
+    if (key.qualifier().isPresent()) {
+      final AnnotationMirror annotationMirror = key.qualifier().get();
+      String value = "";
+      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationMirror.getElementValues().entrySet()) {
+        if (entry.getKey().getSimpleName().toString().equals("value")) {
+          value = entry.getValue().getValue().toString();
+          break;
+        }
+      }
+      return  capitalizeFirstLetter(value);
+    }else {
+      return capitalizeFirstLetter(ClassName.bestGuess(key.type().toString()).simpleName());
+    }
+  }
 }
diff --git a/core/pom.xml b/core/pom.xml
index a665d1297..a2c524533 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -127,6 +127,14 @@
           </execution>
         </executions>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <source>1.8</source>
+          <target>1.8</target>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
