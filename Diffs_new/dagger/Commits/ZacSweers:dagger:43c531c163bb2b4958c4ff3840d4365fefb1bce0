diff --git a/java/dagger/internal/codegen/ComponentModelBuilder.java b/java/dagger/internal/codegen/ComponentModelBuilder.java
index 07627c485..8e22d53bc 100644
--- a/java/dagger/internal/codegen/ComponentModelBuilder.java
+++ b/java/dagger/internal/codegen/ComponentModelBuilder.java
@@ -233,17 +233,11 @@ private void addSubcomponents() {
   }
 
   private GeneratedComponentModel buildAbstractInnerSubcomponentModel(BindingGraph childGraph) {
-    ClassName childName =
-        generatedComponentModel
-            .name()
-            .nestedClass(
-                generatedComponentModel.getSubcomponentName(childGraph.componentDescriptor())
-                    + "Impl");
     GeneratedComponentModel supermodel =
         getSubcomponentSupermodel(childGraph.componentDescriptor());
     GeneratedComponentModel childModel =
         GeneratedComponentModel.forAbstractSubcomponent(
-            childName, supermodel, generatedComponentModel);
+            childGraph.componentDescriptor(), supermodel, generatedComponentModel);
     Optional<GeneratedComponentBuilderModel> childBuilderModel =
         GeneratedComponentBuilderModel.create(childModel, childGraph, elements, types);
     ComponentRequirementFields childComponentRequirementFields =
@@ -300,12 +294,9 @@ private GeneratedComponentModel getSubcomponentSupermodel(ComponentDescriptor su
   }
 
   private GeneratedComponentModel buildSubcomponentModel(BindingGraph childGraph) {
-    ClassName parentName = generatedComponentModel.name();
-    ClassName childName =
-        parentName.nestedClass(
-            generatedComponentModel.getSubcomponentName(childGraph.componentDescriptor()) + "Impl");
     GeneratedComponentModel childModel =
-        GeneratedComponentModel.forSubcomponent(childName, generatedComponentModel);
+        GeneratedComponentModel.forSubcomponent(
+            childGraph.componentDescriptor(), generatedComponentModel);
     Optional<GeneratedComponentBuilderModel> childBuilderModel =
         GeneratedComponentBuilderModel.create(childModel, childGraph, elements, types);
     ComponentRequirementFields childComponentRequirementFields =
diff --git a/java/dagger/internal/codegen/GeneratedComponentBuilderModel.java b/java/dagger/internal/codegen/GeneratedComponentBuilderModel.java
index 75b430863..be60d02a3 100644
--- a/java/dagger/internal/codegen/GeneratedComponentBuilderModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentBuilderModel.java
@@ -97,7 +97,6 @@ private static boolean hasBuilder(ComponentDescriptor component) {
     private final BindingGraph graph;
     private final TypeSpec.Builder builder;
     private final GeneratedComponentModel generatedComponentModel;
-    private final ClassName builderName;
     private final Elements elements;
     private final Types types;
 
@@ -107,23 +106,16 @@ private static boolean hasBuilder(ComponentDescriptor component) {
         Elements elements,
         Types types) {
       this.generatedComponentModel = generatedComponentModel;
-      ClassName componentName = generatedComponentModel.name();
-      if (!generatedComponentModel.isNested()) {
-        builderName = componentName.nestedClass("Builder");
-        builder = classBuilder(builderName).addModifiers(STATIC);
-      } else {
-        builderName =
-            componentName.peerClass(
-                generatedComponentModel.getSubcomponentName(graph.componentDescriptor())
-                    + "Builder");
-        builder = classBuilder(builderName);
-      }
+      this.builder = classBuilder(generatedComponentModel.getBuilderName());
       this.graph = graph;
       this.elements = elements;
       this.types = types;
     }
 
     GeneratedComponentBuilderModel create() {
+      if (!generatedComponentModel.isNested()) {
+        builder.addModifiers(STATIC);
+      }
       if (builderSpec().isPresent()) {
         if (generatedComponentModel.isAbstract()) {
           builder.addModifiers(PROTECTED);
@@ -150,27 +142,15 @@ GeneratedComponentBuilderModel create() {
           // compile-testing tests that rely on the order of the methods
           .addMethods(builderMethods(builderFields));
 
-      return new GeneratedComponentBuilderModel(builder.build(), builderName, builderFields);
+      return new GeneratedComponentBuilderModel(
+          builder.build(), generatedComponentModel.getBuilderName(), builderFields);
     }
 
     /** Set the superclass being extended or interface being implemented for this builder. */
     private void setSupertype() {
       if (generatedComponentModel.supermodel().isPresent()) {
         // If there's a superclass, extend the Builder defined there.
-        GeneratedComponentModel subcomponentSupermodel = generatedComponentModel.supermodel().get();
-        if (subcomponentSupermodel.isNested()) {
-          // If the subcomponent superclass is nested we're overriding the builder that was
-          // defined as a peer of the superclass.
-          builder.superclass(
-              subcomponentSupermodel
-                  .name()
-                  .peerClass(
-                      subcomponentSupermodel.getSubcomponentName(graph.componentDescriptor())
-                          + "Builder"));
-        } else {
-          // Otherwise we're extending the builder defined inside the subcomponent definition.
-          builder.superclass(subcomponentSupermodel.name().nestedClass("Builder"));
-        }
+        builder.superclass(generatedComponentModel.supermodel().get().getBuilderName());
       } else {
         addSupertype(builder, builderSpec().get().builderDefinitionType());
       }
@@ -289,7 +269,7 @@ private MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> bui
           String componentRequirementName = simpleVariableName(componentRequirement.typeElement());
           MethodSpec.Builder builderMethod =
               methodBuilder(componentRequirementName)
-                  .returns(builderName)
+                  .returns(generatedComponentModel.getBuilderName())
                   .addModifiers(PUBLIC)
                   .addParameter(
                       TypeName.get(componentRequirement.type()), componentRequirementName);
@@ -322,7 +302,7 @@ private MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> bui
       // Otherwise we use the generated builder name and take advantage of covariant returns
       // (so that we don't have to worry about setter methods that return type variables).
       if (!returnType.getKind().equals(VOID)) {
-        builderMethod.returns(builderName);
+        builderMethod.returns(generatedComponentModel.getBuilderName());
       }
       return builderMethod;
     }
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index adae1f195..0728828b7 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -134,6 +134,7 @@
     SUBCOMPONENT
   }
 
+  private final ComponentDescriptor componentDescriptor;
   private final ClassName name;
   private final NestingKind nestingKind;
   private final boolean isAbstract;
@@ -156,12 +157,14 @@
       HashMultimap.create();
 
   private GeneratedComponentModel(
+      ComponentDescriptor componentDescriptor,
       ClassName name,
       NestingKind nestingKind,
       Optional<GeneratedComponentModel> supermodel,
       SubcomponentNames subcomponentNames,
       Modifier... modifiers) {
     checkName(name, nestingKind);
+    this.componentDescriptor = componentDescriptor;
     this.name = name;
     this.nestingKind = nestingKind;
     this.isAbstract = Arrays.asList(modifiers).contains(ABSTRACT);
@@ -190,6 +193,7 @@ private static void checkName(ClassName name, NestingKind nestingKind) {
   /** Creates a model for a root component or top-level abstract subcomponent. */
   static GeneratedComponentModel create(ClassName name, BindingGraph graph, KeyFactory keyFactory) {
     return new GeneratedComponentModel(
+        graph.componentDescriptor(),
         name,
         NestingKind.TOP_LEVEL,
         Optional.empty(), // supermodel
@@ -203,9 +207,10 @@ static GeneratedComponentModel create(ClassName name, BindingGraph graph, KeyFac
    * generating ahead-of-time subcomponents.
    */
   static GeneratedComponentModel forSubcomponent(
-      ClassName name, GeneratedComponentModel parentModel) {
+      ComponentDescriptor componentDescriptor, GeneratedComponentModel parentModel) {
     return new GeneratedComponentModel(
-        name,
+        componentDescriptor,
+        parentModel.getSubcomponentName(componentDescriptor),
         NestingKind.MEMBER,
         Optional.empty(), // supermodel
         parentModel.subcomponentNames,
@@ -218,9 +223,12 @@ static GeneratedComponentModel forSubcomponent(
    * generating ahead-of-time subcomponents.
    */
   static GeneratedComponentModel forAbstractSubcomponent(
-      ClassName name, GeneratedComponentModel supermodel, GeneratedComponentModel parentModel) {
+      ComponentDescriptor componentDescriptor,
+      GeneratedComponentModel supermodel,
+      GeneratedComponentModel parentModel) {
     return new GeneratedComponentModel(
-        name,
+        componentDescriptor,
+        parentModel.getSubcomponentName(componentDescriptor),
         NestingKind.MEMBER,
         Optional.of(supermodel),
         parentModel.subcomponentNames,
@@ -228,6 +236,11 @@ static GeneratedComponentModel forAbstractSubcomponent(
         ABSTRACT);
   }
 
+  /** Returns the descriptor for the component being generated. */
+  ComponentDescriptor componentDescriptor() {
+    return componentDescriptor;
+  }
+
   /** Returns the name of the component. */
   ClassName name() {
     return name;
@@ -248,9 +261,24 @@ boolean isAbstract() {
     return supermodel;
   }
 
-  /** Returns the simple subcomponent name for the given {@link ComponentDescriptor}. */
-  String getSubcomponentName(ComponentDescriptor componentDescriptor) {
-    return subcomponentNames.get(componentDescriptor);
+  /**
+   * Returns the name of the builder class for this component. It will be a sibling of this
+   * generated class unless this is a top-level component, in which case it will be nested.
+   */
+  ClassName getBuilderName() {
+    return isNested()
+        ? name.peerClass(subcomponentNames.get(componentDescriptor) + "Builder")
+        : name.nestedClass("Builder");
+  }
+
+  /** Returns the name of the nested implementation class for a child component. */
+  private ClassName getSubcomponentName(ComponentDescriptor childDescriptor) {
+    checkArgument(
+        componentDescriptor.subcomponents().contains(childDescriptor),
+        "%s is not a child of %s",
+        childDescriptor.componentDefinitionType(),
+        componentDescriptor.componentDefinitionType());
+    return name.nestedClass(subcomponentNames.get(childDescriptor) + "Impl");
   }
 
   /** Returns the simple subcomponent name for the given subcomponent builder {@link Key}. */
