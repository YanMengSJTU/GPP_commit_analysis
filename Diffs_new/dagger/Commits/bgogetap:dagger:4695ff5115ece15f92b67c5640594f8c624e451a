diff --git a/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index 982ed531f..521be5293 100644
--- a/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -22,12 +22,15 @@
 import static com.google.common.base.Predicates.not;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.Scopes.getReadableSource;
+import static dagger.internal.codegen.Scopes.uniqueScopeOf;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Maps;
@@ -60,6 +63,7 @@
         report,
         componentDescriptor,
         Maps.toMap(componentDescriptor.moduleTypes(), constant(componentDescriptor.typeElement())));
+    validateRepeatedScopedDeclarations(report, componentDescriptor, LinkedHashMultimap.create());
 
     if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
       validateScopeHierarchy(
@@ -198,4 +202,67 @@ private void validateProductionModuleUniqueness(
 
     report.addError(error.toString());
   }
+
+  private void validateRepeatedScopedDeclarations(
+      ValidationReport.Builder<TypeElement> report,
+      ComponentDescriptor component,
+      // TODO(ronshapiro): optimize ModuleDescriptor.hashCode()/equals. Otherwise this could be
+      // quite costly
+      SetMultimap<ComponentDescriptor, ModuleDescriptor> modulesWithScopes) {
+    ImmutableSet<ModuleDescriptor> modules =
+        component.modules().stream().filter(this::hasScopedDeclarations).collect(toImmutableSet());
+    modulesWithScopes.putAll(component, modules);
+    for (ComponentDescriptor childComponent : component.childComponents()) {
+      validateRepeatedScopedDeclarations(report, childComponent, modulesWithScopes);
+    }
+    modulesWithScopes.removeAll(component);
+
+    SetMultimap<ComponentDescriptor, ModuleDescriptor> repeatedModules =
+        Multimaps.filterValues(modulesWithScopes, modules::contains);
+    if (repeatedModules.isEmpty()) {
+      return;
+    }
+
+    report.addError(
+        repeatedModulesWithScopeError(component, ImmutableSetMultimap.copyOf(repeatedModules)));
+  }
+
+  private boolean hasScopedDeclarations(ModuleDescriptor module) {
+    return !moduleScopes(module).isEmpty();
+  }
+
+  private String repeatedModulesWithScopeError(
+      ComponentDescriptor component,
+      ImmutableSetMultimap<ComponentDescriptor, ModuleDescriptor> repeatedModules) {
+    StringBuilder error =
+        new StringBuilder()
+            .append(component.typeElement().getQualifiedName())
+            .append(" repeats modules with scoped bindings or declarations:");
+
+    repeatedModules
+        .asMap()
+        .forEach(
+            (conflictingComponent, conflictingModules) -> {
+              error
+                  .append("\n  - ")
+                  .append(conflictingComponent.typeElement().getQualifiedName())
+                  .append(" also includes:");
+              for (ModuleDescriptor conflictingModule : conflictingModules) {
+                error
+                    .append("\n    - ")
+                    .append(conflictingModule.moduleElement().getQualifiedName())
+                    .append(" with scopes: ")
+                    .append(COMMA_SEPARATED_JOINER.join(moduleScopes(conflictingModule)));
+              }
+            });
+    return error.toString();
+  }
+
+  private ImmutableSet<Scope> moduleScopes(ModuleDescriptor module) {
+    return FluentIterable.concat(module.allBindingDeclarations())
+        .transform(declaration -> uniqueScopeOf(declaration.bindingElement().get()))
+        .filter(scope -> scope.isPresent() && !scope.get().isReusable())
+        .transform(scope -> scope.get())
+        .toSet();
+  }
 }
diff --git a/java/dagger/internal/codegen/ModuleDescriptor.java b/java/dagger/internal/codegen/ModuleDescriptor.java
index c34c0ef1c..cf59a154d 100644
--- a/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -34,6 +34,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.graph.Traverser;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -45,11 +46,9 @@
 import dagger.model.Key;
 import dagger.multibindings.Multibinds;
 import dagger.producers.Produces;
-import java.util.Collection;
 import java.util.LinkedHashSet;
 import java.util.Optional;
 import java.util.Set;
-import java.util.stream.Stream;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -80,15 +79,21 @@
   /** The kind of the module. */
   abstract ModuleKind kind();
 
+  /** Returns all of the bindings declared in this module. */
+  @Memoized
+  ImmutableSet<BindingDeclaration> allBindingDeclarations() {
+    return ImmutableSet.<BindingDeclaration>builder()
+        .addAll(bindings())
+        .addAll(delegateDeclarations())
+        .addAll(multibindingDeclarations())
+        .addAll(optionalDeclarations())
+        .addAll(subcomponentDeclarations())
+        .build();
+  }
+
   /** Returns the keys of all bindings declared by this module. */
   ImmutableSet<Key> allBindingKeys() {
-    return Stream.of(
-            bindings(),
-            delegateDeclarations(),
-            multibindingDeclarations(),
-            optionalDeclarations(),
-            subcomponentDeclarations())
-        .flatMap(Collection::stream)
+    return allBindingDeclarations().stream()
         .map(BindingDeclaration::key)
         .collect(toImmutableSet());
   }
diff --git a/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java b/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
index 1f232cb3b..19eabac95 100644
--- a/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
+++ b/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
@@ -214,4 +214,136 @@ public void factoryMethodForSubcomponentWithBuilder_isNotAllowed() {
         .hadErrorContaining(
             "Components may not have factory methods for subcomponents that define a builder.");
   }
+
+  @Test
+  public void repeatedModulesWithScopes() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface TestScope {}");
+    JavaFileObject moduleWithScopedProvides =
+        JavaFileObjects.forSourceLines(
+            "test.ModuleWithScopedProvides",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ModuleWithScopedProvides {",
+            "  @Provides",
+            "  @TestScope",
+            "  static Object o() { return new Object(); }",
+            "}");
+    JavaFileObject moduleWithScopedBinds =
+        JavaFileObjects.forSourceLines(
+            "test.ModuleWithScopedBinds",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface ModuleWithScopedBinds {",
+            "  @Binds",
+            "  @TestScope",
+            "  Object o(String s);",
+            "}");
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = {ModuleWithScopedProvides.class, ModuleWithScopedBinds.class})",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(",
+            "    modules = {ModuleWithScopedProvides.class, ModuleWithScopedBinds.class})",
+            "interface Child {}");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(testScope, moduleWithScopedProvides, moduleWithScopedBinds, parent, child);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Child repeats modules with scoped bindings or declarations:",
+                "  - test.Parent also includes:",
+                "    - test.ModuleWithScopedProvides with scopes: @test.TestScope",
+                "    - test.ModuleWithScopedBinds with scopes: @test.TestScope"));
+  }
+
+  @Test
+  public void repeatedModulesWithReusableScope() {
+    JavaFileObject moduleWithScopedProvides =
+        JavaFileObjects.forSourceLines(
+            "test.ModuleWithScopedProvides",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Reusable;",
+            "",
+            "@Module",
+            "class ModuleWithScopedProvides {",
+            "  @Provides",
+            "  @Reusable",
+            "  static Object o() { return new Object(); }",
+            "}");
+    JavaFileObject moduleWithScopedBinds =
+        JavaFileObjects.forSourceLines(
+            "test.ModuleWithScopedBinds",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.Reusable;",
+            "",
+            "@Module",
+            "interface ModuleWithScopedBinds {",
+            "  @Binds",
+            "  @Reusable",
+            "  Object o(String s);",
+            "}");
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = {ModuleWithScopedProvides.class, ModuleWithScopedBinds.class})",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(",
+            "    modules = {ModuleWithScopedProvides.class, ModuleWithScopedBinds.class})",
+            "interface Child {}");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(moduleWithScopedProvides, moduleWithScopedBinds, parent, child);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
 }
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 37983fe60..a07b27bc5 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -596,74 +596,6 @@ public void simpleComponent() {
         .onLine(36);
   }
 
-  @Test
-  public void productionScope_provides() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.producers.ProductionScope;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  @Provides",
-            "  @ProductionScope",
-            "  static int i() {",
-            "    return 1;",
-            "  }",
-            "}");
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "test.Parent",
-            "package test;",
-            "",
-            "import dagger.producers.ProductionComponent;",
-            "",
-            "@ProductionComponent(modules = TestModule.class)",
-            "interface Parent {",
-            "  Child child();",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.producers.ProductionSubcomponent;",
-            "",
-            "@ProductionSubcomponent(modules = TestModule.class)",
-            "interface Child {",
-            "  int i();",
-            "}");
-    Compilation compilation =
-        daggerCompiler().withOptions(compilerMode.javacopts()).compile(module, parent, child);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerParent")
-        .containsElementsIn(
-            new JavaFileBuilder(compilerMode, "test.DaggerRoot")
-                .addLines(
-                    "package test;",
-                    GENERATED_ANNOTATION,
-                    "public final class DaggerParent implements Parent, CancellationListener {",
-                    "  private final class ChildImpl implements Child, CancellationListener {",
-                    "    @Override",
-                    "    public int i() {")
-                .addLinesIn(
-                    CompilerMode.DEFAULT_MODE, //
-                    "      return DaggerParent.this.iProvider.get();")
-                .addLinesIn(
-                    CompilerMode.FAST_INIT_MODE, //
-                    "      return DaggerParent.this.getInteger();")
-                .addLines(
-                    "    }", //
-                    "  }", //
-                    "}")
-                .build());
-  }
-
   @Test
   public void productionScope_injectConstructor() {
     JavaFileObject productionScoped =
