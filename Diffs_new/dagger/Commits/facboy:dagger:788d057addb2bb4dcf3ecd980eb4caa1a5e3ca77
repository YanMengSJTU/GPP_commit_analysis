diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 1d36de555..70971b15b 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -213,7 +213,6 @@ java_library(
         "MemberSelect.java",
         "MembersInjectionBindingExpression.java",
         "MembersInjectionMethods.java",
-        "MembersInjectorFieldInitializer.java",
         "MembersInjectorGenerator.java",
         "MonitoringModuleGenerator.java",
         "MonitoringModuleProcessingStep.java",
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index da8faeff0..15ef307f7 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -16,6 +16,8 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreTypes.isType;
+import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Verify.verify;
@@ -45,6 +47,7 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.common.collect.TreeTraverser;
+import dagger.MembersInjector;
 import dagger.Reusable;
 import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
@@ -520,8 +523,8 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
             ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations =
                 optionalBindingDeclarationsBuilder.build();
 
-            ImmutableSet.Builder<Optional<ContributionBinding>> maybeContributionBindings =
-                ImmutableSet.builder();
+            ImmutableSet.Builder<Optional<? extends ContributionBinding>>
+                maybeContributionBindings = ImmutableSet.builder();
             maybeContributionBindings.add(
                 syntheticMultibinding(
                     requestKey, multibindingContributions, multibindingDeclarations));
@@ -538,9 +541,12 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
              * one. */
             if (contributionBindings.isEmpty()) {
               maybeContributionBindings.add(
-                  injectBindingRegistry
-                      .getOrFindProvisionBinding(requestKey)
-                      .map((ContributionBinding b) -> b));
+                  injectBindingRegistry.getOrFindProvisionBinding(requestKey));
+            }
+
+            if (isType(requestKey.type()) && isTypeOf(MembersInjector.class, requestKey.type())) {
+              maybeContributionBindings.add(
+                  injectBindingRegistry.getOrFindMembersInjectorProvisionBinding(requestKey));
             }
 
             maybeContributionBindings
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index de2063f28..b7a264e5e 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -30,6 +30,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
@@ -129,13 +130,12 @@
 import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor8;
-import javax.lang.model.util.Types;
 
 /** Reports errors in the shape of the binding graph. */
 final class BindingGraphValidator {
 
   private final Elements elements;
-  private final Types types;
+  private final DaggerTypes types;
   private final CompilerOptions compilerOptions;
   private final InjectValidator injectValidator;
   private final InjectBindingRegistry injectBindingRegistry;
@@ -146,7 +146,7 @@
 
   BindingGraphValidator(
       Elements elements,
-      Types types,
+      DaggerTypes types,
       CompilerOptions compilerOptions,
       InjectValidator injectValidator,
       InjectBindingRegistry injectBindingRegistry,
@@ -654,6 +654,8 @@ protected void visitContributionBinding(
         }
         if (binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
           validateMapKeys(binding, owningComponent);
+        } else if (binding.bindingKind().equals(MEMBERS_INJECTOR)) {
+          validateMembersInjectionType(binding);
         }
         super.visitContributionBinding(binding, owningComponent);
       }
@@ -661,7 +663,7 @@ protected void visitContributionBinding(
       @Override
       protected void visitMembersInjectionBinding(
           MembersInjectionBinding binding, ComponentDescriptor owningComponent) {
-        validateMembersInjectionBinding(binding);
+        validateMembersInjectionType(binding);
         super.visitMembersInjectionBinding(binding, owningComponent);
       }
 
@@ -779,21 +781,26 @@ private void validateMapKeyAnnotationTypes(Set<ContributionBinding> mapBindingCo
 
       /** Reports errors if a members injection binding is invalid. */
       // TODO(dpb): Can this be done while validating @Inject?
-      private void validateMembersInjectionBinding(MembersInjectionBinding binding) {
-        binding.key().type().accept(membersInjectionBindingValidator, binding);
+      private void validateMembersInjectionType(Binding binding) {
+        TypeMirror type =
+            binding.bindingType().equals(BindingType.MEMBERS_INJECTION)
+                ? binding.key().type()
+                : types.unwrapType(binding.key().type());
+        type.accept(membersInjectionBindingValidator, binding);
       }
 
-      private final TypeVisitor<Void, MembersInjectionBinding> membersInjectionBindingValidator =
-          new SimpleTypeVisitor8<Void, MembersInjectionBinding>() {
+      private final TypeVisitor<Void, Binding> membersInjectionBindingValidator =
+          new SimpleTypeVisitor8<Void, Binding>() {
             @Override
-            protected Void defaultAction(TypeMirror e, MembersInjectionBinding p) {
+            protected Void defaultAction(TypeMirror e, Binding binding) {
               report(currentGraph())
-                  .addError("Invalid members injection request.", p.membersInjectedType());
+                  .addError(
+                      "Invalid members injection request.", binding.bindingTypeElement().get());
               return null;
             }
 
             @Override
-            public Void visitDeclared(DeclaredType type, MembersInjectionBinding binding) {
+            public Void visitDeclared(DeclaredType type, Binding binding) {
               // If the key has type arguments, validate that each type argument is declared.
               // Otherwise the type argument may be a wildcard (or other type), and we can't
               // resolve that to actual types.  If the arg was an array, validate the type
@@ -1168,7 +1175,7 @@ private boolean doesPathRequireProvisionOnly() {
           case INSTANCE:
           case PROVIDER:
           case LAZY:
-          case MEMBERS_INJECTOR:
+          case MEMBERS_INJECTION:
             return true;
           case PRODUCER:
           case PRODUCED:
diff --git a/java/dagger/internal/codegen/BindingTypeMapper.java b/java/dagger/internal/codegen/BindingTypeMapper.java
index 326b99eb0..173f23715 100644
--- a/java/dagger/internal/codegen/BindingTypeMapper.java
+++ b/java/dagger/internal/codegen/BindingTypeMapper.java
@@ -18,7 +18,6 @@
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.BindingType.CONTRIBUTION_TYPES;
-import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
 import static dagger.internal.codegen.BindingType.PRODUCTION;
 import static dagger.internal.codegen.BindingType.PROVISION;
 
@@ -41,8 +40,6 @@
         case PROVIDER_OF_LAZY:
         case LAZY:
           return PROVISION;
-        case MEMBERS_INJECTOR:
-          return MEMBERS_INJECTION;
         case PRODUCED:
         case PRODUCER:
           throw new IllegalArgumentException(requestKind.toString());
@@ -62,8 +59,6 @@
         case PROVIDER_OF_LAZY:
         case LAZY:
           return PROVISION;
-        case MEMBERS_INJECTOR:
-          return MEMBERS_INJECTION;
         default:
           throw new AssertionError(requestKind);
       }
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 3093c8d02..21e3c4b4b 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -270,7 +270,7 @@ BindingExpression create(BindingKey bindingKey, RequestKind requestKind) {
       ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
       switch (resolvedBindings.bindingType()) {
         case MEMBERS_INJECTION:
-          return membersInjectionBindingExpression(resolvedBindings, requestKind);
+          return membersInjectionBindingExpression(resolvedBindings);
 
         case PROVISION:
           return provisionBindingExpression(resolvedBindings, requestKind);
@@ -285,11 +285,8 @@ BindingExpression create(BindingKey bindingKey, RequestKind requestKind) {
 
     /** Returns a binding expression for a members injection binding. */
     private MembersInjectionBindingExpression membersInjectionBindingExpression(
-        ResolvedBindings resolvedBindings, RequestKind requestKind) {
-      return new MembersInjectionBindingExpression(
-          frameworkInstanceBindingExpression(resolvedBindings, requestKind),
-          generatedComponentModel,
-          membersInjectionMethods);
+        ResolvedBindings resolvedBindings) {
+      return new MembersInjectionBindingExpression(resolvedBindings, membersInjectionMethods);
     }
 
     /**
@@ -331,11 +328,6 @@ private FrameworkFieldInitializer frameworkFieldInitializer(ResolvedBindings res
               compilerOptions,
               graph,
               optionalFactories);
-
-        case MEMBERS_INJECTION:
-          return new MembersInjectorFieldInitializer(
-              resolvedBindings, generatedComponentModel, componentBindingExpressions);
-
         default:
           throw new AssertionError(resolvedBindings);
       }
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index c81f3b1e7..756163706 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -50,7 +50,6 @@
 import dagger.BindsInstance;
 import dagger.Component;
 import dagger.Lazy;
-import dagger.MembersInjector;
 import dagger.Module;
 import dagger.Subcomponent;
 import dagger.model.Scope;
@@ -605,11 +604,6 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
               componentMethod,
               dependencyRequestFactory.forComponentProvisionMethod(
                   componentMethod, resolvedComponentMethod));
-        } else if (MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
-          return ComponentMethodDescriptor.forMembersInjection(
-              componentMethod,
-              dependencyRequestFactory.forComponentMembersInjectionMethod(
-                  componentMethod, resolvedComponentMethod));
         } else if (!getQualifier(componentMethod).isPresent()) {
           Element returnTypeElement = MoreTypes.asElement(returnType);
           if (isSubcomponent(returnTypeElement)) {
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index 15eee20e9..e790bc297 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -128,6 +128,9 @@
     /** An instance of a {@linkplain Component#dependencies() dependency}. */
     COMPONENT_DEPENDENCY,
 
+    /** A binding for a {@link dagger.MembersInjector} of a type. */
+    MEMBERS_INJECTOR,
+
     /**
      * A subcomponent builder method on a component or subcomponent.
      */
diff --git a/java/dagger/internal/codegen/DaggerTypes.java b/java/dagger/internal/codegen/DaggerTypes.java
index 3eb7e12d8..e1979fb04 100644
--- a/java/dagger/internal/codegen/DaggerTypes.java
+++ b/java/dagger/internal/codegen/DaggerTypes.java
@@ -62,6 +62,20 @@
     return Optional.ofNullable(MoreTypes.nonObjectSuperclass(types, elements, type).orNull());
   }
 
+  /**
+   * Returns {@code type}'s single type argument.
+   *
+   * <p>For example, if {@code type} is {@code List<Number>} this will return {@code Number}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not a declared type or has zero or more
+   *     than one type arguments.
+   */
+  TypeMirror unwrapType(TypeMirror type) {
+    TypeMirror unwrapped = unwrapTypeOrDefault(type, null);
+    checkArgument(unwrapped != null, "%s is a raw type", type);
+    return unwrapped;
+  }
+
   /**
    * Returns {@code type}'s single type argument, if one exists, or {@link Object} if not.
    *
@@ -71,15 +85,18 @@
    *     type argument.
    */
   TypeMirror unwrapTypeOrObject(TypeMirror type) {
+    return unwrapTypeOrDefault(
+        type, elements.getTypeElement(Object.class.getCanonicalName()).asType());
+  }
+
+  private TypeMirror unwrapTypeOrDefault(TypeMirror type, TypeMirror defaultType) {
     DeclaredType declaredType = MoreTypes.asDeclared(type);
     TypeElement typeElement = MoreElements.asType(declaredType.asElement());
     checkArgument(
         !typeElement.getTypeParameters().isEmpty(),
         "%s does not have a type parameter",
         typeElement.getQualifiedName());
-    return getOnlyElement(
-        declaredType.getTypeArguments(),
-        elements.getTypeElement(Object.class.getCanonicalName()).asType());
+    return getOnlyElement(declaredType.getTypeArguments(), defaultType);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/DependencyRequest.java b/java/dagger/internal/codegen/DependencyRequest.java
index 36b426380..5c9629ab3 100644
--- a/java/dagger/internal/codegen/DependencyRequest.java
+++ b/java/dagger/internal/codegen/DependencyRequest.java
@@ -29,7 +29,7 @@
 import static dagger.model.RequestKind.FUTURE;
 import static dagger.model.RequestKind.INSTANCE;
 import static dagger.model.RequestKind.LAZY;
-import static dagger.model.RequestKind.MEMBERS_INJECTOR;
+import static dagger.model.RequestKind.MEMBERS_INJECTION;
 import static dagger.model.RequestKind.PRODUCER;
 import static dagger.model.RequestKind.PROVIDER;
 import static dagger.model.RequestKind.PROVIDER_OF_LAZY;
@@ -84,7 +84,7 @@ BindingKey bindingKey() {
       case PRODUCED:
       case FUTURE:
         return BindingKey.contribution(key());
-      case MEMBERS_INJECTOR:
+      case MEMBERS_INJECTION:
         return BindingKey.membersInjection(key());
       default:
         throw new AssertionError(this);
@@ -353,7 +353,7 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
               ? getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments())
               : getOnlyElement(membersInjectionMethodType.getParameterTypes());
       return DependencyRequest.builder()
-          .kind(MEMBERS_INJECTOR)
+          .kind(MEMBERS_INJECTION)
           .key(keyFactory.forMembersInjectedType(membersInjectedType))
           .requestElement(membersInjectionMethod)
           .build();
@@ -397,9 +397,6 @@ private DependencyRequest newDependencyRequest(
         TypeMirror type,
         Optional<AnnotationMirror> qualifier) {
       KindAndType kindAndType = extractKindAndType(type);
-      if (kindAndType.kind().equals(MEMBERS_INJECTOR)) {
-        checkArgument(!qualifier.isPresent());
-      }
       return DependencyRequest.builder()
           .kind(kindAndType.kind())
           .key(keyFactory.forQualifiedType(qualifier, kindAndType.type()))
diff --git a/java/dagger/internal/codegen/DependencyRequestFormatter.java b/java/dagger/internal/codegen/DependencyRequestFormatter.java
index f181dc86e..c8cc16938 100644
--- a/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -214,7 +214,7 @@ private String componentMethodRequestVerb(DependencyRequest request) {
       case PROVIDER_OF_LAZY:
         return "provided";
 
-      case MEMBERS_INJECTOR:
+      case MEMBERS_INJECTION:
         return "injected";
 
       case PRODUCED:
diff --git a/java/dagger/internal/codegen/DependencyVariableNamer.java b/java/dagger/internal/codegen/DependencyVariableNamer.java
index a47e3a900..86845268d 100644
--- a/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -65,10 +65,6 @@ static String name(DependencyRequest dependency) {
         return variableName.endsWith("Provider") && !variableName.equals("Provider")
             ? variableName.substring(0, variableName.length() - 8)
             : variableName;
-      case MEMBERS_INJECTOR:
-        return variableName.endsWith("MembersInjector") && !variableName.equals("MembersInjector")
-            ? variableName.substring(0, variableName.length() - 15)
-            : variableName;
       case PRODUCED:
         return variableName.startsWith("produced") && !variableName.equals("produced")
             ? toLowerCamel(variableName.substring(8))
diff --git a/java/dagger/internal/codegen/FrameworkDependency.java b/java/dagger/internal/codegen/FrameworkDependency.java
index 00a9bed0c..f45fa97be 100644
--- a/java/dagger/internal/codegen/FrameworkDependency.java
+++ b/java/dagger/internal/codegen/FrameworkDependency.java
@@ -61,9 +61,6 @@ RequestKind dependencyRequestKind() {
       case PRODUCTION:
         return RequestKind.PRODUCER;
 
-      case MEMBERS_INJECTION:
-        return RequestKind.MEMBERS_INJECTOR;
-
       default:
         throw new AssertionError(bindingType());
     }
diff --git a/java/dagger/internal/codegen/FrameworkField.java b/java/dagger/internal/codegen/FrameworkField.java
index 18c1126dd..92d7b9f6a 100644
--- a/java/dagger/internal/codegen/FrameworkField.java
+++ b/java/dagger/internal/codegen/FrameworkField.java
@@ -16,6 +16,8 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.ContributionBinding.Kind.MEMBERS_INJECTOR;
+
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
 import com.squareup.javapoet.ClassName;
@@ -94,7 +96,10 @@ private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
     if (resolvedBindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
       ContributionBinding binding = resolvedBindings.contributionBinding();
       if (binding.bindingElement().isPresent()) {
-        return BINDING_ELEMENT_NAME.visit(binding.bindingElement().get(), binding);
+        String name = BINDING_ELEMENT_NAME.visit(binding.bindingElement().get(), binding);
+        return binding.bindingKind().equals(MEMBERS_INJECTOR)
+            ? name + "MembersInjector"
+            : name;
       }
     }
     return BindingVariableNamer.name(resolvedBindings.binding());
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 325054bdf..cd9d16e43 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -88,10 +88,8 @@ private RequestKind frameworkRequestKind() {
         return RequestKind.PROVIDER;
       case PRODUCER:
         return RequestKind.PRODUCER;
-      case MEMBERS_INJECTOR:
-        return RequestKind.MEMBERS_INJECTOR;
       default:
-        throw new AssertionError();
+        throw new AssertionError(frameworkType);
     }
   }
 
diff --git a/java/dagger/internal/codegen/FrameworkType.java b/java/dagger/internal/codegen/FrameworkType.java
index f8b78ab7c..f9e469950 100644
--- a/java/dagger/internal/codegen/FrameworkType.java
+++ b/java/dagger/internal/codegen/FrameworkType.java
@@ -129,30 +129,17 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
     }
   },
 
+  // TODO(ronshapiro): Remove this once MembersInjectionBinding no longer extends Binding
   /** A {@link MembersInjector}. */
   MEMBERS_INJECTOR {
     @Override
     CodeBlock to(RequestKind requestKind, CodeBlock from) {
-      switch (requestKind) {
-        case MEMBERS_INJECTOR:
-          return from;
-
-        default:
-          throw new IllegalArgumentException(
-              String.format("Cannot request a %s from a %s", requestKind, this));
-      }
+      throw new UnsupportedOperationException(requestKind.toString());
     }
 
     @Override
     Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
-      switch (requestKind) {
-        case MEMBERS_INJECTOR:
-          return from;
-
-        default:
-          throw new IllegalArgumentException(
-              String.format("Cannot request a %s from a %s", requestKind, this));
-      }
+      throw new UnsupportedOperationException(requestKind.toString());
     }
   },
   ;
diff --git a/java/dagger/internal/codegen/InjectBindingRegistry.java b/java/dagger/internal/codegen/InjectBindingRegistry.java
index 94bc4a178..2840d75f4 100644
--- a/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -44,6 +44,12 @@
    */
   Optional<MembersInjectionBinding> getOrFindMembersInjectionBinding(Key key);
 
+  /**
+   * Returns a {@link ProvisionBinding} for a {@link dagger.MembersInjector} of {@code key}. If none
+   * has been registered yet, registers one.
+   */
+  Optional<ProvisionBinding> getOrFindMembersInjectorProvisionBinding(Key key);
+
   @CanIgnoreReturnValue
   Optional<ProvisionBinding> tryRegisterConstructor(ExecutableElement constructorElement);
 
diff --git a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
index cff37c9cd..67fc035f5 100644
--- a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
+++ b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
@@ -47,7 +47,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
 /**
@@ -60,7 +59,7 @@
  */
 final class InjectBindingRegistryImpl implements InjectBindingRegistry {
   private final Elements elements;
-  private final Types types;
+  private final DaggerTypes types;
   private final Messager messager;
   private final InjectValidator injectValidator;
   private final InjectValidator injectValidatorWhenGeneratingCode;
@@ -155,7 +154,7 @@ private void tryToCacheBinding(B binding) {
 
   InjectBindingRegistryImpl(
       Elements elements,
-      Types types,
+      DaggerTypes types,
       Messager messager,
       InjectValidator injectValidator,
       KeyFactory keyFactory,
@@ -327,4 +326,14 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
             MoreTypes.asTypeElement(key.type()), Optional.of(key.type()), true);
     return newBinding;
   }
+
+  @Override
+  public Optional<ProvisionBinding> getOrFindMembersInjectorProvisionBinding(Key key) {
+    if (!isValidMembersInjectionKey(key)) {
+      return Optional.empty();
+    }
+    Key membersInjectionKey = keyFactory.forMembersInjectedType(types.unwrapType(key.type()));
+    return getOrFindMembersInjectionBinding(membersInjectionKey)
+        .map(binding -> provisionBindingFactory.forMembersInjector(key, binding));
+  }
 }
diff --git a/java/dagger/internal/codegen/Keys.java b/java/dagger/internal/codegen/Keys.java
index 64760d562..b9ef5bf0d 100644
--- a/java/dagger/internal/codegen/Keys.java
+++ b/java/dagger/internal/codegen/Keys.java
@@ -48,7 +48,9 @@
   }
 
   static boolean isValidMembersInjectionKey(Key key) {
-    return !key.qualifier().isPresent() && key.type().getKind().equals(TypeKind.DECLARED);
+    return !key.qualifier().isPresent()
+        && !key.multibindingContributionIdentifier().isPresent()
+        && key.type().getKind().equals(TypeKind.DECLARED);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
index d662a7142..5450b76b9 100644
--- a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
+++ b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
@@ -25,46 +25,38 @@
 import com.squareup.javapoet.ParameterSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.RequestKind;
-import java.util.List;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.VariableElement;
 
-/** A binding expression for members injection bindings. */
+/**
+ * A binding expression for members injection component methods. See {@link
+ * MembersInjectionMethods}.
+ */
 final class MembersInjectionBindingExpression extends BindingExpression {
-  private final FrameworkInstanceBindingExpression membersInjectorExpression;
-  private final GeneratedComponentModel generatedComponentModel;
   private final MembersInjectionBinding binding;
   private final MembersInjectionMethods membersInjectionMethods;
 
   MembersInjectionBindingExpression(
-      FrameworkInstanceBindingExpression membersInjectorExpression,
-      GeneratedComponentModel generatedComponentModel,
-      MembersInjectionMethods membersInjectionMethods) {
-    super(membersInjectorExpression.resolvedBindings(), membersInjectorExpression.requestKind());
+      ResolvedBindings resolvedBindings, MembersInjectionMethods membersInjectionMethods) {
+    super(resolvedBindings, RequestKind.MEMBERS_INJECTION);
     checkArgument(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
-    checkArgument(requestKind().equals(RequestKind.MEMBERS_INJECTOR));
-    this.membersInjectorExpression = membersInjectorExpression;
-    this.generatedComponentModel = generatedComponentModel;
     this.binding = resolvedBindings().membersInjectionBinding().get();
     this.membersInjectionMethods = membersInjectionMethods;
   }
 
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
-    return membersInjectorExpression.getDependencyExpression(requestingClass);
+    throw new UnsupportedOperationException(binding.toString());
   }
 
+  // TODO(ronshapiro): This class doesn't need to be a BindingExpression, as
+  // getDependencyExpression() should never be called for members injection methods. It's probably
+  // better suited as a method on MembersInjectionMethods
   @Override
   protected CodeBlock doGetComponentMethodImplementation(
       ComponentMethodDescriptor componentMethod, ClassName requestingClass) {
     ExecutableElement methodElement = componentMethod.methodElement();
-    List<? extends VariableElement> parameters = methodElement.getParameters();
-    if (parameters.isEmpty() /* i.e. it's a request for a MembersInjector<T> */) {
-      return membersInjectorExpression.getComponentMethodImplementation(
-          componentMethod, generatedComponentModel.name());
-    }
+    ParameterSpec parameter = ParameterSpec.get(getOnlyElement(methodElement.getParameters()));
 
-    ParameterSpec parameter = ParameterSpec.get(getOnlyElement(parameters));
     if (binding.injectionSites().isEmpty()) {
       return methodElement.getReturnType().getKind().equals(VOID)
           ? CodeBlock.of("")
diff --git a/java/dagger/internal/codegen/MembersInjectorFieldInitializer.java b/java/dagger/internal/codegen/MembersInjectorFieldInitializer.java
deleted file mode 100644
index 721293aff..000000000
--- a/java/dagger/internal/codegen/MembersInjectorFieldInitializer.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.BindingKey.Kind.MEMBERS_INJECTION;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
-
-import com.squareup.javapoet.CodeBlock;
-
-/** An initializer for {@link dagger.MembersInjector} fields. */
-final class MembersInjectorFieldInitializer extends FrameworkFieldInitializer {
-
-  // TODO(ronshapiro): add Binding.bindingKey() and use that instead of taking a ResolvedBindings
-  private final ResolvedBindings resolvedBindings;
-
-  MembersInjectorFieldInitializer(
-      ResolvedBindings resolvedBindings,
-      GeneratedComponentModel generatedComponentModel,
-      ComponentBindingExpressions componentBindingExpressions) {
-    super(generatedComponentModel, componentBindingExpressions, resolvedBindings);
-    checkArgument(resolvedBindings.bindingKey().kind().equals(MEMBERS_INJECTION));
-    this.resolvedBindings = checkNotNull(resolvedBindings);
-  }
-
-  @Override
-  protected CodeBlock getFieldInitialization() {
-    MembersInjectionBinding membersInjectionBinding =
-        resolvedBindings.membersInjectionBinding().get();
-    return CodeBlock.of(
-        "$T.create($L)",
-        membersInjectorNameForType(membersInjectionBinding.membersInjectedType()),
-        makeParametersCodeBlock(getBindingDependencyExpressions(membersInjectionBinding)));
-  }
-}
diff --git a/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java b/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
index 21a3aea92..928e27c89 100644
--- a/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
+++ b/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
@@ -33,9 +33,11 @@
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
+import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
 import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
@@ -324,6 +326,9 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
       case SYNTHETIC_OPTIONAL_BINDING:
         return factoryForSyntheticOptionalBindingInitialization(binding);
 
+      case MEMBERS_INJECTOR:
+        return factoryForSyntheticMembersInjectorBinding(binding);
+
       default:
         throw new AssertionError(binding);
     }
@@ -595,4 +600,25 @@ private CodeBlock factoryForSyntheticOptionalBindingInitialization(ContributionB
           binding, getDependencyExpression(getOnlyElement(binding.frameworkDependencies())));
     }
   }
+
+  /**
+   * Returns an expression that initializes a {@code Provider<MembersInjector<T>>} for a {@link
+   * ContributionBinding.Kind#MEMBERS_INJECTOR} binding.
+   */
+  private CodeBlock factoryForSyntheticMembersInjectorBinding(ContributionBinding binding) {
+    TypeMirror membersInjectedType =
+        getOnlyElement(MoreTypes.asDeclared(binding.key().type()).getTypeArguments());
+
+    CodeBlock membersInjector =
+        ((ProvisionBinding) binding).injectionSites().isEmpty()
+            ? CodeBlock.of("$T.<$T>noOp()", MEMBERS_INJECTORS, membersInjectedType)
+            : CodeBlock.of(
+                "$T.create($L)",
+                membersInjectorNameForType(MoreTypes.asTypeElement(membersInjectedType)),
+                makeParametersCodeBlock(getBindingDependencyExpressions(binding)));
+
+    // TODO(ronshapiro): consider adding a MembersInjectorBindingExpression to return this directly
+    // (as it's rarely requested as a Provider).
+    return CodeBlock.of("$T.create($L)", INSTANCE_FACTORY, membersInjector);
+  }
 }
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index d11522378..ea033d12e 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -140,13 +140,13 @@ boolean shouldCheckForNull(CompilerOptions compilerOptions) {
   }
 
   static final class Factory {
-    private final Types types;
+    private final DaggerTypes types;
     private final KeyFactory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
     private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
 
     Factory(
-        Types types,
+        DaggerTypes types,
         KeyFactory keyFactory,
         DependencyRequest.Factory dependencyRequestFactory,
         MembersInjectionBinding.Factory membersInjectionBindingFactory) {
@@ -420,5 +420,17 @@ ProvisionBinding syntheticPresentBinding(Key key, RequestKind kind) {
               dependencyRequestFactory.forSyntheticPresentOptionalBinding(key, kind))
           .build();
     }
+
+    /** Returns a binding for a {@link dagger.MembersInjector} wrapper type. */
+    ProvisionBinding forMembersInjector(Key key, MembersInjectionBinding membersInjectionBinding) {
+      return ProvisionBinding.builder()
+          .key(key)
+          .contributionType(ContributionType.UNIQUE)
+          .bindingKind(Kind.MEMBERS_INJECTOR)
+          .bindingElement(MoreTypes.asTypeElement(membersInjectionBinding.key().type()))
+          .provisionDependencies(membersInjectionBinding.dependencies())
+          .injectionSites(membersInjectionBinding.injectionSites())
+          .build();
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/RequestKinds.java b/java/dagger/internal/codegen/RequestKinds.java
index f676ea2d7..4d65e41e0 100644
--- a/java/dagger/internal/codegen/RequestKinds.java
+++ b/java/dagger/internal/codegen/RequestKinds.java
@@ -18,12 +18,10 @@
 
 import static dagger.internal.codegen.TypeNames.lazyOf;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
-import static dagger.internal.codegen.TypeNames.membersInjectorOf;
 import static dagger.internal.codegen.TypeNames.producedOf;
 import static dagger.internal.codegen.TypeNames.producerOf;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static dagger.model.RequestKind.LAZY;
-import static dagger.model.RequestKind.MEMBERS_INJECTOR;
 import static dagger.model.RequestKind.PRODUCED;
 import static dagger.model.RequestKind.PRODUCER;
 import static dagger.model.RequestKind.PROVIDER;
@@ -32,7 +30,6 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.TypeName;
 import dagger.Lazy;
-import dagger.MembersInjector;
 import dagger.model.RequestKind;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
@@ -83,9 +80,6 @@ static TypeName requestTypeName(RequestKind requestKind, TypeName keyType) {
       case FUTURE:
         return listenableFutureOf(keyType);
 
-      case MEMBERS_INJECTOR:
-        return membersInjectorOf(keyType);
-
       default:
         throw new AssertionError(requestKind);
     }
@@ -95,7 +89,6 @@ static TypeName requestTypeName(RequestKind requestKind, TypeName keyType) {
       ImmutableMap.of(
           PROVIDER, Provider.class,
           LAZY, Lazy.class,
-          MEMBERS_INJECTOR, MembersInjector.class,
           PRODUCER, Producer.class,
           PRODUCED, Produced.class);
 
diff --git a/java/dagger/internal/codegen/SourceFiles.java b/java/dagger/internal/codegen/SourceFiles.java
index a9390c65b..17ca38b7b 100644
--- a/java/dagger/internal/codegen/SourceFiles.java
+++ b/java/dagger/internal/codegen/SourceFiles.java
@@ -157,7 +157,6 @@ static CodeBlock frameworkTypeUsageStatement(
         return CodeBlock.of("$L.get()", frameworkTypeMemberSelect);
       case PROVIDER:
       case PRODUCER:
-      case MEMBERS_INJECTOR:
         return frameworkTypeMemberSelect;
       case PROVIDER_OF_LAZY:
         return CodeBlock.of("$T.create($L)", PROVIDER_OF_LAZY, frameworkTypeMemberSelect);
diff --git a/java/dagger/model/RequestKind.java b/java/dagger/model/RequestKind.java
index 31895f8f0..2f3c75734 100644
--- a/java/dagger/model/RequestKind.java
+++ b/java/dagger/model/RequestKind.java
@@ -17,7 +17,6 @@
 package dagger.model;
 
 import dagger.Lazy;
-import dagger.MembersInjector;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import javax.inject.Provider;
@@ -42,8 +41,11 @@
   /** A request for a {@link Provider} of a {@link Lazy}. E.g.: {@code Provider<Lazy<FooType>>} */
   PROVIDER_OF_LAZY,
 
-  /** A request for a {@link MembersInjector}. E.g.: {@code MembersInjector<FooType>} */
-  MEMBERS_INJECTOR,
+  /**
+   * A request for a members injection. E.g. {@code void inject(FooType);}. Can only be requested by
+   * component interfaces.
+   */
+  MEMBERS_INJECTION,
 
   /** A request for a {@link Producer}. E.g.: {@code Producer<FooType>} */
   PRODUCER,
diff --git a/javatests/dagger/internal/codegen/BindingTypeMapperTest.java b/javatests/dagger/internal/codegen/BindingTypeMapperTest.java
index 8bdac18da..7dc162cc7 100644
--- a/javatests/dagger/internal/codegen/BindingTypeMapperTest.java
+++ b/javatests/dagger/internal/codegen/BindingTypeMapperTest.java
@@ -17,12 +17,10 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertThat;
-import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
 import static dagger.internal.codegen.BindingType.PRODUCTION;
 import static dagger.internal.codegen.BindingType.PROVISION;
 import static dagger.model.RequestKind.INSTANCE;
 import static dagger.model.RequestKind.LAZY;
-import static dagger.model.RequestKind.MEMBERS_INJECTOR;
 import static dagger.model.RequestKind.PRODUCED;
 import static dagger.model.RequestKind.PRODUCER;
 import static dagger.model.RequestKind.PROVIDER;
@@ -44,8 +42,6 @@
         .isEqualTo(PROVISION);
     assertThat(mapper.getBindingType(PROVIDER))
         .isEqualTo(PROVISION);
-    assertThat(mapper.getBindingType(MEMBERS_INJECTOR))
-        .isEqualTo(MEMBERS_INJECTION);
   }
 
   @Test public void forProducer() {
@@ -56,8 +52,6 @@
         .isEqualTo(PROVISION);
     assertThat(mapper.getBindingType(PROVIDER))
         .isEqualTo(PROVISION);
-    assertThat(mapper.getBindingType(MEMBERS_INJECTOR))
-        .isEqualTo(MEMBERS_INJECTION);
     assertThat(mapper.getBindingType(PRODUCER))
         .isEqualTo(PRODUCTION);
     assertThat(mapper.getBindingType(PRODUCED))
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 2677726b4..3aa583787 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -415,7 +415,7 @@ public void providesMethodReturnsProduced() {
         "@Module",
         "final class TestModule {",
         "  @Provides List<Object> provideObjects(",
-        "      @QualifierA Object a, @QualifierB Object b, MembersInjector<X> x) {",
+        "      @QualifierA Object a, @QualifierB Object b, MembersInjector<X> xInjector) {",
         "    return Arrays.asList(a, b);",
         "  }",
         "",
@@ -445,38 +445,39 @@ public void providesMethodReturnsProduced() {
             "  private final TestModule module;",
             "  private final Provider<Object> aProvider;",
             "  private final Provider<Object> bProvider;",
-            "  private final MembersInjector<X> xMembersInjector;",
+            "  private final Provider<MembersInjector<X>> xInjectorProvider;",
             "",
             "  public TestModule_ProvideObjectsFactory(",
             "      TestModule module,",
             "      Provider<Object> aProvider,",
             "      Provider<Object> bProvider,",
-            "      MembersInjector<X> xMembersInjector) {",
+            "      Provider<MembersInjector<X>> xInjectorProvider) {",
             "    this.module = module;",
             "    this.aProvider = aProvider;",
             "    this.bProvider = bProvider;",
-            "    this.xMembersInjector = xMembersInjector;",
+            "    this.xInjectorProvider = xInjectorProvider;",
             "  }",
             "",
             "  @Override public List<Object> get() {",
             "    return Preconditions.checkNotNull(",
-            "        module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector),",
-            "        " + NPE_LITERAL + ");",
+            "        module.provideObjects(",
+            "            aProvider.get(), bProvider.get(), xInjectorProvider.get()),",
+            "             " + NPE_LITERAL + ");",
             "  }",
             "",
             "  public static TestModule_ProvideObjectsFactory create(",
             "      TestModule module,",
             "      Provider<Object> aProvider,",
             "      Provider<Object> bProvider,",
-            "      MembersInjector<X> xMembersInjector) {",
+            "      Provider<MembersInjector<X>> xInjectorProvider) {",
             "    return new TestModule_ProvideObjectsFactory(",
-            "        module, aProvider, bProvider, xMembersInjector);",
+            "        module, aProvider, bProvider, xInjectorProvider);",
             "  }",
             "",
             "  public static List<Object> proxyProvideObjects(",
-            "      TestModule instance, Object a, Object b, MembersInjector<X> x) {",
+            "      TestModule instance, Object a, Object b, MembersInjector<X> xInjector) {",
             "    return Preconditions.checkNotNull(",
-            "        instance.provideObjects(a, b, x), " + NPE_LITERAL + ");",
+            "        instance.provideObjects(a, b, xInjector), " + NPE_LITERAL + ");",
             "  }",
             "}");
     assertAbout(javaSources()).that(
