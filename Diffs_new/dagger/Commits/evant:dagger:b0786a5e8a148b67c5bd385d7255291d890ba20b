diff --git a/java/dagger/model/Key.java b/java/dagger/model/Key.java
index daeb35a94..e543d2ab0 100644
--- a/java/dagger/model/Key.java
+++ b/java/dagger/model/Key.java
@@ -88,6 +88,32 @@ public final TypeMirror type() {
   @Override
   public abstract int hashCode();
 
+  // We are modifying what would be the AutoValue-generated equals() method to stick in a check for
+  // hashCode() equality before other properties. Profiling indicated that Key equality is called in
+  // numerous places and it cannot be @Memoized, but hashCode() can be. Because so many other value
+  // types use Key, their equality is dependant on Key's. Inserting the check removed Key.equals()
+  // from the profile.
+  // The main equality bottleneck in calculating the equality is in MoreTypes.equivalence()'s
+  // equality checker. It's possible that we can avoid this by tuning that method. Perhaps we can
+  // also avoid the issue entirely by interning all Keys
+  // TODO(ronshapiro): consider creating an AutoValue extension that can generate this code on its
+  // own
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true;
+    }
+    if (o instanceof Key) {
+      Key that = (Key) o;
+      return (this.hashCode() == that.hashCode())
+          && (this.wrappedQualifier().equals(that.wrappedQualifier()))
+          && (this.wrappedType().equals(that.wrappedType()))
+          && (this.multibindingContributionIdentifier()
+              .equals(that.multibindingContributionIdentifier()));
+    }
+    return false;
+  }
+
   @Override
   public final String toString() {
     return Joiner.on(' ')
