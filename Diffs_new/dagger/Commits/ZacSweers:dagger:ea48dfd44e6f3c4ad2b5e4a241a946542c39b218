diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index fded33642..aa03b6756 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -286,7 +286,7 @@ java_library(
         "ProducerCreationExpression.java",
         "ProducerFactoryGenerator.java",
         "ProducerFromProviderCreationExpression.java",
-        "ProducerInstanceBindingExpression.java",
+        "ProducerNodeInstanceBindingExpression.java",
         "ProductionExecutorModuleGenerator.java",
         "ProviderInstanceBindingExpression.java",
         "ReferenceReleasingManagerFields.java",
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 1f190f6dc..c4cd5c119 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -33,6 +33,16 @@
    */
   abstract Expression getDependencyExpression(ClassName requestingClass);
 
+  /**
+   * Equivalent to {@link #getDependencyExpression} that is used only when the request is for an
+   * implementation of a component method. By default, just delegates to {@link
+   * #getDependencyExpression}.
+   */
+  Expression getDependencyExpressionForComponentMethod(
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+    return getDependencyExpression(component.name());
+  }
+
   /** Returns {@code true} if this binding expression should be encapsulated in a method. */
   boolean requiresMethodEncapsulation() {
     return false;
@@ -46,7 +56,9 @@ boolean requiresMethodEncapsulation() {
   CodeBlock getComponentMethodImplementation(
       ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
     // By default, just delegate to #getDependencyExpression().
-    return CodeBlock.of("return $L;", getDependencyExpression(component.name()).codeBlock());
+    return CodeBlock.of(
+        "return $L;",
+        getDependencyExpressionForComponentMethod(componentMethod, component).codeBlock());
   }
 
   /**
diff --git a/java/dagger/internal/codegen/BindingRequest.java b/java/dagger/internal/codegen/BindingRequest.java
index e10dae3f5..5bf1d9319 100644
--- a/java/dagger/internal/codegen/BindingRequest.java
+++ b/java/dagger/internal/codegen/BindingRequest.java
@@ -61,7 +61,7 @@ static BindingRequest bindingRequest(Key key, RequestKind requestKind) {
    */
   static BindingRequest bindingRequest(Key key, FrameworkType frameworkType) {
     return new AutoValue_BindingRequest(
-        key, Optional.of(frameworkType.requestKind()), Optional.of(frameworkType));
+        key, frameworkType.requestKind(), Optional.of(frameworkType));
   }
 
   /** Creates a {@link BindingRequest} for the given {@link FrameworkDependency}. */
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 40edac446..350a3da47 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.BindingRequest.bindingRequest;
@@ -161,7 +162,21 @@ Expression getDependencyExpression(BindingRequest request, ClassName requestingC
   }
 
   /**
-   * Returns the {@link CodeBlock} for the method argmuments used with the factory {@code create()}
+   * Equivalent to {@link #getDependencyExpression(BindingRequest, ClassName)} that is used only
+   * when the request is for implementation of a component method.
+   *
+   * @throws IllegalStateException if there is no binding expression that satisfies the request
+   */
+  Expression getDependencyExpressionForComponentMethod(
+      BindingRequest request,
+      ComponentMethodDescriptor componentMethod,
+      GeneratedComponentModel componentModel) {
+    return getBindingExpression(request)
+        .getDependencyExpressionForComponentMethod(componentMethod, componentModel);
+  }
+
+  /**
+   * Returns the {@link CodeBlock} for the method arguments used with the factory {@code create()}
    * method for the given {@link ContributionBinding binding}.
    */
   CodeBlock getCreateMethodArgumentsCodeBlock(ContributionBinding binding) {
@@ -295,8 +310,8 @@ private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
         return new ProviderInstanceBindingExpression(
             resolvedBindings, frameworkInstanceSupplier, types, elements);
       case PRODUCTION:
-        return new ProducerInstanceBindingExpression(
-            resolvedBindings, frameworkInstanceSupplier, types, elements);
+        return new ProducerNodeInstanceBindingExpression(
+            resolvedBindings, frameworkInstanceSupplier, types, elements, generatedComponentModel);
       default:
         throw new AssertionError("invalid binding type: " + resolvedBindings.bindingType());
     }
@@ -407,9 +422,13 @@ private InstanceFactoryCreationExpression instanceFactoryCreationExpression(
   /** Returns a binding expression for a provision binding. */
   private BindingExpression provisionBindingExpression(
       ResolvedBindings resolvedBindings, BindingRequest request) {
-    // All provision requests should have an associated RequestKind, even if they're a framework
-    // request.
-    checkArgument(request.requestKind().isPresent());
+    if (!request.requestKind().isPresent()) {
+      verify(
+          request.frameworkType().get().equals(FrameworkType.PRODUCER_NODE),
+          "expected a PRODUCER_NODE: %s",
+          request);
+      return producerFromProviderBindingExpression(resolvedBindings);
+    }
     RequestKind requestKind = request.requestKind().get();
     switch (requestKind) {
       case INSTANCE:
@@ -445,7 +464,7 @@ private BindingExpression productionBindingExpression(
     } else {
       // If no FrameworkType is present, a RequestKind is guaranteed to be present.
       return new DerivedFromFrameworkInstanceBindingExpression(
-          resolvedBindings, FrameworkType.PRODUCER, request.requestKind().get(), this, types);
+          resolvedBindings, FrameworkType.PRODUCER_NODE, request.requestKind().get(), this, types);
     }
   }
 
@@ -485,7 +504,7 @@ private BindingExpression providerBindingExpression(ResolvedBindings resolvedBin
   private FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
       ResolvedBindings resolvedBindings) {
     checkArgument(resolvedBindings.bindingType().equals(BindingType.PROVISION));
-    return new ProducerInstanceBindingExpression(
+    return new ProducerNodeInstanceBindingExpression(
         resolvedBindings,
         new FrameworkFieldInitializer(
             generatedComponentModel,
@@ -493,7 +512,8 @@ private FrameworkInstanceBindingExpression producerFromProviderBindingExpression
             new ProducerFromProviderCreationExpression(
                 resolvedBindings.contributionBinding(), generatedComponentModel, this)),
         types,
-        elements);
+        elements,
+        generatedComponentModel);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentModelBuilder.java b/java/dagger/internal/codegen/ComponentModelBuilder.java
index abefd7891..01d70a971 100644
--- a/java/dagger/internal/codegen/ComponentModelBuilder.java
+++ b/java/dagger/internal/codegen/ComponentModelBuilder.java
@@ -25,11 +25,13 @@
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.BUILDER_METHOD;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.CANCELLATION_LISTENER_METHOD;
 import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.COMPONENT_METHOD;
 import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.CONSTRUCTOR;
 import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.INITIALIZE_METHOD;
 import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.COMPONENT_BUILDER;
 import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.SUBCOMPONENT;
+import static dagger.internal.codegen.ProducerNodeInstanceBindingExpression.MAY_INTERRUPT_IF_RUNNING;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
@@ -49,6 +51,7 @@
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.producers.internal.CancellationListener;
 import java.util.List;
 import java.util.Optional;
 import javax.lang.model.element.ExecutableElement;
@@ -179,6 +182,10 @@ protected final GeneratedComponentModel build() {
     addSubcomponents();
     addConstructor();
 
+    if (graph.componentDescriptor().kind().isProducer()) {
+      addCancellationListenerImplementation();
+    }
+
     done = true;
     return generatedComponentModel;
   }
@@ -224,6 +231,56 @@ protected void addInterfaceMethods() {
     }
   }
 
+  private static final int STATEMENTS_PER_METHOD = 100;
+
+  private static final String CANCELLATION_LISTENER_METHOD_NAME = "onProducerFutureCancelled";
+
+  private void addCancellationListenerImplementation() {
+    generatedComponentModel.addSupertype(elements.getTypeElement(CancellationListener.class));
+    generatedComponentModel.claimMethodName(CANCELLATION_LISTENER_METHOD_NAME);
+
+    // Reversing should order cancellations starting from entry points and going down to leaves
+    // rather than the other way around. This shouldn't really matter but seems *slightly*
+    // preferable because:
+    // When a future that another future depends on is cancelled, that cancellation will propagate
+    // up the future graph toward the entry point. Cancelling in reverse order should ensure that
+    // everything that depends on a particular node has already been cancelled when that node is
+    // cancelled, so there's no need to propagate. Otherwise, when we cancel a leaf node, it might
+    // propagate through most of the graph, making most of the cancel calls that follow in the
+    // onProducerFutureCancelled method do nothing.
+    ImmutableList<CodeBlock> cancellationStatements =
+        generatedComponentModel.getCancellations().reverse();
+    MethodSpec.Builder methodBuilder =
+        methodBuilder(CANCELLATION_LISTENER_METHOD_NAME)
+            .addModifiers(PUBLIC)
+            .addAnnotation(Override.class)
+            .addParameter(boolean.class, MAY_INTERRUPT_IF_RUNNING);
+    if (generatedComponentModel.supermodel().isPresent()) {
+      methodBuilder.addStatement(
+          "super.$L($L)", CANCELLATION_LISTENER_METHOD_NAME, MAY_INTERRUPT_IF_RUNNING);
+    }
+
+    if (cancellationStatements.size() < STATEMENTS_PER_METHOD) {
+      methodBuilder.addCode(CodeBlocks.concat(cancellationStatements)).build();
+    } else {
+      List<List<CodeBlock>> partitions =
+          Lists.partition(cancellationStatements, STATEMENTS_PER_METHOD);
+      for (List<CodeBlock> partition : partitions) {
+        String methodName = generatedComponentModel.getUniqueMethodName("cancelProducers");
+        MethodSpec method =
+            MethodSpec.methodBuilder(methodName)
+                .addModifiers(PRIVATE)
+                .addParameter(boolean.class, MAY_INTERRUPT_IF_RUNNING)
+                .addCode(CodeBlocks.concat(partition))
+                .build();
+        methodBuilder.addStatement("$N($L)", method, MAY_INTERRUPT_IF_RUNNING);
+        generatedComponentModel.addMethod(CANCELLATION_LISTENER_METHOD, method);
+      }
+    }
+
+    generatedComponentModel.addMethod(CANCELLATION_LISTENER_METHOD, methodBuilder.build());
+  }
+
   private MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
     return MethodSignature.forComponentMethod(
         method, MoreTypes.asDeclared(graph.componentType().asType()), types);
@@ -323,12 +380,9 @@ private GeneratedComponentModel buildSubcomponentModel(BindingGraph childGraph)
         .build();
   }
 
-  private static final int INITIALIZATIONS_PER_INITIALIZE_METHOD = 100;
-
   private void addConstructor() {
     List<List<CodeBlock>> partitions =
-        Lists.partition(
-            generatedComponentModel.getInitializations(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
+        Lists.partition(generatedComponentModel.getInitializations(), STATEMENTS_PER_METHOD);
 
     ImmutableList<ParameterSpec> constructorParameters = constructorParameters();
     MethodSpec.Builder constructor =
@@ -353,16 +407,15 @@ private void addConstructor() {
             .map(param -> CodeBlock.of("$N", param))
             .collect(toParametersCodeBlock());
 
-    UniqueNameSet methodNames = new UniqueNameSet();
     for (List<CodeBlock> partition : partitions) {
-      String methodName = methodNames.getUniqueName("initialize");
+      String methodName = generatedComponentModel.getUniqueMethodName("initialize");
       MethodSpec.Builder initializeMethod =
           methodBuilder(methodName)
               .addModifiers(PRIVATE)
               /* TODO(gak): Strictly speaking, we only need the suppression here if we are also
                * initializing a raw field in this method, but the structure of this code makes it
                * awkward to pass that bit through.  This will be cleaned up when we no longer
-               * separate fields and initilization as we do now. */
+               * separate fields and initialization as we do now. */
               .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
               .addCode(CodeBlocks.concat(partition));
       initializeMethod.addParameters(initializeParameters);
@@ -372,7 +425,7 @@ private void addConstructor() {
     generatedComponentModel.addMethod(CONSTRUCTOR, constructor.build());
   }
 
-  /** Returns the list of {@link ParameterSpec}s for the initialze methods. */
+  /** Returns the list of {@link ParameterSpec}s for the initialize methods. */
   private ImmutableList<ParameterSpec> initializeParameters() {
     return constructorParameters()
         .stream()
diff --git a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
index 6efe4c750..f762e3c95 100644
--- a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
@@ -19,8 +19,8 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
+import static dagger.internal.codegen.TypeNames.dependencyMethodProducerOf;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
-import static dagger.internal.codegen.TypeNames.producerOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -74,10 +74,10 @@ public CodeBlock creationExpression() {
     return CodeBlock.of(
         "$L",
         anonymousClassBuilder("")
-            .superclass(producerOf(keyType))
+            .superclass(dependencyMethodProducerOf(keyType))
             .addField(dependencyField)
             .addMethod(
-                methodBuilder("get")
+                methodBuilder("callDependencyMethod")
                     .addAnnotation(Override.class)
                     .addModifiers(PUBLIC)
                     .returns(listenableFutureOf(keyType))
diff --git a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
index 20f73deec..2e0ab538b 100644
--- a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
@@ -20,13 +20,13 @@
 import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.ClassName;
-import dagger.model.Key;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.RequestKind;
 
 /** A binding expression that depends on a framework instance. */
 final class DerivedFromFrameworkInstanceBindingExpression extends BindingExpression {
 
-  private final Key key;
+  private final BindingRequest frameworkRequest;
   private final RequestKind requestKind;
   private final FrameworkType frameworkType;
   private final ComponentBindingExpressions componentBindingExpressions;
@@ -38,7 +38,7 @@
       RequestKind requestKind,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types) {
-    this.key = resolvedBindings.key();
+    this.frameworkRequest = bindingRequest(resolvedBindings.key(), frameworkType);
     this.requestKind = checkNotNull(requestKind);
     this.frameworkType = checkNotNull(frameworkType);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
@@ -49,8 +49,16 @@
   Expression getDependencyExpression(ClassName requestingClass) {
     return frameworkType.to(
         requestKind,
-        componentBindingExpressions.getDependencyExpression(
-            bindingRequest(key, frameworkType), requestingClass),
+        componentBindingExpressions.getDependencyExpression(frameworkRequest, requestingClass),
         types);
   }
+
+  @Override
+  Expression getDependencyExpressionForComponentMethod(
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+    Expression expression =
+        componentBindingExpressions.getDependencyExpressionForComponentMethod(
+            frameworkRequest, componentMethod, component);
+    return frameworkType.to(requestKind, expression, types);
+  }
 }
diff --git a/java/dagger/internal/codegen/FrameworkType.java b/java/dagger/internal/codegen/FrameworkType.java
index 05fcbcc69..0e279fce7 100644
--- a/java/dagger/internal/codegen/FrameworkType.java
+++ b/java/dagger/internal/codegen/FrameworkType.java
@@ -48,8 +48,8 @@
     }
 
     @Override
-    RequestKind requestKind() {
-      return RequestKind.PROVIDER;
+    Optional<RequestKind> requestKind() {
+      return Optional.of(RequestKind.PROVIDER);
     }
 
     @Override
@@ -108,15 +108,18 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
   },
 
   /** A {@link Producer}. */
-  PRODUCER {
+  PRODUCER_NODE {
     @Override
     Class<?> frameworkClass() {
+      // TODO(cgdecker): Replace this with new class for representing internal producer nodes.
+      // Currently the new class is CancellableProducer, but it may be changed to ProducerNode and
+      // made to not implement Producer.
       return Producer.class;
     }
 
     @Override
-    RequestKind requestKind() {
-      return RequestKind.PRODUCER;
+    Optional<RequestKind> requestKind() {
+      return Optional.empty();
     }
 
     @Override
@@ -143,7 +146,7 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
               to(requestKind, from.codeBlock()));
 
         case PRODUCER:
-          return from;
+          return Expression.create(from.type(), to(requestKind, from.codeBlock()));
 
         default:
           throw new IllegalArgumentException(
@@ -159,7 +162,7 @@ static FrameworkType forBindingType(BindingType bindingType) {
       case PROVISION:
         return PROVIDER;
       case PRODUCTION:
-        return PRODUCER;
+        return PRODUCER_NODE;
       case MEMBERS_INJECTION:
     }
     throw new AssertionError(bindingType);
@@ -170,8 +173,6 @@ static FrameworkType forBindingType(BindingType bindingType) {
     switch (requestKind) {
       case PROVIDER:
         return Optional.of(FrameworkType.PROVIDER);
-      case PRODUCER:
-        return Optional.of(FrameworkType.PRODUCER);
       default:
         return Optional.empty();
     }
@@ -185,8 +186,8 @@ ParameterizedTypeName frameworkClassOf(TypeName valueType) {
     return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);
   }
 
-  /** Returns the {@link RequestKind} matching this framework type. */
-  abstract RequestKind requestKind();
+  /** The request kind that an instance of this framework type can satisfy directly, if any. */
+  abstract Optional<RequestKind> requestKind();
 
   /**
    * Returns a {@link CodeBlock} that evaluates to a requested object given an expression that
diff --git a/java/dagger/internal/codegen/FrameworkTypeMapper.java b/java/dagger/internal/codegen/FrameworkTypeMapper.java
index d768ca79f..774669253 100644
--- a/java/dagger/internal/codegen/FrameworkTypeMapper.java
+++ b/java/dagger/internal/codegen/FrameworkTypeMapper.java
@@ -20,8 +20,6 @@
 import static dagger.internal.codegen.BindingType.PRODUCTION;
 import static java.util.stream.Collectors.toSet;
 
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
@@ -58,7 +56,7 @@ public FrameworkType getFrameworkType(RequestKind requestKind) {
         case INSTANCE:
         case PRODUCED:
         case PRODUCER:
-          return FrameworkType.PRODUCER;
+          return FrameworkType.PRODUCER_NODE;
         case PROVIDER:
         case PROVIDER_OF_LAZY:
         case LAZY:
@@ -82,15 +80,6 @@ static FrameworkTypeMapper forBindingType(BindingType bindingType) {
   FrameworkType getFrameworkType(Set<DependencyRequest> requests) {
     Set<FrameworkType> frameworkTypes =
         requests.stream().map(request -> getFrameworkType(request.kind())).collect(toSet());
-    if (frameworkTypes.size() == 1) {
-      return getOnlyElement(frameworkTypes);
-    } else if (frameworkTypes.equals(CONTRIBUTION_TYPES)) {
-      return FrameworkType.PROVIDER;
-    } else {
-      throw new IllegalArgumentException("Bad set of framework classes: " + frameworkTypes);
-    }
+    return frameworkTypes.size() == 1 ? getOnlyElement(frameworkTypes) : FrameworkType.PROVIDER;
   }
-
-  private static final ImmutableSet<FrameworkType> CONTRIBUTION_TYPES =
-      Sets.immutableEnumSet(FrameworkType.PROVIDER, FrameworkType.PRODUCER);
 }
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 0728828b7..3ee1ecb84 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -48,6 +48,7 @@
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
+import dagger.producers.internal.CancellationListener;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -116,6 +117,12 @@
      * subcomponents.
      */
     MODIFIABLE_BINDING_METHOD,
+
+    /**
+     * The {@link CancellationListener#onProducerFutureCancelled(boolean)} method for a production
+     * component.
+     */
+    CANCELLATION_LISTENER_METHOD,
     ;
   }
 
@@ -145,6 +152,7 @@
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
   private final List<CodeBlock> initializations = new ArrayList<>();
+  private final List<CodeBlock> cancellations = new ArrayList<>();
   private final ListMultimap<FieldSpecKind, FieldSpec> fieldSpecsMap =
       MultimapBuilder.enumKeys(FieldSpecKind.class).arrayListValues().build();
   private final ListMultimap<MethodSpecKind, MethodSpec> methodSpecsMap =
@@ -392,6 +400,11 @@ void addInitialization(CodeBlock codeBlock) {
     initializations.add(codeBlock);
   }
 
+  /** Adds the given code block to the cancellation listener method of the component. */
+  void addCancellation(CodeBlock codeBlock) {
+    cancellations.add(codeBlock);
+  }
+
   /** Returns a new, unique field name for the component based on the given name. */
   String getUniqueFieldName(String name) {
     return componentFieldNames.getUniqueName(name);
@@ -438,6 +451,11 @@ void claimMethodName(CharSequence name) {
     return ImmutableList.copyOf(initializations);
   }
 
+  /** Returns the list of {@link CodeBlock}s that need to go in the cancellation listener method. */
+  ImmutableList<CodeBlock> getCancellations() {
+    return ImmutableList.copyOf(cancellations);
+  }
+
   /**
    * Returns the {@link ModifiableBindingMethod}s for this subcomponent implementation and its
    * superclasses.
diff --git a/java/dagger/internal/codegen/OptionalFactories.java b/java/dagger/internal/codegen/OptionalFactories.java
index 784b8ec9b..71523b9eb 100644
--- a/java/dagger/internal/codegen/OptionalFactories.java
+++ b/java/dagger/internal/codegen/OptionalFactories.java
@@ -31,6 +31,7 @@
 import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.PRESENT_FACTORY;
 import static dagger.internal.codegen.RequestKinds.requestTypeName;
 import static dagger.internal.codegen.TypeNames.PROVIDER;
+import static dagger.internal.codegen.TypeNames.abstractProducerOf;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -60,6 +61,7 @@
 import dagger.producers.internal.Producers;
 import java.util.Comparator;
 import java.util.Map;
+import java.util.Optional;
 import java.util.TreeMap;
 import java.util.concurrent.Executor;
 import javax.inject.Provider;
@@ -206,6 +208,44 @@ ParameterizedTypeName delegateType() {
       return frameworkType().frameworkClassOf(typeVariable());
     }
 
+    /** Returns the superclass the generated factory should have, if any. */
+    Optional<ParameterizedTypeName> superclass() {
+      switch (frameworkType()) {
+        case PRODUCER_NODE:
+          // TODO(cgdecker): This probably isn't a big issue for now, but it's possible this
+          // shouldn't be an AbstractProducer:
+          // - As AbstractProducer, it'll only call the delegate's get() method once and then cache
+          //   that result (essentially) rather than calling the delegate's get() method each time
+          //   its get() method is called (which was what it did before the cancellation change).
+          // - It's not 100% clear to me whether the view-creation methods should return a view of
+          //   the same view created by the delegate or if they should just return their own views.
+          return Optional.of(abstractProducerOf(optionalType()));
+        default:
+          return Optional.empty();
+      }
+    }
+
+    /** Returns the superinterface the generated factory should have, if any. */
+    Optional<ParameterizedTypeName> superinterface() {
+      switch (frameworkType()) {
+        case PROVIDER:
+          return Optional.of(factoryType());
+        default:
+          return Optional.empty();
+      }
+    }
+
+    /** Returns the name of the factory method to generate. */
+    String factoryMethodName() {
+      switch (frameworkType()) {
+        case PROVIDER:
+          return "get";
+        case PRODUCER_NODE:
+          return "compute";
+      }
+      throw new AssertionError(frameworkType());
+    }
+
     /** The name of the factory class. */
     String factoryClassName() {
       return new StringBuilder("Present")
@@ -263,12 +303,19 @@ private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
     FieldSpec delegateField =
         FieldSpec.builder(spec.delegateType(), "delegate", PRIVATE, FINAL).build();
     ParameterSpec delegateParameter = ParameterSpec.builder(delegateField.type, "delegate").build();
-    return classBuilder(spec.factoryClassName())
-        .addTypeVariable(spec.typeVariable())
-        .addModifiers(PRIVATE, STATIC, FINAL)
-        .addSuperinterface(spec.factoryType())
-        .addJavadoc(
-            "A {@code $T} that uses a delegate {@code $T}.", spec.factoryType(), delegateField.type)
+    TypeSpec.Builder factoryClassBuilder =
+        classBuilder(spec.factoryClassName())
+            .addTypeVariable(spec.typeVariable())
+            .addModifiers(PRIVATE, STATIC, FINAL)
+            .addJavadoc(
+                "A {@code $T} that uses a delegate {@code $T}.",
+                spec.factoryType(),
+                delegateField.type);
+
+    spec.superclass().ifPresent(factoryClassBuilder::superclass);
+    spec.superinterface().ifPresent(factoryClassBuilder::addSuperinterface);
+
+    return factoryClassBuilder
         .addField(delegateField)
         .addMethod(
             constructorBuilder()
@@ -299,7 +346,7 @@ private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
   private MethodSpec presentOptionalFactoryGetMethod(
       PresentFactorySpec spec, FieldSpec delegateField) {
     MethodSpec.Builder getMethodBuilder =
-        methodBuilder("get").addAnnotation(Override.class).addModifiers(PUBLIC);
+        methodBuilder(spec.factoryMethodName()).addAnnotation(Override.class).addModifiers(PUBLIC);
 
     switch (spec.frameworkType()) {
       case PROVIDER:
@@ -313,7 +360,7 @@ private MethodSpec presentOptionalFactoryGetMethod(
                             spec.valueKind(), CodeBlock.of("$N", delegateField))))
             .build();
 
-      case PRODUCER:
+      case PRODUCER_NODE:
         getMethodBuilder.returns(listenableFutureOf(spec.optionalType()));
 
         switch (spec.valueKind()) {
@@ -325,7 +372,7 @@ private MethodSpec presentOptionalFactoryGetMethod(
                     Futures.class,
                     spec.optionalKind()
                         .presentExpression(
-                            FrameworkType.PRODUCER.to(
+                            FrameworkType.PRODUCER_NODE.to(
                                 spec.valueKind(), CodeBlock.of("$N", delegateField))))
                 .build();
 
diff --git a/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 8cb913d54..efc0c515e 100644
--- a/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -59,6 +59,7 @@
 import dagger.model.RequestKind;
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducesMethodProducer;
+import dagger.producers.internal.Producers;
 import java.util.Map;
 import java.util.Optional;
 import javax.annotation.processing.Filer;
@@ -133,43 +134,44 @@ Element originatingElement(ProductionBinding binding) {
                     TypeName.get(binding.bindingTypeElement().get().asType())))
             : Optional.empty();
 
-    String executorParameterName = null;
-    String monitorParameterName = null;
-    for (Map.Entry<Key, FrameworkField> entry :
-        generateBindingFieldsForDependencies(binding).entrySet()) {
-      Key key = entry.getKey();
-      FrameworkField bindingField = entry.getValue();
-      String fieldName = uniqueFieldNames.getUniqueName(bindingField.name());
-      if (key.equals(keyFactory.forProductionImplementationExecutor())) {
-        executorParameterName = fieldName;
-        constructorBuilder.addParameter(bindingField.type(), executorParameterName);
-        continue;
-      } else if (key.equals(keyFactory.forProductionComponentMonitor())) {
-        monitorParameterName = fieldName;
-        constructorBuilder.addParameter(bindingField.type(), monitorParameterName);
-        continue;
-      }
-      FieldSpec field =
-          addFieldAndConstructorParameter(
-              factoryBuilder, constructorBuilder, fieldName, bindingField.type());
-      fieldsBuilder.put(key, field);
-    }
+    String[] executorParameterName = new String[1];
+    String[] monitorParameterName = new String[1];
+    Map<Key, FrameworkField> bindingFieldsForDependencies =
+        generateBindingFieldsForDependencies(binding);
+    bindingFieldsForDependencies.forEach(
+        (key, bindingField) -> {
+          String fieldName = uniqueFieldNames.getUniqueName(bindingField.name());
+          if (key.equals(keyFactory.forProductionImplementationExecutor())) {
+            executorParameterName[0] = fieldName;
+            constructorBuilder.addParameter(bindingField.type(), executorParameterName[0]);
+          } else if (key.equals(keyFactory.forProductionComponentMonitor())) {
+            monitorParameterName[0] = fieldName;
+            constructorBuilder.addParameter(bindingField.type(), monitorParameterName[0]);
+          } else {
+            FieldSpec field =
+                addFieldAndConstructorParameter(
+                    factoryBuilder, constructorBuilder, fieldName, bindingField.type());
+            fieldsBuilder.put(key, field);
+          }
+        });
     ImmutableMap<Key, FieldSpec> fields = fieldsBuilder.build();
 
     constructorBuilder.addStatement(
         "super($N, $L, $N)",
-        verifyNotNull(monitorParameterName),
+        verifyNotNull(monitorParameterName[0]),
         producerTokenConstruction(generatedTypeName, binding),
-        verifyNotNull(executorParameterName));
+        verifyNotNull(executorParameterName[0]));
 
     if (binding.requiresModuleInstance()) {
-      assignField(constructorBuilder, moduleField.get());
-    }
-    
-    for (FieldSpec field : fields.values()) {
-      assignField(constructorBuilder, field);
+      assignField(constructorBuilder, moduleField.get(), null);
     }
 
+    fields.forEach(
+        (key, field) -> {
+          ParameterizedTypeName type = bindingFieldsForDependencies.get(key).type();
+          assignField(constructorBuilder, field, type);
+        });
+
     MethodSpec.Builder collectDependenciesBuilder =
         methodBuilder("collectDependencies")
             .addAnnotation(Override.class)
@@ -235,8 +237,14 @@ private static FieldSpec addFieldAndConstructorParameter(
     return field;
   }
 
-  private static void assignField(MethodSpec.Builder constructorBuilder, FieldSpec field) {
-    constructorBuilder.addStatement("this.$1N = $1N", field);
+  private static void assignField(
+      MethodSpec.Builder constructorBuilder, FieldSpec field, ParameterizedTypeName type) {
+    if (type != null && type.rawType.equals(TypeNames.PRODUCER)) {
+      constructorBuilder.addStatement(
+          "this.$1N = $2T.nonCancellationPropagatingViewOf($1N)", field, Producers.class);
+    } else {
+      constructorBuilder.addStatement("this.$1N = $1N", field);
+    }
   }
 
   /** Returns a list of dependencies that are generated asynchronously. */
diff --git a/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
new file mode 100644
index 000000000..dd8689e8e
--- /dev/null
+++ b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.FRAMEWORK_FIELD;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.TypeName;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.producers.Producer;
+import dagger.producers.internal.Producers;
+import javax.lang.model.type.TypeMirror;
+
+/** Binding expression for producer node instances. */
+final class ProducerNodeInstanceBindingExpression extends FrameworkInstanceBindingExpression {
+
+  static final String MAY_INTERRUPT_IF_RUNNING = "mayInterruptIfRunning";
+
+  /** Model for the component defining this binding. */
+  private final GeneratedComponentModel generatedComponentModel;
+
+  private final TypeMirror type;
+  private boolean addedCancellationStatement = false;
+
+  ProducerNodeInstanceBindingExpression(
+      ResolvedBindings resolvedBindings,
+      FrameworkInstanceSupplier frameworkInstanceSupplier,
+      DaggerTypes types,
+      DaggerElements elements,
+      GeneratedComponentModel generatedComponentModel) {
+    super(resolvedBindings, frameworkInstanceSupplier, types, elements);
+    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.type = types.wrapType(resolvedBindings.key().type(), Producer.class);
+  }
+
+  @Override
+  protected FrameworkType frameworkType() {
+    return FrameworkType.PRODUCER_NODE;
+  }
+
+  @Override
+  Expression getDependencyExpression(ClassName requestingClass) {
+    Expression result = super.getDependencyExpression(requestingClass);
+    if (!addedCancellationStatement) {
+      CodeBlock cancel =
+          CodeBlock.of(
+              "$T.cancel($L, $L);", Producers.class, result.codeBlock(), MAY_INTERRUPT_IF_RUNNING);
+      generatedComponentModel.addCancellation(cancel);
+      addedCancellationStatement = true;
+    }
+    return result;
+  }
+
+  @Override
+  Expression getDependencyExpressionForComponentMethod(
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+    if (component.componentDescriptor().kind().isProducer()) {
+      return Expression.create(type, "$N", createField(componentMethod, component));
+    } else {
+      // If the component isn't a production component, it won't implement CancellationListener and
+      // as such we can't create an entry point. But this binding must also just be a Producer from
+      // Provider anyway in that case, so there shouldn't be an issue.
+      // TODO(b/116855531): Is it really intended that a non-production component can have Producer
+      // entry points?
+      return super.getDependencyExpressionForComponentMethod(componentMethod, component);
+    }
+  }
+
+  private FieldSpec createField(
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+    // TODO(cgdecker): Use a FrameworkFieldInitializer for this?
+    // Though I don't think we need the once-only behavior of that, since I think
+    // getComponentMethodImplementation will only be called once anyway
+    String methodName = componentMethod.methodElement().getSimpleName().toString();
+    FieldSpec field =
+        FieldSpec.builder(
+                TypeName.get(type),
+                component.getUniqueFieldName(methodName + "EntryPoint"),
+                PRIVATE)
+            .build();
+    component.addField(FRAMEWORK_FIELD, field);
+
+    CodeBlock fieldInitialization =
+        CodeBlock.of(
+            "this.$N = $T.entryPointViewOf($L, this);",
+            field,
+            Producers.class,
+            getDependencyExpression(component.name()).codeBlock());
+    component.addInitialization(fieldInitialization);
+
+    return field;
+  }
+}
diff --git a/java/dagger/internal/codegen/TypeNames.java b/java/dagger/internal/codegen/TypeNames.java
index d6b01c768..ed2ee286b 100644
--- a/java/dagger/internal/codegen/TypeNames.java
+++ b/java/dagger/internal/codegen/TypeNames.java
@@ -39,6 +39,7 @@
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducer;
+import dagger.producers.internal.DependencyMethodProducer;
 import dagger.producers.internal.MapOfProducedProducer;
 import dagger.producers.internal.MapOfProducerProducer;
 import dagger.producers.internal.MapProducer;
@@ -60,6 +61,7 @@
 
   static final ClassName ABSTRACT_PRODUCER = ClassName.get(AbstractProducer.class);
   static final ClassName ASYNC_FUNCTION = ClassName.get(AsyncFunction.class);
+  static final ClassName DEPENDENCY_METHOD_PRODUCER = ClassName.get(DependencyMethodProducer.class);
   static final ClassName DOUBLE_CHECK = ClassName.get(DoubleCheck.class);
   static final ClassName EXECUTOR = ClassName.get(Executor.class);
   static final ClassName FACTORY = ClassName.get(Factory.class);
@@ -139,6 +141,10 @@ static ParameterizedTypeName producerOf(TypeName typeName) {
     return ParameterizedTypeName.get(PRODUCER, typeName);
   }
 
+  static ParameterizedTypeName dependencyMethodProducerOf(TypeName typeName) {
+    return ParameterizedTypeName.get(DEPENDENCY_METHOD_PRODUCER, typeName);
+  }
+
   static ParameterizedTypeName providerOf(TypeName typeName) {
     return ParameterizedTypeName.get(PROVIDER, typeName);
   }
diff --git a/java/dagger/producers/internal/AbstractProducer.java b/java/dagger/producers/internal/AbstractProducer.java
index 2af9470c1..3dcd906da 100644
--- a/java/dagger/producers/internal/AbstractProducer.java
+++ b/java/dagger/producers/internal/AbstractProducer.java
@@ -16,14 +16,17 @@
 
 package dagger.producers.internal;
 
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
+import com.google.common.util.concurrent.AbstractFuture;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
+import java.util.concurrent.atomic.AtomicBoolean;
 
-/**
- * An abstract {@link Producer} implementation that memoizes the result of its compute method.
- */
-public abstract class AbstractProducer<T> implements Producer<T> {
-  private volatile ListenableFuture<T> instance = null;
+/** An abstract {@link Producer} implementation that memoizes the result of its compute method. */
+public abstract class AbstractProducer<T> implements CancellableProducer<T> {
+  private final AtomicBoolean requested = new AtomicBoolean();
+  private final NonExternallyCancellableFuture<T> future = new NonExternallyCancellableFuture<T>();
 
   protected AbstractProducer() {}
 
@@ -32,19 +35,133 @@ protected AbstractProducer() {}
 
   @Override
   public final ListenableFuture<T> get() {
-    // double-check idiom from EJ2: Item 71
-    ListenableFuture<T> result = instance;
-    if (result == null) {
-      synchronized (this) {
-        result = instance;
-        if (result == null) {
-          instance = result = compute();
-          if (result == null) {
-            throw new NullPointerException("compute returned null");
-          }
-        }
-      }
+    if (requested.compareAndSet(false, true)) {
+      future.setFuture(compute());
     }
+    return future;
+  }
+
+  @Override
+  public final void cancel(boolean mayInterruptIfRunning) {
+    requested.set(true); // Avoid potentially starting the task later only to cancel it immediately.
+    future.doCancel(mayInterruptIfRunning);
+  }
+
+  @Override
+  public Producer<T> newDependencyView() {
+    return new NonCancellationPropagatingView();
+  }
+
+  @Override
+  public Producer<T> newEntryPointView(CancellationListener cancellationListener) {
+    NonCancellationPropagatingView result = new NonCancellationPropagatingView();
+    result.addCancellationListener(cancellationListener);
     return result;
   }
+
+  /**
+   * A view of this producer that returns a future that can be cancelled without cancelling the
+   * producer itself.
+   */
+  private final class NonCancellationPropagatingView implements Producer<T> {
+    /**
+     * An independently cancellable view of this node. Needs to be cancellable by normal future
+     * cancellation so that the view at an entry point can listen for its cancellation.
+     */
+    private final ListenableFuture<T> viewFuture = nonCancellationPropagating(future);
+
+    @SuppressWarnings("FutureReturnValueIgnored")
+    @Override
+    public ListenableFuture<T> get() {
+      AbstractProducer.this.get(); // force compute()
+      return viewFuture;
+    }
+
+    void addCancellationListener(final CancellationListener cancellationListener) {
+      viewFuture.addListener(
+          new Runnable() {
+            @Override
+            public void run() {
+              if (viewFuture.isCancelled()) {
+                boolean mayInterruptIfRunning =
+                    viewFuture instanceof NonCancellationPropagatingFuture
+                        && ((NonCancellationPropagatingFuture) viewFuture).interrupted();
+                cancellationListener.onProducerFutureCancelled(mayInterruptIfRunning);
+              }
+            }
+          },
+          directExecutor());
+    }
+  }
+
+  /** A settable future that can't be cancelled via normal future cancellation. */
+  private static final class NonExternallyCancellableFuture<T> extends AbstractFuture<T> {
+
+    @Override
+    public boolean setFuture(ListenableFuture<? extends T> future) {
+      return super.setFuture(future);
+    }
+
+    @Override
+    public boolean cancel(boolean mayInterruptIfRunning) {
+      return false;
+    }
+
+    /** Actually cancels this future. */
+    void doCancel(boolean mayInterruptIfRunning) {
+      super.cancel(mayInterruptIfRunning);
+    }
+  }
+
+  private static <T> ListenableFuture<T> nonCancellationPropagating(ListenableFuture<T> future) {
+    if (future.isDone()) {
+      return future;
+    }
+    NonCancellationPropagatingFuture<T> output = new NonCancellationPropagatingFuture<T>(future);
+    future.addListener(output, directExecutor());
+    return output;
+  }
+
+  /**
+   * Equivalent to {@code Futures.nonCancellationPropagating}, but allowing us to check whether or
+   * not {@code mayInterruptIfRunning} was set when cancelling it.
+   */
+  private static final class NonCancellationPropagatingFuture<T> extends AbstractFuture<T>
+      implements Runnable {
+    // TODO(cgdecker): This is copied directly from Producers.nonCancellationPropagating, but try
+    // to find out why this doesn't need to be volatile.
+    private ListenableFuture<T> delegate;
+
+    NonCancellationPropagatingFuture(final ListenableFuture<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public void run() {
+      // This prevents cancellation from propagating because we don't call setFuture(delegate) until
+      // delegate is already done, so calling cancel() on this future won't affect it.
+      ListenableFuture<T> localDelegate = delegate;
+      if (localDelegate != null) {
+        setFuture(localDelegate);
+      }
+    }
+
+    @Override
+    protected String pendingToString() {
+      ListenableFuture<T> localDelegate = delegate;
+      if (localDelegate != null) {
+        return "delegate=[" + localDelegate + "]";
+      }
+      return null;
+    }
+
+    @Override
+    protected void afterDone() {
+      delegate = null;
+    }
+
+    public boolean interrupted() {
+      return super.wasInterrupted();
+    }
+  }
 }
diff --git a/java/dagger/producers/internal/CancellableProducer.java b/java/dagger/producers/internal/CancellableProducer.java
new file mode 100644
index 000000000..6a1475e5a
--- /dev/null
+++ b/java/dagger/producers/internal/CancellableProducer.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+import dagger.producers.Producer;
+
+/** A {@link Producer} that can be cancelled directly even if it hasn't been started. */
+public interface CancellableProducer<T> extends Producer<T> {
+
+  /**
+   * Cancels this producer. If {@link #get()} has already been called, the future it returns will be
+   * cancelled if possible. If not, calling {@link #get()} will return a cancelled future and will
+   * not actually start the underlying operation.
+   *
+   * @param mayInterruptIfRunning the value that should be passed to {@code Future.cancel(boolean)}
+   *     for the futures for any running tasks when cancelling them
+   */
+  void cancel(boolean mayInterruptIfRunning);
+
+  /** Returns a new view of this producer for use as a dependency of another node. */
+  Producer<T> newDependencyView();
+
+  /**
+   * Returns a new view of this producer for use as an entry point.
+   *
+   * <p>When the view's future is cancelled, the given {@code cancellableListener} will be called.
+   */
+  Producer<T> newEntryPointView(CancellationListener cancellationListener);
+}
diff --git a/java/dagger/producers/internal/CancellationListener.java b/java/dagger/producers/internal/CancellationListener.java
new file mode 100644
index 000000000..182ddc6b3
--- /dev/null
+++ b/java/dagger/producers/internal/CancellationListener.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+/** A listener for producer future cancellation. */
+public interface CancellationListener {
+  /** Called when the future for a producer this listener has been added to is cancelled. */
+  // Note that this name is intentionally a bit verbose to make it unlikely that it will conflict
+  // with any user-defined methods on a component.
+  void onProducerFutureCancelled(boolean mayInterruptIfRunning);
+}
diff --git a/java/dagger/producers/internal/DependencyMethodProducer.java b/java/dagger/producers/internal/DependencyMethodProducer.java
new file mode 100644
index 000000000..be118f2d2
--- /dev/null
+++ b/java/dagger/producers/internal/DependencyMethodProducer.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
+import com.google.common.collect.MapMaker;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import java.util.Collections;
+import java.util.Set;
+
+/**
+ * Abstract class for implementing producers derived from methods on component dependencies.
+ *
+ * <p>Unlike most other {@link CancellableProducer} implementations, cancelling the future returned
+ * by a {@linkplain #newDependencyView dependency view} injected into an {@code @Produces} method
+ * will actually cancel the underlying future. This is because the future comes from outside the
+ * component's producer graph (including possibly from another object that isn't a component at
+ * all), so if we don't cancel it when the user asks to cancel it, there might just be no way to
+ * cancel it at all.
+ */
+public abstract class DependencyMethodProducer<T> implements CancellableProducer<T> {
+
+  /** Weak set of all incomplete futures this producer has returned. */
+  private final Set<ListenableFuture<T>> futures =
+      Collections.newSetFromMap(new MapMaker().weakKeys().<ListenableFuture<T>, Boolean>makeMap());
+
+  private boolean cancelled = false;
+
+  /** Calls a method on a component dependency to get a future. */
+  protected abstract ListenableFuture<T> callDependencyMethod();
+
+  @Override
+  public final ListenableFuture<T> get() {
+    synchronized (futures) {
+      if (cancelled) {
+        return Futures.immediateCancelledFuture();
+      }
+
+      final ListenableFuture<T> future = callDependencyMethod();
+      if (!future.isDone() && futures.add(future)) {
+        future.addListener(
+            new Runnable() {
+              @Override
+              public void run() {
+                synchronized (futures) {
+                  futures.remove(future);
+                }
+              }
+            },
+            directExecutor());
+      }
+      return future;
+    }
+  }
+
+  @Override
+  public final void cancel(boolean mayInterruptIfRunning) {
+    synchronized (futures) {
+      cancelled = true;
+      for (ListenableFuture<T> future : futures) {
+        // futures is a concurrent set so that the concurrent removal that will happen here is not
+        // a problem
+        future.cancel(mayInterruptIfRunning);
+      }
+    }
+  }
+
+  @Override
+  public final Producer<T> newDependencyView() {
+    return this;
+  }
+
+  @Override
+  public final Producer<T> newEntryPointView(final CancellationListener cancellationListener) {
+    return new Producer<T>() {
+      private final Set<ListenableFuture<T>> entryPointFutures =
+          Collections.newSetFromMap(
+              new MapMaker().weakKeys().<ListenableFuture<T>, Boolean>makeMap());
+
+      @Override
+      public ListenableFuture<T> get() {
+        final ListenableFuture<T> future = DependencyMethodProducer.this.get();
+        if (!future.isDone() && entryPointFutures.add(future)) {
+          future.addListener(
+              new Runnable() {
+                @Override
+                public void run() {
+                  entryPointFutures.remove(future);
+                  if (future.isCancelled()) {
+                    // TODO(cgdecker): Make this also propagate the actual value that was passed for
+                    // mayInterruptIfRunning
+                    cancellationListener.onProducerFutureCancelled(true);
+                  }
+                }
+              },
+              directExecutor());
+        }
+        return future;
+      }
+    };
+  }
+}
diff --git a/java/dagger/producers/internal/MapOfProducerProducer.java b/java/dagger/producers/internal/MapOfProducerProducer.java
index ef1659224..78b2c017c 100644
--- a/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -17,9 +17,13 @@
 package dagger.producers.internal;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.producers.internal.Producers.entryPointViewOf;
+import static dagger.producers.internal.Producers.nonCancellationPropagatingViewOf;
 import static dagger.producers.internal.Producers.producerFromProvider;
 
+import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
@@ -72,4 +76,45 @@ private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
       return new MapOfProducerProducer<>(mapBuilder.build());
     }
   }
+
+  @Override
+  public Producer<Map<K, Producer<V>>> newDependencyView() {
+    return newTransformedValuesView(MapOfProducerProducer.<V>toDependencyView());
+  }
+
+  @Override
+  public Producer<Map<K, Producer<V>>> newEntryPointView(
+      CancellationListener cancellationListener) {
+    return newTransformedValuesView(
+        MapOfProducerProducer.<V>toEntryPointView(cancellationListener));
+  }
+
+  private Producer<Map<K, Producer<V>>> newTransformedValuesView(
+      Function<Producer<V>, Producer<V>> valueTransformationFunction) {
+    return Producers.<Map<K, Producer<V>>>immediateProducer(
+        ImmutableMap.copyOf(Maps.transformValues(contributingMap, valueTransformationFunction)));
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> Function<Producer<T>, Producer<T>> toDependencyView() {
+    return (Function) TO_DEPENDENCY_VIEW;
+  }
+
+  private static <T> Function<Producer<T>, Producer<T>> toEntryPointView(
+      final CancellationListener cancellationListener) {
+    return new Function<Producer<T>, Producer<T>>() {
+      @Override
+      public Producer<T> apply(Producer<T> input) {
+        return entryPointViewOf(input, cancellationListener);
+      }
+    };
+  }
+
+  private static final Function<Producer<?>, Producer<?>> TO_DEPENDENCY_VIEW =
+      new Function<Producer<?>, Producer<?>>() {
+        @Override
+        public Producer<?> apply(Producer<?> input) {
+          return nonCancellationPropagatingViewOf(input);
+        }
+      };
 }
diff --git a/java/dagger/producers/internal/Producers.java b/java/dagger/producers/internal/Producers.java
index 4de3354ee..b50a95ef2 100644
--- a/java/dagger/producers/internal/Producers.java
+++ b/java/dagger/producers/internal/Producers.java
@@ -126,7 +126,7 @@
    */
   public static <T> Producer<T> producerFromProvider(final Provider<T> provider) {
     checkNotNull(provider);
-    return new Producer<T>() {
+    return new CompletedProducer<T>() {
       @Override
       public ListenableFuture<T> get() {
         return Futures.immediateFuture(provider.get());
@@ -136,24 +136,76 @@
 
   /** Returns a producer that succeeds with the given value. */
   public static <T> Producer<T> immediateProducer(final T value) {
-    return new Producer<T>() {
+    final ListenableFuture<T> future = Futures.immediateFuture(value);
+    return new CompletedProducer<T>() {
       @Override
       public ListenableFuture<T> get() {
-        return Futures.immediateFuture(value);
+        return future;
       }
     };
   }
 
   /** Returns a producer that fails with the given exception. */
   public static <T> Producer<T> immediateFailedProducer(final Throwable throwable) {
-    return new Producer<T>() {
+    final ListenableFuture<T> future = Futures.immediateFailedFuture(throwable);
+    return new CompletedProducer<T>() {
       @Override
       public ListenableFuture<T> get() {
-        return Futures.immediateFailedFuture(throwable);
+        return future;
       }
     };
   }
 
+  /**
+   * Returns a new view of the given {@code producer} if and only if it is a {@link
+   * CancellableProducer}. Cancelling the returned producer's future will not cancel the underlying
+   * task for the given producer.
+   *
+   * @throws IllegalArgumentException if {@code producer} is not a {@code CancellableProducer}
+   */
+  public static <T> Producer<T> nonCancellationPropagatingViewOf(Producer<T> producer) {
+    // This is a hack until we change the types of Producer fields to be CancellableProducer or
+    // some other type.
+    if (producer instanceof CancellableProducer) {
+      return ((CancellableProducer<T>) producer).newDependencyView();
+    }
+    throw new IllegalArgumentException(
+        "nonCancellationPropagatingViewOf called with non-CancellableProducer: " + producer);
+  }
+
+  /**
+   * Returns a new view of the given {@code producer} for use as an entry point in a production
+   * component, if and only if it is a {@link CancellableProducer}. When the returned producer's
+   * future is cancelled, the given {@code cancellable} will also be cancelled.
+   *
+   * @throws IllegalArgumentException if {@code producer} is not a {@code CancellableProducer}
+   */
+  public static <T> Producer<T> entryPointViewOf(
+      Producer<T> producer, CancellationListener cancellationListener) {
+    // This is a hack until we change the types of Producer fields to be CancellableProducer or
+    // some other type.
+    if (producer instanceof CancellableProducer) {
+      return ((CancellableProducer<T>) producer).newEntryPointView(cancellationListener);
+    }
+    throw new IllegalArgumentException(
+        "entryPointViewOf called with non-CancellableProducer: " + producer);
+  }
+
+  /**
+   * Calls {@code cancel} on the given {@code producer} if it is a {@link CancellableProducer}.
+   *
+   * @throws IllegalArgumentException if {@code producer} is not a {@code CancellableProducer}
+   */
+  public static void cancel(Producer<?> producer, boolean mayInterruptIfRunning) {
+    // This is a hack until we change the types of Producer fields to be CancellableProducer or
+    // some other type.
+    if (producer instanceof CancellableProducer) {
+      ((CancellableProducer<?>) producer).cancel(mayInterruptIfRunning);
+    } else {
+      throw new IllegalArgumentException("cancel called with non-CancellableProducer: " + producer);
+    }
+  }
+
   private static final Producer<Map<Object, Object>> EMPTY_MAP_PRODUCER =
       Producers.<Map<Object, Object>>immediateProducer(ImmutableMap.of());
 
@@ -162,5 +214,24 @@
     return (Producer<Map<K, V>>) (Producer) EMPTY_MAP_PRODUCER;
   }
 
+  /**
+   * A {@link CancellableProducer} which can't be cancelled because it represents an
+   * already-completed task.
+   */
+  private abstract static class CompletedProducer<T> implements CancellableProducer<T> {
+    @Override
+    public void cancel(boolean mayInterruptIfRunning) {}
+
+    @Override
+    public Producer<T> newDependencyView() {
+      return this;
+    }
+
+    @Override
+    public Producer<T> newEntryPointView(CancellationListener cancellationListener) {
+      return this;
+    }
+  }
+
   private Producers() {}
 }
diff --git a/java/dagger/producers/internal/SetProducer.java b/java/dagger/producers/internal/SetProducer.java
index 4577db991..687b9ee3c 100644
--- a/java/dagger/producers/internal/SetProducer.java
+++ b/java/dagger/producers/internal/SetProducer.java
@@ -39,12 +39,7 @@
  */
 public final class SetProducer<T> extends AbstractProducer<Set<T>> {
   private static final Producer<Set<Object>> EMPTY_PRODUCER =
-      new Producer<Set<Object>>() {
-        @Override
-        public ListenableFuture<Set<Object>> get() {
-          return Futures.<Set<Object>>immediateFuture(ImmutableSet.<Object>of());
-        }
-      };
+      Producers.<Set<Object>>immediateProducer(ImmutableSet.<Object>of());
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
   public static <T> Producer<Set<T>> empty() {
diff --git a/javatests/dagger/functional/producers/ProducerFactoryTest.java b/javatests/dagger/functional/producers/ProducerFactoryTest.java
index 1134ffed4..ba39b9784 100644
--- a/javatests/dagger/functional/producers/ProducerFactoryTest.java
+++ b/javatests/dagger/functional/producers/ProducerFactoryTest.java
@@ -26,6 +26,8 @@
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.Producer;
+import dagger.producers.internal.AbstractProducer;
+import dagger.producers.internal.CancellableProducer;
 import dagger.producers.monitoring.ProducerMonitor;
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
@@ -87,7 +89,7 @@ public void noArgMethod() throws Exception {
   @Test
   public void singleArgMethod() throws Exception {
     SettableFuture<Integer> intFuture = SettableFuture.create();
-    Producer<Integer> intProducer = producerOfFuture(intFuture);
+    CancellableProducer<Integer> intProducer = producerOfFuture(intFuture);
     Producer<String> producer =
         new SimpleProducerModule_StrWithArgFactory(
             executorProvider, componentMonitorProvider, intProducer);
@@ -103,7 +105,8 @@ public void successMonitor() throws Exception {
     SettableFuture<String> strFuture = SettableFuture.create();
     @SuppressWarnings("FutureReturnValueIgnored")
     SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
-    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    CancellableProducer<SettableFuture<String>> strFutureProducer =
+        producerOfFuture(strFutureFuture);
     Producer<String> producer =
         new SimpleProducerModule_SettableFutureStrFactory(
             executorProvider, componentMonitorProvider, strFutureProducer);
@@ -131,7 +134,8 @@ public void failureMonitor() throws Exception {
     SettableFuture<String> strFuture = SettableFuture.create();
     @SuppressWarnings("FutureReturnValueIgnored")
     SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
-    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    CancellableProducer<SettableFuture<String>> strFutureProducer =
+        producerOfFuture(strFutureFuture);
     Producer<String> producer =
         new SimpleProducerModule_SettableFutureStrFactory(
             executorProvider, componentMonitorProvider, strFutureProducer);
@@ -188,10 +192,10 @@ public void nullComponentMonitorProvider() throws Exception {
     new SimpleProducerModule_StrFactory(executorProvider, null);
   }
 
-  private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
-    return new Producer<T>() {
+  private static <T> CancellableProducer<T> producerOfFuture(final ListenableFuture<T> future) {
+    return new AbstractProducer<T>() {
       @Override
-      public ListenableFuture<T> get() {
+      public ListenableFuture<T> compute() {
         return future;
       }
     };
diff --git a/javatests/dagger/functional/producers/cancellation/CancellationComponent.java b/javatests/dagger/functional/producers/cancellation/CancellationComponent.java
new file mode 100644
index 000000000..f06829e0f
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/CancellationComponent.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.BindsInstance;
+import dagger.functional.producers.cancellation.CancellationComponent.Dependency;
+import dagger.producers.Producer;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import java.util.concurrent.Executor;
+import javax.inject.Named;
+
+@ProductionComponent(modules = CancellationModule.class, dependencies = Dependency.class)
+interface CancellationComponent {
+
+  @Named("ep1")
+  ListenableFuture<String> entryPoint1();
+
+  @Named("ep2")
+  Producer<String> entryPoint2();
+
+  @Named("ep3")
+  ListenableFuture<String> entryPoint3();
+
+  CancellationSubcomponent.Builder subcomponentBuilder();
+
+  @ProductionComponent.Builder
+  interface Builder {
+    Builder module(CancellationModule module);
+
+    Builder dependency(Dependency dependency);
+
+    @BindsInstance
+    Builder executor(@Production Executor executor);
+
+    CancellationComponent build();
+  }
+
+  final class Dependency {
+
+    final ProducerTester tester;
+
+    Dependency(ProducerTester tester) {
+      this.tester = checkNotNull(tester);
+    }
+
+    @SuppressWarnings("unused") // Dagger uses it
+    ListenableFuture<String> getDependencyFuture() {
+      return tester.start("dependencyFuture");
+    }
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/CancellationModule.java b/javatests/dagger/functional/producers/cancellation/CancellationModule.java
new file mode 100644
index 000000000..ff7ee791f
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/CancellationModule.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Provides;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import javax.inject.Named;
+
+@SuppressWarnings("unused") // not actually using dependencies
+@ProducerModule(subcomponents = CancellationSubcomponent.class)
+final class CancellationModule {
+
+  private final ProducerTester tester;
+
+  CancellationModule(ProducerTester tester) {
+    this.tester = checkNotNull(tester);
+  }
+
+  @Produces
+  @Named("leaf1")
+  ListenableFuture<String> produceLeaf1() {
+    return tester.start("leaf1");
+  }
+
+  @Produces
+  @Named("leaf2")
+  ListenableFuture<String> produceLeaf2() {
+    return tester.start("leaf2");
+  }
+
+  @Produces
+  @Named("leaf3")
+  ListenableFuture<String> produceLeaf3() {
+    return tester.start("leaf3");
+  }
+
+  @Produces
+  @Named("foo")
+  ListenableFuture<String> produceFoo(@Named("leaf1") String leaf1, @Named("leaf2") String leaf2) {
+    return tester.start("foo");
+  }
+
+  @Produces
+  @Named("bar")
+  ListenableFuture<String> produceBar(@Named("leaf2") String leaf2, @Named("leaf3") String leaf3) {
+    return tester.start("bar");
+  }
+
+  @Produces
+  @Named("baz")
+  ListenableFuture<String> produceBaz(
+      @Named("foo") Producer<String> foo, @Named("bar") String bar) {
+    ListenableFuture<String> fooFuture = foo.get();
+    if (!fooFuture.isDone()) {
+      assertThat(fooFuture.cancel(true)).isTrue();
+      assertThat(fooFuture.isCancelled()).isTrue();
+    }
+    return tester.start("baz");
+  }
+
+  @Provides
+  @Named("providesDep")
+  static String provideProvidesDep() {
+    return "providesDep";
+  }
+
+  @Produces
+  @Named("qux")
+  ListenableFuture<String> produceQux(
+      @Named("baz") String baz, @Named("providesDep") String providesDep) {
+    return tester.start("qux");
+  }
+
+  @Produces
+  @Named("ep1")
+  ListenableFuture<String> produceEntryPoint1(@Named("qux") String qux) {
+    return tester.start("entryPoint1");
+  }
+
+  @Produces
+  @Named("ep2")
+  ListenableFuture<String> produceEntryPoint2(@Named("bar") String bar, String dependency) {
+    return tester.start("entryPoint2");
+  }
+
+  @Produces
+  @Named("ep3")
+  static ListenableFuture<String> produceEntryPoint3(Producer<String> dependencyProducer) {
+    ListenableFuture<String> dependencyFuture = dependencyProducer.get();
+    assertThat(dependencyFuture.isDone()).isFalse();
+    assertThat(dependencyFuture.cancel(true)).isTrue();
+    assertThat(dependencyFuture.isCancelled()).isTrue();
+    return dependencyFuture;
+  }
+}
diff --git a/java/dagger/internal/codegen/ProducerInstanceBindingExpression.java b/javatests/dagger/functional/producers/cancellation/CancellationSubcomponent.java
similarity index 51%
rename from java/dagger/internal/codegen/ProducerInstanceBindingExpression.java
rename to javatests/dagger/functional/producers/cancellation/CancellationSubcomponent.java
index 3edc2b6db..63b1a9d68 100644
--- a/java/dagger/internal/codegen/ProducerInstanceBindingExpression.java
+++ b/javatests/dagger/functional/producers/cancellation/CancellationSubcomponent.java
@@ -14,25 +14,22 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.functional.producers.cancellation;
 
-/** Binding expression for producer instances. */
-final class ProducerInstanceBindingExpression extends FrameworkInstanceBindingExpression {
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionSubcomponent;
+import javax.inject.Named;
 
-  ProducerInstanceBindingExpression(
-      ResolvedBindings resolvedBindings,
-      FrameworkInstanceSupplier frameworkInstanceSupplier,
-      DaggerTypes types,
-      DaggerElements elements) {
-    super(
-        resolvedBindings,
-        frameworkInstanceSupplier,
-        types,
-        elements);
-  }
+@ProductionSubcomponent(modules = CancellationSubcomponentModule.class)
+interface CancellationSubcomponent {
+
+  @Named("subEntryPoint")
+  ListenableFuture<String> subcomponentEntryPoint();
+
+  @ProductionSubcomponent.Builder
+  interface Builder {
+    Builder module(CancellationSubcomponentModule module);
 
-  @Override
-  protected FrameworkType frameworkType() {
-    return FrameworkType.PRODUCER;
+    CancellationSubcomponent build();
   }
 }
diff --git a/javatests/dagger/functional/producers/cancellation/CancellationSubcomponentModule.java b/javatests/dagger/functional/producers/cancellation/CancellationSubcomponentModule.java
new file mode 100644
index 000000000..9cedad462
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/CancellationSubcomponentModule.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import javax.inject.Named;
+
+@SuppressWarnings("unused") // not actually using dependencies
+@ProducerModule
+final class CancellationSubcomponentModule {
+
+  private final ProducerTester tester;
+
+  CancellationSubcomponentModule(ProducerTester tester) {
+    this.tester = checkNotNull(tester);
+  }
+
+  @Produces
+  @Named("subLeaf")
+  ListenableFuture<String> produceSubLeaf() {
+    return tester.start("subLeaf");
+  }
+
+  @Produces
+  @Named("subTask1")
+  ListenableFuture<String> produceSubTask1(
+      @Named("subLeaf") String subLeaf, @Named("qux") String qux) {
+    return tester.start("subTask1");
+  }
+
+  @Produces
+  @Named("subTask2")
+  ListenableFuture<String> produceSubTask2(@Named("foo") String foo, Producer<String> dependency) {
+    ListenableFuture<String> dependencyFuture = dependency.get();
+    assertThat(dependencyFuture.cancel(true)).isTrue();
+    assertThat(dependencyFuture.isCancelled()).isTrue();
+    return tester.start("subTask2");
+  }
+
+  @Produces
+  @Named("subEntryPoint")
+  ListenableFuture<String> produceSubEntryPoint(
+      @Named("subTask1") String subTask1, @Named("subTask2") String subTask2) {
+    return tester.start("subEntryPoint");
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/ProducerCancellationTest.java b/javatests/dagger/functional/producers/cancellation/ProducerCancellationTest.java
new file mode 100644
index 000000000..23b31d2f5
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/ProducerCancellationTest.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.functional.producers.cancellation.CancellationComponent.Dependency;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests cancellation of tasks in production components. */
+@RunWith(JUnit4.class)
+public class ProducerCancellationTest {
+
+  private final ProducerTester tester = new ProducerTester();
+  private final CancellationComponent component =
+      DaggerCancellationComponent.builder()
+          .module(new CancellationModule(tester))
+          .dependency(new Dependency(tester))
+          .executor(MoreExecutors.directExecutor())
+          .build();
+
+  @Test
+  public void initialState() {
+    tester.assertNoStartedNodes();
+  }
+
+  @Test
+  public void cancellingOneEntryPoint_cancelsAllRunningNodes() {
+    ListenableFuture<String> entryPoint1 = component.entryPoint1();
+    tester.assertStarted("leaf2", "leaf3").only();
+
+    assertThat(entryPoint1.cancel(true)).isTrue();
+    assertThat(entryPoint1.isCancelled()).isTrue();
+
+    tester.assertCancelled("leaf2", "leaf3").only();
+
+    // The other entry points were also cancelled in the process, from the user's perspective.
+    assertThat(component.entryPoint2().get().isCancelled()).isTrue();
+    assertThat(component.entryPoint3().isCancelled()).isTrue();
+
+    // The underlying tasks weren't actually started, even though we just requested them above,
+    // because the node was cancelled already along with the component.
+    tester.assertNotStarted("entryPoint2", "entryPoint3");
+  }
+
+  @SuppressWarnings({"CheckReturnValue", "FutureReturnValueIgnored"})
+  @Test
+  public void cancellingNonEntryPointProducer_doesNotCancelUnderlyingTask() {
+    ListenableFuture<String> entryPoint1 = component.entryPoint1();
+    tester.assertStarted("leaf2", "leaf3").only();
+
+    tester.complete("leaf2", "leaf3");
+
+    tester.assertStarted("bar");
+
+    // foo's dependencies are complete, but it is not yet started because baz depends on
+    // Producer<foo>, so it won't be started until baz calls get() on it.
+    // baz not started yet because it needs bar to complete first.
+    tester.assertNotStarted("foo", "baz");
+
+    // Complete bar, triggering baz to run. It calls get() on the foo Producer, so that also starts
+    // once its dependency leaf1 is complete.
+    tester.complete("bar", "leaf1");
+    tester.assertStarted("baz", "foo");
+
+    // baz then cancelled the foo Producer's future, but that didn't cancel the underlying task.
+    tester.assertNotCancelled("foo");
+
+    // If we cancel the entry point, that does cancel the task.
+    entryPoint1.cancel(true);
+    tester.assertCancelled("foo");
+  }
+
+  @SuppressWarnings({"CheckReturnValue", "FutureReturnValueIgnored"})
+  @Test
+  public void cancellingProducerFromComponentDependency_cancelsUnderlyingTask() {
+    // Start leaf2/leaf3 tasks.
+    component.entryPoint1();
+    tester.assertStarted("leaf2", "leaf3").only();
+    tester.assertNotCancelled("leaf2", "leaf3");
+
+    // Nothing's requested dependencyFuture yet.
+    tester.assertNotStarted("dependencyFuture");
+
+    // entryPoint3 injects Producer of dependency future, then cancels that future. Then also
+    // returns that future as the entry point.
+    ListenableFuture<String> entryPoint = component.entryPoint3();
+
+    tester.assertStarted("dependencyFuture");
+    tester.assertCancelled("dependencyFuture");
+
+    // Even though the entry point future returned from the component is not the dependency future
+    // itself, the cancellation should have propagated out to it and cancelled it.
+    assertThat(entryPoint.isCancelled()).isTrue();
+
+    // And that cancellation should have cancelled the other tasks running in the component.
+    tester.assertCancelled("leaf2", "leaf3");
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/ProducerSubcomponentCancellationTest.java b/javatests/dagger/functional/producers/cancellation/ProducerSubcomponentCancellationTest.java
new file mode 100644
index 000000000..246bf9ffd
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/ProducerSubcomponentCancellationTest.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.truth.Truth.assertThat;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.functional.producers.cancellation.CancellationComponent.Dependency;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests cancellation of tasks in production subcomponents. */
+@RunWith(JUnit4.class)
+public class ProducerSubcomponentCancellationTest {
+
+  private final ProducerTester tester = new ProducerTester();
+  private final CancellationComponent component =
+      DaggerCancellationComponent.builder()
+          .module(new CancellationModule(tester))
+          .dependency(new Dependency(tester))
+          .executor(MoreExecutors.directExecutor())
+          .build();
+  private final CancellationSubcomponent subcomponent =
+      component.subcomponentBuilder().module(new CancellationSubcomponentModule(tester)).build();
+
+  @Test
+  public void initialState() {
+    tester.assertNoStartedNodes();
+  }
+
+  @Test
+  public void cancellingSubcomponent_doesNotCancelParent() throws Exception {
+    ListenableFuture<String> subcomponentEntryPoint = subcomponent.subcomponentEntryPoint();
+
+    // Subcomponent entry point depends on all leaves from the parent component and on the single
+    // leaf in the subcomponent itself, so they should all have started.
+    tester.assertStarted("leaf1", "leaf2", "leaf3", "subLeaf").only();
+
+    assertThat(subcomponentEntryPoint.cancel(true)).isTrue();
+    assertThat(subcomponentEntryPoint.isCancelled()).isTrue();
+
+    // None of the tasks running in the parent were cancelled.
+    tester.assertNotCancelled("leaf1", "leaf2", "leaf3");
+    tester.assertCancelled("subLeaf").only();
+
+    // Finish all the parent tasks to ensure that it can still complete normally.
+    tester.complete(
+        "dependencyFuture",
+        "leaf1",
+        "leaf2",
+        "leaf3",
+        "foo",
+        "bar",
+        "baz",
+        "qux",
+        "entryPoint1",
+        "entryPoint2");
+
+    assertThat(component.entryPoint1().get(1, MILLISECONDS)).isEqualTo("completed");
+    assertThat(component.entryPoint2().get().get(1, MILLISECONDS)).isEqualTo("completed");
+  }
+
+  @Test
+  public void cancellingSubcomponent_preventsUnstartedNodesFromStarting() {
+    ListenableFuture<String> subcomponentEntryPoint = subcomponent.subcomponentEntryPoint();
+
+    tester.complete("subLeaf");
+    tester.assertNotStarted("subTask1", "subTask2");
+
+    subcomponentEntryPoint.cancel(true);
+
+    // Complete the remaining dependencies of subTask1 and subTask2.
+    tester.complete("leaf1", "leaf2", "leaf3", "foo", "bar", "baz", "qux");
+
+    // Since the subcomponent was cancelled, they are not started.
+    tester.assertNotStarted("subTask1", "subTask2");
+  }
+
+  @Test
+  public void cancellingProducerFromComponentDependency_inSubcomponent_cancelsUnderlyingTask()
+      throws Exception {
+    // Request subcomponent's entry point.
+    ListenableFuture<String> subcomponentEntryPoint = subcomponent.subcomponentEntryPoint();
+
+    // Finish all parent tasks so that the subcomponent's tasks can start.
+    tester.complete("leaf1", "leaf2", "leaf3", "foo", "bar", "baz", "qux", "subLeaf");
+
+    tester.assertStarted("subTask1", "subTask2");
+    tester.assertNotCancelled("subTask1", "subTask2");
+
+    // When subTask2 runs, it cancels the dependency future.
+    // TODO(cgdecker): Is this what we want to happen?
+    // On the one hand, there's a policy of "futures from component dependencies come from outside
+    // our control and should be cancelled unconditionally". On the other hand, the dependency is
+    // coming from the parent component, and the policy is also not to cancel things belonging to
+    // the parent unless it allows that.
+    tester.assertCancelled("dependencyFuture");
+
+    // The future it returns didn't depend directly on that future, though, so the subcomponent
+    // should be able to complete normally.
+    tester.complete("subTask1", "subTask2", "subEntryPoint");
+
+    assertThat(subcomponentEntryPoint.get(1, MILLISECONDS)).isEqualTo("completed");
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/ProducerTester.java b/javatests/dagger/functional/producers/cancellation/ProducerTester.java
new file mode 100644
index 000000000..61ddaef35
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/ProducerTester.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.AbstractFuture;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Predicate;
+
+/**
+ * Helper for testing producers.
+ *
+ * <p>Maintains a set of nodes (futures mapped to names) representing the results of different
+ * producer nodes and allows those nodes to be "started" (when returned from a producer method),
+ * completed, and cancelled, as well as to be queried for their state. Additionally, provides
+ * assertions about the state of nodes.
+ */
+final class ProducerTester {
+
+  private final Map<String, TestFuture> futures = new HashMap<>();
+
+  /** Starts the given node. */
+  ListenableFuture<String> start(String node) {
+    return getOrCreate(node).start();
+  }
+
+  private TestFuture getOrCreate(String node) {
+    TestFuture result = futures.get(node);
+    if (result == null) {
+      result = new TestFuture(node);
+      futures.put(node, result);
+    }
+    return result;
+  }
+
+  /** Returns whether or not the given node has been started. */
+  boolean isStarted(String node) {
+    return futures.containsKey(node) && futures.get(node).isStarted();
+  }
+
+  /** Completes of the given nodes. */
+  void complete(String... nodes) {
+    for (String node : nodes) {
+      getOrCreate(node).complete();
+    }
+  }
+
+  /** Returns whether or not the given node has been cancelled. */
+  boolean isCancelled(String node) {
+    TestFuture future = futures.get(node);
+    return future != null && future.isCancelled();
+  }
+
+  /** Asserts that the given nodes have been started. */
+  Only assertStarted(String... nodes) {
+    return assertAboutNodes(STARTED, nodes);
+  }
+
+  /** Asserts that the given nodes have been cancelled. */
+  Only assertCancelled(String... nodes) {
+    return assertAboutNodes(CANCELLED, nodes);
+  }
+
+  /** Asserts that the given nodes have not been started. */
+  Only assertNotStarted(String... nodes) {
+    return assertAboutNodes(not(STARTED), nodes);
+  }
+
+  /** Asserts that the given nodes have not been cancelled. */
+  Only assertNotCancelled(String... nodes) {
+    return assertAboutNodes(not(CANCELLED), nodes);
+  }
+
+  /** Asserts that no nodes in this tester have been started. */
+  void assertNoStartedNodes() {
+    for (TestFuture future : futures.values()) {
+      assertThat(future.isStarted()).named("%s is started", future).isFalse();
+    }
+  }
+
+  private Only assertAboutNodes(Predicate<? super TestFuture> assertion, String... nodes) {
+    ImmutableSet.Builder<TestFuture> builder = ImmutableSet.builder();
+    for (String node : nodes) {
+      TestFuture future = getOrCreate(node);
+      assertThat(assertion.test(future)).named("%s is %s", future, assertion).isTrue();
+      builder.add(future);
+    }
+    return new Only(builder.build(), assertion);
+  }
+
+  /**
+   * Fluent class for making a previous assertion more strict by specifying that whatever was
+   * asserted should be true only for the specified nodes and not for any others.
+   */
+  final class Only {
+
+    private final ImmutableSet<TestFuture> expected;
+    private final Predicate<? super TestFuture> assertion;
+
+    Only(ImmutableSet<TestFuture> expected, Predicate<? super TestFuture> assertion) {
+      this.expected = checkNotNull(expected);
+      this.assertion = checkNotNull(assertion);
+    }
+
+    /**
+     * Asserts that the previous assertion was not true for any node other than those that were
+     * specified.
+     */
+    void only() {
+      for (TestFuture future : futures.values()) {
+        if (!expected.contains(future)) {
+          assertThat(assertion.test(future)).named("%s is %s", future, assertion).isFalse();
+        }
+      }
+    }
+  }
+
+  /**
+   * A simple future for testing that can be marked as having been started and which can be
+   * completed with a result.
+   */
+  private static final class TestFuture extends AbstractFuture<String> {
+
+    private final String name;
+    private volatile boolean started;
+
+    private TestFuture(String name) {
+      this.name = checkNotNull(name);
+    }
+
+    /** Marks this future as having been started and returns it. */
+    TestFuture start() {
+      this.started = true;
+      return this;
+    }
+
+    /** Returns whether or not this future's task was started. */
+    boolean isStarted() {
+      return started;
+    }
+
+    /** Completes this future's task by setting a value for it. */
+    public void complete() {
+      super.set("completed");
+    }
+
+    @Override
+    public String toString() {
+      return name;
+    }
+  }
+
+  private static final Predicate<TestFuture> STARTED =
+      new Predicate<TestFuture>() {
+        @Override
+        public boolean test(TestFuture future) {
+          return future.isStarted();
+        }
+
+        @Override
+        public String toString() {
+          return "started";
+        }
+      };
+
+  private static final Predicate<TestFuture> CANCELLED =
+      new Predicate<TestFuture>() {
+        @Override
+        public boolean test(TestFuture future) {
+          return future.isCancelled();
+        }
+
+        @Override
+        public String toString() {
+          return "cancelled";
+        }
+      };
+
+  /** Version of Predicates.not with a toString() that's nicer for our assertion error messages. */
+  private static <T> Predicate<T> not(final Predicate<T> predicate) {
+    return new Predicate<T>() {
+      @Override
+      public boolean test(T input) {
+        return !predicate.test(input);
+      }
+
+      @Override
+      public String toString() {
+        return "not " + predicate;
+      }
+    };
+  }
+}
diff --git a/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java b/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
index 37af821d9..3e6e3ad69 100644
--- a/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
+++ b/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
@@ -39,10 +39,10 @@
 
   @Test public void forProducer() {
     FrameworkTypeMapper mapper = FrameworkTypeMapper.FOR_PRODUCER;
-    assertThat(mapper.getFrameworkType(INSTANCE)).isEqualTo(FrameworkType.PRODUCER);
+    assertThat(mapper.getFrameworkType(INSTANCE)).isEqualTo(FrameworkType.PRODUCER_NODE);
     assertThat(mapper.getFrameworkType(LAZY)).isEqualTo(FrameworkType.PROVIDER);
     assertThat(mapper.getFrameworkType(PROVIDER)).isEqualTo(FrameworkType.PROVIDER);
-    assertThat(mapper.getFrameworkType(PRODUCER)).isEqualTo(FrameworkType.PRODUCER);
-    assertThat(mapper.getFrameworkType(PRODUCED)).isEqualTo(FrameworkType.PRODUCER);
+    assertThat(mapper.getFrameworkType(PRODUCER)).isEqualTo(FrameworkType.PRODUCER_NODE);
+    assertThat(mapper.getFrameworkType(PRODUCED)).isEqualTo(FrameworkType.PRODUCER_NODE);
   }
 }
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
index 8d1b25dee..343f2613d 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
@@ -522,13 +522,19 @@ public void productionComponents() {
             "test.DaggerTestComponent",
             "package test;",
             "",
+            "import dagger.producers.internal.CancellationListener;",
+            "",
             GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
+            "public final class DaggerTestComponent implements TestComponent, "
+                + "CancellationListener {",
             "  @Override",
             "  public ListenableFuture<Map<String, String>> stringMap() {",
             "    return Futures.immediateFuture(",
             "        (Map<String, String>) ImmutableMap.<String, String>of());",
             "  }",
+            "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {}",
             "}");
     Compilation compilation =
         daggerCompiler()
diff --git a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
index 563a7c283..338b62eb1 100644
--- a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
@@ -246,9 +246,11 @@ public void requestForFuture() {
             "package test;",
             "",
             "import com.google.common.base.Optional;",
+            "import dagger.producers.internal.CancellationListener;",
             "",
             GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
+            "public final class DaggerTestComponent implements TestComponent, "
+                + "CancellationListener {",
             "  @Override",
             "  public ListenableFuture<Optional<Maybe>> maybe() {",
             "    return Futures.immediateFuture(",
@@ -260,6 +262,9 @@ public void requestForFuture() {
             "    return Futures.immediateFuture(Optional.<DefinitelyNot>absent());",
 
             "  }",
+            "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {}",
             "}");
 
     Compilation compilation =
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 4486dd733..13d821039 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -228,6 +228,7 @@ public void simpleComponent() {
                 "import dagger.internal.Preconditions;",
                 "import dagger.internal.SetFactory;",
                 "import dagger.producers.Producer;",
+                "import dagger.producers.internal.CancellationListener;",
                 "import dagger.producers.internal.Producers;",
                 "import dagger.producers.monitoring.ProductionComponentMonitor;",
                 "import java.util.concurrent.Executor;",
@@ -236,7 +237,7 @@ public void simpleComponent() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestClass_SimpleComponent",
-                "    implements TestClass.SimpleComponent {",
+                "    implements TestClass.SimpleComponent, CancellationListener {",
                 "  private volatile Provider<Executor> executorProvider;",
                 "  private volatile Object productionImplementationExecutor =",
                 "      new MemoizedSentinel();",
@@ -244,6 +245,7 @@ public void simpleComponent() {
                 "  private volatile Object productionComponentMonitor = new MemoizedSentinel();",
                 "  private volatile Provider<TestClass.B> bProvider;",
                 "  private TestClass.BModule bModule;",
+                "  private Producer<TestClass.A> aEntryPoint;",
                 "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
                 "  private Producer<TestClass.B> bProducer;",
                 "  private TestClass_AModule_AFactory aProducer;",
@@ -343,11 +345,18 @@ public void simpleComponent() {
                 "            getProductionImplementationExecutorProvider(),",
                 "            getProductionComponentMonitorProvider(),",
                 "            bProducer);",
+                "    this.aEntryPoint = Producers.entryPointViewOf(aProducer, this);",
                 "  }",
                 "",
                 "  @Override",
                 "  public ListenableFuture<TestClass.A> a() {",
-                "    return aProducer.get();",
+                "    return aEntryPoint.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+                "    Producers.cancel(aProducer, mayInterruptIfRunning);",
+                "    Producers.cancel(bProducer, mayInterruptIfRunning);",
                 "  }",
                 "",
                 "  public static final class Builder {",
@@ -417,6 +426,7 @@ public void simpleComponent() {
                 "import dagger.internal.Preconditions;",
                 "import dagger.internal.SetFactory;",
                 "import dagger.producers.Producer;",
+                "import dagger.producers.internal.CancellationListener;",
                 "import dagger.producers.internal.Producers;",
                 "import dagger.producers.monitoring.ProductionComponentMonitor;",
                 "import java.util.concurrent.Executor;",
@@ -425,7 +435,8 @@ public void simpleComponent() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestClass_SimpleComponent",
-                "    implements TestClass.SimpleComponent {",
+                "    implements TestClass.SimpleComponent, CancellationListener {",
+                "  private Producer<TestClass.A> aEntryPoint;",
                 "  private TestClass_BModule_ExecutorFactory executorProvider;",
                 "  private Provider<Executor> executorProvider2;",
                 "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
@@ -470,11 +481,18 @@ public void simpleComponent() {
                 "        executorProvider2,",
                 "        monitorProvider,",
                 "        bProducer);",
+                "    this.aEntryPoint = Producers.entryPointViewOf(aProducer, this);",
                 "  }",
                 "",
                 "  @Override",
                 "  public ListenableFuture<TestClass.A> a() {",
-                "    return aProducer.get();",
+                "    return aEntryPoint.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+                "    Producers.cancel(aProducer, mayInterruptIfRunning);",
+                "    Producers.cancel(bProducer, mayInterruptIfRunning);",
                 "  }",
                 "",
                 "  public static final class Builder {",
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index 0274d96d2..8caae3e2a 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -330,11 +330,13 @@ public void productionComponents() {
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.internal.Preconditions;",
+            "import dagger.producers.internal.CancellationListener;",
             "import java.util.Set;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
+            "public final class DaggerTestComponent implements TestComponent, "
+                + "CancellationListener {",
             "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
@@ -355,6 +357,9 @@ public void productionComponents() {
             "    return Futures.immediateFuture(getSetOfString());",
             "  }",
             "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {}",
+            "",
             "  public static final class Builder {",
             "    private Builder() {}",
             "",
