diff --git a/java/dagger/internal/AbstractMapFactory.java b/java/dagger/internal/AbstractMapFactory.java
index d252bf3ce..1cf83fa1d 100644
--- a/java/dagger/internal/AbstractMapFactory.java
+++ b/java/dagger/internal/AbstractMapFactory.java
@@ -66,6 +66,11 @@
     }
 
     Builder<K, V, V2> putAll(Provider<Map<K, V2>> mapOfProviders) {
+      if (mapOfProviders instanceof DelegateFactory) {
+        @SuppressWarnings("unchecked")
+        DelegateFactory<Map<K, V2>> asDelegateFactory = (DelegateFactory) mapOfProviders;
+        return putAll(asDelegateFactory.getDelegate());
+      }
       @SuppressWarnings("unchecked")
       AbstractMapFactory<K, V, ?> asAbstractMapFactory =
           ((AbstractMapFactory<K, V, ?>) (Provider) mapOfProviders);
diff --git a/java/dagger/internal/DelegateFactory.java b/java/dagger/internal/DelegateFactory.java
index 416c2a172..3b4a30f23 100644
--- a/java/dagger/internal/DelegateFactory.java
+++ b/java/dagger/internal/DelegateFactory.java
@@ -57,5 +57,14 @@ public void setDelegatedProvider(Provider<T> delegate) {
     }
     asDelegateFactory.delegate = delegate;
   }
+
+  /**
+   * Returns the factory's delegate.
+   *
+   * @throws NullPointerException if the delegate has not been set
+   */
+  Provider<T> getDelegate() {
+    return checkNotNull(delegate);
+  }
 }
 
diff --git a/java/dagger/producers/internal/AbstractMapProducer.java b/java/dagger/producers/internal/AbstractMapProducer.java
index f689d9b91..c60f0cb07 100644
--- a/java/dagger/producers/internal/AbstractMapProducer.java
+++ b/java/dagger/producers/internal/AbstractMapProducer.java
@@ -78,6 +78,11 @@
 
     /** Adds contributions from a super-implementation of a component into this builder. */
     Builder<K, V, V2> putAll(Producer<Map<K, V2>> mapOfProducers) {
+      if (mapOfProducers instanceof DelegateProducer) {
+        @SuppressWarnings("unchecked")
+        DelegateProducer<Map<K, V2>> asDelegateProducer = (DelegateProducer) mapOfProducers;
+        return putAll(asDelegateProducer.getDelegate());
+      }
       @SuppressWarnings("unchecked")
       AbstractMapProducer<K, V, ?> asAbstractMapProducer =
           ((AbstractMapProducer<K, V, ?>) (Producer) mapOfProducers);
diff --git a/java/dagger/producers/internal/DelegateProducer.java b/java/dagger/producers/internal/DelegateProducer.java
index 55ab3a705..6cc7547c3 100644
--- a/java/dagger/producers/internal/DelegateProducer.java
+++ b/java/dagger/producers/internal/DelegateProducer.java
@@ -57,6 +57,15 @@ public void setDelegatedProducer(Producer<T> delegate) {
     asDelegateProducer.delegate = (CancellableProducer<T>) delegate;
   }
 
+  /**
+   * Returns the factory's delegate.
+   *
+   * @throws NullPointerException if the delegate has not been set
+   */
+  CancellableProducer<T> getDelegate() {
+    return checkNotNull(delegate);
+  }
+
   @Override
   public void cancel(boolean mayInterruptIfRunning) {
     delegate.cancel(mayInterruptIfRunning);
diff --git a/javatests/dagger/functional/aot/MapFrameworkInstanceWithContributionsInMultipleImplementationsTest.java b/javatests/dagger/functional/aot/MapFrameworkInstanceWithContributionsInMultipleImplementationsTest.java
new file mode 100644
index 000000000..ae6b3a4d2
--- /dev/null
+++ b/javatests/dagger/functional/aot/MapFrameworkInstanceWithContributionsInMultipleImplementationsTest.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.aot;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.StringKey;
+import java.util.Map;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests that framework instances of map bindings are properly instantiated in ahead-of-time mode
+ * when contributions are made in 3 or more implementations.
+ */
+@RunWith(JUnit4.class)
+public final class MapFrameworkInstanceWithContributionsInMultipleImplementationsTest {
+  @Subcomponent(modules = LeafModule.class)
+  interface Leaf {
+    Provider<Map<String, String>> providerOfMapOfValues();
+    Provider<Map<String, Provider<String>>> providerOfMapOfProviders();
+  }
+
+  @Module
+  interface LeafModule {
+    @Provides
+    @IntoMap
+    @StringKey("a")
+    static String fromLeaf() {
+      return "a";
+    }
+  }
+
+  @Subcomponent(modules = AncestorModule.class)
+  interface Ancestor {
+    Leaf leaf();
+  }
+
+  @Module
+  interface AncestorModule {
+    @Provides
+    @IntoMap
+    @StringKey("b")
+    static String fromAncestor() {
+      return "b";
+    }
+  }
+
+  @Component(modules = RootModule.class)
+  interface Root {
+    Ancestor ancestor();
+  }
+
+  @Module
+  interface RootModule {
+    @Provides
+    @IntoMap
+    @StringKey("c")
+    static String fromRoot() {
+      return "c";
+    }
+  }
+
+  @Test
+  public void mapFactoryCanBeInstantiatedAcrossComponentImplementations() {
+    Leaf leaf =
+        DaggerMapFrameworkInstanceWithContributionsInMultipleImplementationsTest_Root.create()
+            .ancestor()
+            .leaf();
+    assertThat(leaf.providerOfMapOfValues().get()).hasSize(3);
+    assertThat(leaf.providerOfMapOfProviders().get()).hasSize(3);
+  }
+}
