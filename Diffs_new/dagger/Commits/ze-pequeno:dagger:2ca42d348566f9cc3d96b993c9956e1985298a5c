diff --git a/java/dagger/android/processor/AndroidInjectorDescriptor.java b/java/dagger/android/processor/AndroidInjectorDescriptor.java
index 7c5ae073f..3ec66139e 100644
--- a/java/dagger/android/processor/AndroidInjectorDescriptor.java
+++ b/java/dagger/android/processor/AndroidInjectorDescriptor.java
@@ -43,9 +43,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleAnnotationValueVisitor8;
-import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
 /**
@@ -85,13 +83,9 @@
   }
 
   static final class Validator {
-    private final Types types;
-    private final Elements elements;
     private final Messager messager;
 
-    Validator(Types types, Elements elements, Messager messager) {
-      this.types = types;
-      this.elements = elements;
+    Validator(Messager messager) {
       this.messager = messager;
     }
 
diff --git a/java/dagger/android/processor/AndroidProcessor.java b/java/dagger/android/processor/AndroidProcessor.java
index c46817018..0cd7e6cae 100644
--- a/java/dagger/android/processor/AndroidProcessor.java
+++ b/java/dagger/android/processor/AndroidProcessor.java
@@ -66,7 +66,7 @@
     return ImmutableList.of(
         new AndroidMapKeyValidator(elements, types, messager),
         new ContributesAndroidInjectorGenerator(
-            new AndroidInjectorDescriptor.Validator(types, elements, messager),
+            new AndroidInjectorDescriptor.Validator(messager),
             useStringKeys(),
             filer,
             elements,
diff --git a/java/dagger/errorprone/AndroidSupportInjectionModuleMigrator.java b/java/dagger/errorprone/AndroidSupportInjectionModuleMigrator.java
index c2d90249e..e98fe9b11 100644
--- a/java/dagger/errorprone/AndroidSupportInjectionModuleMigrator.java
+++ b/java/dagger/errorprone/AndroidSupportInjectionModuleMigrator.java
@@ -58,13 +58,12 @@
   @Override
   public Description matchMemberSelect(MemberSelectTree tree, VisitorState state) {
     if (MODULE_CLASS_LITERAL.matches(tree, state)) {
-      return buildDescription(tree)
-          .addFix(
-              SuggestedFix.builder()
-                  .replace(tree, "AndroidInjectionModule.class")
-                  .addImport("dagger.android.AndroidInjectionModule")
-                  .build())
-          .build();
+      return describeMatch(
+          tree,
+          SuggestedFix.builder()
+              .replace(tree, "AndroidInjectionModule.class")
+              .addImport("dagger.android.AndroidInjectionModule")
+              .build());
     }
     return Description.NO_MATCH;
   }
diff --git a/java/dagger/grpc/server/CallScoped.java b/java/dagger/grpc/server/CallScoped.java
index a477f9d29..4b9d14f7b 100644
--- a/java/dagger/grpc/server/CallScoped.java
+++ b/java/dagger/grpc/server/CallScoped.java
@@ -16,12 +16,14 @@
 
 package dagger.grpc.server;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import javax.inject.Scope;
 
-/**
- * A scope that lasts as long as a single gRPC {@link io.grpc.ServerCall}.
- */
+/** A scope that lasts as long as a single gRPC {@link io.grpc.ServerCall}. */
+@Retention(RUNTIME)
 @Scope
 @Documented
 public @interface CallScoped {}
diff --git a/java/dagger/internal/codegen/Accessibility.java b/java/dagger/internal/codegen/Accessibility.java
index 558b58f12..bf7bc8896 100644
--- a/java/dagger/internal/codegen/Accessibility.java
+++ b/java/dagger/internal/codegen/Accessibility.java
@@ -208,9 +208,8 @@ public Boolean visitType(TypeElement element, Void p) {
         case ANONYMOUS:
         case LOCAL:
           return false;
-        default:
-          throw new AssertionError();
       }
+      throw new AssertionError();
     }
 
     boolean accessibleMember(Element element) {
diff --git a/java/dagger/internal/codegen/BindingElementValidator.java b/java/dagger/internal/codegen/BindingElementValidator.java
index 198fbf200..aa02f42aa 100644
--- a/java/dagger/internal/codegen/BindingElementValidator.java
+++ b/java/dagger/internal/codegen/BindingElementValidator.java
@@ -148,10 +148,6 @@ protected void checkType(ValidationReport.Builder<E> builder) {
 
       case SET_VALUES:
         checkSetValuesType(builder);
-        break;
-
-      default:
-        throw new AssertionError();
     }
   }
 
diff --git a/java/dagger/internal/codegen/BindingMethodValidator.java b/java/dagger/internal/codegen/BindingMethodValidator.java
index 8d042429d..6a16c72b9 100644
--- a/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -182,10 +182,6 @@ private void checkAbstractness(ValidationReport.Builder<ExecutableElement> build
         if (isAbstract) {
           builder.addError(bindingMethods("cannot be abstract"));
         }
-        break;
-
-      default:
-        throw new AssertionError();
     }
   }
 
diff --git a/java/dagger/internal/codegen/BindsTypeChecker.java b/java/dagger/internal/codegen/BindsTypeChecker.java
index c00aa1bab..38d3a5b5e 100644
--- a/java/dagger/internal/codegen/BindsTypeChecker.java
+++ b/java/dagger/internal/codegen/BindsTypeChecker.java
@@ -68,9 +68,8 @@ private TypeMirror desiredAssignableType(
         DeclaredType parameterizedMapType =
             types.getDeclaredType(mapElement(), unboundedWildcard(), leftHandSide);
         return methodParameterTypes(parameterizedMapType, "put").get(1);
-      default:
-        throw new AssertionError("Unknown contribution type: " + contributionType);
     }
+    throw new AssertionError("Unknown contribution type: " + contributionType);
   }
 
   private ImmutableList<TypeMirror> methodParameterTypes(DeclaredType type, String methodName) {
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 1e3a11dfb..21034f06b 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -277,10 +277,8 @@ BindingExpression createBindingExpression(
 
       case PRODUCTION:
         return productionBindingExpression(resolvedBindings, request);
-
-      default:
-        throw new AssertionError(resolvedBindings);
     }
+    throw new AssertionError(resolvedBindings);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentDescriptorFactory.java b/java/dagger/internal/codegen/ComponentDescriptorFactory.java
index e120ade8e..17b8da2f3 100644
--- a/java/dagger/internal/codegen/ComponentDescriptorFactory.java
+++ b/java/dagger/internal/codegen/ComponentDescriptorFactory.java
@@ -110,7 +110,6 @@ ComponentDescriptor moduleComponentDescriptor(TypeElement typeElement) {
 
   private ComponentDescriptor create(
       TypeElement typeElement, ComponentAnnotation componentAnnotation) {
-    DeclaredType declaredComponentType = MoreTypes.asDeclared(typeElement.asType());
     ImmutableSet<ComponentRequirement> componentDependencies =
         componentAnnotation.dependencyTypes().stream()
             .map(ComponentRequirement::forDependency)
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index 4da1e4482..c4119860a 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -133,9 +133,8 @@ final TypeMirror contributedType() {
       case SET_VALUES:
       case UNIQUE:
         return key().type();
-      default:
-        throw new AssertionError();
     }
+    throw new AssertionError();
   }
 
   final boolean isSyntheticMultibinding() {
diff --git a/java/dagger/internal/codegen/DependencyRequestFactory.java b/java/dagger/internal/codegen/DependencyRequestFactory.java
index a66edd073..f6644d758 100644
--- a/java/dagger/internal/codegen/DependencyRequestFactory.java
+++ b/java/dagger/internal/codegen/DependencyRequestFactory.java
@@ -122,9 +122,8 @@ private RequestKind multibindingContributionRequestKind(
       case UNIQUE:
         throw new IllegalArgumentException(
             "multibindingContribution must be a multibinding: " + multibindingContribution);
-      default:
-        throw new AssertionError(multibindingContribution.toString());
     }
+    throw new AssertionError(multibindingContribution.toString());
   }
 
   DependencyRequest forRequiredResolvedVariable(
diff --git a/java/dagger/internal/codegen/DependencyRequestFormatter.java b/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 357cca1d7..0f94d163e 100644
--- a/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -143,8 +143,8 @@ private String componentMethodRequestVerb(DependencyRequest request) {
         return "injected";
 
       case PRODUCED:
-      default:
-        throw new AssertionError("illegal request kind for method: " + request);
+        break;
     }
+    throw new AssertionError("illegal request kind for method: " + request);
   }
 }
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index b69e3b2f2..094846b14 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -121,9 +121,6 @@ private void initializeField() {
       case DELEGATED:
       case INITIALIZED:
         break;
-
-      default:
-        throw new AssertionError("Unhandled initialization state: " + fieldInitializationState);
     }
   }
 
diff --git a/java/dagger/internal/codegen/InjectValidator.java b/java/dagger/internal/codegen/InjectValidator.java
index 949d0c570..c4f875f85 100644
--- a/java/dagger/internal/codegen/InjectValidator.java
+++ b/java/dagger/internal/codegen/InjectValidator.java
@@ -29,7 +29,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.ValidationReport.Builder;
 import dagger.model.Scope;
 import java.util.Optional;
 import java.util.Set;
@@ -307,7 +306,8 @@ private boolean throwsCheckedExceptions(ExecutableElement methodElement) {
     return false;
   }
 
-  private void checkInjectIntoPrivateClass(Element element, Builder<TypeElement> builder) {
+  private void checkInjectIntoPrivateClass(
+      Element element, ValidationReport.Builder<TypeElement> builder) {
     if (!Accessibility.isElementAccessibleFromOwnPackage(
         DaggerElements.closestEnclosingTypeElement(element))) {
       builder.addItem(
diff --git a/java/dagger/internal/codegen/InjectionMethods.java b/java/dagger/internal/codegen/InjectionMethods.java
index 828df634d..0055448a5 100644
--- a/java/dagger/internal/codegen/InjectionMethods.java
+++ b/java/dagger/internal/codegen/InjectionMethods.java
@@ -261,9 +261,8 @@ static InjectionMethod create(InjectionSite injectionSite, DaggerElements elemen
               MoreElements.asVariable(injectionSite.element()),
               methodName,
               elements);
-        default:
-          throw new AssertionError(injectionSite);
       }
+      throw new AssertionError(injectionSite);
     }
 
     /**
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
index 59d400356..3570ca5bd 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -222,15 +222,14 @@ private TypeMirror bindingMethodKeyType(
         // TODO(gak): do we want to allow people to use "covariant return" here?
         checkArgument(SetType.isSet(returnType));
         return returnType;
-      default:
-        throw new AssertionError();
     }
+    throw new AssertionError();
   }
 
   /**
    * Returns the key for a binding associated with a {@link DelegateDeclaration}.
    *
-   * If {@code delegateDeclaration} is {@code @IntoMap}, transforms the {@code Map<K, V>} key
+   * <p>If {@code delegateDeclaration} is {@code @IntoMap}, transforms the {@code Map<K, V>} key
    * from {@link DelegateDeclaration#key()} to {@code Map<K, FrameworkType<V>>}. If {@code
    * delegateDeclaration} is not a map contribution, its key is returned.
    */
diff --git a/java/dagger/internal/codegen/ModuleKind.java b/java/dagger/internal/codegen/ModuleKind.java
index ae169e3a1..1dc25106a 100644
--- a/java/dagger/internal/codegen/ModuleKind.java
+++ b/java/dagger/internal/codegen/ModuleKind.java
@@ -24,9 +24,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import dagger.Module;
-import dagger.Provides;
 import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.Optional;
@@ -37,10 +35,10 @@
 /** Enumeration of the kinds of modules. */
 enum ModuleKind {
   /** {@code @Module} */
-  MODULE(Module.class, Provides.class),
+  MODULE(Module.class),
 
   /** {@code @ProducerModule} */
-  PRODUCER_MODULE(ProducerModule.class, Produces.class);
+  PRODUCER_MODULE(ProducerModule.class);
 
   /** Returns the annotations for modules of the given kinds. */
   static ImmutableSet<Class<? extends Annotation>> annotationsFor(Set<ModuleKind> kinds) {
@@ -74,12 +72,9 @@ static void checkIsModule(TypeElement moduleElement) {
   }
 
   private final Class<? extends Annotation> moduleAnnotation;
-  private final Class<? extends Annotation> methodAnnotation;
 
-  ModuleKind(
-      Class<? extends Annotation> moduleAnnotation, Class<? extends Annotation> methodAnnotation) {
+  ModuleKind(Class<? extends Annotation> moduleAnnotation) {
     this.moduleAnnotation = moduleAnnotation;
-    this.methodAnnotation = methodAnnotation;
   }
 
   /**
diff --git a/java/dagger/internal/codegen/OptionalFactories.java b/java/dagger/internal/codegen/OptionalFactories.java
index f4c146001..5e58c8b71 100644
--- a/java/dagger/internal/codegen/OptionalFactories.java
+++ b/java/dagger/internal/codegen/OptionalFactories.java
@@ -403,10 +403,8 @@ private MethodSpec presentOptionalFactoryGetMethod(
             throw new UnsupportedOperationException(
                 spec.factoryType() + " objects are not supported");
         }
-
-      default:
-        throw new AssertionError(spec.frameworkType());
     }
+    throw new AssertionError(spec.frameworkType());
   }
 
   /**
diff --git a/java/dagger/internal/codegen/SourceFiles.java b/java/dagger/internal/codegen/SourceFiles.java
index 54e1c25e4..7baa5d30c 100644
--- a/java/dagger/internal/codegen/SourceFiles.java
+++ b/java/dagger/internal/codegen/SourceFiles.java
@@ -201,10 +201,8 @@ static ClassName generatedClassNameForBinding(Binding binding) {
       case MEMBERS_INJECTION:
         return membersInjectorNameForType(
             ((MembersInjectionBinding) binding).membersInjectedType());
-
-      default:
-        throw new AssertionError();
     }
+    throw new AssertionError();
   }
 
   /**
diff --git a/java/dagger/internal/codegen/Util.java b/java/dagger/internal/codegen/Util.java
index 7a5694445..1869b7ced 100644
--- a/java/dagger/internal/codegen/Util.java
+++ b/java/dagger/internal/codegen/Util.java
@@ -77,10 +77,9 @@ private static boolean requiresEnclosingInstance(TypeElement typeElement) {
       case ANONYMOUS:
       case LOCAL:
         return true;
-      default:
-        throw new AssertionError(
-            "TypeElement cannot have nesting kind: " + typeElement.getNestingKind());
     }
+    throw new AssertionError(
+        "TypeElement cannot have nesting kind: " + typeElement.getNestingKind());
   }
 
   /**
diff --git a/java/dagger/model/Scope.java b/java/dagger/model/Scope.java
index 7d255e1ca..f48fa16df 100644
--- a/java/dagger/model/Scope.java
+++ b/java/dagger/model/Scope.java
@@ -90,7 +90,7 @@ private boolean isScope(Class<? extends Annotation> annotation) {
 
   /** Returns a debug representation of the scope. */
   @Override
-  public String toString() {
+  public final String toString() {
     return scopeAnnotation().toString();
   }
 }
