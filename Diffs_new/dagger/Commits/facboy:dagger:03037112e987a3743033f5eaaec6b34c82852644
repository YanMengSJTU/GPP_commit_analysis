diff --git a/java/dagger/android/ActivityKey.java b/java/dagger/android/ActivityKey.java
index 2fe7aeeee..22b94171d 100644
--- a/java/dagger/android/ActivityKey.java
+++ b/java/dagger/android/ActivityKey.java
@@ -21,11 +21,13 @@
 import android.app.Activity;
 import dagger.MapKey;
 import dagger.internal.Beta;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 
 /** {@link MapKey} annotation to key bindings by a type of an {@link Activity}. */
 @Beta
 @MapKey
+@Documented
 @Target(METHOD)
 public @interface ActivityKey {
   Class<? extends Activity> value();
diff --git a/java/dagger/android/BroadcastReceiverKey.java b/java/dagger/android/BroadcastReceiverKey.java
index 942577ac1..653de8f35 100644
--- a/java/dagger/android/BroadcastReceiverKey.java
+++ b/java/dagger/android/BroadcastReceiverKey.java
@@ -21,11 +21,13 @@
 import android.content.BroadcastReceiver;
 import dagger.MapKey;
 import dagger.internal.Beta;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 
 /** {@link MapKey} annotation to key bindings by a type of a {@link BroadcastReceiver}. */
 @Beta
 @MapKey
+@Documented
 @Target(METHOD)
 public @interface BroadcastReceiverKey {
   Class<? extends BroadcastReceiver> value();
diff --git a/java/dagger/android/ContentProviderKey.java b/java/dagger/android/ContentProviderKey.java
index 891821c89..9f12e44d8 100644
--- a/java/dagger/android/ContentProviderKey.java
+++ b/java/dagger/android/ContentProviderKey.java
@@ -21,11 +21,13 @@
 import android.content.ContentProvider;
 import dagger.MapKey;
 import dagger.internal.Beta;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 
 /** {@link MapKey} annotation to key bindings by a type of a {@link ContentProvider}. */
 @Beta
 @MapKey
+@Documented
 @Target(METHOD)
 public @interface ContentProviderKey {
   Class<? extends ContentProvider> value();
diff --git a/java/dagger/android/FragmentKey.java b/java/dagger/android/FragmentKey.java
index 5f27e3f01..3372a0645 100644
--- a/java/dagger/android/FragmentKey.java
+++ b/java/dagger/android/FragmentKey.java
@@ -21,11 +21,13 @@
 import android.app.Fragment;
 import dagger.MapKey;
 import dagger.internal.Beta;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 
 /** {@link MapKey} annotation to key bindings by a type of a {@link Fragment}. */
 @Beta
 @MapKey
+@Documented
 @Target(METHOD)
 public @interface FragmentKey {
   Class<? extends Fragment> value();
diff --git a/java/dagger/android/ServiceKey.java b/java/dagger/android/ServiceKey.java
index 1461a98e5..834868c53 100644
--- a/java/dagger/android/ServiceKey.java
+++ b/java/dagger/android/ServiceKey.java
@@ -21,11 +21,13 @@
 import android.app.Service;
 import dagger.MapKey;
 import dagger.internal.Beta;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 
 /** {@link MapKey} annotation to key bindings by a type of a {@link Service}. */
 @Beta
 @MapKey
+@Documented
 @Target(METHOD)
 public @interface ServiceKey {
   Class<? extends Service> value();
diff --git a/java/dagger/android/support/FragmentKey.java b/java/dagger/android/support/FragmentKey.java
index a5ecda4d7..902574be2 100644
--- a/java/dagger/android/support/FragmentKey.java
+++ b/java/dagger/android/support/FragmentKey.java
@@ -21,11 +21,13 @@
 import android.support.v4.app.Fragment;
 import dagger.MapKey;
 import dagger.internal.Beta;
+import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 
 /** {@link MapKey} annotation to key bindings by a type of a {@link Fragment}. */
 @Beta
 @MapKey
+@Documented
 @Target(METHOD)
 public @interface FragmentKey {
   Class<? extends Fragment> value();
diff --git a/java/dagger/internal/codegen/AnyBindingMethodValidator.java b/java/dagger/internal/codegen/AnyBindingMethodValidator.java
index 354a4f878..23393b628 100644
--- a/java/dagger/internal/codegen/AnyBindingMethodValidator.java
+++ b/java/dagger/internal/codegen/AnyBindingMethodValidator.java
@@ -20,8 +20,8 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.ErrorMessages.tooManyBindingMethodAnnotations;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
+import static java.util.stream.Collectors.joining;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -100,7 +100,12 @@ boolean wasAlreadyValidated(ExecutableElement method) {
         break;
 
       default:
-        report.addError(tooManyBindingMethodAnnotations(method, methodAnnotations()), method);
+        report.addError(
+            String.format(
+                "%s is annotated with more than one of (%s)",
+                method.getSimpleName(),
+                methodAnnotations().stream().map(Class::getCanonicalName).collect(joining(", "))),
+            method);
         break;
     }
     return report.build();
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 914fb2426..0354caf45 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -198,6 +198,7 @@ java_library(
     srcs = [
         "BindingGraphValidationModule.java",
         "DuplicateBindingsValidation.java",
+        "IncompatiblyScopedBindingsValidation.java",
         "InjectBindingValidation.java",
         "MapMultibindingValidation.java",
         "MembersInjectionBindingValidation.java",
diff --git a/java/dagger/internal/codegen/BindingGraphValidationModule.java b/java/dagger/internal/codegen/BindingGraphValidationModule.java
index fc231522b..54c245a1f 100644
--- a/java/dagger/internal/codegen/BindingGraphValidationModule.java
+++ b/java/dagger/internal/codegen/BindingGraphValidationModule.java
@@ -30,6 +30,11 @@
   @Validation
   BindingGraphPlugin duplicateBindings(DuplicateBindingsValidation validation);
 
+  @Binds
+  @IntoSet
+  @Validation
+  BindingGraphPlugin incompatiblyScopedBindings(IncompatiblyScopedBindingsValidation validation);
+
   @Binds
   @IntoSet
   @Validation
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index a9767df95..2727da473 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -27,9 +27,6 @@
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
-import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.abstractModuleHasInstanceBindingMethods;
 import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.internal.codegen.RequestKinds.extractKeyType;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
@@ -44,13 +41,10 @@
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toSet;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import dagger.BindsOptionalOf;
 import dagger.Component;
@@ -114,10 +108,6 @@
     final Map<ComponentDescriptor, ValidationReport.Builder<TypeElement>> reports =
         new LinkedHashMap<>();
 
-    /** Bindings whose scopes are not compatible with the component that owns them. */
-    private final SetMultimap<ComponentDescriptor, ContributionBinding> incompatiblyScopedBindings =
-        LinkedHashMultimap.create();
-
     ComponentValidation(BindingGraph rootGraph) {
       super(rootGraph);
       this.rootGraph = rootGraph;
@@ -152,7 +142,6 @@ protected void visitComponent(BindingGraph graph) {
       validateModules(graph);
       validateBuilders(graph);
       super.visitComponent(graph);
-      checkScopedBindings(graph);
     }
 
     @Override
@@ -305,7 +294,7 @@ private void validateModules(BindingGraph graph) {
         if (module.moduleElement().getModifiers().contains(Modifier.ABSTRACT)) {
           for (ContributionBinding binding : module.bindings()) {
             if (binding.requiresModuleInstance()) {
-              report(graph).addError(abstractModuleHasInstanceBindingMethods(module));
+              report(graph).addError(abstractModuleHasInstanceBindingMethodsError(module));
               break;
             }
           }
@@ -313,6 +302,24 @@ private void validateModules(BindingGraph graph) {
       }
     }
 
+    private String abstractModuleHasInstanceBindingMethodsError(ModuleDescriptor module) {
+      String methodAnnotations;
+      switch (module.kind()) {
+        case MODULE:
+          methodAnnotations = "@Provides";
+          break;
+        case PRODUCER_MODULE:
+          methodAnnotations = "@Provides or @Produces";
+          break;
+        default:
+          throw new AssertionError(module.kind());
+      }
+      return String.format(
+          "%s is abstract and has instance %s methods. Consider making the methods static or "
+              + "including a non-abstract subclass of the module instead.",
+          module.moduleElement(), methodAnnotations);
+    }
+
     private void validateBuilders(BindingGraph graph) {
       ComponentDescriptor componentDesc = graph.componentDescriptor();
       if (!componentDesc.builderSpec().isPresent()) {
@@ -455,71 +462,6 @@ private void validateDependencyScopeHierarchy(
       return false;
     }
 
-    /**
-     * Collects scoped bindings that are not compatible with their owning component for later
-     * reporting by {@link #checkScopedBindings(BindingGraph)}.
-     */
-    private void checkBindingScope(
-        ContributionBinding binding, ComponentDescriptor owningComponent) {
-      if (binding.scope().isPresent()
-          && !binding.scope().get().isReusable()
-          && !owningComponent.scopes().contains(binding.scope().get())) {
-        incompatiblyScopedBindings.put(owningComponent, binding);
-      }
-    }
-
-    /**
-     * Reports an error if any of the scoped bindings owned by a given component are incompatible
-     * with the component. Must be called after all bindings owned by the given component have been
-     * {@linkplain #checkBindingScope(ContributionBinding, ComponentDescriptor) visited}.
-     */
-    private void checkScopedBindings(BindingGraph graph) {
-      if (!incompatiblyScopedBindings.containsKey(graph.componentDescriptor())) {
-        return;
-      }
-
-      StringBuilder message = new StringBuilder(graph.componentType().getQualifiedName());
-      if (!graph.componentDescriptor().scopes().isEmpty()) {
-        message.append(" scoped with ");
-        for (Scope scope : graph.componentDescriptor().scopes()) {
-          message.append(getReadableSource(scope)).append(' ');
-        }
-        message.append("may not reference bindings with different scopes:\n");
-      } else {
-        message.append(" (unscoped) may not reference scoped bindings:\n");
-      }
-      for (ContributionBinding binding :
-          incompatiblyScopedBindings.get(graph.componentDescriptor())) {
-        message.append(INDENT);
-
-        switch (binding.kind()) {
-          case DELEGATE:
-          case PROVISION:
-            message.append(
-                methodSignatureFormatter.format(
-                    MoreElements.asExecutable(binding.bindingElement().get())));
-            break;
-
-          case INJECTION:
-            message
-                .append(getReadableSource(binding.scope().get()))
-                .append(" class ")
-                .append(binding.bindingTypeElement().get().getQualifiedName());
-            break;
-
-          default:
-            throw new AssertionError(binding);
-        }
-
-        message.append("\n");
-      }
-      report(graph)
-          .addError(
-              message.toString(),
-              graph.componentType(),
-              graph.componentDescriptor().componentAnnotation());
-    }
-
     final class BindingGraphValidation extends BindingGraphTraverser {
 
       BindingGraphValidation(
@@ -554,7 +496,6 @@ protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
       @Override
       protected void visitContributionBinding(
           ContributionBinding binding, ComponentDescriptor owningComponent) {
-        checkBindingScope(binding, owningComponent);
         if (compilerOptions.usesProducers()) {
           // TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
           // Only the Dagger-specific binding may depend on the production executor.
@@ -576,7 +517,7 @@ protected void visitContributionBinding(
       @SuppressWarnings("resource") // Appendable is a StringBuilder.
       private void reportDependsOnProductionExecutor() {
         reportErrorAtEntryPoint(
-            DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatCurrentDependencyRequestKey());
+            "%s may not depend on the production executor", formatCurrentDependencyRequestKey());
       }
 
       // TODO(cgruber): Provide a hint for the start and end of the cycle.
@@ -591,7 +532,7 @@ private void reportDependencyCycle() {
                     cycleBindings.addAll(resolvedBindings.contributionBindings()));
         reportErrorAtEntryPoint(
             owningGraph(cycleBindings.build()),
-            CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+            "Found a dependency cycle:\n%s",
             formatDependencyTrace());
       }
 
diff --git a/java/dagger/internal/codegen/BindingMethodValidator.java b/java/dagger/internal/codegen/BindingMethodValidator.java
index 7a764f082..3c18ebe73 100644
--- a/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -18,25 +18,6 @@
 
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_ANY;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEYS;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
@@ -49,7 +30,7 @@
 import static javax.lang.model.type.TypeKind.VOID;
 
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
+import com.google.errorprone.annotations.FormatMethod;
 import com.google.errorprone.annotations.OverridingMethodsMustInvokeSuper;
 import dagger.MapKey;
 import dagger.Provides;
@@ -57,6 +38,7 @@
 import dagger.multibindings.IntoMap;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
+import java.util.Formatter;
 import java.util.HashMap;
 import java.util.Map;
 import javax.inject.Qualifier;
@@ -126,12 +108,25 @@ protected BindingMethodValidator(
     this.exceptionSuperclass = exceptionSuperclass;
     this.allowsMultibindings = allowsMultibindings;
   }
-  
-  /** The annotation that identifies methods validated by this object. */
-  Class<? extends Annotation> methodAnnotation() {
+
+  /** The annotation that identifies binding methods validated by this object. */
+  final Class<? extends Annotation> methodAnnotation() {
     return methodAnnotation;
   }
 
+  /**
+   * Returns an error message of the form "@<i>annotation</i> methods <i>rule</i>", where
+   * <i>rule</i> comes from calling {@link String#format(String, Object...)} on {@code ruleFormat}
+   * and the other arguments.
+   */
+  @FormatMethod
+  protected final String bindingMethods(String ruleFormat, Object... args) {
+    return new Formatter()
+        .format("@%s methods ", methodAnnotation.getSimpleName())
+        .format(ruleFormat, args)
+        .toString();
+  }
+
   /** Returns a {@link ValidationReport} for {@code method}. */
   final ValidationReport<ExecutableElement> validate(ExecutableElement method) {
     return reentrantComputeIfAbsent(cache, method, this::validateUncached);
@@ -165,8 +160,8 @@ private void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> b
     if (!isAnyAnnotationPresent(
         builder.getSubject().getEnclosingElement(), enclosingElementAnnotations)) {
       builder.addError(
-          formatErrorMessage(
-              BINDING_METHOD_NOT_IN_MODULE,
+          bindingMethods(
+              "can only be present within a @%s",
               enclosingElementAnnotations
                   .stream()
                   .map(Class::getSimpleName)
@@ -177,14 +172,14 @@ private void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> b
   /** Adds an error if the method is generic. */
   private void checkTypeParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getTypeParameters().isEmpty()) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+      builder.addError(bindingMethods("may not have type parameters"));
     }
   }
 
   /** Adds an error if the method is private. */
   private void checkNotPrivate(ValidationReport.Builder<ExecutableElement> builder) {
     if (builder.getSubject().getModifiers().contains(PRIVATE)) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE));
+      builder.addError(bindingMethods("cannot be private"));
     }
   }
 
@@ -194,13 +189,13 @@ private void checkAbstractness(ValidationReport.Builder<ExecutableElement> build
     switch (abstractness) {
       case MUST_BE_ABSTRACT:
         if (!isAbstract) {
-          builder.addError(formatErrorMessage(BINDING_METHOD_NOT_ABSTRACT));
+          builder.addError(bindingMethods("must be abstract"));
         }
         break;
 
       case MUST_BE_CONCRETE:
         if (isAbstract) {
-          builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+          builder.addError(bindingMethods("cannot be abstract"));
         }
         break;
 
@@ -251,7 +246,7 @@ protected void checkKeyType(
       ValidationReport.Builder<ExecutableElement> builder, TypeMirror keyType) {
     TypeKind kind = keyType.getKind();
     if (kind.equals(VOID)) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+      builder.addError(bindingMethods("must return a value (not void)"));
     } else if (!(kind.isPrimitive()
         || kind.equals(DECLARED)
         || kind.equals(ARRAY)
@@ -262,7 +257,7 @@ protected void checkKeyType(
 
   /** The error message when a non-{@code void} binding method returns a bad type. */
   protected String badReturnTypeMessage() {
-    return formatErrorMessage(BINDING_METHOD_RETURN_TYPE);
+    return bindingMethods("must return a primitive, an array, a type variable, or a declared type");
   }
 
   /**
@@ -282,7 +277,7 @@ protected final void checkSetValuesType(
     } else {
       SetType setType = SetType.from(type);
       if (setType.isRawType()) {
-        builder.addError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+        builder.addError(bindingMethods("annotated with @ElementsIntoSet cannot return a raw Set"));
       } else {
         checkKeyType(builder, setType.elementType());
       }
@@ -302,7 +297,7 @@ protected void checkQualifiers(ValidationReport.Builder<ExecutableElement> build
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(builder.getSubject());
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(BINDING_METHOD_MULTIPLE_QUALIFIERS, builder.getSubject(), qualifier);
+        builder.addError("Cannot use more than one @Qualifier", builder.getSubject(), qualifier);
       }
     }
   }
@@ -320,16 +315,16 @@ protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder)
     if (ContributionType.fromBindingMethod(builder.getSubject()).equals(ContributionType.MAP)) {
       switch (mapKeys.size()) {
         case 0:
-          builder.addError(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY));
+          builder.addError(bindingMethods("of type map must declare a map key"));
           break;
         case 1:
           break;
         default:
-          builder.addError(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEYS));
+          builder.addError(bindingMethods("may not have more than one map key"));
           break;
       }
     } else if (!mapKeys.isEmpty()) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY));
+      builder.addError(bindingMethods("of non map type cannot declare a map key"));
     }
   }
 
@@ -347,7 +342,7 @@ protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> bu
     if (multibindingAnnotations.size() > 1) {
       for (AnnotationMirror annotation : multibindingAnnotations) {
         builder.addError(
-            formatErrorMessage(MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD),
+            bindingMethods("cannot have more than one multibinding annotation"),
             builder.getSubject(),
             annotation);
       }
@@ -361,35 +356,23 @@ protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> bu
     }
     if (usesProvidesType && !multibindingAnnotations.isEmpty()) {
       builder.addError(
-          formatErrorMessage(MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM),
-          builder.getSubject());
+          "@Provides.type cannot be used with multibinding annotations", builder.getSubject());
     }
   }
 
   /** Adds an error if the method returns a {@linkplain FrameworkTypes framework type}. */
   protected void checkFrameworkType(ValidationReport.Builder<ExecutableElement> builder) {
     if (FrameworkTypes.isFrameworkType(builder.getSubject().getReturnType())) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+      builder.addError(bindingMethods("must not return framework types"));
     }
   }
 
-  /**
-   * Formats an error message whose first {@code %s} parameter should be replaced with the simple
-   * name of the method annotation.
-   */
-  protected String formatErrorMessage(String format, Object... otherParameters) {
-    return otherParameters.length == 0
-        ? String.format(format, methodAnnotation.getSimpleName())
-        : String.format(
-            format, Lists.asList(methodAnnotation.getSimpleName(), otherParameters).toArray());
-  }
-
   /**
    * The error message when an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method
    * returns a bad type.
    */
   protected String badSetValuesTypeMessage() {
-    return formatErrorMessage(BINDING_METHOD_SET_VALUES_RETURN_SET);
+    return bindingMethods("annotated with @ElementsIntoSet must return a Set");
   }
 
   /** An abstract/concrete restriction on methods. */
@@ -399,39 +382,53 @@ protected String badSetValuesTypeMessage() {
   }
 
   /**
-   * The exception class that all {@code throws}-declared throwables must extend, other than
-   * {@link Error}.
+   * The exception class that all {@code throws}-declared throwables must extend, other than {@link
+   * Error}.
    */
   protected enum ExceptionSuperclass {
     /** Methods may not declare any throwable types. */
     NO_EXCEPTIONS {
+      @Override
+      protected String errorMessage(BindingMethodValidator validator) {
+        return validator.bindingMethods("may not throw");
+      }
+
       @Override
       protected void checkThrows(
           BindingMethodValidator validator, ValidationReport.Builder<ExecutableElement> builder) {
         if (!builder.getSubject().getThrownTypes().isEmpty()) {
-          builder.addError(validator.formatErrorMessage(BINDING_METHOD_THROWS_ANY));
+          builder.addError(validator.bindingMethods("may not throw"));
           return;
         }
       }
     },
 
     /** Methods may throw checked or unchecked exceptions or errors. */
-    EXCEPTION(Exception.class, BINDING_METHOD_THROWS),
+    EXCEPTION(Exception.class) {
+      @Override
+      protected String errorMessage(BindingMethodValidator validator) {
+        return validator.bindingMethods(
+            "may only throw unchecked exceptions or exceptions subclassing Exception");
+      }
+    },
 
     /** Methods may throw unchecked exceptions or errors. */
-    RUNTIME_EXCEPTION(RuntimeException.class, BINDING_METHOD_THROWS_CHECKED),
+    RUNTIME_EXCEPTION(RuntimeException.class) {
+      @Override
+      protected String errorMessage(BindingMethodValidator validator) {
+        return validator.bindingMethods("may only throw unchecked exceptions");
+      }
+    },
     ;
 
     private final Class<? extends Exception> superclass;
-    private final String errorMessage;
 
-    private ExceptionSuperclass() {
-      this(null, null);
+    ExceptionSuperclass() {
+      this(null);
     }
 
-    private ExceptionSuperclass(Class<? extends Exception> superclass, String errorMessage) {
+    ExceptionSuperclass(Class<? extends Exception> superclass) {
       this.superclass = superclass;
-      this.errorMessage = errorMessage;
     }
 
     /**
@@ -448,11 +445,13 @@ protected void checkThrows(
       for (TypeMirror thrownType : builder.getSubject().getThrownTypes()) {
         if (!validator.types.isSubtype(thrownType, exceptionSupertype)
             && !validator.types.isSubtype(thrownType, errorType)) {
-          builder.addError(validator.formatErrorMessage(errorMessage));
+          builder.addError(errorMessage(validator));
           break;
         }
       }
     }
+
+    protected abstract String errorMessage(BindingMethodValidator validator);
   }
 
   /** Whether to check multibinding annotations. */
diff --git a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index a500eb817..87ddbf772 100644
--- a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -21,9 +21,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_IN_INVALID_COMPONENT;
-import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_ONE_PARAMETER;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
@@ -80,7 +77,8 @@
         report.addError("@BindsInstance methods must be abstract");
       }
       if (method.getParameters().size() != 1) {
-        report.addError(BINDS_INSTANCE_ONE_PARAMETER);
+        report.addError(
+            "@BindsInstance methods should have exactly one parameter for the bound type");
       } else {
         VariableElement parameter = getOnlyElement(method.getParameters());
         if (FrameworkTypes.isFrameworkType(parameter.asType())) {
@@ -91,13 +89,17 @@
       if (isAnyAnnotationPresent(enclosingType, MODULE_ANNOTATIONS)) {
         report.addError(
             String.format(
-                BINDS_INSTANCE_IN_MODULE, simpleName(getModuleAnnotation(enclosingType).get())));
+                "@BindsInstance methods should not be included in @%ss. Did you mean @Binds?",
+                simpleName(getModuleAnnotation(enclosingType).get())));
       }
       if (isAnyAnnotationPresent(enclosingType, COMPONENT_ANNOTATIONS)) {
         AnnotationMirror componentAnnotation =
             getComponentOrSubcomponentAnnotation(enclosingType).get();
         report.addError(
-            String.format(BINDS_INSTANCE_IN_INVALID_COMPONENT, simpleName(componentAnnotation)));
+            String.format(
+                "@BindsInstance methods should not be included in @%1$ss. "
+                    + "Did you mean to put it in a @%1$s.Builder?",
+                simpleName(componentAnnotation)));
       }
       report.build().printMessagesTo(messager);
     }
diff --git a/java/dagger/internal/codegen/BindsMethodValidator.java b/java/dagger/internal/codegen/BindsMethodValidator.java
index 84d1bdcc5..78909e84e 100644
--- a/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -20,8 +20,6 @@
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
-import static dagger.internal.codegen.ErrorMessages.BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
@@ -71,14 +69,20 @@ private void checkParameters(ValidationReport.Builder<ExecutableElement> builder
       TypeMirror rightHandSide = parameter.asType();
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
       if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
-        builder.addError(BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET);
+        builder.addError(
+            "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter");
       }
 
       if (!bindsTypeChecker.isAssignable(rightHandSide, leftHandSide, contributionType)) {
-        builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);
+        // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
+        // right-hand-side might not be assignable to the left-hand-side, but still compatible with
+        // Set.addAll(Collection<? extends E>)
+        builder.addError("@Binds methods' parameter type must be assignable to the return type");
       }
     } else {
-      builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);
+      builder.addError(
+          "@Binds methods must have exactly one parameter, "
+              + "whose type is assignable to the return type");
     }
   }
 
diff --git a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
index 1d9772eff..1210ed6d6 100644
--- a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -19,8 +19,6 @@
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;
-import static dagger.internal.codegen.ErrorMessages.BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
@@ -68,13 +66,15 @@ protected void checkKeyType(
             getQualifiers(builder.getSubject()).stream().findFirst(), keyType, types)
         && !injectedConstructors(MoreElements.asType(MoreTypes.asDeclared(keyType).asElement()))
             .isEmpty()) {
-      builder.addError(BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE);
+      builder.addError(
+          "@BindsOptionalOf methods cannot return unqualified types that have an @Inject-"
+              + "annotated constructor because those are always present");
     }
   }
 
   private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getParameters().isEmpty()) {
-      builder.addError(BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER);
+      builder.addError("@BindsOptionalOf methods cannot have parameters");
     }
   }
 }
diff --git a/java/dagger/internal/codegen/CanReleaseReferencesValidator.java b/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
index 85b8bac93..5c79dab0a 100644
--- a/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
+++ b/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
@@ -18,7 +18,6 @@
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static dagger.internal.codegen.ErrorMessages.CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION;
 import static java.lang.annotation.RetentionPolicy.SOURCE;
 
 import dagger.releasablereferences.CanReleaseReferences;
@@ -52,7 +51,7 @@ private void checkNoSourceRetention(
             retention -> {
               if (getRetentionPolicy(retention).equals(SOURCE)) {
                 report.addError(
-                    CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION,
+                    "@CanReleaseReferences annotations must not have SOURCE retention",
                     report.getSubject(),
                     retention);
               }
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 7ac1d1804..8b0ffc20e 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -412,22 +412,22 @@ private InstanceFactoryCreationExpression instanceFactoryCreationExpression(
   private BindingExpression provisionBindingExpression(
       ResolvedBindings resolvedBindings, RequestKind requestKind) {
     switch (requestKind) {
-      case PRODUCER:
-        return producerFromProviderBindingExpression(resolvedBindings, requestKind);
-
       case INSTANCE:
         return instanceBindingExpression(resolvedBindings);
 
-      case FUTURE:
-        return new ImmediateFutureBindingExpression(resolvedBindings, this, types);
+      case PROVIDER:
+        return providerBindingExpression(resolvedBindings);
 
       case LAZY:
       case PRODUCED:
       case PROVIDER_OF_LAZY:
         return new DerivedFromProviderBindingExpression(resolvedBindings, requestKind, this, types);
 
-      case PROVIDER:
-        return providerBindingExpression(resolvedBindings);
+      case PRODUCER:
+        return producerFromProviderBindingExpression(resolvedBindings, requestKind);
+
+      case FUTURE:
+        return new ImmediateFutureBindingExpression(resolvedBindings, this, types);
 
       case MEMBERS_INJECTION:
         throw new IllegalArgumentException();
@@ -436,6 +436,35 @@ private BindingExpression provisionBindingExpression(
     throw new AssertionError();
   }
 
+  /**
+   * Returns a binding expression for {@link RequestKind#PROVIDER} requests.
+   *
+   * <p>{@code @Binds} bindings that don't {@linkplain #needsCaching(ResolvedBindings) need to be
+   * cached} can use a {@link DelegateBindingExpression}.
+   *
+   * <p>In Android mode, use an {@link InnerSwitchingProviders inner switching provider} unless that
+   * provider's case statement will simply call {@code get()} on another {@link Provider} (in which
+   * case, just use that Provider directly).
+   *
+   * <p>Otherwise, return a {@link FrameworkInstanceBindingExpression}.
+   */
+  private BindingExpression providerBindingExpression(ResolvedBindings resolvedBindings) {
+    if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
+        && !needsCaching(resolvedBindings)) {
+      return new DelegateBindingExpression(
+          resolvedBindings, RequestKind.PROVIDER, this, types, elements);
+    } else if (compilerOptions.experimentalAndroidMode()
+        && frameworkInstanceCreationExpression(resolvedBindings).useInnerSwitchingProvider()
+        && !(instanceBindingExpression(resolvedBindings)
+        instanceof DerivedFromProviderBindingExpression)) {
+      return wrapInMethod(
+          resolvedBindings,
+          RequestKind.PROVIDER,
+          innerSwitchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
+    }
+    return frameworkInstanceBindingExpression(resolvedBindings, RequestKind.PROVIDER);
+  }
+
   /**
    * Returns a binding expression that uses a {@link dagger.producers.Producer} field for a
    * provision binding.
@@ -592,35 +621,6 @@ private boolean canUseDirectInstanceExpression(ResolvedBindings resolvedBindings
             && !requiresReleasableReferences(resolvedBindings));
   }
 
-  /**
-   * Returns a binding expression for {@link RequestKind#PROVIDER} requests.
-   *
-   * <p>{@code @Binds} bindings that don't {@linkplain #needsCaching(ResolvedBindings) need to be
-   * cached} can use a {@link DelegateBindingExpression}.
-   *
-   * <p>In Android mode, use an {@link InnerSwitchingProviders inner switching provider} unless that
-   * provider's case statement will simply call {@code get()} on another {@link Provider} (in which
-   * case, just use that Provider directly).
-   *
-   * <p>Otherwise, return a {@link FrameworkInstanceBindingExpression}.
-   */
-  private BindingExpression providerBindingExpression(ResolvedBindings resolvedBindings) {
-    if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
-        && !needsCaching(resolvedBindings)) {
-      return new DelegateBindingExpression(
-          resolvedBindings, RequestKind.PROVIDER, this, types, elements);
-    } else if (compilerOptions.experimentalAndroidMode()
-        && frameworkInstanceCreationExpression(resolvedBindings).useInnerSwitchingProvider()
-        && !(instanceBindingExpression(resolvedBindings)
-            instanceof DerivedFromProviderBindingExpression)) {
-      return wrapInMethod(
-          resolvedBindings,
-          RequestKind.PROVIDER,
-          innerSwitchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
-    }
-    return frameworkInstanceBindingExpression(resolvedBindings, RequestKind.PROVIDER);
-  }
-
   /**
    * Returns a binding expression that uses a given one as the body of a method that users call. If
    * a component provision method matches it, it will be the method implemented. If not, a new
diff --git a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
index 2ad1cd646..f781a8986 100644
--- a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -68,7 +67,7 @@ static CodeBlock maybeCheckForNull(
             "$T.checkNotNull($L, $S)",
             Preconditions.class,
             invocation,
-            CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD)
+            "Cannot return null from a non-@Nullable component method")
         : invocation;
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index eee833911..89c8195d9 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -25,7 +25,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
-import static dagger.internal.codegen.ErrorMessages.COMPONENT_ANNOTATED_REUSABLE;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -124,7 +123,10 @@ public ComponentValidationReport validate(
 
     Optional<AnnotationMirror> reusableAnnotation = getAnnotationMirror(subject, Reusable.class);
     if (reusableAnnotation.isPresent()) {
-      builder.addError(COMPONENT_ANNOTATED_REUSABLE, subject, reusableAnnotation.get());
+      builder.addError(
+          "@Reusable cannot be applied to components or subcomponents",
+          subject,
+          reusableAnnotation.get());
     }
 
     DeclaredType subjectType = MoreTypes.asDeclared(subject.asType());
diff --git a/java/dagger/internal/codegen/DuplicateBindingsValidation.java b/java/dagger/internal/codegen/DuplicateBindingsValidation.java
index 6074d38fe..7c8686145 100644
--- a/java/dagger/internal/codegen/DuplicateBindingsValidation.java
+++ b/java/dagger/internal/codegen/DuplicateBindingsValidation.java
@@ -22,7 +22,6 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSetMultimap;
 import static dagger.internal.codegen.DuplicateBindingsValidation.SourceAndRequest.indexEdgesBySourceAndRequest;
-import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.internal.codegen.Optionals.emptiesLast;
 import static java.util.Comparator.comparing;
@@ -160,7 +159,7 @@ private void formatDeclarations(
       int indentLevel,
       Iterable<? extends BindingDeclaration> bindingDeclarations) {
     bindingDeclarationFormatter.formatIndentedList(
-        builder, ImmutableList.copyOf(bindingDeclarations), indentLevel, DUPLICATE_SIZE_LIMIT);
+        builder, ImmutableList.copyOf(bindingDeclarations), indentLevel);
     builder.append('\n');
   }
 
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 742349cde..fcc31a5e9 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -16,20 +16,9 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
-import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
-import static java.util.stream.Collectors.joining;
-
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
-import dagger.multibindings.Multibinds;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ForReleasableReferences;
-import java.lang.annotation.Annotation;
-import java.util.Collection;
 import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
@@ -38,231 +27,13 @@
  * The collection of error messages to be reported back to users.
  */
 final class ErrorMessages {
-  static final int DUPLICATE_SIZE_LIMIT = 10;
-
-  /*
-   * JSR-330 errors
-   *
-   * These are errors that are explicitly outlined in the JSR-330 APIs
-   */
-
-  /* constructors */
-  static final String MULTIPLE_INJECT_CONSTRUCTORS =
-      "Types may only contain one @Inject constructor.";
-
-  /* fields */
-  static final String FINAL_INJECT_FIELD = "@Inject fields may not be final";
-
-  /* methods */
-  static final String ABSTRACT_INJECT_METHOD = "Methods with @Inject may not be abstract.";
-  static final String GENERIC_INJECT_METHOD =
-      "Methods with @Inject may not declare type parameters.";
-
-  /* qualifiers */
-  static final String MULTIPLE_QUALIFIERS =
-      "A single injection site may not use more than one @Qualifier.";
-
-  /* scope */
-  static final String MULTIPLE_SCOPES = "A single binding may not declare more than one @Scope.";
-
-  /*
-   * Dagger errors
-   *
-   * These are errors that arise due to restrictions imposed by the dagger implementation.
-   */
-
-  /* constructors */
-  static final String INJECT_ON_PRIVATE_CONSTRUCTOR =
-      "Dagger does not support injection into private constructors";
-  static final String INJECT_CONSTRUCTOR_ON_INNER_CLASS =
-      "@Inject constructors are invalid on inner classes. Did you mean to make the class static?";
-  static final String INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS =
-      "@Inject is nonsense on the constructor of an abstract class";
-  static final String QUALIFIER_ON_INJECT_CONSTRUCTOR =
-      "@Qualifier annotations are not allowed on @Inject constructors.";
-  static final String SCOPE_ON_INJECT_CONSTRUCTOR =
-      "@Scope annotations are not allowed on @Inject constructors. Annotate the class instead.";
-  static final String CHECKED_EXCEPTIONS_ON_CONSTRUCTORS =
-      "Dagger does not support checked exceptions on @Inject constructors.";
-
-  /* fields */
-  static final String PRIVATE_INJECT_FIELD =
-      "Dagger does not support injection into private fields";
-
-  static final String STATIC_INJECT_FIELD =
-      "Dagger does not support injection into static fields";
-
-  /* methods */
-  static final String PRIVATE_INJECT_METHOD =
-      "Dagger does not support injection into private methods";
-
-  static final String STATIC_INJECT_METHOD =
-      "Dagger does not support injection into static methods";
-
-  /* all */
-  static final String INJECT_INTO_PRIVATE_CLASS =
-      "Dagger does not support injection into private classes";
-
-  /*
-   * Configuration errors
-   *
-   * These are errors that relate specifically to the Dagger configuration API (@Module, @Provides,
-   * etc.)
-   */
-  static final String COMPONENT_ANNOTATED_REUSABLE =
-      "@Reusable cannot be applied to components or subcomponents.";
-
-  static final String BINDING_METHOD_RETURN_TYPE =
-      "@%s methods must return a primitive, an array, a type variable, or a declared type.";
-
-  static final String BINDING_METHOD_THROWS_CHECKED =
-      "@%s methods may only throw unchecked exceptions";
-
-  static final String PRODUCES_METHOD_NULLABLE =
-      "@Nullable on @Produces methods does not do anything.";
-
-  static final String PRODUCES_METHOD_RETURN_TYPE =
-      "@Produces methods must return a primitive, an array, a type variable, or a declared type, "
-          + "or a ListenableFuture of one of those types.";
-
-  static final String PRODUCES_METHOD_RAW_FUTURE =
-      "@Produces methods cannot return a raw ListenableFuture.";
-
-  static final String BINDING_METHOD_SET_VALUES_RAW_SET =
-      "@%s methods of type set values cannot return a raw Set";
-
-  static final String BINDING_METHOD_SET_VALUES_RETURN_SET =
-      "@%s methods of type set values must return a Set";
-
-  static final String PRODUCES_METHOD_SET_VALUES_RETURN_SET =
-      "@Produces methods of type set values must return a Set or ListenableFuture of Set";
-
-  static final String PRODUCES_METHOD_SCOPE = "@Produces methods may not have scope annotations.";
-
-  static final String BINDING_METHOD_THROWS =
-      "@%s methods may only throw unchecked exceptions or exceptions subclassing Exception";
-
-  static final String BINDING_METHOD_THROWS_ANY = "@%s methods may not throw";
-
-  static final String BINDING_METHOD_MUST_RETURN_A_VALUE =
-      "@%s methods must return a value (not void).";
-
-  static final String BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES =
-      "@%s methods must not return framework types.";
-
-  static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
-
-  static final String BINDING_METHOD_NOT_ABSTRACT = "@%s methods must be abstract";
-
-  static final String BINDING_METHOD_PRIVATE = "@%s methods cannot be private";
-
-  static final String BINDING_METHOD_TYPE_PARAMETER =
-      "@%s methods may not have type parameters.";
-
-  // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
-  // right-hand-side might not be assignable to the left-hand-side, but still compatible with
-  // Set.addAll(Collection<? extends E>)
-  static final String BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER =
-      "@Binds methods must have only one parameter whose type is assignable to the return type";
-
-  static final String BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER =
-      "@BindsOptionalOf methods must not have parameters";
-
-  static final String BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE =
-      "@BindsOptionalOf methods cannot "
-          + "return unqualified types that have an @Inject-annotated constructor because those are "
-          + "always present";
-
-  static final String BINDING_METHOD_NOT_IN_MODULE = "@%s methods can only be present within a @%s";
-
-  static final String BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET =
-      "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter";
-
-  static final String BINDING_METHOD_NOT_MAP_HAS_MAP_KEY =
-      "@%s methods of non map type cannot declare a map key";
-
-  static final String BINDING_METHOD_WITH_NO_MAP_KEY =
-      "@%s methods of type map must declare a map key";
-
-  static final String BINDING_METHOD_WITH_MULTIPLE_MAP_KEYS =
-      "@%s methods may not have more than one @MapKey-marked annotation";
-
-  static final String BINDING_METHOD_WITH_SAME_NAME =
-      "Cannot have more than one @%s method with the same name in a single module";
-
-  static final String INCOMPATIBLE_MODULE_METHODS =
-      "A @%1$s may not contain both non-static @%2$s methods and abstract @Binds or @Multibinds "
-          + "declarations";
-
-  static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT =
-      "Modules with type parameters must be abstract";
-
-  static final String REFERENCED_MODULE_NOT_ANNOTATED =
-      "%s is listed as a module, but is not annotated with %s";
-
-  static final String REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS =
-      "%s is listed as a module, but has type parameters";
-
-  static final String PROVIDES_METHOD_OVERRIDES_ANOTHER =
-      "@%s methods may not override another method. Overrides: %s";
-
-  static final String METHOD_OVERRIDES_PROVIDES_METHOD =
-      "@%s methods may not be overridden in modules. Overrides: %s";
-
-  static final String BINDING_METHOD_MULTIPLE_QUALIFIERS =
-      "Cannot use more than one @Qualifier";
-
-  /* mapKey errors */
-  static final String MAPKEY_WITHOUT_MEMBERS = "Map key annotations must have members";
-
-  static final String UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS=
-      "Map key annotations with unwrapped values must have exactly one member";
-
-  static final String UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER =
-      "Map key annotations with unwrapped values cannot use arrays";
-
-  /* producer errors */
-  static final String DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT =
-      "%s may not depend on the production executor.";
-
-  private static final String PROVISION_MAY_NOT_DEPEND_ON_PRODUCER_TYPE_FORMAT =
-      "%s may only be injected in @Produces methods.";
 
   static String provisionMayNotDependOnProducerType(TypeMirror type) {
     return String.format(
-        PROVISION_MAY_NOT_DEPEND_ON_PRODUCER_TYPE_FORMAT,
+        "%s may only be injected in @Produces methods",
         MoreTypes.asTypeElement(type).getSimpleName());
   }
 
-  static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "Found a dependency cycle:\n%s";
-
-  static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD =
-      "Cannot return null from a non-@Nullable component method";
-
-  static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD =
-      "Cannot return null from a non-@Nullable @Provides method";
-
-  /* Multibinding messages */
-  static final String MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD =
-      "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods";
-
-  static final String MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD =
-      "Multiple multibinding annotations cannot be placed on the same %s method";
-
-  static final String MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM =
-      "@%s.type cannot be used with multibinding annotations";
-
-  /* BindsInstance messages. */
-  static final String BINDS_INSTANCE_IN_MODULE =
-      "@BindsInstance methods should not be included in @%ss. Did you mean @Binds?";
-
-  static final String BINDS_INSTANCE_IN_INVALID_COMPONENT =
-      "@BindsInstance methods should not be included in @%1$ss. "
-          + "Did you mean to put it in a @%1$s.Builder?";
-
-  static final String BINDS_INSTANCE_ONE_PARAMETER =
-      "@BindsInstance methods should have exactly one parameter for the bound type";
-
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
       case COMPONENT:
@@ -278,63 +49,6 @@ static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     }
   }
 
-  static final String CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION =
-      "@CanReleaseReferences annotations must not have SOURCE retention";
-
-  static String forReleasableReferencesValueNotAScope(TypeElement scopeType) {
-    return forReleasableReferencesValueNeedsAnnotation(
-        scopeType,
-        String.format(
-            "@%s and @%s",
-            javax.inject.Scope.class.getCanonicalName(),
-            CanReleaseReferences.class.getCanonicalName()));
-  }
-
-  static String forReleasableReferencesValueCannotReleaseReferences(TypeElement scopeType) {
-    return forReleasableReferencesValueNeedsAnnotation(
-        scopeType, "@" + CanReleaseReferences.class.getCanonicalName());
-  }
-
-  private static String forReleasableReferencesValueNeedsAnnotation(
-      TypeElement scopeType, String annotations) {
-    return String.format(
-        "The value of @%s must be a reference-releasing scope. "
-            + "Did you mean to annotate %s with %s? Or did you mean to use a different class here?",
-        ForReleasableReferences.class.getSimpleName(), scopeType.getQualifiedName(), annotations);
-  }
-
-  /**
-   * Returns an error message for a method that has more than one binding method annotation.
-   *
-   * @param methodAnnotations the valid method annotations, only one of which may annotate the
-   *     method
-   */
-  static String tooManyBindingMethodAnnotations(
-      ExecutableElement method, Collection<Class<? extends Annotation>> methodAnnotations) {
-    return String.format(
-        "%s is annotated with more than one of (%s)",
-        method.getSimpleName(),
-        methodAnnotations.stream().map(Class::getCanonicalName).collect(joining(", ")));
-  }
-
-  static String abstractModuleHasInstanceBindingMethods(ModuleDescriptor module) {
-    String methodAnnotations;
-    switch (module.kind()) {
-      case MODULE:
-        methodAnnotations = "@Provides";
-        break;
-      case PRODUCER_MODULE:
-        methodAnnotations = "@Provides or @Produces";
-        break;
-      default:
-        throw new AssertionError(module.kind());
-    }
-    return String.format(
-        "%s is abstract and has instance %s methods. Consider making the methods static or "
-            + "including a non-abstract subclass of the module instead.",
-        module.moduleElement(), methodAnnotations);
-  }
-
   static class ComponentBuilderMessages {
     static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
 
@@ -501,47 +215,5 @@ protected String process(String s) {
     }
   }
 
-  /** Error messages related to {@link Multibinds @Multibinds} methods. */
-  static final class MultibindsMessages {
-    static final String METHOD_MUST_RETURN_MAP_OR_SET =
-        "@%s methods must return Map<K, V> or Set<T>";
-
-    static final String PARAMETERS = "@%s methods cannot have parameters";
-
-    private MultibindsMessages() {}
-  }
-
-  static class ModuleMessages {
-    static String moduleSubcomponentsIncludesBuilder(TypeElement moduleSubcomponentsAttribute) {
-      TypeElement subcomponentType =
-          MoreElements.asType(moduleSubcomponentsAttribute.getEnclosingElement());
-      return String.format(
-          "%s is a @%s.Builder. Did you mean to use %s?",
-          moduleSubcomponentsAttribute.getQualifiedName(),
-          simpleName(getSubcomponentAnnotation(subcomponentType).get()),
-          subcomponentType.getQualifiedName());
-    }
-
-    static String moduleSubcomponentsIncludesNonSubcomponent(
-        TypeElement moduleSubcomponentsAttribute) {
-      return moduleSubcomponentsAttribute.getQualifiedName()
-          + " is not a @Subcomponent or @ProductionSubcomponent";
-    }
-
-    static String moduleSubcomponentsDoesntHaveBuilder(
-        TypeElement subcomponent, AnnotationMirror moduleAnnotation) {
-      return String.format(
-          "%s doesn't have a @%s.Builder, which is required when used with @%s.subcomponents",
-          subcomponent.getQualifiedName(),
-          simpleName(getSubcomponentAnnotation(subcomponent).get()),
-          simpleName(moduleAnnotation));
-    }
-  }
-
-  //TODO(cgruber): Extract Formatter and do something less stringy.
-  static String format(AnnotationMirror annotation) {
-    return DiagnosticFormatting.stripCommonTypePrefixes(annotation.toString());
-  }
-
   private ErrorMessages() {}
 }
diff --git a/java/dagger/internal/codegen/FactoryGenerator.java b/java/dagger/internal/codegen/FactoryGenerator.java
index 01dcd9e03..3e34d3a6d 100644
--- a/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/java/dagger/internal/codegen/FactoryGenerator.java
@@ -27,7 +27,6 @@
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
-import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkFieldUsages;
@@ -303,6 +302,6 @@ static CodeBlock checkNotNullProvidesMethod(CodeBlock providesMethodInvocation)
         "$T.checkNotNull($L, $S)",
         Preconditions.class,
         providesMethodInvocation,
-        CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+        "Cannot return null from a non-@Nullable @Provides method");
   }
 }
diff --git a/java/dagger/internal/codegen/ForReleasableReferencesValidator.java b/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
index 452cb24cf..df8d3b969 100644
--- a/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
+++ b/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
@@ -19,8 +19,6 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueCannotReleaseReferences;
-import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueNotAScope;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.Scopes.scope;
 import static dagger.model.Scope.isScope;
@@ -29,6 +27,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
+import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
 import java.lang.annotation.Annotation;
 import java.util.Set;
@@ -81,4 +80,26 @@
         .forEach(report -> report.printMessagesTo(messager));
     return ImmutableSet.of();
   }
+
+  private static String forReleasableReferencesValueNotAScope(TypeElement scopeType) {
+    return forReleasableReferencesValueNeedsAnnotation(
+        scopeType,
+        String.format(
+            "@%s and @%s",
+            javax.inject.Scope.class.getCanonicalName(),
+            CanReleaseReferences.class.getCanonicalName()));
+  }
+
+  private static String forReleasableReferencesValueCannotReleaseReferences(TypeElement scopeType) {
+    return forReleasableReferencesValueNeedsAnnotation(
+        scopeType, "@" + CanReleaseReferences.class.getCanonicalName());
+  }
+
+  private static String forReleasableReferencesValueNeedsAnnotation(
+      TypeElement scopeType, String annotations) {
+    return String.format(
+        "The value of @%s must be a reference-releasing scope. "
+            + "Did you mean to annotate %s with %s? Or did you mean to use a different class here?",
+        ForReleasableReferences.class.getSimpleName(), scopeType.getQualifiedName(), annotations);
+  }
 }
diff --git a/java/dagger/internal/codegen/Formatter.java b/java/dagger/internal/codegen/Formatter.java
index 176477e06..674f2cb40 100644
--- a/java/dagger/internal/codegen/Formatter.java
+++ b/java/dagger/internal/codegen/Formatter.java
@@ -31,6 +31,7 @@
 
   static final String INDENT = "    ";
   static final String DOUBLE_INDENT = INDENT + INDENT;
+  private static final int LIST_LIMIT = 10;
 
   /**
    * Performs the transformation of an object into a string representation.
@@ -51,26 +52,15 @@ public final String apply(T object) {
     return format(object);
   }
 
-  /**
-   * Formats {@code items}, one per line. Stops after {@code limit} items.
-   */
+  /** Formats {@code items}, one per line. Stops after {@value #LIST_LIMIT} items. */
   public void formatIndentedList(
-      StringBuilder builder, Iterable<? extends T> items, int indentLevel, int limit) {
-    formatIndentedList(
-        builder, indentLevel, Iterables.limit(items, limit), Iterables.skip(items, limit));
-  }
-
-  private void formatIndentedList(
-      StringBuilder builder,
-      int indentLevel,
-      Iterable<? extends T> firstItems,
-      Iterable<? extends T> restOfItems) {
-    for (T item : firstItems) {
+      StringBuilder builder, Iterable<? extends T> items, int indentLevel) {
+    for (T item : Iterables.limit(items, LIST_LIMIT)) {
       builder.append('\n');
       appendIndent(builder, indentLevel);
       builder.append(format(item));
     }
-    int numberOfOtherItems = Iterables.size(restOfItems);
+    int numberOfOtherItems = Iterables.size(items) - LIST_LIMIT;
     if (numberOfOtherItems > 0) {
       builder.append('\n');
       appendIndent(builder, indentLevel);
diff --git a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidation.java b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidation.java
new file mode 100644
index 000000000..0a1c708ff
--- /dev/null
+++ b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidation.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.DaggerElements.closestEnclosingTypeElement;
+import static dagger.internal.codegen.Formatter.INDENT;
+import static dagger.internal.codegen.Scopes.getReadableSource;
+import static java.util.stream.Collectors.joining;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Multimaps;
+import dagger.model.Binding;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.ComponentNode;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.Set;
+import javax.inject.Inject;
+
+/**
+ * Reports an error for any component that uses bindings with scopes that are not assigned to the
+ * component.
+ */
+final class IncompatiblyScopedBindingsValidation implements BindingGraphPlugin {
+
+  private final MethodSignatureFormatter methodSignatureFormatter;
+
+  @Inject
+  IncompatiblyScopedBindingsValidation(MethodSignatureFormatter methodSignatureFormatter) {
+    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/IncompatiblyScopedBindings";
+  }
+
+  @Override
+  public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    ImmutableSetMultimap.Builder<ComponentNode, BindingNode> incompatibleBindingNodes =
+        ImmutableSetMultimap.builder();
+    for (BindingNode bindingNode : bindingGraph.bindingNodes()) {
+      bindingNode
+          .binding()
+          .scope()
+          .ifPresent(
+              scope -> {
+                if (scope.isReusable()) {
+                  return;
+                }
+                ComponentNode componentNode =
+                    bindingGraph.componentNode(bindingNode.componentPath()).get();
+                if (!componentNode.scopes().contains(scope)) {
+                  incompatibleBindingNodes.put(componentNode, bindingNode);
+                }
+              });
+    }
+    Multimaps.asMap(incompatibleBindingNodes.build())
+        .forEach(
+            (componentNode, bindingNodes) ->
+                diagnosticReporter.reportComponent(
+                    ERROR,
+                    componentNode,
+                    incompatibleBindingScopesError(componentNode, bindingNodes)));
+  }
+
+  private String incompatibleBindingScopesError(
+      ComponentNode componentNode, Set<BindingNode> bindingNodes) {
+    StringBuilder message =
+        new StringBuilder(componentNode.componentPath().currentComponent().getQualifiedName());
+    if (!componentNode.scopes().isEmpty()) {
+      message
+          .append(" scoped with ")
+          .append(
+              componentNode.scopes().stream().map(Scopes::getReadableSource).collect(joining(" ")))
+          .append(" may not reference bindings with different scopes:\n");
+    } else {
+      message.append(" (unscoped) may not reference scoped bindings:\n");
+    }
+    // TODO(ronshapiro): Should we group by scope?
+    for (BindingNode bindingNode : bindingNodes) {
+      message.append(INDENT);
+
+      Binding binding = bindingNode.binding();
+      switch (binding.kind()) {
+        case DELEGATE:
+        case PROVISION:
+          message.append(
+              methodSignatureFormatter.format(
+                  MoreElements.asExecutable(binding.bindingElement().get())));
+          break;
+
+        case INJECTION:
+          message
+              .append(getReadableSource(binding.scope().get()))
+              .append(" class ")
+              .append(
+                  closestEnclosingTypeElement(binding.bindingElement().get()).getQualifiedName());
+          break;
+
+        default:
+          throw new AssertionError(bindingNode);
+      }
+
+      message.append("\n");
+    }
+    return message.toString();
+  }
+}
diff --git a/java/dagger/internal/codegen/InjectValidator.java b/java/dagger/internal/codegen/InjectValidator.java
index 68d69bc54..4d6c89b03 100644
--- a/java/dagger/internal/codegen/InjectValidator.java
+++ b/java/dagger/internal/codegen/InjectValidator.java
@@ -17,24 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.Accessibility.isElementAccessibleFromOwnPackage;
-import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.CHECKED_EXCEPTIONS_ON_CONSTRUCTORS;
-import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
-import static dagger.internal.codegen.ErrorMessages.SCOPE_ON_INJECT_CONSTRUCTOR;
-import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
@@ -48,11 +30,13 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.ValidationReport.Builder;
 import dagger.model.Scope;
 import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
@@ -103,24 +87,26 @@ InjectValidator whenGeneratingCode() {
     ValidationReport.Builder<TypeElement> builder =
         ValidationReport.about(MoreElements.asType(constructorElement.getEnclosingElement()));
     if (constructorElement.getModifiers().contains(PRIVATE)) {
-      builder.addError(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
+      builder.addError(
+          "Dagger does not support injection into private constructors", constructorElement);
     }
 
     for (AnnotationMirror qualifier : getQualifiers(constructorElement)) {
-      builder.addError(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);
+      builder.addError(
+          "@Qualifier annotations are not allowed on @Inject constructors",
+          constructorElement,
+          qualifier);
     }
 
     for (Scope scope : scopesOf(constructorElement)) {
-      builder.addError(SCOPE_ON_INJECT_CONSTRUCTOR, constructorElement, scope.scopeAnnotation());
+      builder.addError(
+          "@Scope annotations are not allowed on @Inject constructors; annotate the class instead",
+          constructorElement,
+          scope.scopeAnnotation());
     }
 
     for (VariableElement parameter : constructorElement.getParameters()) {
-      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
-      if (qualifiers.size() > 1) {
-        for (AnnotationMirror qualifier : qualifiers) {
-          builder.addError(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
-        }
-      }
+      checkMultipleQualifiers(constructorElement, parameter, builder);
       if (FrameworkTypes.isProducerType(parameter.asType())) {
         builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
       }
@@ -128,44 +114,45 @@ InjectValidator whenGeneratingCode() {
 
     if (throwsCheckedExceptions(constructorElement)) {
       builder.addItem(
-          CHECKED_EXCEPTIONS_ON_CONSTRUCTORS,
+          "Dagger does not support checked exceptions on @Inject constructors",
           privateAndStaticInjectionDiagnosticKind.orElse(
               compilerOptions.privateMemberValidationKind()),
           constructorElement);
     }
 
+    checkInjectIntoPrivateClass(constructorElement, builder);
+
     TypeElement enclosingElement =
         MoreElements.asType(constructorElement.getEnclosingElement());
-    Set<Modifier> typeModifiers = enclosingElement.getModifiers();
-
-    if (!Accessibility.isElementAccessibleFromOwnPackage(enclosingElement)) {
-      builder.addItem(
-          INJECT_INTO_PRIVATE_CLASS,
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.privateMemberValidationKind()),
-          constructorElement);
-    }
 
+    Set<Modifier> typeModifiers = enclosingElement.getModifiers();
     if (typeModifiers.contains(ABSTRACT)) {
-      builder.addError(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
+      builder.addError(
+          "@Inject is nonsense on the constructor of an abstract class", constructorElement);
     }
 
     if (enclosingElement.getNestingKind().isNested()
         && !typeModifiers.contains(STATIC)) {
-      builder.addError(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
+      builder.addError(
+          "@Inject constructors are invalid on inner classes. "
+              + "Did you mean to make the class static?",
+          constructorElement);
     }
 
     // This is computationally expensive, but probably preferable to a giant index
     ImmutableSet<ExecutableElement> injectConstructors = injectedConstructors(enclosingElement);
 
     if (injectConstructors.size() > 1) {
-      builder.addError(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
+      builder.addError("Types may only contain one @Inject constructor", constructorElement);
     }
 
     ImmutableSet<Scope> scopes = scopesOf(enclosingElement);
     if (scopes.size() > 1) {
       for (Scope scope : scopes) {
-        builder.addError(MULTIPLE_SCOPES, enclosingElement, scope.scopeAnnotation());
+        builder.addError(
+            "A single binding may not declare more than one @Scope",
+            enclosingElement,
+            scope.scopeAnnotation());
       }
     }
 
@@ -176,12 +163,12 @@ InjectValidator whenGeneratingCode() {
     ValidationReport.Builder<VariableElement> builder = ValidationReport.about(fieldElement);
     Set<Modifier> modifiers = fieldElement.getModifiers();
     if (modifiers.contains(FINAL)) {
-      builder.addError(FINAL_INJECT_FIELD, fieldElement);
+      builder.addError("@Inject fields may not be final", fieldElement);
     }
 
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
-          PRIVATE_INJECT_FIELD,
+          "Dagger does not support injection into private fields",
           privateAndStaticInjectionDiagnosticKind.orElse(
               compilerOptions.privateMemberValidationKind()),
           fieldElement);
@@ -189,18 +176,13 @@ InjectValidator whenGeneratingCode() {
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
-          STATIC_INJECT_FIELD,
+          "Dagger does not support injection into static fields",
           privateAndStaticInjectionDiagnosticKind.orElse(
               compilerOptions.staticMemberValidationKind()),
           fieldElement);
     }
 
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
-      }
-    }
+    checkMultipleQualifiers(fieldElement, fieldElement, builder);
 
     if (FrameworkTypes.isProducerType(fieldElement.asType())) {
       builder.addError(provisionMayNotDependOnProducerType(fieldElement.asType()), fieldElement);
@@ -213,12 +195,12 @@ InjectValidator whenGeneratingCode() {
     ValidationReport.Builder<ExecutableElement> builder = ValidationReport.about(methodElement);
     Set<Modifier> modifiers = methodElement.getModifiers();
     if (modifiers.contains(ABSTRACT)) {
-      builder.addError(ABSTRACT_INJECT_METHOD, methodElement);
+      builder.addError("Methods with @Inject may not be abstract", methodElement);
     }
 
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
-          PRIVATE_INJECT_METHOD,
+          "Dagger does not support injection into private methods",
           privateAndStaticInjectionDiagnosticKind.orElse(
               compilerOptions.privateMemberValidationKind()),
           methodElement);
@@ -226,23 +208,18 @@ InjectValidator whenGeneratingCode() {
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
-          STATIC_INJECT_METHOD,
+          "Dagger does not support injection into static methods",
           privateAndStaticInjectionDiagnosticKind.orElse(
               compilerOptions.staticMemberValidationKind()),
           methodElement);
     }
 
     if (!methodElement.getTypeParameters().isEmpty()) {
-      builder.addError(GENERIC_INJECT_METHOD, methodElement);
+      builder.addError("Methods with @Inject may not declare type parameters", methodElement);
     }
 
     for (VariableElement parameter : methodElement.getParameters()) {
-      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
-      if (qualifiers.size() > 1) {
-        for (AnnotationMirror qualifier : qualifiers) {
-          builder.addError(MULTIPLE_QUALIFIERS, methodElement, qualifier);
-        }
-      }
+      checkMultipleQualifiers(methodElement, parameter, builder);
       if (FrameworkTypes.isProducerType(parameter.asType())) {
         builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
       }
@@ -275,12 +252,8 @@ InjectValidator whenGeneratingCode() {
       }
     }
 
-    if (hasInjectedMembers && !isElementAccessibleFromOwnPackage(typeElement)) {
-      builder.addItem(
-          INJECT_INTO_PRIVATE_CLASS,
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.privateMemberValidationKind()),
-          typeElement);
+    if (hasInjectedMembers) {
+      checkInjectIntoPrivateClass(typeElement, builder);
     }
     TypeMirror superclass = typeElement.getSuperclass();
     if (!superclass.getKind().equals(TypeKind.NONE)) {
@@ -330,4 +303,31 @@ private boolean throwsCheckedExceptions(ExecutableElement methodElement) {
     }
     return false;
   }
+
+  // TODO(dpb,ronshapiro): Use this on AnyBindingMethodValidator, or a DependencyRequestValidator.
+  // Currently, @Provides and @Produces methods with multiple qualifiers on a dependency will crash
+  // the compiler.
+  private void checkMultipleQualifiers(
+      Element errorElement, Element qualifiedElement, ValidationReport.Builder<?> builder) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(qualifiedElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addError(
+            "A single injection site may not use more than one @Qualifier",
+            errorElement,
+            qualifier);
+      }
+    }
+  }
+
+  private void checkInjectIntoPrivateClass(Element element, Builder<TypeElement> builder) {
+    if (!Accessibility.isElementAccessibleFromOwnPackage(
+        DaggerElements.closestEnclosingTypeElement(element))) {
+      builder.addItem(
+          "Dagger does not support injection into private classes",
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.privateMemberValidationKind()),
+          element);
+    }
+  }
 }
diff --git a/java/dagger/internal/codegen/MapKeyValidator.java b/java/dagger/internal/codegen/MapKeyValidator.java
index a1a69b912..e9027ba10 100644
--- a/java/dagger/internal/codegen/MapKeyValidator.java
+++ b/java/dagger/internal/codegen/MapKeyValidator.java
@@ -16,9 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.ErrorMessages.MAPKEY_WITHOUT_MEMBERS;
-import static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER;
-import static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import dagger.MapKey;
@@ -46,12 +43,13 @@
     ValidationReport.Builder<Element> builder = ValidationReport.about(element);
     List<ExecutableElement> members = methodsIn(((TypeElement) element).getEnclosedElements());
     if (members.isEmpty()) {
-      builder.addError(MAPKEY_WITHOUT_MEMBERS, element);
+      builder.addError("Map key annotations must have members", element);
     } else if (element.getAnnotation(MapKey.class).unwrapValue()) {
       if (members.size() > 1) {
-        builder.addError(UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS, element);
+        builder.addError(
+            "Map key annotations with unwrapped values must have exactly one member", element);
       } else if (members.get(0).getReturnType().getKind() == TypeKind.ARRAY) {
-        builder.addError(UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER, element);
+        builder.addError("Map key annotations with unwrapped values cannot use arrays", element);
       }
     } else if (autoAnnotationIsMissing()) {
       builder.addError(
diff --git a/java/dagger/internal/codegen/MapMultibindingValidation.java b/java/dagger/internal/codegen/MapMultibindingValidation.java
index 1f963717a..0c6893336 100644
--- a/java/dagger/internal/codegen/MapMultibindingValidation.java
+++ b/java/dagger/internal/codegen/MapMultibindingValidation.java
@@ -19,7 +19,6 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
 import static javax.tools.Diagnostic.Kind.ERROR;
@@ -135,8 +134,7 @@ private String inconsistentMapKeyAnnotationTypesErrorMessage(
         .forEach(
             (annotationType, contributions) -> {
               message.append('\n').append(INDENT).append(annotationType.get()).append(':');
-              bindingDeclarationFormatter.formatIndentedList(
-                  message, contributions, 2, DUPLICATE_SIZE_LIMIT);
+              bindingDeclarationFormatter.formatIndentedList(message, contributions, 2);
             });
     return message.toString();
   }
@@ -145,8 +143,7 @@ private String duplicateMapKeyErrorMessage(
       Set<ContributionBinding> contributionsForOneMapKey, Key mapBindingKey) {
     StringBuilder message =
         new StringBuilder("The same map key is bound more than once for ").append(mapBindingKey);
-    bindingDeclarationFormatter.formatIndentedList(
-        message, contributionsForOneMapKey, 1, DUPLICATE_SIZE_LIMIT);
+    bindingDeclarationFormatter.formatIndentedList(message, contributionsForOneMapKey, 1);
     return message.toString();
   }
 }
diff --git a/java/dagger/internal/codegen/MethodSignatureFormatter.java b/java/dagger/internal/codegen/MethodSignatureFormatter.java
index 893aa97d5..6ffee05d0 100644
--- a/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -71,7 +71,7 @@ public String format(ExecutableElement method, Optional<DeclaredType> container)
         if (i > 0) {
           builder.append(' ');
         }
-        builder.append(ErrorMessages.format(annotationIterator.next()));
+        builder.append(formatAnnotation(annotationIterator.next()));
       }
       builder.append(' ');
     }
@@ -99,7 +99,7 @@ private static void appendParameter(StringBuilder builder, VariableElement param
     getQualifier(parameter)
         .ifPresent(
             qualifier -> {
-              builder.append(ErrorMessages.format(qualifier)).append(' ');
+              builder.append(formatAnnotation(qualifier)).append(' ');
             });
     builder.append(nameOfType(type));
   }
@@ -107,4 +107,8 @@ private static void appendParameter(StringBuilder builder, VariableElement param
   private static String nameOfType(TypeMirror type) {
     return stripCommonTypePrefixes(type.toString());
   }
+
+  private static String formatAnnotation(AnnotationMirror annotation) {
+    return stripCommonTypePrefixes(annotation.toString());
+  }
 }
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index eadcfe732..89715eaf0 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -26,20 +26,12 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
-import static dagger.internal.codegen.ErrorMessages.INCOMPATIBLE_MODULE_METHODS;
-import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
-import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsDoesntHaveBuilder;
-import static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsIncludesBuilder;
-import static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsIncludesNonSubcomponent;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;
-import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
-import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
+import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static dagger.internal.codegen.MoreAnnotationValues.asType;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static java.util.EnumSet.noneOf;
@@ -208,7 +200,8 @@ void addKnownModules(Collection<TypeElement> modules) {
         EnumSet.of(ModuleMethodKind.ABSTRACT_DECLARATION, ModuleMethodKind.INSTANCE_BINDING))) {
       builder.addError(
           String.format(
-              INCOMPATIBLE_MODULE_METHODS,
+              "A @%s may not contain both non-static @%s methods and "
+                  + "abstract @Binds or @Multibinds declarations",
               moduleKind.moduleAnnotation().getSimpleName(),
               moduleKind.methodAnnotation().getSimpleName()));
     }
@@ -264,6 +257,22 @@ public Void visitDeclared(DeclaredType declaredType, Void aVoid) {
     }
   }
 
+  private static String moduleSubcomponentsIncludesNonSubcomponent(TypeElement notSubcomponent) {
+    return notSubcomponent.getQualifiedName()
+        + " is not a @Subcomponent or @ProductionSubcomponent";
+  }
+
+  private static String moduleSubcomponentsIncludesBuilder(
+      TypeElement moduleSubcomponentsAttribute) {
+    TypeElement subcomponentType =
+        MoreElements.asType(moduleSubcomponentsAttribute.getEnclosingElement());
+    return String.format(
+        "%s is a @%s.Builder. Did you mean to use %s?",
+        moduleSubcomponentsAttribute.getQualifiedName(),
+        simpleName(getSubcomponentAnnotation(subcomponentType).get()),
+        subcomponentType.getQualifiedName());
+  }
+
   private static void validateSubcomponentHasBuilder(
       TypeElement subcomponentAttribute,
       AnnotationMirror moduleAnnotation,
@@ -277,6 +286,15 @@ private static void validateSubcomponentHasBuilder(
         moduleAnnotation);
   }
 
+  private static String moduleSubcomponentsDoesntHaveBuilder(
+      TypeElement subcomponent, AnnotationMirror moduleAnnotation) {
+    return String.format(
+        "%s doesn't have a @%s.Builder, which is required when used with @%s.subcomponents",
+        subcomponent.getQualifiedName(),
+        simpleName(getSubcomponentAnnotation(subcomponent).get()),
+        simpleName(moduleAnnotation));
+  }
+
   enum ModuleMethodKind {
     ABSTRACT_DECLARATION,
     INSTANCE_BINDING,
@@ -299,7 +317,7 @@ private void validateModifiers(
     // This coupled with the check for abstract modules in ComponentValidator guarantees that
     // only modules without type parameters are referenced from @Component(modules={...}).
     if (!subject.getTypeParameters().isEmpty() && !subject.getModifiers().contains(ABSTRACT)) {
-      builder.addError(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT, subject);
+      builder.addError("Modules with type parameters must be abstract", subject);
     }
   }
 
@@ -313,7 +331,8 @@ private void validateMethodsWithSameName(
         for (ExecutableElement offendingMethod : entry.getValue()) {
           builder.addError(
               String.format(
-                  BINDING_METHOD_WITH_SAME_NAME, moduleKind.methodAnnotation().getSimpleName()),
+                  "Cannot have more than one @%s method with the same name in a single module",
+                  moduleKind.methodAnnotation().getSimpleName()),
               offendingMethod);
         }
       }
@@ -373,11 +392,12 @@ public Void visitDeclared(DeclaredType t, Void p) {
                   TypeElement module = MoreElements.asType(t.asElement());
                   if (!t.getTypeArguments().isEmpty()) {
                     reportError(
-                        REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS, module.getQualifiedName());
+                        "%s is listed as a module, but has type parameters",
+                        module.getQualifiedName());
                   }
                   if (!isAnyAnnotationPresent(module, validModuleAnnotations)) {
                     reportError(
-                        REFERENCED_MODULE_NOT_ANNOTATED,
+                        "%s is listed as a module, but is not annotated with %s",
                         module.getQualifiedName(),
                         (validModuleAnnotations.size() > 1 ? "one of " : "")
                             + validModuleAnnotations
@@ -439,7 +459,7 @@ private void validateProvidesOverrides(
             failedMethods.add(providesMethod);
             builder.addError(
                 String.format(
-                    PROVIDES_METHOD_OVERRIDES_ANOTHER,
+                    "@%s methods may not override another method. Overrides: %s",
                     moduleKind.methodAnnotation().getSimpleName(),
                     methodSignatureFormatter.format(superclassMethod)),
                 providesMethod);
@@ -453,7 +473,7 @@ private void validateProvidesOverrides(
               failedMethods.add(method);
               builder.addError(
                   String.format(
-                      METHOD_OVERRIDES_PROVIDES_METHOD,
+                      "@%s methods may not be overridden in modules. Overrides: %s",
                       moduleKind.methodAnnotation().getSimpleName(),
                       methodSignatureFormatter.format(superclassMethod)),
                   method);
diff --git a/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java b/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
index f646b5c91..4f9c31d95 100644
--- a/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
+++ b/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
@@ -18,7 +18,6 @@
 
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
-import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.common.collect.ImmutableSet;
@@ -67,7 +66,10 @@
       if (!isAnyAnnotationPresent(element, VALID_BINDING_ANNOTATIONS)) {
         AnnotationMirror annotation = getAnnotationMirror(entry.getValue(), entry.getKey()).get();
         messager.printMessage(
-            Kind.ERROR, MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD, element, annotation);
+            Kind.ERROR,
+            "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods",
+            element,
+            annotation);
       }
     }
     return ImmutableSet.of();
diff --git a/java/dagger/internal/codegen/MultibindsMethodValidator.java b/java/dagger/internal/codegen/MultibindsMethodValidator.java
index f780e9423..bfac2839a 100644
--- a/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -19,8 +19,6 @@
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;
-import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
-import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.PARAMETERS;
 import static dagger.internal.codegen.FrameworkTypes.isFrameworkType;
 
 import com.google.auto.common.MoreTypes;
@@ -58,7 +56,7 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
 
   private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getParameters().isEmpty()) {
-      builder.addError(formatErrorMessage(PARAMETERS));
+      builder.addError(bindingMethods("cannot have parameters"));
     }
   }
 
@@ -67,7 +65,7 @@ private void checkParameters(ValidationReport.Builder<ExecutableElement> builder
   protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
     if (!isPlainMap(builder.getSubject().getReturnType())
         && !isPlainSet(builder.getSubject().getReturnType())) {
-      builder.addError(formatErrorMessage(METHOD_MUST_RETURN_MAP_OR_SET));
+      builder.addError(bindingMethods("must return Map<K, V> or Set<T>"));
     }
   }
 
diff --git a/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 6d292cfc5..16e5cd923 100644
--- a/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Verify.verifyNotNull;
 import static com.squareup.javapoet.ClassName.OBJECT;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
@@ -76,15 +77,18 @@
  */
 final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
   private final CompilerOptions compilerOptions;
+  private final KeyFactory keyFactory;
 
   @Inject
   ProducerFactoryGenerator(
       Filer filer,
       Elements elements,
       SourceVersion sourceVersion,
-      CompilerOptions compilerOptions) {
+      CompilerOptions compilerOptions,
+      KeyFactory keyFactory) {
     super(filer, elements, sourceVersion);
     this.compilerOptions = compilerOptions;
+    this.keyFactory = keyFactory;
   }
 
   @Override
@@ -133,15 +137,23 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                     TypeName.get(binding.bindingTypeElement().get().asType())))
             : Optional.empty();
 
+    String monitorParameterName = null;
     for (Map.Entry<Key, FrameworkField> entry :
         generateBindingFieldsForDependencies(binding).entrySet()) {
       Key key = entry.getKey();
       FrameworkField bindingField = entry.getValue();
+      String fieldName = uniqueFieldNames.getUniqueName(bindingField.name());
+      if (key.equals(keyFactory.forProductionComponentMonitor())) {
+        monitorParameterName = fieldName;
+        constructorBuilder.addParameter(bindingField.type(), monitorParameterName);
+        continue;
+      }
+
       FieldSpec field =
           addFieldAndConstructorParameter(
               factoryBuilder,
               constructorBuilder,
-              uniqueFieldNames.getUniqueName(bindingField.name()),
+              fieldName,
               bindingField.type());
       fieldsBuilder.put(key, field);
     }
@@ -149,7 +161,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
 
     constructorBuilder.addStatement(
         "super($N, $L)",
-        fields.get(binding.monitorRequest().get().key()),
+        verifyNotNull(monitorParameterName),
         producerTokenConstruction(generatedTypeName, binding));
 
     if (binding.requiresModuleInstance()) {
@@ -202,10 +214,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
             .addExceptions(getThrownTypeNames(binding.thrownTypes()))
             .addCode(
                 getInvocationCodeBlock(
-                    generatedTypeName,
-                    binding,
-                    providedTypeName,
-                    futureTransform.parameterCodeBlocks()));
+                    binding, providedTypeName, futureTransform.parameterCodeBlocks()));
     if (futureTransform.hasUncheckedCast()) {
       applyMethodBuilder.addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED));
     }
@@ -378,7 +387,11 @@ TypeName applyArgType() {
 
     @Override
     String applyArgName() {
-      return asyncDependency.requestElement().get().getSimpleName().toString();
+      String argName = asyncDependency.requestElement().get().getSimpleName().toString();
+      if (argName.equals("module")) {
+        return "moduleArg";
+      }
+      return argName;
     }
 
     @Override
@@ -494,7 +507,6 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
    * @param parameterCodeBlocks The code blocks for all the parameters to the producer method.
    */
   private CodeBlock getInvocationCodeBlock(
-      ClassName generatedTypeName,
       ProductionBinding binding,
       TypeName providedTypeName,
       ImmutableList<CodeBlock> parameterCodeBlocks) {
@@ -502,7 +514,7 @@ private CodeBlock getInvocationCodeBlock(
         CodeBlock.of(
             "$L.$L($L)",
             binding.requiresModuleInstance()
-                ? CodeBlock.of("$T.this.module", generatedTypeName)
+                ? "module"
                 : CodeBlock.of("$T", ClassName.get(binding.bindingTypeElement().get())),
             binding.bindingElement().get().getSimpleName(),
             makeParametersCodeBlock(parameterCodeBlocks));
diff --git a/java/dagger/internal/codegen/ProducesMethodValidator.java b/java/dagger/internal/codegen/ProducesMethodValidator.java
index a49336fd1..2245dff30 100644
--- a/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -20,11 +20,6 @@
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.EXCEPTION;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_NULLABLE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SCOPE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.Scopes.scopesOf;
 
 import com.google.auto.common.MoreTypes;
@@ -68,20 +63,21 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
   // TODO(beder): Properly handle nullable with producer methods.
   private void checkNullable(ValidationReport.Builder<ExecutableElement> builder) {
     if (ConfigurationAnnotations.getNullableType(builder.getSubject()).isPresent()) {
-      builder.addWarning(PRODUCES_METHOD_NULLABLE);
+      builder.addWarning("@Nullable on @Produces methods does not do anything");
     }
   }
 
   /** Adds an error if a {@link Produces @Produces} method has a scope annotation. */
   private void checkScope(ValidationReport.Builder<ExecutableElement> builder) {
     if (!scopesOf(builder.getSubject()).isEmpty()) {
-      builder.addError(PRODUCES_METHOD_SCOPE);
+      builder.addError("@Produces methods may not have scope annotations");
     }
   }
 
   @Override
   protected String badReturnTypeMessage() {
-    return formatErrorMessage(PRODUCES_METHOD_RETURN_TYPE);
+    return "@Produces methods can return only a primitive, an array, a type variable, "
+        + "a declared type, or a ListenableFuture of one of those types";
   }
 
   /**
@@ -115,7 +111,7 @@ protected void checkSetValuesType(ValidationReport.Builder<ExecutableElement> bu
 
   @Override
   protected String badSetValuesTypeMessage() {
-    return PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+    return "@Produces methods of type set values must return a Set or ListenableFuture of Set";
   }
 
   private static Optional<TypeMirror> unwrapListenableFuture(
@@ -123,7 +119,7 @@ protected String badSetValuesTypeMessage() {
     if (MoreTypes.isType(type) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
       DeclaredType declaredType = MoreTypes.asDeclared(type);
       if (declaredType.getTypeArguments().isEmpty()) {
-        reportBuilder.addError(PRODUCES_METHOD_RAW_FUTURE);
+        reportBuilder.addError("@Produces methods cannot return a raw ListenableFuture");
         return Optional.empty();
       } else {
         return Optional.of((TypeMirror) getOnlyElement(declaredType.getTypeArguments()));
diff --git a/java/dagger/internal/codegen/Scopes.java b/java/dagger/internal/codegen/Scopes.java
index a6376dc34..4bbb06d34 100644
--- a/java/dagger/internal/codegen/Scopes.java
+++ b/java/dagger/internal/codegen/Scopes.java
@@ -68,12 +68,9 @@ private static Scope scope(Elements elements, Class<? extends Annotation> scopeA
    *
    * <p>It's readable source because it has had common package prefixes removed, e.g.
    * {@code @javax.inject.Singleton} is returned as {@code @Singleton}.
-   *
-   * <p>Does not return any annotation values, since {@link javax.inject.Scope @Scope} annotations
-   * are not supposed to have any.
    */
   static String getReadableSource(Scope scope) {
-    return stripCommonTypePrefixes("@" + scope.scopeAnnotationElement().getQualifiedName());
+    return stripCommonTypePrefixes(scope.toString());
   }
 
   /** Returns all of the associated scopes for a source code element. */
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index f37cfc760..9ed3158c2 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -22,12 +22,13 @@
 import static com.google.common.graph.Graphs.reachableNodes;
 import static com.google.common.graph.Graphs.transpose;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
-import static dagger.internal.codegen.DaggerStreams.toImmutableMap;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSetMultimap;
 
 import com.google.auto.value.AutoValue;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.graph.EndpointPair;
 import com.google.common.graph.ImmutableNetwork;
 import com.google.common.graph.Network;
 import dagger.Module;
@@ -122,10 +123,17 @@ public ComponentNode rootComponentNode() {
     return dependencyEdgeStream().collect(toImmutableSet());
   }
 
-  /** Returns the dependency edges for the dependencies of a binding. */
-  public ImmutableMap<DependencyRequest, DependencyEdge> dependencyEdges(BindingNode bindingNode) {
+  /**
+   * Returns the dependency edges for the dependencies of a binding. For valid graphs, each {@link
+   * DependencyRequest} will map to a single {@link DependencyEdge}. When conflicting bindings exist
+   * for a key, the multimap will have several edges for that {@link DependencyRequest}. Graphs that
+   * have no binding for a key will have an edge whose {@linkplain EndpointPair#target() target
+   * node} is a {@link MissingBindingNode}.
+   */
+  public ImmutableSetMultimap<DependencyRequest, DependencyEdge> dependencyEdges(
+      BindingNode bindingNode) {
     return dependencyEdgeStream(bindingNode)
-        .collect(toImmutableMap(DependencyEdge::dependencyRequest, edge -> edge));
+        .collect(toImmutableSetMultimap(DependencyEdge::dependencyRequest, edge -> edge));
   }
 
   /** Returns the dependency edges for a dependency request. */
diff --git a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java b/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
index a8567173d..07c07859e 100644
--- a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
+++ b/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
@@ -18,6 +18,7 @@
 
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import com.google.common.collect.ImmutableList;
 import dagger.Module;
@@ -26,6 +27,7 @@
 import dagger.producers.ProducerModule;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
 import java.util.Collection;
 import javax.inject.Qualifier;
 import org.junit.Ignore;
@@ -132,7 +134,7 @@ public void intoMap_multipleMapKeys() {
     assertThatMethod(
             "@Binds @IntoMap @IntKey(1) @LongKey(2L) abstract Object manyMapKeys(String string);")
         .importing(IntKey.class, LongKey.class)
-        .hasError("may not have more than one @MapKey-marked annotation");
+        .hasError("may not have more than one map key");
   }
 
   private DaggerModuleMethodSubject assertThatMethod(String method) {
@@ -140,8 +142,10 @@ private DaggerModuleMethodSubject assertThatMethod(String method) {
   }
 
   @Qualifier
+  @Retention(RUNTIME)
   public @interface Qualifier1 {}
 
   @Qualifier
+  @Retention(RUNTIME)
   public @interface Qualifier2 {}
 }
diff --git a/javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java b/javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
index bdaea7ec5..00e9bb2cb 100644
--- a/javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
+++ b/javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
@@ -16,10 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
-import com.google.auto.value.processor.AutoAnnotationProcessor;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -43,12 +43,8 @@ public void annotatesSourceRetainedAnnotation() {
             "@CanReleaseReferences",
             "@Retention(RetentionPolicy.SOURCE)",
             "@interface Metadata {}");
-    assertAbout(javaSource())
-        .that(annotation)
-        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-        .failsToCompile()
-        .withErrorContaining("SOURCE")
-        .in(annotation)
-        .onLine(8);
+    Compilation compilation = daggerCompiler().compile(annotation);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("SOURCE").inFile(annotation).onLine(8);
   }
 }
diff --git a/javatests/dagger/internal/codegen/Compilers.java b/javatests/dagger/internal/codegen/Compilers.java
index fed935886..aed1572f8 100644
--- a/javatests/dagger/internal/codegen/Compilers.java
+++ b/javatests/dagger/internal/codegen/Compilers.java
@@ -25,6 +25,7 @@
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compiler;
+import javax.annotation.processing.Processor;
 
 /** {@link Compiler} instances for testing Dagger. */
 final class Compilers {
@@ -39,8 +40,14 @@
               .filter(jar -> !jar.contains(GUAVA))
               .collect(joining(PATH_SEPARATOR.value())));
 
-  /** Returns a compiler that runs the Dagger processor. */
-  static Compiler daggerCompiler() {
-    return javac().withProcessors(new ComponentProcessor(), new AutoAnnotationProcessor());
+  /**
+   * Returns a compiler that runs the Dagger and {@code @AutoAnnotation} processors, along with
+   * extras.
+   */
+  static Compiler daggerCompiler(Processor... extraProcessors) {
+    ImmutableList.Builder<Processor> processors = ImmutableList.builder();
+    processors.add(new ComponentProcessor(), new AutoAnnotationProcessor());
+    processors.add(extraProcessors);
+    return javac().withProcessors(processors.build());
   }
 }
diff --git a/javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java b/javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
index db2702f58..6fbdbd3bd 100644
--- a/javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
@@ -16,8 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -54,16 +56,16 @@ public void singletonSubcomponent() {
             "@Subcomponent",
             "interface Child {}");
 
-    assertThat(component, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("conflicting scopes")
-        .and().withErrorContaining("test.Parent also has @Singleton");
+    Compilation compilation = daggerCompiler().compile(component, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("conflicting scopes");
+    assertThat(compilation).hadErrorContaining("test.Parent also has @Singleton");
 
-    assertThat(component, subcomponent)
-        .withCompilerOptions("-Adagger.disableInterComponentScopeValidation=none")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation withoutScopeValidation =
+        daggerCompiler()
+            .withOptions("-Adagger.disableInterComponentScopeValidation=none")
+            .compile(component, subcomponent);
+    assertThat(withoutScopeValidation).succeeded();
   }
   
   @Test
@@ -117,8 +119,8 @@ public void productionComponents_productionScopeImplicitOnBoth() {
             "class ChildModule {",
             "  @Provides @ProductionScope String childScopedString() { return new String(); }",
             "}");
-    assertThat(component, subcomponent, parentModule, childModule)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation =
+        daggerCompiler().compile(component, subcomponent, parentModule, childModule);
+    assertThat(compilation).succeeded();
   }
 }
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index 851b92bd7..45b14c379 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -18,23 +18,22 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
-import static dagger.internal.codegen.CodeBlocks.stringLiteral;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
 import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_COMPONENT_METHOD;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.testing.compile.Compilation;
-import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
 import dagger.MembersInjector;
 import java.io.IOException;
 import java.io.Writer;
@@ -68,11 +67,6 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
     this.compilerMode = compilerMode;
   }
 
-  private static final CodeBlock NPE_FROM_COMPONENT_METHOD =
-      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-  private static final CodeBlock NPE_FROM_PROVIDES_METHOD =
-      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-
   @Test public void doubleBindingFromResolvedModules() {
     JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
         "package test;",
@@ -2029,7 +2023,7 @@ public void scopeAnnotationOnInjectConstructorNotValid() {
         daggerCompiler().withOptions(compilerMode.javacopts()).compile(aScope, aClass);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("@Scope annotations are not allowed on @Inject constructors.")
+        .hadErrorContaining("@Scope annotations are not allowed on @Inject constructors")
         .inFile(aClass)
         .onLine(6);
   }
@@ -2520,10 +2514,6 @@ public void componentMethodInChildCallsComponentMethodInParent() {
         .containsElementsIn(expectedPattern);
   }
 
-  private static Compiler daggerCompiler(Processor... extraProcessors) {
-    return javac().withProcessors(Lists.asList(new ComponentProcessor(), extraProcessors));
-  }
-
   /**
    * A {@link ComponentProcessor} that excludes elements using a {@link Predicate}.
    */
diff --git a/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java b/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java
index 4684db56e..18107c97a 100644
--- a/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java
+++ b/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java
@@ -17,13 +17,15 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.truth.FailureMetadata;
 import com.google.common.truth.Subject;
 import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import dagger.Module;
 import dagger.producers.ProducerModule;
@@ -143,12 +145,12 @@ DaggerModuleMethodSubject withAdditionalSources(JavaFileObject... sources) {
   void hasError(String errorSubstring) {
     String source = moduleSource();
     JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule", source);
-    assertAbout(javaSources())
-        .that(FluentIterable.from(additionalSources).append(module))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorSubstring)
-        .in(module)
+    Compilation compilation =
+        daggerCompiler().compile(FluentIterable.from(additionalSources).append(module));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(errorSubstring)
+        .inFile(module)
         .onLine(methodLine(source));
   }
 
diff --git a/javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java b/javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
index 05f849f21..8a529e91c 100644
--- a/javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
+++ b/javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
@@ -16,10 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
-import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -48,15 +48,14 @@ public void notAScope() {
             "interface Injects {",
             "  @ForReleasableReferences(NotAScope.class) ReleasableReferenceManager manager();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(notAScope, injects))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(notAScope, injects);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "The value of @ForReleasableReferences must be a reference-releasing scope. "
                 + "Did you mean to annotate test.NotAScope with @javax.inject.Scope and "
                 + "@dagger.releasablereferences.CanReleaseReferences?")
-        .in(injects)
+        .inFile(injects)
         .onLine(7)
         .atColumn(3);
   }
@@ -87,15 +86,14 @@ public void notAReferenceReleasingScope() {
             "interface Injects {",
             "  @ForReleasableReferences(TestScope.class) ReleasableReferenceManager manager();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(testScope, injects))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(testScope, injects);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "The value of @ForReleasableReferences must be a reference-releasing scope. "
                 + "Did you mean to annotate test.TestScope with "
                 + "@dagger.releasablereferences.CanReleaseReferences?")
-        .in(injects)
+        .inFile(injects)
         .onLine(7)
         .atColumn(3);
   }
diff --git a/javatests/dagger/internal/codegen/GeneratedLines.java b/javatests/dagger/internal/codegen/GeneratedLines.java
index 1b56c3a87..2d79e4a47 100644
--- a/javatests/dagger/internal/codegen/GeneratedLines.java
+++ b/javatests/dagger/internal/codegen/GeneratedLines.java
@@ -44,9 +44,8 @@ private static boolean isBeforeJava9() {
   }
 
   public static final CodeBlock NPE_FROM_PROVIDES_METHOD =
-      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+      stringLiteral("Cannot return null from a non-@Nullable @Provides method");
 
   public static final CodeBlock NPE_FROM_COMPONENT_METHOD =
-      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-
+      stringLiteral("Cannot return null from a non-@Nullable component method");
 }
diff --git a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
index 1bdea110a..c11d04fbc 100644
--- a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -16,11 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static java.util.Arrays.asList;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -67,11 +66,9 @@
         "test.MyComponent (unscoped) may not reference scoped bindings:\n"
             + "      @Singleton class test.ScopedType\n"
             + "      @Provides @Singleton String test.ScopedModule.string()";
-    assertAbout(javaSources())
-        .that(asList(componentFile, typeFile, moduleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+    Compilation compilation = daggerCompiler().compile(componentFile, typeFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
@@ -93,6 +90,17 @@
         "",
         "@Scope",
         "@interface PerTest {}");
+    JavaFileObject scopeWithAttribute =
+        JavaFileObjects.forSourceLines(
+            "test.Per",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface Per {",
+            "  Class<?> value();",
+            "}");
     JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
         "package test;",
         "",
@@ -100,7 +108,7 @@
         "",
         "@PerTest", // incompatible scope
         "class ScopedType {",
-        "  @Inject ScopedType(String s, long l, float f) {}",
+        "  @Inject ScopedType(String s, long l, float f, boolean b) {}",
         "}");
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
         "package test;",
@@ -114,17 +122,19 @@
         "  @Provides @PerTest String string() { return \"a string\"; }", // incompatible scope
         "  @Provides long integer() { return 0L; }", // unscoped - valid
         "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
+        "  @Provides @Per(MyComponent.class) boolean bool() { return false; }", // incompatible
         "}");
     String errorMessage =
         "test.MyComponent scoped with @Singleton "
             + "may not reference bindings with different scopes:\n"
             + "      @test.PerTest class test.ScopedType\n"
-            + "      @Provides @test.PerTest String test.ScopedModule.string()";
-    assertAbout(javaSources())
-        .that(asList(componentFile, scopeFile, typeFile, moduleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+            + "      @Provides @test.PerTest String test.ScopedModule.string()\n"
+            + "      @Provides @test.Per(test.MyComponent.class) boolean test.ScopedModule.bool()";
+    Compilation compilation =
+        daggerCompiler()
+            .compile(componentFile, scopeFile, scopeWithAttribute, typeFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test public void componentWithScopeMayDependOnOnlyOneScopedComponent() {
@@ -191,12 +201,12 @@
         "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped component:\n"
         + "      @Singleton test.SingletonComponentA\n"
         + "      @Singleton test.SingletonComponentB";
-    assertAbout(javaSources())
-        .that(
-            asList(type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test public void componentWithoutScopeCannotDependOnScopedComponent() {
@@ -232,11 +242,9 @@
     String errorMessage =
         "test.UnscopedComponent (unscoped) cannot depend on scoped components:\n"
         + "      @Singleton test.ScopedComponent";
-    assertAbout(javaSources())
-        .that(asList(type, scopedComponent, unscopedComponent))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+    Compilation compilation = daggerCompiler().compile(type, scopedComponent, unscopedComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test public void componentWithSingletonScopeMayNotDependOnOtherScope() {
@@ -279,11 +287,10 @@
     String errorMessage =
         "This @Singleton component cannot depend on scoped components:\n"
         + "      @test.SimpleScope test.SimpleScopedComponent";
-    assertAbout(javaSources())
-        .that(asList(type, simpleScope, simpleScoped, singletonScoped))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+    Compilation compilation =
+        daggerCompiler().compile(type, simpleScope, simpleScoped, singletonScoped);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test public void componentScopeAncestryMustNotCycle() {
@@ -345,11 +352,10 @@
         + "      @test.ScopeA test.ComponentLong\n"
         + "      @test.ScopeB test.ComponentMedium\n"
         + "      @test.ScopeA test.ComponentShort";
-    assertAbout(javaSources())
-        .that(asList(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+    Compilation compilation =
+        daggerCompiler().compile(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test
@@ -365,12 +371,11 @@ public void reusableNotAllowedOnComponent() {
             "@Reusable",
             "@Component",
             "interface SomeComponent {}");
-    assertAbout(javaSource())
-        .that(someComponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Reusable cannot be applied to components or subcomponents.")
-        .in(someComponent)
+    Compilation compilation = daggerCompiler().compile(someComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents")
+        .inFile(someComponent)
         .onLine(6);
   }
 
@@ -387,12 +392,11 @@ public void reusableNotAllowedOnSubcomponent() {
             "@Reusable",
             "@Subcomponent",
             "interface SomeSubcomponent {}");
-    assertAbout(javaSource())
-        .that(someSubcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Reusable cannot be applied to components or subcomponents.")
-        .in(someSubcomponent)
+    Compilation compilation = daggerCompiler().compile(someSubcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents")
+        .inFile(someSubcomponent)
         .onLine(6);
   }
 }
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index 1d0d0c110..a36fd23d4 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -16,19 +16,14 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static com.google.testing.compile.Compiler.javac;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.NonNullableRequestForNullableBindingValidation.nullableToNonNullable;
 
 import com.google.common.base.Joiner;
-import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
-import java.util.Arrays;
 import javax.tools.JavaFileObject;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -68,11 +63,12 @@
         "import javax.inject.Inject;",
         "",
         "interface Bar {}");
-    assertAbout(javaSources()).that(Arrays.asList(component, injectable, nonInjectable))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
-            .in(component).onLine(7);
+    Compilation compilation = daggerCompiler().compile(component, injectable, nonInjectable);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
+        .inFile(component)
+        .onLine(7);
   }
 
   @Test public void componentProvisionWithNoDependencyChain() {
@@ -94,19 +90,18 @@
             "    @Q A qualifiedA();",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.TestClass.A cannot be provided without an @Provides-annotated method.")
-        .in(component)
-        .onLine(12)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(12);
+    assertThat(compilation)
+        .hadErrorContaining(
             "@test.TestClass.Q test.TestClass.A "
                 + "cannot be provided without an @Provides-annotated method.")
-        .in(component)
+        .inFile(component)
         .onLine(13);
   }
 
@@ -132,10 +127,9 @@
     String expectedError =
         "test.TestClass.A cannot be provided without an @Inject constructor or an "
             + "@Provides-annotated method.";
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(15);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(15);
   }
 
   @Test public void membersInjectWithoutProvision() {
@@ -165,10 +159,9 @@
         "test.TestClass.B cannot be provided without an @Inject constructor or an "
             + "@Provides-annotated method. This type supports members injection but cannot be "
             + "implicitly provided.";
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(19);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(19);
   }
 
   @Test
@@ -196,11 +189,10 @@ public void membersInjectDependsOnUnboundedType() {
             "interface TestComponent {",
             "  void injectsUnboundedType(InjectsUnboundedType injects);",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(injectsUnboundedType, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(injectsUnboundedType, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             Joiner.on('\n')
                 .join(
                     "Cannot inject members into types with unbounded type arguments: "
@@ -209,7 +201,7 @@ public void membersInjectDependsOnUnboundedType() {
                     "          test.InjectsUnboundedType.listInjector",
                     "      test.InjectsUnboundedType is injected at",
                     "          test.TestComponent.injectsUnboundedType(test.InjectsUnboundedType)"))
-        .in(component)
+        .inFile(component)
         .onLine(7);
   }
 
@@ -322,13 +314,9 @@ public void staticFieldInjection() {
             "interface TestComponent {",
             "  void inject(Injected injected);",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(injected, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("static fields")
-        .in(injected)
-        .onLine(6);
+    Compilation compilation = daggerCompiler().compile(injected, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("static fields").inFile(injected).onLine(6);
   }
 
   @Test public void cyclicDependency() {
@@ -372,10 +360,9 @@ public void staticFieldInjection() {
                 "      test.Outer.C is provided at",
                 "          test.Outer.CComponent.getC()");
 
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(23);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(23);
   }
 
   @Test public void cyclicDependencyNotIncludingEntryPoint() {
@@ -427,13 +414,9 @@ public void staticFieldInjection() {
                 "      test.Outer.D is provided at",
                 "          test.Outer.DComponent.getD()");
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(27);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(27);
   }
 
   @Test
@@ -499,13 +482,9 @@ public void cyclicDependencyNotBrokenByMapBinding() {
                 "      test.Outer.C is provided at",
                 "          test.Outer.CComponent.getC()");
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(26);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(26);
   }
 
   @Test
@@ -564,13 +543,9 @@ public void cyclicDependencyWithSetBinding() {
                 "      test.Outer.C is provided at",
                 "          test.Outer.CComponent.getC()");
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(25);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(25);
   }
 
   @Test
@@ -624,13 +599,9 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
                 "      test.Outer.D is provided at",
                 "          test.Outer.DComponent.getD()");
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(28);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(28);
   }
 
   @Test
@@ -708,13 +679,10 @@ public void cyclicDependencyInSubcomponents() {
                 "      java.lang.String is provided at",
                 "          test.Grandchild.entry()");
 
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, child, grandchild, childModule, grandchildModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(child)
-        .onLine(6);
+    Compilation compilation =
+        daggerCompiler().compile(parent, child, grandchild, childModule, grandchildModule);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(child).onLine(6);
   }
 
   @Test
@@ -753,10 +721,10 @@ public void circularBindsMethods() {
             "  @SomeQualifier Object qualified();",
             "}");
 
-    assertThat(qualifier, module, component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(qualifier, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "Found a dependency cycle:\n"
                 + "      java.lang.Object is injected at\n"
                 + "          test.TestModule.bindQualified(unqualified)\n"
@@ -764,10 +732,12 @@ public void circularBindsMethods() {
                 + "          test.TestModule.bindUnqualified(qualified)\n"
                 + "      java.lang.Object is provided at\n"
                 + "          test.TestComponent.unqualified()")
-        .in(component)
-        .onLine(7)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(7);
+    assertThat(compilation)
+        .hadErrorContaining(
+            // TODO(gak): cl/126230644 produces a better error message in this case. Here it isn't
+            // unclear what is going wrong.
             "Found a dependency cycle:\n"
                 + "      @test.SomeQualifier java.lang.Object is injected at\n"
                 + "          test.TestModule.bindUnqualified(qualified)\n"
@@ -775,7 +745,7 @@ public void circularBindsMethods() {
                 + "          test.TestModule.bindQualified(unqualified)\n"
                 + "      @test.SomeQualifier java.lang.Object is provided at\n"
                 + "          test.TestComponent.qualified()")
-        .in(component)
+        .inFile(component)
         .onLine(8);
   }
 
@@ -805,18 +775,16 @@ public void selfReferentialBinds() {
             "  Object selfReferential();",
             "}");
 
-    assertThat(module, component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            // TODO(gak): cl/126230644 produces a better error message in this case. Here it isn't
-            // unclear what is going wrong.
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "Found a dependency cycle:\n"
                 + "      java.lang.Object is injected at\n"
                 + "          test.TestModule.bindToSelf(sameKey)\n"
                 + "      java.lang.Object is provided at\n"
                 + "          test.TestComponent.selfReferential()")
-        .in(component)
+        .inFile(component)
         .onLine(7);
   }
 
@@ -949,10 +917,9 @@ public void missingBindingWithSameKeyAsMembersInjectionMethod() {
             "@Provides test.Outer.A test.Outer.AModule.provideA(String)",
             "test.Outer.A test.Outer.Parent.getA()");
 
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(30);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(30);
   }
 
   @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
@@ -988,10 +955,9 @@ public void missingBindingWithSameKeyAsMembersInjectionMethod() {
         + "      @Provides test.Outer.A test.Outer.Module1.provideA1()\n"
         + "      @Provides test.Outer.A test.Outer.Module2.provideA2(String)";
 
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(24);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(24);
   }
 
   @Test
@@ -1030,17 +996,16 @@ public void duplicateExplicitBindings_ProvidesVsBinds() {
             "  }",
             "}");
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             Joiner.on("\n      ")
                 .join(
                     "test.Outer.A is bound multiple times:",
                     "@Provides test.Outer.A test.Outer.Module1.provideA1()",
                     "@Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
-        .in(component)
+        .inFile(component)
         .onLine(28);
   }
 
@@ -1127,17 +1092,10 @@ public void duplicateExplicitBindings_ProvidesVsBinds() {
             "Unique bindings and declarations:",
             "    @Provides Map<String,String> test.Outer.TestModule2.stringMap()");
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedSetError)
-        .in(component)
-        .onLine(52)
-        .and()
-        .withErrorContaining(expectedMapError)
-        .in(component)
-        .onLine(53);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedSetError).inFile(component).onLine(52);
+    assertThat(compilation).hadErrorContaining(expectedMapError).inFile(component).onLine(53);
   }
 
   @Test
@@ -1198,17 +1156,10 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             + "      Unique bindings and declarations:\n"
             + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedSetError)
-        .in(component)
-        .onLine(32)
-        .and()
-        .withErrorContaining(expectedMapError)
-        .in(component)
-        .onLine(33);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedSetError).inFile(component).onLine(32);
+    assertThat(compilation).hadErrorContaining(expectedMapError).inFile(component).onLine(33);
   }
 
   @Test public void duplicateBindings_TruncateAfterLimit() {
@@ -1452,11 +1403,11 @@ public void bindsMethodAppearsInTrace() {
             "interface TestModule {",
             "  @Binds abstract TestInterface bindTestInterface(TestImplementation implementation);",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(component, module, interfaceFile, implementationFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().compile(component, module, interfaceFile, implementationFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             Joiner.on("\n      ")
                 .join(
                     "java.lang.String cannot be provided without an @Inject constructor or an "
@@ -1467,7 +1418,7 @@ public void bindsMethodAppearsInTrace() {
                     "    TestModule.bindTestInterface(implementation)",
                     "TestInterface is provided at",
                     "    TestComponent.testInterface()"))
-        .in(component)
+        .inFile(component)
         .onLine(5);
   }
 
@@ -1539,16 +1490,19 @@ public void bindsMissingRightHandSide() {
 
     Compilation compilation = daggerCompiler().compile(duplicates, component);
     assertThat(compilation).failed();
+    // Some javacs report only the first error for each source line.
+    // Assert that one of the expected errors is reported.
     assertThat(compilation)
-        .hadErrorContaining(
-            error(
-                "test.Duplicates.BoundTwice is bound multiple times:",
-                "@Binds test.Duplicates.BoundTwice "
-                    + "test.Duplicates.DuplicatesModule"
-                    + ".bindWithResolvedKey(test.Duplicates.BoundImpl)",
-                "@Binds test.Duplicates.BoundTwice "
-                    + "test.Duplicates.DuplicatesModule"
-                    + ".bindWithUnresolvedKey(test.Duplicates.NotBound)"))
+        .hadErrorContainingMatch(
+            "\\Qtest.Duplicates.NotBound cannot be provided\\E|"
+                + error(
+                    "\\Qtest.Duplicates.BoundTwice is bound multiple times:",
+                    "@Binds test.Duplicates.BoundTwice "
+                        + "test.Duplicates.DuplicatesModule"
+                        + ".bindWithResolvedKey(test.Duplicates.BoundImpl)",
+                    "@Binds test.Duplicates.BoundTwice "
+                        + "test.Duplicates.DuplicatesModule"
+                        + ".bindWithUnresolvedKey(test.Duplicates.NotBound)"))
         .inFile(component)
         .onLineContaining("boundTwice();");
     assertThat(compilation)
@@ -1620,10 +1574,9 @@ public void bindsMissingRightHandSide() {
                 "          test.UsesTest.<init>(genericTestClass)",
                 "      test.UsesTest is provided at",
                 "          test.TestComponent.usesTest()");
-    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedMsg);
+    Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedMsg);
   }
 
   @Test public void resolvedVariablesInDependencyTrace() {
@@ -1675,10 +1628,9 @@ public void bindsMissingRightHandSide() {
                 "          test.UsesTest.<init>(genericTestClass)",
                 "      test.UsesTest is provided at",
                 "          test.TestComponent.usesTest()");
-    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedMsg);
+    Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedMsg);
   }
 
   @Test public void nullCheckForConstructorParameters() {
@@ -1709,19 +1661,21 @@ public void bindsMissingRightHandSide() {
         "interface TestComponent {",
         "  A a();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             nullableToNonNullable(
                 "java.lang.String",
                 "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, a, module, component);
+    assertThat(compilation2).succeeded();
   }
 
   @Test public void nullCheckForMembersInjectParam() {
@@ -1753,19 +1707,21 @@ public void bindsMissingRightHandSide() {
         "interface TestComponent {",
         "  A a();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             nullableToNonNullable(
                 "java.lang.String",
                 "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, a, module, component);
+    assertThat(compilation2).succeeded();
   }
 
   @Test public void nullCheckForVariable() {
@@ -1797,19 +1753,21 @@ public void bindsMissingRightHandSide() {
         "interface TestComponent {",
         "  A a();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             nullableToNonNullable(
                 "java.lang.String",
                 "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, a, module, component);
+    assertThat(compilation2).succeeded();
   }
 
   @Test public void nullCheckForComponentReturn() {
@@ -1832,19 +1790,21 @@ public void bindsMissingRightHandSide() {
         "interface TestComponent {",
         "  String string();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(NULLABLE, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             nullableToNonNullable(
                 "java.lang.String",
                 "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, module, component);
+    assertThat(compilation2).succeeded();
   }
 
   @Test
@@ -1885,11 +1845,10 @@ public void nullCheckForOptionalInstance() {
             "interface TestComponent {",
             "  A a();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             nullableToNonNullable(
                 "java.lang.String",
                 "@test.Nullable @Provides String test.TestModule.provideString()"));
@@ -1934,10 +1893,8 @@ public void nullCheckForOptionalProvider() {
             "interface TestComponent {",
             "  A a();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).succeeded();
   }
 
   @Test
@@ -1979,10 +1936,8 @@ public void nullCheckForOptionalLazy() {
             "interface TestComponent {",
             "  A a();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).succeeded();
   }
 
   @Test
@@ -2025,10 +1980,8 @@ public void nullCheckForOptionalProviderOfLazy() {
             "interface TestComponent {",
             "  A a();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).succeeded();
   }
 
   @Test public void componentDependencyMustNotCycle_Direct() {
@@ -2043,11 +1996,9 @@ public void nullCheckForOptionalProviderOfLazy() {
     String errorMessage =
         "test.ComponentShort contains a cycle in its component dependencies:\n"
             + "      test.ComponentShort";
-    assertAbout(javaSource())
-        .that(shortLifetime)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+    Compilation compilation = daggerCompiler().compile(shortLifetime);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test public void componentDependencyMustNotCycle_Indirect() {
@@ -2091,15 +2042,11 @@ public void nullCheckForOptionalProviderOfLazy() {
             + "      test.ComponentLong\n"
             + "      test.ComponentMedium\n"
             + "      test.ComponentShort";
-    assertAbout(javaSources())
-        .that(ImmutableList.of(longLifetime, mediumLifetime, shortLifetime))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(longErrorMessage).in(longLifetime)
-        .and()
-        .withErrorContaining(mediumErrorMessage).in(mediumLifetime)
-        .and()
-        .withErrorContaining(shortErrorMessage).in(shortLifetime);
+    Compilation compilation = daggerCompiler().compile(longLifetime, mediumLifetime, shortLifetime);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(longErrorMessage).inFile(longLifetime);
+    assertThat(compilation).hadErrorContaining(mediumErrorMessage).inFile(mediumLifetime);
+    assertThat(compilation).hadErrorContaining(shortErrorMessage).inFile(shortLifetime);
   }
 
   @Test
@@ -2335,19 +2282,21 @@ public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning()
             "    }",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parentConflictsWithChild, child))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(parentConflictsWithChild, child);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             error(
                 "[test.Child.parentChildConflictThatViolatesNullability()] "
                     + "java.lang.Object is bound multiple times:",
                 "@Provides Object test.Child.ChildModule.nonNullableParentChildConflict()",
                 "@Provides @javax.annotation.Nullable Object"
                     + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()"))
-        .in(parentConflictsWithChild)
+        .inFile(parentConflictsWithChild)
         .onLine(9);
   }
 
@@ -2396,12 +2345,11 @@ public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
             "    return \"child string\";",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, parentModule, child, childModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("[Child.needsString()] java.lang.String cannot be provided")
-        .in(parent)
+    Compilation compilation = daggerCompiler().compile(parent, parentModule, child, childModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("[Child.needsString()] java.lang.String cannot be provided")
+        .inFile(parent)
         .onLine(4);
   }
 
@@ -2470,12 +2418,12 @@ public void multibindingContributionBetweenAncestorComponentAndEntrypointCompone
             "    return \"\" + i;",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, parentModule, child, childModule, grandchild))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("[Grandchild.object()] java.lang.Double cannot be provided")
-        .in(parent)
+    Compilation compilation =
+        daggerCompiler().compile(parent, parentModule, child, childModule, grandchild);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("[Grandchild.object()] java.lang.Double cannot be provided")
+        .inFile(parent)
         .onLine(4);
   }
 
@@ -2565,13 +2513,12 @@ public void missingReleasableReferenceManager() {
             "  @ForReleasableReferences(TestScope.class)",
             "  TypedReleasableReferenceManager<BadMetadata> badManager();",
             "}");
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
-                testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .compile(testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "There is no binding for "
                 + "@dagger.releasablereferences.ForReleasableReferences(test.OtherScope.class) "
                 + "dagger.releasablereferences.ReleasableReferenceManager "
@@ -2579,24 +2526,24 @@ public void missingReleasableReferenceManager() {
                 + "with @test.OtherScope. "
                 + "The available reference-releasing scopes are "
                 + "[@test.TestScope, @test.YetAnotherScope].")
-        .in(component)
-        .onLine(13)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(13);
+    assertThat(compilation)
+        .hadErrorContaining(
             "There is no binding for "
                 + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
                 + "dagger.releasablereferences.TypedReleasableReferenceManager<test.TestMetadata> "
                 + "because test.TestScope is not annotated with @test.TestMetadata")
-        .in(component)
-        .onLine(16)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(16);
+    assertThat(compilation)
+        .hadErrorContaining(
             "There is no binding for "
                 + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
                 + "dagger.releasablereferences.TypedReleasableReferenceManager<test.BadMetadata> "
                 + "because test.BadMetadata is not annotated with "
                 + "@dagger.releasablereferences.CanReleaseReferences")
-        .in(component)
+        .inFile(component)
         .onLine(19);
   }
 
@@ -2686,11 +2633,11 @@ public void releasableReferenceManagerConflict() {
             "  Set<ReleasableReferenceManager> managers();",
             "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(testScope, testMetadata, testModule, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().compile(testScope, testMetadata, testModule, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 error(
                     "@%1$s.ForReleasableReferences(test.TestScope.class) "
@@ -2701,10 +2648,10 @@ public void releasableReferenceManagerConflict() {
                         + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
                         + "%1$s.ReleasableReferenceManager from the scope declaration"),
                 "dagger.releasablereferences"))
-        .in(component)
-        .onLine(13)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(13);
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 error(
                     "@%1$s.ForReleasableReferences(test.TestScope.class) "
@@ -2718,10 +2665,10 @@ public void releasableReferenceManagerConflict() {
                         + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
                         + "from the scope declaration"),
                 "dagger.releasablereferences"))
-        .in(component)
-        .onLine(16)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(16);
+    assertThat(compilation)
+        .hadErrorContaining(
             error(
                 "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
                     + "is bound multiple times:",
@@ -2730,10 +2677,10 @@ public void releasableReferenceManagerConflict() {
                     + "test.TestModule.rrmSet()",
                 "Dagger-generated binding for "
                     + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
-        .in(component)
-        .onLine(18)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(18);
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 error(
                     "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
@@ -2744,7 +2691,7 @@ public void releasableReferenceManagerConflict() {
                     "Dagger-generated binding for "
                         + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
                 "dagger.releasablereferences"))
-        .in(component)
+        .inFile(component)
         .onLine(19);
   }
 
diff --git a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index f8baa6059..21de94a06 100644
--- a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -17,28 +17,15 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.CHECKED_EXCEPTIONS_ON_CONSTRUCTORS;
-import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
-import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -86,10 +73,12 @@
         "class PrivateConstructor {",
         "  @Inject private PrivateConstructor() {}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_ON_PRIVATE_CONSTRUCTOR).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into private constructors")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void injectConstructorOnInnerClass() {
@@ -103,10 +92,14 @@
         "    @Inject InnerClass() {}",
         "  }",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_CONSTRUCTOR_ON_INNER_CLASS).in(file).onLine(7);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@Inject constructors are invalid on inner classes. "
+                + "Did you mean to make the class static?")
+        .inFile(file)
+        .onLine(7);
   }
 
   @Test public void injectConstructorOnAbstractClass() {
@@ -118,10 +111,12 @@
         "abstract class AbstractClass {",
         "  @Inject AbstractClass() {}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Inject is nonsense on the constructor of an abstract class")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void injectConstructorOnGenericClass() {
@@ -544,11 +539,16 @@
         "  TooManyInjectConstructors(int i) {}",
         "  @Inject TooManyInjectConstructors(String s) {}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(6)
-        .and().withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(8);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Types may only contain one @Inject constructor")
+        .inFile(file)
+        .onLine(6);
+    assertThat(compilation)
+        .hadErrorContaining("Types may only contain one @Inject constructor")
+        .inFile(file)
+        .onLine(8);
   }
 
   @Test public void multipleQualifiersOnInjectConstructorParameter() {
@@ -560,10 +560,13 @@
         "class MultipleQualifierConstructorParam {",
         "  @Inject MultipleQualifierConstructorParam(@QualifierA @QualifierB String s) {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ComponentProcessor()).failsToCompile()
-        // for whatever reason, javac only reports the error once on the constructor
-        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    // for whatever reason, javac only reports the error once on the constructor
+    assertThat(compilation)
+        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void injectConstructorOnClassWithMultipleScopes() {
@@ -575,10 +578,18 @@
         "@ScopeA @ScopeB class MultipleScopeClass {",
         "  @Inject MultipleScopeClass() {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file, SCOPE_A, SCOPE_B))
-        .processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(1)
-        .and().withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(9);
+    Compilation compilation = daggerCompiler().compile(file, SCOPE_A, SCOPE_B);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("A single binding may not declare more than one @Scope")
+        .inFile(file)
+        .onLine(5)
+        .atColumn(1);
+    assertThat(compilation)
+        .hadErrorContaining("A single binding may not declare more than one @Scope")
+        .inFile(file)
+        .onLine(5)
+        .atColumn(9);
   }
 
   @Test public void injectConstructorWithQualifier() {
@@ -593,10 +604,16 @@
         "  @QualifierB",
         "  MultipleScopeClass() {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(7)
-        .and().withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(8);
+    Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Qualifier annotations are not allowed on @Inject constructors")
+        .inFile(file)
+        .onLine(7);
+    assertThat(compilation)
+        .hadErrorContaining("@Qualifier annotations are not allowed on @Inject constructors")
+        .inFile(file)
+        .onLine(8);
   }
 
   @Test public void injectConstructorWithCheckedExceptionsError() {
@@ -608,9 +625,12 @@
         "class CheckedExceptionClass {",
         "  @Inject CheckedExceptionClass() throws Exception {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file))
-        .processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support checked exceptions on @Inject constructors")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void injectConstructorWithCheckedExceptionsWarning() {
@@ -622,11 +642,13 @@
         "class CheckedExceptionClass {",
         "  @Inject CheckedExceptionClass() throws Exception {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file))
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .withWarningContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS).in(file).onLine(6);
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.privateMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining("Dagger does not support checked exceptions on @Inject constructors")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void privateInjectClassError() {
@@ -640,11 +662,12 @@
         "    @Inject InnerClass() {}",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(file))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(7);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into private classes")
+        .inFile(file)
+        .onLine(7);
   }
 
   @Test public void privateInjectClassWarning() {
@@ -658,12 +681,13 @@
         "    @Inject InnerClass() {}",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(file))
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(7);
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.privateMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining("Dagger does not support injection into private classes")
+        .inFile(file)
+        .onLine(7);
   }
 
   @Test public void nestedInPrivateInjectClassError() {
@@ -679,11 +703,12 @@
         "    }",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(file))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(8);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into private classes")
+        .inFile(file)
+        .onLine(8);
   }
 
   @Test public void nestedInPrivateInjectClassWarning() {
@@ -699,12 +724,13 @@
         "    }",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(file))
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(8);
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.privateMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining("Dagger does not support injection into private classes")
+        .inFile(file)
+        .onLine(8);
   }
 
   @Test public void finalInjectField() {
@@ -716,10 +742,12 @@
         "class FinalInjectField {",
         "  @Inject final String s;",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(FINAL_INJECT_FIELD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Inject fields may not be final")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void privateInjectFieldError() {
@@ -731,10 +759,12 @@
         "class PrivateInjectField {",
         "  @Inject private String s;",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into private fields")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void privateInjectFieldWarning() {
@@ -746,10 +776,9 @@
         "class PrivateInjectField {",
         "  @Inject private String s;",
         "}");
-    assertAbout(javaSource()).that(file)
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError(); // TODO: Verify warning message when supported
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.privateMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded(); // TODO: Verify warning message when supported
   }
 
   @Test public void staticInjectFieldError() {
@@ -761,10 +790,12 @@
         "class StaticInjectField {",
         "  @Inject static String s;",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(STATIC_INJECT_FIELD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into static fields")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void staticInjectFieldWarning() {
@@ -776,10 +807,9 @@
         "class StaticInjectField {",
         "  @Inject static String s;",
         "}");
-    assertAbout(javaSource()).that(file)
-        .withCompilerOptions("-Adagger.staticMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError(); // TODO: Verify warning message when supported
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.staticMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded(); // TODO: Verify warning message when supported
   }
 
   @Test public void multipleQualifiersOnField() {
@@ -791,10 +821,18 @@
         "class MultipleQualifierInjectField {",
         "  @Inject @QualifierA @QualifierB String s;",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(11)
-        .and().withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(23);
+    Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .inFile(file)
+        .onLine(6)
+        .atColumn(11);
+    assertThat(compilation)
+        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .inFile(file)
+        .onLine(6)
+        .atColumn(23);
   }
 
   @Test public void abstractInjectMethod() {
@@ -806,10 +844,12 @@
         "abstract class AbstractInjectMethod {",
         "  @Inject abstract void method();",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(ABSTRACT_INJECT_METHOD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Methods with @Inject may not be abstract")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void privateInjectMethodError() {
@@ -821,10 +861,12 @@
         "class PrivateInjectMethod {",
         "  @Inject private void method(){}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRIVATE_INJECT_METHOD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into private methods")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void privateInjectMethodWarning() {
@@ -836,10 +878,9 @@
         "class PrivateInjectMethod {",
         "  @Inject private void method(){}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError(); // TODO: Verify warning message when supported
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.privateMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded(); // TODO: Verify warning message when supported
   }
 
   @Test public void staticInjectMethodError() {
@@ -851,10 +892,12 @@
         "class StaticInjectMethod {",
         "  @Inject static void method(){}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(STATIC_INJECT_METHOD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into static methods")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void staticInjectMethodWarning() {
@@ -866,10 +909,9 @@
         "class StaticInjectMethod {",
         "  @Inject static void method(){}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .withCompilerOptions("-Adagger.staticMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError(); // TODO: Verify warning message when supported
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.staticMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded(); // TODO: Verify warning message when supported
   }
 
   @Test public void genericInjectMethod() {
@@ -881,10 +923,12 @@
         "class AbstractInjectMethod {",
         "  @Inject <T> void method();",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(GENERIC_INJECT_METHOD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Methods with @Inject may not declare type parameters")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void multipleQualifiersOnInjectMethodParameter() {
@@ -896,11 +940,12 @@
         "class MultipleQualifierMethodParam {",
         "  @Inject void method(@QualifierA @QualifierB String s) {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        // for whatever reason, javac only reports the error once on the method
-        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void injectConstructorDependsOnProduced() {
@@ -913,10 +958,10 @@
         "final class A {",
         "  @Inject A(Produced<String> str) {}",
         "}");
-    assertAbout(javaSource()).that(aFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Produced may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(aFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Produced may only be injected in @Produces methods");
   }
 
   @Test public void injectConstructorDependsOnProducer() {
@@ -929,10 +974,10 @@
         "final class A {",
         "  @Inject A(Producer<String> str) {}",
         "}");
-    assertAbout(javaSource()).that(aFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Producer may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(aFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Producer may only be injected in @Produces methods");
   }
 
   @Test public void injectFieldDependsOnProduced() {
@@ -945,10 +990,10 @@
         "final class A {",
         "  @Inject Produced<String> str;",
         "}");
-    assertAbout(javaSource()).that(aFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Produced may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(aFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Produced may only be injected in @Produces methods");
   }
 
   @Test public void injectFieldDependsOnProducer() {
@@ -961,10 +1006,10 @@
         "final class A {",
         "  @Inject Producer<String> str;",
         "}");
-    assertAbout(javaSource()).that(aFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Producer may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(aFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Producer may only be injected in @Produces methods");
   }
 
   @Test public void injectMethodDependsOnProduced() {
@@ -977,10 +1022,10 @@
         "final class A {",
         "  @Inject void inject(Produced<String> str) {}",
         "}");
-    assertAbout(javaSource()).that(aFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Produced may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(aFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Produced may only be injected in @Produces methods");
   }
 
   @Test public void injectMethodDependsOnProducer() {
@@ -993,10 +1038,10 @@
         "final class A {",
         "  @Inject void inject(Producer<String> str) {}",
         "}");
-    assertAbout(javaSource()).that(aFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Producer may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(aFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Producer may only be injected in @Produces methods");
   }
 
   @Test public void injectConstructor() {
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 77baa5de9..0f8d95789 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -16,13 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
-import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Collection;
@@ -1127,18 +1124,13 @@ public void mapBindingsWithDuplicateKeys() {
             "interface TestComponent {",
             "  Map<String, Object> objects();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(module, componentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("The same map key is bound more than once")
-        .and()
-        .withErrorContaining("provideObjectForAKey()")
-        .and()
-        .withErrorContaining("provideObjectForAKeyAgain()")
-        .and()
-        .withErrorCount(1);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(module, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("The same map key is bound more than once");
+    assertThat(compilation).hadErrorContaining("provideObjectForAKey()");
+    assertThat(compilation).hadErrorContaining("provideObjectForAKeyAgain()");
+    assertThat(compilation).hadErrorCount(1);
   }
 
   @Test
@@ -1186,17 +1178,14 @@ public void mapBindingsWithInconsistentKeyAnnotations() {
             "interface TestComponent {",
             "  Map<String, Object> objects();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(module, stringKeyTwoFile, componentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("uses more than one @MapKey annotation type")
-        .and()
-        .withErrorContaining("provideObjectForAKey()")
-        .and()
-        .withErrorContaining("provideObjectForBKey()")
-        .and()
-        .withErrorCount(1);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, stringKeyTwoFile, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("uses more than one @MapKey annotation type");
+    assertThat(compilation).hadErrorContaining("provideObjectForAKey()");
+    assertThat(compilation).hadErrorContaining("provideObjectForBKey()");
+    assertThat(compilation).hadErrorCount(1);
   }
 }
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
index 86cab871d..547ad4ea8 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
@@ -26,7 +26,6 @@
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -47,9 +46,6 @@ public MapBindingExpressionTest(CompilerMode compilerMode) {
     this.compilerMode = compilerMode;
   }
 
-  public static final CodeBlock NPE_FROM_PROVIDES =
-      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-
   @Test
   public void mapBindings() {
     JavaFileObject mapModuleFile = JavaFileObjects.forSourceLines("test.MapModule",
diff --git a/javatests/dagger/internal/codegen/MembersInjectionTest.java b/javatests/dagger/internal/codegen/MembersInjectionTest.java
index 160005095..2a7fd2194 100644
--- a/javatests/dagger/internal/codegen/MembersInjectionTest.java
+++ b/javatests/dagger/internal/codegen/MembersInjectionTest.java
@@ -19,12 +19,10 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
 import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 import static javax.tools.StandardLocation.CLASS_OUTPUT;
@@ -853,13 +851,12 @@ public void lowerCaseNamedMembersInjector_forLowerCaseType() {
             "  void inject(foo target);",
             "}");
 
-    assertAbout(javaSources())
-        .that(ImmutableList.of(foo, fooModule, fooComponent))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesFileNamed(CLASS_OUTPUT, "test", "foo_MembersInjector.class");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, fooModule, fooComponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation).generatedFile(CLASS_OUTPUT, "test", "foo_MembersInjector.class");
   }
 
   @Test
@@ -972,13 +969,11 @@ public void fieldInjectionForShadowedMember() {
         "    @Inject int field;",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(file)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS)
-        .in(file)
+    Compilation compilation = daggerCompiler().withOptions(compilerMode.javacopts()).compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into private classes")
+        .inFile(file)
         .onLine(6);
   }
 
@@ -993,14 +988,15 @@ public void fieldInjectionForShadowedMember() {
         "    @Inject int field;",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(file)
-        .withCompilerOptions(
-            compilerMode.javacopts().append("-Adagger.privateMemberValidation=WARNING"))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS)
-        .in(file)
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(
+                compilerMode.javacopts().append("-Adagger.privateMemberValidation=WARNING"))
+            .compile(file);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining("Dagger does not support injection into private classes")
+        .inFile(file)
         .onLine(6);
   }
 
@@ -1017,11 +1013,8 @@ public void fieldInjectionForShadowedMember() {
         "    @Inject int field;",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(file)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation = daggerCompiler().withOptions(compilerMode.javacopts()).compile(file);
+    assertThat(compilation).succeeded();
   }
 
   @Test public void rawFrameworkTypes() {
@@ -1047,16 +1040,15 @@ public void fieldInjectionForShadowedMember() {
             "  void inject(RawProviderField rawProviderField);",
             "  void inject(RawProviderParameter rawProviderParameter);",
             "}");
-    assertThat(file)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("javax.inject.Provider cannot be provided")
-        .in(file)
-        .onLine(17)
-        .and()
-        .withErrorContaining("javax.inject.Provider cannot be provided")
-        .in(file)
+    Compilation compilation = daggerCompiler().withOptions(compilerMode.javacopts()).compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("javax.inject.Provider cannot be provided")
+        .inFile(file)
+        .onLine(17);
+    assertThat(compilation)
+        .hadErrorContaining("javax.inject.Provider cannot be provided")
+        .inFile(file)
         .onLine(18);
   }
 
diff --git a/javatests/dagger/internal/codegen/MissingBindingSuggestionsTest.java b/javatests/dagger/internal/codegen/MissingBindingSuggestionsTest.java
index f63771743..e2f963494 100644
--- a/javatests/dagger/internal/codegen/MissingBindingSuggestionsTest.java
+++ b/javatests/dagger/internal/codegen/MissingBindingSuggestionsTest.java
@@ -16,10 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
-import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -91,12 +91,11 @@ private static JavaFileObject emptyInterface(String interfaceName) {
         "  BarComponent getBar(BarModule barModule);",
         "}");
 
-    assertAbout(javaSources())
-        .that(ImmutableList.of(
-            fooComponent, barComponent, topComponent, foo, bar, barModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("A binding with matching key exists in component: test.BarComponent");
+    Compilation compilation =
+        daggerCompiler().compile(fooComponent, barComponent, topComponent, foo, bar, barModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("A binding with matching key exists in component: test.BarComponent");
   }
 
   @Test public void suggestsBindingInNestedSubcomponent() {
@@ -151,11 +150,11 @@ private static JavaFileObject emptyInterface(String interfaceName) {
         "  BarComponent getBar();",
         "}");
 
-    assertAbout(javaSources())
-        .that(ImmutableList.of(
-            fooComponent, barComponent, bazComponent, topComponent, foo, baz, bazModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("A binding with matching key exists in component: test.BazComponent");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(fooComponent, barComponent, bazComponent, topComponent, foo, baz, bazModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("A binding with matching key exists in component: test.BazComponent");
   }
 }
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 3c0751d4c..3c1931b9e 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -17,31 +17,19 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
-import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.CompileTester;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -54,9 +42,6 @@
       JavaFileObjects.forSourceLines(
           "test.Nullable", "package test;", "public @interface Nullable {}");
 
-  private static final CodeBlock NPE_LITERAL =
-      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-
   // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have
   // for @Inject
 
@@ -70,73 +55,79 @@ private String formatModuleErrorMessage(String msg) {
 
   @Test public void providesMethodNotInModule() {
     assertThatMethodInUnannotatedClass("@Provides String provideString() { return null; }")
-        .hasError(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
+        .hasError(formatModuleErrorMessage("@%s methods can only be present within a @%s"));
   }
 
   @Test public void providesMethodAbstract() {
     assertThatModuleMethod("@Provides abstract String abstractMethod();")
-        .hasError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+        .hasError(formatErrorMessage("@%s methods cannot be abstract"));
   }
 
   @Test public void providesMethodPrivate() {
     assertThatModuleMethod("@Provides private String privateMethod() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_PRIVATE));
+        .hasError(formatErrorMessage("@%s methods cannot be private"));
   }
 
   @Test public void providesMethodReturnVoid() {
     assertThatModuleMethod("@Provides void voidMethod() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+        .hasError(formatErrorMessage("@%s methods must return a value (not void)"));
   }
 
   @Test
   public void providesMethodReturnsProvider() {
     assertThatModuleMethod("@Provides Provider<String> provideProvider() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void providesMethodReturnsLazy() {
     assertThatModuleMethod("@Provides Lazy<String> provideLazy() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void providesMethodReturnsMembersInjector() {
     assertThatModuleMethod("@Provides MembersInjector<String> provideMembersInjector() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void providesMethodReturnsProducer() {
     assertThatModuleMethod("@Provides Producer<String> provideProducer() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void providesMethodReturnsProduced() {
     assertThatModuleMethod("@Provides Produced<String> provideProduced() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test public void providesMethodWithTypeParameter() {
     assertThatModuleMethod("@Provides <T> String typeParameter() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+        .hasError(formatErrorMessage("@%s methods may not have type parameters"));
   }
 
   @Test public void providesMethodSetValuesWildcard() {
     assertThatModuleMethod("@Provides @ElementsIntoSet Set<?> provideWildcard() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_RETURN_TYPE));
+        .hasError(
+            formatErrorMessage(
+                "@%s methods must return a primitive, an array, a type variable, "
+                    + "or a declared type"));
   }
 
   @Test public void providesMethodSetValuesRawSet() {
     assertThatModuleMethod("@Provides @ElementsIntoSet Set provideSomething() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+        .hasError(
+            formatErrorMessage(
+                "@%s methods annotated with @ElementsIntoSet cannot return a raw Set"));
   }
 
   @Test public void providesMethodSetValuesNotASet() {
     assertThatModuleMethod(
             "@Provides @ElementsIntoSet List<String> provideStrings() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RETURN_SET));
+        .hasError(
+            formatErrorMessage("@%s methods annotated with @ElementsIntoSet must return a Set"));
   }
 
   @Test public void modulesWithTypeParamsMustBeAbstract() {
@@ -147,12 +138,11 @@ public void providesMethodReturnsProduced() {
         "",
         "@Module",
         "final class TestModule<A> {}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT)
-        .in(moduleFile)
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Modules with type parameters must be abstract")
+        .inFile(moduleFile)
         .onLine(6);
   }
 
@@ -172,9 +162,8 @@ public void providesMethodReturnsProduced() {
         .withAdditionalSources(parent)
         .hasError(
             String.format(
-                ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD,
-                "Provides",
-                "@Provides String test.Parent.foo()"));
+                "@%s methods may not be overridden in modules. Overrides: %s",
+                "Provides", "@Provides String test.Parent.foo()"));
   }
 
   @Test public void provideOverriddenByProvide() {
@@ -193,9 +182,8 @@ public void providesMethodReturnsProduced() {
         .withAdditionalSources(parent)
         .hasError(
             String.format(
-                ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
-                "Provides",
-                "@Provides String test.Parent.foo()"));
+                "@%s methods may not override another method. Overrides: %s",
+                "Provides", "@Provides String test.Parent.foo()"));
   }
 
   @Test public void providesOverridesNonProvides() {
@@ -213,9 +201,8 @@ public void providesMethodReturnsProduced() {
         .withAdditionalSources(parent)
         .hasError(
             String.format(
-                ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
-                "Provides",
-                "String test.Parent.foo()"));
+                "@%s methods may not override another method. Overrides: %s",
+                "Provides", "String test.Parent.foo()"));
   }
 
   @Test public void validatesIncludedModules() {
@@ -226,13 +213,13 @@ public void providesMethodReturnsProduced() {
         "",
         "@Module(includes = Void.class)",
         "class TestModule {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(module))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(module);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
-                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED, "java.lang.Void", "@Module"));
+                "%s is listed as a module, but is not annotated with %s",
+                "java.lang.Void", "@Module"));
   }
 
   @Test public void singleProvidesMethodNoArgs() {
@@ -278,7 +265,8 @@ public void providesMethodReturnsProduced() {
             "  }",
             "",
             "  public static String proxyProvideString(TestModule instance) {",
-            "    return Preconditions.checkNotNull(instance.provideString(), " + NPE_LITERAL + ");",
+            "    return Preconditions.checkNotNull(",
+            "        instance.provideString(), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     assertAbout(javaSource()).that(moduleFile)
@@ -496,7 +484,7 @@ public void providesMethodReturnsProduced() {
             "  public static List<Object> proxyProvideObjects(",
             "      TestModule instance, Object a, Object b, MembersInjector<X> xInjector) {",
             "    return Preconditions.checkNotNull(",
-            "        instance.provideObjects(a, b, xInjector), " + NPE_LITERAL + ");",
+            "        instance.provideObjects(a, b, xInjector), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     assertAbout(javaSources()).that(
@@ -551,7 +539,9 @@ public void providesMethodReturnsProduced() {
             "  }",
             "",
             "  public static String proxyProvideString(TestModule instance) {",
-            "    return Preconditions.checkNotNull(instance.provideString(), " + NPE_LITERAL + ");",
+            "    return Preconditions.checkNotNull(instance.provideString(), "
+                + NPE_FROM_PROVIDES_METHOD
+                + ");",
             "  }",
             "}");
     assertAbout(javaSource()).that(moduleFile)
@@ -610,7 +600,7 @@ public void providesMethodReturnsProduced() {
             "",
             "  public static List<List<?>> proxyProvideWildcardList(TestModule instance) {",
             "    return Preconditions.checkNotNull(",
-            "        instance.provideWildcardList(), " + NPE_LITERAL + ");",
+            "        instance.provideWildcardList(), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     assertAbout(javaSource()).that(moduleFile)
@@ -666,7 +656,7 @@ public void providesMethodReturnsProduced() {
             "",
             "  public static Set<String> proxyProvideStrings(TestModule instance) {",
             "    return Preconditions.checkNotNull(",
-            "        instance.provideStrings(), " + NPE_LITERAL + ");",
+            "        instance.provideStrings(), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     assertAbout(javaSource()).that(moduleFile)
@@ -692,12 +682,20 @@ public void providesMethodReturnsProduced() {
         "    return \"\";",
         "  }",
         "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-    .withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME)).in(moduleFile).onLine(8)
-        .and().withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME))
-        .in(moduleFile).onLine(12);
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            formatErrorMessage(
+                "Cannot have more than one @%s method with the same name in a single module"))
+        .inFile(moduleFile)
+        .onLine(8);
+    assertThat(compilation)
+        .hadErrorContaining(
+            formatErrorMessage(
+                "Cannot have more than one @%s method with the same name in a single module"))
+        .inFile(moduleFile)
+        .onLine(12);
   }
 
   @Test
@@ -720,16 +718,15 @@ public void providesMethodThrowsChecked() {
             "    return \"\";",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))
-        .in(moduleFile)
-        .onLine(8)
-        .and()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))
-        .in(moduleFile)
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(formatErrorMessage("@%s methods may only throw unchecked exceptions"))
+        .inFile(moduleFile)
+        .onLine(8);
+    assertThat(compilation)
+        .hadErrorContaining(formatErrorMessage("@%s methods may only throw unchecked exceptions"))
+        .inFile(moduleFile)
         .onLine(12);
   }
 
@@ -769,9 +766,8 @@ public void providedTypes() {
         "    return null;",
         "  }",
         "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).succeeded();
   }
 
   @Test
@@ -785,12 +781,12 @@ public void privateModule() {
         "  @Module private static final class PrivateModule {",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Modules cannot be private.")
-        .in(moduleFile).onLine(6);
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Modules cannot be private")
+        .inFile(moduleFile)
+        .onLine(6);
   }
 
   @Test
@@ -806,12 +802,12 @@ public void enclosedInPrivateModule() {
         "    }",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Modules cannot be enclosed in private types.")
-        .in(moduleFile).onLine(7);
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Modules cannot be enclosed in private types")
+        .inFile(moduleFile)
+        .onLine(7);
   }
 
   @Test
@@ -850,16 +846,22 @@ public void publicModuleNonPublicIncludes() {
         "@Module",
         "public final class OtherPublicModule {",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(
-            publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("This module is public, but it includes non-public "
-            + "(or effectively non-public) modules. "
-            + "Either reduce the visibility of this module or make "
-            + "test.NonPublicModule1 and test.NonPublicModule2 public.")
-        .in(publicModuleFile).onLine(8);
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                publicModuleFile,
+                nonPublicModule1File,
+                nonPublicModule2File,
+                otherPublicModuleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "This module is public, but it includes non-public "
+                + "(or effectively non-public) modules. "
+                + "Either reduce the visibility of this module or make "
+                + "test.NonPublicModule1 and test.NonPublicModule2 public.")
+        .inFile(publicModuleFile)
+        .onLine(8);
   }
 
   @Test
@@ -967,7 +969,8 @@ public void genericSubclassedModule() {
             "",
             "  public static <A extends CharSequence, B, C extends Number & Comparable<C>> List<B>",
             "      proxyProvideListB(ParentModule<A, B, C> instance, B b) {",
-            "    return Preconditions.checkNotNull(instance.provideListB(b), " + NPE_LITERAL + ");",
+            "    return Preconditions.checkNotNull(",
+            "        instance.provideListB(b), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     JavaFileObject bElementFactory =
@@ -1012,7 +1015,7 @@ public void genericSubclassedModule() {
             "      B proxyProvideBElement(",
             "          ParentModule<A, B, C> instance, B b) {",
             "    return Preconditions.checkNotNull(",
-            "        instance.provideBElement(b), " + NPE_LITERAL + ");",
+            "        instance.provideBElement(b), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     JavaFileObject bEntryFactory =
@@ -1057,7 +1060,7 @@ public void genericSubclassedModule() {
             "      B proxyProvideBEntry(",
             "          ParentModule<A, B, C> instance, B b) {",
             "    return Preconditions.checkNotNull(",
-            "        instance.provideBEntry(b), " + NPE_LITERAL + ");",
+            "        instance.provideBEntry(b), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     JavaFileObject numberFactory =
@@ -1093,7 +1096,8 @@ public void genericSubclassedModule() {
             "  }",
             "",
             "  public static Number proxyProvideNumber(ChildNumberModule instance) {",
-            "    return Preconditions.checkNotNull(instance.provideNumber(), " + NPE_LITERAL + ");",
+            "    return Preconditions.checkNotNull(",
+            "        instance.provideNumber(), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     JavaFileObject integerFactory =
@@ -1130,7 +1134,7 @@ public void genericSubclassedModule() {
             "",
             "  public static Integer proxyProvideInteger(ChildIntegerModule instance) {",
             "    return Preconditions.checkNotNull(",
-            "        instance.provideInteger(), " + NPE_LITERAL + ");",
+            "        instance.provideInteger(), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     assertAbout(javaSources())
@@ -1204,7 +1208,7 @@ public void genericSubclassedModule() {
             "",
             "  public static Map<String, Number> proxyProvideMapStringNumber() {",
             "    return Preconditions.checkNotNull(ParameterizedModule.provideMapStringNumber(),",
-            "        " + NPE_LITERAL + ");",
+            "        " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
 
@@ -1238,7 +1242,7 @@ public void genericSubclassedModule() {
             "",
             "  public static Object proxyProvideNonGenericType() {",
             "    return Preconditions.checkNotNull(ParameterizedModule.provideNonGenericType(),",
-            "        " + NPE_LITERAL + ");",
+            "        " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
 
@@ -1279,7 +1283,7 @@ public void genericSubclassedModule() {
             "  public static String proxyProvideNonGenericTypeWithDeps(Object o) {",
             "    return Preconditions.checkNotNull(",
             "        ParameterizedModule.provideNonGenericTypeWithDeps(o),",
-            "        " + NPE_LITERAL + ");",
+            "        " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
 
@@ -1309,10 +1313,9 @@ public void genericSubclassedModule() {
         "    return \"foo\";",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(BINDING_METHOD_MULTIPLE_QUALIFIERS);
+    Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("Cannot use more than one @Qualifier");
   }
 
   @Test public void providerDependsOnProduced() {
@@ -1329,10 +1332,10 @@ public void genericSubclassedModule() {
         "    return \"foo\";",
         "  }",
         "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Producer may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Producer may only be injected in @Produces methods");
   }
 
   @Test public void providerDependsOnProducer() {
@@ -1349,10 +1352,10 @@ public void genericSubclassedModule() {
         "    return \"foo\";",
         "  }",
         "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Produced may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Produced may only be injected in @Produces methods");
   }
 
   private static final String BINDS_METHOD = "@Binds abstract Foo bindFoo(FooImpl impl);";
@@ -1364,25 +1367,47 @@ public void genericSubclassedModule() {
   private static final String SOME_ABSTRACT_METHOD = "abstract void blah();";
 
   @Test
-  public void moduleMethodPermutations() {
-    assertThatMethodCombination(BINDS_METHOD, INSTANCE_PROVIDES_METHOD)
-        .failsToCompile()
-        .withErrorContaining(
+  public void bindsWithInstanceProvides() {
+    Compilation compilation = compileMethodCombination(BINDS_METHOD, INSTANCE_PROVIDES_METHOD);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "A @Module may not contain both non-static @Provides methods and "
                 + "abstract @Binds or @Multibinds declarations");
-    assertThatMethodCombination(MULTIBINDS_METHOD, INSTANCE_PROVIDES_METHOD)
-        .failsToCompile()
-        .withErrorContaining(
+  }
+
+  @Test
+  public void multibindsWithInstanceProvides() {
+    Compilation compilation = compileMethodCombination(MULTIBINDS_METHOD, INSTANCE_PROVIDES_METHOD);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "A @Module may not contain both non-static @Provides methods and "
                 + "abstract @Binds or @Multibinds declarations");
-    assertThatMethodCombination(BINDS_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
-    assertThatMethodCombination(BINDS_METHOD, MULTIBINDS_METHOD).compilesWithoutError();
-    assertThatMethodCombination(MULTIBINDS_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
-    assertThatMethodCombination(INSTANCE_PROVIDES_METHOD, SOME_ABSTRACT_METHOD)
-        .compilesWithoutError();
   }
 
-  private CompileTester assertThatMethodCombination(String... methodLines) {
+  @Test
+  public void bindsWithStaticProvides() {
+    assertThat(compileMethodCombination(BINDS_METHOD, STATIC_PROVIDES_METHOD)).succeeded();
+  }
+
+  @Test
+  public void bindsWithMultibinds() {
+    assertThat(compileMethodCombination(BINDS_METHOD, MULTIBINDS_METHOD)).succeeded();
+  }
+
+  @Test
+  public void multibindsWithStaticProvides() {
+    assertThat(compileMethodCombination(MULTIBINDS_METHOD, STATIC_PROVIDES_METHOD)).succeeded();
+  }
+
+  @Test
+  public void instanceProvidesWithAbstractMethod() {
+    assertThat(compileMethodCombination(INSTANCE_PROVIDES_METHOD, SOME_ABSTRACT_METHOD))
+        .succeeded();
+  }
+
+  private Compilation compileMethodCombination(String... methodLines) {
     JavaFileObject fooFile =
         JavaFileObjects.forSourceLines(
             "test.Foo",
@@ -1430,8 +1455,8 @@ private CompileTester assertThatMethodCombination(String... methodLines) {
 
     JavaFileObject bindsMethodAndInstanceProvidesMethodModuleFile =
         JavaFileObjects.forSourceLines("test.TestModule", moduleLines);
-    return assertThat(
-            fooFile, fooImplFile, barFile, bazFile, bindsMethodAndInstanceProvidesMethodModuleFile)
-        .processedWith(new ComponentProcessor());
+    return daggerCompiler()
+        .compile(
+            fooFile, fooImplFile, barFile, bazFile, bindsMethodAndInstanceProvidesMethodModuleFile);
   }
 }
diff --git a/javatests/dagger/internal/codegen/ModuleValidatorTest.java b/javatests/dagger/internal/codegen/ModuleValidatorTest.java
index ea45f41ac..1c605bb5c 100644
--- a/javatests/dagger/internal/codegen/ModuleValidatorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleValidatorTest.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
 
@@ -85,12 +84,12 @@ public void moduleSubcomponents_notASubcomponent() {
     JavaFileObject notASubcomponent =
         JavaFileObjects.forSourceLines(
             "test.NotASubcomponent", "package test;", "", "class NotASubcomponent {}");
-    assertThat(module, notASubcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(module, notASubcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.NotASubcomponent is not a @Subcomponent or @ProductionSubcomponent")
-        .in(module)
+        .inFile(module)
         .onLine(5);
   }
 
@@ -119,12 +118,12 @@ public void moduleSubcomponents_listsSubcomponentBuilder() {
             "    Sub build();",
             "  }",
             "}");
-    assertThat(module, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(module, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.Sub.Builder is a @Subcomponent.Builder. Did you mean to use test.Sub?")
-        .in(module)
+        .inFile(module)
         .onLine(5);
   }
 
@@ -153,12 +152,12 @@ public void moduleSubcomponents_listsProductionSubcomponentBuilder() {
             "    Sub build();",
             "  }",
             "}");
-    assertThat(module, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(module, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.Sub.Builder is a @ProductionSubcomponent.Builder. Did you mean to use test.Sub?")
-        .in(module)
+        .inFile(module)
         .onLine(5);
   }
 
@@ -182,15 +181,15 @@ public void moduleSubcomponents_noSubcomponentBuilder() {
             "",
             "@Subcomponent",
             "interface NoBuilder {}");
-    assertThat(module, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(module, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.NoBuilder doesn't have a @Subcomponent.Builder, which is required when used "
                 + "with @"
                 + moduleType.simpleName()
                 + ".subcomponents")
-        .in(module)
+        .inFile(module)
         .onLine(5);
   }
 
@@ -214,15 +213,15 @@ public void moduleSubcomponents_noProductionSubcomponentBuilder() {
             "",
             "@ProductionSubcomponent",
             "interface NoBuilder {}");
-    assertThat(module, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(module, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.NoBuilder doesn't have a @ProductionSubcomponent.Builder, which is required "
                 + "when used with @"
                 + moduleType.simpleName()
                 + ".subcomponents")
-        .in(module)
+        .inFile(module)
         .onLine(5);
   }
 
@@ -237,11 +236,11 @@ public void moduleSubcomponentsAreTypes() {
             "",
             "@Module(subcomponents = int.class)",
             "class TestModule {}");
-    assertThat(module)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("int is not a valid subcomponent type")
-        .in(module)
+    Compilation compilation = daggerCompiler().compile(module);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("int is not a valid subcomponent type")
+        .inFile(module)
         .onLine(5);
   }
 
diff --git a/javatests/dagger/internal/codegen/MultibindingTest.java b/javatests/dagger/internal/codegen/MultibindingTest.java
index 29063c22c..23ce61438 100644
--- a/javatests/dagger/internal/codegen/MultibindingTest.java
+++ b/javatests/dagger/internal/codegen/MultibindingTest.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 
 import com.google.testing.compile.Compilation;
@@ -49,12 +48,11 @@ public void providesWithTwoMultibindingAnnotations_failsToCompile() {
             "  }",
             "}");
 
-    assertThat(module)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "Multiple multibinding annotations cannot be placed on the same Provides method")
-        .in(module)
+    Compilation compilation = daggerCompiler().compile(module);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Provides methods cannot have more than one multibinding annotation")
+        .inFile(module)
         .onLine(10);
   }
 
@@ -78,22 +76,22 @@ public void appliedOnInvalidMethods_failsToCompile() {
             "  @IntoMap Map<Integer, Double> map();",
             "}");
 
-    assertThat(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
-        .in(component)
-        .onLine(11)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(11);
+    assertThat(compilation)
+        .hadErrorContaining(
             "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
-        .in(component)
-        .onLine(12)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(12);
+    assertThat(compilation)
+        .hadErrorContaining(
             "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
-        .in(component)
+        .inFile(component)
         .onLine(13);
   }
 
diff --git a/javatests/dagger/internal/codegen/MultipleRequestTest.java b/javatests/dagger/internal/codegen/MultipleRequestTest.java
index 3dfd29566..a5514caf7 100644
--- a/javatests/dagger/internal/codegen/MultipleRequestTest.java
+++ b/javatests/dagger/internal/codegen/MultipleRequestTest.java
@@ -16,10 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
-import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -38,9 +38,9 @@
       "}");
 
   @Test public void multipleRequests_constructor() {
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
                 DEP_FILE,
                 JavaFileObjects.forSourceLines(
                     "test.ConstructorInjectsMultiple",
@@ -60,15 +60,14 @@
                     "@Component",
                     "interface SimpleComponent {",
                     "  ConstructorInjectsMultiple get();",
-                    "}")))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+                    "}"));
+    assertThat(compilation).succeeded();
   }
 
   @Test public void multipleRequests_field() {
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
                 DEP_FILE,
                 JavaFileObjects.forSourceLines(
                     "test.FieldInjectsMultiple",
@@ -90,15 +89,14 @@
                     "@Component",
                     "interface SimpleComponent {",
                     "  FieldInjectsMultiple get();",
-                    "}")))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+                    "}"));
+    assertThat(compilation).succeeded();
   }
 
   @Test public void multipleRequests_providesMethod() {
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
                 DEP_FILE,
                 JavaFileObjects.forSourceLines(
                     "test.FieldInjectsMultiple",
@@ -122,8 +120,7 @@
                     "@Component(modules = SimpleModule.class)",
                     "interface SimpleComponent {",
                     "  Object get();",
-                    "}")))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+                    "}"));
+    assertThat(compilation).succeeded();
   }
 }
diff --git a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
index 136e45063..4da7f6b5e 100644
--- a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
@@ -24,7 +24,6 @@
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -45,9 +44,6 @@ public OptionalBindingRequestFulfillmentTest(CompilerMode compilerMode) {
     this.compilerMode = compilerMode;
   }
 
-  public static final CodeBlock NPE_FROM_PROVIDES =
-      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-
   @Test
   public void inlinedOptionalBindings() {
     JavaFileObject module =
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 578d7fec7..eec32f72d 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -18,29 +18,19 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatProductionModuleMethod;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SCOPE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import java.lang.annotation.Retention;
 import javax.inject.Qualifier;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -60,88 +50,95 @@ private String formatModuleErrorMessage(String msg) {
 
   @Test public void producesMethodNotInModule() {
     assertThatMethodInUnannotatedClass("@Produces String produceString() { return null; }")
-        .hasError(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
+        .hasError(formatModuleErrorMessage("@%s methods can only be present within a @%s"));
   }
 
   @Test public void producesMethodAbstract() {
     assertThatProductionModuleMethod("@Produces abstract String produceString();")
-        .hasError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+        .hasError(formatErrorMessage("@%s methods cannot be abstract"));
   }
 
   @Test public void producesMethodPrivate() {
     assertThatProductionModuleMethod("@Produces private String produceString() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_PRIVATE));
+        .hasError(formatErrorMessage("@%s methods cannot be private"));
   }
 
   @Test public void producesMethodReturnVoid() {
     assertThatProductionModuleMethod("@Produces void produceNothing() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+        .hasError(formatErrorMessage("@%s methods must return a value (not void)"));
   }
 
   @Test
   public void producesProvider() {
     assertThatProductionModuleMethod("@Produces Provider<String> produceProvider() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void producesLazy() {
     assertThatProductionModuleMethod("@Produces Lazy<String> produceLazy() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void producesMembersInjector() {
     assertThatProductionModuleMethod(
             "@Produces MembersInjector<String> produceMembersInjector() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void producesProducer() {
     assertThatProductionModuleMethod("@Produces Producer<String> produceProducer() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void producesProduced() {
     assertThatProductionModuleMethod("@Produces Produced<String> produceProduced() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test public void producesMethodReturnRawFuture() {
     assertThatProductionModuleMethod("@Produces ListenableFuture produceRaw() {}")
         .importing(ListenableFuture.class)
-        .hasError(PRODUCES_METHOD_RAW_FUTURE);
+        .hasError("@Produces methods cannot return a raw ListenableFuture");
   }
 
   @Test public void producesMethodReturnWildcardFuture() {
     assertThatProductionModuleMethod("@Produces ListenableFuture<?> produceRaw() {}")
         .importing(ListenableFuture.class)
-        .hasError(PRODUCES_METHOD_RETURN_TYPE);
+        .hasError(
+            "@Produces methods can return only a primitive, an array, a type variable, "
+                + "a declared type, or a ListenableFuture of one of those types");
   }
 
   @Test public void producesMethodWithTypeParameter() {
     assertThatProductionModuleMethod("@Produces <T> String produceString() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+        .hasError(formatErrorMessage("@%s methods may not have type parameters"));
   }
 
   @Test public void producesMethodSetValuesWildcard() {
     assertThatProductionModuleMethod(
             "@Produces @ElementsIntoSet Set<?> produceWildcard() { return null; }")
-        .hasError(PRODUCES_METHOD_RETURN_TYPE);
+        .hasError(
+            "@Produces methods can return only a primitive, an array, a type variable, "
+                + "a declared type, or a ListenableFuture of one of those types");
   }
 
   @Test public void producesMethodSetValuesRawSet() {
     assertThatProductionModuleMethod(
             "@Produces @ElementsIntoSet Set produceSomething() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+        .hasError(
+            formatErrorMessage(
+                "@%s methods annotated with @ElementsIntoSet cannot return a raw Set"));
   }
 
   @Test public void producesMethodSetValuesNotASet() {
     assertThatProductionModuleMethod(
             "@Produces @ElementsIntoSet List<String> produceStrings() { return null; }")
-        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+        .hasError(
+            "@Produces methods of type set values must return a Set or ListenableFuture of Set");
   }
 
   @Test public void producesMethodSetValuesWildcardInFuture() {
@@ -149,14 +146,18 @@ public void producesProduced() {
             "@Produces @ElementsIntoSet "
                 + "ListenableFuture<Set<?>> produceWildcard() { return null; }")
         .importing(ListenableFuture.class)
-        .hasError(PRODUCES_METHOD_RETURN_TYPE);
+        .hasError(
+            "@Produces methods can return only a primitive, an array, a type variable, "
+                + "a declared type, or a ListenableFuture of one of those types");
   }
 
   @Test public void producesMethodSetValuesFutureRawSet() {
     assertThatProductionModuleMethod(
             "@Produces @ElementsIntoSet ListenableFuture<Set> produceSomething() { return null; }")
         .importing(ListenableFuture.class)
-        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+        .hasError(
+            formatErrorMessage(
+                "@%s methods annotated with @ElementsIntoSet cannot return a raw Set"));
   }
 
   @Test public void producesMethodSetValuesFutureNotASet() {
@@ -164,7 +165,8 @@ public void producesProduced() {
             "@Produces @ElementsIntoSet "
                 + "ListenableFuture<List<String>> produceStrings() { return null; }")
         .importing(ListenableFuture.class)
-        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+        .hasError(
+            "@Produces methods of type set values must return a Set or ListenableFuture of Set");
   }
 
   @Test public void multipleProducesMethodsWithSameName() {
@@ -184,12 +186,12 @@ public void producesProduced() {
         "    return \"\";",
         "  }",
         "}");
-    String errorMessage = String.format(BINDING_METHOD_WITH_SAME_NAME, "Produces");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage).in(moduleFile).onLine(8)
-        .and().withErrorContaining(errorMessage).in(moduleFile).onLine(12);
+    String errorMessage =
+        "Cannot have more than one @Produces method with the same name in a single module";
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage).inFile(moduleFile).onLine(8);
+    assertThat(compilation).hadErrorContaining(errorMessage).inFile(moduleFile).onLine(12);
   }
 
   @Test
@@ -202,7 +204,7 @@ public void producesMethodThrowsThrowable() {
 
   @Test public void producesMethodWithScope() {
     assertThatProductionModuleMethod("@Produces @Singleton String str() { return \"\"; }")
-        .hasError(PRODUCES_METHOD_SCOPE);
+        .hasError("@Produces methods may not have scope annotations");
   }
 
   @Test
@@ -216,12 +218,12 @@ public void privateModule() {
         "  @ProducerModule private static final class PrivateModule {",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Modules cannot be private.")
-        .in(moduleFile).onLine(6);
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Modules cannot be private")
+        .inFile(moduleFile)
+        .onLine(6);
   }
 
   @Test
@@ -237,12 +239,12 @@ public void enclosedInPrivateModule() {
         "    }",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Modules cannot be enclosed in private types.")
-        .in(moduleFile).onLine(7);
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Modules cannot be enclosed in private types")
+        .inFile(moduleFile)
+        .onLine(7);
   }
 
   @Test
@@ -259,15 +261,11 @@ public void includesNonModule() {
             "@ProducerModule(includes = X.class)",
             "public final class FooModule {",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(xFile, moduleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(
-                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
-                "X",
-                "one of @Module, @ProducerModule"));
+    Compilation compilation = daggerCompiler().compile(xFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "X is listed as a module, but is not annotated with one of @Module, @ProducerModule");
   }
 
   @Test
@@ -306,16 +304,22 @@ public void publicModuleNonPublicIncludes() {
         "@ProducerModule",
         "public final class OtherPublicModule {",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(
-            publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("This module is public, but it includes non-public "
-            + "(or effectively non-public) modules. "
-            + "Either reduce the visibility of this module or make "
-            + "test.NonPublicModule1 and test.NonPublicModule2 public.")
-        .in(publicModuleFile).onLine(8);
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                publicModuleFile,
+                nonPublicModule1File,
+                nonPublicModule2File,
+                otherPublicModuleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "This module is public, but it includes non-public "
+                + "(or effectively non-public) modules. "
+                + "Either reduce the visibility of this module or make "
+                + "test.NonPublicModule1 and test.NonPublicModule2 public.")
+        .inFile(publicModuleFile)
+        .onLine(8);
   }
 
   @Test public void argumentNamedModuleCompiles() {
@@ -331,10 +335,8 @@ public void publicModuleNonPublicIncludes() {
         "    return null;",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).succeeded();
   }
 
   @Test public void singleProducesMethodNoArgsFuture() {
@@ -373,8 +375,6 @@ public void publicModuleNonPublicIncludes() {
             "    implements AsyncFunction<Void, String>, Executor {",
             "  private final TestModule module;",
             "  private final Provider<Executor> executorProvider;",
-            "  private final ",
-            "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider;",
             "",
             "  public TestModule_ProduceStringFactory(",
             "      TestModule module,",
@@ -385,7 +385,6 @@ public void publicModuleNonPublicIncludes() {
             "        ProducerToken.create(TestModule_ProduceStringFactory.class));",
             "    this.module = module;",
             "    this.executorProvider = executorProvider;",
-            "    this.productionComponentMonitorProvider = productionComponentMonitorProvider;",
             "  }",
             "",
             "  @Override protected ListenableFuture<String> compute() {",
@@ -397,7 +396,7 @@ public void publicModuleNonPublicIncludes() {
             "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
             "    monitor.methodStarting();",
             "    try {",
-            "      return TestModule_ProduceStringFactory.this.module.produceString();",
+            "      return module.produceString();",
             "    } finally {",
             "      monitor.methodFinished();",
             "    }",
@@ -457,8 +456,6 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "    implements AsyncFunction<Void, String>, Executor {",
             "  private final TestModule module;",
             "  private final Provider<Executor> executorProvider;",
-            "  private final ",
-            "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider;",
             "",
             "  public TestModule_ProduceStringFactory(",
             "      TestModule module,",
@@ -469,7 +466,6 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "        ProducerToken.create(\"test.TestModule#produceString\"));",
             "    this.module = module;",
             "    this.executorProvider = executorProvider;",
-            "    this.productionComponentMonitorProvider = productionComponentMonitorProvider;",
             "  }",
             "",
             "  @Override protected ListenableFuture<String> compute() {",
@@ -481,7 +477,7 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
             "    monitor.methodStarting();",
             "    try {",
-            "      return TestModule_ProduceStringFactory.this.module.produceString();",
+            "      return module.produceString();",
             "    } finally {",
             "      monitor.methodFinished();",
             "    }",
@@ -506,12 +502,14 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
     assertThatProductionModuleMethod(
             "@Produces @QualifierA @QualifierB abstract String produceString() { return null; }")
         .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
-        .hasError(BINDING_METHOD_MULTIPLE_QUALIFIERS);
+        .hasError("Cannot use more than one @Qualifier");
   }
-  
+
   @Qualifier
+  @Retention(RUNTIME)
   public @interface QualifierA {}
 
   @Qualifier
+  @Retention(RUNTIME)
   public @interface QualifierB {}
 }
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index fad441e49..b7fa898ca 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -17,12 +17,13 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
-import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
@@ -52,10 +53,9 @@ public ProductionComponentProcessorTest(CompilerMode compilerMode) {
         "",
         "@ProductionComponent",
         "final class NotAComponent {}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
   }
 
   @Test public void componentOnEnum() {
@@ -68,12 +68,10 @@ public ProductionComponentProcessorTest(CompilerMode compilerMode) {
         "enum NotAComponent {",
         "  INSTANCE",
         "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
   }
 
   @Test public void componentOnAnnotation() {
@@ -84,12 +82,10 @@ public ProductionComponentProcessorTest(CompilerMode compilerMode) {
         "",
         "@ProductionComponent",
         "@interface NotAComponent {}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
   }
 
   @Test public void nonModuleModule() {
@@ -100,12 +96,11 @@ public ProductionComponentProcessorTest(CompilerMode compilerMode) {
         "",
         "@ProductionComponent(modules = Object.class)",
         "interface NotAComponent {}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("is not annotated with one of @Module, @ProducerModule");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("is not annotated with one of @Module, @ProducerModule");
   }
 
   @Test
@@ -161,12 +156,12 @@ public void dependsOnProductionExecutor() {
             "    SimpleComponent build();",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("may not depend on the production executor");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(moduleFile, producerModuleFile, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("may not depend on the production executor");
   }
 
   @Test
@@ -576,17 +571,16 @@ public void simpleComponent() {
         "    ListenableFuture<A> a();",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(component)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .withWarningContaining("@Nullable on @Produces methods does not do anything")
-        .in(component)
-        .onLine(33)
-        .and()
-        .withWarningContaining("@Nullable on @Produces methods does not do anything")
-        .in(component)
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining("@Nullable on @Produces methods does not do anything")
+        .inFile(component)
+        .onLine(33);
+    assertThat(compilation)
+        .hadWarningContaining("@Nullable on @Produces methods does not do anything")
+        .inFile(component)
         .onLine(36);
   }
 }
diff --git a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
index f3fe3bf45..32f984b81 100644
--- a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -16,12 +16,9 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 
-import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -78,14 +75,13 @@
         "    return null;",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(EXECUTOR_MODULE, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.Bar cannot be provided without an @Inject constructor or an @Provides- or "
                 + "@Produces-annotated method.")
-        .in(component)
+        .inFile(component)
         .onLine(8);
   }
 
@@ -106,10 +102,9 @@
         "}");
     String expectedError =
         "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated method.";
-    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(11);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(11);
   }
 
   @Test public void provisionDependsOnProduction() {
@@ -148,10 +143,9 @@
         "}");
     String expectedError =
         "test.TestClass.A is a provision, which cannot depend on a production.";
-    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(30);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(30);
   }
 
   @Test public void provisionEntryPointDependsOnProduction() {
@@ -182,10 +176,9 @@
             "}");
     String expectedError =
         "test.TestClass.A is a provision entry-point, which cannot depend on a production.";
-    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(20);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(20);
   }
 
   @Test
@@ -238,12 +231,11 @@ public void providingMultibindingWithProductions() {
             "    ListenableFuture<B> b();",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(EXECUTOR_MODULE, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("test.TestClass.A is a provision, which cannot depend on a production")
-        .in(component)
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.TestClass.A is a provision, which cannot depend on a production")
+        .inFile(component)
         .onLine(43);
   }
 
@@ -290,12 +282,9 @@ public void monitoringDependsOnUnboundType() {
             "}");
     String expectedError =
         "test.TestClass.A cannot be provided without an @Provides-annotated method.";
-    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(34);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(34);
   }
 
   @Test
@@ -346,12 +335,9 @@ public void monitoringDependsOnProduction() {
         "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory>"
             + " test.TestClass.MonitoringModule#monitorFactory is a provision,"
             + " which cannot depend on a production.";
-    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(37);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(37);
   }
 
   @Test
@@ -390,13 +376,9 @@ public void cycleNotBrokenByMap() {
             "    return string;",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(EXECUTOR_MODULE, component, module))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("cycle")
-        .in(component)
-        .onLine(8);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component, module);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("cycle").inFile(component).onLine(8);
   }
 
   @Test
@@ -436,13 +418,9 @@ public void cycleNotBrokenByProducerMap() {
             "    return string;",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(EXECUTOR_MODULE, component, module))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("cycle")
-        .in(component)
-        .onLine(8);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component, module);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("cycle").inFile(component).onLine(8);
   }
   
   @Test
diff --git a/javatests/dagger/internal/codegen/RepeatedModuleValidationTest.java b/javatests/dagger/internal/codegen/RepeatedModuleValidationTest.java
index 4fc74d811..60a9bd516 100644
--- a/javatests/dagger/internal/codegen/RepeatedModuleValidationTest.java
+++ b/javatests/dagger/internal/codegen/RepeatedModuleValidationTest.java
@@ -16,10 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
-import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -61,12 +61,12 @@ public void moduleRepeatedInSubcomponentFactoryMethod() {
             "interface TestComponent {",
             "  TestSubcomponent newTestSubcomponent(TestModule module);",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("TestModule is present in test.TestComponent.")
-        .in(componentFile)
+    Compilation compilation =
+        daggerCompiler().compile(MODULE_FILE, subcomponentFile, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("TestModule is present in test.TestComponent.")
+        .inFile(componentFile)
         .onLine(7)
         .atColumn(51);
   }
@@ -99,10 +99,9 @@ public void moduleRepeatedInSubcomponentBuilderMethod() {
             "interface TestComponent {",
             "  TestSubcomponent.Builder newTestSubcomponentBuilder();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation =
+        daggerCompiler().compile(MODULE_FILE, subcomponentFile, componentFile);
+    assertThat(compilation).succeeded();
     // TODO(gak): assert about the warning when we have that ability
   }
 
@@ -129,9 +128,8 @@ public void moduleRepeatedButNotPassed() {
             "interface TestComponent {",
             "  TestSubcomponent newTestSubcomponent();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation =
+        daggerCompiler().compile(MODULE_FILE, subcomponentFile, componentFile);
+    assertThat(compilation).succeeded();
   }
 }
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
index 0a5de8dd6..046061689 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
@@ -25,7 +25,6 @@
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -46,9 +45,6 @@ public SetBindingRequestFulfillmentTest(CompilerMode compilerMode) {
     this.compilerMode = compilerMode;
   }
 
-  public static final CodeBlock NPE_FROM_PROVIDES =
-      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-
   @Test
   public void setBindings() {
     JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index 32ddf8d52..0274d96d2 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -23,7 +23,6 @@
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -44,9 +43,6 @@ public SetBindingRequestFulfillmentWithGuavaTest(CompilerMode compilerMode) {
     this.compilerMode = compilerMode;
   }
 
-  public static final CodeBlock NPE_FROM_PROVIDES =
-      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-
   @Test
   public void setBindings() {
     JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index 1351702e0..a829ec3d5 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -16,14 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 
 import com.google.common.base.Joiner;
-import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -63,12 +59,13 @@ public void testRefSubcomponentAndSubBuilderFails() {
         "    ChildComponent build();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
-            "test.ChildComponent", "[child(), builder()]"))
-        .in(componentFile);
+    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                MSGS.moreThanOneRefToSubcomponent(), "test.ChildComponent", "[child(), builder()]"))
+        .inFile(componentFile);
   }
 
   @Test
@@ -96,12 +93,15 @@ public void testRefSubBuilderTwiceFails() {
         "    ChildComponent build();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
-            "test.ChildComponent", "[builder1(), builder2()]"))
-        .in(componentFile);
+    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                MSGS.moreThanOneRefToSubcomponent(),
+                "test.ChildComponent",
+                "[builder1(), builder2()]"))
+        .inFile(componentFile);
   }
 
   @Test
@@ -133,12 +133,13 @@ public void testMoreThanOneBuilderFails() {
         "    ChildComponent build();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.moreThanOne(),
-            "[test.ChildComponent.Builder1, test.ChildComponent.Builder2]"))
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                MSGS.moreThanOne(), "[test.ChildComponent.Builder1, test.ChildComponent.Builder2]"))
+        .inFile(childComponentFile);
   }
 
   @Test
@@ -165,11 +166,9 @@ public void testBuilderGenericsFails() {
         "     ChildComponent build();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.generics())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.generics()).inFile(childComponentFile);
   }
 
   @Test
@@ -181,11 +180,9 @@ public void testBuilderNotInComponentFails() {
         "",
         "@Subcomponent.Builder",
         "interface Builder {}");
-    assertAbout(javaSource()).that(builder)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeInComponent())
-        .in(builder);
+    Compilation compilation = daggerCompiler().compile(builder);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.mustBeInComponent()).inFile(builder);
   }
 
   @Test
@@ -210,11 +207,11 @@ public void testBuilderMissingBuildMethodFails() {
         "  @Subcomponent.Builder",
         "  interface Builder {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.missingBuildMethod())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.missingBuildMethod())
+        .inFile(childComponentFile);
   }
 
   @Test
@@ -229,11 +226,9 @@ public void testPrivateBuilderFails() {
         "  @Subcomponent.Builder",
         "  private interface Builder {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.isPrivate())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.isPrivate()).inFile(childComponentFile);
   }
 
   @Test
@@ -248,11 +243,9 @@ public void testNonStaticBuilderFails() {
         "  @Subcomponent.Builder",
         "  abstract class Builder {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeStatic())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.mustBeStatic()).inFile(childComponentFile);
   }
 
   @Test
@@ -267,11 +260,9 @@ public void testNonAbstractBuilderFails() {
         "  @Subcomponent.Builder",
         "  static class Builder {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeAbstract())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.mustBeAbstract()).inFile(childComponentFile);
   }
 
   @Test
@@ -288,11 +279,11 @@ public void testBuilderOneCxtorWithArgsFails() {
         "    Builder(String unused) {}",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .inFile(childComponentFile);
   }
 
   @Test
@@ -310,11 +301,11 @@ public void testBuilderMoreThanOneCxtorFails() {
         "    Builder(String unused) {}",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .inFile(childComponentFile);
   }
 
   @Test
@@ -329,11 +320,11 @@ public void testBuilderEnumFails() {
         "  @Subcomponent.Builder",
         "  enum Builder {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeClassOrInterface())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.mustBeClassOrInterface())
+        .inFile(childComponentFile);
   }
 
   @Test
@@ -350,11 +341,12 @@ public void testBuilderBuildReturnsWrongTypeFails() {
         "    String build();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.buildMustReturnComponentType())
-            .in(childComponentFile).onLine(9);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.buildMustReturnComponentType())
+        .inFile(childComponentFile)
+        .onLine(9);
   }
 
   @Test
@@ -373,12 +365,12 @@ public void testInheritedBuilderBuildReturnsWrongTypeFails() {
         "  @Subcomponent.Builder",
         "  interface Builder extends Parent {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
-            .in(childComponentFile).onLine(12);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+        .inFile(childComponentFile)
+        .onLine(12);
   }
 
   @Test
@@ -396,11 +388,12 @@ public void testTwoBuildMethodsFails() {
         "    ChildComponent create();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
-            .in(childComponentFile).onLine(10);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
+        .inFile(childComponentFile)
+        .onLine(10);
   }
 
   @Test
@@ -420,12 +413,12 @@ public void testInheritedTwoBuildMethodsFails() {
         "  @Subcomponent.Builder",
         "  interface Builder extends Parent {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
-            .in(childComponentFile).onLine(13);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
+        .inFile(childComponentFile)
+        .onLine(13);
   }
 
   @Test
@@ -444,13 +437,16 @@ public void testMoreThanOneArgFails() {
         "    Builder set(Number n, Double d);",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(childComponentFile).onLine(10)
-        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(childComponentFile).onLine(11);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.methodsMustTakeOneArg())
+        .inFile(childComponentFile)
+        .onLine(10);
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.methodsMustTakeOneArg())
+        .inFile(childComponentFile)
+        .onLine(11);
   }
 
   @Test
@@ -470,13 +466,14 @@ public void testInheritedMoreThanOneArgFails() {
         "  @Subcomponent.Builder",
         "  interface Builder extends Parent {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
-                "set1(java.lang.String,java.lang.Integer)"))
-            .in(childComponentFile).onLine(13);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                MSGS.inheritedMethodsMustTakeOneArg(), "set1(java.lang.String,java.lang.Integer)"))
+        .inFile(childComponentFile)
+        .onLine(13);
   }
 
   @Test
@@ -494,11 +491,12 @@ public void testSetterReturningNonVoidOrBuilderFails() {
         "    String set(Integer i);",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
-            .in(childComponentFile).onLine(10);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
+        .inFile(childComponentFile)
+        .onLine(10);
   }
 
   @Test
@@ -518,13 +516,13 @@ public void testInheritedSetterReturningNonVoidOrBuilderFails() {
         "  @Subcomponent.Builder",
         "  interface Builder extends Parent {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
-                "set(java.lang.Integer)"))
-            .in(childComponentFile).onLine(13);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(), "set(java.lang.Integer)"))
+        .inFile(childComponentFile)
+        .onLine(13);
   }
 
   @Test
@@ -542,11 +540,12 @@ public void testGenericsOnSetterMethodFails() {
         "    <T> Builder set(T t);",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
-            .in(childComponentFile).onLine(10);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
+        .inFile(childComponentFile)
+        .onLine(10);
   }
 
   @Test
@@ -566,12 +565,13 @@ public void testGenericsOnInheritedSetterMethodFails() {
         "  @Subcomponent.Builder",
         "  interface Builder extends Parent {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
-            .in(childComponentFile).onLine(13);
+        .inFile(childComponentFile)
+        .onLine(13);
   }
 
   @Test
@@ -617,16 +617,16 @@ public void testMultipleSettersPerTypeFails() {
             "    void set2(TestModule s);",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().compile(moduleFile, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 MSGS.manyMethodsForType(),
                 "test.TestModule",
                 "[set1(test.TestModule), set2(test.TestModule)]"))
-        .in(childComponentFile)
+        .inFile(childComponentFile)
         .onLine(10);
   }
 
@@ -676,14 +676,14 @@ public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
             "    void set2(TestModule s);",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().compile(moduleFile, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 MSGS.manyMethodsForType(), "test.TestModule", "[set1(T), set2(test.TestModule)]"))
-        .in(childComponentFile)
+        .inFile(childComponentFile)
         .onLine(14);
   }
 
@@ -758,14 +758,16 @@ public void testExtraSettersFails() {
         "    void set2(Integer s);",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.extraSetters(),
-                  "[void test.ChildComponent.Builder.set1(String),"
-                  + " void test.ChildComponent.Builder.set2(Integer)]"))
-            .in(childComponentFile).onLine(8);
+    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                MSGS.extraSetters(),
+                "[void test.ChildComponent.Builder.set1(String),"
+                    + " void test.ChildComponent.Builder.set2(Integer)]"))
+        .inFile(childComponentFile)
+        .onLine(8);
   }
 
   @Test
@@ -827,19 +829,17 @@ public void testMissingSettersFail() {
         "    ChildComponent create();",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile,
-            module2File,
-            module3File,
-            componentFile,
-            childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .compile(moduleFile, module2File, module3File, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             // Ignores Test2Module because we can construct it ourselves.
             // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
             String.format(MSGS.missingSetters(), "[test.TestModule, test.Test3Module]"))
-            .in(childComponentFile).onLine(11);
+        .inFile(childComponentFile)
+        .onLine(11);
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index e8def7a4c..5e02bd637 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -16,17 +16,13 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
 import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
-import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Collection;
@@ -86,16 +82,17 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "    return object;",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(componentFile, childComponentFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.ChildComponent requires modules which have no visible default constructors. "
                 + "Add the following modules as parameters to this method: "
                 + "test.ModuleWithParameters")
-        .in(componentFile)
+        .inFile(componentFile)
         .onLine(7);
   }
 
@@ -116,14 +113,15 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "",
         "@Subcomponent",
         "interface ChildComponent {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(componentFile, childComponentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "Subcomponent factory methods may only accept modules, but java.lang.String is not.")
-        .in(componentFile)
+        .inFile(componentFile)
         .onLine(7)
         .atColumn(43);
   }
@@ -152,15 +150,16 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "",
         "@Subcomponent(modules = TestModule.class)",
         "interface ChildComponent {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(moduleFile, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "A module may only occur once an an argument in a Subcomponent factory method, "
                 + "but test.TestModule was already passed.")
-        .in(componentFile)
+        .inFile(componentFile)
         .onLine(7)
         .atColumn(71);
   }
@@ -189,15 +188,16 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "",
         "@Subcomponent",
         "interface ChildComponent {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(moduleFile, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.TestModule is present as an argument to the test.ChildComponent factory method, "
                 + "but is not one of the modules used to implement the subcomponent.")
-        .in(componentFile)
+        .inFile(componentFile)
         .onLine(7);
   }
 
@@ -232,16 +232,17 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "interface ChildComponent {",
         "  String getString();",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(moduleFile, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "[test.ChildComponent.getString()] "
                 + "java.lang.Integer cannot be provided without an @Inject constructor or an "
                 + "@Provides-annotated method")
-        .in(componentFile)
+        .inFile(componentFile)
         .onLine(6);
   }
 
@@ -253,12 +254,10 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "",
         "@Subcomponent",
         "final class NotASubcomponent {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(subcomponentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(subcomponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
   }
 
   @Test public void scopeMismatch() {
@@ -293,12 +292,12 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "final class ChildModule {",
         "  @Provides @Singleton Object provideObject() { return null; }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(componentFile, subcomponentFile, moduleFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Singleton");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(componentFile, subcomponentFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("@Singleton");
   }
 
   @Test
@@ -1033,15 +1032,17 @@ public void duplicateBindingWithSubcomponentDeclaration() {
             "  Object dependsOnBuilder();",
             "}");
 
-    assertThat(module, component, subcomponent)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("test.Sub.Builder is bound multiple times:")
-        .and()
-        .withErrorContaining(
-            "@Provides test.Sub.Builder test.TestModule.providesConflictsWithModuleSubcomponents()")
-        .and()
-        .withErrorContaining("@Module(subcomponents = test.Sub.class) for test.TestModule");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, component, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("test.Sub.Builder is bound multiple times:");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@Provides test.Sub.Builder "
+                + "test.TestModule.providesConflictsWithModuleSubcomponents()");
+    assertThat(compilation)
+        .hadErrorContaining("@Module(subcomponents = test.Sub.class) for test.TestModule");
   }
 }
diff --git a/javatests/dagger/internal/codegen/ValidationReportTest.java b/javatests/dagger/internal/codegen/ValidationReportTest.java
index 2ca4ce75f..b0f2f2fe1 100644
--- a/javatests/dagger/internal/codegen/ValidationReportTest.java
+++ b/javatests/dagger/internal/codegen/ValidationReportTest.java
@@ -16,11 +16,12 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
 
 import com.google.common.collect.ImmutableSet;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import dagger.internal.codegen.ValidationReport.Builder;
 import java.util.Set;
@@ -42,67 +43,67 @@
 
   @Test
   public void basicReport() {
-    assertAbout(javaSource())
-        .that(TEST_CLASS_FILE)
-        .processedWith(
-            new SimpleTestProcessor() {
-              @Override
-              void test() {
-                Builder<TypeElement> reportBuilder =
-                    ValidationReport.about(getTypeElement("test.TestClass"));
-                reportBuilder.addError("simple error");
-                reportBuilder.build().printMessagesTo(processingEnv.getMessager());
-              }
-            })
-        .failsToCompile()
-        .withErrorContaining("simple error")
-        .in(TEST_CLASS_FILE)
-        .onLine(3);
+    Compilation compilation =
+        javac()
+            .withProcessors(
+                new SimpleTestProcessor() {
+                  @Override
+                  void test() {
+                    Builder<TypeElement> reportBuilder =
+                        ValidationReport.about(getTypeElement("test.TestClass"));
+                    reportBuilder.addError("simple error");
+                    reportBuilder.build().printMessagesTo(processingEnv.getMessager());
+                  }
+                })
+            .compile(TEST_CLASS_FILE);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("simple error").inFile(TEST_CLASS_FILE).onLine(3);
   }
 
   @Test
   public void messageOnDifferentElement() {
-    assertAbout(javaSource())
-        .that(TEST_CLASS_FILE)
-        .processedWith(
-            new SimpleTestProcessor() {
-              @Override
-              void test() {
-                Builder<TypeElement> reportBuilder =
-                    ValidationReport.about(getTypeElement("test.TestClass"));
-                reportBuilder.addError("simple error", getTypeElement(String.class));
-                reportBuilder.build().printMessagesTo(processingEnv.getMessager());
-              }
-            })
-        .failsToCompile()
-        .withErrorContaining("[java.lang.String] simple error")
-        .in(TEST_CLASS_FILE)
+    Compilation compilation =
+        javac()
+            .withProcessors(
+                new SimpleTestProcessor() {
+                  @Override
+                  void test() {
+                    Builder<TypeElement> reportBuilder =
+                        ValidationReport.about(getTypeElement("test.TestClass"));
+                    reportBuilder.addError("simple error", getTypeElement(String.class));
+                    reportBuilder.build().printMessagesTo(processingEnv.getMessager());
+                  }
+                })
+            .compile(TEST_CLASS_FILE);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("[java.lang.String] simple error")
+        .inFile(TEST_CLASS_FILE)
         .onLine(3);
   }
 
   @Test
   public void subreport() {
-    assertAbout(javaSource())
-        .that(TEST_CLASS_FILE)
-        .processedWith(
-            new SimpleTestProcessor() {
-              @Override
-              void test() {
-                Builder<TypeElement> reportBuilder =
-                    ValidationReport.about(getTypeElement("test.TestClass"));
-                reportBuilder.addError("simple error");
-                ValidationReport<TypeElement> parentReport =
-                    ValidationReport.about(getTypeElement(String.class))
-                        .addSubreport(reportBuilder.build())
-                        .build();
-                assertThat(parentReport.isClean()).isFalse();
-                parentReport.printMessagesTo(processingEnv.getMessager());
-              }
-            })
-        .failsToCompile()
-        .withErrorContaining("simple error")
-        .in(TEST_CLASS_FILE)
-        .onLine(3);
+    Compilation compilation =
+        javac()
+            .withProcessors(
+                new SimpleTestProcessor() {
+                  @Override
+                  void test() {
+                    Builder<TypeElement> reportBuilder =
+                        ValidationReport.about(getTypeElement("test.TestClass"));
+                    reportBuilder.addError("simple error");
+                    ValidationReport<TypeElement> parentReport =
+                        ValidationReport.about(getTypeElement(String.class))
+                            .addSubreport(reportBuilder.build())
+                            .build();
+                    assertThat(parentReport.isClean()).isFalse();
+                    parentReport.printMessagesTo(processingEnv.getMessager());
+                  }
+                })
+            .compile(TEST_CLASS_FILE);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("simple error").inFile(TEST_CLASS_FILE).onLine(3);
   }
 
   private static abstract class SimpleTestProcessor extends AbstractProcessor {
diff --git a/util/deploy-to-maven-central.sh b/util/deploy-to-maven-central.sh
index 37df4808e..63471807f 100755
--- a/util/deploy-to-maven-central.sh
+++ b/util/deploy-to-maven-central.sh
@@ -20,16 +20,6 @@ if [[ "$version_name" =~ " " ]]; then
   exit 3
 fi
 
-#validate key
-keystatus=$(gpg --list-keys | grep ${key} | awk '{print $1}')
-if [ "${keystatus}" != "pub" ]; then
-  echo "Could not find public key with label ${key}"
-  echo -n "Available keys from: "
-  gpg --list-keys | grep --invert-match '^sub'
-
-  exit 64
-fi
-
 bazel test //...
 
 bash $(dirname $0)/execute-deploy.sh \
@@ -60,4 +50,5 @@ for generated_pom_file in dagger*pom.xml; do
   rm "${generated_pom_file}.asc"
 done
 
-
+git tag -a -m "Dagger ${version_name}" dagger-"${version_name}"
+git push origin tag dagger-"${version_name}"
