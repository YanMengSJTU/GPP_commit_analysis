diff --git a/java/dagger/internal/MissingBindingFactory.java b/java/dagger/internal/MissingBindingFactory.java
new file mode 100644
index 000000000..993d15047
--- /dev/null
+++ b/java/dagger/internal/MissingBindingFactory.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+/**
+ * A {@link Factory} that always throws on calls to {@link Factory#get()}. This is necessary in
+ * ahead-of-time subcomponents mode, where modifiable binding methods need to return a {@code
+ * Provider<T>} to a framework instance initialization that is pruned and no longer in the binding
+ * graph, but was present in a superclass implementation. This class fulfills that requirement but
+ * is still practically unusable.
+ */
+public final class MissingBindingFactory<T> implements Factory<T> {
+  private static final MissingBindingFactory<Object> INSTANCE = new MissingBindingFactory<>();
+
+  private MissingBindingFactory() {}
+
+  @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
+  public static <T> Factory<T> create() {
+    return (Factory) INSTANCE;
+  }
+
+  @Override
+  public T get() {
+    throw new AssertionError(
+        "This binding is not part of the final binding graph. The key was requested by a binding "
+            + "that was believed to possibly be part of the graph, but is no longer requested. "
+            + "If this exception is thrown, it is the result of a Dagger bug.");
+  }
+}
diff --git a/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java
index c577ea9c4..f76c49c67 100644
--- a/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java
@@ -18,7 +18,10 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import dagger.internal.MissingBindingFactory;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.producers.internal.MissingBindingProducer;
+import java.util.Optional;
 
 /**
  * A {@link BindingExpression} that implements a method that encapsulates a binding that is not part
@@ -37,7 +40,8 @@
           "throw new $T($S);",
           UnsupportedOperationException.class,
           "This binding is not part of the final binding graph. The key was requested by a binding "
-              + "that was believed to possibly be part of the graph, but is no longer requested.");
+              + "that was believed to possibly be part of the graph, but is no longer requested. "
+              + "If this exception is thrown, it is the result of a Dagger bug.");
 
   PrunedConcreteMethodBindingExpression() {}
 
@@ -46,9 +50,25 @@ CodeBlock getModifiableBindingMethodImplementation(
       ModifiableBindingMethod modifiableBindingMethod,
       ComponentImplementation component,
       DaggerTypes types) {
+    Optional<FrameworkType> frameworkType = modifiableBindingMethod.request().frameworkType();
+    if (frameworkType.isPresent()) {
+      // If we make initializations replaceable, we can do away with these classes and this logic
+      // since the pruned framework instances will no longer be initialized
+      switch (frameworkType.get()) {
+        case PROVIDER:
+          return missingFrameworkInstance(MissingBindingFactory.class);
+        case PRODUCER_NODE:
+          return missingFrameworkInstance(MissingBindingProducer.class);
+      }
+      throw new AssertionError(frameworkType);
+    }
     return METHOD_IMPLEMENTATION;
   }
 
+  private static CodeBlock missingFrameworkInstance(Class<?> factoryClass) {
+    return CodeBlock.builder().addStatement("return $T.create()", factoryClass).build();
+  }
+
   @Override
   final Expression getDependencyExpression(ClassName requestingClass) {
     throw new UnsupportedOperationException(
diff --git a/java/dagger/producers/internal/MissingBindingProducer.java b/java/dagger/producers/internal/MissingBindingProducer.java
new file mode 100644
index 000000000..5721569a0
--- /dev/null
+++ b/java/dagger/producers/internal/MissingBindingProducer.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+
+/**
+ * A {@link Producer} that always throws on calls to {@link Producer#get()}. This is necessary in
+ * ahead-of-time subcomponents mode, where modifiable binding methods need to return a {@code
+ * Producer<T>} to a framework instance initialization that is pruned and no longer in the binding
+ * graph, but was present in a superclass implementation. This class fulfills that requirement but
+ * is still practically unusable.
+ */
+public final class MissingBindingProducer<T> extends AbstractProducer<T> {
+  private static final MissingBindingProducer<Object> INSTANCE = new MissingBindingProducer<>();
+
+  private MissingBindingProducer() {}
+
+  @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
+  public static <T> Producer<T> create() {
+    return (Producer) INSTANCE;
+  }
+
+  @Override
+  protected ListenableFuture<T> compute() {
+    throw new AssertionError(
+        "This binding is not part of the final binding graph. The key was requested by a binding "
+            + "that was believed to possibly be part of the graph, but is no longer requested. "
+            + "If this exception is thrown, it is the result of a Dagger bug.");
+  }
+}
diff --git a/javatests/dagger/functional/aot/PrunedBindingDependedOnInSuperInitializationTest.java b/javatests/dagger/functional/aot/PrunedBindingDependedOnInSuperInitializationTest.java
new file mode 100644
index 000000000..853e22b07
--- /dev/null
+++ b/javatests/dagger/functional/aot/PrunedBindingDependedOnInSuperInitializationTest.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.aot;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class PrunedBindingDependedOnInSuperInitializationTest {
+  interface PrunedDependency {}
+
+  static class WillHavePrunedDependency {
+    @Inject WillHavePrunedDependency(PrunedDependency pruned) {}
+  }
+
+  @Subcomponent
+  interface Child {
+    Provider<WillHavePrunedDependency> frameworkInstance();
+  }
+
+  @Module
+  static class ParentModule {
+    @Provides
+    static WillHavePrunedDependency pruneDependency() {
+      return new WillHavePrunedDependency(new PrunedDependency() {});
+    }
+  }
+
+  @Component(modules = ParentModule.class)
+  interface Parent {
+    Child child();
+  }
+
+  @Test
+  public void prunedFrameworkInstanceBindingUsedInInitializationDoesntThrow() {
+    Parent parent = DaggerPrunedBindingDependedOnInSuperInitializationTest_Parent.create();
+    // This test ensures that pruned bindings that are used during unpruned initialization
+    // statements do not throw exceptions. If the subcomponent initialization succeeds, the test
+    // should pass
+    parent.child();
+  }
+}
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 71ee8d5aa..59d1f510c 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -33,6 +33,12 @@
 
 @RunWith(JUnit4.class)
 public final class AheadOfTimeSubcomponentsTest {
+  private static final String PRUNED_METHOD_BODY =
+      "throw new UnsupportedOperationException(\"This binding is not part of the final binding "
+          + "graph. The key was requested by a binding that was believed to possibly be part of "
+          + "the graph, but is no longer requested. If this exception is thrown, it is the result "
+          + "of a Dagger bug.\");";
+
   @Test
   public void missingBindings_fromComponentMethod() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
@@ -958,10 +964,7 @@ public void prunedGeneratedInstanceBinding() {
             "",
             "    @Override",
             "    protected Object getPrunedSubcomponentBuilder() {",
-            "      throw new UnsupportedOperationException(",
-            "          \"This binding is not part of the final binding graph. The key was \"",
-            "              + \"requested by a binding that was believed to possibly be part of \"",
-            "              + \"the graph, but is no longer requested.\");",
+            "      " + PRUNED_METHOD_BODY,
             "    }",
             "",
             "    @Override",
@@ -4361,10 +4364,7 @@ public void provisionOverInjection_prunedIndirectDependency() {
             "",
             "    @Override",
             "    protected Object getPrunedDependency() {",
-            "      throw new UnsupportedOperationException(",
-            "          \"This binding is not part of the final binding graph. The key was \"",
-            "              + \"requested by a binding that was believed to possibly be part of \"",
-            "              + \"the graph, but is no longer requested.\");",
+            "      " + PRUNED_METHOD_BODY,
             "    }",
             "",
             "    @Override",
@@ -6395,10 +6395,7 @@ public void bindsWithMissingDependency_pruned() {
             "",
             "    @Override",
             "    protected Object getObject() {",
-            "      throw new UnsupportedOperationException(",
-            "          \"This binding is not part of the final binding graph. The key was \"",
-            "              + \"requested by a binding that was believed to possibly be part of \"",
-            "              + \"the graph, but is no longer requested.\");",
+            "      " + PRUNED_METHOD_BODY,
             "    }",
             "",
             "    @Override",
