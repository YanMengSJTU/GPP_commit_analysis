diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 92fee88b4..601f4b327 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -228,24 +228,6 @@ boolean isProducer() {
         .toSet();
   }
 
-  private static ImmutableSet<ModuleDescriptor> transitiveModules(
-      Iterable<ModuleDescriptor> topLevelModules) {
-    Set<ModuleDescriptor> transitiveModules = new LinkedHashSet<>();
-    for (ModuleDescriptor module : topLevelModules) {
-      addTransitiveModules(transitiveModules, module);
-    }
-    return ImmutableSet.copyOf(transitiveModules);
-  }
-
-  private static void addTransitiveModules(
-      Set<ModuleDescriptor> transitiveModules, ModuleDescriptor module) {
-    if (transitiveModules.add(module)) {
-      for (ModuleDescriptor includedModule : module.includedModules()) {
-        addTransitiveModules(transitiveModules, includedModule);
-      }
-    }
-  }
-
   /**
    * This component's {@linkplain #dependencies() dependencies} keyed by each provision or
    * production method implemented by that dependency. Note that the dependencies' types are not
@@ -727,6 +709,24 @@ private ModuleDescriptor descriptorForProductionExecutorModule(
           elements.checkTypePresent(productionExecutorModuleName.toString());
       return moduleDescriptorFactory.create(productionExecutorModule);
     }
+
+    private ImmutableSet<ModuleDescriptor> transitiveModules(
+        Iterable<ModuleDescriptor> topLevelModules) {
+      Set<ModuleDescriptor> transitiveModules = new LinkedHashSet<>();
+      for (ModuleDescriptor module : topLevelModules) {
+        addTransitiveModules(transitiveModules, module);
+      }
+      return ImmutableSet.copyOf(transitiveModules);
+    }
+
+    private void addTransitiveModules(
+        Set<ModuleDescriptor> transitiveModules, ModuleDescriptor module) {
+      if (transitiveModules.add(module)) {
+        for (TypeElement includedModule : module.includedModules()) {
+          addTransitiveModules(transitiveModules, moduleDescriptorFactory.create(includedModule));
+        }
+      }
+    }
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index 42e06f230..eee833911 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -47,6 +47,7 @@
 import dagger.internal.codegen.ComponentDescriptor.Kind;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
@@ -220,7 +221,7 @@ public ComponentValidationReport validate(
     }
     builder.addSubreport(
         moduleValidator.validateReferencedModules(
-            subject, componentMirror, componentKind.moduleKinds()));
+            subject, componentMirror, componentKind.moduleKinds(), new HashSet<>()));
 
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
diff --git a/java/dagger/internal/codegen/ModuleDescriptor.java b/java/dagger/internal/codegen/ModuleDescriptor.java
index 3735f8e5e..1210e22ea 100644
--- a/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -26,6 +26,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.SourceFiles.classFileName;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.NONE;
@@ -61,7 +62,7 @@
 
   abstract TypeElement moduleElement();
 
-  abstract ImmutableSet<ModuleDescriptor> includedModules();
+  abstract ImmutableSet<TypeElement> includedModules();
 
   abstract ImmutableSet<ContributionBinding> bindings();
 
@@ -200,8 +201,9 @@ ModuleDescriptor create(TypeElement moduleElement) {
     }
 
     @CanIgnoreReturnValue
-    private Set<ModuleDescriptor> collectIncludedModules(
-        Set<ModuleDescriptor> includedModules, TypeElement moduleElement) {
+    private Set<TypeElement> collectIncludedModules(
+        Set<TypeElement> includedModules,
+        TypeElement moduleElement) {
       TypeMirror superclass = moduleElement.getSuperclass();
       if (!superclass.getKind().equals(NONE)) {
         verify(superclass.getKind().equals(DECLARED));
@@ -212,32 +214,25 @@ ModuleDescriptor create(TypeElement moduleElement) {
       }
       Optional<AnnotationMirror> moduleAnnotation = getModuleAnnotation(moduleElement);
       if (moduleAnnotation.isPresent()) {
-        getModuleIncludes(moduleAnnotation.get())
-            .stream()
-            .map(MoreTypes::asTypeElement)
-            .map(this::create)
-            .forEach(includedModules::add);
-
-        collectImplicitlyIncludedModules(includedModules, moduleElement);
+        includedModules.addAll(MoreTypes.asTypeElements(getModuleIncludes(moduleAnnotation.get())));
+        includedModules.addAll(implicitlyIncludedModules(moduleElement));
       }
       return includedModules;
     }
 
     // @ContributesAndroidInjector generates a module that is implicitly included in the enclosing
     // module
-    private void collectImplicitlyIncludedModules(
-        Set<ModuleDescriptor> includedModules, TypeElement moduleElement) {
+    private ImmutableSet<TypeElement> implicitlyIncludedModules(TypeElement moduleElement) {
       TypeElement contributesAndroidInjector =
           elements.getTypeElement("dagger.android.ContributesAndroidInjector");
       if (contributesAndroidInjector == null) {
-        return;
-      }
-      for (ExecutableElement method : methodsIn(moduleElement.getEnclosedElements())) {
-        if (isAnnotationPresent(method, contributesAndroidInjector.asType())) {
-          includedModules.add(
-              create(elements.checkTypePresent(implicitlyIncludedModuleName(method))));
-        }
+        return ImmutableSet.of();
       }
+      return methodsIn(moduleElement.getEnclosedElements())
+          .stream()
+          .filter(method -> isAnnotationPresent(method, contributesAndroidInjector.asType()))
+          .map(method -> elements.checkTypePresent(implicitlyIncludedModuleName(method)))
+          .collect(toImmutableSet());
     }
 
     private String implicitlyIncludedModuleName(ExecutableElement method) {
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index 4cbad8aca..eadcfe732 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -17,10 +17,12 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.Visibility.PRIVATE;
 import static com.google.auto.common.Visibility.PUBLIC;
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModules;
@@ -79,10 +81,12 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.SimpleAnnotationValueVisitor8;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor8;
 import javax.lang.model.util.Types;
@@ -138,7 +142,7 @@
    *
    * <p>This logic depends on this method being called before {@linkplain #validate(TypeElement)
    * validating} any module or {@linkplain #validateReferencedModules(TypeElement, AnnotationMirror,
-   * ImmutableSet) component}.
+   * ImmutableSet, Set) component}.
    */
   void addKnownModules(Collection<TypeElement> modules) {
     knownModules.addAll(modules);
@@ -146,10 +150,19 @@ void addKnownModules(Collection<TypeElement> modules) {
 
   /** Returns a validation report for a module type. */
   ValidationReport<TypeElement> validate(TypeElement module) {
-    return reentrantComputeIfAbsent(cache, module, this::validateUncached);
+    return validate(module, new HashSet<>());
   }
 
-  private ValidationReport<TypeElement> validateUncached(TypeElement module) {
+  private ValidationReport<TypeElement> validate(
+      TypeElement module, Set<TypeElement> visitedModules) {
+    if (visitedModules.add(module)) {
+      return reentrantComputeIfAbsent(cache, module, m -> validateUncached(module, visitedModules));
+    }
+    return ValidationReport.about(module).build();
+  }
+
+  private ValidationReport<TypeElement> validateUncached(
+      TypeElement module, Set<TypeElement> visitedModules) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(module);
     ModuleDescriptor.Kind moduleKind = ModuleDescriptor.Kind.forAnnotatedElement(module).get();
 
@@ -207,9 +220,10 @@ void addKnownModules(Collection<TypeElement> modules) {
           module, moduleKind, builder, allMethodsByName, bindingMethodsByName);
     }
     validateModifiers(module, builder);
-    validateReferencedModules(module, moduleKind, builder);
+    validateReferencedModules(module, moduleKind, visitedModules, builder);
     validateReferencedSubcomponents(module, moduleKind, builder);
     validateNoScopeAnnotationsOnModuleElement(module, moduleKind, builder);
+    validateSelfCycles(module, builder);
 
     return builder.build();
   }
@@ -309,10 +323,12 @@ private void validateMethodsWithSameName(
   private void validateReferencedModules(
       TypeElement subject,
       ModuleDescriptor.Kind moduleKind,
+      Set<TypeElement> visitedModules,
       ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
     AnnotationMirror mirror = moduleKind.getModuleAnnotationMirror(subject).get();
-    builder.addSubreport(validateReferencedModules(subject, mirror, moduleKind.includesKinds()));
+    builder.addSubreport(
+        validateReferencedModules(subject, mirror, moduleKind.includesKinds(), visitedModules));
   }
 
   /**
@@ -333,7 +349,8 @@ private void validateReferencedModules(
   ValidationReport<TypeElement> validateReferencedModules(
       TypeElement annotatedType,
       AnnotationMirror annotation,
-      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
+      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds,
+      Set<TypeElement> visitedModules) {
     ValidationReport.Builder<TypeElement> subreport = ValidationReport.about(annotatedType);
     ImmutableSet<? extends Class<? extends Annotation>> validModuleAnnotations =
         validModuleKinds
@@ -367,7 +384,8 @@ public Void visitDeclared(DeclaredType t, Void p) {
                                 .stream()
                                 .map(otherClass -> "@" + otherClass.getSimpleName())
                                 .collect(joining(", ")));
-                  } else if (knownModules.contains(module) && !validate(module).isClean()) {
+                  } else if (knownModules.contains(module)
+                      && !validate(module, visitedModules).isClean()) {
                     reportError("%s has errors", module.getQualifiedName());
                   }
                   return null;
@@ -503,6 +521,35 @@ private void validateNoScopeAnnotationsOnModuleElement(
     }
   }
 
+  private void validateSelfCycles(
+      TypeElement module, ValidationReport.Builder<TypeElement> builder) {
+    AnnotationMirror moduleAnnotation = getModuleAnnotation(module).get();
+    getAnnotationValue(moduleAnnotation, "includes")
+        .accept(
+            new SimpleAnnotationValueVisitor8<Void, AnnotationValue>() {
+              @Override
+              public Void visitType(TypeMirror includedModule, AnnotationValue value) {
+                if (MoreTypes.equivalence().equivalent(module.asType(), includedModule)) {
+                  Name moduleKind =
+                      moduleAnnotation.getAnnotationType().asElement().getSimpleName();
+                  builder.addError(
+                      String.format("@%s cannot include themselves.", moduleKind),
+                      module,
+                      moduleAnnotation,
+                      value);
+                }
+                return null;
+              }
+
+              @Override
+              public Void visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
+                values.stream().forEach(value -> value.accept(this, value));
+                return null;
+              }
+            },
+            null);
+  }
+
   private static String formatListForErrorMessage(List<?> things) {
     switch (things.size()) {
       case 0:
diff --git a/javatests/dagger/functional/ModuleCycles.java b/javatests/dagger/functional/ModuleCycles.java
new file mode 100644
index 000000000..9df6685f2
--- /dev/null
+++ b/javatests/dagger/functional/ModuleCycles.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import dagger.Module;
+
+final class ModuleCycles {
+  @Module(includes = ModuleB.class)
+  interface ModuleA {}
+
+  @Module(includes = ModuleA.class)
+  interface ModuleB {}
+
+  @Component(modules = ModuleA.class)
+  interface CycleComponent {}
+}
diff --git a/javatests/dagger/internal/codegen/ModuleValidatorTest.java b/javatests/dagger/internal/codegen/ModuleValidatorTest.java
index e31630aac..ea45f41ac 100644
--- a/javatests/dagger/internal/codegen/ModuleValidatorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleValidatorTest.java
@@ -244,7 +244,7 @@ public void moduleSubcomponentsAreTypes() {
         .in(module)
         .onLine(5);
   }
-  
+
   @Test
   public void tooManyAnnotations() {
     assertThatModuleMethod(
@@ -301,4 +301,41 @@ public void scopeOnModule() {
         .inFile(badModule)
         .onLineContaining("@Singleton");
   }
+
+  @Test
+  public void moduleIncludesSelfCycle() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "import dagger.Provides;",
+            "",
+            String.format("@%s(", moduleType.simpleName()),
+            "  includes = {",
+            "      TestModule.class, // first",
+            "      OtherModule.class,",
+            "      TestModule.class, // second",
+            "  }",
+            ")",
+            "class TestModule {",
+            "  @Provides int i() { return 0; }",
+            "}");
+
+    JavaFileObject otherModule =
+        JavaFileObjects.forSourceLines(
+            "test.OtherModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "class OtherModule {}");
+
+    Compilation compilation = daggerCompiler().compile(module, otherModule);
+    assertThat(compilation).failed();
+    String error = String.format("@%s cannot include themselves", moduleType.simpleName());
+    assertThat(compilation).hadErrorContaining(error).inFile(module).onLineContaining("Module(");
+  }
 }
