diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 18b6af73b..a9d7ef0b4 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -241,7 +241,6 @@ java_library(
     srcs = [
         "AnnotationCreatorGenerator.java",
         "BindingExpression.java",
-        "BindingMethodImplementation.java",
         "ComponentBindingExpressions.java",
         "ComponentCreatorImplementation.java",
         "ComponentImplementation.java",
@@ -257,7 +256,6 @@ java_library(
         "DependencyMethodProducerCreationExpression.java",
         "DependencyMethodProviderCreationExpression.java",
         "DerivedFromFrameworkInstanceBindingExpression.java",
-        "DoubleCheckedMethodImplementation.java",
         "FactoryGenerator.java",
         "FrameworkFieldInitializer.java",
         "FrameworkInstanceBindingExpression.java",
@@ -310,7 +308,6 @@ java_library(
         "SetFactoryCreationExpression.java",
         "SimpleInvocationBindingExpression.java",
         "SimpleMethodBindingExpression.java",
-        "SingleCheckedMethodImplementation.java",
         "SubcomponentBuilderBindingExpression.java",
         "SubcomponentBuilderProviderCreationExpression.java",
         "SubcomponentNames.java",
diff --git a/java/dagger/internal/codegen/BindingMethodImplementation.java b/java/dagger/internal/codegen/BindingMethodImplementation.java
deleted file mode 100644
index 9fc28d031..000000000
--- a/java/dagger/internal/codegen/BindingMethodImplementation.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import com.google.common.base.Supplier;
-import com.squareup.javapoet.CodeBlock;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.model.RequestKind;
-import java.util.Optional;
-import javax.lang.model.type.TypeMirror;
-
-/** Defines a method body and return type for a given {@link BindingExpression}. */
-class BindingMethodImplementation {
-  private final ComponentImplementation component;
-  private final ContributionBinding binding;
-  private final BindingRequest request;
-  private final BindingExpression bindingExpression;
-  private final DaggerTypes types;
-
-  BindingMethodImplementation(
-      ComponentImplementation component,
-      ContributionBinding binding,
-      BindingRequest request,
-      BindingExpression bindingExpression,
-      DaggerTypes types) {
-    this.component = component;
-    this.binding = binding;
-    this.request = request;
-    this.bindingExpression = checkNotNull(bindingExpression);
-    this.types = types;
-  }
-
-  /** The method's body. */
-  final CodeBlock body() {
-    return implementation(bindingExpression.getDependencyExpression(component.name())::codeBlock);
-  }
-
-  /** The method's body if this method is a component method. */
-  final CodeBlock bodyForComponentMethod(ComponentMethodDescriptor componentMethod) {
-    return implementation(
-        bindingExpression.getDependencyExpressionForComponentMethod(componentMethod, component)
-            ::codeBlock);
-  }
-
-  /**
-   * Returns the method body, which contains zero or more statements (including semicolons).
-   *
-   * <p>If the implementation has a non-void return type, the body will also include the {@code
-   * return} statement.
-   *
-   * @param simpleBindingExpression the expression to retrieve an instance of this binding without
-   *     the wrapping method.
-   */
-  CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression) {
-    return CodeBlock.of("return $L;", simpleBindingExpression.get());
-  }
-
-  /** Returns the return type for the dependency request. */
-  final TypeMirror returnType() {
-    if (request.isRequestKind(RequestKind.INSTANCE)
-        && binding.contributedPrimitiveType().isPresent()) {
-      return binding.contributedPrimitiveType().get();
-    }
-
-    if (matchingComponentMethod().isPresent()) {
-      // Component methods are part of the user-defined API, and thus we must use the user-defined
-      // type.
-      return matchingComponentMethod().get().resolvedReturnType(types);
-    }
-
-    // If the component is abstract, this method may be overridden by another implementation in a
-    // different package for which requestedType is inaccessible. In order to make that method
-    // overridable, we use the publicly accessible type. If the type is final, we don't need to 
-    // worry about this, and instead just need to check accessibility of the file we're about to
-    // write
-    TypeMirror requestedType = request.requestedType(binding.contributedType(), types);
-    return component.isAbstract()
-        ? types.publiclyAccessibleType(requestedType)
-        : types.accessibleType(requestedType, component.name());
-  }
-
-  private Optional<ComponentMethodDescriptor> matchingComponentMethod() {
-    return component.componentDescriptor().firstMatchingComponentMethod(request);
-  }
-}
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 999cae3fa..8c47d59c6 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -41,6 +41,7 @@
 import com.squareup.javapoet.MethodSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.MethodBindingExpression.MethodImplementationStrategy;
 import dagger.model.DependencyRequest;
 import dagger.model.RequestKind;
 import java.util.HashMap;
@@ -629,8 +630,8 @@ BindingExpression wrapInMethod(
       return bindingExpression;
     }
 
-    BindingMethodImplementation methodImplementation =
-        methodImplementation(resolvedBindings, request, bindingExpression);
+    MethodImplementationStrategy methodImplementationStrategy =
+        methodImplementationStrategy(resolvedBindings, request);
     Optional<ComponentMethodDescriptor> matchingComponentMethod =
         graph.componentDescriptor().firstMatchingComponentMethod(request);
 
@@ -638,39 +639,40 @@ BindingExpression wrapInMethod(
         && (componentImplementation.superclassImplementation().isPresent()
             || !matchingComponentMethod.isPresent())) {
       return modifiableBindingExpressions.wrapInModifiableMethodBindingExpression(
-          request, methodImplementation);
+          request, resolvedBindings, methodImplementationStrategy, bindingExpression);
     } else if (matchingComponentMethod.isPresent()) {
       ComponentMethodDescriptor componentMethod = matchingComponentMethod.get();
       return new ComponentMethodBindingExpression(
-          request, methodImplementation, componentImplementation, componentMethod, types);
+          request,
+          resolvedBindings,
+          methodImplementationStrategy,
+          bindingExpression,
+          componentImplementation,
+          componentMethod,
+          types);
     } else {
       return new PrivateMethodBindingExpression(
-          request, methodImplementation, componentImplementation, types);
+          request,
+          resolvedBindings,
+          methodImplementationStrategy,
+          bindingExpression,
+          componentImplementation,
+          types);
     }
   }
 
-  // TODO(ronshapiro): pass ContributionBinding directly instead of ResolvedBindings. The
-  // ResolvedBindings type is only needed in one case, and it seems like it could be removed.
-  private BindingMethodImplementation methodImplementation(
-      ResolvedBindings resolvedBindings,
-      BindingRequest request,
-      BindingExpression bindingExpression) {
-    ContributionBinding binding = resolvedBindings.contributionBinding();
+  private MethodImplementationStrategy methodImplementationStrategy(
+      ResolvedBindings resolvedBindings, BindingRequest request) {
     if (compilerOptions.fastInit()) {
       if (request.isRequestKind(RequestKind.PROVIDER)) {
-        return new SingleCheckedMethodImplementation(
-            componentImplementation, resolvedBindings, request, bindingExpression, types);
+        return MethodImplementationStrategy.SINGLE_CHECK;
       } else if (request.isRequestKind(RequestKind.INSTANCE) && needsCaching(resolvedBindings)) {
         return resolvedBindings.scope().get().isReusable()
-            ? new SingleCheckedMethodImplementation(
-                componentImplementation, resolvedBindings, request, bindingExpression, types)
-            : new DoubleCheckedMethodImplementation(
-                componentImplementation, binding, request, bindingExpression, types);
+            ? MethodImplementationStrategy.SINGLE_CHECK
+            : MethodImplementationStrategy.DOUBLE_CHECK;
       }
     }
-
-    return new BindingMethodImplementation(
-        componentImplementation, binding, request, bindingExpression, types);
+    return MethodImplementationStrategy.SIMPLE;
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index e5e5c271f..f9e0b5ab4 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -29,18 +29,24 @@
  * <p>Dependents of this binding expression will just call the component method.
  */
 final class ComponentMethodBindingExpression extends MethodBindingExpression {
-  private final BindingMethodImplementation methodImplementation;
   private final ComponentImplementation componentImplementation;
   private final ComponentMethodDescriptor componentMethod;
 
   ComponentMethodBindingExpression(
       BindingRequest request,
-      BindingMethodImplementation methodImplementation,
+      ResolvedBindings resolvedBindings,
+      MethodImplementationStrategy methodImplementationStrategy,
+      BindingExpression wrappedBindingExpression,
       ComponentImplementation componentImplementation,
       ComponentMethodDescriptor componentMethod,
       DaggerTypes types) {
-    super(request, methodImplementation, componentImplementation, types);
-    this.methodImplementation = checkNotNull(methodImplementation);
+    super(
+        request,
+        resolvedBindings,
+        methodImplementationStrategy,
+        wrappedBindingExpression,
+        componentImplementation,
+        types);
     this.componentImplementation = checkNotNull(componentImplementation);
     this.componentMethod = checkNotNull(componentMethod);
   }
@@ -58,7 +64,7 @@ protected CodeBlock getComponentMethodImplementation(
     // the child's can delegate to the parent. So use methodImplementation.body() only if
     // componentName equals the component for this instance.
     return componentMethod.equals(this.componentMethod) && component.equals(componentImplementation)
-        ? methodImplementation.bodyForComponentMethod(componentMethod)
+        ? methodBodyForComponentMethod(componentMethod)
         : super.getComponentMethodImplementation(componentMethod, component);
   }
 
diff --git a/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java b/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
deleted file mode 100644
index 6b56c0e9c..000000000
--- a/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.VOLATILE;
-
-import com.google.common.base.Supplier;
-import com.google.common.base.Suppliers;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
-import com.squareup.javapoet.TypeName;
-import dagger.internal.DoubleCheck;
-import dagger.internal.MemoizedSentinel;
-
-/**
- * Defines a method body and return type for double checked locking of the given {@link
- * BindingExpression}.
- */
-final class DoubleCheckedMethodImplementation extends BindingMethodImplementation {
-
-  private final ComponentImplementation componentImplementation;
-  private final ContributionBinding binding;
-  private final Supplier<String> fieldName = Suppliers.memoize(this::createField);
-
-  DoubleCheckedMethodImplementation(
-      ComponentImplementation component,
-      ContributionBinding binding,
-      BindingRequest request,
-      BindingExpression bindingExpression,
-      DaggerTypes types) {
-    super(component, binding, request, bindingExpression, types);
-    this.componentImplementation = checkNotNull(component);
-    this.binding = checkNotNull(binding);
-  }
-
-  @Override
-  CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression) {
-    String fieldExpression = fieldName.get().equals("local") ? "this.local" : fieldName.get();
-    return CodeBlock.builder()
-        .addStatement("$T local = $L", TypeName.OBJECT, fieldExpression)
-        .beginControlFlow("if (local instanceof $T)", MemoizedSentinel.class)
-        .beginControlFlow("synchronized (local)")
-        .addStatement("local = $L", fieldExpression)
-        .beginControlFlow("if (local instanceof $T)", MemoizedSentinel.class)
-        .addStatement("local = $L", simpleBindingExpression.get())
-        .addStatement("$1L = $2T.reentrantCheck($1L, local)", fieldExpression, DoubleCheck.class)
-        .endControlFlow()
-        .endControlFlow()
-        .endControlFlow()
-        .addStatement("return ($T) local", returnType())
-        .build();
-  }
-
-  private String createField() {
-    String name = componentImplementation.getUniqueFieldName(KeyVariableNamer.name(binding.key()));
-    componentImplementation.addField(
-        PRIVATE_METHOD_SCOPED_FIELD,
-        FieldSpec.builder(TypeName.OBJECT, name, PRIVATE, VOLATILE)
-            .initializer("new $T()", MemoizedSentinel.class)
-            .build());
-    return name;
-  }
-}
diff --git a/java/dagger/internal/codegen/MethodBindingExpression.java b/java/dagger/internal/codegen/MethodBindingExpression.java
index d51fc9866..05f241e74 100644
--- a/java/dagger/internal/codegen/MethodBindingExpression.java
+++ b/java/dagger/internal/codegen/MethodBindingExpression.java
@@ -18,29 +18,50 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.VOLATILE;
 
+import com.google.common.base.Supplier;
+import com.google.common.base.Suppliers;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.TypeName;
+import dagger.internal.DoubleCheck;
+import dagger.internal.MemoizedSentinel;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.model.RequestKind;
 import java.util.Optional;
+import javax.lang.model.type.TypeMirror;
 
 /** A binding expression that wraps another in a nullary method on the component. */
 abstract class MethodBindingExpression extends BindingExpression {
   private final BindingRequest request;
-  private final BindingMethodImplementation methodImplementation;
+  private final ResolvedBindings resolvedBindings;
+  private final ContributionBinding binding;
+  private final BindingMethodImplementation bindingMethodImplementation;
   private final ComponentImplementation componentImplementation;
   private final ProducerEntryPointView producerEntryPointView;
+  private final BindingExpression wrappedBindingExpression;
+  private final DaggerTypes types;
 
   protected MethodBindingExpression(
       BindingRequest request,
-      BindingMethodImplementation methodImplementation,
+      ResolvedBindings resolvedBindings,
+      MethodImplementationStrategy methodImplementationStrategy,
+      BindingExpression wrappedBindingExpression,
       ComponentImplementation componentImplementation,
       DaggerTypes types) {
     this.request = checkNotNull(request);
-    this.methodImplementation = checkNotNull(methodImplementation);
+    this.resolvedBindings = resolvedBindings;
+    this.binding = resolvedBindings.contributionBinding();
+    this.bindingMethodImplementation = bindingMethodImplementation(methodImplementationStrategy);
+    this.wrappedBindingExpression = checkNotNull(wrappedBindingExpression);
     this.componentImplementation = checkNotNull(componentImplementation);
     this.producerEntryPointView = new ProducerEntryPointView(types);
+    this.types = checkNotNull(types);
   }
 
   @Override
@@ -53,12 +74,12 @@ Expression getDependencyExpression(ClassName requestingClass) {
       // around that weirdness - methodImplementation.body() will invoke the framework instance
       // initialization again in case the field is not fully initialized.
       // TODO(b/121196706): use a less hacky approach to fix this bug
-      Object unused = methodImplementation.body();
+      Object unused = methodBody();
     }
     
     addMethod();
     return Expression.create(
-        methodImplementation.returnType(),
+        returnType(),
         requestingClass.equals(componentImplementation.name())
             ? CodeBlock.of("$N()", methodName())
             : CodeBlock.of("$T.this.$N()", componentImplementation.name(), methodName()));
@@ -76,7 +97,7 @@ final CodeBlock getModifiableBindingMethodImplementation(
     if (supertypeModifiableBindingMethod().isPresent()) {
       checkState(
           supertypeModifiableBindingMethod().get().fulfillsSameRequestAs(modifiableBindingMethod));
-      return methodImplementation.body();
+      return methodBody();
     }
     return super.getModifiableBindingMethodImplementation(
         modifiableBindingMethod, component, types);
@@ -100,4 +121,198 @@ Expression getDependencyExpressionForComponentMethod(ComponentMethodDescriptor c
 
   /** Returns the name of the method to call. */
   protected abstract String methodName();
+
+  /** Returns {@code true} if the method of this binding expression is {@code private}. */
+  protected boolean isPrivateMethod() {
+    return false;
+  }
+
+  /** The method's body. */
+  protected final CodeBlock methodBody() {
+    return implementation(
+        wrappedBindingExpression.getDependencyExpression(componentImplementation.name())
+            ::codeBlock);
+  }
+
+  /** The method's body if this method is a component method. */
+  protected final CodeBlock methodBodyForComponentMethod(
+      ComponentMethodDescriptor componentMethod) {
+    return implementation(
+        wrappedBindingExpression.getDependencyExpressionForComponentMethod(
+                componentMethod, componentImplementation)
+            ::codeBlock);
+  }
+
+  private CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression) {
+    return bindingMethodImplementation.implementation(simpleBindingExpression);
+  }
+
+  private BindingMethodImplementation bindingMethodImplementation(
+      MethodImplementationStrategy methodImplementationStrategy) {
+    switch (methodImplementationStrategy) {
+      case SIMPLE:
+        return new SimpleMethodImplementation();
+      case SINGLE_CHECK:
+        return new SingleCheckedMethodImplementation();
+      case DOUBLE_CHECK:
+        return new DoubleCheckedMethodImplementation();
+    }
+    throw new AssertionError(methodImplementationStrategy);
+  }
+
+  /** Returns the return type for the dependency request. */
+  protected TypeMirror returnType() {
+    if (request.isRequestKind(RequestKind.INSTANCE)
+        && binding.contributedPrimitiveType().isPresent()) {
+      return binding.contributedPrimitiveType().get();
+    }
+
+    if (matchingComponentMethod().isPresent()) {
+      // Component methods are part of the user-defined API, and thus we must use the user-defined
+      // type.
+      return matchingComponentMethod().get().resolvedReturnType(types);
+    }
+
+    // If the component is abstract, this method may be overridden by another implementation in a
+    // different package for which requestedType is inaccessible. In order to make that method
+    // overridable, we use the publicly accessible type. If the method is private, we don't need to
+    // worry about this, and instead just need to check accessibility of the file we're about to
+    // write
+    TypeMirror requestedType = request.requestedType(binding.contributedType(), types);
+    return componentImplementation.isAbstract() && !isPrivateMethod()
+        ? types.publiclyAccessibleType(requestedType)
+        : types.accessibleType(requestedType, componentImplementation.name());
+  }
+
+  private Optional<ComponentMethodDescriptor> matchingComponentMethod() {
+    return componentImplementation.componentDescriptor().firstMatchingComponentMethod(request);
+  }
+
+  /** Strateg for implementing the body of this method. */
+  enum MethodImplementationStrategy {
+    SIMPLE,
+    SINGLE_CHECK,
+    DOUBLE_CHECK,
+    ;
+  }
+
+  private abstract static class BindingMethodImplementation {
+    /**
+     * Returns the method body, which contains zero or more statements (including semicolons).
+     *
+     * <p>If the implementation has a non-void return type, the body will also include the {@code
+     * return} statement.
+     *
+     * @param simpleBindingExpression the expression to retrieve an instance of this binding without
+     *     the wrapping method.
+     */
+    abstract CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression);
+  }
+
+  /** Returns the {@code wrappedBindingExpression} directly. */
+  private static final class SimpleMethodImplementation extends BindingMethodImplementation {
+    @Override
+    CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression) {
+      return CodeBlock.of("return $L;", simpleBindingExpression.get());
+    }
+  }
+
+  /**
+   * Defines a method body for single checked caching of the given {@code wrappedBindingExpression}.
+   */
+  private final class SingleCheckedMethodImplementation extends BindingMethodImplementation {
+    private final Supplier<FieldSpec> field = Suppliers.memoize(this::createField);
+
+    @Override
+    CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression) {
+      String fieldExpression = field.get().name.equals("local") ? "this.local" : field.get().name;
+
+      CodeBlock.Builder builder = CodeBlock.builder()
+          .addStatement("Object local = $N", fieldExpression);
+
+      if (isNullable()) {
+        builder.beginControlFlow("if (local instanceof $T)", MemoizedSentinel.class);
+      } else {
+        builder.beginControlFlow("if (local == null)");
+      }
+
+      return builder
+          .addStatement("local = $L", simpleBindingExpression.get())
+          .addStatement("$N = ($T) local", fieldExpression, returnType())
+          .endControlFlow()
+          .addStatement("return ($T) local", returnType())
+          .build();
+    }
+
+    FieldSpec createField() {
+      String name =
+          componentImplementation.getUniqueFieldName(
+              request.isRequestKind(RequestKind.INSTANCE)
+                  ? KeyVariableNamer.name(binding.key())
+                  // TODO(ronshapiro): Use KeyVariableNamer directly so we don't need to use a
+                  // ResolvedBindings instance and construct a whole framework field just to get the
+                  // name
+                  : FrameworkField.forResolvedBindings(resolvedBindings, Optional.empty()).name());
+
+      FieldSpec.Builder builder = FieldSpec.builder(fieldType(), name, PRIVATE, VOLATILE);
+      if (isNullable()) {
+        builder.initializer("new $T()", MemoizedSentinel.class);
+      }
+
+      FieldSpec field = builder.build();
+      componentImplementation.addField(PRIVATE_METHOD_SCOPED_FIELD, field);
+      return field;
+    }
+
+    TypeName fieldType() {
+      if (isNullable()) {
+        // Nullable instances use `MemoizedSentinel` instead of `null` as the initialization value,
+        // so the field type must accept that and the return type
+        return TypeName.OBJECT;
+      }
+      TypeName returnType = TypeName.get(returnType());
+      return returnType.isPrimitive() ? returnType.box() : returnType;
+    }
+
+    private boolean isNullable() {
+      return request.isRequestKind(RequestKind.INSTANCE) && binding.isNullable();
+    }
+  }
+
+  /**
+   * Defines a method body for double checked caching of the given {@code wrappedBindingExpression}.
+   */
+  private final class DoubleCheckedMethodImplementation extends BindingMethodImplementation {
+    private final Supplier<String> fieldName = Suppliers.memoize(this::createField);
+
+    @Override
+    CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression) {
+      String fieldExpression = fieldName.get().equals("local") ? "this.local" : fieldName.get();
+      return CodeBlock.builder()
+          .addStatement("$T local = $L", TypeName.OBJECT, fieldExpression)
+          .beginControlFlow("if (local instanceof $T)", MemoizedSentinel.class)
+          .beginControlFlow("synchronized (local)")
+          .addStatement("local = $L", fieldExpression)
+          .beginControlFlow("if (local instanceof $T)", MemoizedSentinel.class)
+          .addStatement("local = $L", simpleBindingExpression.get())
+          .addStatement("$1L = $2T.reentrantCheck($1L, local)", fieldExpression, DoubleCheck.class)
+          .endControlFlow()
+          .endControlFlow()
+          .endControlFlow()
+          .addStatement("return ($T) local", returnType())
+          .build();
+    }
+
+    private String createField() {
+      String name =
+          componentImplementation.getUniqueFieldName(KeyVariableNamer.name(binding.key()));
+      componentImplementation.addField(
+          PRIVATE_METHOD_SCOPED_FIELD,
+          FieldSpec.builder(TypeName.OBJECT, name, PRIVATE, VOLATILE)
+              .initializer("new $T()", MemoizedSentinel.class)
+              .build());
+      return name;
+    }
+  }
+
 }
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index 59c547fbf..07f622791 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -26,6 +26,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.MethodSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.MethodBindingExpression.MethodImplementationStrategy;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
@@ -433,13 +434,18 @@ private boolean resolvedInThisComponent(BindingRequest request) {
    * implementation.
    */
   BindingExpression wrapInModifiableMethodBindingExpression(
-      BindingRequest request, BindingMethodImplementation methodImplementation) {
+      BindingRequest request,
+      ResolvedBindings resolvedBindings,
+      MethodImplementationStrategy methodImplementationStrategy,
+      BindingExpression wrappedBindingExpression) {
     ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
     checkState(modifiableBindingType.isModifiable());
     return new ModifiableConcreteMethodBindingExpression(
         request,
+        resolvedBindings,
+        methodImplementationStrategy,
+        wrappedBindingExpression,
         modifiableBindingType,
-        methodImplementation,
         componentImplementation,
         newModifiableBindingWillBeFinalized(modifiableBindingType, request),
         types);
diff --git a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
index 8f5e109c0..e8cdf9bd7 100644
--- a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
@@ -34,22 +34,28 @@
 
   private final BindingRequest request;
   private final ModifiableBindingType modifiableBindingType;
-  private final BindingMethodImplementation methodImplementation;
   private final ComponentImplementation componentImplementation;
   private final boolean bindingCannotBeModified;
   private Optional<String> methodName = Optional.empty();
 
   ModifiableConcreteMethodBindingExpression(
       BindingRequest request,
+      ResolvedBindings resolvedBindings,
+      MethodImplementationStrategy methodImplementationStrategy,
+      BindingExpression wrappedBindingExpression,
       ModifiableBindingType modifiableBindingType,
-      BindingMethodImplementation methodImplementation,
       ComponentImplementation componentImplementation,
       boolean bindingCannotBeModified,
       DaggerTypes types) {
-    super(request, methodImplementation, componentImplementation, types);
+    super(
+        request,
+        resolvedBindings,
+        methodImplementationStrategy,
+        wrappedBindingExpression,
+        componentImplementation,
+        types);
     this.request = checkNotNull(request);
     this.modifiableBindingType = checkNotNull(modifiableBindingType);
-    this.methodImplementation = checkNotNull(methodImplementation);
     this.componentImplementation = checkNotNull(componentImplementation);
     this.bindingCannotBeModified = bindingCannotBeModified;
   }
@@ -70,11 +76,11 @@ protected void addMethod() {
     componentImplementation.addModifiableBindingMethod(
         modifiableBindingType,
         request,
-        methodImplementation.returnType(),
+        returnType(),
         methodBuilder(methodName.get())
             .addModifiers(bindingCannotBeModified ? PRIVATE : PROTECTED)
-            .returns(TypeName.get(methodImplementation.returnType()))
-            .addCode(methodImplementation.body())
+            .returns(TypeName.get(returnType()))
+            .addCode(methodBody())
             .build(),
         bindingCannotBeModified);
   }
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 9e87b1d2d..cb4a6d8b1 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -31,18 +31,24 @@
  */
 final class PrivateMethodBindingExpression extends MethodBindingExpression {
   private final BindingRequest request;
-  private final BindingMethodImplementation methodImplementation;
   private final ComponentImplementation componentImplementation;
   private String methodName;
 
   PrivateMethodBindingExpression(
       BindingRequest request,
-      BindingMethodImplementation methodImplementation,
+      ResolvedBindings resolvedBindings,
+      MethodImplementationStrategy methodImplementationStrategy,
+      BindingExpression wrappedBindingExpression,
       ComponentImplementation componentImplementation,
       DaggerTypes types) {
-    super(request, methodImplementation, componentImplementation, types);
+    super(
+        request,
+        resolvedBindings,
+        methodImplementationStrategy,
+        wrappedBindingExpression,
+        componentImplementation,
+        types);
     this.request = checkNotNull(request);
-    this.methodImplementation = checkNotNull(methodImplementation);
     this.componentImplementation = checkNotNull(componentImplementation);
   }
 
@@ -56,8 +62,8 @@ protected void addMethod() {
           PRIVATE_METHOD,
           methodBuilder(methodName)
               .addModifiers(PRIVATE)
-              .returns(TypeName.get(methodImplementation.returnType()))
-              .addCode(methodImplementation.body())
+              .returns(TypeName.get(returnType()))
+              .addCode(methodBody())
               .build());
     }
   }
@@ -67,4 +73,9 @@ protected String methodName() {
     checkState(methodName != null, "addMethod() must be called before methodName()");
     return methodName;
   }
+
+  @Override
+  protected boolean isPrivateMethod() {
+    return true;
+  }
 }
diff --git a/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java b/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
deleted file mode 100644
index 0804a2060..000000000
--- a/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.VOLATILE;
-
-import com.google.common.base.Supplier;
-import com.google.common.base.Suppliers;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
-import com.squareup.javapoet.TypeName;
-import dagger.internal.MemoizedSentinel;
-import dagger.model.RequestKind;
-import java.util.Optional;
-
-/**
- * Defines a method body and return type for single checked caching of the given {@link
- * BindingExpression}.
- */
-final class SingleCheckedMethodImplementation extends BindingMethodImplementation {
-
-  private final ComponentImplementation componentImplementation;
-  private final ResolvedBindings resolvedBindings;
-  private final ContributionBinding binding;
-  private final BindingRequest request;
-  private final Supplier<FieldSpec> field = Suppliers.memoize(this::createField);
-
-  SingleCheckedMethodImplementation(
-      ComponentImplementation component,
-      ResolvedBindings resolvedBindings,
-      BindingRequest request,
-      BindingExpression bindingExpression,
-      DaggerTypes types) {
-    super(component, resolvedBindings.contributionBinding(), request, bindingExpression, types);
-    this.componentImplementation = checkNotNull(component);
-    this.resolvedBindings = resolvedBindings;
-    this.binding = resolvedBindings.contributionBinding();
-    this.request = checkNotNull(request);
-  }
-
-  @Override
-  CodeBlock implementation(Supplier<CodeBlock> simpleBindingExpression) {
-    String fieldExpression = field.get().name.equals("local") ? "this.local" : field.get().name;
-
-    CodeBlock.Builder builder = CodeBlock.builder()
-        .addStatement("Object local = $N", fieldExpression);
-
-    if (isNullable()) {
-      builder.beginControlFlow("if (local instanceof $T)", MemoizedSentinel.class);
-    } else {
-      builder.beginControlFlow("if (local == null)");
-    }
-
-    return builder
-        .addStatement("local = $L", simpleBindingExpression.get())
-        .addStatement("$N = ($T) local", fieldExpression, returnType())
-        .endControlFlow()
-        .addStatement("return ($T) local", returnType())
-        .build();
-  }
-
-  private FieldSpec createField() {
-    String name =
-        componentImplementation.getUniqueFieldName(
-            request.isRequestKind(RequestKind.INSTANCE)
-                ? KeyVariableNamer.name(binding.key())
-                : FrameworkField.forResolvedBindings(resolvedBindings, Optional.empty()).name());
-
-    FieldSpec.Builder builder = FieldSpec.builder(fieldType(), name, PRIVATE, VOLATILE);
-    if (isNullable()) {
-      builder.initializer("new $T()", MemoizedSentinel.class);
-    }
-
-    FieldSpec field = builder.build();
-    componentImplementation.addField(PRIVATE_METHOD_SCOPED_FIELD, field);
-    return field;
-  }
-
-  private TypeName fieldType() {
-    if (isNullable()) {
-      // Nullable instances use `MemoizedSentinel` instead of `null` as the initialization value, so
-      // the field type must accept that and the return type
-      return TypeName.OBJECT;
-    }
-    TypeName returnType = TypeName.get(returnType());
-    return returnType.isPrimitive() ? returnType.box() : returnType;
-  }
-
-  private boolean isNullable() {
-    return request.isRequestKind(RequestKind.INSTANCE) && binding.isNullable();
-  }
-}
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java
new file mode 100644
index 000000000..079b5a0d8
--- /dev/null
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java
@@ -0,0 +1,2578 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.CompilerMode.AHEAD_OF_TIME_SUBCOMPONENTS_MODE;
+import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
+import static dagger.internal.codegen.Compilers.CLASS_PATH_WITHOUT_GUAVA_OPTION;
+import static dagger.internal.codegen.Compilers.compilerWithOptions;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class AheadOfTimeSubcomponentsMultibindingsTest {
+  @Test
+  public void setMultibindings_contributionsInLeaf() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InLeaf");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<InLeaf> contributionsInLeaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InLeaf provideInLeaf() {",
+            "    return new InLeaf();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<InLeaf> contributionsInLeaf() {",
+            "    return ImmutableSet.<InLeaf>of(",
+            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+  }
+
+  @Test
+  public void setMultibindings_contributionsInAncestorOnly() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  Set<InAncestor> contributionsInAncestor();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @ElementsIntoSet",
+            "  static Set<InAncestor> provideInAncestors() {",
+            "    return ImmutableSet.of(new InAncestor(), new InAncestor());",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Set<InAncestor> contributionsInAncestor() {",
+            "      return ImmutableSet.<InAncestor>copyOf(",
+            "          AncestorModule_ProvideInAncestorsFactory.proxyProvideInAncestors());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void setMultibindings_contributionsInLeafAndAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<InEachSubcomponent> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InEachSubcomponent provideAnotherInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "    return ImmutableSet.<InEachSubcomponent>of(",
+            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf(),",
+            "        LeafModule_ProvideAnotherInLeafFactory.proxyProvideAnotherInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @ElementsIntoSet",
+            "  static Set<InEachSubcomponent> provideInAncestor() {",
+            "    return ImmutableSet.of(new InEachSubcomponent(), new InEachSubcomponent());",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Set<InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "      return ImmutableSet.<InEachSubcomponent>builderWithExpectedSize(3)",
+            "          .addAll(AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
+            "          .addAll(super.contributionsInEachSubcomponent())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void setMultibindings_contributionsInLeafAndGrandAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InLeafAndGrandAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InLeafAndGrandAncestor provideInLeaf() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InLeafAndGrandAncestor provideAnotherInLeaf() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
+            "    return ImmutableSet.<InLeafAndGrandAncestor>of(",
+            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf(),",
+            "        LeafModule_ProvideAnotherInLeafFactory.proxyProvideAnotherInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = GrandAncestorModule.class)",
+            "interface GrandAncestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestorModule",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class GrandAncestorModule {",
+            "  @Provides",
+            "  @ElementsIntoSet",
+            "  static Set<InLeafAndGrandAncestor> provideInGrandAncestor() {",
+            "    return ImmutableSet.of(new InLeafAndGrandAncestor(),",
+            "        new InLeafAndGrandAncestor());",
+            "  }",
+            "}"));
+    JavaFileObject generatedGrandAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
+            "  protected DaggerGrandAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
+            "      return ImmutableSet.<InLeafAndGrandAncestor>builderWithExpectedSize(3)",
+            "          .addAll(GrandAncestorModule_ProvideInGrandAncestorFactory",
+            "              .proxyProvideInGrandAncestor())",
+            "          .addAll(super.contributionsInLeafAndGrandAncestor())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandAncestor")
+        .hasSourceEquivalentTo(generatedGrandAncestor);
+  }
+
+  @Test
+  public void setMultibindings_nonComponentMethodDependency() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InAllSubcomponents", "RequresInAllSubcomponentsSet");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  RequresInAllSubcomponentsSet requiresNonComponentMethod();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "    return new InAllSubcomponents();",
+            "  }",
+            "",
+            "  @Provides",
+            "  static RequresInAllSubcomponentsSet providesRequresInAllSubcomponentsSet(",
+            "      Set<InAllSubcomponents> inAllSubcomponents) {",
+            "    return new RequresInAllSubcomponentsSet();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public RequresInAllSubcomponentsSet requiresNonComponentMethod() {",
+            "    return LeafModule_ProvidesRequresInAllSubcomponentsSetFactory",
+            "        .proxyProvidesRequresInAllSubcomponentsSet(getSetOfInAllSubcomponents());",
+            "  }",
+            "",
+            "  protected Set getSetOfInAllSubcomponents() {",
+            "    return ImmutableSet.<InAllSubcomponents>of(",
+            "        LeafModule_ProvideInAllSubcomponentsFactory",
+            "            .proxyProvideInAllSubcomponents());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "      return new InAllSubcomponents();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected Set getSetOfInAllSubcomponents() {",
+            "      return ImmutableSet.<InAllSubcomponents>builderWithExpectedSize(2)",
+            "          .add(AncestorModule_ProvideInAllSubcomponentsFactory",
+            "              .proxyProvideInAllSubcomponents())",
+            "          .addAll(super.getSetOfInAllSubcomponents())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void setMultibindings_newSubclass() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InAncestor", "RequiresInAncestorSet");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  RequiresInAncestorSet missingWithSetDependency();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "",
+            "  @Provides",
+            "  static RequiresInAncestorSet provideRequiresInAncestorSet(",
+            "      Set<InAncestor> inAncestors) {",
+            "    return new RequiresInAncestorSet();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InAncestor provideInAncestor() {",
+            "    return new InAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  private RequiresInAncestorSet getRequiresInAncestorSet() {",
+            "    return AncestorModule_ProvideRequiresInAncestorSetFactory",
+            "        .proxyProvideRequiresInAncestorSet(getSetOfInAncestor());",
+            "  }",
+            "",
+            "  protected Set getSetOfInAncestor() {",
+            "    return ImmutableSet.<InAncestor>of(",
+            "        AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor());",
+            "  }",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public final RequiresInAncestorSet missingWithSetDependency() {",
+            "      return DaggerAncestor.this.getRequiresInAncestorSet();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void setMultibinding_requestedAsInstanceInLeaf_requestedAsFrameworkInstanceFromAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(
+        filesToCompile, "Multibound", "MissingInLeaf_WillDependOnFrameworkInstance");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<Multibound> instance();",
+            "  MissingInLeaf_WillDependOnFrameworkInstance willDependOnFrameworkInstance();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Multibound contribution() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<Multibound> instance() {",
+            "    return ImmutableSet.<Multibound>of(",
+            "        LeafModule_ContributionFactory.proxyContribution());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "interface AncestorModule {",
+            "  @Provides",
+            "  static MissingInLeaf_WillDependOnFrameworkInstance providedInAncestor(",
+            "      Provider<Set<Multibound>> frameworkInstance) {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Multibinds Set<Multibound> multibinds();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Set<Multibound>> setOfMultiboundProvider;",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    protected void configureInitialization() { ",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() { ",
+            "      this.setOfMultiboundProvider =",
+            "          SetFactory.<Multibound>builder(1, 0)",
+            "              .addProvider(LeafModule_ContributionFactory.create())",
+            "              .build();",
+            "    }",
+            "",
+            "    protected Provider getSetOfMultiboundProvider() {",
+            "      return setOfMultiboundProvider;",
+            "    }",
+            "",
+            "    @Override",
+            "    public final MissingInLeaf_WillDependOnFrameworkInstance ",
+            "        willDependOnFrameworkInstance() {",
+            "      return AncestorModule_ProvidedInAncestorFactory.proxyProvidedInAncestor(",
+            "          getSetOfMultiboundProvider());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void setMultibindings_contributionsInLeafAndAncestor_frameworkInstances() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InEachSubcomponent provideAnotherInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private Provider<Set<InEachSubcomponent>> setOfInEachSubcomponentProvider;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.setOfInEachSubcomponentProvider =",
+            "        SetFactory.<InEachSubcomponent>builder(2, 0)",
+            "            .addProvider(LeafModule_ProvideInLeafFactory.create())",
+            "            .addProvider(LeafModule_ProvideAnotherInLeafFactory.create())",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent() {",
+            "    return setOfInEachSubcomponentProvider;",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @ElementsIntoSet",
+            "  static Set<InEachSubcomponent> provideInAncestor() {",
+            "    return ImmutableSet.of(new InEachSubcomponent(), new InEachSubcomponent());",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.DelegateFactory;",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Set<InEachSubcomponent>> setOfInEachSubcomponentProvider = ",
+            "        new DelegateFactory<>();",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected void configureInitialization() {",
+            "      super.configureInitialization();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      DelegateFactory.setDelegate(",
+            "          setOfInEachSubcomponentProvider,",
+            "          SetFactory.<InEachSubcomponent>builder(0, 2)",
+            "              .addCollectionProvider(super.contributionsInEachSubcomponent())",
+            "              .addCollectionProvider(",
+            "                  AncestorModule_ProvideInAncestorFactory.create())",
+            "              .build());",
+            "    }",
+            "",
+            "    @Override",
+            "    public Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent() {",
+            "      return setOfInEachSubcomponentProvider;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeaf() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InLeaf");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InLeaf> contributionsInLeaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InLeaf provideInLeaf() {",
+            "    return new InLeaf();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InLeaf> contributionsInLeaf() {",
+            "    return ImmutableMap.<String, InLeaf>of(",
+            "        \"leafmodule\",",
+            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInAncestorOnly() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  Map<String, InAncestor> contributionsInAncestor();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"ancestormodule\")",
+            "  static InAncestor provideInAncestor() {",
+            "    return new InAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<String, InAncestor> contributionsInAncestor() {",
+            "      return ImmutableMap.<String, InAncestor>of(\"ancestormodule\",",
+            "          AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeafAndAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InEachSubcomponent> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "    return ImmutableMap.<String, InEachSubcomponent>of(",
+            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"ancestormodule\")",
+            "  static InEachSubcomponent provideInAncestor() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "      return ImmutableMap.<String, InEachSubcomponent>builderWithExpectedSize(2)",
+            "          .put(\"ancestormodule\",",
+            "              AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
+            "          .putAll(super.contributionsInEachSubcomponent())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeafAndAncestor_frameworkInstance() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Provider<Map<String, InEachSubcomponent>> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private Provider<Map<String, InEachSubcomponent>> ",
+            "    mapOfStringAndInEachSubcomponentProvider;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.mapOfStringAndInEachSubcomponentProvider =",
+            "        MapFactory.<String, InEachSubcomponent>builder(1)",
+            "            .put(\"leafmodule\", LeafModule_ProvideInLeafFactory.create())",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<Map<String, InEachSubcomponent>> ",
+            "      contributionsInEachSubcomponent() {",
+            "    return mapOfStringAndInEachSubcomponentProvider;",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"ancestormodule\")",
+            "  static InEachSubcomponent provideInAncestor() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.DelegateFactory;",
+            "import dagger.internal.MapFactory;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Map<String, InEachSubcomponent>> ",
+            "      mapOfStringAndInEachSubcomponentProvider = new DelegateFactory<>();",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected void configureInitialization() { ",
+            "      super.configureInitialization();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() { ",
+            "      DelegateFactory.setDelegate(",
+            "          mapOfStringAndInEachSubcomponentProvider,",
+            "          MapFactory.<String, InEachSubcomponent>builder(2)",
+            "              .putAll(super.contributionsInEachSubcomponent())",
+            "              .put(",
+            "                  \"ancestormodule\",",
+            "                  AncestorModule_ProvideInAncestorFactory.create())",
+            "              .build());",
+            "    }",
+            "",
+            "    @Override",
+            "    public Provider<Map<String, InEachSubcomponent>> ",
+            "        contributionsInEachSubcomponent() {",
+            "      return mapOfStringAndInEachSubcomponentProvider;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeafAndGrandAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InLeafAndGrandAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InLeafAndGrandAncestor provideInLeaf() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
+            "    return ImmutableMap.<String, InLeafAndGrandAncestor>of(",
+            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandAncestorModule.class)",
+            "interface GrandAncestor {",
+            "  Ancestor ancestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class GrandAncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"grandancestormodule\")",
+            "  static InLeafAndGrandAncestor provideInGrandAncestor() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedGrandAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
+            "  protected DaggerGrandAncestor() {}",
+            "",
+            "  protected abstract class AncestorImpl extends DaggerAncestor {",
+            "    protected AncestorImpl() {}",
+            "",
+            "    protected abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      protected LeafImpl() {}",
+            "",
+            "      @Override",
+            "      public Map<String, InLeafAndGrandAncestor>",
+            "          contributionsInLeafAndGrandAncestor() {",
+            "        return",
+            "            ImmutableMap.<String, InLeafAndGrandAncestor>builderWithExpectedSize(2)",
+            "                .put(\"grandancestormodule\",",
+            "                    GrandAncestorModule_ProvideInGrandAncestorFactory",
+            "                        .proxyProvideInGrandAncestor())",
+            "                .putAll(super.contributionsInLeafAndGrandAncestor())",
+            "                .build();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandAncestor")
+        .hasSourceEquivalentTo(generatedGrandAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeafAndAncestorWithoutGuava() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InEachSubcomponent> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import java.util.Collections;",
+            "import java.util.Map",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "    return Collections.<String, InEachSubcomponent>singletonMap(",
+            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compileWithoutGuava(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"ancestormodule\")",
+            "  static InEachSubcomponent provideInAncestor() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.MapBuilder;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "      return MapBuilder.<String, InEachSubcomponent>newMapBuilder(2)",
+            "          .put(\"ancestormodule\",",
+            "              AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
+            "          .putAll(super.contributionsInEachSubcomponent())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compileWithoutGuava(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibinding_requestedAsInstanceInLeaf_requestedAsFrameworkInstanceFromAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(
+        filesToCompile, "Multibound", "MissingInLeaf_WillDependOnFrameworkInstance");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<Integer, Multibound> instance();",
+            "  MissingInLeaf_WillDependOnFrameworkInstance willDependOnFrameworkInstance();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoMap;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @IntKey(111)",
+            "  static Multibound contribution() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<Integer, Multibound> instance() {",
+            "    return ImmutableMap.<Integer, Multibound>of(",
+            "        111, LeafModule_ContributionFactory.proxyContribution());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "interface AncestorModule {",
+            "  @Provides",
+            "  static MissingInLeaf_WillDependOnFrameworkInstance providedInAncestor(",
+            "      Provider<Map<Integer, Multibound>> frameworkInstance) {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Multibinds Map<Integer, Multibound> multibinds();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Map<Integer, Multibound>> mapOfIntegerAndMultiboundProvider;",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    protected void configureInitialization() { ",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() { ",
+            "      this.mapOfIntegerAndMultiboundProvider =",
+            "          MapFactory.<Integer, Multibound>builder(1)",
+            "              .put(111, LeafModule_ContributionFactory.create())",
+            "              .build();",
+            "    }",
+            "",
+            "    protected Provider getMapOfIntegerAndMultiboundProvider() {",
+            "      return mapOfIntegerAndMultiboundProvider;",
+            "    }",
+            "",
+            "    @Override",
+            "    public final MissingInLeaf_WillDependOnFrameworkInstance ",
+            "        willDependOnFrameworkInstance() {",
+            "      return AncestorModule_ProvidedInAncestorFactory.proxyProvidedInAncestor(",
+            "          getMapOfIntegerAndMultiboundProvider());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void emptyMultibinds_set() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Multibound");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Multibinds",
+            "  Set<Multibound> set();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<Multibound> set();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<Multibound> set() {",
+            "    return ImmutableSet.<Multibound>of();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Multibound fromAncestor() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Set<Multibound> set() {",
+            "      return ImmutableSet.<Multibound>of(",
+            "          AncestorModule_FromAncestorFactory.proxyFromAncestor());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void emptyMultibinds_set_frameworkInstance() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Multibound");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Multibinds",
+            "  Set<Multibound> set();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Provider<Set<Multibound>> set();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Provider<Set<Multibound>> set() {",
+            "    return SetFactory.<Multibound>empty();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Multibound fromAncestor() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.DelegateFactory;",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Set<Multibound>> setOfMultiboundProvider =",
+            "        new DelegateFactory<>();",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    protected void configureInitialization() {",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      DelegateFactory.setDelegate(",
+            "          setOfMultiboundProvider,",
+            "          SetFactory.<Multibound>builder(1, 0)",
+            "              .addProvider(AncestorModule_FromAncestorFactory.create())",
+            "              .build());",
+            "    }",
+            "",
+            "    @Override",
+            "    public Provider<Set<Multibound>> set() {",
+            "      return setOfMultiboundProvider;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void emptyMultibinds_map() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Multibound");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Multibinds",
+            "  Map<Integer, Multibound> map();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<Integer, Multibound> map();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<Integer, Multibound> map() {",
+            "    return ImmutableMap.<Integer, Multibound>of();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @IntKey(111)",
+            "  static Multibound fromAncestor() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<Integer, Multibound> map() {",
+            "      return ImmutableMap.<Integer, Multibound>of(",
+            "          111, AncestorModule_FromAncestorFactory.proxyFromAncestor());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void emptyMultibinds_map_frameworkInstance() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Multibound");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Multibinds",
+            "  Map<Integer, Multibound> map();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Provider<Map<Integer, Multibound>> map();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Provider<Map<Integer, Multibound>> map() {",
+            "    return MapFactory.<Integer, Multibound>emptyMapProvider();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @IntKey(111)",
+            "  static Multibound fromAncestor() {",
+            "    return new Multibound();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.DelegateFactory;",
+            "import dagger.internal.MapFactory;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private Provider<Map<Integer, Multibound>> mapOfIntegerAndMultiboundProvider =",
+            "        new DelegateFactory<>()",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    protected void configureInitialization() {",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      DelegateFactory.setDelegate(",
+            "          mapOfIntegerAndMultiboundProvider,",
+            "          MapFactory.<Integer, Multibound>builder(1)",
+            "              .put(111, AncestorModule_FromAncestorFactory.create())",
+            "              .build());",
+            "    }",
+            "",
+            "    @Override",
+            "    public Provider<Map<Integer, Multibound>> map() {",
+            "      return mapOfIntegerAndMultiboundProvider;",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void bindsMissingDep_Multibindings() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Binds",
+            "  @IntoSet",
+            "  CharSequence bindsMultibindingWithMissingDep(String string);",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<CharSequence> set();",
+            "}"));
+
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<CharSequence> set() {",
+            "    return ImmutableSet.<CharSequence>of(getBindsMultibindingWithMissingDep());",
+            "  }",
+            "",
+            // The expected output here is subtle: the Key of
+            // LeafModule.bindsMultibindingWithMissingDep() is Set<CharSequence>, but the binding
+            // method should only be returning an individual CharSequence. Otherwise the
+            // ImmutableSet factory method above will fail.
+            "  protected abstract CharSequence getBindsMultibindingWithMissingDep();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+  }
+
+  @Test
+  public void multibindingsAndFastInit() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "PackagePrivate");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.MultibindingModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "interface MultibindingModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  @LeafScope",
+            "  static PackagePrivate setContribution() {",
+            "    return new PackagePrivate();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoMap",
+            "  @IntKey(1)",
+            "  @LeafScope",
+            "  static PackagePrivate mapContribution() {",
+            "    return new PackagePrivate();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface LeafScope {}"),
+        JavaFileObjects.forSourceLines(
+            "test.UsesMultibindings",
+            "package test;",
+            "",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.inject.Inject;",
+            "",
+            "class UsesMultibindings {",
+            "  @Inject",
+            "  UsesMultibindings(Set<PackagePrivate> set, Map<Integer, PackagePrivate> map) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@LeafScope",
+            "@Subcomponent(modules = MultibindingModule.class)",
+            "interface Leaf {",
+            "  UsesMultibindings entryPoint();",
+            "}"));
+
+    Compilation compilation =
+        compilerWithOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE, FAST_INIT_MODE)
+            .compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  private PackagePrivate getSetContribution() {",
+            "    Object local = setContribution;",
+            "    if (local instanceof MemoizedSentinel) {",
+            "      synchronized (local) {",
+            "        local = setContribution;",
+            "        if (local instanceof MemoizedSentinel) {",
+            "          local = MultibindingModule_SetContributionFactory.proxySetContribution();",
+            "          setContribution = DoubleCheck.reentrantCheck(setContribution, local);",
+            "        }",
+            "      }",
+            "    }",
+            "    return (PackagePrivate) local;",
+            "  }",
+            "",
+            "  private PackagePrivate getMapContribution() {",
+            "    Object local = mapContribution;",
+            "    if (local instanceof MemoizedSentinel) {",
+            "      synchronized (local) {",
+            "        local = mapContribution;",
+            "        if (local instanceof MemoizedSentinel) {",
+            "          local = MultibindingModule_MapContributionFactory.proxyMapContribution();",
+            "          mapContribution = DoubleCheck.reentrantCheck(mapContribution, local);",
+            "        }",
+            "      }",
+            "    }",
+            "    return (PackagePrivate) local;",
+            "  }",
+            "",
+            "  @Override",
+            "  public UsesMultibindings entryPoint() {",
+            "    return new UsesMultibindings(",
+            "        getSetOfPackagePrivate(), getMapOfIntegerAndPackagePrivate());",
+            "  }",
+            "",
+            "  protected Set getSetOfPackagePrivate() {",
+            "    return ImmutableSet.<PackagePrivate>of(getSetContribution());",
+            "  }",
+            "",
+            "  protected Map getMapOfIntegerAndPackagePrivate() {",
+            "    return ImmutableMap.<Integer, PackagePrivate>of(1, getMapContribution());",
+            "  }",
+            "}");
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .containsElementsIn(generatedLeaf);
+  }
+
+  // TODO(ronshapiro): remove copies from AheadOfTimeSubcomponents*Test classes
+  private void createAncillaryClasses(
+      ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
+    for (String className : ancillaryClasses) {
+      filesBuilder.add(
+          JavaFileObjects.forSourceLines(
+              String.format("test.%s", className),
+              "package test;",
+              "",
+              String.format("class %s { }", className)));
+    }
+  }
+
+  private static Compilation compile(Iterable<JavaFileObject> files) {
+    return compilerWithOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE).compile(files);
+  }
+
+  private static Compilation compileWithoutGuava(Iterable<JavaFileObject> files) {
+    return daggerCompiler()
+        .withOptions(
+            AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts().append(CLASS_PATH_WITHOUT_GUAVA_OPTION))
+        .compile(files);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 79fe6dfae..8dcf383ca 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -18,8 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.CompilerMode.AHEAD_OF_TIME_SUBCOMPONENTS_MODE;
-import static dagger.internal.codegen.Compilers.CLASS_PATH_WITHOUT_GUAVA_OPTION;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.Compilers.compilerWithOptions;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
@@ -1528,2338 +1527,6 @@ public void optionalBindings_boundInAncestorAndSatisfiedInGrandAncestor() {
         .hasSourceEquivalentTo(generatedGrandAncestor);
   }
 
-  @Test
-  public void setMultibindings_contributionsInLeaf() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InLeaf");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Set<InLeaf> contributionsInLeaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InLeaf provideInLeaf() {",
-            "    return new InLeaf();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Set<InLeaf> contributionsInLeaf() {",
-            "    return ImmutableSet.<InLeaf>of(",
-            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-  }
-
-  @Test
-  public void setMultibindings_contributionsInAncestorOnly() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InAncestor");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  Set<InAncestor> contributionsInAncestor();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.ElementsIntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @ElementsIntoSet",
-            "  static Set<InAncestor> provideInAncestors() {",
-            "    return ImmutableSet.of(new InAncestor(), new InAncestor());",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Set<InAncestor> contributionsInAncestor() {",
-            "      return ImmutableSet.<InAncestor>copyOf(",
-            "          AncestorModule_ProvideInAncestorsFactory.proxyProvideInAncestors());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void setMultibindings_contributionsInLeafAndAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Set<InEachSubcomponent> contributionsInEachSubcomponent();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InEachSubcomponent provideInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InEachSubcomponent provideAnotherInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Set<InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "    return ImmutableSet.<InEachSubcomponent>of(",
-            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf(),",
-            "        LeafModule_ProvideAnotherInLeafFactory.proxyProvideAnotherInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.ElementsIntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @ElementsIntoSet",
-            "  static Set<InEachSubcomponent> provideInAncestor() {",
-            "    return ImmutableSet.of(new InEachSubcomponent(), new InEachSubcomponent());",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Set<InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "      return ImmutableSet.<InEachSubcomponent>builderWithExpectedSize(3)",
-            "          .addAll(AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
-            "          .addAll(super.contributionsInEachSubcomponent())",
-            "          .build();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void setMultibindings_contributionsInLeafAndGrandAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InLeafAndGrandAncestor");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InLeafAndGrandAncestor provideInLeaf() {",
-            "    return new InLeafAndGrandAncestor();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InLeafAndGrandAncestor provideAnotherInLeaf() {",
-            "    return new InLeafAndGrandAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
-            "    return ImmutableSet.<InLeafAndGrandAncestor>of(",
-            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf(),",
-            "        LeafModule_ProvideAnotherInLeafFactory.proxyProvideAnotherInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.GrandAncestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = GrandAncestorModule.class)",
-            "interface GrandAncestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.GrandAncestorModule",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.ElementsIntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class GrandAncestorModule {",
-            "  @Provides",
-            "  @ElementsIntoSet",
-            "  static Set<InLeafAndGrandAncestor> provideInGrandAncestor() {",
-            "    return ImmutableSet.of(new InLeafAndGrandAncestor(),",
-            "        new InLeafAndGrandAncestor());",
-            "  }",
-            "}"));
-    JavaFileObject generatedGrandAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerGrandAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
-            "  protected DaggerGrandAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
-            "      return ImmutableSet.<InLeafAndGrandAncestor>builderWithExpectedSize(3)",
-            "          .addAll(GrandAncestorModule_ProvideInGrandAncestorFactory",
-            "              .proxyProvideInGrandAncestor())",
-            "          .addAll(super.contributionsInLeafAndGrandAncestor())",
-            "          .build();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandAncestor")
-        .hasSourceEquivalentTo(generatedGrandAncestor);
-  }
-
-  @Test
-  public void setMultibindings_nonComponentMethodDependency() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InAllSubcomponents", "RequresInAllSubcomponentsSet");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  RequresInAllSubcomponentsSet requiresNonComponentMethod();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "    return new InAllSubcomponents();",
-            "  }",
-            "",
-            "  @Provides",
-            "  static RequresInAllSubcomponentsSet providesRequresInAllSubcomponentsSet(",
-            "      Set<InAllSubcomponents> inAllSubcomponents) {",
-            "    return new RequresInAllSubcomponentsSet();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public RequresInAllSubcomponentsSet requiresNonComponentMethod() {",
-            "    return LeafModule_ProvidesRequresInAllSubcomponentsSetFactory",
-            "        .proxyProvidesRequresInAllSubcomponentsSet(getSetOfInAllSubcomponents());",
-            "  }",
-            "",
-            "  protected Set getSetOfInAllSubcomponents() {",
-            "    return ImmutableSet.<InAllSubcomponents>of(",
-            "        LeafModule_ProvideInAllSubcomponentsFactory",
-            "            .proxyProvideInAllSubcomponents());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InAllSubcomponents provideInAllSubcomponents() {",
-            "      return new InAllSubcomponents();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected Set getSetOfInAllSubcomponents() {",
-            "      return ImmutableSet.<InAllSubcomponents>builderWithExpectedSize(2)",
-            "          .add(AncestorModule_ProvideInAllSubcomponentsFactory",
-            "              .proxyProvideInAllSubcomponents())",
-            "          .addAll(super.getSetOfInAllSubcomponents())",
-            "          .build();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void setMultibindings_newSubclass() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InAncestor", "RequiresInAncestorSet");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  RequiresInAncestorSet missingWithSetDependency();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "",
-            "  @Provides",
-            "  static RequiresInAncestorSet provideRequiresInAncestorSet(",
-            "      Set<InAncestor> inAncestors) {",
-            "    return new RequiresInAncestorSet();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InAncestor provideInAncestor() {",
-            "    return new InAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            // TODO(b/117833324): because this is a private method, the return type shouldn't need
-            // to be the publicly accessible type. This may be easier to detect if we fold
-            // BindingMethodImplementation into MethodBindingExpression
-            "  private Object getRequiresInAncestorSet() {",
-            "    return AncestorModule_ProvideRequiresInAncestorSetFactory",
-            "        .proxyProvideRequiresInAncestorSet(getSetOfInAncestor());",
-            "  }",
-            "",
-            "  protected Set getSetOfInAncestor() {",
-            "    return ImmutableSet.<InAncestor>of(",
-            "        AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor());",
-            "  }",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public final RequiresInAncestorSet missingWithSetDependency() {",
-            "      return (RequiresInAncestorSet) DaggerAncestor.this.getRequiresInAncestorSet();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void setMultibinding_requestedAsInstanceInLeaf_requestedAsFrameworkInstanceFromAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(
-        filesToCompile, "Multibound", "MissingInLeaf_WillDependOnFrameworkInstance");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Set<Multibound> instance();",
-            "  MissingInLeaf_WillDependOnFrameworkInstance willDependOnFrameworkInstance();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static Multibound contribution() {",
-            "    return new Multibound();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Set<Multibound> instance() {",
-            "    return ImmutableSet.<Multibound>of(",
-            "        LeafModule_ContributionFactory.proxyContribution());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "",
-            "@Module",
-            "interface AncestorModule {",
-            "  @Provides",
-            "  static MissingInLeaf_WillDependOnFrameworkInstance providedInAncestor(",
-            "      Provider<Set<Multibound>> frameworkInstance) {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Multibinds Set<Multibound> multibinds();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private Provider<Set<Multibound>> setOfMultiboundProvider;",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    protected void configureInitialization() { ",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() { ",
-            "      this.setOfMultiboundProvider =",
-            "          SetFactory.<Multibound>builder(1, 0)",
-            "              .addProvider(LeafModule_ContributionFactory.create())",
-            "              .build();",
-            "    }",
-            "",
-            "    protected Provider getSetOfMultiboundProvider() {",
-            "      return setOfMultiboundProvider;",
-            "    }",
-            "",
-            "    @Override",
-            "    public final MissingInLeaf_WillDependOnFrameworkInstance ",
-            "        willDependOnFrameworkInstance() {",
-            "      return AncestorModule_ProvidedInAncestorFactory.proxyProvidedInAncestor(",
-            "          getSetOfMultiboundProvider());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void setMultibindings_contributionsInLeafAndAncestor_frameworkInstances() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InEachSubcomponent provideInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoSet",
-            "  static InEachSubcomponent provideAnotherInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  private Provider<Set<InEachSubcomponent>> setOfInEachSubcomponentProvider;",
-            "",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  protected void configureInitialization() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.setOfInEachSubcomponentProvider =",
-            "        SetFactory.<InEachSubcomponent>builder(2, 0)",
-            "            .addProvider(LeafModule_ProvideInLeafFactory.create())",
-            "            .addProvider(LeafModule_ProvideAnotherInLeafFactory.create())",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent() {",
-            "    return setOfInEachSubcomponentProvider;",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.ElementsIntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @ElementsIntoSet",
-            "  static Set<InEachSubcomponent> provideInAncestor() {",
-            "    return ImmutableSet.of(new InEachSubcomponent(), new InEachSubcomponent());",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.DelegateFactory;",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private Provider<Set<InEachSubcomponent>> setOfInEachSubcomponentProvider = ",
-            "        new DelegateFactory<>();",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected void configureInitialization() {",
-            "      super.configureInitialization();",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      DelegateFactory.setDelegate(",
-            "          setOfInEachSubcomponentProvider,",
-            "          SetFactory.<InEachSubcomponent>builder(0, 2)",
-            "              .addCollectionProvider(super.contributionsInEachSubcomponent())",
-            "              .addCollectionProvider(",
-            "                  AncestorModule_ProvideInAncestorFactory.create())",
-            "              .build());",
-            "    }",
-            "",
-            "    @Override",
-            "    public Provider<Set<InEachSubcomponent>> contributionsInEachSubcomponent() {",
-            "      return setOfInEachSubcomponentProvider;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void mapMultibindings_contributionsInLeaf() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InLeaf");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Map<String, InLeaf> contributionsInLeaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"leafmodule\")",
-            "  static InLeaf provideInLeaf() {",
-            "    return new InLeaf();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Map<String, InLeaf> contributionsInLeaf() {",
-            "    return ImmutableMap.<String, InLeaf>of(",
-            "        \"leafmodule\",",
-            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-  }
-
-  @Test
-  public void mapMultibindings_contributionsInAncestorOnly() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InAncestor");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "",
-            "@Subcomponent",
-            "interface Leaf {",
-            "  Map<String, InAncestor> contributionsInAncestor();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"ancestormodule\")",
-            "  static InAncestor provideInAncestor() {",
-            "    return new InAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Map<String, InAncestor> contributionsInAncestor() {",
-            "      return ImmutableMap.<String, InAncestor>of(\"ancestormodule\",",
-            "          AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void mapMultibindings_contributionsInLeafAndAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Map<String, InEachSubcomponent> contributionsInEachSubcomponent();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"leafmodule\")",
-            "  static InEachSubcomponent provideInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "    return ImmutableMap.<String, InEachSubcomponent>of(",
-            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"ancestormodule\")",
-            "  static InEachSubcomponent provideInAncestor() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "      return ImmutableMap.<String, InEachSubcomponent>builderWithExpectedSize(2)",
-            "          .put(\"ancestormodule\",",
-            "              AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
-            "          .putAll(super.contributionsInEachSubcomponent())",
-            "          .build();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void mapMultibindings_contributionsInLeafAndAncestor_frameworkInstance() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Provider<Map<String, InEachSubcomponent>> contributionsInEachSubcomponent();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"leafmodule\")",
-            "  static InEachSubcomponent provideInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.MapFactory;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  private Provider<Map<String, InEachSubcomponent>> ",
-            "    mapOfStringAndInEachSubcomponentProvider;",
-            "",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  protected void configureInitialization() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.mapOfStringAndInEachSubcomponentProvider =",
-            "        MapFactory.<String, InEachSubcomponent>builder(1)",
-            "            .put(\"leafmodule\", LeafModule_ProvideInLeafFactory.create())",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Provider<Map<String, InEachSubcomponent>> ",
-            "      contributionsInEachSubcomponent() {",
-            "    return mapOfStringAndInEachSubcomponentProvider;",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"ancestormodule\")",
-            "  static InEachSubcomponent provideInAncestor() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.DelegateFactory;",
-            "import dagger.internal.MapFactory;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private Provider<Map<String, InEachSubcomponent>> ",
-            "      mapOfStringAndInEachSubcomponentProvider = new DelegateFactory<>();",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    protected void configureInitialization() { ",
-            "      super.configureInitialization();",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() { ",
-            "      DelegateFactory.setDelegate(",
-            "          mapOfStringAndInEachSubcomponentProvider,",
-            "          MapFactory.<String, InEachSubcomponent>builder(2)",
-            "              .putAll(super.contributionsInEachSubcomponent())",
-            "              .put(",
-            "                  \"ancestormodule\",",
-            "                  AncestorModule_ProvideInAncestorFactory.create())",
-            "              .build());",
-            "    }",
-            "",
-            "    @Override",
-            "    public Provider<Map<String, InEachSubcomponent>> ",
-            "        contributionsInEachSubcomponent() {",
-            "      return mapOfStringAndInEachSubcomponentProvider;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void mapMultibindings_contributionsInLeafAndGrandAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InLeafAndGrandAncestor");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"leafmodule\")",
-            "  static InLeafAndGrandAncestor provideInLeaf() {",
-            "    return new InLeafAndGrandAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
-            "    return ImmutableMap.<String, InLeafAndGrandAncestor>of(",
-            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.GrandAncestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = GrandAncestorModule.class)",
-            "interface GrandAncestor {",
-            "  Ancestor ancestor();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.GrandAncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class GrandAncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"grandancestormodule\")",
-            "  static InLeafAndGrandAncestor provideInGrandAncestor() {",
-            "    return new InLeafAndGrandAncestor();",
-            "  }",
-            "}"));
-    JavaFileObject generatedGrandAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerGrandAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
-            "  protected DaggerGrandAncestor() {}",
-            "",
-            "  protected abstract class AncestorImpl extends DaggerAncestor {",
-            "    protected AncestorImpl() {}",
-            "",
-            "    protected abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      protected LeafImpl() {}",
-            "",
-            "      @Override",
-            "      public Map<String, InLeafAndGrandAncestor>",
-            "          contributionsInLeafAndGrandAncestor() {",
-            "        return",
-            "            ImmutableMap.<String, InLeafAndGrandAncestor>builderWithExpectedSize(2)",
-            "                .put(\"grandancestormodule\",",
-            "                    GrandAncestorModule_ProvideInGrandAncestorFactory",
-            "                        .proxyProvideInGrandAncestor())",
-            "                .putAll(super.contributionsInLeafAndGrandAncestor())",
-            "                .build();",
-            "      }",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerGrandAncestor")
-        .hasSourceEquivalentTo(generatedGrandAncestor);
-  }
-
-  @Test
-  public void mapMultibindings_contributionsInLeafAndAncestorWithoutGuava() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Map<String, InEachSubcomponent> contributionsInEachSubcomponent();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"leafmodule\")",
-            "  static InEachSubcomponent provideInLeaf() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import java.util.Collections;",
-            "import java.util.Map",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "    return Collections.<String, InEachSubcomponent>singletonMap(",
-            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
-            "  }",
-            "}");
-    Compilation compilation = compileWithoutGuava(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @StringKey(\"ancestormodule\")",
-            "  static InEachSubcomponent provideInAncestor() {",
-            "    return new InEachSubcomponent();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.MapBuilder;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
-            "      return MapBuilder.<String, InEachSubcomponent>newMapBuilder(2)",
-            "          .put(\"ancestormodule\",",
-            "              AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
-            "          .putAll(super.contributionsInEachSubcomponent())",
-            "          .build();",
-            "    }",
-            "  }",
-            "}");
-    compilation = compileWithoutGuava(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void mapMultibinding_requestedAsInstanceInLeaf_requestedAsFrameworkInstanceFromAncestor() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(
-        filesToCompile, "Multibound", "MissingInLeaf_WillDependOnFrameworkInstance");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Map<Integer, Multibound> instance();",
-            "  MissingInLeaf_WillDependOnFrameworkInstance willDependOnFrameworkInstance();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntKey;",
-            "import dagger.multibindings.IntoMap;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "class LeafModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @IntKey(111)",
-            "  static Multibound contribution() {",
-            "    return new Multibound();",
-            "  }",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Map<Integer, Multibound> instance() {",
-            "    return ImmutableMap.<Integer, Multibound>of(",
-            "        111, LeafModule_ContributionFactory.proxyContribution());",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Map;",
-            "import javax.inject.Provider;",
-            "",
-            "@Module",
-            "interface AncestorModule {",
-            "  @Provides",
-            "  static MissingInLeaf_WillDependOnFrameworkInstance providedInAncestor(",
-            "      Provider<Map<Integer, Multibound>> frameworkInstance) {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Multibinds Map<Integer, Multibound> multibinds();",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.MapFactory;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private Provider<Map<Integer, Multibound>> mapOfIntegerAndMultiboundProvider;",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    protected void configureInitialization() { ",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() { ",
-            "      this.mapOfIntegerAndMultiboundProvider =",
-            "          MapFactory.<Integer, Multibound>builder(1)",
-            "              .put(111, LeafModule_ContributionFactory.create())",
-            "              .build();",
-            "    }",
-            "",
-            "    protected Provider getMapOfIntegerAndMultiboundProvider() {",
-            "      return mapOfIntegerAndMultiboundProvider;",
-            "    }",
-            "",
-            "    @Override",
-            "    public final MissingInLeaf_WillDependOnFrameworkInstance ",
-            "        willDependOnFrameworkInstance() {",
-            "      return AncestorModule_ProvidedInAncestorFactory.proxyProvidedInAncestor(",
-            "          getMapOfIntegerAndMultiboundProvider());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void emptyMultibinds_set() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "Multibound");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Multibinds",
-            "  Set<Multibound> set();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Set<Multibound> set();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Set<Multibound> set() {",
-            "    return ImmutableSet.<Multibound>of();",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static Multibound fromAncestor() {",
-            "    return new Multibound();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Set<Multibound> set() {",
-            "      return ImmutableSet.<Multibound>of(",
-            "          AncestorModule_FromAncestorFactory.proxyFromAncestor());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void emptyMultibinds_set_frameworkInstance() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "Multibound");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Multibinds",
-            "  Set<Multibound> set();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Provider<Set<Multibound>> set();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Provider<Set<Multibound>> set() {",
-            "    return SetFactory.<Multibound>empty();",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoSet",
-            "  static Multibound fromAncestor() {",
-            "    return new Multibound();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.DelegateFactory;",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private Provider<Set<Multibound>> setOfMultiboundProvider =",
-            "        new DelegateFactory<>();",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    protected void configureInitialization() {",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      DelegateFactory.setDelegate(",
-            "          setOfMultiboundProvider,",
-            "          SetFactory.<Multibound>builder(1, 0)",
-            "              .addProvider(AncestorModule_FromAncestorFactory.create())",
-            "              .build());",
-            "    }",
-            "",
-            "    @Override",
-            "    public Provider<Set<Multibound>> set() {",
-            "      return setOfMultiboundProvider;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void emptyMultibinds_map() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "Multibound");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Multibinds",
-            "  Map<Integer, Multibound> map();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Map<Integer, Multibound> map();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Map<Integer, Multibound> map() {",
-            "    return ImmutableMap.<Integer, Multibound>of();",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntKey;",
-            "import dagger.multibindings.IntoMap;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @IntKey(111)",
-            "  static Multibound fromAncestor() {",
-            "    return new Multibound();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    protected LeafImpl() {}",
-            "",
-            "    @Override",
-            "    public Map<Integer, Multibound> map() {",
-            "      return ImmutableMap.<Integer, Multibound>of(",
-            "          111, AncestorModule_FromAncestorFactory.proxyFromAncestor());",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
-  @Test
-  public void emptyMultibinds_map_frameworkInstance() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "Multibound");
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.Map;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Multibinds",
-            "  Map<Integer, Multibound> map();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "import javax.inject.Provider;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Provider<Map<Integer, Multibound>> map();",
-            "}"));
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import dagger.internal.MapFactory;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Provider<Map<Integer, Multibound>> map() {",
-            "    return MapFactory.<Integer, Multibound>emptyMapProvider();",
-            "  }",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.Ancestor",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = AncestorModule.class)",
-            "interface Ancestor {",
-            "  Leaf leaf();",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.AncestorModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntKey;",
-            "import dagger.multibindings.IntoMap;",
-            "",
-            "@Module",
-            "class AncestorModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @IntKey(111)",
-            "  static Multibound fromAncestor() {",
-            "    return new Multibound();",
-            "  }",
-            "}"));
-    JavaFileObject generatedAncestor =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerAncestor",
-            "package test;",
-            "",
-            "import dagger.internal.DelegateFactory;",
-            "import dagger.internal.MapFactory;",
-            "import java.util.Map;",
-            IMPORT_GENERATED_ANNOTATION,
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerAncestor implements Ancestor {",
-            "  protected DaggerAncestor() {}",
-            "",
-            "  protected abstract class LeafImpl extends DaggerLeaf {",
-            "    private Provider<Map<Integer, Multibound>> mapOfIntegerAndMultiboundProvider =",
-            "        new DelegateFactory<>()",
-            "",
-            "    protected LeafImpl() {}",
-            "",
-            "    protected void configureInitialization() {",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      DelegateFactory.setDelegate(",
-            "          mapOfIntegerAndMultiboundProvider,",
-            "          MapFactory.<Integer, Multibound>builder(1)",
-            "              .put(111, AncestorModule_FromAncestorFactory.create())",
-            "              .build());",
-            "    }",
-            "",
-            "    @Override",
-            "    public Provider<Map<Integer, Multibound>> map() {",
-            "      return mapOfIntegerAndMultiboundProvider;",
-            "    }",
-            "  }",
-            "}");
-    compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerAncestor")
-        .hasSourceEquivalentTo(generatedAncestor);
-  }
-
   @Test
   public void provisionOverInjection_providedInAncestor() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
@@ -6433,67 +4100,6 @@ public void modifiedProducerFromProvider() {
         .hasSourceEquivalentTo(generatedRoot);
   }
 
-  @Test
-  public void bindsMissingDep_Multibindings() {
-    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    filesToCompile.add(
-        JavaFileObjects.forSourceLines(
-            "test.LeafModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "interface LeafModule {",
-            "  @Binds",
-            "  @IntoSet",
-            "  CharSequence bindsMultibindingWithMissingDep(String string);",
-            "}"),
-        JavaFileObjects.forSourceLines(
-            "test.Leaf",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent(modules = LeafModule.class)",
-            "interface Leaf {",
-            "  Set<CharSequence> set();",
-            "}"));
-
-    JavaFileObject generatedLeaf =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerLeaf",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import java.util.Set;",
-            IMPORT_GENERATED_ANNOTATION,
-            "",
-            GENERATED_ANNOTATION,
-            "public abstract class DaggerLeaf implements Leaf {",
-            "  protected DaggerLeaf() {}",
-            "",
-            "  @Override",
-            "  public Set<CharSequence> set() {",
-            "    return ImmutableSet.<CharSequence>of(getBindsMultibindingWithMissingDep());",
-            "  }",
-            "",
-            // The expected output here is subtle: the Key of
-            // LeafModule.bindsMultibindingWithMissingDep() is Set<CharSequence>, but the binding
-            // method should only be returning an individual CharSequence. Otherwise the
-            // ImmutableSet factory method above will fail.
-            "  protected abstract CharSequence getBindsMultibindingWithMissingDep();",
-            "}");
-    Compilation compilation = compile(filesToCompile.build());
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerLeaf")
-        .hasSourceEquivalentTo(generatedLeaf);
-  }
-
   @Test
   public void modifiableBindingMethods_namesDedupedAcrossImplementations() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
@@ -7285,6 +4891,7 @@ public void dependencyExpressionCasting() {
         .containsElementsIn(generatedLeaf);
   }
 
+  // TODO(ronshapiro): remove copies from AheadOfTimeSubcomponents*Test classes
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
     for (String className : ancillaryClasses) {
@@ -7298,15 +4905,6 @@ private void createAncillaryClasses(
   }
 
   private static Compilation compile(Iterable<JavaFileObject> files) {
-    return daggerCompiler()
-        .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
-        .compile(files);
-  }
-
-  private static Compilation compileWithoutGuava(Iterable<JavaFileObject> files) {
-    return daggerCompiler()
-        .withOptions(
-            AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts().append(CLASS_PATH_WITHOUT_GUAVA_OPTION))
-        .compile(files);
+    return compilerWithOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE).compile(files);
   }
 }
diff --git a/javatests/dagger/internal/codegen/Compilers.java b/javatests/dagger/internal/codegen/Compilers.java
index aed1572f8..805713331 100644
--- a/javatests/dagger/internal/codegen/Compilers.java
+++ b/javatests/dagger/internal/codegen/Compilers.java
@@ -23,6 +23,7 @@
 
 import com.google.auto.value.processor.AutoAnnotationProcessor;
 import com.google.common.base.Splitter;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compiler;
 import javax.annotation.processing.Processor;
@@ -50,4 +51,12 @@ static Compiler daggerCompiler(Processor... extraProcessors) {
     processors.add(extraProcessors);
     return javac().withProcessors(processors.build());
   }
+
+  static Compiler compilerWithOptions(CompilerMode... compilerModes) {
+    FluentIterable<String> options = FluentIterable.of();
+    for (CompilerMode compilerMode : compilerModes) {
+      options = options.append(compilerMode.javacopts());
+    }
+    return daggerCompiler().withOptions(options);
+  }
 }
