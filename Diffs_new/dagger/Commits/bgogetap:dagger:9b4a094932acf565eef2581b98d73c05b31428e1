diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 921867da0..b417e8684 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -78,6 +78,7 @@
   private final BindingFactory bindingFactory;
   private final CompilerOptions compilerOptions;
   private final ModuleDescriptor.Factory moduleDescriptorFactory;
+  private final Map<Key, ImmutableSet<Key>> keysMatchingRequestCache = new HashMap<>();
 
   @Inject
   BindingGraphFactory(
@@ -277,6 +278,11 @@ private ModuleDescriptor descriptorForProductionExecutorModule() {
     return ImmutableSetMultimap.copyOf(Multimaps.index(declarations, BindingDeclaration::key));
   }
 
+  /** Releases cached references that this factory is retaining during this processing round. */
+  void clearCache() {
+    keysMatchingRequestCache.clear();
+  }
+
   private final class Resolver {
     final Optional<Resolver> parentResolver;
     final ComponentDescriptor componentDescriptor;
@@ -443,7 +449,28 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentCreato
           owningResolver.componentDescriptor.getChildComponentWithBuilderType(builderType));
     }
 
+    /**
+     * Profiling has determined that computing the keys matching {@code requestKey} has measurable
+     * performance impact. It is called repeatedly (at least 3 times per key resolved per {@link
+     * BindingGraph}. {@code javac}'s name-checking performance seems suboptimal (converting byte
+     * strings to Strings repeatedly), and the matching keys creations relies on that. This also
+     * ensures that the resulting keys have their hash codes cached on successive calls to this
+     * method.
+     *
+     * <p>This caching may become obsolete if:
+     *
+     * <ul>
+     *   <li>We decide to intern all {@link Key} instances
+     *   <li>We fix javac's name-checking peformance (though we may want to keep this for older
+     *       javac users)
+     * </ul>
+     */
     private ImmutableSet<Key> keysMatchingRequest(Key requestKey) {
+      return keysMatchingRequestCache.computeIfAbsent(
+          requestKey, this::keysMatchingRequestUncached);
+    }
+
+    private ImmutableSet<Key> keysMatchingRequestUncached(Key requestKey) {
       ImmutableSet.Builder<Key> keys = ImmutableSet.builder();
       keys.add(requestKey);
       keyFactory.unwrapSetKey(requestKey, Produced.class).ifPresent(keys::add);
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index df8834abc..e21453dc4 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -55,7 +55,10 @@
   @Inject BindingGraphPlugins bindingGraphPlugins;
   @Inject CompilerOptions compilerOptions;
   @Inject DaggerStatistics daggerStatistics;
+
+  // TODO(ronshapiro): inject a multibinding for all instances that retain caches?
   @Inject ModuleDescriptor.Factory moduleDescriptorFactory;
+  @Inject BindingGraphFactory bindingGraphFactory;
 
   public ComponentProcessor() {
     this.testingPlugins = Optional.empty();
@@ -190,5 +193,6 @@ protected void postRound(RoundEnvironment roundEnv) {
       }
     }
     moduleDescriptorFactory.clearCache();
+    bindingGraphFactory.clearCache();
   }
 }
