diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index 0462ad68c..bc3cbf8f8 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -83,8 +83,12 @@ final boolean doCheckForNulls() {
 
   abstract boolean useGradleIncrementalProcessing();
 
-  /** Returns the binding {@link ValidationType} for the element. */
-  abstract ValidationType moduleBindingValidationType(TypeElement element);
+  /**
+   * Returns the validation that should be done for the full binding graph for the element.
+   *
+   * @throws IllegalArgumentException if {@code element} is not a module or (sub)component
+   */
+  abstract ValidationType fullBindingGraphValidationType(TypeElement element);
 
   abstract Diagnostic.Kind moduleHasDifferentScopesDiagnosticKind();
 
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 154401cb2..645c94f63 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -146,7 +146,7 @@ private void processRootComponent(TypeElement component) {
 
   private void processSubcomponent(TypeElement subcomponent) {
     if (!compilerOptions.aheadOfTimeSubcomponents()
-        && compilerOptions.moduleBindingValidationType(subcomponent).equals(NONE)) {
+        && compilerOptions.fullBindingGraphValidationType(subcomponent).equals(NONE)) {
       return;
     }
     if (!isSubcomponentValid(subcomponent)) {
@@ -235,7 +235,7 @@ private boolean isSubcomponentValid(Element subcomponentElement) {
 
   private boolean isFullBindingGraphValid(ComponentDescriptor componentDescriptor) {
     if (compilerOptions
-        .moduleBindingValidationType(componentDescriptor.typeElement())
+        .fullBindingGraphValidationType(componentDescriptor.typeElement())
         .equals(NONE)) {
       return true;
     }
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index 30ec2779a..1a14b8199 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -234,7 +234,8 @@ void printMessage(
         CharSequence message,
         @NullableDecl Element elementToReport) {
       if (graph.isFullBindingGraph()) {
-        ValidationType validationType = compilerOptions.moduleBindingValidationType(rootComponent);
+        ValidationType validationType =
+            compilerOptions.fullBindingGraphValidationType(rootComponent);
         if (validationType.equals(NONE)) {
           return;
         }
diff --git a/java/dagger/internal/codegen/ForwardingCompilerOptions.java b/java/dagger/internal/codegen/ForwardingCompilerOptions.java
index 5c98b570a..4a1deda59 100644
--- a/java/dagger/internal/codegen/ForwardingCompilerOptions.java
+++ b/java/dagger/internal/codegen/ForwardingCompilerOptions.java
@@ -106,8 +106,8 @@ boolean useGradleIncrementalProcessing() {
   }
 
   @Override
-  ValidationType moduleBindingValidationType(TypeElement element) {
-    return delegate.moduleBindingValidationType(element);
+  ValidationType fullBindingGraphValidationType(TypeElement element) {
+    return delegate.fullBindingGraphValidationType(element);
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/JavacPluginModule.java b/java/dagger/internal/codegen/JavacPluginModule.java
index 29e46a99d..6fb7f478f 100644
--- a/java/dagger/internal/codegen/JavacPluginModule.java
+++ b/java/dagger/internal/codegen/JavacPluginModule.java
@@ -119,7 +119,7 @@ boolean useGradleIncrementalProcessing() {
       }
 
       @Override
-      ValidationType moduleBindingValidationType(TypeElement element) {
+      ValidationType fullBindingGraphValidationType(TypeElement element) {
         return NONE;
       }
 
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index a21b2a85a..46a1490ef 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -34,6 +34,7 @@
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static dagger.internal.codegen.MoreAnnotationValues.asType;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
+import static dagger.internal.codegen.ValidationType.NONE;
 import static java.util.EnumSet.noneOf;
 import static java.util.stream.Collectors.joining;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -226,7 +227,7 @@ void addKnownModules(Collection<TypeElement> modules) {
     validateSelfCycles(module, builder);
 
     if (builder.build().isClean()
-        && !compilerOptions.moduleBindingValidationType(module).equals(ValidationType.NONE)) {
+        && !compilerOptions.fullBindingGraphValidationType(module).equals(NONE)) {
       validateModuleBindings(module, builder);
     }
 
diff --git a/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java b/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java
index cbf8283d7..cf2475de7 100644
--- a/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java
+++ b/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Sets.immutableEnumSet;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.FeatureStatus.DISABLED;
@@ -36,7 +37,7 @@
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.KeyOnlyOption.USE_GRADLE_INCREMENTAL_PROCESSING;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.DISABLE_INTER_COMPONENT_SCOPE_VALIDATION;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.EXPLICIT_BINDING_CONFLICTS_WITH_INJECT;
-import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.MODULE_BINDING_VALIDATION;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.FULL_BINDING_GRAPH_VALIDATION;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.MODULE_HAS_DIFFERENT_SCOPES_VALIDATION;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.NULLABLE_VALIDATION;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.PRIVATE_MEMBER_VALIDATION;
@@ -44,14 +45,19 @@
 import static dagger.internal.codegen.ValidationType.ERROR;
 import static dagger.internal.codegen.ValidationType.NONE;
 import static dagger.internal.codegen.ValidationType.WARNING;
+import static java.util.stream.Collectors.joining;
+import static java.util.stream.Stream.concat;
 
 import com.google.common.base.Ascii;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import dagger.producers.Produces;
 import java.util.Arrays;
 import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import java.util.stream.Stream;
 import javax.annotation.processing.ProcessingEnvironment;
@@ -66,6 +72,8 @@ static CompilerOptions create(ProcessingEnvironment processingEnvironment) {
 
   private final ProcessingEnvironment processingEnvironment;
   private final Map<EnumOption<?>, Object> enumOptions = new HashMap<>();
+  private final Map<EnumOption<?>, ImmutableMap<String, ? extends Enum<?>>> allCommandLineOptions =
+      new HashMap<>();
 
   private ProcessingEnvironmentCompilerOptions(ProcessingEnvironment processingEnvironment) {
     this.processingEnvironment = processingEnvironment;
@@ -148,12 +156,12 @@ boolean useGradleIncrementalProcessing() {
   }
 
   @Override
-  ValidationType moduleBindingValidationType(TypeElement element) {
-    return moduleBindingValidationType();
+  ValidationType fullBindingGraphValidationType(TypeElement element) {
+    return fullBindingGraphValidationType();
   }
 
-  private ValidationType moduleBindingValidationType() {
-    return parseOption(MODULE_BINDING_VALIDATION);
+  private ValidationType fullBindingGraphValidationType() {
+    return parseOption(FULL_BINDING_GRAPH_VALIDATION);
   }
 
   @Override
@@ -207,6 +215,19 @@ private void noLongerRecognized(CommandLineOption commandLineOption) {
     /** The key of the option (appears after "-A"). */
     @Override
     String toString();
+
+    /**
+     * Returns all aliases besides {@link #toString()}, such as old names for an option, in order of
+     * precedence.
+     */
+    default ImmutableList<String> aliases() {
+      return ImmutableList.of();
+    }
+
+    /** All the command-line names for this option, in order of precedence. */
+    default Stream<String> allNames() {
+      return concat(Stream.of(toString()), aliases().stream());
+    }
   }
 
   /** An option that can be set on the command line. */
@@ -296,8 +317,13 @@ public String toString() {
 
     STATIC_MEMBER_VALIDATION(ERROR, WARNING),
 
-    /** Whether to validate partial binding graphs associated with modules. */
-    MODULE_BINDING_VALIDATION(NONE, ERROR, WARNING),
+    /** Whether to validate full binding graphs for components, subcomponents, and modules. */
+    FULL_BINDING_GRAPH_VALIDATION(NONE, ERROR, WARNING) {
+      @Override
+      public ImmutableList<String> aliases() {
+        return ImmutableList.of("dagger.moduleBindingValidation");
+      }
+    },
 
     /**
      * How to report conflicting scoped bindings when validating partial binding graphs associated
@@ -350,11 +376,20 @@ private static String optionName(Enum<? extends EnumOption<?>> option) {
     return Stream.<CommandLineOption[]>of(
             KeyOnlyOption.values(), Feature.values(), Validation.values())
         .flatMap(Arrays::stream)
-        .map(CommandLineOption::toString)
+        .flatMap(CommandLineOption::allNames)
         .collect(toImmutableSet());
   }
 
-  /** Returns the value for the option as set on the command line, or the default value if not. */
+  /**
+   * Returns the value for the option as set on the command line by any name, or the default value
+   * if not set.
+   *
+   * <p>If more than one name is used to set the value, but all names specify the same value,
+   * reports a warning and returns that value.
+   *
+   * <p>If more than one name is used to set the value, and not all names specify the same value,
+   * reports an error and returns the default value.
+   */
   private <T extends Enum<T>> T parseOption(EnumOption<T> option) {
     @SuppressWarnings("unchecked") // we only put covariant values into the map
     T value = (T) enumOptions.computeIfAbsent(option, this::parseOptionUncached);
@@ -362,34 +397,88 @@ private static String optionName(Enum<? extends EnumOption<?>> option) {
   }
 
   private <T extends Enum<T>> T parseOptionUncached(EnumOption<T> option) {
-    String key = option.toString();
-    if (processingEnvironment.getOptions().containsKey(key)) {
-      String stringValue = processingEnvironment.getOptions().get(key);
-      if (stringValue == null) {
-        processingEnvironment
-            .getMessager()
-            .printMessage(Diagnostic.Kind.ERROR, "Processor option -A" + key + " needs a value");
-      } else {
-        try {
-          T value =
-              Enum.valueOf(
-                  option.defaultValue().getDeclaringClass(), Ascii.toUpperCase(stringValue));
-          if (option.validValues().contains(value)) {
-            return value;
-          }
-        } catch (IllegalArgumentException e) {
-          // handled below
-        }
-        processingEnvironment
-            .getMessager()
-            .printMessage(
-                Diagnostic.Kind.ERROR,
-                String.format(
-                    "Processor option -A%s may only have the values %s "
-                        + "(case insensitive), found: %s",
-                    key, option.validValues(), stringValue));
+    ImmutableMap<String, T> values = parseOptionWithAllNames(option);
+
+    // If no value is specified, return the default value.
+    if (values.isEmpty()) {
+      return option.defaultValue();
+    }
+
+    // If all names have the same value, return that.
+    if (values.asMultimap().inverse().keySet().size() == 1) {
+      // Warn if an option was set with more than one name. That would be an error if the values
+      // differed.
+      if (values.size() > 1) {
+        reportUseOfDifferentNamesForOption(Diagnostic.Kind.WARNING, option, values.keySet());
       }
+      return values.values().asList().get(0);
     }
+
+    // If different names have different values, report an error and return the default
+    // value.
+    reportUseOfDifferentNamesForOption(Diagnostic.Kind.ERROR, option, values.keySet());
     return option.defaultValue();
   }
+
+  private void reportUseOfDifferentNamesForOption(
+      Diagnostic.Kind diagnosticKind, EnumOption<?> option, ImmutableSet<String> usedNames) {
+    processingEnvironment
+        .getMessager()
+        .printMessage(
+            diagnosticKind,
+            String.format(
+                "Only one of the equivalent options (%s) should be used; prefer -A%s",
+                usedNames.stream().map(name -> "-A" + name).collect(joining(", ")), option));
+  }
+
+  private <T extends Enum<T>> ImmutableMap<String, T> parseOptionWithAllNames(
+      EnumOption<T> option) {
+    @SuppressWarnings("unchecked") // map is covariant
+    ImmutableMap<String, T> aliasValues =
+        (ImmutableMap<String, T>)
+            allCommandLineOptions.computeIfAbsent(option, this::parseOptionWithAllNamesUncached);
+    return aliasValues;
+  }
+
+  private <T extends Enum<T>> ImmutableMap<String, T> parseOptionWithAllNamesUncached(
+      EnumOption<T> option) {
+    ImmutableMap.Builder<String, T> values = ImmutableMap.builder();
+    getUsedNames(option)
+        .forEach(
+            name -> parseOptionWithName(option, name).ifPresent(value -> values.put(name, value)));
+    return values.build();
+  }
+
+  private <T extends Enum<T>> Optional<T> parseOptionWithName(EnumOption<T> option, String key) {
+    checkArgument(processingEnvironment.getOptions().containsKey(key), "key %s not found", key);
+    String stringValue = processingEnvironment.getOptions().get(key);
+    if (stringValue == null) {
+      processingEnvironment
+          .getMessager()
+          .printMessage(Diagnostic.Kind.ERROR, "Processor option -A" + key + " needs a value");
+    } else {
+      try {
+        T value =
+            Enum.valueOf(option.defaultValue().getDeclaringClass(), Ascii.toUpperCase(stringValue));
+        if (option.validValues().contains(value)) {
+          return Optional.of(value);
+        }
+      } catch (IllegalArgumentException e) {
+        // handled below
+      }
+      processingEnvironment
+          .getMessager()
+          .printMessage(
+              Diagnostic.Kind.ERROR,
+              String.format(
+                  "Processor option -A%s may only have the values %s "
+                      + "(case insensitive), found: %s",
+                  key, option.validValues(), stringValue));
+    }
+    return Optional.empty();
+  }
+
+  private Stream<String> getUsedNames(CommandLineOption option) {
+    return option.allNames().filter(name -> processingEnvironment.getOptions().containsKey(name));
+  }
 }
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 681cfafb3..45213b2de 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -106,14 +106,13 @@ public final String toString() {
   }
 
   /**
-   * Returns {@code true} if this graph was constructed from a module for module binding validation.
+   * Returns {@code true} if this graph was constructed from a module for full binding graph
+   * validation.
    *
-   * @see <a href="https://google.github.io/dagger/compiler-options#module-binding-validation">Module binding
-   *     validation</a>
    * @deprecated use {@link #isFullBindingGraph()} to tell if this is a full binding graph, or
    *     {@link ComponentNode#isRealComponent() rootComponentNode().isRealComponent()} to tell if
-   *     the root component node is really a component or derived from a module. Dagger will soon
-   *     generate full binding graphs for components and subcomponents as well as modules.
+   *     the root component node is really a component or derived from a module. Dagger can generate
+   *     full binding graphs for components and subcomponents as well as modules.
    */
   @Deprecated
   public final boolean isModuleBindingGraph() {
@@ -124,6 +123,9 @@ public final boolean isModuleBindingGraph() {
    * Returns {@code true} if this is a full binding graph, which contains all bindings installed in
    * the component, or {@code false} if it is a reachable binding graph, which contains only
    * bindings that are reachable from at least one {@linkplain #entryPointEdges() entry point}.
+   *
+   * @see <a href="https://google.github.io/dagger/compiler-options#full-binding-graph-validation">Full binding
+   *     graph validation</a>
    */
   public abstract boolean isFullBindingGraph();
 
diff --git a/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java b/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
index f43e34c31..4a4e0a51d 100644
--- a/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
+++ b/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
@@ -106,7 +106,7 @@ public void cyclicDependencyWithModuleBindingValidation() {
 
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .withOptions("-Adagger.fullBindingGraphValidation=ERROR")
             .compile(SIMPLE_CYCLIC_DEPENDENCY);
     assertThat(compilation).failed();
 
diff --git a/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java b/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java
index f5863a30d..14a6fb967 100644
--- a/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java
+++ b/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java
@@ -33,19 +33,19 @@
 @RunWith(Parameterized.class)
 public class DuplicateBindingsValidationTest {
 
-  @Parameters(name = "moduleBindingValidation={0}")
+  @Parameters(name = "fullBindingGraphValidation={0}")
   public static ImmutableList<Object[]> parameters() {
     return ImmutableList.copyOf(new Object[][] {{false}, {true}});
   }
 
-  private final boolean moduleBindingValidation;
+  private final boolean fullBindingGraphValidation;
 
-  public DuplicateBindingsValidationTest(boolean moduleBindingValidation) {
-    this.moduleBindingValidation = moduleBindingValidation;
+  public DuplicateBindingsValidationTest(boolean fullBindingGraphValidation) {
+    this.fullBindingGraphValidation = fullBindingGraphValidation;
   }
 
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
-    assumeFalse(moduleBindingValidation);
+    assumeFalse(fullBindingGraphValidation);
 
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -82,7 +82,7 @@ public DuplicateBindingsValidationTest(boolean moduleBindingValidation) {
         "}");
 
     Compilation compilation =
-        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
+        daggerCompiler().withOptions(fullBindingGraphValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -134,7 +134,7 @@ public DuplicateBindingsValidationTest(boolean moduleBindingValidation) {
             "}");
 
     Compilation compilation =
-        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
+        daggerCompiler().withOptions(fullBindingGraphValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -145,7 +145,7 @@ public DuplicateBindingsValidationTest(boolean moduleBindingValidation) {
         .inFile(component)
         .onLineContaining("interface TestComponent");
 
-    if (moduleBindingValidation) {
+    if (fullBindingGraphValidation) {
       assertThat(compilation)
           .hadErrorContaining(
               message(
@@ -157,7 +157,7 @@ public DuplicateBindingsValidationTest(boolean moduleBindingValidation) {
     }
 
     // The duplicate bindngs are also requested from B, but we don't want to report them again.
-    assertThat(compilation).hadErrorCount(moduleBindingValidation ? 2 : 1);
+    assertThat(compilation).hadErrorCount(fullBindingGraphValidation ? 2 : 1);
   }
 
   @Test
@@ -200,7 +200,7 @@ public void duplicateExplicitBindings_ProvidesVsBinds() {
             "}");
 
     Compilation compilation =
-        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
+        daggerCompiler().withOptions(fullBindingGraphValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -211,7 +211,7 @@ public void duplicateExplicitBindings_ProvidesVsBinds() {
         .inFile(component)
         .onLineContaining("interface TestComponent");
 
-    if (moduleBindingValidation) {
+    if (fullBindingGraphValidation) {
       assertThat(compilation)
           .hadErrorContaining(
               message(
@@ -268,7 +268,7 @@ public void duplicateExplicitBindings_multibindingsAndExplicitSets() {
             "}");
 
     Compilation compilation =
-        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
+        daggerCompiler().withOptions(fullBindingGraphValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -284,7 +284,7 @@ public void duplicateExplicitBindings_multibindingsAndExplicitSets() {
                 "        @Provides Set<String> test.Outer.TestModule2.stringSet()"))
         .inFile(component)
         .onLineContaining(
-            moduleBindingValidation ? "class TestModule3" : "interface TestComponent");
+            fullBindingGraphValidation ? "class TestModule3" : "interface TestComponent");
   }
 
   @Test
@@ -337,7 +337,7 @@ public void duplicateExplicitBindings_multibindingsAndExplicitMaps() {
             "}");
 
     Compilation compilation =
-        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
+        daggerCompiler().withOptions(fullBindingGraphValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -356,7 +356,7 @@ public void duplicateExplicitBindings_multibindingsAndExplicitMaps() {
                 "        @Provides Map<String,String> test.Outer.TestModule2.stringMap()"))
         .inFile(component)
         .onLineContaining(
-            moduleBindingValidation ? "class TestModule3" : "interface TestComponent");
+            fullBindingGraphValidation ? "class TestModule3" : "interface TestComponent");
   }
 
   @Test
@@ -394,7 +394,7 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Se
             "}");
 
     Compilation compilation =
-        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
+        daggerCompiler().withOptions(fullBindingGraphValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -407,7 +407,7 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Se
                 "        @Provides Set<String> test.Outer.TestModule2.stringSet()"))
         .inFile(component)
         .onLineContaining(
-            moduleBindingValidation ? "class TestModule3" : "interface TestComponent");
+            fullBindingGraphValidation ? "class TestModule3" : "interface TestComponent");
   }
 
   @Test
@@ -447,7 +447,7 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Ma
             "}");
 
     Compilation compilation =
-        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
+        daggerCompiler().withOptions(fullBindingGraphValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -461,7 +461,7 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Ma
                 "        @Provides Map<String,String> test.Outer.TestModule2.stringMap()"))
         .inFile(component)
         .onLineContaining(
-            moduleBindingValidation ? "class TestModule3" : "interface TestComponent");
+            fullBindingGraphValidation ? "class TestModule3" : "interface TestComponent");
   }
 
   @Test public void duplicateBindings_TruncateAfterLimit() {
@@ -574,7 +574,7 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Ma
             "}");
 
     Compilation compilation =
-        daggerCompiler().withOptions(moduleBindingValidationOption()).compile(component);
+        daggerCompiler().withOptions(fullBindingGraphValidationOption()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -592,7 +592,7 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Ma
                 "    @Provides test.Outer.A test.Outer.Module10.provideA()",
                 "    and 2 others"))
         .inFile(component)
-        .onLineContaining(moduleBindingValidation ? "class Modules" : "interface TestComponent");
+        .onLineContaining(fullBindingGraphValidation ? "class Modules" : "interface TestComponent");
   }
 
   @Test
@@ -647,7 +647,7 @@ public void childBindingConflictsWithParent() {
 
     Compilation compilation =
         daggerCompiler()
-            .withOptions(moduleBindingValidationOption())
+            .withOptions(fullBindingGraphValidationOption())
             .compile(aComponent, bComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
@@ -657,7 +657,7 @@ public void childBindingConflictsWithParent() {
                 "    @Provides Object test.A.AModule.abConflict()",
                 "    @Provides Object test.B.BModule.abConflict()"))
         .inFile(aComponent)
-        .onLineContaining(moduleBindingValidation ? "class AModule" : "interface A {");
+        .onLineContaining(fullBindingGraphValidation ? "class AModule" : "interface A {");
   }
 
   @Test
@@ -728,7 +728,7 @@ public void grandchildBindingConflictsWithGrandparent() {
 
     Compilation compilation =
         daggerCompiler()
-            .withOptions(moduleBindingValidationOption())
+            .withOptions(fullBindingGraphValidationOption())
             .compile(aComponent, bComponent, cComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
@@ -738,7 +738,7 @@ public void grandchildBindingConflictsWithGrandparent() {
                 "    @Provides Object test.A.AModule.acConflict()",
                 "    @Provides Object test.C.CModule.acConflict()"))
         .inFile(aComponent)
-        .onLineContaining(moduleBindingValidation ? "class AModule" : "interface A {");
+        .onLineContaining(fullBindingGraphValidation ? "class AModule" : "interface A {");
   }
 
   @Test
@@ -804,7 +804,7 @@ public void grandchildBindingConflictsWithChild() {
 
     Compilation compilation =
         daggerCompiler()
-            .withOptions(moduleBindingValidationOption())
+            .withOptions(fullBindingGraphValidationOption())
             .compile(aComponent, bComponent, cComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
@@ -813,13 +813,13 @@ public void grandchildBindingConflictsWithChild() {
                 "java.lang.Object is bound multiple times:",
                 "    @Provides Object test.B.BModule.bcConflict()",
                 "    @Provides Object test.C.CModule.bcConflict()"))
-        .inFile(moduleBindingValidation ? bComponent : aComponent)
-        .onLineContaining(moduleBindingValidation ? "class BModule" : "interface A {");
+        .inFile(fullBindingGraphValidation ? bComponent : aComponent)
+        .onLineContaining(fullBindingGraphValidation ? "class BModule" : "interface A {");
   }
 
   @Test
   public void childProvidesConflictsWithParentInjects() {
-    assumeFalse(moduleBindingValidation);
+    assumeFalse(fullBindingGraphValidation);
 
     JavaFileObject foo =
         JavaFileObjects.forSourceLines(
@@ -992,7 +992,7 @@ public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning()
 
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.nullableValidation=WARNING", moduleBindingValidationOption())
+            .withOptions("-Adagger.nullableValidation=WARNING", fullBindingGraphValidationOption())
             .compile(parentConflictsWithChild, child);
     assertThat(compilation).failed();
     assertThat(compilation)
@@ -1004,11 +1004,13 @@ public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning()
                     + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()"))
         .inFile(parentConflictsWithChild)
         .onLineContaining(
-            moduleBindingValidation ? "class ParentModule" : "interface ParentConflictsWithChild");
+            fullBindingGraphValidation
+                ? "class ParentModule"
+                : "interface ParentConflictsWithChild");
   }
 
-  private String moduleBindingValidationOption() {
-    return "-Adagger.moduleBindingValidation=" + (moduleBindingValidation ? "ERROR" : "NONE");
+  private String fullBindingGraphValidationOption() {
+    return "-Adagger.fullBindingGraphValidation=" + (fullBindingGraphValidation ? "ERROR" : "NONE");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/ModuleBindingValidationTest.java b/javatests/dagger/internal/codegen/FullBindingGraphValidationTest.java
similarity index 87%
rename from javatests/dagger/internal/codegen/ModuleBindingValidationTest.java
rename to javatests/dagger/internal/codegen/FullBindingGraphValidationTest.java
index 28338775c..944e30794 100644
--- a/javatests/dagger/internal/codegen/ModuleBindingValidationTest.java
+++ b/javatests/dagger/internal/codegen/FullBindingGraphValidationTest.java
@@ -29,7 +29,7 @@
 import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
-public final class ModuleBindingValidationTest {
+public final class FullBindingGraphValidationTest {
   private static final JavaFileObject MODULE_WITH_ERRORS =
       JavaFileObjects.forSourceLines(
           "test.ModuleWithErrors",
@@ -62,7 +62,7 @@ public void moduleWithErrors_validationTypeNone() {
   public void moduleWithErrors_validationTypeError() {
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .withOptions("-Adagger.fullBindingGraphValidation=ERROR")
             .compile(MODULE_WITH_ERRORS);
 
     assertThat(compilation).failed();
@@ -79,7 +79,7 @@ public void moduleWithErrors_validationTypeError() {
   public void moduleWithErrors_validationTypeWarning() {
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=WARNING")
+            .withOptions("-Adagger.fullBindingGraphValidation=WARNING")
             .compile(MODULE_WITH_ERRORS);
 
     assertThat(compilation).succeeded();
@@ -114,7 +114,7 @@ public void includesModuleWithErrors_validationTypeNone() {
   public void includesModuleWithErrors_validationTypeError() {
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .withOptions("-Adagger.fullBindingGraphValidation=ERROR")
             .compile(MODULE_WITH_ERRORS, INCLUDES_MODULE_WITH_ERRORS);
 
     assertThat(compilation).failed();
@@ -136,7 +136,7 @@ public void includesModuleWithErrors_validationTypeError() {
   public void includesModuleWithErrors_validationTypeWarning() {
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=WARNING")
+            .withOptions("-Adagger.fullBindingGraphValidation=WARNING")
             .compile(MODULE_WITH_ERRORS, INCLUDES_MODULE_WITH_ERRORS);
 
     assertThat(compilation).succeeded();
@@ -199,7 +199,7 @@ public void moduleIncludingModuleWithCombinedErrors_validationTypeNone() {
   public void moduleIncludingModuleWithCombinedErrors_validationTypeError() {
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .withOptions("-Adagger.fullBindingGraphValidation=ERROR")
             .compile(A_MODULE, COMBINED_WITH_A_MODULE_HAS_ERRORS);
 
     assertThat(compilation).failed();
@@ -216,7 +216,7 @@ public void moduleIncludingModuleWithCombinedErrors_validationTypeError() {
   public void moduleIncludingModuleWithCombinedErrors_validationTypeWarning() {
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=WARNING")
+            .withOptions("-Adagger.fullBindingGraphValidation=WARNING")
             .compile(A_MODULE, COMBINED_WITH_A_MODULE_HAS_ERRORS);
 
     assertThat(compilation).succeeded();
@@ -265,7 +265,7 @@ public void subcomponentWithErrors_validationTypeNone() {
   public void subcomponentWithErrors_validationTypeError() {
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .withOptions("-Adagger.fullBindingGraphValidation=ERROR")
             .compile(SUBCOMPONENT_WITH_ERRORS, A_MODULE);
 
     assertThat(compilation).failed();
@@ -282,7 +282,7 @@ public void subcomponentWithErrors_validationTypeError() {
   public void subcomponentWithErrors_validationTypeWarning() {
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=WARNING")
+            .withOptions("-Adagger.fullBindingGraphValidation=WARNING")
             .compile(SUBCOMPONENT_WITH_ERRORS, A_MODULE);
 
     assertThat(compilation).succeeded();
@@ -319,7 +319,7 @@ public void moduleWithSubcomponentWithErrors_validationTypeNone() {
   public void moduleWithSubcomponentWithErrors_validationTypeError() {
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .withOptions("-Adagger.fullBindingGraphValidation=ERROR")
             .compile(MODULE_WITH_SUBCOMPONENT_WITH_ERRORS, SUBCOMPONENT_WITH_ERRORS, A_MODULE);
 
     assertThat(compilation).failed();
@@ -342,7 +342,7 @@ public void moduleWithSubcomponentWithErrors_validationTypeError() {
   public void moduleWithSubcomponentWithErrors_validationTypeWarning() {
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=WARNING")
+            .withOptions("-Adagger.fullBindingGraphValidation=WARNING")
             .compile(MODULE_WITH_SUBCOMPONENT_WITH_ERRORS, SUBCOMPONENT_WITH_ERRORS, A_MODULE);
 
     assertThat(compilation).succeeded();
@@ -409,7 +409,7 @@ public void moduleWithSubcomponentWithCombinedErrors_validationTypeNone() {
   public void moduleWithSubcomponentWithCombinedErrors_validationTypeError() {
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .withOptions("-Adagger.fullBindingGraphValidation=ERROR")
             .compile(COMBINED_WITH_A_SUBCOMPONENT_HAS_ERRORS, A_SUBCOMPONENT, A_MODULE);
 
     assertThat(compilation).failed();
@@ -426,7 +426,7 @@ public void moduleWithSubcomponentWithCombinedErrors_validationTypeError() {
   public void moduleWithSubcomponentWithCombinedErrors_validationTypeWarning() {
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=WARNING")
+            .withOptions("-Adagger.fullBindingGraphValidation=WARNING")
             .compile(COMBINED_WITH_A_SUBCOMPONENT_HAS_ERRORS, A_SUBCOMPONENT, A_MODULE);
 
     assertThat(compilation).succeeded();
@@ -438,4 +438,41 @@ public void moduleWithSubcomponentWithCombinedErrors_validationTypeWarning() {
 
     assertThat(compilation).hadWarningCount(1);
   }
+
+  @Test
+  public void bothAliasesDifferentValues() {
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(
+                "-Adagger.moduleBindingValidation=NONE",
+                "-Adagger.fullBindingGraphValidation=ERROR")
+            .compile(MODULE_WITH_ERRORS);
+
+    assertThat(compilation).failed();
+
+    assertThat(compilation)
+        .hadErrorContaining(
+            "Only one of the equivalent options "
+                + "(-Adagger.fullBindingGraphValidation, -Adagger.moduleBindingValidation)"
+                + " should be used; prefer -Adagger.fullBindingGraphValidation");
+
+    assertThat(compilation).hadErrorCount(1);
+  }
+
+  @Test
+  public void bothAliasesSameValue() {
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(
+                "-Adagger.moduleBindingValidation=NONE", "-Adagger.fullBindingGraphValidation=NONE")
+            .compile(MODULE_WITH_ERRORS);
+
+    assertThat(compilation).succeeded();
+
+    assertThat(compilation)
+        .hadWarningContaining(
+            "Only one of the equivalent options "
+                + "(-Adagger.fullBindingGraphValidation, -Adagger.moduleBindingValidation)"
+                + " should be used; prefer -Adagger.fullBindingGraphValidation");
+  }
 }
diff --git a/javatests/dagger/internal/codegen/MapMultibindingValidationTest.java b/javatests/dagger/internal/codegen/MapMultibindingValidationTest.java
index b2ed61456..04b0986e8 100644
--- a/javatests/dagger/internal/codegen/MapMultibindingValidationTest.java
+++ b/javatests/dagger/internal/codegen/MapMultibindingValidationTest.java
@@ -71,7 +71,7 @@ public void duplicateMapKeys() {
     assertThat(compilation).hadErrorCount(1);
 
     compilation =
-        daggerCompiler().withOptions("-Adagger.moduleBindingValidation=ERROR").compile(module);
+        daggerCompiler().withOptions("-Adagger.fullBindingGraphValidation=ERROR").compile(module);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -213,7 +213,7 @@ public void inconsistentMapKeyAnnotations() {
 
     compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .withOptions("-Adagger.fullBindingGraphValidation=ERROR")
             .compile(module, stringKeyTwoFile);
     assertThat(compilation).failed();
     assertThat(compilation)
diff --git a/javatests/dagger/internal/codegen/NullableBindingValidationTest.java b/javatests/dagger/internal/codegen/NullableBindingValidationTest.java
index eb0dc2343..24d563643 100644
--- a/javatests/dagger/internal/codegen/NullableBindingValidationTest.java
+++ b/javatests/dagger/internal/codegen/NullableBindingValidationTest.java
@@ -407,7 +407,7 @@ public void moduleValidation() {
 
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .withOptions("-Adagger.fullBindingGraphValidation=ERROR")
             .compile(module, NULLABLE);
     assertThat(compilation).failed();
     assertThat(compilation)
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 4568ca04d..9a852c779 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -167,7 +167,7 @@ public void dependsOnProductionExecutor() {
 
     compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .withOptions("-Adagger.fullBindingGraphValidation=ERROR")
             .compile(producerModuleFile);
     assertThat(compilation).failed();
     assertThat(compilation)
diff --git a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
index 7106dd9e7..8453e03e7 100644
--- a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -154,7 +154,7 @@
 
     compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .withOptions("-Adagger.fullBindingGraphValidation=ERROR")
             .compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
     assertThat(compilation)
diff --git a/javatests/dagger/internal/codegen/ScopingValidationTest.java b/javatests/dagger/internal/codegen/ScopingValidationTest.java
index c8322063f..9efcc2a59 100644
--- a/javatests/dagger/internal/codegen/ScopingValidationTest.java
+++ b/javatests/dagger/internal/codegen/ScopingValidationTest.java
@@ -243,7 +243,7 @@ public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
 
     compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .withOptions("-Adagger.fullBindingGraphValidation=ERROR")
             .compile(componentFile, scopeFile, scopeWithAttribute, typeFile, moduleFile);
     // The @Inject binding for ScopedType should not appear here, but the @Singleton binding should.
     assertThat(compilation)
@@ -259,11 +259,11 @@ public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
   }
 
   @Test
-  public void moduleBindingValidationDoesNotReportForOneScope() {
+  public void fullBindingGraphValidationDoesNotReportForOneScope() {
     Compilation compilation =
         daggerCompiler()
             .withOptions(
-                "-Adagger.moduleBindingValidation=ERROR",
+                "-Adagger.fullBindingGraphValidation=ERROR",
                 "-Adagger.moduleHasDifferentScopesValidation=ERROR")
             .compile(
                 JavaFileObjects.forSourceLines(
@@ -284,11 +284,11 @@ public void moduleBindingValidationDoesNotReportForOneScope() {
   }
 
   @Test
-  public void moduleBindingValidationDoesNotReportInjectBindings() {
+  public void fullBindingGraphValidationDoesNotReportInjectBindings() {
     Compilation compilation =
         daggerCompiler()
             .withOptions(
-                "-Adagger.moduleBindingValidation=ERROR",
+                "-Adagger.fullBindingGraphValidation=ERROR",
                 "-Adagger.moduleHasDifferentScopesValidation=ERROR")
             .compile(
                 JavaFileObjects.forSourceLines(
diff --git a/javatests/dagger/spi/SpiPluginTest.java b/javatests/dagger/spi/SpiPluginTest.java
index e0a78b2e0..613a91507 100644
--- a/javatests/dagger/spi/SpiPluginTest.java
+++ b/javatests/dagger/spi/SpiPluginTest.java
@@ -53,8 +53,7 @@ public void moduleBinding() {
         javac()
             .withProcessors(new ComponentProcessor())
             .withOptions(
-                "-Aerror_on_binding=java.lang.Integer",
-                "-Adagger.moduleBindingValidation=ERROR")
+                "-Aerror_on_binding=java.lang.Integer", "-Adagger.fullBindingGraphValidation=ERROR")
             .compile(module);
     assertThat(compilation).failed();
     assertThat(compilation)
