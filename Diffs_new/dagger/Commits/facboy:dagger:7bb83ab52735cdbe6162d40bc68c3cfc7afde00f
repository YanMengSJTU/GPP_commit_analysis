diff --git a/java/dagger/internal/codegen/DependencyRequestFactory.java b/java/dagger/internal/codegen/DependencyRequestFactory.java
index 95ac61824..a66edd073 100644
--- a/java/dagger/internal/codegen/DependencyRequestFactory.java
+++ b/java/dagger/internal/codegen/DependencyRequestFactory.java
@@ -111,7 +111,7 @@ private RequestKind multibindingContributionRequestKind(
       case MAP:
         MapType mapType = MapType.from(multibindingKey);
         for (RequestKind kind : WRAPPING_MAP_VALUE_FRAMEWORK_TYPES) {
-          if (mapType.valuesAreTypeOf(frameworkClass(kind).get())) {
+          if (mapType.valuesAreTypeOf(frameworkClass(kind))) {
             return kind;
           }
         }
diff --git a/java/dagger/internal/codegen/FrameworkType.java b/java/dagger/internal/codegen/FrameworkType.java
index f596a0f32..8f5fcf767 100644
--- a/java/dagger/internal/codegen/FrameworkType.java
+++ b/java/dagger/internal/codegen/FrameworkType.java
@@ -90,7 +90,7 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
 
         default:
           return Expression.create(
-              types.rewrapType(from.type(), frameworkClass(requestKind).get()), codeBlock);
+              types.rewrapType(from.type(), frameworkClass(requestKind)), codeBlock);
       }
     }
   },
diff --git a/java/dagger/internal/codegen/RequestKinds.java b/java/dagger/internal/codegen/RequestKinds.java
index b13c57b8e..1a1516e51 100644
--- a/java/dagger/internal/codegen/RequestKinds.java
+++ b/java/dagger/internal/codegen/RequestKinds.java
@@ -42,7 +42,6 @@
 import dagger.model.RequestKind;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import java.util.Optional;
 import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
 
@@ -61,7 +60,7 @@ static TypeMirror requestType(RequestKind requestKind, TypeMirror type, DaggerTy
         return types.wrapType(type, ListenableFuture.class);
 
       default:
-        return types.wrapType(type, frameworkClass(requestKind).get());
+        return types.wrapType(type, frameworkClass(requestKind));
     }
   }
 
@@ -94,10 +93,17 @@ static TypeName requestTypeName(RequestKind requestKind, TypeName keyType) {
     }
   }
 
+  private static final ImmutableMap<RequestKind, Class<?>> FRAMEWORK_CLASSES =
+      ImmutableMap.of(
+          PROVIDER, Provider.class,
+          LAZY, Lazy.class,
+          PRODUCER, Producer.class,
+          PRODUCED, Produced.class);
+
   /** Returns the {@link RequestKind} that matches the wrapping types (if any) of {@code type}. */
   static RequestKind getRequestKind(TypeMirror type) {
     checkTypePresent(type);
-    for (RequestKind kind : RequestKind.values()) {
+    for (RequestKind kind : FRAMEWORK_CLASSES.keySet()) {
       if (matchesKind(kind, type)) {
         if (kind.equals(PROVIDER) && matchesKind(LAZY, extractKeyType(kind, type))) {
           return PROVIDER_OF_LAZY;
@@ -113,10 +119,8 @@ static RequestKind getRequestKind(TypeMirror type) {
    * #frameworkClass(RequestKind) framework class}.
    */
   private static boolean matchesKind(RequestKind kind, TypeMirror type) {
-    Optional<Class<?>> frameworkClass = frameworkClass(kind);
-    return frameworkClass.isPresent()
-        && isType(type)
-        && isTypeOf(frameworkClass.get(), type)
+    return isType(type)
+        && isTypeOf(frameworkClass(kind), type)
         && !asDeclared(type).getTypeArguments().isEmpty();
   }
 
@@ -137,18 +141,11 @@ static TypeMirror extractKeyType(RequestKind requestKind, TypeMirror type) {
       case PROVIDER_OF_LAZY:
         return extractKeyType(LAZY, extractKeyType(PROVIDER, type));
       default:
-        checkArgument(isType(type) && isTypeOf(frameworkClass(requestKind).get(), type));
+        checkArgument(isType(type) && isTypeOf(frameworkClass(requestKind), type));
         return getOnlyElement(MoreTypes.asDeclared(type).getTypeArguments());
     }
   }
 
-  private static final ImmutableMap<RequestKind, Class<?>> FRAMEWORK_CLASSES =
-      ImmutableMap.of(
-          PROVIDER, Provider.class,
-          LAZY, Lazy.class,
-          PRODUCER, Producer.class,
-          PRODUCED, Produced.class);
-
   /**
    * A dagger- or {@code javax.inject}-defined class for {@code requestKind} that that can wrap
    * another type but share the same {@link dagger.model.Key}.
@@ -161,8 +158,10 @@ static TypeMirror extractKeyType(RequestKind requestKind, TypeMirror type) {
    * classes, and {@link RequestKind#FUTURE} is wrapped with a {@link ListenableFuture}, but for
    * historical/implementation reasons has not had an associated framework class.
    */
-  static Optional<Class<?>> frameworkClass(RequestKind requestKind) {
-    return Optional.ofNullable(FRAMEWORK_CLASSES.get(requestKind));
+  static Class<?> frameworkClass(RequestKind requestKind) {
+    Class<?> result = FRAMEWORK_CLASSES.get(requestKind);
+    checkArgument(result != null, "no framework class for %s", requestKind);
+    return result;
   }
 
   /**
