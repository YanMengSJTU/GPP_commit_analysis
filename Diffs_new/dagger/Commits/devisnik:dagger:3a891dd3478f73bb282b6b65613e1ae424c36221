diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index fd43c8fad..8751a105c 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -118,6 +118,12 @@ private RequestFulfillment createRequestFulfillment(
                   hasBindingExpressions,
                   providerFieldRequestFulfillment,
                   elements);
+            case SYNTHETIC_OPTIONAL_BINDING:
+              return new OptionalBindingRequestFulfillment(
+                  bindingKey,
+                  provisionBinding,
+                  providerFieldRequestFulfillment,
+                  hasBindingExpressions);
             case INJECTION:
             case PROVISION:
               if (provisionBinding.implicitDependencies().isEmpty()
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 5cdc04065..b412d80c3 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -654,14 +654,19 @@ private boolean multibindingsRequireProduction(
         if (optionalBindingDeclarations.isEmpty()) {
           return Optional.empty();
         }
+        DependencyRequest.Kind kind =
+            DependencyRequest.extractKindAndType(OptionalType.from(key).valueType()).kind();
         ResolvedBindings underlyingKeyBindings =
             lookUpBindings(contribution(keyFactory.unwrapOptional(key).get()));
         if (underlyingKeyBindings.isEmpty()) {
           return Optional.of(provisionBindingFactory.syntheticAbsentBinding(key));
-        } else if (underlyingKeyBindings.bindingTypes().contains(BindingType.PRODUCTION)) {
-          return Optional.of(productionBindingFactory.syntheticPresentBinding(key));
+        } else if (underlyingKeyBindings.bindingTypes().contains(BindingType.PRODUCTION)
+            // handles producerFromProvider cases
+            || kind.equals(DependencyRequest.Kind.PRODUCER)
+            || kind.equals(DependencyRequest.Kind.PRODUCED)) {
+          return Optional.of(productionBindingFactory.syntheticPresentBinding(key, kind));
         } else {
-          return Optional.of(provisionBindingFactory.syntheticPresentBinding(key));
+          return Optional.of(provisionBindingFactory.syntheticPresentBinding(key, kind));
         }
       }
 
diff --git a/java/dagger/internal/codegen/DependencyRequest.java b/java/dagger/internal/codegen/DependencyRequest.java
index fb0420218..2dc8a28c9 100644
--- a/java/dagger/internal/codegen/DependencyRequest.java
+++ b/java/dagger/internal/codegen/DependencyRequest.java
@@ -161,7 +161,7 @@ TypeName typeName(TypeName keyType) {
 
   abstract Kind kind();
   abstract Key key();
-  
+
   BindingKey bindingKey() {
     switch (kind()) {
       case INSTANCE:
diff --git a/java/dagger/internal/codegen/OptionalBindingRequestFulfillment.java b/java/dagger/internal/codegen/OptionalBindingRequestFulfillment.java
new file mode 100644
index 000000000..609e24159
--- /dev/null
+++ b/java/dagger/internal/codegen/OptionalBindingRequestFulfillment.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.OptionalType.OptionalKind;
+
+/**
+ * A {@link RequestFulfillment} for {@link
+ * dagger.internal.codegen.ContributionBinding.Kind#SYNTHETIC_OPTIONAL_BINDING}
+ */
+final class OptionalBindingRequestFulfillment extends SimpleInvocationRequestFulfillment {
+  private final ProvisionBinding binding;
+  private final HasBindingExpressions hasBindingExpressions;
+
+  OptionalBindingRequestFulfillment(
+      BindingKey bindingKey,
+      ProvisionBinding binding,
+      RequestFulfillment delegate,
+      HasBindingExpressions hasBindingExpressions) {
+    super(bindingKey, delegate);
+    this.binding = binding;
+    this.hasBindingExpressions = hasBindingExpressions;
+  }
+
+  @Override
+  CodeBlock getSimpleInvocation(DependencyRequest request, ClassName requestingClass) {
+    OptionalType optionalType = OptionalType.from(binding.key());
+    OptionalKind optionalKind = optionalType.kind();
+    if (binding.dependencies().isEmpty()) {
+      // When compiling with -source 7, javac's type inference isn't strong enough to detect
+      // Futures.immediateFuture(Optional.absent()) for keys that aren't Object
+      if (request.kind().equals(DependencyRequest.Kind.FUTURE)
+          && isTypeAccessibleFrom(binding.key().type(), requestingClass.packageName())) {
+        return optionalKind.parameterizedAbsentValueExpression(optionalType);
+      }
+      return optionalKind.absentValueExpression();
+    }
+    DependencyRequest dependency = getOnlyElement(binding.dependencies());
+    return optionalKind.presentExpression(
+        hasBindingExpressions
+            .getBindingExpression(dependency.bindingKey())
+            .getSnippetForDependencyRequest(dependency, requestingClass));
+  }
+}
diff --git a/java/dagger/internal/codegen/OptionalFactories.java b/java/dagger/internal/codegen/OptionalFactories.java
index 4d608f8c7..49c30ad5b 100644
--- a/java/dagger/internal/codegen/OptionalFactories.java
+++ b/java/dagger/internal/codegen/OptionalFactories.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
@@ -190,11 +191,10 @@ String factoryClassName() {
     }
 
     private static PresentFactorySpec of(ContributionBinding binding) {
-      OptionalKind optionalKind = OptionalType.from(binding.key()).kind();
-      DependencyRequest.Kind valueKind =
-          DependencyRequest.extractKindAndType(OptionalType.from(binding.key()).valueType()).kind();
       return new AutoValue_OptionalFactories_PresentFactorySpec(
-          binding.bindingType(), optionalKind, valueKind);
+          binding.bindingType(),
+          OptionalType.from(binding.key()).kind(),
+          getOnlyElement(binding.dependencies()).kind());
     }
   }
   
diff --git a/java/dagger/internal/codegen/OptionalType.java b/java/dagger/internal/codegen/OptionalType.java
index f154ab2d1..c68aebf14 100644
--- a/java/dagger/internal/codegen/OptionalType.java
+++ b/java/dagger/internal/codegen/OptionalType.java
@@ -68,6 +68,13 @@ CodeBlock absentValueExpression() {
       return CodeBlock.of("$T.$L()", clazz, absentFactoryMethodName);
     }
 
+    /**
+     * Returns an expression for the absent/empty value, parameterized with {@link #valueType()}.
+     */
+    CodeBlock parameterizedAbsentValueExpression(OptionalType optionalType) {
+      return CodeBlock.of("$T.<$T>$L()", clazz, optionalType.valueType(), absentFactoryMethodName);
+    }
+
     /** Returns an expression for the present {@code value}. */
     CodeBlock presentExpression(CodeBlock value) {
       return CodeBlock.of("$T.of($L)", clazz, value);
diff --git a/java/dagger/internal/codegen/ProductionBinding.java b/java/dagger/internal/codegen/ProductionBinding.java
index dd9f3a18b..1c802632b 100644
--- a/java/dagger/internal/codegen/ProductionBinding.java
+++ b/java/dagger/internal/codegen/ProductionBinding.java
@@ -245,14 +245,13 @@ ProductionBinding delegate(
      * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
      * component with a binding for the underlying key.
      */
-    ProductionBinding syntheticPresentBinding(Key key) {
+    ProductionBinding syntheticPresentBinding(Key key, DependencyRequest.Kind kind) {
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(key)
           .bindingKind(Kind.SYNTHETIC_OPTIONAL_BINDING)
           .explicitDependencies(
-              dependencyRequestFactory.forSyntheticPresentOptionalBinding(
-                  key, DependencyRequest.Kind.PRODUCER))
+              dependencyRequestFactory.forSyntheticPresentOptionalBinding(key, kind))
           .build();
     }
   }
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index 5de760e93..d5779e9ff 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -393,12 +393,11 @@ ProvisionBinding syntheticAbsentBinding(Key key) {
      * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
      * component with a binding for the underlying key.
      */
-    ProvisionBinding syntheticPresentBinding(Key key) {
+    ProvisionBinding syntheticPresentBinding(Key key, DependencyRequest.Kind kind) {
       return syntheticAbsentBinding(key)
           .toBuilder()
           .explicitDependencies(
-              dependencyRequestFactory.forSyntheticPresentOptionalBinding(
-                  key, DependencyRequest.Kind.PROVIDER))
+              dependencyRequestFactory.forSyntheticPresentOptionalBinding(key, kind))
           .build();
     }
   }
diff --git a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
new file mode 100644
index 000000000..9cc900581
--- /dev/null
+++ b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
@@ -0,0 +1,391 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class OptionalBindingRequestFulfillmentTest {
+  @Test
+  public void inlinedOptionalBindings() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.BindsOptionalOf;",
+            "import other.Maybe;",
+            "import other.DefinitelyNot;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @BindsOptionalOf Maybe maybe();",
+            "  @BindsOptionalOf DefinitelyNot definitelyNot();",
+            "}");
+    JavaFileObject maybe =
+        JavaFileObjects.forSourceLines(
+            "other.Maybe",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "public class Maybe {",
+            "  @Module",
+            "  public interface MaybeModule {",
+            "    @Provides static Maybe provideMaybe() { return new Maybe(); }",
+            "  }",
+            "}");
+    JavaFileObject definitelyNot =
+        JavaFileObjects.forSourceLines(
+            "other.DefinitelyNot",
+            "package other;",
+            "",
+            "public class DefinitelyNot {}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.Component;",
+            "import dagger.Lazy;",
+            "import javax.inject.Provider;",
+            "import other.Maybe;",
+            "import other.DefinitelyNot;",
+            "",
+            "@Component(modules = {TestModule.class, Maybe.MaybeModule.class})",
+            "interface TestComponent {",
+            "  Optional<Maybe> maybe();",
+            "  Optional<Provider<Lazy<Maybe>>> providerOfLazyOfMaybe();",
+            "  Optional<DefinitelyNot> definitelyNot();",
+            "  Optional<Provider<Lazy<DefinitelyNot>>> providerOfLazyOfDefinitelyNot();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.Lazy;",
+            "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.Preconditions;",
+            "import dagger.internal.ProviderOfLazy;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "import other.DefinitelyNot;",
+            "import other.Maybe;",
+            "import other.Maybe_MaybeModule_ProvideMaybeFactory;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  @SuppressWarnings(\"rawtypes\")",
+            "  private static final Provider ABSENT_GUAVA_OPTIONAL_PROVIDER =",
+            "      InstanceFactory.create(Optional.absent());",
+            "",
+            "  private Provider<Optional<Maybe>> optionalOfMaybeProvider;",
+            "",
+            "  private Provider<Optional<Provider<Lazy<Maybe>>>> ",
+            "      optionalOfProviderOfLazyOfMaybeProvider;",
+            "",
+            "  private Provider<Optional<DefinitelyNot>> optionalOfDefinitelyNotProvider;",
+            "",
+            "  private Provider<Optional<Provider<Lazy<DefinitelyNot>>>>",
+            "      optionalOfProviderOfLazyOfDefinitelyNotProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "",
+            "    this.optionalOfMaybeProvider =",
+            "        PresentGuavaOptionalInstanceProvider.of(",
+            "            Maybe_MaybeModule_ProvideMaybeFactory.create());",
+            "",
+            "    this.optionalOfProviderOfLazyOfMaybeProvider =",
+            "        PresentGuavaOptionalProviderOfLazyProvider.of(",
+            "            Maybe_MaybeModule_ProvideMaybeFactory.create());",
+            "",
+            "    this.optionalOfDefinitelyNotProvider = absentGuavaOptionalProvider();",
+            "",
+            "    this.optionalOfProviderOfLazyOfDefinitelyNotProvider = ",
+            "        absentGuavaOptionalProvider();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Optional<Maybe> maybe() {",
+            "    return Optional.of(Maybe.MaybeModule.provideMaybe());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Optional<Provider<Lazy<Maybe>>> providerOfLazyOfMaybe() {",
+            "    return Optional.of(",
+            "        ProviderOfLazy.create(Maybe_MaybeModule_ProvideMaybeFactory.create()));",
+            "  }",
+            "",
+            "  @Override",
+            "  public Optional<DefinitelyNot> definitelyNot() {",
+            "    return Optional.absent();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Optional<Provider<Lazy<DefinitelyNot>>> providerOfLazyOfDefinitelyNot() {",
+            "    return Optional.absent();",
+            "  }",
+            "",
+            "  private static <T> Provider<Optional<T>> absentGuavaOptionalProvider() {",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    Provider<Optional<T>> provider = ",
+            "        (Provider<Optional<T>>) ABSENT_GUAVA_OPTIONAL_PROVIDER;",
+            "    return provider;",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private static final class PresentGuavaOptionalInstanceProvider<T>",
+            "      implements Provider<Optional<T>> {",
+            "    private final Provider<T> delegate;",
+            "",
+            "    private PresentGuavaOptionalInstanceProvider(Provider<T> delegate) {",
+            "      this.delegate = Preconditions.checkNotNull(delegate);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Optional<T> get() {",
+            "      return Optional.of(delegate.get());",
+            "    }",
+            "",
+            "    private static <T> Provider<Optional<T>> of(Provider<T> delegate) {",
+            "      return new PresentGuavaOptionalInstanceProvider<T>(delegate);",
+            "    }",
+            "  }",
+            "",
+            "  private static final class PresentGuavaOptionalProviderOfLazyProvider<T>",
+            "      implements Provider<Optional<Provider<Lazy<T>>>> {",
+            "    private final Provider<T> delegate;",
+            "",
+            "    private PresentGuavaOptionalProviderOfLazyProvider(Provider<T> delegate) {",
+            "      this.delegate = Preconditions.checkNotNull(delegate);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Optional<Provider<Lazy<T>>> get() {",
+            "      return Optional.of(ProviderOfLazy.create(delegate));",
+            "    }",
+            "",
+            "    private static <T> Provider<Optional<Provider<Lazy<T>>>> of(",
+            "        Provider<T> delegate) {",
+            "      return new PresentGuavaOptionalProviderOfLazyProvider<T>(delegate);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(module, maybe, definitelyNot, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void requestForFuture() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.BindsOptionalOf;",
+            "import other.Maybe;",
+            "import other.DefinitelyNot;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @BindsOptionalOf Maybe maybe();",
+            "  @BindsOptionalOf DefinitelyNot definitelyNot();",
+            "}");
+    JavaFileObject maybe =
+        JavaFileObjects.forSourceLines(
+            "other.Maybe",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "public class Maybe {",
+            "  @Module",
+            "  public interface MaybeModule {",
+            "    @Provides static Maybe provideMaybe() { return new Maybe(); }",
+            "  }",
+            "}");
+    JavaFileObject definitelyNot =
+        JavaFileObjects.forSourceLines(
+            "other.DefinitelyNot",
+            "package other;",
+            "",
+            "public class DefinitelyNot {}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionComponent;",
+            "import javax.inject.Provider;",
+            "import other.Maybe;",
+            "import other.DefinitelyNot;",
+            "",
+            "@ProductionComponent(modules = {TestModule.class, Maybe.MaybeModule.class})",
+            "interface TestComponent {",
+            "  ListenableFuture<Optional<Maybe>> maybe();",
+            "  ListenableFuture<Optional<DefinitelyNot>> definitelyNot();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "import other.DefinitelyNot;",
+            "import other.Maybe;",
+            "import other.Maybe_MaybeModule_ProvideMaybeFactory;",
+            "",
+            GENERATED_ANNOTATION,
+            "  public final class DaggerTestComponent implements TestComponent {",
+            "    @SuppressWarnings(\"rawtypes\")",
+            "    private static final Provider ABSENT_GUAVA_OPTIONAL_PROVIDER =",
+            "        InstanceFactory.create(Optional.absent());",
+            "    private Provider<Optional<Maybe>> optionalOfMaybeProvider;",
+            "    private Provider<Optional<DefinitelyNot>> optionalOfDefinitelyNotProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "      assert builder != null;",
+            "      initialize(builder);",
+            "    }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.optionalOfMaybeProvider =",
+            "        PresentGuavaOptionalInstanceProvider.of(",
+            "            Maybe_MaybeModule_ProvideMaybeFactory.create());",
+            "    this.optionalOfDefinitelyNotProvider = absentGuavaOptionalProvider();",
+            "  }",
+            "",
+            "  @Override",
+            "  public ListenableFuture<Optional<Maybe>> maybe() {",
+            "    return Futures.immediateFuture(Optional.of(Maybe.MaybeModule.provideMaybe()));",
+            "  }",
+            "",
+            "  @Override",
+            "  public ListenableFuture<Optional<DefinitelyNot>> definitelyNot() {",
+            "    return Futures.immediateFuture(Optional.<DefinitelyNot>absent());",
+
+            "  }",
+            "",
+            "  private static <T> Provider<Optional<T>> absentGuavaOptionalProvider() {",
+            "    @SuppressWarnings(\"unchecked\")",
+            "        Provider<Optional<T>> provider = ",
+            "            (Provider<Optional<T>>) ABSENT_GUAVA_OPTIONAL_PROVIDER;",
+            "    return provider;",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder testComponent_ProductionExecutorModule(",
+            "        TestComponent_ProductionExecutorModule",
+            "            testComponent_ProductionExecutorModule) {",
+            "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private static final class PresentGuavaOptionalInstanceProvider<T>",
+            "      implements Provider<Optional<T>> {",
+            "    private final Provider<T> delegate;",
+            "",
+            "    private PresentGuavaOptionalInstanceProvider(Provider<T> delegate) {",
+            "      this.delegate = Preconditions.checkNotNull(delegate);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Optional<T> get() {",
+            "      return Optional.of(delegate.get());",
+            "    }",
+            "",
+            "    private static <T> Provider<Optional<T>> of(Provider<T> delegate) {",
+            "      return new PresentGuavaOptionalInstanceProvider<T>(delegate);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(module, maybe, definitelyNot, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+}
