diff --git a/java/dagger/model/BUILD b/java/dagger/model/BUILD
index f91b9141d..5fe0db375 100644
--- a/java/dagger/model/BUILD
+++ b/java/dagger/model/BUILD
@@ -45,6 +45,7 @@ java_library(
         "@google_bazel_common//third_party/java/auto:value",
         "@google_bazel_common//third_party/java/error_prone:annotations",
         "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/javapoet",
         "@google_bazel_common//third_party/java/jsr330_inject",
     ],
 )
diff --git a/java/dagger/model/Key.java b/java/dagger/model/Key.java
index df5d32de9..53ee39194 100644
--- a/java/dagger/model/Key.java
+++ b/java/dagger/model/Key.java
@@ -17,6 +17,7 @@
 package dagger.model;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.stream.Collectors.joining;
 
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreTypes;
@@ -25,12 +26,17 @@
 import com.google.common.base.Equivalence;
 import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableMap;
+import com.squareup.javapoet.CodeBlock;
+import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleAnnotationValueVisitor8;
 
 /**
  * A {@linkplain TypeMirror type} and an optional {@linkplain javax.inject.Qualifier qualifier} that
@@ -95,11 +101,73 @@ public final TypeMirror type() {
   @Override
   public abstract boolean equals(Object o);
 
+  /**
+   * Returns a String rendering of an {@link AnnotationMirror} that includes attributes in the order
+   * defined in the annotation type. This will produce the same output for {@linkplain
+   * AnnotationMirrors#equivalence() equal} {@link AnnotationMirror}s even if default values are
+   * omitted or their attributes were written in different orders, e.g. {@code @A(b = "b", c = "c")}
+   * and {@code @A(c = "c", b = "b", attributeWithDefaultValue = "default value")}.
+   */
+  // TODO(ronshapiro): move this to auto-common
+  private static String stableAnnotationMirrorToString(AnnotationMirror qualifier) {
+    StringBuilder builder = new StringBuilder("@").append(qualifier.getAnnotationType());
+    ImmutableMap<ExecutableElement, AnnotationValue> elementValues =
+        AnnotationMirrors.getAnnotationValuesWithDefaults(qualifier);
+    if (!elementValues.isEmpty()) {
+      ImmutableMap.Builder<String, String> namedValuesBuilder = ImmutableMap.builder();
+      elementValues.forEach(
+          (key, value) ->
+              namedValuesBuilder.put(
+                  key.getSimpleName().toString(), stableAnnotationValueToString(value)));
+      ImmutableMap<String, String> namedValues = namedValuesBuilder.build();
+      builder.append('(');
+      if (namedValues.size() == 1 && namedValues.containsKey("value")) {
+        // Omit "value ="
+        builder.append(namedValues.get("value"));
+      } else {
+        builder.append(Joiner.on(", ").withKeyValueSeparator("=").join(namedValues));
+      }
+      builder.append(')');
+    }
+    return builder.toString();
+  }
+
+  private static String stableAnnotationValueToString(AnnotationValue annotationValue) {
+    return annotationValue.accept(
+        new SimpleAnnotationValueVisitor8<String, Void>() {
+          @Override
+          protected String defaultAction(Object value, Void ignore) {
+            return value.toString();
+          }
+
+          @Override
+          public String visitString(String value, Void ignore) {
+            return CodeBlock.of("$S", value).toString();
+          }
+
+          @Override
+          public String visitAnnotation(AnnotationMirror value, Void ignore) {
+            return stableAnnotationMirrorToString(value);
+          }
+
+          @Override
+          public String visitArray(List<? extends AnnotationValue> value, Void ignore) {
+            return value.stream()
+                .map(Key::stableAnnotationValueToString)
+                .collect(joining(", ", "{", "}"));
+          }
+        },
+        null);
+  }
+
   @Override
   public final String toString() {
     return Joiner.on(' ')
         .skipNulls()
-        .join(qualifier().orElse(null), type(), multibindingContributionIdentifier().orElse(null));
+        .join(
+            qualifier().map(Key::stableAnnotationMirrorToString).orElse(null),
+            type(),
+            multibindingContributionIdentifier().orElse(null));
   }
 
   /** Returns a builder for {@link Key}s. */
diff --git a/javatests/dagger/internal/codegen/KeyFactoryTest.java b/javatests/dagger/internal/codegen/KeyFactoryTest.java
index c011c7093..69dfeaa50 100644
--- a/javatests/dagger/internal/codegen/KeyFactoryTest.java
+++ b/javatests/dagger/internal/codegen/KeyFactoryTest.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertThat;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.Iterables;
@@ -30,6 +31,7 @@
 import dagger.multibindings.IntoSet;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.lang.annotation.Retention;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
@@ -111,8 +113,14 @@
         .isEqualTo(MoreTypes.equivalence().wrap(stringType));
     assertThat(key.toString())
         .isEqualTo(
-            "@dagger.internal.codegen.KeyFactoryTest.TestQualifier("
-                + "{@dagger.internal.codegen.KeyFactoryTest.InnerAnnotation}) java.lang.String");
+            "@dagger.internal.codegen.KeyFactoryTest.TestQualifier({"
+                + "@dagger.internal.codegen.KeyFactoryTest.InnerAnnotation("
+                + "param1=1, value=\"value a\"), "
+                + "@dagger.internal.codegen.KeyFactoryTest.InnerAnnotation("
+                + "param1=2, value=\"value b\"), "
+                + "@dagger.internal.codegen.KeyFactoryTest.InnerAnnotation("
+                + "param1=3145, value=\"default\")"
+                + "}) java.lang.String");
   }
 
   @Test public void qualifiedKeyEquivalents() {
@@ -133,29 +141,51 @@
     assertThat(provisionKey).isEqualTo(injectionKey);
     assertThat(injectionKey.toString())
         .isEqualTo(
-            "@dagger.internal.codegen.KeyFactoryTest.TestQualifier("
-                + "{@dagger.internal.codegen.KeyFactoryTest.InnerAnnotation}) java.lang.String");
+            "@dagger.internal.codegen.KeyFactoryTest.TestQualifier({"
+                + "@dagger.internal.codegen.KeyFactoryTest.InnerAnnotation("
+                + "param1=1, value=\"value a\"), "
+                + "@dagger.internal.codegen.KeyFactoryTest.InnerAnnotation("
+                + "param1=2, value=\"value b\"), "
+                + "@dagger.internal.codegen.KeyFactoryTest.InnerAnnotation("
+                + "param1=3145, value=\"default\")"
+                + "}) java.lang.String");
   }
 
   @Module
   static final class QualifiedProvidesMethodModule {
     @Provides
-    @TestQualifier(@InnerAnnotation)
-    String provideQualifiedString() {
+    @TestQualifier({
+      @InnerAnnotation(value = "value a", param1 = 1),
+      // please note the order of 'param' and 'value' is inverse
+      @InnerAnnotation(param1 = 2, value = "value b"),
+      @InnerAnnotation()
+    })
+    static String provideQualifiedString() {
       throw new UnsupportedOperationException();
     }
   }
 
   static final class QualifiedFieldHolder {
-    @TestQualifier(@InnerAnnotation) String aString;
+    @TestQualifier({
+      @InnerAnnotation(value = "value a", param1 = 1),
+      // please note the order of 'param' and 'value' is inverse
+      @InnerAnnotation(param1 = 2, value = "value b"),
+      @InnerAnnotation()
+    })
+    String aString;
   }
 
+  @Retention(RUNTIME)
   @Qualifier
   @interface TestQualifier {
     InnerAnnotation[] value();
   }
 
-  @interface InnerAnnotation {}
+  @interface InnerAnnotation {
+    int param1() default 3145;
+
+    String value() default "default";
+  }
 
   @Test public void forProvidesMethod_sets() {
     TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
