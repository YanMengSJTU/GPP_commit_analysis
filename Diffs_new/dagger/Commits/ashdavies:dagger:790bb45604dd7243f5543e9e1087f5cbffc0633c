diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index f56b83f07..96708bcb6 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -34,7 +34,6 @@
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER_MANAGER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
-import static dagger.internal.codegen.Util.toImmutableList;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -42,7 +41,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.MoreObjects;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
@@ -57,7 +55,6 @@
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.InjectionMethods.InjectionSiteMethod;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-import dagger.producers.Producer;
 import dagger.releasablereferences.CanReleaseReferences;
 import java.util.ArrayList;
 import java.util.EnumSet;
@@ -66,7 +63,6 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
-import javax.inject.Provider;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
@@ -92,9 +88,6 @@
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
   private final ComponentBindingExpressions bindingExpressions;
   protected final ComponentRequirementFields componentRequirementFields;
-  // TODO(user): Merge into ComponentBindingExpressions after we refactor BindingKey.
-  private final Map<BindingKey, FrameworkInstanceBindingExpression>
-      producerFromProviderBindingExpressions = new LinkedHashMap<>();
   private final List<CodeBlock> initializations = new ArrayList<>();
   protected final List<MethodSpec> interfaceMethods = new ArrayList<>();
   private final BindingExpression.Factory bindingExpressionFactory;
@@ -192,10 +185,6 @@ protected AbstractComponentWriter(
         parent.componentRequirementFields.forChildComponent());
   }
 
-  protected final ClassName componentDefinitionTypeName() {
-    return ClassName.get(graph.componentType());
-  }
-
   /**
    * Creates a {@link FieldSpec.Builder} with a unique name based off of {@code name}.
    */
@@ -569,35 +558,4 @@ public CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybe
           factoryCreate);
     }
   }
-
-  @Override
-  public ImmutableList<CodeBlock> getBindingDependencyExpressions(Binding binding) {
-    ImmutableList<FrameworkDependency> dependencies = binding.frameworkDependencies();
-    return dependencies.stream().map(this::getDependencyExpression).collect(toImmutableList());
-  }
-
-  @Override
-  public CodeBlock getDependencyExpression(FrameworkDependency frameworkDependency) {
-    return isProducerFromProvider(frameworkDependency)
-        ? getProducerFromProviderBindingExpression(frameworkDependency)
-            .getDependencyExpression(frameworkDependency.dependencyRequestKind(), name)
-        : bindingExpressions.getDependencyExpression(frameworkDependency, name);
-  }
-
-  private FrameworkInstanceBindingExpression getProducerFromProviderBindingExpression(
-      FrameworkDependency frameworkDependency) {
-    checkState(isProducerFromProvider(frameworkDependency));
-    return producerFromProviderBindingExpressions.computeIfAbsent(
-        frameworkDependency.bindingKey(),
-        dependencyKey ->
-            bindingExpressionFactory.forProducerFromProviderField(
-                graph.resolvedBindings().get(dependencyKey)));
-  }
-
-  private boolean isProducerFromProvider(FrameworkDependency frameworkDependency) {
-    ResolvedBindings resolvedBindings =
-        graph.resolvedBindings().get(frameworkDependency.bindingKey());
-    return resolvedBindings.frameworkClass().equals(Provider.class)
-        && frameworkDependency.frameworkClass().equals(Producer.class);
-  }
 }
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 06c8e6483..6ef9ab6c8 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -18,9 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
-import static dagger.internal.codegen.FrameworkInstanceBindingExpression.producerFromProviderBindingExpression;
 import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
-import static dagger.internal.codegen.TypeNames.PRODUCER;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.google.common.collect.ImmutableMap;
@@ -33,11 +31,9 @@
 /** A factory of code expressions used to access a single binding in a component. */
 abstract class BindingExpression {
   private final ResolvedBindings resolvedBindings;
-  private final ClassName componentName;
 
-  BindingExpression(ResolvedBindings resolvedBindings, ClassName componentName) {
+  BindingExpression(ResolvedBindings resolvedBindings) {
     this.resolvedBindings = checkNotNull(resolvedBindings);
-    this.componentName = checkNotNull(componentName);
   }
 
   /** The binding this instance uses to fulfill requests. */
@@ -45,11 +41,6 @@ final ResolvedBindings resolvedBindings() {
     return resolvedBindings;
   }
 
-  /** The name of the component owning this binding expression. */
-  final ClassName componentName() {
-    return componentName;
-  }
-
   /**
    * Returns an expression that evaluates to the value of a request for a given kind of dependency
    * on this binding.
@@ -102,23 +93,6 @@ BindingExpression forField(ResolvedBindings resolvedBindings) {
       return create(resolvedBindings, Optional.of(fieldSpec), memberSelect);
     }
 
-    FrameworkInstanceBindingExpression forProducerFromProviderField(
-        ResolvedBindings resolvedBindings) {
-      FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.of(PRODUCER));
-      MemberSelect memberSelect = MemberSelect.localField(componentName, fieldSpec.name);
-      return producerFromProviderBindingExpression(
-          resolvedBindings,
-          componentName,
-          Optional.of(fieldSpec),
-          generatedComponentModel,
-          memberSelect,
-          componentBindingExpressions,
-          componentRequirementFields,
-          compilerOptions,
-          graph,
-          optionalFactories);
-    }
-
     /** Creates a binding expression for a static method call. */
     Optional<BindingExpression> forStaticMethod(ResolvedBindings resolvedBindings) {
       return staticMemberSelect(resolvedBindings)
@@ -159,23 +133,35 @@ private BindingExpression create(
         ResolvedBindings resolvedBindings,
         Optional<FieldSpec> fieldSpec,
         MemberSelect memberSelect) {
-      FrameworkInstanceBindingExpression bindingExpression =
-          FrameworkInstanceBindingExpression.create(
-              resolvedBindings,
-              componentName,
-              fieldSpec,
+      FrameworkFieldInitializer frameworkFieldInitializer =
+          new FrameworkFieldInitializer(
               generatedComponentModel,
-              memberSelect,
               componentBindingExpressions,
               componentRequirementFields,
+              resolvedBindings,
               compilerOptions,
               graph,
-              optionalFactories);
+              optionalFactories,
+              componentName);
+      FrameworkInstanceBindingExpression frameworkInstanceBindingExpression =
+          FrameworkInstanceBindingExpression.create(
+              resolvedBindings,
+              fieldSpec,
+              generatedComponentModel,
+              memberSelect,
+              frameworkFieldInitializer);
 
       if (!resolvedBindings.bindingType().equals(BindingType.PROVISION)) {
-        return bindingExpression;
+        return frameworkInstanceBindingExpression;
       }
 
+      BindingExpression bindingExpression =
+          new ProviderOrProducerBindingExpression(
+              frameworkInstanceBindingExpression,
+              frameworkInstanceBindingExpression.producerFromProvider(
+                  generateFrameworkField(resolvedBindings, Optional.of(TypeNames.PRODUCER)),
+                  componentName));
+
       ProvisionBinding provisionBinding = (ProvisionBinding) resolvedBindings.contributionBinding();
       switch (provisionBinding.bindingKind()) {
         case COMPONENT:
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index 0b22230d0..3cad7ee2d 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -24,7 +24,7 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
-import static dagger.internal.codegen.BindingType.PRODUCTION;
+import static dagger.internal.codegen.BindingType.PROVISION;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
@@ -39,6 +39,7 @@
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.producerOf;
 import static dagger.internal.codegen.TypeNames.providerOf;
+import static dagger.internal.codegen.Util.toImmutableList;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -82,8 +83,8 @@
   // TODO(ronshapiro): add Binding.bindingKey() and use that instead of taking a ResolvedBindings
   private final ResolvedBindings resolvedBindings;
   private final CompilerOptions compilerOptions;
-  private final boolean isProducerFromProvider;
   private final BindingGraph graph;
+  private final boolean isProducerFromProvider;
   private final OptionalFactories optionalFactories;
   private final ClassName componentName;
 
@@ -93,26 +94,49 @@
       ComponentRequirementFields componentRequirementFields,
       ResolvedBindings resolvedBindings,
       CompilerOptions compilerOptions,
-      boolean isProducerFromProvider,
       BindingGraph graph,
       OptionalFactories optionalFactories,
       ClassName componentName) {
+    this(
+        generatedComponentModel,
+        componentBindingExpressions,
+        componentRequirementFields,
+        resolvedBindings,
+        compilerOptions,
+        graph,
+        false,
+        optionalFactories,
+        componentName);
+  }
+
+  private FrameworkFieldInitializer(
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions,
+      ComponentRequirementFields componentRequirementFields,
+      ResolvedBindings resolvedBindings,
+      CompilerOptions compilerOptions,
+      BindingGraph graph,
+      boolean isProducerFromProvider,
+      OptionalFactories optionalFactories,
+      ClassName componentName) {
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.componentRequirementFields = checkNotNull(componentRequirementFields);
     this.resolvedBindings = checkNotNull(resolvedBindings);
     this.compilerOptions = checkNotNull(compilerOptions);
-    this.isProducerFromProvider = isProducerFromProvider;
     this.graph = checkNotNull(graph);
     this.optionalFactories = checkNotNull(optionalFactories);
     this.componentName = checkNotNull(componentName);
+    this.isProducerFromProvider = isProducerFromProvider;
   }
 
   /** Returns the expression to use to initialize the field. */
   CodeBlock getFieldInitialization() {
     if (isProducerFromProvider) {
-      return componentBindingExpressions.getDependencyExpression(
-          FrameworkDependency.create(resolvedBindings.bindingKey(), PRODUCTION), componentName);
+      return FrameworkType.PROVIDER.to(
+          DependencyRequest.Kind.PRODUCER,
+          componentBindingExpressions.getDependencyExpression(
+              FrameworkDependency.create(resolvedBindings.bindingKey(), PROVISION), componentName));
     }
 
     switch (resolvedBindings.bindingKey().kind()) {
@@ -133,8 +157,8 @@ private CodeBlock contributionBindingInitialization() {
             CodeBlock.of(
                 "($T) $L",
                 contributionBinding.bindingType().frameworkClass(),
-                componentBindingExpressions.getDependencyExpression(
-                    getOnlyElement(contributionBinding.frameworkDependencies()), componentName));
+                getDependencyExpression(
+                    getOnlyElement(contributionBinding.frameworkDependencies())));
         return generatedComponentModel.decorateForScope(
             delegatingCodeBlock, contributionBinding.scope());
       case SINGLETON_INSTANCE:
@@ -154,8 +178,7 @@ private CodeBlock membersInjectionBindingInitialization() {
     return CodeBlock.of(
         "$T.create($L)",
         membersInjectorNameForType(membersInjectionBinding.membersInjectedType()),
-        makeParametersCodeBlock(
-            generatedComponentModel.getBindingDependencyExpressions(membersInjectionBinding)));
+        makeParametersCodeBlock(getBindingDependencyExpressions(membersInjectionBinding)));
   }
 
   private CodeBlock factoryForContributionBindingInitialization(ContributionBinding binding) {
@@ -259,7 +282,7 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
                     ComponentRequirement.forModule(binding.contributingModule().get().asType()),
                     componentName));
           }
-          arguments.addAll(generatedComponentModel.getBindingDependencyExpressions(binding));
+          arguments.addAll(getBindingDependencyExpressions(binding));
 
           CodeBlock factoryCreate =
               CodeBlock.of(
@@ -320,7 +343,7 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
                     ComponentRequirement.forModule(binding.contributingModule().get().asType()),
                     componentName));
           }
-          arguments.addAll(generatedComponentModel.getBindingDependencyExpressions(binding));
+          arguments.addAll(getBindingDependencyExpressions(binding));
 
           return CodeBlock.of(
               "new $T($L)",
@@ -390,7 +413,7 @@ private CodeBlock factoryForSetMultibindingInitialization(ContributionBinding bi
           potentiallyCast(
               useRawTypes,
               frameworkDependency.frameworkClass(),
-              generatedComponentModel.getDependencyExpression(frameworkDependency)));
+              getDependencyExpression(frameworkDependency)));
     }
     builder.add("builder($L, $L)", individualProviders, setProviders);
     builder.add(builderMethodCalls.build());
@@ -433,7 +456,7 @@ private CodeBlock factoryForMapMultibindingInitialization(ContributionBinding bi
           potentiallyCast(
               useRawTypes,
               frameworkDependency.frameworkClass(),
-              generatedComponentModel.getDependencyExpression(frameworkDependency));
+              getDependencyExpression(frameworkDependency));
       codeBlocks.add(
           CodeBlock.of(
               ".put($L, $L)", getMapKeyExpression(contributionBinding.mapKey().get()), value));
@@ -583,8 +606,31 @@ private CodeBlock factoryForSyntheticOptionalBindingInitialization(ContributionB
       return optionalFactories.absentOptionalProvider(binding);
     } else {
       return optionalFactories.presentOptionalFactory(
-          binding,
-          getOnlyElement(generatedComponentModel.getBindingDependencyExpressions(binding)));
+          binding, getDependencyExpression(getOnlyElement(binding.frameworkDependencies())));
     }
   }
+
+  /** Returns a list of code blocks for referencing all of the given binding's dependencies. */
+  private ImmutableList<CodeBlock> getBindingDependencyExpressions(Binding binding) {
+    ImmutableList<FrameworkDependency> dependencies = binding.frameworkDependencies();
+    return dependencies.stream().map(this::getDependencyExpression).collect(toImmutableList());
+  }
+
+  /** Returns a code block referencing the given dependency. */
+  private CodeBlock getDependencyExpression(FrameworkDependency frameworkDependency) {
+    return componentBindingExpressions.getDependencyExpression(frameworkDependency, componentName);
+  }
+
+  FrameworkFieldInitializer forProducerFromProvider() {
+    return new FrameworkFieldInitializer(
+        generatedComponentModel,
+        componentBindingExpressions,
+        componentRequirementFields,
+        resolvedBindings,
+        compilerOptions,
+        graph,
+        true,
+        optionalFactories,
+        componentName);
+  }
 }
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 00b8d0b7d..599fa45d5 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 
 import com.squareup.javapoet.ClassName;
@@ -38,81 +39,27 @@
   /** Returns a binding expression for a binding. */
   static FrameworkInstanceBindingExpression create(
       ResolvedBindings resolvedBindings,
-      ClassName componentName,
       Optional<FieldSpec> fieldSpec,
       GeneratedComponentModel generatedComponentModel,
       MemberSelect memberSelect,
-      ComponentBindingExpressions componentBindingExpressions,
-      ComponentRequirementFields componentRequirementFields,
-      CompilerOptions compilerOptions,
-      BindingGraph graph,
-      OptionalFactories optionalFactories) {
+      FrameworkFieldInitializer frameworkFieldInitializer) {
     return new FrameworkInstanceBindingExpression(
         resolvedBindings,
-        componentName,
         fieldSpec,
         generatedComponentModel,
         memberSelect,
         resolvedBindings.bindingType().frameworkType(),
-        // TODO(user): When producerFromProvider is moved, this initialization can be moved
-        // to BindingExpression.Factory
-        new FrameworkFieldInitializer(
-            generatedComponentModel,
-            componentBindingExpressions,
-            componentRequirementFields,
-            resolvedBindings,
-            compilerOptions,
-            false,
-            graph,
-            optionalFactories,
-            componentName));
-  }
-
-  /**
-   * Returns a binding expression that uses a {@link dagger.producers.Producer} instance derived
-   * from a {@link javax.inject.Provider}.
-   */
-  static FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
-      ResolvedBindings resolvedBindings,
-      ClassName componentName,
-      Optional<FieldSpec> fieldSpec,
-      GeneratedComponentModel generatedComponentModel,
-      MemberSelect memberSelect,
-      ComponentBindingExpressions componentBindingExpressions,
-      ComponentRequirementFields componentRequirementFields,
-      CompilerOptions compilerOptions,
-      BindingGraph graph,
-      OptionalFactories optionalFactories) {
-    return new FrameworkInstanceBindingExpression(
-        resolvedBindings,
-        componentName,
-        fieldSpec,
-        generatedComponentModel,
-        memberSelect,
-        FrameworkType.PRODUCER,
-        // TODO(user): When producerFromProvider is moved, this initialization can be moved
-        // to BindingExpression.Factory
-        new FrameworkFieldInitializer(
-            generatedComponentModel,
-            componentBindingExpressions,
-            componentRequirementFields,
-            resolvedBindings,
-            compilerOptions,
-            true,
-            graph,
-            optionalFactories,
-            componentName));
+        frameworkFieldInitializer);
   }
 
   private FrameworkInstanceBindingExpression(
       ResolvedBindings resolvedBindings,
-      ClassName componentName,
       Optional<FieldSpec> fieldSpec,
       GeneratedComponentModel generatedComponentModel,
       MemberSelect memberSelect,
       FrameworkType frameworkType,
       FrameworkFieldInitializer fieldInitializer) {
-    super(resolvedBindings, componentName);
+    super(resolvedBindings);
     this.generatedComponentModel = generatedComponentModel;
     this.memberSelect = memberSelect;
     this.fieldSpec = fieldSpec;
@@ -120,6 +67,18 @@ private FrameworkInstanceBindingExpression(
     this.fieldInitializer = fieldInitializer;
   }
 
+  FrameworkInstanceBindingExpression producerFromProvider(
+      FieldSpec fieldSpec, ClassName componentName) {
+    checkState(frameworkType.equals(FrameworkType.PROVIDER));
+    return new FrameworkInstanceBindingExpression(
+        resolvedBindings(),
+        Optional.of(fieldSpec),
+        generatedComponentModel,
+        MemberSelect.localField(componentName, fieldSpec.name),
+        FrameworkType.PRODUCER,
+        fieldInitializer.forProducerFromProvider());
+  }
+
   @Override
   CodeBlock getDependencyExpression(DependencyRequest.Kind requestKind, ClassName requestingClass) {
     return frameworkType.to(requestKind, getFrameworkTypeInstance(requestingClass));
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index f3b2a7de8..9800a4d81 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
@@ -54,13 +53,4 @@
    * object for a scope.
    */
   CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope);
-
-  // TODO(user): this and getDependencyArguments should go on ComponentBindingExpressions
-  // once producerFromProvider fields are pushed into their corresponding binding expressions.
-  // This cannot be done currently due to these expressions being created lazily.
-  /** Returns a code block referencing the given dependency. */
-  CodeBlock getDependencyExpression(FrameworkDependency frameworkDependency);
-
-  /** Returns a list of code blocks for referencing all of the given binding's dependencies. */
-  ImmutableList<CodeBlock> getBindingDependencyExpressions(Binding binding);
 }
diff --git a/java/dagger/internal/codegen/ProviderOrProducerBindingExpression.java b/java/dagger/internal/codegen/ProviderOrProducerBindingExpression.java
new file mode 100644
index 000000000..07cb22a6e
--- /dev/null
+++ b/java/dagger/internal/codegen/ProviderOrProducerBindingExpression.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+
+/**
+ * A {@link FrameworkInstanceBindingExpression} that is expressed with a {@link
+ * javax.inject.Provider} for all {@link DependencyRequest.Kind}s except {@link
+ * DependencyRequest.Kind#PRODUCER}, for which it uses a {@link
+ * dagger.producers.internal.Producers#producerFromProvider(javax.inject.Provider) provider wrapped
+ * by a producer}.
+ */
+final class ProviderOrProducerBindingExpression extends BindingExpression {
+  private final FrameworkInstanceBindingExpression providerBindingExpression;
+  private final FrameworkInstanceBindingExpression producerBindingExpression;
+
+  ProviderOrProducerBindingExpression(
+      FrameworkInstanceBindingExpression providerBindingExpression,
+      FrameworkInstanceBindingExpression producerBindingExpression) {
+    super(providerBindingExpression.resolvedBindings());
+    this.providerBindingExpression = providerBindingExpression;
+    this.producerBindingExpression = producerBindingExpression;
+  }
+
+  @Override
+  CodeBlock getDependencyExpression(DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    switch (requestKind) {
+      case PRODUCER:
+        return producerBindingExpression.getDependencyExpression(requestKind, requestingClass);
+      default:
+        return providerBindingExpression.getDependencyExpression(requestKind, requestingClass);
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
index 84c8b14da..f01ecd80e 100644
--- a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
@@ -28,7 +28,7 @@
   private final BindingExpression delegate;
 
   SimpleInvocationBindingExpression(BindingExpression delegate) {
-    super(delegate.resolvedBindings(), delegate.componentName());
+    super(delegate.resolvedBindings());
     this.delegate = delegate;
   }
 
