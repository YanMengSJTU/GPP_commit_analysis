diff --git a/java/dagger/internal/codegen/BindingCycleValidation.java b/java/dagger/internal/codegen/BindingCycleValidation.java
index 2d6108408..ed61c36b6 100644
--- a/java/dagger/internal/codegen/BindingCycleValidation.java
+++ b/java/dagger/internal/codegen/BindingCycleValidation.java
@@ -27,7 +27,6 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.RequestKinds.extractKeyType;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
-import static java.util.Comparator.comparingInt;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 import com.google.auto.value.AutoValue;
@@ -40,6 +39,7 @@
 import com.google.common.graph.NetworkBuilder;
 import dagger.model.BindingGraph;
 import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Node;
 import dagger.model.BindingKind;
@@ -106,6 +106,15 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
   /**
    * Reports a dependency cycle at the dependency into the cycle that is closest to an entry point.
+   *
+   * <p>Looks for the shortest path from the component that contains the cycle (all bindings in a
+   * cycle must be in the same component; see below) to some binding in the cycle. Then looks for
+   * the last dependency in that path that is not in the cycle; that is the dependency that will be
+   * reported, so that the dependency trace will end just before the cycle.
+   *
+   * <p>Proof (by counterexample) that all bindings in a cycle must be in the same component: Assume
+   * one binding in the cycle is in a parent component. Bindings cannot depend on bindings in child
+   * components, so that binding cannot depend on the next binding in the cycle.
    */
   private void reportCycle(
       Cycle<Node> cycle, BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
@@ -121,18 +130,11 @@ private void reportCycle(
   private ImmutableList<Node> shortestPathToCycleFromAnEntryPoint(
       Cycle<Node> cycle, BindingGraph bindingGraph) {
     Node someCycleNode = cycle.nodes().asList().get(0);
-    return bindingGraph
-        .componentNodes()
-        .stream()
-        .map(componentNode -> shortestPath(bindingGraph, componentNode, someCycleNode))
-        // Ignore paths that go through subcomponents by requiring all nodes after the first to be
-        // BindingNodes. We can't just use nonCycleBreakingDependencyGraph because that filters out
-        // edges that might break a cycle, but those edges might still be part of the shortest path
-        // TO a cycle.
-        .filter(path -> path.stream().skip(1).allMatch(node -> node instanceof BindingNode))
-        .map(path -> subpathToCycle(path, cycle))
-        .min(comparingInt(ImmutableList::size))
-        .get();
+    ComponentNode componentContainingCycle =
+        bindingGraph.componentNode(someCycleNode.componentPath()).get();
+    ImmutableList<Node> pathToCycle =
+        shortestPath(bindingGraph, componentContainingCycle, someCycleNode);
+    return subpathToCycle(pathToCycle, cycle);
   }
 
   /**
@@ -232,13 +234,8 @@ private DependencyEdge chooseDependencyEdgeConnecting(
   private ImmutableNetwork<Node, DependencyEdge> nonCycleBreakingDependencyGraph(
       BindingGraph bindingGraph) {
     MutableNetwork<Node, DependencyEdge> dependencyNetwork =
-        NetworkBuilder.directed()
-            .allowsParallelEdges(true)
-            .allowsSelfLoops(true)
-            .nodeOrder(bindingGraph.nodeOrder())
-            .edgeOrder(bindingGraph.edgeOrder())
-            .expectedNodeCount(
-                bindingGraph.bindingNodes().size() + bindingGraph.componentNodes().size())
+        NetworkBuilder.from(bindingGraph)
+            .expectedNodeCount(bindingGraph.nodes().size())
             .expectedEdgeCount(bindingGraph.dependencyEdges().size())
             .build();
     bindingGraph
@@ -298,7 +295,7 @@ int size() {
     }
 
     @Override
-    public String toString() {
+    public final String toString() {
       return endpointPairs().toString();
     }
 
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index cd64d7685..2abceae51 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -616,7 +616,7 @@ public void cyclicDependencyInSubcomponents() {
             "",
             "@Component",
             "interface Parent {",
-            "  Child child();",
+            "  Child.Builder child();",
             "}");
     JavaFileObject child =
         JavaFileObjects.forSourceLines(
@@ -625,9 +625,14 @@ public void cyclicDependencyInSubcomponents() {
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = ChildModule.class)",
+            "@Subcomponent(modules = CycleModule.class)",
             "interface Child {",
-            "  Grandchild grandchild();",
+            "  Grandchild.Builder grandchild();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
             "}");
     JavaFileObject grandchild =
         JavaFileObjects.forSourceLines(
@@ -639,17 +644,22 @@ public void cyclicDependencyInSubcomponents() {
             "@Subcomponent",
             "interface Grandchild {",
             "  String entry();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Grandchild build();",
+            "  }",
             "}");
-    JavaFileObject childModule =
+    JavaFileObject cycleModule =
         JavaFileObjects.forSourceLines(
-            "test.ChildModule",
+            "test.CycleModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
             "",
             "@Module",
-            "abstract class ChildModule {",
+            "abstract class CycleModule {",
             "  @Provides static Object object(String string) {",
             "    return string;",
             "  }",
@@ -659,20 +669,102 @@ public void cyclicDependencyInSubcomponents() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, childModule);
+    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, cycleModule);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
             message(
                 "[test.Grandchild.entry()] Found a dependency cycle:",
                 "java.lang.String is injected at",
-                "    test.ChildModule.object(string)",
+                "    test.CycleModule.object(string)",
                 "java.lang.Object is injected at",
-                "    test.ChildModule.string(object)",
+                "    test.CycleModule.string(object)",
                 "java.lang.String is provided at",
                 "    test.Grandchild.entry()"))
         .inFile(parent)
-        .onLineContaining("interface Parent {");
+        .onLineContaining("interface Parent");
+  }
+
+  @Test
+  public void cyclicDependencyInSubcomponentsWithChildren() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Parent {",
+            "  Child.Builder child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = CycleModule.class)",
+            "interface Child {",
+            "  String entry();",
+            "",
+            "  Grandchild grandchild();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "}");
+    // Grandchild has no entry point that depends on the cycle. http://b/111317986
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Grandchild build();",
+            "  }",
+            "}");
+    JavaFileObject cycleModule =
+        JavaFileObjects.forSourceLines(
+            "test.CycleModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class CycleModule {",
+            "  @Provides static Object object(String string) {",
+            "    return string;",
+            "  }",
+            "",
+            "  @Provides static String string(Object object) {",
+            "    return object.toString();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, cycleModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "[test.Child.entry()] Found a dependency cycle:",
+                "java.lang.String is injected at",
+                "    test.CycleModule.object(string)",
+                "java.lang.Object is injected at",
+                "    test.CycleModule.string(object)",
+                "java.lang.String is provided at",
+                "    test.Child.entry()"))
+        .inFile(parent)
+        .onLineContaining("interface Parent");
   }
 
   @Test
