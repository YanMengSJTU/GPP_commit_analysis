diff --git a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
index a5c664b56..0e8c0cca7 100644
--- a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
+++ b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
@@ -111,9 +111,7 @@ private void validateMapKeyUniqueness(
   }
 
   private Stream<BindingNode> dependencies(BindingNode bindingNode, BindingGraph graph) {
-    return graph
-        .successors(bindingNode)
-        .stream()
+    return graph.network().successors(bindingNode).stream()
         // TODO(ronshapiro): reuse DaggerStreams.instancesOf()?
         .filter(BindingNode.class::isInstance)
         .map(BindingNode.class::cast);
diff --git a/java/dagger/example/spi/BindingGraphVisualizer.java b/java/dagger/example/spi/BindingGraphVisualizer.java
index 01b5c42d4..379e9733f 100644
--- a/java/dagger/example/spi/BindingGraphVisualizer.java
+++ b/java/dagger/example/spi/BindingGraphVisualizer.java
@@ -58,7 +58,7 @@
 import javax.tools.StandardLocation;
 
 /**
- * Experimental network visualizer used as a proof-of-concept for {@link BindingGraphPlugin}.
+ * Experimental visualizer used as a proof-of-concept for {@link BindingGraphPlugin}.
  *
  * <p>For each component, writes a <a href=http://www.graphviz.org/content/dot-language>DOT file</a>
  * in the same package. The file name is the name of the component type (with enclosing type names,
@@ -224,9 +224,7 @@ private static String quote(String string) {
     DotGraph graph() {
       if (nodeIds.isEmpty()) {
         Iterator<String> colors = Iterators.cycle(COMPONENT_COLORS);
-        bindingGraph
-            .nodes()
-            .stream()
+        bindingGraph.network().nodes().stream()
             .collect(groupingBy(Node::componentPath))
             .forEach(
                 (component, networkNodes) -> {
@@ -241,7 +239,7 @@ DotGraph graph() {
                     subgraph.add(dotNode(node));
                   }
                 });
-        for (Edge edge : bindingGraph.edges()) {
+        for (Edge edge : bindingGraph.network().edges()) {
           dotEdge(edge).ifPresent(graph::add);
         }
       }
@@ -259,7 +257,7 @@ UUID nodeId(Node node) {
     }
 
     Optional<DotEdge> dotEdge(Edge edge) {
-      EndpointPair<Node> incidentNodes = bindingGraph.incidentNodes(edge);
+      EndpointPair<Node> incidentNodes = bindingGraph.network().incidentNodes(edge);
       DotEdge dotEdge = new DotEdge(nodeId(incidentNodes.source()), nodeId(incidentNodes.target()));
       if (edge instanceof DependencyEdge) {
         if (((DependencyEdge) edge).isEntryPoint()) {
diff --git a/java/dagger/internal/codegen/DependencyCycleValidator.java b/java/dagger/internal/codegen/DependencyCycleValidator.java
index 87564cdd7..b5e3b562d 100644
--- a/java/dagger/internal/codegen/DependencyCycleValidator.java
+++ b/java/dagger/internal/codegen/DependencyCycleValidator.java
@@ -133,7 +133,7 @@ private void reportCycle(
     ComponentNode componentContainingCycle =
         bindingGraph.componentNode(someCycleNode.componentPath()).get();
     ImmutableList<Node> pathToCycle =
-        shortestPath(bindingGraph, componentContainingCycle, someCycleNode);
+        shortestPath(bindingGraph.network(), componentContainingCycle, someCycleNode);
     return subpathToCycle(pathToCycle, cycle);
   }
 
@@ -171,7 +171,7 @@ private String errorMessage(Cycle<Node> cycle, BindingGraph graph) {
    * #breaksCycle(DependencyEdge, BindingGraph) break} a cycle.
    */
   private DependencyEdge nonCycleBreakingEdge(EndpointPair<Node> endpointPair, BindingGraph graph) {
-    return graph.edgesConnecting(endpointPair.source(), endpointPair.target()).stream()
+    return graph.network().edgesConnecting(endpointPair.source(), endpointPair.target()).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .filter(edge -> !breaksCycle(edge, graph))
         .findFirst()
@@ -185,7 +185,7 @@ private boolean breaksCycle(DependencyEdge edge, BindingGraph graph) {
     if (breaksCycle(edge.dependencyRequest().key().type(), edge.dependencyRequest().kind())) {
       return true;
     }
-    Node target = graph.incidentNodes(edge).target();
+    Node target = graph.network().incidentNodes(edge).target();
     if (target instanceof BindingNode
         && ((BindingNode) target).binding().kind().equals(BindingKind.OPTIONAL)) {
       /* For @BindsOptionalOf bindings, unwrap the type inside the Optional. If the unwrapped type
@@ -218,7 +218,7 @@ private boolean breaksCycle(TypeMirror requestedType, RequestKind requestKind) {
 
   private DependencyEdge chooseDependencyEdgeConnecting(
       Node source, Node target, BindingGraph bindingGraph) {
-    return bindingGraph.edgesConnecting(source, target).stream()
+    return bindingGraph.network().edgesConnecting(source, target).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .findFirst()
         .get();
@@ -228,15 +228,15 @@ private DependencyEdge chooseDependencyEdgeConnecting(
   private ImmutableNetwork<Node, DependencyEdge> nonCycleBreakingDependencyGraph(
       BindingGraph bindingGraph) {
     MutableNetwork<Node, DependencyEdge> dependencyNetwork =
-        NetworkBuilder.from(bindingGraph)
-            .expectedNodeCount(bindingGraph.nodes().size())
+        NetworkBuilder.from(bindingGraph.network())
+            .expectedNodeCount(bindingGraph.network().nodes().size())
             .expectedEdgeCount(bindingGraph.dependencyEdges().size())
             .build();
     bindingGraph.dependencyEdges().stream()
         .filter(edge -> !breaksCycle(edge, bindingGraph))
         .forEach(
             edge -> {
-              EndpointPair<Node> endpoints = bindingGraph.incidentNodes(edge);
+              EndpointPair<Node> endpoints = bindingGraph.network().incidentNodes(edge);
               dependencyNetwork.addEdge(endpoints.source(), endpoints.target(), edge);
             });
     return ImmutableNetwork.copyOf(dependencyNetwork);
diff --git a/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
index 73da6c9fc..965be6dd8 100644
--- a/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
+++ b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
@@ -57,7 +57,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
     bindingGraph.bindingNodes(productionExecutorKey).stream()
         .flatMap(
             productionExecutorBinding ->
-                bindingGraph.predecessors(productionExecutorBinding).stream())
+                bindingGraph.network().predecessors(productionExecutorBinding).stream())
         .flatMap(instancesOf(BindingNode.class))
         .filter(binding -> !binding.key().equals(productionImplementationExecutorKey))
         .forEach(binding -> reportError(diagnosticReporter, binding));
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index a35414e2f..83e09870c 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -217,7 +217,7 @@ private String formatMessage(String messageFormat, Object firstArg, Object[] mor
     }
 
     private Node source(Edge edge) {
-      return graph.incidentNodes(edge).source();
+      return graph.network().incidentNodes(edge).source();
     }
 
     void printMessage(
@@ -364,7 +364,9 @@ public String toString() {
         dependencyTrace.add(entryPointForTrace);
         for (int i = 0; i < shortestBindingPath.size() - 1; i++) {
           Set<Edge> dependenciesBetween =
-              graph.edgesConnecting(shortestBindingPath.get(i), shortestBindingPath.get(i + 1));
+              graph
+                  .network()
+                  .edgesConnecting(shortestBindingPath.get(i), shortestBindingPath.get(i + 1));
           // If a binding requests a key more than once, any of them should be fine to get to the
           // shortest path
           dependencyTrace.add((DependencyEdge) Iterables.get(dependenciesBetween, 0));
@@ -374,7 +376,7 @@ public String toString() {
 
       /** Returns all the nonsynthetic dependency requests for a binding node. */
       ImmutableSet<DependencyEdge> requests(MaybeBindingNode bindingNode) {
-        return graph.inEdges(bindingNode).stream()
+        return graph.network().inEdges(bindingNode).stream()
             .flatMap(instancesOf(DependencyEdge.class))
             .filter(edge -> edge.dependencyRequest().requestElement().isPresent())
             .sorted(requestEnclosingTypeName().thenComparing(requestElementDeclarationOrder()))
@@ -405,8 +407,11 @@ public String toString() {
                 entryPoint,
                 ep ->
                     shortestPath(
-                        node -> filter(graph.successors(node), MaybeBindingNode.class::isInstance),
-                        graph.incidentNodes(ep).target(),
+                        node ->
+                            filter(
+                                graph.network().successors(node),
+                                MaybeBindingNode.class::isInstance),
+                        graph.network().incidentNodes(ep).target(),
                         bindingNode));
       }
 
diff --git a/java/dagger/internal/codegen/DuplicateBindingsValidator.java b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
index 2e54f84ae..927dbf4b2 100644
--- a/java/dagger/internal/codegen/DuplicateBindingsValidator.java
+++ b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
@@ -97,7 +97,7 @@ private void reportDuplicateBindings(
       DiagnosticReporter diagnosticReporter) {
     ImmutableSet<BindingNode> duplicateBindings =
         duplicateDependencies.stream()
-            .map(edge -> bindingGraph.incidentNodes(edge).target())
+            .map(edge -> bindingGraph.network().incidentNodes(edge).target())
             .flatMap(instancesOf(BindingNode.class))
             .collect(toImmutableSet());
     diagnosticReporter.reportDependency(
@@ -177,7 +177,7 @@ private void formatDeclarations(
       if (bindingDeclarationFormatter.canFormat(declaration)) {
         declarations.add(declaration);
       } else {
-        graph.successors(node).stream()
+        graph.network().successors(node).stream()
             .flatMap(instancesOf(BindingNode.class))
             .flatMap(dependency -> declarations(graph, dependency).stream())
             .forEach(declarations::add);
@@ -210,7 +210,9 @@ private String multibindingTypeString(BindingNode multibinding) {
           .collect(
               toImmutableSetMultimap(
                   edge ->
-                      create(bindingGraph.incidentNodes(edge).source(), edge.dependencyRequest()),
+                      create(
+                          bindingGraph.network().incidentNodes(edge).source(),
+                          edge.dependencyRequest()),
                   edge -> edge));
     }
 
diff --git a/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java b/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
index 5df3b9a2f..67d72d0ab 100644
--- a/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
+++ b/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
@@ -123,9 +123,9 @@ private boolean isChild(ComponentPath possibleParent, ComponentPath possibleChil
   }
 
   private ImmutableNetwork<Node, Edge> dependencyGraph(BindingGraph graph) {
-    MutableNetwork<Node, Edge> dependencyGraph = NetworkBuilder.from(graph).build();
+    MutableNetwork<Node, Edge> dependencyGraph = NetworkBuilder.from(graph.network()).build();
     for (DependencyEdge dependencyEdge : graph.dependencyEdges()) {
-      EndpointPair<Node> endpoint = graph.incidentNodes(dependencyEdge);
+      EndpointPair<Node> endpoint = graph.network().incidentNodes(dependencyEdge);
       dependencyGraph.addEdge(endpoint.source(), endpoint.target(), dependencyEdge);
     }
     return ImmutableNetwork.copyOf(dependencyGraph);
diff --git a/java/dagger/internal/codegen/MapMultibindingValidator.java b/java/dagger/internal/codegen/MapMultibindingValidator.java
index d7ccf2be0..f604a8b80 100644
--- a/java/dagger/internal/codegen/MapMultibindingValidator.java
+++ b/java/dagger/internal/codegen/MapMultibindingValidator.java
@@ -70,7 +70,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
   private ImmutableSet<ContributionBinding> mapBindingContributions(
       BindingNode bindingNode, BindingGraph bindingGraph) {
     checkArgument(bindingNode.binding().kind().equals(MULTIBOUND_MAP));
-    return bindingGraph.successors(bindingNode).stream()
+    return bindingGraph.network().successors(bindingNode).stream()
         .flatMap(instancesOf(BindingNode.class))
         .map(node -> (ContributionBinding) node.binding())
         .collect(toImmutableSet());
diff --git a/java/dagger/internal/codegen/MissingBindingValidator.java b/java/dagger/internal/codegen/MissingBindingValidator.java
index ab8e754ce..0e1e7a7e6 100644
--- a/java/dagger/internal/codegen/MissingBindingValidator.java
+++ b/java/dagger/internal/codegen/MissingBindingValidator.java
@@ -127,13 +127,13 @@ private String missingBindingErrorMessage(
 
   private boolean allIncomingDependenciesCanUseProduction(
       MissingBindingNode missingBindingNode, BindingGraph graph) {
-    return graph.inEdges(missingBindingNode).stream()
+    return graph.network().inEdges(missingBindingNode).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .allMatch(edge -> dependencyCanBeProduction(edge, graph));
   }
 
   private boolean dependencyCanBeProduction(DependencyEdge edge, BindingGraph graph) {
-    Node source = graph.incidentNodes(edge).source();
+    Node source = graph.network().incidentNodes(edge).source();
     if (source instanceof ComponentNode) {
       return entryPointCanUseProduction(edge.dependencyRequest().kind());
     }
diff --git a/java/dagger/internal/codegen/NullableBindingValidator.java b/java/dagger/internal/codegen/NullableBindingValidator.java
index 951e4d410..553192eb9 100644
--- a/java/dagger/internal/codegen/NullableBindingValidator.java
+++ b/java/dagger/internal/codegen/NullableBindingValidator.java
@@ -18,9 +18,11 @@
 
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import dagger.model.BindingGraph;
 import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.DependencyEdge;
@@ -66,12 +68,12 @@ public String pluginName() {
         .collect(toImmutableList());
   }
 
-  private ImmutableList<DependencyEdge> nonNullableDependencies(
+  private ImmutableSet<DependencyEdge> nonNullableDependencies(
       BindingGraph bindingGraph, BindingNode bindingNode) {
-    return bindingGraph.inEdges(bindingNode).stream()
+    return bindingGraph.network().inEdges(bindingNode).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .filter(edge -> !edge.dependencyRequest().isNullable())
-        .collect(toImmutableList());
+        .collect(toImmutableSet());
   }
 
   @VisibleForTesting
diff --git a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
index a9a9c7d2d..272bf8889 100644
--- a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
+++ b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
@@ -71,7 +71,8 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
   // TODO(dpb): Move to BindingGraph.
   private Stream<DependencyEdge> incomingDependencies(
       BindingNode binding, BindingGraph bindingGraph) {
-    return bindingGraph.inEdges(binding).stream().flatMap(instancesOf(DependencyEdge.class));
+    return bindingGraph.network().inEdges(binding).stream()
+        .flatMap(instancesOf(DependencyEdge.class));
   }
 
   private boolean dependencyCanUseProduction(DependencyEdge edge, BindingGraph bindingGraph) {
@@ -90,7 +91,7 @@ private boolean dependencyCanUseProduction(DependencyEdge edge, BindingGraph bin
   private BindingNode bindingRequestingDependency(
       DependencyEdge dependency, BindingGraph bindingGraph) {
     checkArgument(!dependency.isEntryPoint());
-    Node source = bindingGraph.incidentNodes(dependency).source();
+    Node source = bindingGraph.network().incidentNodes(dependency).source();
     verify(
         source instanceof BindingNode,
         "expected source of %s to be a binding node, but was: %s",
diff --git a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
index 4c3cffa83..5e9b1e8a8 100644
--- a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
+++ b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
@@ -61,7 +61,7 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    bindingGraph.edges().stream()
+    bindingGraph.network().edges().stream()
         .flatMap(instancesOf(ChildFactoryMethodEdge.class))
         .forEach(
             edge -> {
@@ -77,7 +77,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
       ChildFactoryMethodEdge edge, BindingGraph graph) {
     ImmutableSet<TypeElement> factoryMethodParameters =
         subgraphFactoryMethodParameters(edge, graph);
-    ComponentNode child = (ComponentNode) graph.incidentNodes(edge).target();
+    ComponentNode child = (ComponentNode) graph.network().incidentNodes(edge).target();
     SetView<TypeElement> modulesOwnedByChild = ownedModules(child, graph);
     return graph.bindingNodes().stream()
         // bindings owned by child
@@ -100,7 +100,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
   private ImmutableSet<TypeElement> subgraphFactoryMethodParameters(
       ChildFactoryMethodEdge edge, BindingGraph bindingGraph) {
-    ComponentNode parent = (ComponentNode) bindingGraph.incidentNodes(edge).source();
+    ComponentNode parent = (ComponentNode) bindingGraph.network().incidentNodes(edge).source();
     DeclaredType parentType = asDeclared(parent.componentPath().currentComponent().asType());
     ExecutableType factoryMethodType =
         asExecutable(types.asMemberOf(parentType, edge.factoryMethod()));
@@ -138,7 +138,13 @@ private void reportMissingModuleParameters(
         edge,
         "%s requires modules which have no visible default constructors. "
             + "Add the following modules as parameters to this method: %s",
-        graph.incidentNodes(edge).target().componentPath().currentComponent().getQualifiedName(),
+        graph
+            .network()
+            .incidentNodes(edge)
+            .target()
+            .componentPath()
+            .currentComponent()
+            .getQualifiedName(),
         Joiner.on(", ").join(missingModules));
   }
 }
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 7c724d787..3c8d31bb0 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -34,8 +34,6 @@
 import com.google.common.graph.Network;
 import com.google.common.graph.NetworkBuilder;
 import dagger.Module;
-import dagger.model.BindingGraph.Edge;
-import dagger.model.BindingGraph.Node;
 import java.util.Optional;
 import java.util.stream.Stream;
 import javax.lang.model.element.ExecutableElement;
@@ -71,9 +69,26 @@
  *
  * <p><b>Note that this API is experimental and will change.</b>
  */
-public final class BindingGraph extends ForwardingNetwork<Node, Edge> {
+public final class BindingGraph {
+  private final ImmutableNetwork<Node, Edge> network;
+
   BindingGraph(Network<Node, Edge> network) {
-    super(ImmutableNetwork.copyOf(network));
+    this.network = ImmutableNetwork.copyOf(network);
+  }
+
+  /** Returns the graph in its {@link Network} representation. */
+  public ImmutableNetwork<Node, Edge> network() {
+    return network;
+  }
+
+  @Override
+  public int hashCode() {
+    return network.hashCode();
+  }
+
+  @Override
+  public String toString() {
+    return network.toString();
   }
 
   /** Returns the binding nodes. */
@@ -154,7 +169,7 @@ public ComponentNode rootComponentNode() {
   }
 
   private Stream<DependencyEdge> dependencyEdgeStream(Node node) {
-    return outEdges(node).stream().flatMap(instancesOf(DependencyEdge.class));
+    return network.outEdges(node).stream().flatMap(instancesOf(DependencyEdge.class));
   }
 
   /**
@@ -168,7 +183,7 @@ public ComponentNode rootComponentNode() {
   /** Returns the binding nodes or missing binding nodes that directly satisfy entry points. */
   public ImmutableSet<MaybeBindingNode> entryPointBindingNodes() {
     return entryPointEdgeStream()
-        .map(edge -> (MaybeBindingNode) incidentNodes(edge).target())
+        .map(edge -> (MaybeBindingNode) network.incidentNodes(edge).target())
         .collect(toImmutableSet());
   }
 
@@ -191,14 +206,14 @@ public ComponentNode rootComponentNode() {
   // TODO(dpb): Make public. Cache.
   private ImmutableNetwork<Node, DependencyEdge> dependencyGraph() {
     MutableNetwork<Node, DependencyEdge> dependencyGraph =
-        NetworkBuilder.from(this)
-            .expectedNodeCount(nodes().size())
+        NetworkBuilder.from(network)
+            .expectedNodeCount(network.nodes().size())
             .expectedEdgeCount((int) dependencyEdgeStream().count())
             .build();
     dependencyEdgeStream()
         .forEach(
             edge -> {
-              EndpointPair<Node> endpoints = incidentNodes(edge);
+              EndpointPair<Node> endpoints = network.incidentNodes(edge);
               dependencyGraph.addEdge(endpoints.source(), endpoints.target(), edge);
             });
     return ImmutableNetwork.copyOf(dependencyGraph);
@@ -209,11 +224,11 @@ public ComponentNode rootComponentNode() {
   }
 
   private <N extends Node> Stream<N> nodeStream(Class<N> clazz) {
-    return nodes().stream().flatMap(instancesOf(clazz));
+    return network.nodes().stream().flatMap(instancesOf(clazz));
   }
 
   private Stream<DependencyEdge> dependencyEdgeStream() {
-    return edges().stream().flatMap(instancesOf(DependencyEdge.class));
+    return network.edges().stream().flatMap(instancesOf(DependencyEdge.class));
   }
 
   private Stream<DependencyEdge> entryPointEdgeStream() {
diff --git a/java/dagger/model/ForwardingNetwork.java b/java/dagger/model/ForwardingNetwork.java
deleted file mode 100644
index aa4b538f9..000000000
--- a/java/dagger/model/ForwardingNetwork.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.model;
-
-import static dagger.internal.Preconditions.checkNotNull;
-
-import com.google.common.collect.ForwardingObject;
-import com.google.common.graph.ElementOrder;
-import com.google.common.graph.EndpointPair;
-import com.google.common.graph.Graph;
-import com.google.common.graph.Network;
-import java.util.Optional;
-import java.util.Set;
-
-/** A {@link Network} that delegates all methods to another instance. */
-// TODO(dpb): Move to com.google.common.graph.
-public class ForwardingNetwork<N, E> extends ForwardingObject implements Network<N, E> {
-
-  private final Network<N, E> delegate;
-
-  protected ForwardingNetwork(Network<N, E> delegate) {
-    this.delegate = checkNotNull(delegate);
-  }
-
-  @Override
-  protected final Network<N, E> delegate() {
-    return delegate;
-  }
-
-  @Override
-  public Set<N> nodes() {
-    return delegate().nodes();
-  }
-
-  @Override
-  public Set<E> edges() {
-    return delegate().edges();
-  }
-
-  @Override
-  public Graph<N> asGraph() {
-    return delegate().asGraph();
-  }
-
-  @Override
-  public boolean isDirected() {
-    return delegate().isDirected();
-  }
-
-  @Override
-  public boolean allowsParallelEdges() {
-    return delegate().allowsParallelEdges();
-  }
-
-  @Override
-  public boolean allowsSelfLoops() {
-    return delegate().allowsSelfLoops();
-  }
-
-  @Override
-  public ElementOrder<N> nodeOrder() {
-    return delegate().nodeOrder();
-  }
-
-  @Override
-  public ElementOrder<E> edgeOrder() {
-    return delegate().edgeOrder();
-  }
-
-  @Override
-  public Set<N> adjacentNodes(N node) {
-    return delegate().adjacentNodes(node);
-  }
-
-  @Override
-  public Set<N> predecessors(N node) {
-    return delegate().predecessors(node);
-  }
-
-  @Override
-  public Set<N> successors(N node) {
-    return delegate().successors(node);
-  }
-
-  @Override
-  public Set<E> incidentEdges(N node) {
-    return delegate().incidentEdges(node);
-  }
-
-  @Override
-  public Set<E> inEdges(N node) {
-    return delegate().inEdges(node);
-  }
-
-  @Override
-  public Set<E> outEdges(N node) {
-    return delegate().outEdges(node);
-  }
-
-  @Override
-  public int degree(N node) {
-    return delegate().degree(node);
-  }
-
-  @Override
-  public int inDegree(N node) {
-    return delegate().inDegree(node);
-  }
-
-  @Override
-  public int outDegree(N node) {
-    return delegate().outDegree(node);
-  }
-
-  @Override
-  public EndpointPair<N> incidentNodes(E edge) {
-    return delegate().incidentNodes(edge);
-  }
-
-  @Override
-  public Set<E> adjacentEdges(E edge) {
-    return delegate().adjacentEdges(edge);
-  }
-
-  @Override
-  public Set<E> edgesConnecting(N nodeU, N nodeV) {
-    return delegate().edgesConnecting(nodeU, nodeV);
-  }
-
-  @SuppressWarnings("MissingOverride") // Until Guava 23.0
-  public Optional<E> edgeConnecting(N nodeU, N nodeV) {
-    return Optional.ofNullable(edgeConnectingOrNull(nodeU, nodeV));
-  }
-
-  @SuppressWarnings("MissingOverride") // Until Guava 23.0
-  // @Nullable // TODO(ronshapiro): replace with the checker framework?
-  public E edgeConnectingOrNull(N nodeU, N nodeV) {
-    return delegate().edgeConnectingOrNull(nodeU, nodeV);
-  }
-
-  @Override
-  public boolean hasEdgeConnecting(N nodeU, N nodeV) {
-    return delegate().hasEdgeConnecting(nodeU, nodeV);
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    return delegate().equals(obj);
-  }
-
-  @Override
-  public int hashCode() {
-    return delegate().hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return delegate().toString();
-  }
-}
diff --git a/java/dagger/model/testing/BindingGraphSubject.java b/java/dagger/model/testing/BindingGraphSubject.java
index d88f93d27..cd4e65ce1 100644
--- a/java/dagger/model/testing/BindingGraphSubject.java
+++ b/java/dagger/model/testing/BindingGraphSubject.java
@@ -137,7 +137,7 @@ public void dependsOnBindingWithKey(String qualifier, String type) {
     }
 
     private void dependsOnBindingWithKeyString(String keyString) {
-      if (actualBindingGraph().successors(actual()).stream()
+      if (actualBindingGraph().network().successors(actual()).stream()
           .filter(node -> node instanceof BindingNode)
           .map(node -> (BindingNode) node)
           .noneMatch(node -> node.key().toString().equals(keyString))) {
