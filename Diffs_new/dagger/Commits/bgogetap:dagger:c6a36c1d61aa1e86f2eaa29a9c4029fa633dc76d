diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index ee0887e8c..eac3f02b2 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -124,7 +124,6 @@ java_library(
         "BindingGraph.java",
         "BindingNodeImpl.java",
         "BindingType.java",
-        "BindingTypeMapper.java",
         "BindingVariableNamer.java",  # needed by FrameworkField
         "BindsTypeChecker.java",
         "ComponentDescriptor.java",
@@ -140,6 +139,7 @@ java_library(
         "FrameworkDependency.java",
         "FrameworkField.java",  # Used by SourceFiles
         "FrameworkType.java",
+        "FrameworkTypeMapper.java",
         "InjectBindingRegistry.java",
         "KeyFactory.java",
         "MapKeys.java",
diff --git a/java/dagger/internal/codegen/Binding.java b/java/dagger/internal/codegen/Binding.java
index 6254b73ca..f3fd84a4a 100644
--- a/java/dagger/internal/codegen/Binding.java
+++ b/java/dagger/internal/codegen/Binding.java
@@ -28,15 +28,16 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.Scope;
-import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
+import java.util.Set;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
@@ -157,15 +158,16 @@ static DependencyAssociation create(
   private final Supplier<ImmutableList<DependencyAssociation>> dependencyAssociations =
       memoize(
           () -> {
-            BindingTypeMapper bindingTypeMapper = BindingTypeMapper.forBindingType(bindingType());
+            FrameworkTypeMapper frameworkTypeMapper =
+                FrameworkTypeMapper.forBindingType(bindingType());
             ImmutableList.Builder<DependencyAssociation> list = ImmutableList.builder();
-            for (Collection<DependencyRequest> requests : groupByUnresolvedKey()) {
+            for (Set<DependencyRequest> requests : groupByUnresolvedKey()) {
               list.add(
                   DependencyAssociation.create(
                       FrameworkDependency.create(
                           getOnlyElement(
                               requests.stream().map(DependencyRequest::key).collect(toSet())),
-                          bindingTypeMapper.getBindingType(requests)),
+                          frameworkTypeMapper.getFrameworkType(requests)),
                       requests));
             }
             return list.build();
@@ -212,7 +214,7 @@ static DependencyAssociation create(
    * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
    * from the {@link Binding#unresolved()} binding if it exists.
    */
-  private ImmutableList<Collection<DependencyRequest>> groupByUnresolvedKey() {
+  private ImmutableList<Set<DependencyRequest>> groupByUnresolvedKey() {
     ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
         ImmutableSetMultimap.builder();
     Iterator<DependencyRequest> dependencies = dependencies().iterator();
@@ -222,10 +224,8 @@ static DependencyAssociation create(
       dependenciesByKeyBuilder.put(unresolvedDependencies.next().key(), dependencies.next());
     }
     return ImmutableList.copyOf(
-        dependenciesByKeyBuilder
-            .orderValuesBy(SourceFiles.DEPENDENCY_ORDERING)
-            .build()
-            .asMap()
+        Multimaps.asMap(
+                dependenciesByKeyBuilder.orderValuesBy(SourceFiles.DEPENDENCY_ORDERING).build())
             .values());
   }
 
diff --git a/java/dagger/internal/codegen/BindingType.java b/java/dagger/internal/codegen/BindingType.java
index 2aefe4522..37109c73b 100644
--- a/java/dagger/internal/codegen/BindingType.java
+++ b/java/dagger/internal/codegen/BindingType.java
@@ -16,43 +16,16 @@
 
 package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.ParameterizedTypeName;
-import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
-import dagger.producers.Producer;
-import javax.inject.Provider;
 
 /** Whether a binding or declaration is for provision, production, or a {@link MembersInjector}. */
 enum BindingType {
   /** A binding with this type is a {@link ProvisionBinding}. */
-  PROVISION(Provider.class),
+  PROVISION,
 
   /** A binding with this type is a {@link MembersInjectionBinding}. */
-  MEMBERS_INJECTION(MembersInjector.class),
+  MEMBERS_INJECTION,
 
   /** A binding with this type is a {@link ProductionBinding}. */
-  PRODUCTION(Producer.class),
-  ;
-
-  static final ImmutableSet<BindingType> CONTRIBUTION_TYPES =
-      Sets.immutableEnumSet(PROVISION, PRODUCTION);
-
-  private final Class<?> frameworkClass;
-
-  BindingType(Class<?> frameworkClass) {
-    this.frameworkClass = frameworkClass;
-  }
-
-  /** The framework class associated with bindings of this type. */
-  Class<?> frameworkClass() {
-    return frameworkClass;
-  }
-
-  /** Returns the {@link #frameworkClass()} parameterized with a type. */
-  ParameterizedTypeName frameworkClassOf(TypeName valueType) {
-    return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);
-  }
+  PRODUCTION,
 }
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index c47747d0c..8f4b5b3d4 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -180,7 +180,9 @@ Expression getDependencyExpression(DependencyRequest request, ClassName requesti
   Expression getDependencyExpression(
       FrameworkDependency frameworkDependency, ClassName requestingClass) {
     return getDependencyExpression(
-        frameworkDependency.key(), frameworkDependency.dependencyRequestKind(), requestingClass);
+        frameworkDependency.key(),
+        frameworkDependency.frameworkType().requestKind(),
+        requestingClass);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index c58a980b3..9d206eff5 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -143,7 +143,7 @@ FactoryCreationStrategy factoryCreationStrategy() {
   final TypeMirror contributedType() {
     switch (contributionType()) {
       case MAP:
-        return MapType.from(key()).unwrappedValueType(bindingType().frameworkClass());
+        return MapType.from(key()).unwrappedFrameworkValueType();
       case SET:
         return SetType.from(key()).elementType();
       case SET_VALUES:
diff --git a/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java b/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
index 09fd1f962..63521c07f 100644
--- a/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
+++ b/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
@@ -46,6 +46,6 @@ public CodeBlock creationExpression() {
         componentBindingExpressions
             .getDependencyExpression(frameworkDependency, generatedComponentModel.name())
             .codeBlock(),
-        binding.bindingType().frameworkClass());
+        frameworkDependency.frameworkClass());
   }
 }
diff --git a/java/dagger/internal/codegen/FrameworkDependency.java b/java/dagger/internal/codegen/FrameworkDependency.java
index 6b69e0eb9..feea7a0a6 100644
--- a/java/dagger/internal/codegen/FrameworkDependency.java
+++ b/java/dagger/internal/codegen/FrameworkDependency.java
@@ -18,8 +18,6 @@
 
 import com.google.auto.value.AutoValue;
 import dagger.model.Key;
-import dagger.model.RequestKind;
-import javax.inject.Provider;
 
 /**
  * The framework class and binding key for a resolved dependency of a binding. If a binding has
@@ -34,7 +32,7 @@
  *
  * But they both can be satisfied with the same instance of {@code Provider<Bar>}. So one instance
  * of {@code FrameworkDependency} will be used for both. Its {@link #key()} will be for {@code Bar},
- * and its {@link #frameworkClass()} will be {@link Provider}.
+ * and its {@link #frameworkType()} will be {@link FrameworkType#PROVIDER}.
  *
  * <pre><code>
  *   {@literal @Provides} static Foo provideFoo(Bar bar, {@literal Provider<Bar>} barProvider) {
@@ -48,30 +46,16 @@
   /** The fully-resolved key shared by all the dependency requests. */
   abstract Key key();
 
-  /** The binding type of the framework dependency. */
-  abstract BindingType bindingType();
+  /** The type of the framework dependency. */
+  abstract FrameworkType frameworkType();
 
-  /** The dependency request kind that is equivalent to requesting the framework dependency. */
-  RequestKind dependencyRequestKind() {
-    switch (bindingType()) {
-      case PROVISION:
-        return RequestKind.PROVIDER;
-
-      case PRODUCTION:
-        return RequestKind.PRODUCER;
-
-      default:
-        throw new AssertionError(bindingType());
-    }
-  }
-
-  /** The framework class to use for these requests. */
+  /** The framework class to use for this dependency. */
   final Class<?> frameworkClass() {
-    return bindingType().frameworkClass();
+    return frameworkType().frameworkClass();
   }
 
   /** Returns a new instance with the given key and type. */
-  static FrameworkDependency create(Key key, BindingType bindingType) {
-    return new AutoValue_FrameworkDependency(key, bindingType);
+  static FrameworkDependency create(Key key, FrameworkType frameworkType) {
+    return new AutoValue_FrameworkDependency(key, frameworkType);
   }
 }
diff --git a/java/dagger/internal/codegen/FrameworkField.java b/java/dagger/internal/codegen/FrameworkField.java
index fdb9f6e59..c04dcf11f 100644
--- a/java/dagger/internal/codegen/FrameworkField.java
+++ b/java/dagger/internal/codegen/FrameworkField.java
@@ -69,24 +69,17 @@ static FrameworkField create(
   static FrameworkField forResolvedBindings(
       ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
     return create(
-        frameworkClass.orElse(ClassName.get(resolvedBindings.frameworkClass())),
+        frameworkClass.orElse(
+            ClassName.get(
+                FrameworkType.forBindingType(resolvedBindings.bindingType()).frameworkClass())),
         TypeName.get(fieldValueType(resolvedBindings)),
         frameworkFieldName(resolvedBindings));
   }
 
   private static TypeMirror fieldValueType(ResolvedBindings resolvedBindings) {
-    if (resolvedBindings.isMultibindingContribution()) {
-      switch (resolvedBindings.contributionType()) {
-        case MAP:
-          return MapType.from(resolvedBindings.key())
-              .unwrappedValueType(resolvedBindings.frameworkClass());
-        case SET:
-          return SetType.from(resolvedBindings.key()).elementType();
-        default:
-          // do nothing
-      }
-    }
-    return resolvedBindings.key().type();
+    return resolvedBindings.isMultibindingContribution()
+        ? resolvedBindings.contributionBinding().contributedType()
+        : resolvedBindings.key().type();
   }
 
   private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 0bfb42709..54284a738 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -24,20 +24,19 @@
 import com.squareup.javapoet.FieldSpec;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 
 /** A binding expression that uses a {@link FrameworkType} field. */
 abstract class FrameworkInstanceBindingExpression extends BindingExpression {
   private final ResolvedBindings resolvedBindings;
   private final FrameworkInstanceSupplier frameworkInstanceSupplier;
   private final DaggerTypes types;
-  private final Elements elements;
+  private final DaggerElements elements;
 
   FrameworkInstanceBindingExpression(
       ResolvedBindings resolvedBindings,
       FrameworkInstanceSupplier frameworkInstanceSupplier,
       DaggerTypes types,
-      Elements elements) {
+      DaggerElements elements) {
     this.resolvedBindings = checkNotNull(resolvedBindings);
     this.frameworkInstanceSupplier = checkNotNull(frameworkInstanceSupplier);
     this.types = checkNotNull(types);
@@ -58,7 +57,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
         frameworkInstanceSupplier.specificType().isPresent()
                 || isTypeAccessibleFrom(contributedType, requestingClass.packageName())
                 || isInlinedFactoryCreation(memberSelect)
-            ? types.wrapType(contributedType, resolvedBindings.frameworkClass())
+            ? types.wrapType(contributedType, frameworkType().frameworkClass())
             : rawFrameworkType();
     return Expression.create(expressionType, memberSelect.getExpressionFor(requestingClass));
   }
@@ -82,7 +81,6 @@ private static boolean isInlinedFactoryCreation(MemberSelect memberSelect) {
   }
 
   private DeclaredType rawFrameworkType() {
-    return types.getDeclaredType(
-        elements.getTypeElement(resolvedBindings.frameworkClass().getCanonicalName()));
+    return types.getDeclaredType(elements.getTypeElement(frameworkType().frameworkClass()));
   }
 }
diff --git a/java/dagger/internal/codegen/FrameworkType.java b/java/dagger/internal/codegen/FrameworkType.java
index 46585ae21..9ac0b9df9 100644
--- a/java/dagger/internal/codegen/FrameworkType.java
+++ b/java/dagger/internal/codegen/FrameworkType.java
@@ -18,12 +18,14 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
-import static dagger.internal.codegen.RequestKinds.frameworkClass;
 import static dagger.model.RequestKind.INSTANCE;
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
 import dagger.Lazy;
 import dagger.internal.DoubleCheck;
 import dagger.internal.ProviderOfLazy;
@@ -39,6 +41,11 @@
 enum FrameworkType {
   /** A {@link Provider}. */
   PROVIDER {
+    @Override
+    Class<?> frameworkClass() {
+      return Provider.class;
+    }
+
     @Override
     RequestKind requestKind() {
       return RequestKind.PROVIDER;
@@ -94,13 +101,18 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
 
         default:
           return Expression.create(
-              types.rewrapType(from.type(), frameworkClass(requestKind)), codeBlock);
+              types.rewrapType(from.type(), RequestKinds.frameworkClass(requestKind)), codeBlock);
       }
     }
   },
 
   /** A {@link Producer}. */
   PRODUCER {
+    @Override
+    Class<?> frameworkClass() {
+      return Producer.class;
+    }
+
     @Override
     RequestKind requestKind() {
       return RequestKind.PRODUCER;
@@ -140,6 +152,26 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
   },
   ;
 
+  /** Returns the framework type appropriate for fields for a given binding type. */
+  static FrameworkType forBindingType(BindingType bindingType) {
+    switch (bindingType) {
+      case PROVISION:
+        return PROVIDER;
+      case PRODUCTION:
+        return PRODUCER;
+      case MEMBERS_INJECTION:
+    }
+    throw new AssertionError(bindingType);
+  }
+
+  /** The class of fields of this type. */
+  abstract Class<?> frameworkClass();
+
+  /** Returns the {@link #frameworkClass()} parameterized with a type. */
+  ParameterizedTypeName frameworkClassOf(TypeName valueType) {
+    return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);
+  }
+
   /** Returns the {@link RequestKind} matching this framework type. */
   abstract RequestKind requestKind();
 
diff --git a/java/dagger/internal/codegen/BindingTypeMapper.java b/java/dagger/internal/codegen/FrameworkTypeMapper.java
similarity index 53%
rename from java/dagger/internal/codegen/BindingTypeMapper.java
rename to java/dagger/internal/codegen/FrameworkTypeMapper.java
index f407cbed3..d768ca79f 100644
--- a/java/dagger/internal/codegen/BindingTypeMapper.java
+++ b/java/dagger/internal/codegen/FrameworkTypeMapper.java
@@ -17,30 +17,32 @@
 package dagger.internal.codegen;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.BindingType.CONTRIBUTION_TYPES;
 import static dagger.internal.codegen.BindingType.PRODUCTION;
-import static dagger.internal.codegen.BindingType.PROVISION;
+import static java.util.stream.Collectors.toSet;
 
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 import dagger.model.DependencyRequest;
+import dagger.model.Key;
 import dagger.model.RequestKind;
 import dagger.producers.Producer;
+import java.util.Set;
 import javax.inject.Provider;
 
 /**
- * A mapper for associating a {@link RequestKind} to a {@link BindingType}, dependent on the type of
- * code to be generated (e.g., for {@link Provider} or {@link Producer}).
+ * A mapper for associating a {@link RequestKind} to a {@link FrameworkType}, dependent on the type
+ * of code to be generated (e.g., for {@link Provider} or {@link Producer}).
  */
-enum BindingTypeMapper {
+enum FrameworkTypeMapper {
   FOR_PROVIDER() {
-    @Override public BindingType getBindingType(RequestKind requestKind) {
+    @Override
+    public FrameworkType getFrameworkType(RequestKind requestKind) {
       switch (requestKind) {
         case INSTANCE:
         case PROVIDER:
         case PROVIDER_OF_LAZY:
         case LAZY:
-          return PROVISION;
+          return FrameworkType.PROVIDER;
         case PRODUCED:
         case PRODUCER:
           throw new IllegalArgumentException(requestKind.toString());
@@ -50,42 +52,45 @@
     }
   },
   FOR_PRODUCER() {
-    @Override public BindingType getBindingType(RequestKind requestKind) {
+    @Override
+    public FrameworkType getFrameworkType(RequestKind requestKind) {
       switch (requestKind) {
         case INSTANCE:
         case PRODUCED:
         case PRODUCER:
-          return PRODUCTION;
+          return FrameworkType.PRODUCER;
         case PROVIDER:
         case PROVIDER_OF_LAZY:
         case LAZY:
-          return PROVISION;
+          return FrameworkType.PROVIDER;
         default:
           throw new AssertionError(requestKind);
       }
     }
   };
 
-  static BindingTypeMapper forBindingType(BindingType bindingType) {
+  static FrameworkTypeMapper forBindingType(BindingType bindingType) {
     return bindingType.equals(PRODUCTION) ? FOR_PRODUCER : FOR_PROVIDER;
   }
 
-  abstract BindingType getBindingType(RequestKind requestKind);
+  abstract FrameworkType getFrameworkType(RequestKind requestKind);
 
   /**
-   * Returns the {@link BindingType} to use for a collection of requests of the same {@link
-   * dagger.model.Key}. This allows factories to only take a single argument for multiple requests
-   * of the same key.
+   * Returns the {@link FrameworkType} to use for a collection of requests of the same {@link Key}.
+   * This allows factories to only take a single argument for multiple requests of the same key.
    */
-  BindingType getBindingType(Iterable<DependencyRequest> requests) {
-    ImmutableSet<BindingType> classes =
-        FluentIterable.from(requests).transform(request -> getBindingType(request.kind())).toSet();
-    if (classes.size() == 1) {
-      return getOnlyElement(classes);
-    } else if (classes.equals(CONTRIBUTION_TYPES)) {
-      return PROVISION;
+  FrameworkType getFrameworkType(Set<DependencyRequest> requests) {
+    Set<FrameworkType> frameworkTypes =
+        requests.stream().map(request -> getFrameworkType(request.kind())).collect(toSet());
+    if (frameworkTypes.size() == 1) {
+      return getOnlyElement(frameworkTypes);
+    } else if (frameworkTypes.equals(CONTRIBUTION_TYPES)) {
+      return FrameworkType.PROVIDER;
     } else {
-      throw new IllegalArgumentException("Bad set of framework classes: " + classes);
+      throw new IllegalArgumentException("Bad set of framework classes: " + frameworkTypes);
     }
   }
+
+  private static final ImmutableSet<FrameworkType> CONTRIBUTION_TYPES =
+      Sets.immutableEnumSet(FrameworkType.PROVIDER, FrameworkType.PRODUCER);
 }
diff --git a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
index add4c7669..b0247e4ef 100644
--- a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
+++ b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
@@ -33,6 +33,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import dagger.Component;
+import dagger.MembersInjector;
 import dagger.Provides;
 import dagger.model.Key;
 import java.util.ArrayDeque;
@@ -42,6 +43,7 @@
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.inject.Singleton;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -68,13 +70,13 @@
   private final CompilerOptions compilerOptions;
 
   final class BindingsCollection<B extends Binding> {
-    private final BindingType bindingType;
+    private final Class<?> factoryClass;
     private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
     private final Deque<B> bindingsRequiringGeneration = new ArrayDeque<>();
     private final Set<Key> materializedBindingKeys = Sets.newLinkedHashSet();
-    
-    BindingsCollection(BindingType bindingType) {
-      this.bindingType = bindingType;
+
+    BindingsCollection(Class<?> factoryClass) {
+      this.factoryClass = factoryClass;
     }
 
     void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
@@ -117,7 +119,7 @@ void tryToGenerateBinding(B binding, boolean warnIfNotAlreadyGenerated) {
               String.format(
                   "Generating a %s for %s. "
                       + "Prefer to run the dagger processor over that class instead.",
-                  bindingType.frameworkClass().getSimpleName(),
+                  factoryClass.getSimpleName(),
                   types.erasure(binding.key().type()))); // erasure to strip <T> from msgs.
         }
       }
@@ -147,9 +149,9 @@ private void tryToCacheBinding(B binding) {
   }
 
   private final BindingsCollection<ProvisionBinding> provisionBindings =
-      new BindingsCollection<>(BindingType.PROVISION);
+      new BindingsCollection<>(Provider.class);
   private final BindingsCollection<MembersInjectionBinding> membersInjectionBindings =
-      new BindingsCollection<>(BindingType.MEMBERS_INJECTION);
+      new BindingsCollection<>(MembersInjector.class);
 
   @Inject
   InjectBindingRegistryImpl(
diff --git a/java/dagger/internal/codegen/InjectionOrProvisionProviderCreationExpression.java b/java/dagger/internal/codegen/InjectionOrProvisionProviderCreationExpression.java
index f80c0831e..a2ba0e0c4 100644
--- a/java/dagger/internal/codegen/InjectionOrProvisionProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/InjectionOrProvisionProviderCreationExpression.java
@@ -24,11 +24,11 @@
 import com.squareup.javapoet.TypeName;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
 import java.util.Optional;
+import javax.inject.Provider;
 
 /**
- * A {@link javax.inject.Provider} creation expression for an {@link
- * javax.inject.Inject @Inject}-constructed class or a {@link dagger.Provides @Provides}-annotated
- * module method.
+ * A {@link Provider} creation expression for an {@link javax.inject.Inject @Inject}-constructed
+ * class or a {@link dagger.Provides @Provides}-annotated module method.
  */
 // TODO(dpb): Resolve with ProducerCreationExpression.
 final class InjectionOrProvisionProviderCreationExpression
@@ -56,7 +56,7 @@ public CodeBlock creationExpression() {
     if (binding.kind().equals(INJECTION)
         && binding.unresolved().isPresent()
         && binding.scope().isPresent()) {
-      return CodeBlocks.cast(createFactory, binding.bindingType().frameworkClass());
+      return CodeBlocks.cast(createFactory, Provider.class);
     } else {
       return createFactory;
     }
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
index 5f8650be5..645c2193e 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -64,15 +64,14 @@
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 
 /** A factory for {@link Key}s. */
 final class KeyFactory {
   private final DaggerTypes types;
-  private final Elements elements;
+  private final DaggerElements elements;
 
   @Inject
-  KeyFactory(DaggerTypes types, Elements elements) {
+  KeyFactory(DaggerTypes types, DaggerElements elements) {
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
   }
@@ -192,20 +191,17 @@ private Key forBindingMethod(
   /**
    * Returns the key for a {@link Multibinds @Multibinds} method.
    *
-   * <p>The key's type is either {@code Set<T>} or {@code Map<K, F<V>>}, where {@code F} is either
-   * {@link Provider} or {@link Producer}, depending on {@code bindingType}.
+   * <p>The key's type is either {@code Set<T>} or {@code Map<K, Provider<V>>}. The latter works
+   * even for maps used by {@code Producer}s.
    */
-  Key forMultibindsMethod(
-      BindingType bindingType, ExecutableType executableType, ExecutableElement method) {
+  Key forMultibindsMethod(ExecutableType executableType, ExecutableElement method) {
     checkArgument(method.getKind().equals(METHOD), "%s must be a method", method);
-    TypeElement factoryType =
-        elements.getTypeElement(bindingType.frameworkClass().getCanonicalName());
     TypeMirror returnType = executableType.getReturnType();
     TypeMirror keyType =
         MapType.isMap(returnType)
             ? mapOfFrameworkType(
                 MapType.from(returnType).keyType(),
-                factoryType,
+                elements.getTypeElement(Provider.class),
                 MapType.from(returnType).valueType())
             : returnType;
     return forMethod(method, keyType);
diff --git a/java/dagger/internal/codegen/MapType.java b/java/dagger/internal/codegen/MapType.java
index c7e51e047..73ecdbfa3 100644
--- a/java/dagger/internal/codegen/MapType.java
+++ b/java/dagger/internal/codegen/MapType.java
@@ -88,7 +88,20 @@ boolean valuesAreTypeOf(Class<?> clazz) {
   boolean valuesAreFrameworkType() {
     return FrameworkTypes.isFrameworkType(valueType());
   }
-  
+
+  /**
+   * {@code V} if {@link #valueType()} is a framework type like {@code Provider<V>} or {@code
+   * Producer<V>}.
+   *
+   * @throws IllegalStateException if {@link #isRawType()} is true or {@link #valueType()} is not a
+   *     framework type
+   */
+  TypeMirror unwrappedFrameworkValueType() {
+    checkState(
+        valuesAreFrameworkType(), "called unwrappedFrameworkValueType() on %s", declaredMapType());
+    return uncheckedUnwrappedValueType();
+  }
+
   /**
    * {@code V} if {@link #valueType()} is a {@code WrappingClass<V>}.
    *
@@ -103,6 +116,10 @@ TypeMirror unwrappedValueType(Class<?> wrappingClass) {
         "%s must have exactly one type parameter",
         wrappingClass);
     checkState(valuesAreTypeOf(wrappingClass), "expected values to be %s: %s", wrappingClass, this);
+    return uncheckedUnwrappedValueType();
+  }
+
+  private TypeMirror uncheckedUnwrappedValueType() {
     return MoreTypes.asDeclared(valueType()).getTypeArguments().get(0);
   }
 
diff --git a/java/dagger/internal/codegen/MultibindingDeclaration.java b/java/dagger/internal/codegen/MultibindingDeclaration.java
index 4fa25f537..a642b1d73 100644
--- a/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -21,17 +21,13 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import dagger.Module;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.model.Key;
 import dagger.multibindings.Multibinds;
-import dagger.producers.Producer;
-import dagger.producers.ProducerModule;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -48,9 +44,8 @@
 abstract class MultibindingDeclaration extends BindingDeclaration implements HasContributionType {
 
   /**
-   * The map or set key whose availability is declared. For maps, this will be {@code Map<K, F<V>>},
-   * where {@code F} is either {@link Provider} or {@link Producer}. For sets, this will be
-   * {@code Set<T>}.
+   * The map or set key whose availability is declared. For maps, this will be {@code Map<K,
+   * Provider<V>>}. For sets, this will be {@code Set<T>}.
    */
   @Override
   public abstract Key key();
@@ -62,13 +57,6 @@
   @Override
   public abstract ContributionType contributionType();
 
-  /**
-   * {@link BindingType#PROVISION} if {@link Multibinds @Multibinds}-annotated method
-   * is enclosed in a {@link Module @Module}, or {@link BindingType#PROVISION} if it is nested in a
-   * {@link ProducerModule @ProducerModule}.
-   */
-  abstract BindingType bindingType();
-
   /**
    * A factory for {@link MultibindingDeclaration}s.
    */
@@ -87,26 +75,13 @@ MultibindingDeclaration forMultibindsMethod(
         ExecutableElement moduleMethod, TypeElement moduleElement) {
       checkArgument(isAnnotationPresent(moduleMethod, Multibinds.class));
       return forDeclaredMethod(
-          bindingType(moduleElement),
           moduleMethod,
           MoreTypes.asExecutable(
               types.asMemberOf(MoreTypes.asDeclared(moduleElement.asType()), moduleMethod)),
           moduleElement);
     }
 
-    private BindingType bindingType(Element moduleElement) {
-      if (isAnnotationPresent(moduleElement, Module.class)) {
-        return BindingType.PROVISION;
-      } else if (isAnnotationPresent(moduleElement, ProducerModule.class)) {
-        return BindingType.PRODUCTION;
-      } else {
-        throw new IllegalArgumentException(
-            "Expected " + moduleElement + " to be a @Module or @ProducerModule");
-      }
-    }
-
     private MultibindingDeclaration forDeclaredMethod(
-        BindingType bindingType,
         ExecutableElement method,
         ExecutableType methodType,
         TypeElement contributingType) {
@@ -118,9 +93,8 @@ private MultibindingDeclaration forDeclaredMethod(
       return new AutoValue_MultibindingDeclaration(
           Optional.<Element>of(method),
           Optional.of(contributingType),
-          keyFactory.forMultibindsMethod(bindingType, methodType, method),
-          contributionType(returnType),
-          bindingType);
+          keyFactory.forMultibindsMethod(methodType, method),
+          contributionType(returnType));
     }
 
     private ContributionType contributionType(TypeMirror returnType) {
diff --git a/java/dagger/internal/codegen/OptionalFactories.java b/java/dagger/internal/codegen/OptionalFactories.java
index 3297823d0..784b8ec9b 100644
--- a/java/dagger/internal/codegen/OptionalFactories.java
+++ b/java/dagger/internal/codegen/OptionalFactories.java
@@ -83,7 +83,7 @@
   private final Map<PresentFactorySpec, TypeSpec> presentFactoryClasses =
       new TreeMap<>(
           Comparator.comparing(PresentFactorySpec::valueKind)
-              .thenComparing(PresentFactorySpec::bindingType)
+              .thenComparing(PresentFactorySpec::frameworkType)
               .thenComparing(PresentFactorySpec::optionalKind));
 
   /**
@@ -173,7 +173,7 @@ private FieldSpec absentOptionalProviderField(OptionalKind optionalKind) {
   @AutoValue
   abstract static class PresentFactorySpec {
     /** Whether the factory is a {@link Provider} or a {@link Producer}. */
-    abstract BindingType bindingType();
+    abstract FrameworkType frameworkType();
 
     /** What kind of {@code Optional} is returned. */
     abstract OptionalKind optionalKind();
@@ -198,12 +198,12 @@ ParameterizedTypeName optionalType() {
 
     /** The type of the factory. */
     ParameterizedTypeName factoryType() {
-      return bindingType().frameworkClassOf(optionalType());
+      return frameworkType().frameworkClassOf(optionalType());
     }
 
     /** The type of the delegate provider or producer. */
     ParameterizedTypeName delegateType() {
-      return bindingType().frameworkClassOf(typeVariable());
+      return frameworkType().frameworkClassOf(typeVariable());
     }
 
     /** The name of the factory class. */
@@ -211,13 +211,13 @@ String factoryClassName() {
       return new StringBuilder("Present")
           .append(UPPER_UNDERSCORE.to(UPPER_CAMEL, optionalKind().name()))
           .append(UPPER_UNDERSCORE.to(UPPER_CAMEL, valueKind().toString()))
-          .append(bindingType().frameworkClass().getSimpleName())
+          .append(frameworkType().frameworkClass().getSimpleName())
           .toString();
     }
 
     private static PresentFactorySpec of(ContributionBinding binding) {
       return new AutoValue_OptionalFactories_PresentFactorySpec(
-          binding.bindingType(),
+          FrameworkType.forBindingType(binding.bindingType()),
           OptionalType.from(binding.key()).kind(),
           getOnlyElement(binding.dependencies()).kind());
     }
@@ -301,8 +301,8 @@ private MethodSpec presentOptionalFactoryGetMethod(
     MethodSpec.Builder getMethodBuilder =
         methodBuilder("get").addAnnotation(Override.class).addModifiers(PUBLIC);
 
-    switch (spec.bindingType()) {
-      case PROVISION:
+    switch (spec.frameworkType()) {
+      case PROVIDER:
         return getMethodBuilder
             .returns(spec.optionalType())
             .addCode(
@@ -313,7 +313,7 @@ private MethodSpec presentOptionalFactoryGetMethod(
                             spec.valueKind(), CodeBlock.of("$N", delegateField))))
             .build();
 
-      case PRODUCTION:
+      case PRODUCER:
         getMethodBuilder.returns(listenableFutureOf(spec.optionalType()));
 
         switch (spec.valueKind()) {
@@ -356,7 +356,7 @@ private MethodSpec presentOptionalFactoryGetMethod(
         }
 
       default:
-        throw new AssertionError(spec.bindingType());
+        throw new AssertionError(spec.frameworkType());
     }
   }
 
diff --git a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
index f34e26cfd..d35e6c2a0 100644
--- a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.BindingType.PROVISION;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -47,7 +46,7 @@ public CodeBlock creationExpression() {
         RequestKind.PRODUCER,
         componentBindingExpressions
             .getDependencyExpression(
-                FrameworkDependency.create(binding.key(), PROVISION),
+                FrameworkDependency.create(binding.key(), FrameworkType.PROVIDER),
                 generatedComponentModel.name())
             .codeBlock());
   }
diff --git a/java/dagger/internal/codegen/ProducerInstanceBindingExpression.java b/java/dagger/internal/codegen/ProducerInstanceBindingExpression.java
index e4481c2eb..3edc2b6db 100644
--- a/java/dagger/internal/codegen/ProducerInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/ProducerInstanceBindingExpression.java
@@ -16,8 +16,6 @@
 
 package dagger.internal.codegen;
 
-import javax.lang.model.util.Elements;
-
 /** Binding expression for producer instances. */
 final class ProducerInstanceBindingExpression extends FrameworkInstanceBindingExpression {
 
@@ -25,7 +23,7 @@
       ResolvedBindings resolvedBindings,
       FrameworkInstanceSupplier frameworkInstanceSupplier,
       DaggerTypes types,
-      Elements elements) {
+      DaggerElements elements) {
     super(
         resolvedBindings,
         frameworkInstanceSupplier,
diff --git a/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java b/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java
index 1f277ac66..aa8c8156e 100644
--- a/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java
@@ -16,8 +16,6 @@
 
 package dagger.internal.codegen;
 
-import javax.lang.model.util.Elements;
-
 /** Binding expression for provider instances. */
 final class ProviderInstanceBindingExpression extends FrameworkInstanceBindingExpression {
 
@@ -25,7 +23,7 @@
       ResolvedBindings resolvedBindings,
       FrameworkInstanceSupplier frameworkInstanceSupplier,
       DaggerTypes types,
-      Elements elements) {
+      DaggerElements elements) {
     super(
         resolvedBindings,
         frameworkInstanceSupplier,
diff --git a/java/dagger/internal/codegen/ResolvedBindings.java b/java/dagger/internal/codegen/ResolvedBindings.java
index 001df1924..e4421d5d8 100644
--- a/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/java/dagger/internal/codegen/ResolvedBindings.java
@@ -273,13 +273,6 @@ public ContributionType contributionType() {
     return contributionBinding().contributionType();
   }
 
-  /**
-   * The framework class associated with these bindings.
-   */
-  Class<?> frameworkClass() {
-    return bindingType().frameworkClass();
-  }
-
   /**
    * The scope associated with the single binding.
    *
diff --git a/javatests/dagger/internal/codegen/BindingTypeMapperTest.java b/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
similarity index 53%
rename from javatests/dagger/internal/codegen/BindingTypeMapperTest.java
rename to javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
index 7dc162cc7..37af821d9 100644
--- a/javatests/dagger/internal/codegen/BindingTypeMapperTest.java
+++ b/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
@@ -17,8 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertThat;
-import static dagger.internal.codegen.BindingType.PRODUCTION;
-import static dagger.internal.codegen.BindingType.PROVISION;
 import static dagger.model.RequestKind.INSTANCE;
 import static dagger.model.RequestKind.LAZY;
 import static dagger.model.RequestKind.PRODUCED;
@@ -29,32 +27,22 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Test case for {@link BindingTypeMapper}.
- */
+/** Test case for {@link FrameworkTypeMapper}. */
 @RunWith(JUnit4.class)
-public class BindingTypeMapperTest {
+public class FrameworkTypeMapperTest {
   @Test public void forProvider() {
-    BindingTypeMapper mapper = BindingTypeMapper.FOR_PROVIDER;
-    assertThat(mapper.getBindingType(INSTANCE))
-        .isEqualTo(PROVISION);
-    assertThat(mapper.getBindingType(LAZY))
-        .isEqualTo(PROVISION);
-    assertThat(mapper.getBindingType(PROVIDER))
-        .isEqualTo(PROVISION);
+    FrameworkTypeMapper mapper = FrameworkTypeMapper.FOR_PROVIDER;
+    assertThat(mapper.getFrameworkType(INSTANCE)).isEqualTo(FrameworkType.PROVIDER);
+    assertThat(mapper.getFrameworkType(LAZY)).isEqualTo(FrameworkType.PROVIDER);
+    assertThat(mapper.getFrameworkType(PROVIDER)).isEqualTo(FrameworkType.PROVIDER);
   }
 
   @Test public void forProducer() {
-    BindingTypeMapper mapper = BindingTypeMapper.FOR_PRODUCER;
-    assertThat(mapper.getBindingType(INSTANCE))
-        .isEqualTo(PRODUCTION);
-    assertThat(mapper.getBindingType(LAZY))
-        .isEqualTo(PROVISION);
-    assertThat(mapper.getBindingType(PROVIDER))
-        .isEqualTo(PROVISION);
-    assertThat(mapper.getBindingType(PRODUCER))
-        .isEqualTo(PRODUCTION);
-    assertThat(mapper.getBindingType(PRODUCED))
-        .isEqualTo(PRODUCTION);
+    FrameworkTypeMapper mapper = FrameworkTypeMapper.FOR_PRODUCER;
+    assertThat(mapper.getFrameworkType(INSTANCE)).isEqualTo(FrameworkType.PRODUCER);
+    assertThat(mapper.getFrameworkType(LAZY)).isEqualTo(FrameworkType.PROVIDER);
+    assertThat(mapper.getFrameworkType(PROVIDER)).isEqualTo(FrameworkType.PROVIDER);
+    assertThat(mapper.getFrameworkType(PRODUCER)).isEqualTo(FrameworkType.PRODUCER);
+    assertThat(mapper.getFrameworkType(PRODUCED)).isEqualTo(FrameworkType.PRODUCER);
   }
 }
