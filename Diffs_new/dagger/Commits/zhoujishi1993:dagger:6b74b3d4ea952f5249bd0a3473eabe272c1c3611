diff --git a/java/dagger/EncryptConstant.java b/java/dagger/EncryptConstant.java
index 93014460f..1738b0824 100644
--- a/java/dagger/EncryptConstant.java
+++ b/java/dagger/EncryptConstant.java
@@ -9,4 +9,5 @@
 
     public static final String PKCS5PADDING = "PKCS5PADDING";
 
+    public static final int KEYSIZE = 128;
 }
diff --git a/java/dagger/SymEncrypt.java b/java/dagger/SymEncrypt.java
index 5917c8c7c..c09bf64a4 100644
--- a/java/dagger/SymEncrypt.java
+++ b/java/dagger/SymEncrypt.java
@@ -14,5 +14,5 @@
     String algorithm() default EncryptConstant.AES;
     String blockMode() default EncryptConstant.CBC;
     String paddingMode() default EncryptConstant.PKCS5PADDING;
-    int keySize() default 128;
+    int keySize() default EncryptConstant.KEYSIZE;
 }
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 20b4ac6af..12127b0a0 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -175,6 +175,7 @@ java_library(
         "MultibindsMethodValidator.java",
         "ProducesMethodValidator.java",
         "ProvidesMethodValidator.java",
+        "SymEncValidator.java",
         "ValidationReport.java",
     ],
     plugins = CODEGEN_PLUGINS,
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index f55be7188..b3067e213 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -230,6 +230,7 @@ public SourceVersion getSupportedSourceVersion() {
     HelloWorldGenerator helloWorldGenerator = new HelloWorldGenerator(filer, elements);
 
     SymEncGenerator symEncGenerator = new SymEncGenerator(filer, types, elements);
+    SymEncValidator symEncValidator = new SymEncValidator(elements, types);
 
     return ImmutableList.of(
         new MapKeyProcessingStep(
@@ -253,7 +254,7 @@ public SourceVersion getSupportedSourceVersion() {
         componentProcessingStep,
         new BindingMethodProcessingStep(messager, anyBindingMethodValidator),
         new HelloWorldProcessingStep(helloWorldGenerator, messager),
-            new SymEncProssingStep(symEncGenerator, messager));
+            new SymEncProssingStep(symEncGenerator, symEncValidator, messager));
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/SymEncGenerator.java b/java/dagger/internal/codegen/SymEncGenerator.java
index 69c5db458..6eb78dd19 100644
--- a/java/dagger/internal/codegen/SymEncGenerator.java
+++ b/java/dagger/internal/codegen/SymEncGenerator.java
@@ -67,11 +67,11 @@ private void writeConstructors(TypeSpec.Builder builder, SymEncPara input){
         ClassName secureRandomClass = ClassName.get("java.security", "SecureRandom");
         addStatement(tryBuilder, makeAssignBlock(secureRandomClass, "secureRandom", makeNewBlock(CodeBlock.of("$T", secureRandomClass), Optional.empty())));
         addStatement(tryBuilder, makeAssignThisBlock("ivParameterSpec", makeNewBlock(CodeBlock.of("$T", ClassName.get("javax.crypto.spec", "IvParameterSpec")), Optional.of(makeInvokeCodeBlock(CodeBlock.of("$L", "secureRandom"), "generateSeed", Optional.of(CodeBlock.of("16")))))));
-        addStatement(tryBuilder, makeAssignBlock(ClassName.get("javax.crypto", "KeyGenerator"),"keyGenerator", makeInvokeCodeBlock(CodeBlock.of("$L", "KeyGenerator"), "getInstance", Optional.of(CodeBlock.of("\"AES\"")))));
-        addStatement(tryBuilder, makeInvokeCodeBlock(CodeBlock.of("$L","keyGenerator"), "init", Optional.of(CodeBlock.of("128"))));
+        addStatement(tryBuilder, makeAssignBlock(ClassName.get("javax.crypto", "KeyGenerator"),"keyGenerator", makeInvokeCodeBlock(CodeBlock.of("$L", "KeyGenerator"), "getInstance", Optional.of(CodeBlock.of("\"$L\"", input.algorithm())))));
+        addStatement(tryBuilder, makeInvokeCodeBlock(CodeBlock.of("$L","keyGenerator"), "init", Optional.of(CodeBlock.of("$L", String.valueOf(input.keySize())))));
         addStatement(tryBuilder, makeAssignThisBlock("secretKey", makeInvokeCodeBlock(CodeBlock.of("$L", "keyGenerator"), "generateKey", Optional.empty())));
         //This line may have bugs because of $L
-        addStatement(tryBuilder, makeAssignThisBlock( "algorithms", CodeBlock.of("\"AES/CBC/PKCS5Padding\"")));
+        addStatement(tryBuilder, makeAssignThisBlock( "algorithms", CodeBlock.of("\"$L/$L/$L\"", input.algorithm(), input.blockMode(), input.paddingMode())));
         addStatement(tryBuilder, makeAssignThisBlock("cipher", makeInvokeCodeBlock(CodeBlock.of("$L", "Cipher"), "getInstance", Optional.of(CodeBlock.of("algorithms")))));
 
 
diff --git a/java/dagger/internal/codegen/SymEncPara.java b/java/dagger/internal/codegen/SymEncPara.java
index a37cf7692..e269a8f88 100644
--- a/java/dagger/internal/codegen/SymEncPara.java
+++ b/java/dagger/internal/codegen/SymEncPara.java
@@ -14,12 +14,28 @@ static Builder builder(){
 
     abstract String className();
 
+    abstract String algorithm();
+
+    abstract String blockMode();
+
+    abstract String paddingMode();
+
+    abstract int keySize();
+
     @AutoValue.Builder
     abstract static class Builder{
         abstract Builder setTypeElement(TypeElement typeElement);
 
         abstract Builder setClassName(String className);
 
+        abstract Builder setAlgorithm(String algorithm);
+
+        abstract Builder setBlockMode(String blockMode);
+
+        abstract Builder setPaddingMode(String paddingMode);
+
+        abstract Builder setKeySize(int keySize);
+
         abstract SymEncPara build();
     }
 }
diff --git a/java/dagger/internal/codegen/SymEncProssingStep.java b/java/dagger/internal/codegen/SymEncProssingStep.java
index 8978d288f..c8339cffe 100644
--- a/java/dagger/internal/codegen/SymEncProssingStep.java
+++ b/java/dagger/internal/codegen/SymEncProssingStep.java
@@ -1,15 +1,18 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.squareup.javapoet.ClassName;
+import dagger.EncryptConstant;
 import dagger.SymEncrypt;
 
 import javax.annotation.processing.Messager;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.*;
 import java.lang.annotation.Annotation;
+import java.util.Map;
 import java.util.Set;
 
 import static javax.lang.model.util.ElementFilter.typesIn;
@@ -17,10 +20,12 @@
 public class SymEncProssingStep implements BasicAnnotationProcessor.ProcessingStep  {
 
     SymEncGenerator generator;
+    SymEncValidator validator;
     Messager messager;
 
-    public SymEncProssingStep(SymEncGenerator generator, Messager messager) {
+    public SymEncProssingStep(SymEncGenerator generator, SymEncValidator validator, Messager messager) {
         this.generator = generator;
+        this.validator = validator;
         this.messager = messager;
     }
 
@@ -29,13 +34,37 @@ public SymEncProssingStep(SymEncGenerator generator, Messager messager) {
         return ImmutableSet.of(SymEncrypt.class);
     }
 
+    //TODO find place to add validator
     @Override
     public Set<? extends Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
 
         for(TypeElement typeElement: typesIn(elementsByAnnotation.values())){
             try{
-                SymEncPara para = SymEncPara.builder().setClassName(ClassName.get(typeElement).simpleName()).setTypeElement(typeElement).build();
-                generator.generate(para);
+                ValidationReport<TypeElement> report = validator.validateAnnotationParameter(typeElement);
+                report.printMessagesTo(messager);
+                if(report.isClean()){
+                    Optional<AnnotationMirror> mirror = MoreElements.getAnnotationMirror(typeElement, SymEncrypt.class);
+                    if(mirror.isPresent()){
+                        SymEncPara.Builder paraBuilder = SymEncPara.builder().setClassName(ClassName.get(typeElement).simpleName()).setTypeElement(typeElement)
+                                .setAlgorithm(EncryptConstant.AES).setBlockMode(EncryptConstant.CBC).setPaddingMode(EncryptConstant.PKCS5PADDING).setKeySize(EncryptConstant.KEYSIZE);
+
+                        for(Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : mirror.get().getElementValues().entrySet()){
+                            Name elementName = entry.getKey().getSimpleName();
+                            if(elementName.contentEquals("algorithm")){
+                                paraBuilder = paraBuilder.setAlgorithm((String)(entry.getValue().getValue()));
+                            }else if(elementName.contentEquals("blockMode")){
+                                paraBuilder = paraBuilder.setBlockMode((String)(entry.getValue().getValue()));
+                            }else if(elementName.contentEquals("paddingMode")){
+                                paraBuilder = paraBuilder.setPaddingMode((String)(entry.getValue().getValue()));
+                            }else if(elementName.contentEquals("keySize")){
+                                paraBuilder = paraBuilder.setKeySize((Integer)(entry.getValue().getValue()));
+                            }else{
+                                //TODO deal with this error
+                            }
+                        }
+                        generator.generate(paraBuilder.build());
+                    }
+                }
             }catch(SourceFileGenerationException e){
                 e.printMessageTo(messager);
             }
diff --git a/java/dagger/internal/codegen/SymEncValidator.java b/java/dagger/internal/codegen/SymEncValidator.java
new file mode 100644
index 000000000..63b79d6b9
--- /dev/null
+++ b/java/dagger/internal/codegen/SymEncValidator.java
@@ -0,0 +1,80 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import dagger.EncryptConstant;
+import dagger.SymEncrypt;
+
+import javax.lang.model.element.*;
+import javax.lang.model.util.Types;
+import java.util.Map;
+
+/**
+ * this class may need refactor but not now
+ */
+public class SymEncValidator {
+    private final DaggerElements elements;
+    private final Types types;
+
+    private ImmutableSet<String> algorithmSet;
+    private ImmutableSet<String> blockModeSet;
+    private ImmutableSet<String> paddingModeSet;
+    private ImmutableSet<Integer> keySizeSet;
+
+
+    static final String NO_SUCH_PAPR = "no such parameter %s for %s";
+    static final String INSECURE_BLOCK_MODE = "in secure block mode ECB for encryption, please use CBC instead";
+
+    public SymEncValidator(DaggerElements elements, Types types) {
+        this.elements = elements;
+        this.types = types;
+        this.algorithmSet = ImmutableSet.<String>builder().add(EncryptConstant.AES).add(EncryptConstant.DES).build();
+        this.blockModeSet = ImmutableSet.<String>builder().add(EncryptConstant.CBC).add(EncryptConstant.ECB).build();
+        this.paddingModeSet = ImmutableSet.<String>builder().add(EncryptConstant.PKCS5PADDING).build();
+        this.keySizeSet = ImmutableSet.<Integer>builder().add(32).add(64).add(128).build();
+    }
+
+    //This function is a little long, how to simplify it ?
+    public ValidationReport<TypeElement> validateAnnotationParameter(TypeElement typeElement){
+        ValidationReport.Builder<TypeElement> builder = ValidationReport.about(typeElement);
+        Optional<AnnotationMirror> annotationMirror = MoreElements.getAnnotationMirror(typeElement, SymEncrypt.class);
+        if(annotationMirror.isPresent()){
+            for(Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationMirror.get().getElementValues().entrySet()){
+                Name elementName = entry.getKey().getSimpleName();
+                if(elementName.contentEquals("algorithm")){
+                    String value = (String)(entry.getValue().getValue());
+                    if(!algorithmSet.contains(value)){
+                        builder.addError(String.format(NO_SUCH_PAPR, value, "algorithm"), typeElement);
+                    }else{
+                        //Other error are not specified yet
+                    }
+                }else if(elementName.contentEquals("blockMode")){
+                   String value = (String)(entry.getValue().getValue());
+                   if(!blockModeSet.contains(value)){
+                       builder.addError(String.format(NO_SUCH_PAPR, value, "block mode"), typeElement);
+                   }else{
+                       if(value.equals(EncryptConstant.ECB)){
+                           builder.addError(INSECURE_BLOCK_MODE, typeElement);
+                       }
+                   }
+                }else if(elementName.contentEquals("paddingMode")){
+                    String value = (String)(entry.getValue().getValue());
+                    if(!paddingModeSet.contains(value)){
+                        builder.addError(String.format(NO_SUCH_PAPR, value, "paddingMode"), typeElement);
+                    }
+                }else if(elementName.contentEquals("keySize")){
+                    Integer keySize = (Integer)(entry.getValue().getValue());
+                    if(!keySizeSet.contains(keySize)){
+                        builder.addError(String.format(NO_SUCH_PAPR, String.valueOf(keySize), "keySize"), typeElement);
+                    }
+                }else{
+                    //TODO deal with this error
+                }
+            }
+        }
+        return builder.build();
+    }
+
+
+}
