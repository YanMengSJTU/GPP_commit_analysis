diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
index 5f8650be5..d25f233a3 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -35,6 +35,9 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.sun.tools.javac.code.Symbol;
+import com.sun.tools.javac.code.Type;
+
 import dagger.Binds;
 import dagger.BindsOptionalOf;
 import dagger.model.Key;
@@ -253,18 +256,31 @@ private Key forMethod(ExecutableElement method, TypeMirror keyType) {
   }
 
   Key forInjectConstructorWithResolvedType(TypeMirror type) {
+    ensureTypeIsCompleted(type);
     return Key.builder(type).build();
   }
 
   // TODO(ronshapiro): Remove these conveniences which are simple wrappers around Key.Builder
   Key forType(TypeMirror type) {
+    ensureTypeIsCompleted(type);
     return Key.builder(type).build();
   }
 
   Key forMembersInjectedType(TypeMirror type) {
+    ensureTypeIsCompleted(type);
     return Key.builder(type).build();
   }
 
+  private void ensureTypeIsCompleted(TypeMirror type) {
+    if (type instanceof Type.ClassType) {
+      Type.ClassType classType = (Type.ClassType) type;
+      Symbol.TypeSymbol typeSymbol = classType.asElement();
+      if (typeSymbol.completer != null) {
+        typeSymbol.complete();
+      }
+    }
+  }
+
   Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
     return Key.builder(boxPrimitives(type)).qualifier(qualifier).build();
   }
