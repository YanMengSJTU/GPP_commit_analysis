diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 1b8db0235..fc27afae5 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -46,6 +46,8 @@
   private final BindingGraph graph;
   private final DaggerTypes types;
   private final BindingExpressionFactory bindingExpressionFactory;
+  // TODO(user): Switch to Table<BindingKey, DependencyRequest.Kind, BindingExpression>, and give
+  // each BindingKey, DependencyRequest.Kind pair its own instance of BindingExpression.
   private final Map<BindingKey, BindingExpression> bindingExpressionsMap = new HashMap<>();
 
   ComponentBindingExpressions(
@@ -311,6 +313,7 @@ private BindingExpression provisionBindingExpression(
         return new PrivateMethodBindingExpression(
             resolvedBindings,
             generatedComponentModel,
+            componentBindingExpressions,
             inlineBindingExpression,
             referenceReleasingManagerFields,
             compilerOptions,
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 367ff063c..b52889bb3 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -31,6 +31,7 @@
 
 /** A binding expression that uses an instance of a {@link FrameworkType}. */
 final class FrameworkInstanceBindingExpression extends BindingExpression {
+  private final ComponentBindingExpressions componentBindingExpressions;
   private final Supplier<MemberSelect> frameworkFieldSupplier;
   private final FrameworkType frameworkType;
   private final DaggerTypes types;
@@ -75,6 +76,7 @@ static FrameworkInstanceBindingExpression create(
 
     return new FrameworkInstanceBindingExpression(
         resolvedBindings,
+        componentBindingExpressions,
         isProducerFromProvider ? FrameworkType.PRODUCER : frameworkType,
         frameworkFieldSupplier,
         types,
@@ -83,11 +85,13 @@ static FrameworkInstanceBindingExpression create(
 
   private FrameworkInstanceBindingExpression(
       ResolvedBindings resolvedBindings,
+      ComponentBindingExpressions componentBindingExpressions,
       FrameworkType frameworkType,
       Supplier<MemberSelect> frameworkFieldSupplier,
       DaggerTypes types,
       Elements elements) {
     super(resolvedBindings);
+    this.componentBindingExpressions = componentBindingExpressions;
     this.frameworkType = frameworkType;
     this.frameworkFieldSupplier = frameworkFieldSupplier;
     this.types = types;
@@ -103,20 +107,41 @@ private FrameworkInstanceBindingExpression(
   @Override
   Expression getDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
-    MemberSelect memberSelect = frameworkFieldSupplier.get();
-
-    TypeMirror expressionType =
-        isTypeAccessibleFrom(instanceType(), requestingClass.packageName())
-                || isInlinedFactoryCreation(memberSelect)
-            ? types.wrapType(instanceType(), resolvedBindings().frameworkClass())
-            : rawFrameworkType();
+    if (requestKind.equals(frameworkRequestKind())) {
+      MemberSelect memberSelect = frameworkFieldSupplier.get();
+      TypeMirror expressionType =
+          isTypeAccessibleFrom(instanceType(), requestingClass.packageName())
+                  || isInlinedFactoryCreation(memberSelect)
+              ? types.wrapType(instanceType(), resolvedBindings().frameworkClass())
+              : rawFrameworkType();
+      return Expression.create(expressionType, memberSelect.getExpressionFor(requestingClass));
+    }
 
+    // The following expressions form a composite with the expression for the framework type.
+    // For example, the expression for a DependencyRequest.Kind.LAZY is a composite of the
+    // expression for a DependencyRequest.Kind.PROVIDER (the framework type):
+    //    lazyExpression = DoubleCheck.lazy(providerExpression);
     return frameworkType.to(
         requestKind,
-        Expression.create(expressionType, memberSelect.getExpressionFor(requestingClass)),
+        componentBindingExpressions.getDependencyExpression(
+            resolvedBindings().bindingKey(), frameworkRequestKind(), requestingClass),
         types);
   }
 
+  /** Returns the request kind that matches the framework type. */
+  private DependencyRequest.Kind frameworkRequestKind() {
+    switch (frameworkType) {
+      case PROVIDER:
+        return DependencyRequest.Kind.PROVIDER;
+      case PRODUCER:
+        return DependencyRequest.Kind.PRODUCER;
+      case MEMBERS_INJECTOR:
+        return DependencyRequest.Kind.MEMBERS_INJECTOR;
+      default:
+        throw new AssertionError();
+    }
+  }
+
   /**
    * The instance type {@code T} of this {@code FrameworkType<T>}. For {@link
    * MembersInjectionBinding}s, this is the {@linkplain Key#type() key type}; for {@link
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 625a82ee1..705422e04 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -52,6 +52,7 @@
  */
 final class PrivateMethodBindingExpression extends BindingExpression {
   private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentBindingExpressions componentBindingExpressions;
   private final BindingExpression delegate;
   private final Map<DependencyRequest.Kind, String> methodNames =
       new EnumMap<>(DependencyRequest.Kind.class);
@@ -66,6 +67,7 @@
   PrivateMethodBindingExpression(
       ResolvedBindings resolvedBindings,
       GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions,
       BindingExpression delegate,
       ReferenceReleasingManagerFields referenceReleasingManagerFields,
       CompilerOptions compilerOptions,
@@ -73,6 +75,7 @@
       Elements elements) {
     super(resolvedBindings);
     this.generatedComponentModel = generatedComponentModel;
+    this.componentBindingExpressions = componentBindingExpressions;
     this.delegate = delegate;
     binding = resolvedBindings.contributionBinding();
     this.referenceReleasingManagerFields = referenceReleasingManagerFields;
@@ -138,6 +141,7 @@ private boolean ignorePrivateMethodStrategy(DependencyRequest.Kind requestKind)
       case LAZY:
       case PROVIDER_OF_LAZY:
         return !compilerOptions.experimentalAndroidMode()
+            || (binding.scope().isPresent() && !canInlineScope())
             || binding.factoryCreationStrategy().equals(SINGLETON_INSTANCE);
       default:
         return !compilerOptions.experimentalAndroidMode();
@@ -209,15 +213,6 @@ private CodeBlock methodBody(DependencyRequest.Kind requestKind) {
       case PROVIDER:
         // TODO(user): Cache provider field instead of recreating each time.
         return CodeBlock.of("return $L;", providerTypeSpec());
-      case LAZY:
-      case PROVIDER_OF_LAZY:
-        // TODO(user): Refactor the delegate BindingExpression to handle these cases?
-        // Don't use delegate.getDependencyExpression() because that will inline the provider
-        // dependency instead of delegating to the private method. To use the private method,
-        // recursively call this.getDependencyExpression().
-        CodeBlock asProvider =
-            getDependencyExpression(DependencyRequest.Kind.PROVIDER, componentName()).codeBlock();
-        return CodeBlock.of("return $L;", FrameworkType.PROVIDER.to(requestKind, asProvider));
       case INSTANCE:
         if (canInlineScope()) {
           Scope scope = resolvedBindings().scope().get();
@@ -225,13 +220,10 @@ private CodeBlock methodBody(DependencyRequest.Kind requestKind) {
               ? singleCheck(requestKind) : doubleCheck(requestKind);
         }
         // fall through
-      case PRODUCER:
-      case FUTURE:
+      default:
         return CodeBlock.of(
             "return $L;",
             delegate.getDependencyExpression(requestKind, componentName()).codeBlock());
-      default:
-        throw new AssertionError("Unhandled DependencyRequest: " + requestKind);
     }
   }
 
@@ -295,7 +287,11 @@ private TypeSpec providerTypeSpec() {
                 .returns(TypeName.get(accessibleType(binding.contributedType())))
                 .addStatement(
                     "return $L",
-                    getDependencyExpression(DependencyRequest.Kind.INSTANCE, componentName())
+                    componentBindingExpressions
+                        .getDependencyExpression(
+                            resolvedBindings().bindingKey(),
+                            DependencyRequest.Kind.INSTANCE,
+                            componentName())
                         .codeBlock())
                 .build())
         .build();
