diff --git a/multibindings.md b/multibindings.md
index dd6f6e227..915a557e8 100644
--- a/multibindings.md
+++ b/multibindings.md
@@ -28,7 +28,7 @@ to a module that returns an element and is annotated with
 @Module
 class MyModuleA {
   @Provides(type = SET)
-  String provideOneString(DepA depA, DepB depB) {
+  static String provideOneString(DepA depA, DepB depB) {
     return "ABC";
   }
 }
@@ -41,7 +41,7 @@ that returns a subset and is annotated with [`@Provides(type = SET_VALUES)`]:
 @Module
 class MyModuleB {
   @Provides(type = SET_VALUES)
-  Set<String> provideSomeStrings(DepA depA, DepB depB) {
+  static Set<String> provideSomeStrings(DepA depA, DepB depB) {
     return new HashSet<Foo>(Arrays.asList("DEF", "GHI"));
   }
 }
@@ -55,7 +55,7 @@ depending on that set is an error. If you want to allow an empty set, then add a
 @Module
 class MyEmptySetModule {
   @Provides(type = SET_VALUES)
-  Set<Foo> primeEmptyFooSet() {
+  static Set<Foo> primeEmptyFooSet() {
     return Collections.emptySet();
   }
 }
@@ -99,7 +99,7 @@ with the qualifier:
 class MyModuleC {
   @Provides(type = SET)
   @MyQualifier
-  Foo provideOneFoo(DepA depA, DepB depB) {
+  static Foo provideOneFoo(DepA depA, DepB depB) {
     return new Foo(depA, depB);
   }
 }
@@ -107,7 +107,7 @@ class MyModuleC {
 @Module
 class MyModuleD {
   @Provides
-  FooSetUser provideFooSetUser(@MyQualifier Set<Foo> foos) { … }
+  static FooSetUser provideFooSetUser(@MyQualifier Set<Foo> foos) { … }
 }
 ```
 
@@ -138,13 +138,13 @@ the standard annotations in [`dagger.mapkeys`]:
 class MyModule {
   @Provides(type = MAP)
   @StringKey("foo")
-  Long provideFooValue() {
+  static Long provideFooValue() {
     return 100L;
   }
 
   @Provides(type = MAP)
   @ClassKey(Thing.class)
-  String provideThingValue() {
+  static String provideThingValue() {
     return "value for Thing";
   }
 }
@@ -186,13 +186,13 @@ enum MyEnum {
 class MyModule {
   @Provides(type = MAP)
   @MyEnumKey(MyEnum.ABC)
-  String provideABCValue() {
+  static String provideABCValue() {
     return "value for ABC";
   }
 
   @Provides(type = MAP)
   @MyNumberClassKey(BigDecimal.class)
-  String provideBigDecimalValue() {
+  static String provideBigDecimalValue() {
     return "value for BigDecimal";
   }
 }
@@ -233,7 +233,7 @@ well.
 class MyModule {
   @Provides(type = MAP)
   @MyKey(name = "abc", implementingClass = Abc.class, thresholds = {1, 5, 10})
-  String provideAbc1510Value() {
+  static String provideAbc1510Value() {
     return "foo";
   }
 }
@@ -280,14 +280,14 @@ transform into a non-multibound map.
 @Module
 class MyModule {
   @Provides(type = SET)
-  Map.Entry<Foo, Bar> entryOne(…) {
+  static Map.Entry<Foo, Bar> entryOne(…) {
     Foo key = …;
     Bar value = …;
     return new SimpleImmutableEntry(key, value);
   }
 
   @Provides(type = SET)
-  Map.Entry<Foo, Bar> entryTwo(…) {
+  static Map.Entry<Foo, Bar> entryTwo(…) {
     Foo key = …;
     Bar value = …;
     return new SimpleImmutableEntry(key, value);
@@ -297,7 +297,7 @@ class MyModule {
 @Module
 class MyMapModule {
   @Provides
-  Map<Foo, Bar> fooBarMap(Set<Map.Entry<Foo, Bar>> entries) {
+  static Map<Foo, Bar> fooBarMap(Set<Map.Entry<Foo, Bar>> entries) {
     Map<Foo, Bar> fooBarMap = new LinkedHashMap<>(entries.size());
     for (Map.Entry<Foo, Bar> entry : entries) {
       fooBarMap.put(entry.getKey(), entry.getValue());
@@ -316,7 +316,8 @@ your non-multibound map can have `Provider` values.
 @Module
 class MyModule {
   @Provides(type = SET)
-  Map.Entry<Foo, Provider<Bar>> entry(Provider<BarSubclass> barSubclassProvider) {
+  static Map.Entry<Foo, Provider<Bar>> entry(
+      Provider<BarSubclass> barSubclassProvider) {
     Foo key = …;
     return new SimpleImmutableEntry(key, barSubclassProvider);
   }
@@ -325,7 +326,8 @@ class MyModule {
 @Module
 class MyProviderMapModule {
   @Provides
-  Map<Foo, Provider<Bar>> fooBarProviderMap(Set<Map.Entry<Foo, Provider<Bar>>> entries) {
+  static Map<Foo, Provider<Bar>> fooBarProviderMap(
+      Set<Map.Entry<Foo, Provider<Bar>>> entries) {
     return …;
   }
 }
@@ -357,24 +359,24 @@ interface ParentComponent {
 @Module
 class ParentModule {
   @Provides(type = SET)
-  String string1() {
+  static String string1() {
     "parent string 1";
   }
 
   @Provides(type = SET)
-  String string2() {
+  static String string2() {
     "parent string 2";
   }
 
   @Provides(type = MAP)
   @StringKey("a")
-  String stringA() {
+  static String stringA() {
     "parent string A";
   }
 
   @Provides(type = MAP)
   @StringKey("b")
-  String stringB() {
+  static String stringB() {
     "parent string B";
   }
 }
@@ -388,24 +390,24 @@ interface ChildComponent {
 @Module
 class ChildModule {
   @Provides(type = SET)
-  String string3() {
+  static String string3() {
     "child string 3";
   }
 
   @Provides(type = SET)
-  String string4() {
+  static String string4() {
     "child string 4";
   }
 
   @Provides(type = MAP)
   @StringKey("c")
-  String stringC() {
+  static String stringC() {
     "child string C";
   }
 
   @Provides(type = MAP)
   @StringKey("d")
-  String stringD() {
+  static String stringD() {
     "child string D";
   }
 }
diff --git a/producers.md b/producers.md
index a40e4abda..eb0eee1f6 100644
--- a/producers.md
+++ b/producers.md
@@ -30,12 +30,14 @@ Here is a simple example that mimics a server’s request-handling flow:
 ```java
 @ProducerModule(includes = UserModule.class)
 final class UserResponseModule {
-  @Produces ListenableFuture<UserData> lookUpUserData(
+  @Produces
+  static ListenableFuture<UserData> lookUpUserData(
       User user, UserDataStub stub) {
     return stub.lookUpData(user);
   }
 
-  @Produces Html renderHtml(UserData data, UserHtmlTemplate template) {
+  @Produces
+  static Html renderHtml(UserData data, UserHtmlTemplate template) {
     return template.render(data);
   }
 }
@@ -92,7 +94,8 @@ If a producer method would like to “catch” that exception, the method can
 request a [Produced&lt;T>][Produced] instead of a T. For example:
 
 ```java
-@Produces Html renderHtml(
+@Produces
+static Html renderHtml(
     Produced<UserData> data,
     UserHtmlTemplate template,
     ErrorHtmlTemplate errorTemplate) {
@@ -121,7 +124,8 @@ method returns a `ListenableFuture`, which can then be fed to the framework. For
 example:
 
 ```java
-@Produces ListenableFuture<UserData> lookUpUserData(
+@Produces
+static ListenableFuture<UserData> lookUpUserData(
     Flags flags,
     @Standard Producer<UserData> standardUserData,
     @Experimental Producer<UserData> experimentalUserData) {
@@ -144,12 +148,12 @@ in [ordinary Dagger](multibindings). For example:
 ```java
 @ProducerModule
 final class UserDataModule {
-  @Produces(type = SET) ListenableFuture<Data> standardData(…) { … }
-  @Produces(type = SET) ListenableFuture<Data> extraData(…) { … }
-  @Produces(type = SET) Data synchronousData(…) { … }
-  @Produces(type = SET_VALUES) Set<ListenableFuture<Data>> rest(…) { … }
+  @Produces(type = SET) static ListenableFuture<Data> standardData(…) { … }
+  @Produces(type = SET) static ListenableFuture<Data> extraData(…) { … }
+  @Produces(type = SET) static Data synchronousData(…) { … }
+  @Produces(type = SET_VALUES) static Set<ListenableFuture<Data>> rest(…) { … }
 
-  @Produces … collect(Set<Data> data) { … }
+  @Produces static … collect(Set<Data> data) { … }
 }
 ```
 
@@ -167,12 +171,13 @@ Map multibindings are similar:
 @ProducerModule
 final class DispatchModule {
   @Produces(type = MAP) @DispatchPath("/user")
-  ListenableFuture<Html> dispatchUser(…) { … }
+  static ListenableFuture<Html> dispatchUser(…) { … }
 
   @Produces(type = MAP) @DispatchPath("/settings")
-  ListenableFuture<Html> dispatchSettings(…) { … }
+  static ListenableFuture<Html> dispatchSettings(…) { … }
 
-  @Produces ListenableFuture<Html> dispatch(
+  @Produces
+  static ListenableFuture<Html> dispatch(
       Map<DispatchPath, Producer<Html>> dispatchers, Url url) {
     return dispatchers.get(url.path()).get();
   }
@@ -202,7 +207,7 @@ interface RequestComponent {
 
 @ProducerModule
 final class UserDataModule {
-  @Produces ListenableFuture<UserData> userData(Request request, …) { … }
+  @Produces static ListenableFuture<UserData> userData(Request request, …) { … }
 }
 
 @ProductionComponent(
diff --git a/users-guide.md b/users-guide.md
index b15697ff3..bfb5276d3 100644
--- a/users-guide.md
+++ b/users-guide.md
@@ -115,7 +115,7 @@ return type defines which dependency it satisfies.
 For example, `provideHeater()` is invoked whenever a `Heater` is required:
 
 ```java
-@Provides Heater provideHeater() {
+@Provides static Heater provideHeater() {
   return new ElectricHeater();
 }
 ```
@@ -124,7 +124,7 @@ It's possible for `@Provides` methods to have dependencies of their own. This
 one returns a `Thermosiphon` whenever a `Pump` is required:
 
 ```java
-@Provides Pump providePump(Thermosiphon pump) {
+@Provides static Pump providePump(Thermosiphon pump) {
   return pump;
 }
 ```
@@ -135,17 +135,18 @@ have an [`@Module`][Module] annotation.
 ```java
 @Module
 class DripCoffeeModule {
-  @Provides Heater provideHeater() {
+  @Provides static Heater provideHeater() {
     return new ElectricHeater();
   }
 
-  @Provides Pump providePump(Thermosiphon pump) {
+  @Provides static Pump providePump(Thermosiphon pump) {
     return pump;
   }
 }
 ```
 
-By convention, `@Provides` methods are named with a `provide` prefix and module classes are named with a `Module` suffix.
+By convention, `@Provides` methods are named with a `provide` prefix and module
+classes are named with a `Module` suffix.
 
 ### Building the Graph
 
@@ -178,10 +179,12 @@ CoffeeShop coffeeShop = DaggerCoffeeShop.builder()
 ```
 
 Any module with an accessible default constructor can be elided as the builder
-will construct an instance automatically if none is set.  If all dependencies
-can be constructed in that manner, the generated implementation will also have a
-`create()` method that can be used to get a new instance without having to deal
-with the builder.
+will construct an instance automatically if none is set.  And for any module
+whose `@Provides` methods are all static, the implementation doesn't need an
+instance at all.  If all dependencies can be constructed without the user
+creating a dependency instance, then the generated implementation will also
+have a `create()` method that can be used to get a new instance without having
+to deal with the builder.
 
 ```java
 CoffeeShop coffeeShop = DaggerCoffeeShop.create();
@@ -216,7 +219,7 @@ Annotate an `@Provides` method or injectable class with
 all of its clients.
 
 ```java
-@Provides @Singleton Heater provideHeater() {
+@Provides @Singleton static Heater provideHeater() {
   return new ElectricHeater();
 }
 ```
@@ -341,11 +344,11 @@ class ExpensiveCoffeeMaker {
 Supply qualified values by annotating the corresponding `@Provides` method.
 
 ```java
-@Provides @Named("hot plate") Heater provideHotPlateHeater() {
+@Provides @Named("hot plate") static Heater provideHotPlateHeater() {
   return new ElectricHeater(70);
 }
 
-@Provides @Named("water") Heater provideWaterHeater() {
+@Provides @Named("water") static Heater provideWaterHeater() {
   return new ElectricHeater(93);
 }
 ```
@@ -363,7 +366,7 @@ missing a binding for `Executor`:
 ```java
 @Module
 class DripCoffeeModule {
-  @Provides Heater provideHeater(Executor executor) {
+  @Provides static Heater provideHeater(Executor executor) {
     return new CpuHeater(executor);
   }
 }
