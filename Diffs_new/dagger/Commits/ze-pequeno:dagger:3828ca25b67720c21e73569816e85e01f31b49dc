diff --git a/java/dagger/internal/codegen/AndroidModeBindingMethodImplementation.java b/java/dagger/internal/codegen/AndroidModeBindingMethodImplementation.java
index ec9a5cca3..9283a3e17 100644
--- a/java/dagger/internal/codegen/AndroidModeBindingMethodImplementation.java
+++ b/java/dagger/internal/codegen/AndroidModeBindingMethodImplementation.java
@@ -19,7 +19,9 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.CodeBlocks.anonymousProvider;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
+import static dagger.internal.codegen.DelegateBindingExpression.isBindsScopeStrongerThanDependencyScope;
 import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
+import static dagger.model.BindingKind.DELEGATE;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.VOLATILE;
 
@@ -40,6 +42,7 @@
  * which optionally inlines provider and locking optimizations.
  */
 final class AndroidModeBindingMethodImplementation extends BindingMethodImplementation {
+  private final BindingGraph graph;
   private final GeneratedComponentModel generatedComponentModel;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final BindingExpression bindingExpression;
@@ -52,10 +55,12 @@
       BindingExpression bindingExpression,
       DaggerTypes types,
       Elements elements,
+      BindingGraph graph,
       GeneratedComponentModel generatedComponentModel,
       ComponentBindingExpressions componentBindingExpressions,
       ReferenceReleasingManagerFields referenceReleasingManagerFields) {
     super(bindingExpression, generatedComponentModel.name(), types, elements);
+    this.graph = graph;
     this.generatedComponentModel = generatedComponentModel;
     this.componentName = generatedComponentModel.name();
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
@@ -104,8 +109,15 @@ private boolean shouldInlineProvider() {
   }
 
   private boolean shouldInlineScope(Scope scope) {
-    // TODO(user): enable for releasable references.
-    return !referenceReleasingManagerFields.requiresReleasableReferences(scope);
+    if (referenceReleasingManagerFields.requiresReleasableReferences(scope)) {
+      // TODO(user): enable for releasable references.
+      return false;
+    } else if (binding.kind().equals(DELEGATE)) {
+      // Only scope a delegate binding if its scope is stronger than its dependency's scope.
+      return isBindsScopeStrongerThanDependencyScope(resolvedBindings(), graph);
+    } else {
+      return true;
+    }
   }
 
   private CodeBlock singleCheck() {
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index d477b021e..5cbc8ce04 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -257,7 +257,7 @@ private BindingExpression getBindingExpression(Key key, RequestKind requestKind)
     // TODO(user): Consider using PrivateMethodBindingExpression for other/all BEs?
     private static final ImmutableSet<BindingKind> PRIVATE_METHOD_KINDS =
         ImmutableSet.copyOf(
-            EnumSet.of(MULTIBOUND_SET, MULTIBOUND_MAP, INJECTION, PROVISION));
+            EnumSet.of(MULTIBOUND_SET, MULTIBOUND_MAP, INJECTION, PROVISION, DELEGATE));
 
     private final BindingGraph graph;
     private final GeneratedComponentModel generatedComponentModel;
@@ -497,7 +497,7 @@ private BindingExpression provisionBindingExpression(
             componentBindingExpressions);
       }
 
-      if (shouldUsePrivateMethod(resolvedBindings.contributionBinding(), requestKind)) {
+      if (shouldUsePrivateMethod(resolvedBindings, requestKind)) {
         return new PrivateMethodBindingExpression(
             resolvedBindings,
             requestKind,
@@ -514,6 +514,7 @@ private BindingMethodImplementation methodImplementation(BindingExpression bindi
               bindingExpression,
               types,
               elements,
+              graph,
               generatedComponentModel,
               componentBindingExpressions,
               referenceReleasingManagerFields)
@@ -531,21 +532,23 @@ private BindingMethodImplementation methodImplementation(BindingExpression bindi
      * <p>In Android mode, private methods are used for all provision bindings unless the request:
      *
      * <ul>
-     *   <li>has releasable reference scope; TODO(user): enable for releasable reference scope
+     *   <li>is a delegate binding with a scope that is not stronger than its dependency scope,
+     *   <li>has releasable reference scope; TODO(user): enable for releasable reference scope,
      *   <li>is for an unscoped framework type (Provider, Lazy, ProviderOfLazy) that can use the
-     *       singleton instance of the factory class.
+     *       singleton instance of the factory class,
      *   <li>is for an unscoped non-framework type that has no dependencies, which means users can
      *       call a nullary method anyway.
      * </ul>
      */
-    private boolean shouldUsePrivateMethod(ContributionBinding binding, RequestKind requestKind) {
-      // TODO(user): enable for releasable references.
-      Optional<Scope> releasableReferenceScope =
-          binding.scope().filter(referenceReleasingManagerFields::requiresReleasableReferences);
-      if (!PRIVATE_METHOD_KINDS.contains(binding.kind()) || releasableReferenceScope.isPresent()) {
+    private boolean shouldUsePrivateMethod(
+        ResolvedBindings resolvedBindings, RequestKind requestKind) {
+      ContributionBinding binding = resolvedBindings.contributionBinding();
+      if (!PRIVATE_METHOD_KINDS.contains(binding.kind())
+          || (binding.kind().equals(DELEGATE)
+              && !isBindsScopeStrongerThanDependencyScope(resolvedBindings, graph))) {
         return false;
       }
-      if (compilerOptions.experimentalAndroidMode()) {
+      if (useExperimentalAndroidMode(binding)) {
         switch (requestKind) {
           case PROVIDER:
           case LAZY:
@@ -614,11 +617,11 @@ private FrameworkInstanceBindingExpression producerFromProviderInstanceBindingEx
      */
     private BindingExpression basicProvisionBindingExpression(
         ResolvedBindings resolvedBindings, RequestKind requestKind) {
-      if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
-          && !isBindsScopeStrongerThanDependencyScope(resolvedBindings, graph)) {
+      if (shouldUseDelegateBindingExpression(resolvedBindings)) {
         return new DelegateBindingExpression(
             resolvedBindings, requestKind, componentBindingExpressions, types, elements);
       }
+
       switch (requestKind) {
         case PRODUCER:
           return producerFromProviderInstanceBindingExpression(resolvedBindings, requestKind);
@@ -705,18 +708,39 @@ private BindingExpression instanceOrFutureBindingExpression(
       return frameworkInstanceBindingExpression(resolvedBindings, requestKind);
     }
 
+    private boolean shouldUseDelegateBindingExpression(ResolvedBindings resolvedBindings) {
+      if (!resolvedBindings.contributionBinding().kind().equals(DELEGATE)) {
+        return false;
+      }
+      if (useExperimentalAndroidMode(resolvedBindings.contributionBinding())) {
+        // In Android mode, we should always use the delegate binding expression.
+        return true;
+      } else {
+        // In default mode, we should only use delegate binding expressions if
+        // bindsScope <= dependencyScope.
+        return !isBindsScopeStrongerThanDependencyScope(resolvedBindings, graph);
+      }
+    }
+
     private boolean canCallSimpleMethod(ResolvedBindings resolvedBindings) {
-      Optional<Scope> scope = resolvedBindings.contributionBinding().scope();
-      if (compilerOptions.experimentalAndroidMode()) {
-        // In Android mode we can call simple methods unless the scope is a releasable-references
-        // scope.
-        // TODO(user): Also inline releasable references in experimentalAndroidMode
-        return !scope.isPresent()
-            || !referenceReleasingManagerFields.requiresReleasableReferences(scope.get());
+      Binding binding = resolvedBindings.contributionBinding();
+      if (useExperimentalAndroidMode(binding)) {
+        // In Android mode, always call simple methods.
+        return true;
       } else {
         // In default mode, we can call simple methods unless the binding is scoped.
-        return !scope.isPresent();
+        return !binding.scope().isPresent();
       }
     }
+
+    // TODO(user): Enable releasable references in experimentalAndroidMode
+    private boolean useExperimentalAndroidMode(Binding binding) {
+      return compilerOptions.experimentalAndroidMode() && !usesReleasableReferences(binding);
+    }
+
+    private boolean usesReleasableReferences(Binding binding) {
+      return binding.scope().isPresent()
+          && referenceReleasingManagerFields.requiresReleasableReferences(binding.scope().get());
+    }
   }
 }
diff --git a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
index f901df2c1..4ba6f0d65 100644
--- a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
@@ -198,23 +198,10 @@ public void toDoubleCheck() {
                     "    }",
                     "    return (ReusableScoped) reusableScoped;",
                     "  }",
-                    "",
-                    "  private Provider<ReusableScoped> getReusableScopedProvider() {",
-                    "    return new Provider<ReusableScoped>() {",
-                    "      @Override",
-                    "      public ReusableScoped get() {",
-                    "        return getReusableScoped();",
-                    "      }",
-                    "    };",
-                    "  }",
                     "")
                 .addLines(
                     "  @SuppressWarnings(\"unchecked\")",
                     "  private void initialize(final Builder builder) {")
-                .addLinesIn(
-                    EXPERIMENTAL_ANDROID_MODE,
-                    "    this.reusableProvider = DoubleCheck.provider(",
-                    "        (Provider) getReusableScopedProvider());")
                 .addLinesIn(
                     DEFAULT_MODE,
                     "    this.regularScopedProvider = ",
@@ -226,11 +213,14 @@ public void toDoubleCheck() {
                 .addLines(
                     "    this.releasableScopedProvider = ",
                     "         ReferenceReleasingProvider.create(",
-                    "             ReleasableScoped_Factory.create(), customScopeReferences);",
+                    "             ReleasableScoped_Factory.create(), customScopeReferences);")
+                .addLinesIn(
+                    DEFAULT_MODE,
                     "    this.releasableProvider = DoubleCheck.provider(",
                     "        (Provider) releasableScopedProvider);",
                     "    this.unscopedProvider = DoubleCheck.provider(",
-                    "        (Provider) Unscoped_Factory.create());",
+                    "        (Provider) Unscoped_Factory.create());")
+                .addLines(
                     "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
                     "        new Provider<ReleasableReferenceManager>() {",
                     "          @Override",
@@ -313,11 +303,14 @@ public void toSingleCheck() {
                 .addLines(
                     "    this.releasableScopedProvider = ",
                     "         ReferenceReleasingProvider.create(",
-                    "             ReleasableScoped_Factory.create(), customScopeReferences);",
+                    "             ReleasableScoped_Factory.create(), customScopeReferences);")
+                .addLinesIn(
+                    DEFAULT_MODE,
                     "    this.releasableProvider = SingleCheck.provider(",
                     "        (Provider) releasableScopedProvider);",
                     "    this.unscopedProvider = SingleCheck.provider(",
-                    "        (Provider) Unscoped_Factory.create());",
+                    "        (Provider) Unscoped_Factory.create());")
+                .addLines(
                     "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
                     "        new Provider<ReleasableReferenceManager>() {",
                     "          @Override",
@@ -847,6 +840,115 @@ public void inlineFactoryOfInacessibleType() {
                 "}"));
   }
 
+  @Test
+  public void providerWhenBindsScopeGreaterThanDependencyScope() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Reusable;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Module",
+            "public abstract class TestModule {",
+            "  @Reusable",
+            "  @Provides",
+            "  static String provideString() {",
+            "    return \"\";",
+            "  }",
+            "",
+            "  @Binds",
+            "  @Singleton",
+            "  abstract Object bindString(String str);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "import javax.inject.Provider;",
+            "",
+            "@Singleton",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Provider<Object> getObject();",
+            "}");
+
+    Compilation compilation = daggerCompiler()
+        .withOptions(compilerMode.javacopts())
+        .compile(module, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .containsElementsIn(
+            compilerMode
+                .javaFileBuilder("test.DaggerTestComponent")
+                .addLines(
+                    "package test;",
+                    "",
+                    GENERATED_ANNOTATION,
+                    "public final class DaggerTestComponent implements TestComponent {")
+                .addLinesIn(
+                    DEFAULT_MODE,
+                    "  private Provider<String> provideStringProvider;",
+                    "  private Provider<Object> bindStringProvider;",
+                    "",
+                    "  @SuppressWarnings(\"unchecked\")",
+                    "  private void initialize(final Builder builder) {",
+                    "    this.provideStringProvider =",
+                    "        SingleCheck.provider(TestModule_ProvideStringFactory.create());",
+                    "    this.bindStringProvider =",
+                    "        DoubleCheck.provider((Provider) provideStringProvider);",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public Provider<Object> getObject() {",
+                    "    return bindStringProvider;",
+                    "  }",
+                    "}")
+                .addLinesIn(
+                    EXPERIMENTAL_ANDROID_MODE,
+                    "  private volatile Object object = new MemoizedSentinel();",
+                    "  private volatile Object string = new MemoizedSentinel();",
+                    "",
+                    "  private String getString() {",
+                    "    if (string instanceof MemoizedSentinel) {",
+                    "      string = TestModule_ProvideStringFactory.proxyProvideString();",
+                    "    }",
+                    "    return (String) string;",
+                    "  }",
+                    "",
+                    "  private Object getObject2() {",
+                    "    Object local = object;",
+                    "    if (local instanceof MemoizedSentinel) {",
+                    "      synchronized (local) {",
+                    "        if (local == object) {",
+                    "          object = getString();",
+                    "        }",
+                    "        local = object;",
+                    "      }",
+                    "    }",
+                    "    return (Object) local;",
+                    "  }",
+                    "",
+                    "  @Override",
+                    "  public Provider<Object> getObject() {",
+                    "    return new Provider<Object>() {",
+                    "      @Override",
+                    "      public Object get() {",
+                    "        return getObject2();",
+                    "      }",
+                    "    };",
+                    "  }")
+                .build());
+  }
+
   private CompilationSubject assertThatCompilationWithModule(JavaFileObject module) {
     Compilation compilation =
         daggerCompiler()
