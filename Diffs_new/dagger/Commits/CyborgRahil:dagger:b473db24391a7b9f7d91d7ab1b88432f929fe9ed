diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index 61af7159a..bac07d7b1 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -554,13 +554,8 @@ private void addInitializeMethods(
    * from the requirement the parameter fulfills to the spec for the parameter.
    */
   private final ImmutableMap<ComponentRequirement, ParameterSpec> initializationParameters() {
-    Optional<ComponentCreatorImplementation> creatorImplementation =
-        Optionals.firstPresent(
-            componentImplementation.creatorImplementation(),
-            componentImplementation.baseCreatorImplementation());
-
     Map<ComponentRequirement, ParameterSpec> parameters;
-    if (creatorImplementation.isPresent()) {
+    if (componentImplementation.componentDescriptor().hasCreator()) {
       parameters =
           Maps.toMap(componentImplementation.requirements(), ComponentRequirement::toParameterSpec);
     } else if (componentImplementation.isAbstract() && componentImplementation.isNested()) {
diff --git a/java/dagger/internal/codegen/ComponentRequirementExpressions.java b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
index 1b22b6cf7..779a7b5ff 100644
--- a/java/dagger/internal/codegen/ComponentRequirementExpressions.java
+++ b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
@@ -127,11 +127,7 @@ private ComponentRequirementExpression createMethodOrField(ComponentRequirement
 
   /** Returns a field for a {@link ComponentRequirement}. */
   private ComponentRequirementExpression createField(ComponentRequirement requirement) {
-    Optional<ComponentCreatorImplementation> creatorImplementation =
-        Optionals.firstPresent(
-            componentImplementation.baseImplementation().flatMap(c -> c.creatorImplementation()),
-            componentImplementation.creatorImplementation());
-    if (creatorImplementation.isPresent()) {
+    if (componentImplementation.componentDescriptor().hasCreator()) {
       return new ComponentParameterField(requirement, componentImplementation, Optional.empty());
     } else if (graph.factoryMethod().isPresent()
         && graph.factoryMethodParameters().containsKey(requirement)) {
diff --git a/javatests/dagger/functional/factory/AbstractModule.java b/javatests/dagger/functional/factory/AbstractModule.java
new file mode 100644
index 000000000..83a13d6ad
--- /dev/null
+++ b/javatests/dagger/functional/factory/AbstractModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.factory;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+abstract class AbstractModule {
+  @Provides
+  static String provideString() {
+    return "foo";
+  }
+}
diff --git a/javatests/dagger/functional/factory/ConcreteModuleThatCouldBeAbstract.java b/javatests/dagger/functional/factory/ConcreteModuleThatCouldBeAbstract.java
new file mode 100644
index 000000000..32591a29d
--- /dev/null
+++ b/javatests/dagger/functional/factory/ConcreteModuleThatCouldBeAbstract.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.factory;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class ConcreteModuleThatCouldBeAbstract {
+  @Provides
+  static double provideDouble() {
+    return 42.0;
+  }
+}
diff --git a/javatests/dagger/functional/factory/Dependency.java b/javatests/dagger/functional/factory/Dependency.java
new file mode 100644
index 000000000..90dc294de
--- /dev/null
+++ b/javatests/dagger/functional/factory/Dependency.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.factory;
+
+final class Dependency {
+  Object object() {
+    return "bar";
+  }
+}
diff --git a/javatests/dagger/functional/factory/FactoryBindsInstanceTest.java b/javatests/dagger/functional/factory/FactoryBindsInstanceTest.java
new file mode 100644
index 000000000..83505e981
--- /dev/null
+++ b/javatests/dagger/functional/factory/FactoryBindsInstanceTest.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.factory;
+
+import static com.google.common.truth.Truth.assertThat;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static org.junit.Assert.fail;
+
+import dagger.BindsInstance;
+import dagger.Component;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for component factories with {@link BindsInstance} parameters. */
+@RunWith(JUnit4.class)
+public final class FactoryBindsInstanceTest {
+
+  @Component
+  interface BindsInstanceComponent {
+    String string();
+
+    @Component.Factory
+    interface Factory {
+      BindsInstanceComponent create(@BindsInstance String string);
+    }
+  }
+
+  @Test
+  public void bindsInstance() {
+    BindsInstanceComponent component =
+        DaggerFactoryBindsInstanceTest_BindsInstanceComponent.factory().create("baz");
+    assertThat(component.string()).isEqualTo("baz");
+  }
+
+  @Test
+  public void nonNullableBindsInstance_failsOnNull() {
+    try {
+      DaggerFactoryBindsInstanceTest_BindsInstanceComponent.factory().create(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Target({METHOD, PARAMETER})
+  @Retention(RUNTIME)
+  @interface Nullable {}
+
+  @Component
+  interface NullableBindsInstanceComponent {
+    @Nullable
+    String string();
+
+    @Component.Factory
+    interface Factory {
+      NullableBindsInstanceComponent create(@BindsInstance @Nullable String string);
+    }
+  }
+
+  @Test
+  public void nullableBindsInstance_doesNotFailOnNull() {
+    NullableBindsInstanceComponent component =
+        DaggerFactoryBindsInstanceTest_NullableBindsInstanceComponent.factory().create(null);
+    assertThat(component.string()).isEqualTo(null);
+  }
+
+  @Component
+  interface PrimitiveBindsInstanceComponent {
+    int getInt();
+
+    @Component.Factory
+    interface Factory {
+      PrimitiveBindsInstanceComponent create(@BindsInstance int i);
+    }
+  }
+
+  @Test
+  public void primitiveBindsInstance() {
+    PrimitiveBindsInstanceComponent component =
+        DaggerFactoryBindsInstanceTest_PrimitiveBindsInstanceComponent.factory().create(1);
+    assertThat(component.getInt()).isEqualTo(1);
+  }
+}
diff --git a/javatests/dagger/functional/factory/FactoryDependenciesTest.java b/javatests/dagger/functional/factory/FactoryDependenciesTest.java
new file mode 100644
index 000000000..35a0b851d
--- /dev/null
+++ b/javatests/dagger/functional/factory/FactoryDependenciesTest.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.factory;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import dagger.Component;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for factories for components with a dependency. */
+@RunWith(JUnit4.class)
+public final class FactoryDependenciesTest {
+
+  @Component(dependencies = Dependency.class)
+  interface DependencyComponent {
+    Object object();
+
+    @Component.Factory
+    interface Factory {
+      DependencyComponent create(Dependency dependency);
+    }
+  }
+
+  @Test
+  public void dependency() {
+    DependencyComponent component =
+        DaggerFactoryDependenciesTest_DependencyComponent.factory().create(new Dependency());
+    assertThat(component.object()).isEqualTo("bar");
+  }
+
+  @Test
+  public void dependency_failsOnNull() {
+    try {
+      DaggerFactoryDependenciesTest_DependencyComponent.factory().create(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+}
diff --git a/javatests/dagger/functional/factory/FactoryImplicitModulesTest.java b/javatests/dagger/functional/factory/FactoryImplicitModulesTest.java
new file mode 100644
index 000000000..3cc163064
--- /dev/null
+++ b/javatests/dagger/functional/factory/FactoryImplicitModulesTest.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.factory;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import dagger.Component;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests for factories for components with modules that do not require an instance to be passed to
+ * the factory. Includes both tests where the module does not have a corresponding parameter in the
+ * factory method and where it does have a parameter, for cases where that's allowed.
+ */
+@RunWith(JUnit4.class)
+public final class FactoryImplicitModulesTest {
+
+  @Component(modules = AbstractModule.class)
+  interface AbstractModuleComponent {
+    String string();
+
+    @Component.Factory
+    interface Factory {
+      AbstractModuleComponent create();
+    }
+  }
+
+  @Test
+  public void abstractModule() {
+    AbstractModuleComponent component =
+        DaggerFactoryImplicitModulesTest_AbstractModuleComponent.factory().create();
+    assertThat(component.string()).isEqualTo("foo");
+  }
+
+  @Component(modules = InstantiableConcreteModule.class)
+  interface InstantiableConcreteModuleComponent {
+    int getInt();
+
+    @Component.Factory
+    interface Factory {
+      InstantiableConcreteModuleComponent create();
+    }
+  }
+
+  @Test
+  public void instantiableConcreteModule() {
+    InstantiableConcreteModuleComponent component =
+        DaggerFactoryImplicitModulesTest_InstantiableConcreteModuleComponent.factory().create();
+    assertThat(component.getInt()).isEqualTo(42);
+  }
+
+  @Component(modules = InstantiableConcreteModule.class)
+  interface InstantiableConcreteModuleWithFactoryParameterComponent {
+    int getInt();
+
+    @Component.Factory
+    interface Factory {
+      InstantiableConcreteModuleWithFactoryParameterComponent create(
+          InstantiableConcreteModule module);
+    }
+  }
+
+  @Test
+  public void instantiableConcreteModule_withFactoryParameter() {
+    InstantiableConcreteModuleWithFactoryParameterComponent component =
+        DaggerFactoryImplicitModulesTest_InstantiableConcreteModuleWithFactoryParameterComponent
+            .factory()
+            .create(new InstantiableConcreteModule());
+    assertThat(component.getInt()).isEqualTo(42);
+  }
+
+  @Test
+  public void instantiableConcreteModule_withFactoryParameter_failsOnNull() {
+    try {
+      DaggerFactoryImplicitModulesTest_InstantiableConcreteModuleWithFactoryParameterComponent
+          .factory()
+          .create(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Component(modules = ConcreteModuleThatCouldBeAbstract.class)
+  interface ConcreteModuleThatCouldBeAbstractComponent {
+    double getDouble();
+
+    @Component.Factory
+    interface Factory {
+      ConcreteModuleThatCouldBeAbstractComponent create();
+    }
+  }
+
+  @Test
+  public void concreteModuleThatCouldBeAbstract() {
+    ConcreteModuleThatCouldBeAbstractComponent component =
+        DaggerFactoryImplicitModulesTest_ConcreteModuleThatCouldBeAbstractComponent.factory()
+            .create();
+    assertThat(component.getDouble()).isEqualTo(42.0);
+  }
+
+  @Component(modules = ConcreteModuleThatCouldBeAbstract.class)
+  interface ConcreteModuleThatCouldBeAbstractWithFactoryParameterComponent {
+    double getDouble();
+
+    @Component.Factory
+    interface Factory {
+      ConcreteModuleThatCouldBeAbstractWithFactoryParameterComponent create(
+          ConcreteModuleThatCouldBeAbstract module);
+    }
+  }
+
+  @Test
+  public void concreteModuleThatCouldBeAbstract_withFactoryParameter() {
+    ConcreteModuleThatCouldBeAbstractWithFactoryParameterComponent component =
+        DaggerFactoryImplicitModulesTest_ConcreteModuleThatCouldBeAbstractWithFactoryParameterComponent
+            .factory()
+            .create(new ConcreteModuleThatCouldBeAbstract());
+    assertThat(component.getDouble()).isEqualTo(42.0);
+  }
+
+  @Test
+  public void concreteModuleThatCouldBeAbstract_withFactoryParameter_doesNotFailOnNull() {
+    // TODO(cgdecker): Is this really what we want to happen?
+    // Builders allow there to be a setter for such a module; the setter checks that the argument
+    // is not null but otherwise ignores it. If nothing else, we should probably throw if the arg
+    // is null. But it's not clear to me that we should even allow such a parameter for a factory,
+    // since unlike a builder, where the setter can just not be called, a factory doesn't give the
+    // option of not passing *something* for the unused parameter.
+    ConcreteModuleThatCouldBeAbstractWithFactoryParameterComponent component =
+        DaggerFactoryImplicitModulesTest_ConcreteModuleThatCouldBeAbstractWithFactoryParameterComponent
+            .factory()
+            .create(null); // the parameter is unused and therefore not checked
+    assertThat(component.getDouble()).isEqualTo(42.0);
+  }
+}
diff --git a/javatests/dagger/functional/factory/FactoryMixedParametersTest.java b/javatests/dagger/functional/factory/FactoryMixedParametersTest.java
new file mode 100644
index 000000000..3c8e2ca78
--- /dev/null
+++ b/javatests/dagger/functional/factory/FactoryMixedParametersTest.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.factory;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.BindsInstance;
+import dagger.Component;
+import java.util.Random;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for component factories with multiple parameters. */
+@RunWith(JUnit4.class)
+public final class FactoryMixedParametersTest {
+
+  @Component(
+      modules = {
+        AbstractModule.class,
+        UninstantiableConcreteModule.class,
+        InstantiableConcreteModule.class
+      },
+      dependencies = Dependency.class)
+  interface MixedArgComponent {
+    String string();
+    int getInt();
+    long getLong();
+    Object object();
+    double getDouble();
+    Provider<Random> randomProvider();
+
+    @Component.Factory
+    interface Factory {
+      MixedArgComponent create(
+          @BindsInstance double d,
+          Dependency dependency,
+          UninstantiableConcreteModule module,
+          @BindsInstance Random random);
+    }
+  }
+
+  @Test
+  public void mixedArgComponent() {
+    Random random = new Random();
+    MixedArgComponent component =
+        DaggerFactoryMixedParametersTest_MixedArgComponent.factory()
+            .create(3.0, new Dependency(), new UninstantiableConcreteModule(2L), random);
+    assertThat(component.string()).isEqualTo("foo");
+    assertThat(component.getInt()).isEqualTo(42);
+    assertThat(component.getDouble()).isEqualTo(3.0);
+    assertThat(component.object()).isEqualTo("bar");
+    assertThat(component.getLong()).isEqualTo(2L);
+    assertThat(component.randomProvider().get()).isSameAs(random);
+    assertThat(component.randomProvider().get()).isSameAs(random);
+  }
+}
diff --git a/javatests/dagger/functional/factory/FactoryRequiredModulesTest.java b/javatests/dagger/functional/factory/FactoryRequiredModulesTest.java
new file mode 100644
index 000000000..5b81b512c
--- /dev/null
+++ b/javatests/dagger/functional/factory/FactoryRequiredModulesTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.factory;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import dagger.Component;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests for factories for components that have a module that must have an instance provided by the
+ * user.
+ */
+@RunWith(JUnit4.class)
+public final class FactoryRequiredModulesTest {
+
+  @Component(modules = UninstantiableConcreteModule.class)
+  interface UninstantiableConcreteModuleComponent {
+    long getLong();
+
+    @Component.Factory
+    interface Factory {
+      UninstantiableConcreteModuleComponent create(UninstantiableConcreteModule module);
+    }
+  }
+
+  @Test
+  public void uninstantiableConcreteModule() {
+    UninstantiableConcreteModuleComponent component =
+        DaggerFactoryRequiredModulesTest_UninstantiableConcreteModuleComponent.factory()
+            .create(new UninstantiableConcreteModule(42L));
+    assertThat(component.getLong()).isEqualTo(42L);
+  }
+
+  @Test
+  public void uninstantiableConcreteModule_failsOnNull() {
+    try {
+      DaggerFactoryRequiredModulesTest_UninstantiableConcreteModuleComponent.factory().create(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+}
diff --git a/javatests/dagger/functional/factory/InstantiableConcreteModule.java b/javatests/dagger/functional/factory/InstantiableConcreteModule.java
new file mode 100644
index 000000000..37acbe0f8
--- /dev/null
+++ b/javatests/dagger/functional/factory/InstantiableConcreteModule.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.factory;
+
+import dagger.Module;
+import dagger.Provides;
+
+@SuppressWarnings("StaticModuleMethods") // intentionally non-static
+@Module
+final class InstantiableConcreteModule {
+  @Provides
+  int provideInt() {
+    return 42;
+  }
+}
diff --git a/javatests/dagger/functional/factory/SubcomponentFactoryTest.java b/javatests/dagger/functional/factory/SubcomponentFactoryTest.java
new file mode 100644
index 000000000..cbff8a1cd
--- /dev/null
+++ b/javatests/dagger/functional/factory/SubcomponentFactoryTest.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.factory;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.BindsInstance;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import javax.inject.Inject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests for {@linkplain Subcomponent.Factory subcomponent factories}.
+ *
+ * <p>Most things are tested in {@code FactoryTest}; this is just intended to test some things like
+ * injecting subcomponent factories and returning them from component methods.
+ */
+@RunWith(JUnit4.class)
+public final class SubcomponentFactoryTest {
+
+  @Component
+  interface ParentWithSubcomponentFactory {
+    Sub.Factory subcomponentFactory();
+
+    @Component.Factory
+    interface Factory {
+      ParentWithSubcomponentFactory create(@BindsInstance int i);
+    }
+  }
+
+  @Subcomponent
+  interface Sub {
+    int i();
+    String s();
+
+    @Subcomponent.Factory
+    interface Factory {
+      Sub create(@BindsInstance String s);
+    }
+  }
+
+  @Test
+  public void parentComponentWithSubcomponentFactoryEntryPoint() {
+    ParentWithSubcomponentFactory parent =
+        DaggerSubcomponentFactoryTest_ParentWithSubcomponentFactory.factory().create(3);
+    Sub subcomponent = parent.subcomponentFactory().create("foo");
+    assertThat(subcomponent.i()).isEqualTo(3);
+    assertThat(subcomponent.s()).isEqualTo("foo");
+  }
+
+  @Module(subcomponents = Sub.class)
+  abstract static class ModuleWithSubcomponent {
+    @Provides
+    static int provideInt() {
+      return 42;
+    }
+  }
+
+  static class UsesSubcomponentFactory {
+    private final Sub.Factory subFactory;
+
+    @Inject
+    UsesSubcomponentFactory(Sub.Factory subFactory) {
+      this.subFactory = subFactory;
+    }
+
+    Sub getSubcomponent(String s) {
+      return subFactory.create(s);
+    }
+  }
+
+  @Component(modules = ModuleWithSubcomponent.class)
+  interface ParentWithModuleWithSubcomponent {
+    UsesSubcomponentFactory usesSubcomponentFactory();
+  }
+
+  @Test
+  public void parentComponentWithModuleWithSubcomponent() {
+    ParentWithModuleWithSubcomponent parent =
+        DaggerSubcomponentFactoryTest_ParentWithModuleWithSubcomponent.create();
+    UsesSubcomponentFactory usesSubcomponentFactory = parent.usesSubcomponentFactory();
+
+    Sub subcomponent1 = usesSubcomponentFactory.getSubcomponent("foo");
+    assertThat(subcomponent1.i()).isEqualTo(42);
+    assertThat(subcomponent1.s()).isEqualTo("foo");
+
+    Sub subcomponent2 = usesSubcomponentFactory.getSubcomponent("bar");
+    assertThat(subcomponent2.i()).isEqualTo(42);
+    assertThat(subcomponent2.s()).isEqualTo("bar");
+  }
+}
diff --git a/javatests/dagger/functional/factory/UninstantiableConcreteModule.java b/javatests/dagger/functional/factory/UninstantiableConcreteModule.java
new file mode 100644
index 000000000..13f50fda0
--- /dev/null
+++ b/javatests/dagger/functional/factory/UninstantiableConcreteModule.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.factory;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class UninstantiableConcreteModule {
+  private final long l;
+
+  UninstantiableConcreteModule(long l) {
+    this.l = l;
+  }
+
+  @Provides
+  long provideLong() {
+    return l;
+  }
+}
