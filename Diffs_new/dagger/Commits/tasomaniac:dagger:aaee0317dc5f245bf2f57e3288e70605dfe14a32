diff --git a/_layouts/default.html b/_layouts/default.html
index f51f821a8..23ff4ba5d 100644
--- a/_layouts/default.html
+++ b/_layouts/default.html
@@ -30,8 +30,23 @@
         <paper-item label="Home">
           <a href="//google.github.io/dagger/"></a>
         </paper-item>
+        <paper-item label="User's Guide">
+          <a href="http://google.github.io/dagger/shared/users-guide.html"></a>
+        </paper-item>
         <paper-item label="Migrating from Dagger 1">
-          <a href="dagger-1-migration.html"></a>
+          <a href="http://google.github.io/dagger/dagger-1-migration.html"></a>
+        </paper-item>
+        <paper-item label="Android">
+          <a href="http://google.github.io/dagger/android.html"></a>
+        </paper-item>
+        <paper-item label="Multibinding Sets and Maps">
+          <a href="http://google.github.io/dagger/multibindings.html"></a>
+        </paper-item>
+        <paper-item label="Subcomponents">
+          <a href="http://google.github.io/dagger/subcomponents.html"></a>
+        </paper-item>
+        <paper-item label="Producers">
+          <a href="http://google.github.io/dagger/producers.html"></a>
         </paper-item>
         <h4>Project Pages</h4>
         <paper-item label="GitHub" icon="open-in-browser">
diff --git a/android.md b/android.md
new file mode 100644
index 000000000..be587c6a1
--- /dev/null
+++ b/android.md
@@ -0,0 +1,51 @@
+---
+layout: default
+title: Dagger & Android
+---
+
+One of the primary advantages of Dagger 2 over most other dependency injection
+frameworks is that its strictly generated implementation (no reflection) means
+that it can be used in Android applications. However, there _are_ still some
+considerations to be made when using Dagger within Android applications.
+
+## Philosophy
+
+While code written for Android is Java source, it is often quite different in
+terms of style.  Typically, such differences exist to accomodate the unique
+[performance][android-performance] considerations of a mobile platform.
+
+But many of the patterns commonly applied to code intended for Android are
+contrary to those applied to other Java code.  Even much of the advice in
+[Effective Java][effective-java] is considered inappropriate for Android.
+
+In order to achieve the goals of both idiomatic and portable code, Dagger
+relies on [ProGuard] to post-process the compiled bytecode.  This allows Dagger
+to emit source that looks and feels natural on both the server and Android,
+while using the different toolchains to produce bytecode that executes
+efficiently in both environements.  Moreover, Dagger has an explicit goal to
+ensure that the Java source that it generates is consistently compatible with
+ProGuard optimizations.
+
+Of course, not all issues can be addressed in that manner, but it is the primary
+mechanism by which Android-specific compatbility will be provided.
+
+### tl;dr
+
+Dagger assumes that users on Android will use ProGuard.
+
+## Recommended ProGuard Settings
+
+Watch this space for ProGuard settings that are relevant to applications using
+Dagger.
+
+
+<!-- References -->
+
+[android-performance]: http://developer.android.com/training/best-performance.html
+
+
+[effective-java]: https://books.google.com/books?id=ka2VUBqHiWkC
+[ProGuard]: http://proguard.sourceforge.net/
+
+
+
diff --git a/index.md b/index.md
index 02f26029f..8db8860d3 100644
--- a/index.md
+++ b/index.md
@@ -1,334 +1,40 @@
 ---
 layout: default
-title: Dagger 2
+title: Dagger
 ---
 
-The best classes in any application are the ones that do stuff: the `BarcodeDecoder`, the `KoopaPhysicsEngine`, and the `AudioStreamer`. These classes have dependencies; perhaps a `BarcodeCameraFinder`, `DefaultPhysicsEngine`, and an `HttpStreamer`.
+Dagger is a fully static, compile-time [dependency injection][DI] framework for
+both Java and Android. It is an adaptation of an earlier version
+[created](https://github.com/square/dagger) by
+[Square] and now maintained by Google.
 
-To contrast, the worst classes in any application are the ones that take up space without doing much at all: the `BarcodeDecoderFactory`, the `CameraServiceLoader`, and the `MutableContextWrapper`. These classes are the clumsy duct tape that wires the interesting stuff together.
+Dagger aims to address many of the development and performance issues that have
+plagued reflection-based solutions. More details can be found in
+[this talk][dagger-talk-video]([slides][dagger-talk-slides]) by
+[+Gregory Kick].
 
-Dagger is a replacement for these `FactoryFactory` classes that implements the [dependency injection][DI] design pattern without the burden of writing the boilerplate. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.
+## Where are the docs?
 
-By building on standard [`javax.inject`](http://docs.oracle.com/javaee/7/api/javax/inject/package-summary.html) annotations ([JSR 330](https://jcp.org/en/jsr/detail?id=330)), each class is **easy to test**. You don't need a bunch of boilerplate just to swap the `RpcCreditCardService` out for a `FakeCreditCardService`.
+* [User documentation](users-guide.md)
+* [Dagger API @ HEAD][api-docs]
 
-Dependency injection isn't just for testing. It also makes it easy to create **reusable, interchangeable modules**. You can share the same `AuthenticationModule`  across all of your apps. And you can run `DevLoggingModule` during development and `ProdLoggingModule` in production to get the right behavior in each situation.
+## Where is the code?
 
-## Why Dagger 2 is Different
+* https://github.com/google/dagger
 
-[Dependency injection][DI] frameworks have existed for years with a whole variety of APIs for configuring and injecting.  So, why reinvent the wheel?  Dagger 2 is the first to **implement the full stack with generated code**. The guiding principle is to generate code that mimics the code that a user might have hand-written to ensure that dependency injection is a simple, traceable and performant as it can be. For more background on the design, watch [this talk](https://www.youtube.com/watch?v=oK_XtfXPkqw) ([slides](https://docs.google.com/presentation/d/1fby5VeGU9CN8zjw4lAb2QPPsKRxx6mSwCe9q7ECNSJQ/pub?start=false&loop=false&delayms=3000)) by [+Gregory Kick](https://google.com/+GregoryKick/).
+## Have a question?
 
-## Using Dagger
-We'll demonstrate dependency injection and Dagger by building a coffee maker. For complete sample code that you can compile and run, see Dagger's [coffee example](https://github.com/google/dagger/tree/master/examples/simple/src/main/java/coffee).
+* Ask it on Stack Overflow with the [dagger-2][stack-overflow] tag
+* Send an email to [dagger-discuss@googlegroups.com][dagger-discuss]
 
-### Declaring Dependencies
+[api-docs]: http://google.github.io/dagger/api/latest/
+[DI]: http://en.wikipedia.org/wiki/Dependency_injection
+[dagger-talk-video]: https://www.youtube.com/watch?v=oK_XtfXPkqw
+[dagger-discuss]: https://groups.google.com/forum/#!forum/dagger-discuss
+[dagger-github]: https://github.com/google/dagger
+[dagger-talk-slides]: https://docs.google.com/presentation/d/1fby5VeGU9CN8zjw4lAb2QPPsKRxx6mSwCe9q7ECNSJQ/pub?start=false&loop=false&delayms=3000
+[Square]: http://square.github.io/
+[stack-overflow]: http://stackoverflow.com/questions/tagged/dagger-2
+[+Gregory Kick]: https://google.com/+GregoryKick/
 
-Dagger constructs instances of your application classes and satisfies their dependencies. It uses the [`javax.inject.Inject`](http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html) annotation to identify which constructors and fields it is interested in.
-
-Use `@Inject` to annotate the constructor that Dagger should use to create instances of a class. When a new instance is requested, Dagger will obtain the required parameters values and invoke this constructor.
-
-```java
-class Thermosiphon implements Pump {
-  private final Heater heater;
-
-  @Inject
-  Thermosiphon(Heater heater) {
-    this.heater = heater;
-  }
-
-  ...
-}
-```
-
-Dagger can inject fields directly. In this example it obtains a `Heater` instance for the `heater` field and a `Pump` instance for the `pump` field.
-
-```java
-class CoffeeMaker {
-  @Inject Heater heater;
-  @Inject Pump pump;
-
-  ...
-}
-```
-
-If your class has `@Inject`-annotated fields but no `@Inject`-annotated constructor, Dagger will inject those fields if requested, but will not create new instances. Add a no-argument constructor with the `@Inject` annotation to indicate that Dagger may create instances as well.
-
-Dagger also supports method injection, though constructor or field injection are typically preferred.
-
-Classes that lack `@Inject` annotations cannot be constructed by Dagger.
-
-### Satisfying Dependencies
-
-By default, Dagger satisfies each dependency by constructing an instance of the requested type as described above. When you request a `CoffeeMaker`, it'll obtain one by calling `new CoffeeMaker()` and setting its injectable fields.
-
-But `@Inject` doesn't work everywhere:
-
-  * Interfaces can't be constructed.
-  * Third-party classes can't be annotated.
-  * Configurable objects must be configured!
-
-For these cases where `@Inject` is insufficient or awkward, use an [`@Provides`][Provides]-annotated method to satisfy a dependency. The method's return type defines which dependency it satisfies.
-
-For example, `provideHeater()` is invoked whenever a `Heater` is required:
-
-```java
-@Provides Heater provideHeater() {
-  return new ElectricHeater();
-}
-```
-
-It's possible for `@Provides` methods to have dependencies of their own. This one returns a `Thermosiphon` whenever a `Pump` is required:
-
-```java
-@Provides Pump providePump(Thermosiphon pump) {
-  return pump;
-}
-```
-
-All `@Provides` methods must belong to a module. These are just classes that have an [`@Module`][Module] annotation.
-
-```java
-@Module
-class DripCoffeeModule {
-  @Provides Heater provideHeater() {
-    return new ElectricHeater();
-  }
-
-  @Provides Pump providePump(Thermosiphon pump) {
-    return pump;
-  }
-}
-```
-
-By convention, `@Provides` methods are named with a `provide` prefix and module classes are named with a `Module` suffix.
-
-### Building the Graph
-
-The `@Inject` and `@Provides`-annotated classes form a graph of objects, linked by their dependencies. Calling code like an application's `main` method or an Android [`Application`](http://developer.android.com/reference/android/app/Application.html) accesses that graph via a well-defined set of roots. In Dagger 2, that set is defined by an interface with methods that have no arguments and return the desired type. By applying the [`@Component`][Component] annotation to such an interface and passing the [module][Module] types to the `modules` parameter, Dagger 2 then fully generates an implementation of that contract.
-
-```java
-@Component(modules = DripCoffeeModule.class)
-interface CoffeeShop {
-  CoffeeMaker maker();
-}
-```
-
-The implementation has the same name as the interface prefixed with `Dagger`.  Obtain an instance by invoking the `builder()` method on that implementation and use the returned [builder](http://en.wikipedia.org/wiki/Builder_pattern) to set dependencies and `build()` a new instance.
-
-```java
-CoffeeShop coffeeShop = DaggerCoffeeShop.builder()
-    .dripCoffeeModule(new DripCoffeeModule())
-    .build();
-```
-
-Any module with an accessible default constructor can be elided as the builder will construct an instance automatically if none is set.  If all dependencies can be constructed in that manner, the generated implementation will also have a `create()` method that can be used to get a new instance without having to deal with the builder.
-
-```java
-CoffeeShop coffeeShop = DaggerCoffeeShop.create();
-```
-
-Now, our `CoffeeApp` can simply use the Dagger-generated implementation of `CoffeeShop` to get a fully-injected `CoffeeMaker`.
-
-```java
-public class CoffeeApp {
-  public static void main(String[] args) {
-    CoffeeShop coffeeShop = DaggerCoffeeShop.create();
-    coffeeShop.maker().brew();
-  }
-}
-```
-
-Now that the graph is constructed and the entry point is injected, we run our coffee maker app. Fun.
-
-```
-$ java -cp ... coffee.CoffeeApp
-~ ~ ~ heating ~ ~ ~
-=> => pumping => =>
- [_]P coffee! [_]P
-```
-
-### Singletons and Scoped Bindings
-
-Annotate an `@Provides` method or injectable class with [`@Singleton`][Singleton]. The graph will use a single instance of the value for all of its clients.
-
-```java
-@Provides @Singleton Heater provideHeater() {
-  return new ElectricHeater();
-}
-```
-
-The `@Singleton` annotation on an injectable class also serves as [documentation](http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Documented.html). It reminds potential maintainers that this class may be shared by multiple threads.
-
-```java
-@Singleton
-class CoffeeMaker {
-  ...
-}
-```
-
-Since Dagger 2 associates scoped instances in the graph with instances of component implementations, the components themselves need to declare which scope they intend to represent. For example, it wouldn't make any sense to have a `@Singleton` binding and a `@RequestScoped` binding in the same component because those scopes have different lifecycles and thus must live in components with different lifecycles. To declare that a component is associated with a given scope, simply apply the scope annotation to the component interface.
-
-```java
-@Component(modules = DripCoffeeModule.class)
-@Singleton
-interface CoffeeShop {
-  CoffeeMaker maker();
-}
-```
-
-### Lazy injections
-
-Sometimes you need an object to be instantiated lazily.  For any binding `T`, you can create a [`Lazy<T>`][Lazy] which defers instantiation until the first call to `Lazy<T>`'s `get()` method. If `T` is a singleton, then `Lazy<T>` will be the same instance for all injections within the `ObjectGraph`.  Otherwise, each injection site will get its own `Lazy<T>` instance.  Regardless, subsequent calls to any given instance of `Lazy<T>` will return the same underlying instance of `T`.
-
-```java
-class GridingCoffeeMaker {
-  @Inject Lazy<Grinder> lazyGrinder;
-
-  public void brew() {
-    while (needsGrinding()) {
-      // Grinder created once on first call to .get() and cached.
-      lazyGrinder.get().grind();
-    }
-  }
-}
-```
-
-### Provider injections
-
-Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have several options (Factories, Builders, etc.), one option is to inject a [`Provider<T>`][Provider] instead of just `T`.  A `Provider<T>` invokes the _binding logic_ for `T` each time `.get()` is called.  If that binding logic is an `@Inject` constructor, a new instance will be created, but a `@Provides` method has no such guarantee.
-
-```java
-class BigCoffeeMaker {
-  @Inject Provider<Filter> filterProvider;
-
-  public void brew(int numberOfPots) {
-  ...
-    for (int p = 0; p < numberOfPots; p++) {
-      maker.addFilter(filterProvider.get()); //new filter every time.
-      maker.addCoffee(...);
-      maker.percolate();
-      ...
-    }
-  }
-}
-```
-
-***Note:*** Injecting `Provider<T>` has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph.  Often you will want to use a [factory](http://en.wikipedia.org/wiki/Factory_(object-oriented_programming)) or a `Lazy<T>` or re-organize the lifetimes and structure of your code to be able to just inject a `T`.  Injecting `Provider<T>` can, however, be a life saver in some cases.  A common use is when you must use a legacy architecture that doesn't line up with your object's natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).
-
-### Qualifiers
-
-Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.
-
-In this case, we add a **qualifier annotation**. This is any annotation that itself has a [`@Qualifier`][Qualifier] annotation. Here's the declaration of [`@Named`][Named], a qualifier annotation included in `javax.inject`:
-
-```java
-@Qualifier
-@Documented
-@Retention(RUNTIME)
-public @interface Named {
-  String value() default "";
-}
-```
-
-You can create your own qualifier annotations, or just use `@Named`. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.
-
-```java
-class ExpensiveCoffeeMaker {
-  @Inject @Named("water") Heater waterHeater;
-  @Inject @Named("hot plate") Heater hotPlateHeater;
-  ...
-}
-```
-
-Supply qualified values by annotating the corresponding `@Provides` method.
-
-```java
-@Provides @Named("hot plate") Heater provideHotPlateHeater() {
-  return new ElectricHeater(70);
-}
-
-@Provides @Named("water") Heater provideWaterHeater() {
-  return new ElectricHeater(93);
-}
-```
-
-Dependencies may not have multiple qualifier annotations.
-
-### Compile-time Validation
-
-The Dagger [annotation processor](http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html) is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is installed in a component, which is missing a binding for `Executor`:
-
-```java
-@Module
-class DripCoffeeModule {
-  @Provides Heater provideHeater(Executor executor) {
-    return new CpuHeater(executor);
-  }
-}
-```
-
-When compiling it, `javac` rejects the missing binding:
-
-```
-[ERROR] COMPILATION ERROR :
-[ERROR] error: java.util.concurrent.Executor cannot be provided without an @Provides-annotated method.
-```
-
-Fix the problem by adding an `@Provides`-annotated method for `Executor` to _any_ of the modules in the component.  While `@Inject`, `@Module` and `@Provides` annotations are validated individually, all validation of the relationship between bindings happens at the `@Component` level.  Dagger 1 relied strictly on `@Module`-level validation (which may or may not have reflected runtime behavior), but Dagger 2 elides such validation (and the accompanying configuration parameters on `@Module`) in favor of full graph validation.
-
-### Compile-time Code Generation
-
-Dagger's annotation processor may also generate source files with names like `CoffeeMaker$$Factory.java` or `CoffeeMaker$$MembersInjector.java`. These files are Dagger implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.
-
-## Using Dagger In Your Build
-
-You will need to include the `dagger-{{site.dagger.version}}.jar` in your application's runtime.  In order to activate code generation you will need to include `dagger-compiler-{{site.dagger.version}}.jar` in your build at compile time.
-
-In a Maven project, one would include the runtime in the dependencies section of your `pom.xml`, and the `dagger-compiler` artifact as a dependency of the compiler plugin:
-
-```xml
-<dependencies>
-  <dependency>
-    <groupId>{{site.dagger.groupId}}</groupId>
-    <artifactId>dagger</artifactId>
-    <version>{{site.dagger.version}}</version>
-  </dependency>
-  <dependency>
-    <groupId>{{site.dagger.groupId}}</groupId>
-    <artifactId>dagger-compiler</artifactId>
-    <version>{{site.dagger.version}}</version>
-    <optional>true</optional>
-  </dependency>
-</dependencies>
-```
-
-## License
-
-```
-Copyright 2014 Google, Inc.
-Copyright 2012 Square, Inc.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-   http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-```
-
-[DI]: <http://en.wikipedia.org/wiki/Dependency_injection>
-
-[Component]: <api/latest/dagger/Component.html>
-[Lazy]: <api/latest/dagger/Lazy.html>
-[Module]: <api/latest/dagger/Module.html>
-[Provides]: <api/latest/dagger/Provides.html>
-
-[Named]: <http://docs.oracle.com/javaee/7/api/javax/inject/Named.html>
-[Provider]: <http://docs.oracle.com/javaee/7/api/javax/inject/Provider.html>
-[Qualifier]: <http://docs.oracle.com/javaee/7/api/javax/inject/Qualifier.html>
-[Scope]: <http://docs.oracle.com/javaee/7/api/javax/inject/Scope.html>
-[Singleton]: <http://docs.oracle.com/javaee/7/api/javax/inject/Singleton.html>
+>>>>>>> f944c5e... Fix github-pages landing page to show link to updated users-guide
diff --git a/multibindings.md b/multibindings.md
index 81cfa38a2..4fdbd9e1a 100644
--- a/multibindings.md
+++ b/multibindings.md
@@ -43,20 +43,6 @@ class MyModuleB {
 }
 ```
 
-If no `type = SET` or `type = SET_VALUES` multibindings exist for a set, then
-depending on that set is an error. If you want to allow an empty set, then add a
-`type = SET_VALUES` method that returns an empty set.
-
-```java
-@Module
-class MyEmptySetModule {
-  @Provides(type = SET_VALUES)
-  static Set<Foo> primeEmptyFooSet() {
-    return Collections.emptySet();
-  }
-}
-```
-
 Now a binding in that component can depend on the set:
 
 ```java
@@ -329,6 +315,48 @@ class MyProviderMapModule {
 }
 ```
 
+## Declaring multibindings
+
+You can declare that a multibound set or map is bound by nesting a
+[`@Multibindings`]-annotated interface within a module, with methods that return
+the sets or maps you want to declare.
+
+You do not have to use [`@Multibindings`] for sets or maps that have at least
+one contribution, but you do have to declare them if they may be empty.[^empty-set-values]
+
+[^empty-set-values]:
+    For empty sets only, as an alternative, you can add a [`@Provides(type =
+    SET_VALUES)`] method that returns an empty set:
+
+    ```java
+    @Module
+    class MyEmptySetModule {
+      @Provides(type = SET_VALUES)
+      static Set<Foo> primeEmptyFooSet() {
+        return Collections.emptySet();
+      }
+    }
+    ```
+
+```java
+@Module
+class MyModule {
+  @Multibindings
+  interface MyMultibindings {
+    Set<Foo> aSet();
+    @MyQualifier Set<Foo> aQualifiedSet();
+    Map<String, Foo> aMap();
+    @MyQualifier Map<String, Foo> aQualifiedMap();
+  }
+}
+```
+
+All methods on the interface and any supertypes (except for methods on `Object`)
+are used to declare multibindings. The names of the interface and its methods
+are ignored. A given set or map multibinding can be declared any number of times
+without error. Dagger never implements the interface or calls any of its
+methods.
+
 ## Inherited subcomponent multibindings
 
 A binding in a subcomponent can depend on a multibound set or map from its
@@ -432,6 +460,7 @@ class ChildModule {
 [`@AutoAnnotation`]: https://github.com/google/auto/blob/master/value/src/main/java/com/google/auto/value/AutoAnnotation.java
 [`dagger.mapkeys`]: http://google.github.io/dagger/api/latest/dagger/mapkeys/package-summary.html
 [`@MapKey`]: http://google.github.io/dagger/api/latest/dagger/MapKey.html
+[`@Multibindings`]: http://google.github.io/dagger/api/latest/dagger/Multibindings.html
 [`@Provides(type = MAP)`]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#MAP
 [`@Provides(type = SET)`]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#SET
 [`@Provides(type = SET_VALUES)`]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#SET_VALUES
diff --git a/producers.md b/producers.md
index ebc991b9f..0c46865a2 100644
--- a/producers.md
+++ b/producers.md
@@ -161,7 +161,9 @@ In this example, when all the producer methods that contribute to this set have
 completed futures, the `Set<Data>` is constructed and the collect() method is
 called.
 
-Map multibindings are similar:
+#### Map multibindings
+
+Map multibindings are similar to set multibindings:
 
 ```java
 @MapKey @interface DispatchPath {
@@ -242,9 +244,40 @@ subcomponents of either components or production components.
 A subcomponent inherits all bindings from its parent component, and so it is
 often a simpler way of building nested scopes.
 
-### Logging and debugging
+### Monitoring
 
-==As of April 2015, not implemented yet==
+[ProducerMonitor][ProducerMonitor] can be used to monitor the execution of
+producer methods; its methods correspond to various places in a producer's
+lifecycle.
+
+To install a `ProducerMonitor`, contribute into a set binding of
+[`ProductionComponentMonitor.Factory`][ProductionComponentMonitorFactory]. For
+example:
+
+```java
+@Module
+final class MyMonitorModule {
+  @Provides(type = SET)
+  static ProductionComponentMonitor.Factory provideMonitorFactory(
+      MyProductionComponentMonitor.Factory monitorFactory) {
+    return monitorFactory;
+  }
+}
+
+@ProductionComponent(modules = {MyMonitorModule.class, MyProducerModule.class})
+interface MyComponent {
+  ListenableFuture<SomeType> someType();
+}
+```
+
+When the component is created, each monitor factory contributed to the set will
+be asked to create a monitor for the component. The resulting (single) instance
+will be held for the lifetime of the component, and will be used to create
+individual monitors for each producer method.
+
+### Timing, Logging and Debugging
+
+==As of January 2016, not implemented yet==
 
 Since graphs are constructed at compile-time, the graph will be able to be
 viewed immediately after compiling, likely via writing its structure to json
@@ -263,8 +296,11 @@ While a graph is running, its current state will be able to be dumped.
 [Produced]: http://google.github.io/dagger/api/latest/dagger/producers/Produced.html
 [Producer]: http://google.github.io/dagger/api/latest/dagger/producers/Producer.html
 [ProducerModule]: http://google.github.io/dagger/api/latest/dagger/producers/ProducerModule.html
+[ProducerMonitor]: http://google.github.io/dagger/api/latest/dagger/producers/monitoring/ProducerMonitor.html
 [Produces]: http://google.github.io/dagger/api/latest/dagger/producers/Produces.html
 [ProductionComponent]: http://google.github.io/dagger/api/latest/dagger/producers/ProductionComponent.html
+[ProductionComponentMonitor]: http://google.github.io/dagger/api/latest/dagger/producers/monitoring/ProductionComponentMonitor.html
+[ProductionComponentMonitorFactory]: http://google.github.io/dagger/api/latest/dagger/producers/monitoring/ProductionComponentMonitor.Factory.html
 [Provider]: http://docs.oracle.com/javaee/6/api/javax/inject/Provider.html
 [Provides]: http://google.github.io/dagger/api/latest/dagger/Provides.html
 [Subcomponent]: http://google.github.io/dagger/api/latest/dagger/Subcomponent.html
diff --git a/public_docs/index.md b/public_docs/index.md
new file mode 100644
index 000000000..02f26029f
--- /dev/null
+++ b/public_docs/index.md
@@ -0,0 +1,334 @@
+---
+layout: default
+title: Dagger 2
+---
+
+The best classes in any application are the ones that do stuff: the `BarcodeDecoder`, the `KoopaPhysicsEngine`, and the `AudioStreamer`. These classes have dependencies; perhaps a `BarcodeCameraFinder`, `DefaultPhysicsEngine`, and an `HttpStreamer`.
+
+To contrast, the worst classes in any application are the ones that take up space without doing much at all: the `BarcodeDecoderFactory`, the `CameraServiceLoader`, and the `MutableContextWrapper`. These classes are the clumsy duct tape that wires the interesting stuff together.
+
+Dagger is a replacement for these `FactoryFactory` classes that implements the [dependency injection][DI] design pattern without the burden of writing the boilerplate. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.
+
+By building on standard [`javax.inject`](http://docs.oracle.com/javaee/7/api/javax/inject/package-summary.html) annotations ([JSR 330](https://jcp.org/en/jsr/detail?id=330)), each class is **easy to test**. You don't need a bunch of boilerplate just to swap the `RpcCreditCardService` out for a `FakeCreditCardService`.
+
+Dependency injection isn't just for testing. It also makes it easy to create **reusable, interchangeable modules**. You can share the same `AuthenticationModule`  across all of your apps. And you can run `DevLoggingModule` during development and `ProdLoggingModule` in production to get the right behavior in each situation.
+
+## Why Dagger 2 is Different
+
+[Dependency injection][DI] frameworks have existed for years with a whole variety of APIs for configuring and injecting.  So, why reinvent the wheel?  Dagger 2 is the first to **implement the full stack with generated code**. The guiding principle is to generate code that mimics the code that a user might have hand-written to ensure that dependency injection is a simple, traceable and performant as it can be. For more background on the design, watch [this talk](https://www.youtube.com/watch?v=oK_XtfXPkqw) ([slides](https://docs.google.com/presentation/d/1fby5VeGU9CN8zjw4lAb2QPPsKRxx6mSwCe9q7ECNSJQ/pub?start=false&loop=false&delayms=3000)) by [+Gregory Kick](https://google.com/+GregoryKick/).
+
+## Using Dagger
+We'll demonstrate dependency injection and Dagger by building a coffee maker. For complete sample code that you can compile and run, see Dagger's [coffee example](https://github.com/google/dagger/tree/master/examples/simple/src/main/java/coffee).
+
+### Declaring Dependencies
+
+Dagger constructs instances of your application classes and satisfies their dependencies. It uses the [`javax.inject.Inject`](http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html) annotation to identify which constructors and fields it is interested in.
+
+Use `@Inject` to annotate the constructor that Dagger should use to create instances of a class. When a new instance is requested, Dagger will obtain the required parameters values and invoke this constructor.
+
+```java
+class Thermosiphon implements Pump {
+  private final Heater heater;
+
+  @Inject
+  Thermosiphon(Heater heater) {
+    this.heater = heater;
+  }
+
+  ...
+}
+```
+
+Dagger can inject fields directly. In this example it obtains a `Heater` instance for the `heater` field and a `Pump` instance for the `pump` field.
+
+```java
+class CoffeeMaker {
+  @Inject Heater heater;
+  @Inject Pump pump;
+
+  ...
+}
+```
+
+If your class has `@Inject`-annotated fields but no `@Inject`-annotated constructor, Dagger will inject those fields if requested, but will not create new instances. Add a no-argument constructor with the `@Inject` annotation to indicate that Dagger may create instances as well.
+
+Dagger also supports method injection, though constructor or field injection are typically preferred.
+
+Classes that lack `@Inject` annotations cannot be constructed by Dagger.
+
+### Satisfying Dependencies
+
+By default, Dagger satisfies each dependency by constructing an instance of the requested type as described above. When you request a `CoffeeMaker`, it'll obtain one by calling `new CoffeeMaker()` and setting its injectable fields.
+
+But `@Inject` doesn't work everywhere:
+
+  * Interfaces can't be constructed.
+  * Third-party classes can't be annotated.
+  * Configurable objects must be configured!
+
+For these cases where `@Inject` is insufficient or awkward, use an [`@Provides`][Provides]-annotated method to satisfy a dependency. The method's return type defines which dependency it satisfies.
+
+For example, `provideHeater()` is invoked whenever a `Heater` is required:
+
+```java
+@Provides Heater provideHeater() {
+  return new ElectricHeater();
+}
+```
+
+It's possible for `@Provides` methods to have dependencies of their own. This one returns a `Thermosiphon` whenever a `Pump` is required:
+
+```java
+@Provides Pump providePump(Thermosiphon pump) {
+  return pump;
+}
+```
+
+All `@Provides` methods must belong to a module. These are just classes that have an [`@Module`][Module] annotation.
+
+```java
+@Module
+class DripCoffeeModule {
+  @Provides Heater provideHeater() {
+    return new ElectricHeater();
+  }
+
+  @Provides Pump providePump(Thermosiphon pump) {
+    return pump;
+  }
+}
+```
+
+By convention, `@Provides` methods are named with a `provide` prefix and module classes are named with a `Module` suffix.
+
+### Building the Graph
+
+The `@Inject` and `@Provides`-annotated classes form a graph of objects, linked by their dependencies. Calling code like an application's `main` method or an Android [`Application`](http://developer.android.com/reference/android/app/Application.html) accesses that graph via a well-defined set of roots. In Dagger 2, that set is defined by an interface with methods that have no arguments and return the desired type. By applying the [`@Component`][Component] annotation to such an interface and passing the [module][Module] types to the `modules` parameter, Dagger 2 then fully generates an implementation of that contract.
+
+```java
+@Component(modules = DripCoffeeModule.class)
+interface CoffeeShop {
+  CoffeeMaker maker();
+}
+```
+
+The implementation has the same name as the interface prefixed with `Dagger`.  Obtain an instance by invoking the `builder()` method on that implementation and use the returned [builder](http://en.wikipedia.org/wiki/Builder_pattern) to set dependencies and `build()` a new instance.
+
+```java
+CoffeeShop coffeeShop = DaggerCoffeeShop.builder()
+    .dripCoffeeModule(new DripCoffeeModule())
+    .build();
+```
+
+Any module with an accessible default constructor can be elided as the builder will construct an instance automatically if none is set.  If all dependencies can be constructed in that manner, the generated implementation will also have a `create()` method that can be used to get a new instance without having to deal with the builder.
+
+```java
+CoffeeShop coffeeShop = DaggerCoffeeShop.create();
+```
+
+Now, our `CoffeeApp` can simply use the Dagger-generated implementation of `CoffeeShop` to get a fully-injected `CoffeeMaker`.
+
+```java
+public class CoffeeApp {
+  public static void main(String[] args) {
+    CoffeeShop coffeeShop = DaggerCoffeeShop.create();
+    coffeeShop.maker().brew();
+  }
+}
+```
+
+Now that the graph is constructed and the entry point is injected, we run our coffee maker app. Fun.
+
+```
+$ java -cp ... coffee.CoffeeApp
+~ ~ ~ heating ~ ~ ~
+=> => pumping => =>
+ [_]P coffee! [_]P
+```
+
+### Singletons and Scoped Bindings
+
+Annotate an `@Provides` method or injectable class with [`@Singleton`][Singleton]. The graph will use a single instance of the value for all of its clients.
+
+```java
+@Provides @Singleton Heater provideHeater() {
+  return new ElectricHeater();
+}
+```
+
+The `@Singleton` annotation on an injectable class also serves as [documentation](http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Documented.html). It reminds potential maintainers that this class may be shared by multiple threads.
+
+```java
+@Singleton
+class CoffeeMaker {
+  ...
+}
+```
+
+Since Dagger 2 associates scoped instances in the graph with instances of component implementations, the components themselves need to declare which scope they intend to represent. For example, it wouldn't make any sense to have a `@Singleton` binding and a `@RequestScoped` binding in the same component because those scopes have different lifecycles and thus must live in components with different lifecycles. To declare that a component is associated with a given scope, simply apply the scope annotation to the component interface.
+
+```java
+@Component(modules = DripCoffeeModule.class)
+@Singleton
+interface CoffeeShop {
+  CoffeeMaker maker();
+}
+```
+
+### Lazy injections
+
+Sometimes you need an object to be instantiated lazily.  For any binding `T`, you can create a [`Lazy<T>`][Lazy] which defers instantiation until the first call to `Lazy<T>`'s `get()` method. If `T` is a singleton, then `Lazy<T>` will be the same instance for all injections within the `ObjectGraph`.  Otherwise, each injection site will get its own `Lazy<T>` instance.  Regardless, subsequent calls to any given instance of `Lazy<T>` will return the same underlying instance of `T`.
+
+```java
+class GridingCoffeeMaker {
+  @Inject Lazy<Grinder> lazyGrinder;
+
+  public void brew() {
+    while (needsGrinding()) {
+      // Grinder created once on first call to .get() and cached.
+      lazyGrinder.get().grind();
+    }
+  }
+}
+```
+
+### Provider injections
+
+Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have several options (Factories, Builders, etc.), one option is to inject a [`Provider<T>`][Provider] instead of just `T`.  A `Provider<T>` invokes the _binding logic_ for `T` each time `.get()` is called.  If that binding logic is an `@Inject` constructor, a new instance will be created, but a `@Provides` method has no such guarantee.
+
+```java
+class BigCoffeeMaker {
+  @Inject Provider<Filter> filterProvider;
+
+  public void brew(int numberOfPots) {
+  ...
+    for (int p = 0; p < numberOfPots; p++) {
+      maker.addFilter(filterProvider.get()); //new filter every time.
+      maker.addCoffee(...);
+      maker.percolate();
+      ...
+    }
+  }
+}
+```
+
+***Note:*** Injecting `Provider<T>` has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph.  Often you will want to use a [factory](http://en.wikipedia.org/wiki/Factory_(object-oriented_programming)) or a `Lazy<T>` or re-organize the lifetimes and structure of your code to be able to just inject a `T`.  Injecting `Provider<T>` can, however, be a life saver in some cases.  A common use is when you must use a legacy architecture that doesn't line up with your object's natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).
+
+### Qualifiers
+
+Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.
+
+In this case, we add a **qualifier annotation**. This is any annotation that itself has a [`@Qualifier`][Qualifier] annotation. Here's the declaration of [`@Named`][Named], a qualifier annotation included in `javax.inject`:
+
+```java
+@Qualifier
+@Documented
+@Retention(RUNTIME)
+public @interface Named {
+  String value() default "";
+}
+```
+
+You can create your own qualifier annotations, or just use `@Named`. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.
+
+```java
+class ExpensiveCoffeeMaker {
+  @Inject @Named("water") Heater waterHeater;
+  @Inject @Named("hot plate") Heater hotPlateHeater;
+  ...
+}
+```
+
+Supply qualified values by annotating the corresponding `@Provides` method.
+
+```java
+@Provides @Named("hot plate") Heater provideHotPlateHeater() {
+  return new ElectricHeater(70);
+}
+
+@Provides @Named("water") Heater provideWaterHeater() {
+  return new ElectricHeater(93);
+}
+```
+
+Dependencies may not have multiple qualifier annotations.
+
+### Compile-time Validation
+
+The Dagger [annotation processor](http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html) is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is installed in a component, which is missing a binding for `Executor`:
+
+```java
+@Module
+class DripCoffeeModule {
+  @Provides Heater provideHeater(Executor executor) {
+    return new CpuHeater(executor);
+  }
+}
+```
+
+When compiling it, `javac` rejects the missing binding:
+
+```
+[ERROR] COMPILATION ERROR :
+[ERROR] error: java.util.concurrent.Executor cannot be provided without an @Provides-annotated method.
+```
+
+Fix the problem by adding an `@Provides`-annotated method for `Executor` to _any_ of the modules in the component.  While `@Inject`, `@Module` and `@Provides` annotations are validated individually, all validation of the relationship between bindings happens at the `@Component` level.  Dagger 1 relied strictly on `@Module`-level validation (which may or may not have reflected runtime behavior), but Dagger 2 elides such validation (and the accompanying configuration parameters on `@Module`) in favor of full graph validation.
+
+### Compile-time Code Generation
+
+Dagger's annotation processor may also generate source files with names like `CoffeeMaker$$Factory.java` or `CoffeeMaker$$MembersInjector.java`. These files are Dagger implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.
+
+## Using Dagger In Your Build
+
+You will need to include the `dagger-{{site.dagger.version}}.jar` in your application's runtime.  In order to activate code generation you will need to include `dagger-compiler-{{site.dagger.version}}.jar` in your build at compile time.
+
+In a Maven project, one would include the runtime in the dependencies section of your `pom.xml`, and the `dagger-compiler` artifact as a dependency of the compiler plugin:
+
+```xml
+<dependencies>
+  <dependency>
+    <groupId>{{site.dagger.groupId}}</groupId>
+    <artifactId>dagger</artifactId>
+    <version>{{site.dagger.version}}</version>
+  </dependency>
+  <dependency>
+    <groupId>{{site.dagger.groupId}}</groupId>
+    <artifactId>dagger-compiler</artifactId>
+    <version>{{site.dagger.version}}</version>
+    <optional>true</optional>
+  </dependency>
+</dependencies>
+```
+
+## License
+
+```
+Copyright 2014 Google, Inc.
+Copyright 2012 Square, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+```
+
+[DI]: <http://en.wikipedia.org/wiki/Dependency_injection>
+
+[Component]: <api/latest/dagger/Component.html>
+[Lazy]: <api/latest/dagger/Lazy.html>
+[Module]: <api/latest/dagger/Module.html>
+[Provides]: <api/latest/dagger/Provides.html>
+
+[Named]: <http://docs.oracle.com/javaee/7/api/javax/inject/Named.html>
+[Provider]: <http://docs.oracle.com/javaee/7/api/javax/inject/Provider.html>
+[Qualifier]: <http://docs.oracle.com/javaee/7/api/javax/inject/Qualifier.html>
+[Scope]: <http://docs.oracle.com/javaee/7/api/javax/inject/Scope.html>
+[Singleton]: <http://docs.oracle.com/javaee/7/api/javax/inject/Singleton.html>
diff --git a/sitemap.md b/sitemap.md
deleted file mode 100644
index 70471e915..000000000
--- a/sitemap.md
+++ /dev/null
@@ -1,8 +0,0 @@
- * [Home](index.md)
- * [User's Guide](users-guide.md)
-   * [Multibindings](multibindings.md)
-   * [Subcomponents](subcomponents.md)
-   * [Migrating from Dagger 1](dagger-1-migration.md)
-   * [Producers](producers.md)
- * [Overview](overview.md)
- * [Disambiguation](disambiguation.md)
diff --git a/subcomponents.md b/subcomponents.md
index 4b4ffc115..2ed6952a4 100644
--- a/subcomponents.md
+++ b/subcomponents.md
@@ -122,6 +122,57 @@ SessionComponent sessionComponent = serverComponent.sessionComponentBuilder()
     .build();
 ```
 
+#### Injecting subcomponent builders
+
+Like the component itself, subcomponent builders are bound in the graph and can
+be injected, too. So instead of injecting the component and calling the subcomponent
+builder method on it, you can inject the builder itself:
+
+```java
+  /** Injecting the subcomponent builder. This is simpler than what's below. */
+  class SessionStarterInjectingSubcomponentBuilder {
+    private final SessionComponent.Builder sessionComponentBuilder;
+    
+    @Inject SessionStarterInjectingSubcomponentBuilder(
+        SessionComponent.Builder sessionComponentBuilder) {
+      this.sessionComponentBuilder = sessionComponentBuilder;
+    }
+    
+    Session startSession() {
+      return sessionComponentBuilder
+          .sessionModule(new SessionModule(…))
+          .build()
+          .session();
+    }
+  }
+
+  /**
+   * Injecting the component and calling the factory method. Not as simple as
+   * what's above.
+   */
+  class SessionStarterInjectingComponent {
+    private final ServerComponent serverComponent;
+    
+    @Inject SessionStarterInjectingComponent(ServerComponent serverComponent) {
+      this.serverComponent = serverComponent;
+    }
+
+    Session startSession() {
+      return serverComponent.sessionComponentBuilder()
+          .sessionModule(new SessionModule(…))
+          .build()
+          .session();
+    }
+  }
+```
+
+Note that `SessionStarterInjectingSubcomponentBuilder` doesn't refer to
+`ServerComponent` at all.
+
+<!-- TODO(dpb):
+     Describe the "subcomponent framework" pattern in detail elsewhere.
+-->
+
 ## Subcomponents and scope
 
 <!-- TODO(dpb,gak): Describe scopes independently from subcomponents. -->
