diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index f78a0e601..add74973e 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -311,6 +311,8 @@ Expression getDependencyArgumentExpression(
               modifiableBindingMethod,
               MethodSpec.methodBuilder(baseMethod.name)
                   .addModifiers(PUBLIC)
+                  // TODO(b/72748365): Mark method as final if binding should not be further
+                  // modified.
                   .returns(baseMethod.returnType)
                   .addAnnotation(Override.class)
                   .addCode(
@@ -367,6 +369,7 @@ private boolean modifiableBindingWillBeFinalized(
       case MISSING:
       case GENERATED_INSTANCE:
       case OPTIONAL:
+      case INJECTION:
         // Once we modify any of the above a single time, then they are finalized.
         return modifyingBinding;
       case MULTIBINDING:
@@ -445,6 +448,7 @@ private BindingExpression createModifiableBindingExpression(
             matchingComponentMethod);
       case OPTIONAL:
       case MULTIBINDING:
+      case INJECTION:
         return wrapInMethod(
             resolvedBindings, request, createBindingExpression(resolvedBindings, request));
       default:
@@ -490,11 +494,14 @@ private ModifiableBindingType getModifiableBindingType(BindingRequest request) {
           && binding.isSyntheticMultibinding()) {
         return ModifiableBindingType.MULTIBINDING;
       }
+
+      if (binding.kind().equals(BindingKind.INJECTION)) {
+        return ModifiableBindingType.INJECTION;
+      }
     } else if (!resolvableBinding(request)) {
       return ModifiableBindingType.MISSING;
     }
 
-    // TODO(b/72748365): Add support for remaining types.
     return ModifiableBindingType.NONE;
   }
 
@@ -537,6 +544,8 @@ private boolean shouldModifyBinding(
         return !generatedComponentModel
             .superclassContributionsMade(request.key())
             .containsAll(resolvedBindings.contributionBinding().dependencies());
+      case INJECTION:
+        return !resolvedBindings.contributionBinding().kind().equals(BindingKind.INJECTION);
       default:
         throw new IllegalStateException(
             String.format(
diff --git a/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
index 095784f37..0da08797d 100644
--- a/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
@@ -33,6 +33,11 @@
  * expression is requested. The method is overridden when generating the implementation of an
  * ancestor component.
  */
+// TODO(b/72748365): There may be unimplemented abstract binding methods even after considering a
+// complete binding graph: If there are @Provides-over-@Inject bindings then there could be branches
+// of dependencies (of the @Inject binding) that have induced abstract modifiable binding methods
+// that are missing in the full binding graph (given the @Provides binding). Such abstract
+// modifiable methods should be overridden and an exception thrown.
 abstract class ModifiableAbstractMethodBindingExpression extends BindingExpression {
   private final GeneratedComponentModel generatedComponentModel;
   private final ModifiableBindingType modifiableBindingType;
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index e3c40dd98..66a88b83a 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -2375,6 +2375,360 @@ public void mapMultibindings_methodDependencies() {
         .hasSourceEquivalentTo(generatedChild);
   }
 
+  @Test
+  public void provisionOverInjection_providedInAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ProvidedInAncestor",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class ProvidedInAncestor {",
+            "  @Inject",
+            "  ProvidedInAncestor(String string) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  ProvidedInAncestor injectedInLeaf();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public ProvidedInAncestor injectedInLeaf() {",
+            "    return new ProvidedInAncestor(getString());",
+            "  }",
+            "",
+            "  public abstract String getString();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  static ProvidedInAncestor provideProvidedInAncestor() {",
+            "    return new ProvidedInAncestor(\"static\");",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public ProvidedInAncestor injectedInLeaf() {",
+            "      return AncestorModule_ProvideProvidedInAncestorFactory",
+            "          .proxyProvideProvidedInAncestor();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void provisionOverInjection_providedInGrandAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ProvidedInGrandAncestor",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class ProvidedInGrandAncestor {",
+            "  @Inject",
+            "  ProvidedInGrandAncestor(String string) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  ProvidedInGrandAncestor injectedInLeaf();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public ProvidedInGrandAncestor injectedInLeaf() {",
+            "    return new ProvidedInGrandAncestor(getString());",
+            "  }",
+            "",
+            "  public abstract String getString();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandAncestorModule.class)",
+            "interface GrandAncestor {",
+            "  Ancestor ancestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class GrandAncestorModule {",
+            "  @Provides",
+            "  static ProvidedInGrandAncestor provideProvidedInGrandAncestor() {",
+            "    return new ProvidedInGrandAncestor(\"static\");",
+            "  }",
+            "}"));
+    JavaFileObject generatedGrandAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
+            "  protected DaggerGrandAncestor() {}",
+            "",
+            "  public abstract class AncestorImpl extends DaggerAncestor {",
+            "    protected AncestorImpl() { super(); }",
+            "",
+            "    public abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      protected LeafImpl() { super(); }",
+            "",
+            "      @Override",
+            "      public ProvidedInGrandAncestor injectedInLeaf() {",
+            "        return GrandAncestorModule_ProvideProvidedInGrandAncestorFactory",
+            "            .proxyProvideProvidedInGrandAncestor();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandAncestor")
+        .hasSourceEquivalentTo(generatedGrandAncestor);
+  }
+
+  @Test
+  public void provisionOverInjection_indirectDependency() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ProvidedInAncestor",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class ProvidedInAncestor {",
+            "  @Inject",
+            "  ProvidedInAncestor(String string) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.InjectedInLeaf",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class InjectedInLeaf {",
+            "  @Inject",
+            "  InjectedInLeaf(ProvidedInAncestor providedInAncestor) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  InjectedInLeaf injectedInLeaf();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public InjectedInLeaf injectedInLeaf() {",
+            "    return new InjectedInLeaf(getProvidedInAncestor());",
+            "  }",
+            "",
+            "  public abstract String getString();",
+            "",
+            "  public ProvidedInAncestor getProvidedInAncestor() {",
+            "    return new ProvidedInAncestor(getString());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  static ProvidedInAncestor provideProvidedInAncestor() {",
+            "    return new ProvidedInAncestor(\"static\");",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public ProvidedInAncestor getProvidedInAncestor() {",
+            "      return AncestorModule_ProvideProvidedInAncestorFactory",
+            "          .proxyProvideProvidedInAncestor();",
+            "    }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
     for (String className : ancillaryClasses) {
@@ -2386,4 +2740,10 @@ private void createAncillaryClasses(
               String.format("class %s { }", className)));
     }
   }
+
+  private static Compilation compile(Iterable<JavaFileObject> files) {
+    return daggerCompiler()
+        .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+        .compile(files);
+  }
 }
