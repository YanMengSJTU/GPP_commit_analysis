diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 9b2646078..cdcac2eb2 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -657,7 +657,8 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
           // If a @Reusable binding was resolved in an ancestor, use that component.
           ResolvedBindings resolvedBindings =
               requestResolver.resolvedContributionBindings.get(binding.key());
-          if (resolvedBindings != null && resolvedBindings.bindings().contains(binding)) {
+          if (resolvedBindings != null
+              && resolvedBindings.contributionBindings().contains(binding)) {
             return Optional.of(requestResolver);
           }
         }
diff --git a/java/dagger/internal/codegen/ResolvedBindings.java b/java/dagger/internal/codegen/ResolvedBindings.java
index 5d1334eff..295c3ea6a 100644
--- a/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/java/dagger/internal/codegen/ResolvedBindings.java
@@ -23,7 +23,7 @@
 
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
-import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableCollection;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
@@ -97,8 +97,8 @@
   }
 
   /** All bindings for {@link #key()}, regardless of which component owns them. */
-  final ImmutableSet<? extends Binding> bindings() {
-    return ImmutableSet.copyOf(allBindings().values());
+  final ImmutableCollection<? extends Binding> bindings() {
+    return allBindings().values();
   }
 
   /**
@@ -116,7 +116,8 @@ final Binding binding() {
    * #optionalBindingDeclarations()}, or {@link #subcomponentDeclarations()}.
    */
   final boolean isEmpty() {
-    return bindings().isEmpty()
+    return allMembersInjectionBindings().isEmpty()
+        && allContributionBindings().isEmpty()
         && multibindingDeclarations().isEmpty()
         && optionalBindingDeclarations().isEmpty()
         && subcomponentDeclarations().isEmpty();
@@ -133,6 +134,10 @@ final boolean isEmpty() {
    */
   @Memoized
   ImmutableSet<ContributionBinding> contributionBindings() {
+    // TODO(ronshapiro): consider optimizing ImmutableSet.copyOf(Collection) for small immutable
+    // collections so that it doesn't need to call toArray(). Even though this method is memoized,
+    // toArray() can take ~150ms for large components, and there are surely other places in the
+    // processor that can benefit from this.
     return ImmutableSet.copyOf(allContributionBindings().values());
   }
 
@@ -151,11 +156,9 @@ final TypeElement owningComponent(ContributionBinding binding) {
    * bindings, or if there is no members-injection binding because the type fails validation.
    */
   final Optional<MembersInjectionBinding> membersInjectionBinding() {
-    ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
-        FluentIterable.from(allMembersInjectionBindings().values()).toSet();
-    return membersInjectionBindings.isEmpty()
+    return allMembersInjectionBindings().isEmpty()
         ? Optional.empty()
-        : Optional.of(Iterables.getOnlyElement(membersInjectionBindings));
+        : Optional.of(Iterables.getOnlyElement(allMembersInjectionBindings().values()));
   }
 
   /** Creates a {@link ResolvedBindings} for contribution bindings. */
@@ -248,7 +251,7 @@ ContributionBinding contributionBinding() {
    */
   final BindingType bindingType() {
     checkState(!isEmpty(), "empty bindings for %s", key());
-    if (bindings().isEmpty()
+    if (allBindings().isEmpty()
         && (!multibindingDeclarations().isEmpty() || !subcomponentDeclarations().isEmpty())) {
       // Only multibinding declarations, so assume provision.
       return BindingType.PROVISION;
@@ -259,6 +262,7 @@ final BindingType bindingType() {
   }
 
   /** The binding types for {@link #bindings()}. */
+  @Memoized
   ImmutableSet<BindingType> bindingTypes() {
     return bindings().stream().map(Binding::bindingType).collect(toImmutableSet());
   }
@@ -280,6 +284,6 @@ public ContributionType contributionType() {
    * @throws IllegalStateException if {@link #bindings()} does not have exactly one element
    */
   Optional<Scope> scope() {
-    return getOnlyElement(bindings()).scope();
+    return binding().scope();
   }
 }
