diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index ec0e38a96..04b769a57 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -250,8 +250,8 @@ java_library(
         "ComponentMethodBindingExpression.java",
         "ComponentProvisionBindingExpression.java",
         "ComponentRequirementBindingExpression.java",
-        "ComponentRequirementField.java",
-        "ComponentRequirementFields.java",
+        "ComponentRequirementExpression.java",
+        "ComponentRequirementExpressions.java",
         "DeferredModifiableBindingExpression.java",
         "DelegateBindingExpression.java",
         "DelegatingFrameworkInstanceCreationExpression.java",
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 3a3e4491c..f715ca47f 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -50,14 +50,14 @@
 
 /** A central repository of code expressions used to access any binding available to a component. */
 final class ComponentBindingExpressions {
-  // TODO(dpb,ronshapiro): refactor this and ComponentRequirementFields into a
+  // TODO(dpb,ronshapiro): refactor this and ComponentRequirementExpressions into a
   // HierarchicalComponentMap<K, V>, or perhaps this use a flattened ImmutableMap, built from its
   // parents? If so, maybe make BindingExpression.Factory create it.
 
   private final Optional<ComponentBindingExpressions> parent;
   private final BindingGraph graph;
   private final ComponentImplementation componentImplementation;
-  private final ComponentRequirementFields componentRequirementFields;
+  private final ComponentRequirementExpressions componentRequirementExpressions;
   private final OptionalFactories optionalFactories;
   private final DaggerTypes types;
   private final DaggerElements elements;
@@ -71,7 +71,7 @@
   ComponentBindingExpressions(
       BindingGraph graph,
       ComponentImplementation componentImplementation,
-      ComponentRequirementFields componentRequirementFields,
+      ComponentRequirementExpressions componentRequirementExpressions,
       OptionalFactories optionalFactories,
       DaggerTypes types,
       DaggerElements elements,
@@ -80,7 +80,7 @@
         Optional.empty(),
         graph,
         componentImplementation,
-        componentRequirementFields,
+        componentRequirementExpressions,
         new StaticSwitchingProviders(componentImplementation, types),
         optionalFactories,
         types,
@@ -92,7 +92,7 @@ private ComponentBindingExpressions(
       Optional<ComponentBindingExpressions> parent,
       BindingGraph graph,
       ComponentImplementation componentImplementation,
-      ComponentRequirementFields componentRequirementFields,
+      ComponentRequirementExpressions componentRequirementExpressions,
       StaticSwitchingProviders staticSwitchingProviders,
       OptionalFactories optionalFactories,
       DaggerTypes types,
@@ -101,7 +101,7 @@ private ComponentBindingExpressions(
     this.parent = parent;
     this.graph = graph;
     this.componentImplementation = componentImplementation;
-    this.componentRequirementFields = checkNotNull(componentRequirementFields);
+    this.componentRequirementExpressions = checkNotNull(componentRequirementExpressions);
     this.optionalFactories = checkNotNull(optionalFactories);
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
@@ -127,12 +127,12 @@ private ComponentBindingExpressions(
   ComponentBindingExpressions forChildComponent(
       BindingGraph childGraph,
       ComponentImplementation childComponentImplementation,
-      ComponentRequirementFields childComponentRequirementFields) {
+      ComponentRequirementExpressions childComponentRequirementExpressions) {
     return new ComponentBindingExpressions(
         Optional.of(this),
         childGraph,
         childComponentImplementation,
-        childComponentRequirementFields,
+        childComponentRequirementExpressions,
         staticSwitchingProviders,
         optionalFactories,
         types,
@@ -183,7 +183,7 @@ CodeBlock getCreateMethodArgumentsCodeBlock(ContributionBinding binding) {
 
     if (binding.requiresModuleInstance()) {
       arguments.add(
-          componentRequirementFields.getExpressionDuringInitialization(
+          componentRequirementExpressions.getExpressionDuringInitialization(
               ComponentRequirement.forModule(binding.contributingModule().get().asType()),
               componentImplementation.name()));
     }
@@ -353,7 +353,11 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
 
       case COMPONENT_PROVISION:
         return new DependencyMethodProviderCreationExpression(
-            binding, componentImplementation, componentRequirementFields, compilerOptions, graph);
+            binding,
+            componentImplementation,
+            componentRequirementExpressions,
+            compilerOptions,
+            graph);
 
       case SUBCOMPONENT_BUILDER:
         return new SubcomponentBuilderProviderCreationExpression(
@@ -367,7 +371,7 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
 
       case COMPONENT_PRODUCTION:
         return new DependencyMethodProducerCreationExpression(
-            binding, componentImplementation, componentRequirementFields, graph);
+            binding, componentImplementation, componentRequirementExpressions, graph);
 
       case PRODUCTION:
         return new ProducerCreationExpression(binding, this);
@@ -400,7 +404,7 @@ private InstanceFactoryCreationExpression instanceFactoryCreationExpression(
     return new InstanceFactoryCreationExpression(
         binding.nullableType().isPresent(),
         () ->
-            componentRequirementFields.getExpressionDuringInitialization(
+            componentRequirementExpressions.getExpressionDuringInitialization(
                 componentRequirement, componentImplementation.name()));
   }
 
@@ -551,12 +555,12 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
             new ComponentRequirementBindingExpression(
                 resolvedBindings,
                 ComponentRequirement.forDependency(resolvedBindings.key().type()),
-                componentRequirementFields));
+                componentRequirementExpressions));
 
       case COMPONENT_PROVISION:
         return Optional.of(
             new ComponentProvisionBindingExpression(
-                resolvedBindings, graph, componentRequirementFields, compilerOptions));
+                resolvedBindings, graph, componentRequirementExpressions, compilerOptions));
 
       case SUBCOMPONENT_BUILDER:
         return Optional.of(
@@ -582,7 +586,7 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
             new ComponentRequirementBindingExpression(
                 resolvedBindings,
                 ComponentRequirement.forBoundInstance(resolvedBindings.contributionBinding()),
-                componentRequirementFields));
+                componentRequirementExpressions));
 
       case INJECTION:
       case PROVISION:
@@ -592,7 +596,7 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
                 compilerOptions,
                 this,
                 membersInjectionMethods,
-                componentRequirementFields,
+                componentRequirementExpressions,
                 types,
                 elements));
 
diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index 22a4fc4b6..06d345c34 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -29,6 +29,7 @@
 import com.google.common.base.Supplier;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.MultimapBuilder;
@@ -47,6 +48,7 @@
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -154,6 +156,7 @@
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
   private final List<CodeBlock> initializations = new ArrayList<>();
+  private final List<CodeBlock> componentRequirementInitializations = new ArrayList<>();
   private final Set<Key> cancellableProducerKeys = new LinkedHashSet<>();
   private final ListMultimap<FieldSpecKind, FieldSpec> fieldSpecsMap =
       MultimapBuilder.enumKeys(FieldSpecKind.class).arrayListValues().build();
@@ -168,6 +171,7 @@
   private final SetMultimap<BindingRequest, DependencyRequest> multibindingContributionsMade =
       HashMultimap.create();
   private Optional<MethodSpec> configureInitializationMethod = Optional.empty();
+  private final Map<ComponentRequirement, String> modifiableModuleMethods = new LinkedHashMap<>();
 
   ComponentImplementation(
       ComponentDescriptor componentDescriptor,
@@ -406,6 +410,13 @@ void addImplementedModifiableBindingMethod(ModifiableBindingMethod method) {
     methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, method.methodSpec());
   }
 
+  /** Add's a modifiable module method to this implementation. */
+  void addModifiableModuleMethod(ComponentRequirement module, MethodSpec method) {
+    checkArgument(module.kind().isModule());
+    checkState(modifiableModuleMethods.put(module, method.name) == null);
+    methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, method);
+  }
+
   /** Adds the given type to the component. */
   void addType(TypeSpecKind typeKind, TypeSpec typeSpec) {
     typeSpecsMap.put(typeKind, typeSpec);
@@ -432,6 +443,14 @@ void addInitialization(CodeBlock codeBlock) {
     initializations.add(codeBlock);
   }
 
+  /**
+   * Adds the given code block that initializes a {@link ComponentRequirement} to the component
+   * implementation.
+   */
+  void addComponentRequirementInitialization(CodeBlock codeBlock) {
+    componentRequirementInitializations.add(codeBlock);
+  }
+
   /**
    * Marks the given key of a producer as one that should have a cancellation statement in the
    * cancellation listener method of the component.
@@ -485,6 +504,19 @@ void claimMethodName(CharSequence name) {
     return ImmutableList.copyOf(initializations);
   }
 
+  /**
+   * Returns the list of {@link CodeBlock}s that initialize {@link ComponentRequirement}s. These
+   * initializations are kept separate from {@link #getInitializations()} because they must be
+   * executed before the initializations of any framework instance initializations in a superclass
+   * implementation that may depend on the instances. We cannot use the same strategy that we use
+   * for framework instances (i.e. wrap in a {@link dagger.internal.DelegateFactory} or {@link
+   * dagger.producers.internal.DelegateProducer} since the types of these initialized fields have no
+   * interface type that we can write a proxy for.
+   */
+  ImmutableList<CodeBlock> getComponentRequirementInitializations() {
+    return ImmutableList.copyOf(componentRequirementInitializations);
+  }
+
   /**
    * Returns the list of producer {@link Key}s that need cancellation statements in the cancellation
    * listener method.
@@ -521,14 +553,15 @@ void claimMethodName(CharSequence name) {
   }
 
   /**
-   * Returns the names of every modifiable binding method of this implementation and any superclass
+   * Returns the names of every modifiable method of this implementation and any superclass
    * implementations.
    */
-  ImmutableSet<String> getAllModifiableBindingMethodNames() {
+  ImmutableSet<String> getAllModifiableMethodNames() {
     ImmutableSet.Builder<String> names = ImmutableSet.builder();
     modifiableBindingMethods.allMethods().forEach(method -> names.add(method.methodSpec().name));
+    names.addAll(modifiableModuleMethods.values());
     superclassImplementation.ifPresent(
-        superclass -> names.addAll(superclass.getAllModifiableBindingMethodNames()));
+        superclass -> names.addAll(superclass.getAllModifiableMethodNames()));
     return names.build();
   }
 
@@ -553,6 +586,34 @@ void claimMethodName(CharSequence name) {
         .flatMap(superImplementation -> superImplementation.getModifiableBindingMethod(request));
   }
 
+  /**
+   * Returns the names of modifiable module methods for this implementation and all inherited
+   * implementations, keyed by the corresponding module's {@link ComponentRequirement}.
+   */
+  ImmutableMap<ComponentRequirement, String> getAllModifiableModuleMethods() {
+    ImmutableMap.Builder<ComponentRequirement, String> methods = ImmutableMap.builder();
+    methods.putAll(modifiableModuleMethods);
+    superclassImplementation.ifPresent(
+        superclass -> methods.putAll(superclass.getAllModifiableModuleMethods()));
+    return methods.build();
+  }
+
+  /**
+   * Returns the name of the modifiable module method for {@code module} that is inherited in this
+   * implementation, or empty if none has been defined.
+   */
+  Optional<String> supertypeModifiableModuleMethodName(ComponentRequirement module) {
+    checkArgument(module.kind().isModule());
+    if (!superclassImplementation.isPresent()) {
+      return Optional.empty();
+    }
+    String methodName = superclassImplementation.get().modifiableModuleMethods.get(module);
+    if (methodName == null) {
+      return superclassImplementation.get().supertypeModifiableModuleMethodName(module);
+    }
+    return Optional.of(methodName);
+  }
+
   /** Generates the component and returns the resulting {@link TypeSpec.Builder}. */
   TypeSpec.Builder generate() {
     fieldSpecsMap.asMap().values().forEach(component::addFields);
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
index a4f162454..9f8623021 100644
--- a/java/dagger/internal/codegen/ComponentImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -31,6 +31,7 @@
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.COMPONENT_METHOD;
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.CONSTRUCTOR;
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.INITIALIZE_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.MODIFIABLE_BINDING_METHOD;
 import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.COMPONENT_CREATOR;
 import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.SUBCOMPONENT;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
@@ -52,6 +53,7 @@
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
@@ -111,13 +113,13 @@ ComponentImplementation createComponentImplementation(BindingGraph bindingGraph)
         ComponentCreatorImplementation.create(
             componentImplementation, bindingGraph, elements, types);
     componentImplementation.setCreatorImplementation(componentCreatorImplementation);
-    ComponentRequirementFields componentRequirementFields =
-        new ComponentRequirementFields(bindingGraph, componentImplementation);
+    ComponentRequirementExpressions componentRequirementExpressions =
+        new ComponentRequirementExpressions(bindingGraph, componentImplementation, types, elements);
     ComponentBindingExpressions bindingExpressions =
         new ComponentBindingExpressions(
             bindingGraph,
             componentImplementation,
-            componentRequirementFields,
+            componentRequirementExpressions,
             optionalFactories,
             types,
             elements,
@@ -134,7 +136,7 @@ ComponentImplementation createComponentImplementation(BindingGraph bindingGraph)
               componentImplementation,
               optionalFactories,
               bindingExpressions,
-              componentRequirementFields)
+              componentRequirementExpressions)
           .build();
     } else {
       return new RootComponentImplementationBuilder(
@@ -142,7 +144,7 @@ ComponentImplementation createComponentImplementation(BindingGraph bindingGraph)
               componentImplementation,
               optionalFactories,
               bindingExpressions,
-              componentRequirementFields)
+              componentRequirementExpressions)
           .build();
     }
   }
@@ -162,7 +164,7 @@ ComponentImplementation topLevelImplementation(ClassName name, BindingGraph grap
   private abstract class ComponentImplementationBuilder {
     final BindingGraph graph;
     final ComponentBindingExpressions bindingExpressions;
-    final ComponentRequirementFields componentRequirementFields;
+    final ComponentRequirementExpressions componentRequirementExpressions;
     final ComponentImplementation componentImplementation;
     final OptionalFactories optionalFactories;
     boolean done;
@@ -172,12 +174,12 @@ ComponentImplementation topLevelImplementation(ClassName name, BindingGraph grap
         ComponentImplementation componentImplementation,
         OptionalFactories optionalFactories,
         ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields) {
+        ComponentRequirementExpressions componentRequirementExpressions) {
       this.graph = graph;
       this.componentImplementation = componentImplementation;
       this.optionalFactories = optionalFactories;
       this.bindingExpressions = bindingExpressions;
-      this.componentRequirementFields = componentRequirementFields;
+      this.componentRequirementExpressions = componentRequirementExpressions;
     }
 
     /**
@@ -203,13 +205,15 @@ final ComponentImplementation build() {
           .ifPresent(
               superclassImplementation -> {
                 superclassImplementation
-                    .getAllModifiableBindingMethodNames()
+                    .getAllModifiableMethodNames()
                     .forEach(componentImplementation::claimMethodName);
               });
 
       addFactoryMethods();
       addInterfaceMethods();
       addChildComponents();
+      implementModifiableModuleMethods();
+
       addConstructor();
 
       if (graph.componentDescriptor().kind().isProducer()) {
@@ -348,6 +352,34 @@ final void addCancellationListenerImplementation() {
       return Optional.empty();
     }
 
+    /**
+     * For final components, reimplements all modifiable module methods that may have been modified.
+     */
+    private void implementModifiableModuleMethods() {
+      if (componentImplementation.isAbstract()) {
+        return;
+      }
+      componentImplementation
+          .getAllModifiableModuleMethods()
+          .forEach(this::implementModifiableModuleMethod);
+    }
+
+    private void implementModifiableModuleMethod(ComponentRequirement module, String methodName) {
+      // TODO(b/117833324): only reimplement methods for modules that were abstract or were repeated
+      // by an ancestor component.
+      componentImplementation.addMethod(
+          MODIFIABLE_BINDING_METHOD,
+          methodBuilder(methodName)
+              .addAnnotation(Override.class)
+              .addModifiers(PROTECTED)
+              .returns(TypeName.get(module.type()))
+              .addStatement(
+                  "return $L",
+                  componentRequirementExpressions.getExpression(
+                      module, componentImplementation.name()))
+              .build());
+    }
+
     final MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
       return MethodSignature.forComponentMethod(
           method, MoreTypes.asDeclared(graph.componentTypeElement().asType()), types);
@@ -395,18 +427,18 @@ final ComponentImplementation buildChildImplementation(BindingGraph childGraph)
       Optional<ComponentCreatorImplementation> childCreatorImplementation =
           ComponentCreatorImplementation.create(childImplementation, childGraph, elements, types);
       childImplementation.setCreatorImplementation(childCreatorImplementation);
-      ComponentRequirementFields childComponentRequirementFields =
-          componentRequirementFields.forChildComponent(childGraph, childImplementation);
+      ComponentRequirementExpressions childComponentRequirementExpressions =
+          componentRequirementExpressions.forChildComponent(childGraph, childImplementation);
       ComponentBindingExpressions childBindingExpressions =
           bindingExpressions.forChildComponent(
-              childGraph, childImplementation, childComponentRequirementFields);
+              childGraph, childImplementation, childComponentRequirementExpressions);
       return new SubcomponentImplementationBuilder(
               Optional.of(this),
               childGraph,
               childImplementation,
               optionalFactories,
               childBindingExpressions,
-              childComponentRequirementFields)
+              childComponentRequirementExpressions)
           .build();
     }
 
@@ -433,6 +465,8 @@ final ComponentImplementation concreteSubcomponent(ComponentDescriptor child) {
     final void addConstructor() {
       List<List<CodeBlock>> partitions =
           Lists.partition(componentImplementation.getInitializations(), STATEMENTS_PER_METHOD);
+      ImmutableList<CodeBlock> componentRequirementInitializations =
+          componentImplementation.getComponentRequirementInitializations();
 
       ImmutableList<ParameterSpec> constructorParameters = constructorParameters();
       MethodSpec.Builder constructor =
@@ -444,10 +478,15 @@ final void addConstructor() {
       }
 
       Optional<MethodSpec.Builder> configureInitialization =
-          partitions.isEmpty() || !componentImplementation.isAbstract()
+          (partitions.isEmpty() && componentRequirementInitializations.isEmpty())
+                  || !componentImplementation.isAbstract()
               ? Optional.empty()
               : Optional.of(configureInitializationMethodBuilder(constructorParameters));
 
+      configureInitialization
+          .orElse(constructor)
+          .addCode(CodeBlocks.concat(componentRequirementInitializations));
+
       if (componentImplementation.superConfigureInitializationMethod().isPresent()) {
         MethodSpec superConfigureInitializationMethod =
             componentImplementation.superConfigureInitializationMethod().get();
@@ -571,13 +610,13 @@ final void addConstructor() {
         ComponentImplementation componentImplementation,
         OptionalFactories optionalFactories,
         ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields) {
+        ComponentRequirementExpressions componentRequirementExpressions) {
       super(
           graph,
           componentImplementation,
           optionalFactories,
           bindingExpressions,
-          componentRequirementFields);
+          componentRequirementExpressions);
       this.componentCreatorName = componentImplementation.creatorImplementation().get().name();
     }
 
@@ -642,13 +681,13 @@ boolean canInstantiateAllRequirements() {
         ComponentImplementation componentImplementation,
         OptionalFactories optionalFactories,
         ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields) {
+        ComponentRequirementExpressions componentRequirementExpressions) {
       super(
           graph,
           componentImplementation,
           optionalFactories,
           bindingExpressions,
-          componentRequirementFields);
+          componentRequirementExpressions);
       this.parent = parent;
     }
 
diff --git a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
index 0f6c0be78..723673ba6 100644
--- a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
@@ -26,18 +26,18 @@
 final class ComponentProvisionBindingExpression extends SimpleInvocationBindingExpression {
   private final ProvisionBinding binding;
   private final BindingGraph bindingGraph;
-  private final ComponentRequirementFields componentRequirementFields;
+  private final ComponentRequirementExpressions componentRequirementExpressions;
   private final CompilerOptions compilerOptions;
 
   ComponentProvisionBindingExpression(
       ResolvedBindings resolvedBindings,
       BindingGraph bindingGraph,
-      ComponentRequirementFields componentRequirementFields,
+      ComponentRequirementExpressions componentRequirementExpressions,
       CompilerOptions compilerOptions) {
     super(resolvedBindings);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     this.bindingGraph = checkNotNull(bindingGraph);
-    this.componentRequirementFields = checkNotNull(componentRequirementFields);
+    this.componentRequirementExpressions = checkNotNull(componentRequirementExpressions);
     this.compilerOptions = checkNotNull(compilerOptions);
   }
 
@@ -46,7 +46,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
     CodeBlock invocation =
         CodeBlock.of(
             "$L.$L()",
-            componentRequirementFields.getExpression(componentRequirement(), requestingClass),
+            componentRequirementExpressions.getExpression(componentRequirement(), requestingClass),
             binding.bindingElement().get().getSimpleName());
     return Expression.create(
         binding.contributedPrimitiveType().orElse(binding.key().type()),
diff --git a/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java b/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
index f00502bdc..e0cdd5a46 100644
--- a/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
@@ -25,21 +25,21 @@
  */
 final class ComponentRequirementBindingExpression extends SimpleInvocationBindingExpression {
   private final ComponentRequirement componentRequirement;
-  private final ComponentRequirementFields componentRequirementFields;
+  private final ComponentRequirementExpressions componentRequirementExpressions;
 
   ComponentRequirementBindingExpression(
       ResolvedBindings resolvedBindings,
       ComponentRequirement componentRequirement,
-      ComponentRequirementFields componentRequirementFields) {
+      ComponentRequirementExpressions componentRequirementExpressions) {
     super(resolvedBindings);
     this.componentRequirement = componentRequirement;
-    this.componentRequirementFields = componentRequirementFields;
+    this.componentRequirementExpressions = componentRequirementExpressions;
   }
 
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
     return Expression.create(
         componentRequirement.type(),
-        componentRequirementFields.getExpression(componentRequirement, requestingClass));
+        componentRequirementExpressions.getExpression(componentRequirement, requestingClass));
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentRequirementField.java b/java/dagger/internal/codegen/ComponentRequirementExpression.java
similarity index 72%
rename from java/dagger/internal/codegen/ComponentRequirementField.java
rename to java/dagger/internal/codegen/ComponentRequirementExpression.java
index b9c478539..540d00cff 100644
--- a/java/dagger/internal/codegen/ComponentRequirementField.java
+++ b/java/dagger/internal/codegen/ComponentRequirementExpression.java
@@ -25,11 +25,11 @@
  * {@link dagger.model.Key}. See {@link ComponentRequirementBindingExpression} for binding
  * expressions that are themselves a component requirement.
  */
-interface ComponentRequirementField {
+interface ComponentRequirementExpression {
   /**
    * Returns an expression for the {@link ComponentRequirement} to be used when implementing a
-   * component method. This may add a field to the component in order to reference the component
-   * requirement outside of the {@code initialize()} methods.
+   * component method. This may add a field or method to the component in order to reference the
+   * component requirement outside of the {@code initialize()} methods.
    */
   CodeBlock getExpression(ClassName requestingClass);
 
@@ -37,8 +37,10 @@
    * Returns an expression for the {@link ComponentRequirement} to be used only within {@code
    * initialize()} methods, where the component builder is available.
    *
-   * <p>When accessing this field from a subcomponent, this may cause a field to be initialized in
-   * the component that owns this {@link ComponentRequirement}.
+   * <p>When accessing this expression from a subcomponent, this may cause a field to be initialized
+   * or a method to be added in the component that owns this {@link ComponentRequirement}.
    */
-  CodeBlock getExpressionDuringInitialization(ClassName requestingClass);
+  default CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
+    return getExpression(requestingClass);
+  }
 }
diff --git a/java/dagger/internal/codegen/ComponentRequirementFields.java b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
similarity index 56%
rename from java/dagger/internal/codegen/ComponentRequirementFields.java
rename to java/dagger/internal/codegen/ComponentRequirementExpressions.java
index fc07e486b..0638167f3 100644
--- a/java/dagger/internal/codegen/ComponentRequirementFields.java
+++ b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
@@ -16,15 +16,23 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Suppliers.memoize;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.COMPONENT_REQUIREMENT_FIELD;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
 
 import com.google.common.base.Supplier;
+import com.google.common.base.Suppliers;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeName;
 import dagger.internal.Preconditions;
@@ -33,75 +41,100 @@
 import java.util.Optional;
 
 /**
- * A central repository of fields used to access any {@link ComponentRequirement} available to a
- * component.
+ * A central repository of expressions used to access any {@link ComponentRequirement} available to
+ * a component.
  */
-final class ComponentRequirementFields {
+final class ComponentRequirementExpressions {
 
   // TODO(dpb,ronshapiro): refactor this and ComponentBindingExpressions into a
   // HierarchicalComponentMap<K, V>, or perhaps this use a flattened ImmutableMap, built from its
-  // parents? If so, maybe make ComponentRequirementField.Factory create it.
+  // parents? If so, maybe make ComponentRequirementExpression.Factory create it.
 
-  private final Optional<ComponentRequirementFields> parent;
-  private final Map<ComponentRequirement, ComponentRequirementField> componentRequirementFields =
-      new HashMap<>();
+  private final Optional<ComponentRequirementExpressions> parent;
+  private final Map<ComponentRequirement, ComponentRequirementExpression>
+      componentRequirementExpressions = new HashMap<>();
   private final BindingGraph graph;
   private final ComponentImplementation componentImplementation;
+  private final DaggerTypes types;
+  private final DaggerElements elements;
 
-  private ComponentRequirementFields(
-      Optional<ComponentRequirementFields> parent,
+  private ComponentRequirementExpressions(
+      Optional<ComponentRequirementExpressions> parent,
       BindingGraph graph,
-      ComponentImplementation componentImplementation) {
+      ComponentImplementation componentImplementation,
+      DaggerTypes types,
+      DaggerElements elements) {
     this.parent = parent;
     this.graph = graph;
     this.componentImplementation = componentImplementation;
+    this.types = types;
+    this.elements = elements;
   }
 
   // TODO(ronshapiro): give ComponentImplementation a graph() method
-  ComponentRequirementFields(BindingGraph graph, ComponentImplementation componentImplementation) {
-    this(Optional.empty(), graph, componentImplementation);
+  ComponentRequirementExpressions(
+      BindingGraph graph,
+      ComponentImplementation componentImplementation,
+      DaggerTypes types,
+      DaggerElements elements) {
+    this(Optional.empty(), graph, componentImplementation, types, elements);
   }
 
-  /** Returns a new object representing the fields available from a child component of this one. */
-  ComponentRequirementFields forChildComponent(
+  /**
+   * Returns a new object representing the expressions available from a child component of this one.
+   */
+  ComponentRequirementExpressions forChildComponent(
       BindingGraph graph, ComponentImplementation componentImplementation) {
-    return new ComponentRequirementFields(Optional.of(this), graph, componentImplementation);
+    return new ComponentRequirementExpressions(
+        Optional.of(this), graph, componentImplementation, types, elements);
   }
 
   /**
    * Returns an expression for the {@code componentRequirement} to be used when implementing a
-   * component method. This may add a field to the component in order to reference the component
-   * requirement outside of the {@code initialize()} methods.
+   * component method. This may add a field or method to the component in order to reference the
+   * component requirement outside of the {@code initialize()} methods.
    */
   CodeBlock getExpression(ComponentRequirement componentRequirement, ClassName requestingClass) {
-    return getField(componentRequirement).getExpression(requestingClass);
+    return getExpression(componentRequirement).getExpression(requestingClass);
   }
 
   /**
    * Returns an expression for the {@code componentRequirement} to be used only within {@code
    * initialize()} methods, where the component builder is available.
    *
-   * <p>When accessing this field from a subcomponent, this may cause a field to be initialized in
-   * the component that owns this {@link ComponentRequirement}.
+   * <p>When accessing this expression from a subcomponent, this may cause a field to be initialized
+   * or a method to be added in the component that owns this {@link ComponentRequirement}.
    */
   CodeBlock getExpressionDuringInitialization(
       ComponentRequirement componentRequirement, ClassName requestingClass) {
-    return getField(componentRequirement).getExpressionDuringInitialization(requestingClass);
+    return getExpression(componentRequirement).getExpressionDuringInitialization(requestingClass);
   }
 
-  ComponentRequirementField getField(ComponentRequirement componentRequirement) {
+  ComponentRequirementExpression getExpression(ComponentRequirement componentRequirement) {
     if (graph.componentRequirements().contains(componentRequirement)) {
-      return componentRequirementFields.computeIfAbsent(componentRequirement, this::create);
+      return componentRequirementExpressions.computeIfAbsent(
+          componentRequirement, this::createMethodOrField);
     }
     if (parent.isPresent()) {
-      return parent.get().getField(componentRequirement);
+      return parent.get().getExpression(componentRequirement);
     }
     throw new IllegalStateException(
-        "no component requirement field found for " + componentRequirement);
+        "no component requirement expression found for " + componentRequirement);
   }
 
-  /** Returns a {@link ComponentRequirementField} for a {@link ComponentRequirement}. */
-  private ComponentRequirementField create(ComponentRequirement requirement) {
+  /**
+   * If {@code requirement} is a module that may be owned by a future ancestor component, returns a
+   * modifiable module method. Otherwise, returns a field for {@code requirement}.
+   */
+  private ComponentRequirementExpression createMethodOrField(ComponentRequirement requirement) {
+    if (componentImplementation.isAbstract() && requirement.kind().isModule()) {
+      return new ModifiableModule(requirement);
+    }
+    return createField(requirement);
+  }
+
+  /** Returns a field for a {@link ComponentRequirement}. */
+  private ComponentRequirementExpression createField(ComponentRequirement requirement) {
     Optional<ComponentCreatorImplementation> creatorImplementation =
         Optionals.firstPresent(
             componentImplementation.baseImplementation().flatMap(c -> c.creatorImplementation()),
@@ -122,7 +155,7 @@ private ComponentRequirementField create(ComponentRequirement requirement) {
     }
   }
 
-  private abstract static class AbstractField implements ComponentRequirementField {
+  private abstract static class AbstractField implements ComponentRequirementExpression {
     private final ComponentRequirement componentRequirement;
     private final ComponentImplementation componentImplementation;
     private final Supplier<MemberSelect> field = memoize(this::createField);
@@ -139,11 +172,6 @@ public CodeBlock getExpression(ClassName requestingClass) {
       return field.get().getExpressionFor(requestingClass);
     }
 
-    @Override
-    public CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
-      return getExpression(requestingClass);
-    }
-
     private MemberSelect createField() {
       // TODO(dpb,ronshapiro): think about whether ComponentImplementation.addField
       // should make a unique name for the field.
@@ -152,7 +180,7 @@ private MemberSelect createField() {
       FieldSpec field =
           FieldSpec.builder(TypeName.get(componentRequirement.type()), fieldName, PRIVATE).build();
       componentImplementation.addField(COMPONENT_REQUIREMENT_FIELD, field);
-      componentImplementation.addInitialization(fieldInitialization(field));
+      componentImplementation.addComponentRequirementInitialization(fieldInitialization(field));
       return MemberSelect.localField(componentImplementation.name(), fieldName);
     }
 
@@ -161,8 +189,8 @@ private MemberSelect createField() {
   }
 
   /**
-   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a corresponding
-   * field on the component builder.
+   * A {@link ComponentRequirementExpression} for {@link ComponentRequirement}s that have a
+   * corresponding field on the component builder.
    */
   private static final class BuilderField extends AbstractField {
     private final FieldSpec builderField;
@@ -193,8 +221,8 @@ CodeBlock fieldInitialization(FieldSpec componentField) {
   }
 
   /**
-   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that can be instantiated
-   * by the component (i.e. a static class with a no-arg constructor).
+   * A {@link ComponentRequirementExpression} for {@link ComponentRequirement}s that can be
+   * instantiated by the component (i.e. a static class with a no-arg constructor).
    */
   private static final class ComponentInstantiableField extends AbstractField {
     private ComponentInstantiableField(
@@ -210,7 +238,7 @@ CodeBlock fieldInitialization(FieldSpec componentField) {
   }
 
   /**
-   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that are passed in
+   * A {@link ComponentRequirementExpression} for {@link ComponentRequirement}s that are passed in
    * as parameters to a component factory method.
    */
   private static final class ComponentParameterField extends AbstractField {
@@ -230,4 +258,50 @@ CodeBlock fieldInitialization(FieldSpec componentField) {
           "this.$N = $T.checkNotNull($N);", componentField, Preconditions.class, factoryParameter);
     }
   }
+
+  private final class ModifiableModule implements ComponentRequirementExpression {
+    private final ComponentRequirement module;
+    private final Supplier<MemberSelect> method = Suppliers.memoize(this::methodSelect);
+
+    private ModifiableModule(ComponentRequirement module) {
+      checkArgument(module.kind().isModule());
+      this.module = module;
+    }
+
+    @Override
+    public CodeBlock getExpression(ClassName requestingClass) {
+      return method.get().getExpressionFor(requestingClass);
+    }
+
+    private MemberSelect methodSelect() {
+      String methodName =
+          componentImplementation
+              .supertypeModifiableModuleMethodName(module)
+              .orElseGet(this::createMethod);
+      return MemberSelect.localMethod(componentImplementation.name(), methodName);
+    }
+
+    private String createMethod() {
+      String methodName =
+          UPPER_CAMEL.to(
+              LOWER_CAMEL,
+              componentImplementation.getUniqueMethodName(
+                  module.typeElement().getSimpleName().toString()));
+      MethodSpec.Builder methodBuilder =
+          methodBuilder(methodName)
+              .addModifiers(PROTECTED)
+              .returns(TypeName.get(module.type()));
+      // TODO(b/117833324): if the module is instantiable, we could provide an implementation here
+      // too. Then, if no ancestor ever repeats the module, there's nothing to do in subclasses.
+      if (graph.componentDescriptor().creatorDescriptor().isPresent()) {
+        methodBuilder.addStatement(
+            "return $L",
+            createField(module).getExpression(componentImplementation.name()));
+      } else {
+        methodBuilder.addModifiers(ABSTRACT);
+      }
+      componentImplementation.addModifiableModuleMethod(module, methodBuilder.build());
+      return methodName;
+    }
+  }
 }
diff --git a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
index acfdb99fc..909d9921c 100644
--- a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
@@ -41,17 +41,17 @@
     implements FrameworkInstanceCreationExpression {
   private final ContributionBinding binding;
   private final ComponentImplementation componentImplementation;
-  private final ComponentRequirementFields componentRequirementFields;
+  private final ComponentRequirementExpressions componentRequirementExpressions;
   private final BindingGraph graph;
 
   DependencyMethodProducerCreationExpression(
       ContributionBinding binding,
       ComponentImplementation componentImplementation,
-      ComponentRequirementFields componentRequirementFields,
+      ComponentRequirementExpressions componentRequirementExpressions,
       BindingGraph graph) {
     this.binding = checkNotNull(binding);
     this.componentImplementation = checkNotNull(componentImplementation);
-    this.componentRequirementFields = checkNotNull(componentRequirementFields);
+    this.componentRequirementExpressions = checkNotNull(componentRequirementExpressions);
     this.graph = checkNotNull(graph);
   }
 
@@ -63,7 +63,7 @@ public CodeBlock creationExpression() {
         FieldSpec.builder(
                 ClassName.get(dependency.typeElement()), dependency.variableName(), PRIVATE, FINAL)
             .initializer(
-                componentRequirementFields.getExpressionDuringInitialization(
+                componentRequirementExpressions.getExpressionDuringInitialization(
                     dependency, componentImplementation.name()))
             .build();
     // TODO(b/70395982): Explore using a private static type instead of an anonymous class.
diff --git a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
index 128e28663..485f389ab 100644
--- a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
@@ -45,7 +45,7 @@
     implements FrameworkInstanceCreationExpression {
 
   private final ComponentImplementation componentImplementation;
-  private final ComponentRequirementFields componentRequirementFields;
+  private final ComponentRequirementExpressions componentRequirementExpressions;
   private final CompilerOptions compilerOptions;
   private final BindingGraph graph;
   private final ContributionBinding binding;
@@ -53,12 +53,12 @@
   DependencyMethodProviderCreationExpression(
       ContributionBinding binding,
       ComponentImplementation componentImplementation,
-      ComponentRequirementFields componentRequirementFields,
+      ComponentRequirementExpressions componentRequirementExpressions,
       CompilerOptions compilerOptions,
       BindingGraph graph) {
     this.binding = checkNotNull(binding);
     this.componentImplementation = checkNotNull(componentImplementation);
-    this.componentRequirementFields = checkNotNull(componentRequirementFields);
+    this.componentRequirementExpressions = checkNotNull(componentRequirementExpressions);
     this.compilerOptions = checkNotNull(compilerOptions);
     this.graph = checkNotNull(graph);
   }
@@ -104,7 +104,7 @@ public CodeBlock creationExpression() {
     return CodeBlock.of(
         "new $T($L)",
         factoryClassName(),
-        componentRequirementFields.getExpressionDuringInitialization(
+        componentRequirementExpressions.getExpressionDuringInitialization(
             dependency(), componentImplementation.name()));
   }
 
diff --git a/java/dagger/internal/codegen/MemberSelect.java b/java/dagger/internal/codegen/MemberSelect.java
index cad733c73..2806207ff 100644
--- a/java/dagger/internal/codegen/MemberSelect.java
+++ b/java/dagger/internal/codegen/MemberSelect.java
@@ -67,8 +67,35 @@ static MemberSelect localField(ClassName owningClass, String fieldName) {
     @Override
     CodeBlock getExpressionFor(ClassName usingClass) {
       return owningClass().equals(usingClass)
-          ? CodeBlock.of("$L", fieldName)
-          : CodeBlock.of("$T.this.$L", owningClass(), fieldName);
+          ? CodeBlock.of("$N", fieldName)
+          : CodeBlock.of("$T.this.$N", owningClass(), fieldName);
+    }
+  }
+
+  /**
+   * Returns a {@link MemberSelect} that accesses the method given by {@code methodName} owned by
+   * {@code owningClass}. In this context "local" refers to the fact that the method is owned by the
+   * type (or an enclosing type) from which the code block will be used. The returned {@link
+   * MemberSelect} will not be valid for accessing the method from a different class (regardless of
+   * accessibility).
+   */
+  static MemberSelect localMethod(ClassName owningClass, String methodName) {
+    return new LocalMethod(owningClass, methodName);
+  }
+
+  private static final class LocalMethod extends MemberSelect {
+    final String methodName;
+
+    LocalMethod(ClassName owningClass, String methodName) {
+      super(owningClass, false);
+      this.methodName = checkNotNull(methodName);
+    }
+
+    @Override
+    CodeBlock getExpressionFor(ClassName usingClass) {
+      return owningClass().equals(usingClass)
+          ? CodeBlock.of("$N()", methodName)
+          : CodeBlock.of("$T.this.$N()", owningClass(), methodName);
     }
   }
 
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index 60d0301c6..c6a699431 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -181,7 +181,6 @@ private boolean modifiableBindingWillBeFinalized(
         // scope to allow us to make this distinction.
         return false;
       case MULTIBINDING:
-      case MODULE_INSTANCE:
         return false;
       default:
         throw new IllegalStateException(
@@ -261,7 +260,6 @@ private BindingExpression createModifiableBindingExpression(
       case OPTIONAL:
       case MULTIBINDING:
       case INJECTION:
-      case MODULE_INSTANCE:
       case PRODUCTION:
         return bindingExpressions.wrapInMethod(
             resolvedBindings,
@@ -327,13 +325,6 @@ ModifiableBindingType getModifiableBindingType(BindingRequest request) {
         return ModifiableBindingType.INJECTION;
       }
 
-      // TODO(b/117833324): Check whether we need to modify a module instance binding if we are
-      // correctly installing the new module instance. In other words, if there is a subcomponent
-      // builder should we consider a module instance binding modifiable?
-      if (binding.requiresModuleInstance()) {
-        return ModifiableBindingType.MODULE_INSTANCE;
-      }
-
       if ((binding.scope().map(Scope::isProductionScope).orElse(false)
               && componentImplementation.isAbstract())
           || binding.bindingType().equals(BindingType.PRODUCTION)) {
@@ -423,14 +414,6 @@ private boolean shouldModifyImplementation(
       case INJECTION:
         return !resolvedBindings.contributionBinding().kind().equals(BindingKind.INJECTION);
 
-      case MODULE_INSTANCE:
-        // At the moment we have no way of detecting whether a new module instance is installed and
-        // the implementation has changed, so we implement the binding once in the base
-        // implementation of the subcomponent. It will be re-implemented when generating the
-        // component.
-        return !componentImplementation.superclassImplementation().isPresent()
-            || !componentImplementation.isAbstract();
-
       case PRODUCTION:
         // TODO(b/117833324): Profile this to see if this check is slow
         return !resolvedBindings
diff --git a/java/dagger/internal/codegen/ModifiableBindingType.java b/java/dagger/internal/codegen/ModifiableBindingType.java
index 96fe7633d..92a66f341 100644
--- a/java/dagger/internal/codegen/ModifiableBindingType.java
+++ b/java/dagger/internal/codegen/ModifiableBindingType.java
@@ -71,17 +71,6 @@
    */
   INJECTION,
 
-  /**
-   * If a binding requires an instance of a module then it is possible for that same module to be
-   * re-instantiated with different state by an ancestor component and thereby bind to a different
-   * instance of the same object. For this reason we reimplement the binding in the base
-   * implementation of the subcomponent, but then allow for all modifiations by re-implementing the
-   * binding when generating the root component. This allows for as much of the known binding graph
-   * to be implemented as early as possible, even if the binding requiring a module must be
-   * overridden later on.
-   */
-  MODULE_INSTANCE,
-
   /**
    * {@link dagger.producers.ProductionScope} is a unique scope that is allowed on multiple
    * components. In Ahead-of-Time mode, we don't actually know what component will end up owning the
@@ -116,7 +105,7 @@
   ;
 
   private static final ImmutableSet<ModifiableBindingType> TYPES_WITH_BASE_CLASS_IMPLEMENTATIONS =
-      ImmutableSet.of(NONE, INJECTION, MODULE_INSTANCE, MULTIBINDING, OPTIONAL, PRODUCTION);
+      ImmutableSet.of(NONE, INJECTION, MULTIBINDING, OPTIONAL, PRODUCTION);
 
   boolean isModifiable() {
     return !equals(NONE);
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index 677899800..fe04bade0 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -48,7 +48,7 @@
   private final ProvisionBinding provisionBinding;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final MembersInjectionMethods membersInjectionMethods;
-  private final ComponentRequirementFields componentRequirementFields;
+  private final ComponentRequirementExpressions componentRequirementExpressions;
   private final DaggerTypes types;
   private final DaggerElements elements;
 
@@ -57,7 +57,7 @@
       CompilerOptions compilerOptions,
       ComponentBindingExpressions componentBindingExpressions,
       MembersInjectionMethods membersInjectionMethods,
-      ComponentRequirementFields componentRequirementFields,
+      ComponentRequirementExpressions componentRequirementExpressions,
       DaggerTypes types,
       DaggerElements elements) {
     super(resolvedBindings);
@@ -69,7 +69,7 @@
     checkArgument(provisionBinding.bindingElement().isPresent());
     this.componentBindingExpressions = componentBindingExpressions;
     this.membersInjectionMethods = membersInjectionMethods;
-    this.componentRequirementFields = componentRequirementFields;
+    this.componentRequirementExpressions = componentRequirementExpressions;
     this.types = types;
     this.elements = elements;
   }
@@ -172,9 +172,7 @@ private Expression injectMembers(CodeBlock instance) {
             .contributingModule()
             .map(Element::asType)
             .map(ComponentRequirement::forModule)
-            .map(
-                requirement ->
-                    componentRequirementFields.getExpression(requirement, requestingClass))
+            .map(module -> componentRequirementExpressions.getExpression(module, requestingClass))
         : Optional.empty();
   }
 
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 28237b498..ea013ffcf 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -390,23 +390,14 @@ public void moduleInstanceDependency() {
             "",
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
-            "  private TestModule testModule;",
-            "",
             "  protected DaggerLeaf() {}",
             "",
-            "  protected void configureInitialization() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.testModule = new TestModule();",
-            "  }",
-            "",
             "  @Override",
             "  public String string() {",
-            "    return TestModule_ProvideStringFactory.proxyProvideString(testModule);",
+            "    return TestModule_ProvideStringFactory.proxyProvideString(testModule());",
             "  }",
+            "",
+            "  protected abstract TestModule testModule();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -499,18 +490,12 @@ public void moduleInstanceDependency() {
             "      private TestModule testModule;",
             "",
             "      private LeafImpl() {",
-            "        configureInitialization();",
-            "        initialize();",
-            "      }",
-            "",
-            "      @SuppressWarnings(\"unchecked\")",
-            "      private void initialize() {",
             "        this.testModule = new TestModule();",
             "      }",
             "",
             "      @Override",
-            "      public String string() {",
-            "        return TestModule_ProvideStringFactory.proxyProvideString(testModule);",
+            "      protected TestModule testModule() {",
+            "        return testModule;",
             "      }",
             "    }",
             "  }",
@@ -545,7 +530,9 @@ public void moduleInstanceDependency_withModuleParams() {
             "",
             "@Module",
             "final class TestModule {",
-            "  private int i = 0;",
+            "  private int i;",
+            "",
+            "  TestModule(int i) {}",
             "",
             "  @Provides int provideInt() {",
             "    return i++;",
@@ -559,23 +546,14 @@ public void moduleInstanceDependency_withModuleParams() {
             "",
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
-            "  private TestModule testModule;",
-            "",
             "  protected DaggerLeaf() {}",
             "",
-            "  protected void configureInitialization() {",
-            "    initialize();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize() {",
-            "    this.testModule = new TestModule();",
-            "  }",
-            "",
             "  @Override",
             "  public int getInt() {",
-            "    return testModule.provideInt();",
+            "    return testModule().provideInt();",
             "  }",
+            "",
+            "  protected abstract TestModule testModule();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -670,18 +648,12 @@ public void moduleInstanceDependency_withModuleParams() {
             "      private TestModule testModule;",
             "",
             "      private LeafImpl(TestModule module) {",
-            "        configureInitialization();",
-            "        initialize(module);",
-            "      }",
-            "",
-            "      @SuppressWarnings(\"unchecked\")",
-            "      private void initialize(final TestModule module) {",
             "        this.testModule = Preconditions.checkNotNull(module);",
             "      }",
             "",
             "      @Override",
-            "      public int getInt() {",
-            "        return testModule.provideInt();",
+            "      protected TestModule testModule() {",
+            "        return testModule;",
             "      }",
             "    }",
             "  }",
@@ -5599,11 +5571,6 @@ public void subcomponentBuilders() {
             "  protected DaggerLeaf() {}",
             "",
             "  protected void configureInitialization(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
             "    this.bindsInstance = builder.bindsInstance;",
             "    this.leafModule = builder.leafModule;",
             "  }",
@@ -5615,7 +5582,11 @@ public void subcomponentBuilders() {
             "",
             "  @Override",
             "  public Object fromModule() {",
-            "    return LeafModule_FromModuleFactory.proxyFromModule(leafModule);",
+            "    return LeafModule_FromModuleFactory.proxyFromModule(leafModule());",
+            "  }",
+            "",
+            "  protected LeafModule leafModule() {",
+            "    return leafModule;",
             "  }",
             "",
             "  public abstract static class Builder implements Leaf.Builder {",
@@ -5699,13 +5670,8 @@ public void subcomponentBuilders() {
             "",
             "    @Override",
             "    protected void configureInitialization(DaggerLeaf.Builder builder) {",
-            "      super.configureInitialization(builder);",
-            "      initialize(builder);",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize(final DaggerLeaf.Builder builder) {",
             "      this.inducedInSubclass = builder.inducedInSubclass;",
+            "      super.configureInitialization(builder);",
             "    }",
             "",
             "    protected Set<String> getSetOfString() {",
@@ -5795,18 +5761,13 @@ public void subcomponentBuilders() {
             "      private LeafModule leafModule;",
             "",
             "      private LeafImpl(LeafBuilder builder) {",
-            "        configureInitialization(builder);",
-            "        initialize(builder);",
-            "      }",
-            "",
-            "      @SuppressWarnings(\"unchecked\")",
-            "      private void initialize(final LeafBuilder builder) {",
             "        this.leafModule = builder.leafModule;",
+            "        configureInitialization(builder);",
             "      }",
             "",
             "      @Override",
-            "      public Object fromModule() {",
-            "        return LeafModule_FromModuleFactory.proxyFromModule(leafModule);",
+            "      protected LeafModule leafModule() {",
+            "        return leafModule;",
             "      }",
             "    }",
             "  }",
@@ -5880,17 +5841,17 @@ public void subcomponentBuilders_moduleWithUnusedInstanceBindings() {
             "  protected DaggerLeaf() {}",
             "",
             "  protected void configureInitialization(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
             "    this.moduleWithUsedBinding = builder.moduleWithUsedBinding;",
             "  }",
             "",
             "  @Override",
             "  public Used used() {",
-            "    return ModuleWithUsedBinding_UsedFactory.proxyUsed(moduleWithUsedBinding);",
+            "    return ModuleWithUsedBinding_UsedFactory.proxyUsed(",
+            "        moduleWithUsedBinding());",
+            "  }",
+            "",
+            "  protected ModuleWithUsedBinding moduleWithUsedBinding() {",
+            "    return moduleWithUsedBinding;",
             "  }",
             "",
             "  public abstract static class Builder implements Leaf.Builder {",
@@ -5962,18 +5923,13 @@ public void subcomponentBuilders_moduleWithUnusedInstanceBindings() {
             "    private ModuleWithUsedBinding moduleWithUsedBinding;",
             "",
             "    private LeafImpl(LeafBuilder builder) {",
-            "      configureInitialization(builder);",
-            "      initialize(builder);",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize(final LeafBuilder builder) {",
             "      this.moduleWithUsedBinding = builder.moduleWithUsedBinding;",
+            "      configureInitialization(builder);",
             "    }",
             "",
             "    @Override",
-            "    public Used used() {",
-            "      return ModuleWithUsedBinding_UsedFactory.proxyUsed(moduleWithUsedBinding);",
+            "    protected ModuleWithUsedBinding moduleWithUsedBinding() {",
+            "      return moduleWithUsedBinding;",
             "    }",
             "  }",
             "}");
@@ -6033,17 +5989,16 @@ public void subcomponentBuilders_repeatedModule() {
             "  protected DaggerLeaf() {}",
             "",
             "  protected void configureInitialization(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
             "    this.repeatedModule = builder.repeatedModule;",
             "  }",
             "",
             "  @Override",
             "  public int i() {",
-            "    return repeatedModule.i();",
+            "    return repeatedModule().i();",
+            "  }",
+            "",
+            "  protected RepeatedModule repeatedModule() {",
+            "    return repeatedModule;",
             "  }",
             "",
             "  public abstract static class Builder implements Leaf.Builder {",
@@ -6086,7 +6041,7 @@ public void subcomponentBuilders_repeatedModule() {
             "  private RepeatedModule repeatedModule;",
             "",
             "  private DaggerRoot(Builder builder) {",
-            "    initialize(builder);",
+            "    this.repeatedModule = builder.repeatedModule;",
             "  }",
             "",
             "  public static Builder builder() {",
@@ -6097,11 +6052,6 @@ public void subcomponentBuilders_repeatedModule() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.repeatedModule = builder.repeatedModule;",
-            "  }",
-            "",
             "  @Override",
             "  public Leaf.Builder leaf() {",
             "    return new LeafBuilder();",
@@ -6146,8 +6096,8 @@ public void subcomponentBuilders_repeatedModule() {
             "    }",
             "",
             "    @Override",
-            "    public int i() {",
-            "      return DaggerRoot.this.repeatedModule.i();",
+            "    protected RepeatedModule repeatedModule() {",
+            "      return DaggerRoot.this.repeatedModule;",
             "    }",
             "  }",
             "}");
diff --git a/javatests/dagger/internal/codegen/ComponentBuilderTest.java b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
index ca90f84d3..cc385249d 100644
--- a/javatests/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
@@ -226,7 +226,8 @@ public void testIgnoresModulesNotInApi() {
             "  private TestModule2 testModule2;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
+            "    this.testModule1 = builder.testModule1;",
+            "    this.testModule2 = builder.testModule2;",
             "  }",
             "",
             "  public static TestComponent.Builder builder() {",
@@ -237,12 +238,6 @@ public void testIgnoresModulesNotInApi() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.testModule1 = builder.testModule1;",
-            "    this.testModule2 = builder.testModule2;",
-            "  }",
-            "",
             "  @Override",
             "  public String string() {",
             "    return TestModule1_StringFactory.proxyString(testModule1);",
@@ -414,18 +409,13 @@ public void testBuilderBindsInstanceNoCreateGenerated() {
             "  private Object object;",
             "",
             "  private DaggerSimpleComponent(Builder builder) {",
-            "    initialize(builder);",
+            "    this.object = builder.object;",
             "  }",
             "",
             "  public static SimpleComponent.Builder builder() {",
             "    return new Builder();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.object = builder.object;",
-            "  }",
-            "",
             "  @Override",
             "  public Object object() {",
             "    return object;",
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index 9dc9141ce..5dde439bd 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -510,13 +510,12 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private TestModule testModule;",
                 "",
-                "  private B getB() {",
-                "    return TestModule_BFactory.proxyB(testModule, new C());",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    this.testModule = builder.testModule;",
                 "  }",
                 "",
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
-                "    this.testModule = builder.testModule;",
+                "  private B getB() {",
+                "    return TestModule_BFactory.proxyB(testModule, new C());",
                 "  }",
                 "",
                 "  @Override",
@@ -1208,6 +1207,10 @@ public void testDefaultPackage() {
                 "  private volatile Provider<A> aProvider;",
                 "  private AComponent aComponent;",
                 "",
+                "  private DaggerBComponent(Builder builder) {",
+                "    this.aComponent = builder.aComponent;",
+                "  }",
+                "",
                 "  private Provider<A> getAProvider() {",
                 "    Object local = aProvider;",
                 "    if (local == null) {",
@@ -1216,17 +1219,13 @@ public void testDefaultPackage() {
                 "    }",
                 "    return (Provider<A>) local;",
                 "  }")
-            .addLines(
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {")
             .addLinesIn(
                 DEFAULT_MODE,
-                "    this.aProvider = new test_AComponent_a(builder.aComponent);")
-            .addLinesIn(
-                FAST_INIT_MODE,
-                "    this.aComponent = builder.aComponent;")
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.aProvider = new test_AComponent_a(builder.aComponent);",
+                "  }")
             .addLines(
-                "  }",
                 "",
                 "  @Override",
                 "  public B b() {")
@@ -1348,8 +1347,7 @@ public void testDefaultPackage() {
             "  private TestModule testModule;",
             "  private other.test.TestModule testModule2;",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
+            "  private DaggerTestComponent(Builder builder) {",
             "    this.testModule = builder.testModule;",
             "    this.testModule2 = builder.testModule2;",
             "  }",
@@ -1472,8 +1470,7 @@ public void testDefaultPackage() {
             "public final class DaggerBComponent implements BComponent {",
             "  private AComponent aComponent;",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
+            "  private DaggerBComponent(Builder builder) {",
             "    this.aComponent = builder.aComponent;",
             "  }",
             "",
diff --git a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
index fe5104df6..f44c5dc56 100644
--- a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
+++ b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
@@ -81,8 +81,7 @@ public void bindsInstance() {
                 "  private Integer i;",
                 "  private List<String> list;",
                 "",
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private DaggerTestComponent(Builder builder) {",
                 "    this.i = builder.i;",
                 "    this.list = builder.list;",
                 "  }",
@@ -252,8 +251,7 @@ public void componentInstances() {
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private Dep dep;",
                 "",
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private DaggerTestComponent(Builder builder) {",
                 "    this.dep = builder.dep;",
                 "  }",
                 "",
@@ -367,8 +365,7 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private ParentModule parentModule;",
                 "",
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private DaggerTestComponent(Builder builder) {",
                 "    this.parentModule = builder.parentModule;",
                 "  }",
                 "",
@@ -396,6 +393,11 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private ParentModule parentModule;",
                 "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "    initialize(builder);",
+                "  }",
+                "",
                 "  @SuppressWarnings(\"unchecked\")",
                 "  private void initialize(final Builder builder) {",
                 "    this.setOfObjectProvider =",
@@ -405,7 +407,6 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
                 "    this.reliesOnMultibindingProvider =",
                 "        ParentModule_ReliesOnMultibindingFactory.create(",
                 "            builder.parentModule, setOfObjectProvider);",
-                "    this.parentModule = builder.parentModule;",
                 "  }",
                 "",
                 "  private final class TestSubcomponentImpl implements TestSubcomponent {",
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 2bc70bc9b..a761d52c0 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -742,6 +742,11 @@ public void mapBindingsWithWrappedKey() {
                 "  private MapModuleOne mapModuleOne;",
                 "  private MapModuleTwo mapModuleTwo;",
                 "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    this.mapModuleOne = builder.mapModuleOne;",
+                "    this.mapModuleTwo = builder.mapModuleTwo;",
+                "  }",
+                "",
                 "  private Provider<Handler>",
                 "        getMapOfWrappedClassKeyAndProviderOfHandlerProvider() {",
                 "        Object local = provideAdminHandlerProvider;",
@@ -771,12 +776,6 @@ public void mapBindingsWithWrappedKey() {
                 "        getMapOfWrappedClassKeyAndProviderOfHandlerProvider2());",
                 "  }",
                 "",
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
-                "    this.mapModuleOne = builder.mapModuleOne;",
-                "    this.mapModuleTwo = builder.mapModuleTwo;",
-                "  }",
-                "",
                 "  @Override",
                 "  public Provider<Map<WrappedClassKey, Provider<Handler>>> dispatcher() {",
                 "    Object local = mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 48af3ec5c..3bb87e666 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -264,6 +264,7 @@ public void simpleComponent() {
                 "  private TestClass_AModule_AFactory aProducer;",
                 "",
                 "  private DaggerTestClass_SimpleComponent(Builder builder) {",
+                "    this.bModule = builder.bModule;",
                 "    initialize(builder);",
                 "  }",
                 "",
@@ -346,7 +347,6 @@ public void simpleComponent() {
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
                 "  private void initialize(final Builder builder) {",
-                "    this.bModule = builder.bModule;",
                 "    this.simpleComponentProvider =",
                 "        InstanceFactory.create((TestClass.SimpleComponent) this);",
                 "    this.bProducer = Producers.producerFromProvider(getBProvider());",
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index 79ed0b6c6..ca3fd35ae 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -540,7 +540,7 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
                 "    private ChildModule childModule;",
                 "",
                 "    private ChildComponentImpl() {",
-                "      initialize();",
+                "      this.childModule = new ChildModule();",
                 "    }",
                 "")
             .addLinesIn(
@@ -567,11 +567,6 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
                 "              DaggerParentComponent.this.getDep1(),",
                 "              DaggerParentComponent.this.getDep2()));")
             .addLines(
-                "    }",
-                "",
-                "    @SuppressWarnings(\"unchecked\")",
-                "    private void initialize() {",
-                "      this.childModule = new ChildModule();",
                 "    }",
                 "",
                 "    @Override",
