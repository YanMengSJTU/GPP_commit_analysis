diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 737197703..34e78b608 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -192,7 +192,22 @@
     this.subcomponentNames = subcomponentNames;
     this.optionalFactories = optionalFactories;
     this.requestFulfillmentRegistry =
-        new RequestFulfillmentRegistry(graph.resolvedBindings(), this);
+        new RequestFulfillmentRegistry(
+            graph.resolvedBindings(), this, childComponentNames(keyFactory, subcomponentNames));
+  }
+
+  private static ImmutableMap<BindingKey, String> childComponentNames(
+      Key.Factory keyFactory, ImmutableMap<ComponentDescriptor, String> subcomponentNames) {
+    ImmutableMap.Builder<BindingKey, String> builder = ImmutableMap.builder();
+    subcomponentNames.forEach(
+        (component, name) -> {
+          if (component.builderSpec().isPresent()) {
+            TypeMirror builderType = component.builderSpec().get().builderDefinitionType().asType();
+            builder.put(
+                BindingKey.contribution(keyFactory.forSubcomponentBuilder(builderType)), name);
+          }
+        });
+    return builder.build();
   }
 
   protected AbstractComponentWriter(
diff --git a/java/dagger/internal/codegen/RequestFulfillmentRegistry.java b/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
index 941d314e6..ec140fd65 100644
--- a/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
+++ b/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
@@ -33,13 +33,16 @@
   private final HasBindingMembers hasBindingMembers;
   /** This map is mutated as {@link #getRequestFulfillment} is invoked. */
   private final Map<BindingKey, RequestFulfillment> requestFulfillments;
+  private final ImmutableMap<BindingKey, String> subcomponentNames;
 
   RequestFulfillmentRegistry(
       ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap,
-      HasBindingMembers hasBindingMembers) {
+      HasBindingMembers hasBindingMembers,
+      ImmutableMap<BindingKey, String> subcomponentNames) {
     this.resolvedBindingsMap = resolvedBindingsMap;
     this.hasBindingMembers = hasBindingMembers;
     this.requestFulfillments = newLinkedHashMapWithExpectedSize(resolvedBindingsMap.size());
+    this.subcomponentNames = subcomponentNames;
   }
 
   /** Returns a {@link RequestFulfillment} implementation for the given {@link BindingKey} */
@@ -64,6 +67,12 @@ private RequestFulfillment createRequestFulfillment(BindingKey bindingKey) {
 
         ProviderFieldRequestFulfillment providerFieldRequestFulfillment =
             new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
+
+        if (provisionBinding.bindingKind().equals(ContributionBinding.Kind.SUBCOMPONENT_BUILDER)) {
+          return new SubcomponentBuilderRequestFulfillment(
+              bindingKey, providerFieldRequestFulfillment, subcomponentNames.get(bindingKey));
+        }
+
         if (provisionBinding.implicitDependencies().isEmpty()
             && !provisionBinding.scope().isPresent()
             && !provisionBinding.requiresModuleInstance()
diff --git a/java/dagger/internal/codegen/SubcomponentBuilderRequestFulfillment.java b/java/dagger/internal/codegen/SubcomponentBuilderRequestFulfillment.java
new file mode 100644
index 000000000..ec4e291d1
--- /dev/null
+++ b/java/dagger/internal/codegen/SubcomponentBuilderRequestFulfillment.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.DependencyRequest.Kind;
+
+final class SubcomponentBuilderRequestFulfillment extends RequestFulfillment {
+  private final RequestFulfillment delegate;
+  private final String subcomponentBuilderName;
+
+  SubcomponentBuilderRequestFulfillment(
+      BindingKey bindingKey, RequestFulfillment delegate, String subcomponentBuilderName) {
+    super(bindingKey);
+    this.delegate = delegate;
+    this.subcomponentBuilderName = subcomponentBuilderName;
+  }
+
+  @Override
+  CodeBlock getSnippetForDependencyRequest(DependencyRequest request, ClassName requestingClass) {
+    if (request.kind().equals(Kind.INSTANCE)) {
+      return CodeBlock.of("new $LBuilder()", subcomponentBuilderName);
+    }
+    return delegate.getSnippetForDependencyRequest(request, requestingClass);
+  }
+
+  @Override
+  CodeBlock getSnippetForFrameworkDependency(
+      FrameworkDependency frameworkDependency, ClassName requestingClass) {
+    return delegate.getSnippetForFrameworkDependency(frameworkDependency, requestingClass);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
new file mode 100644
index 000000000..1eb5431eb
--- /dev/null
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class SubcomponentBuilderRequestFulfillmentTest {
+  @Test
+  public void testInlinedSubcomponentBuilders_componentMethod() {
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Sub {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Sub build();",
+            "  }",
+            "}");
+    JavaFileObject usesSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.UsesSubcomponent",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class UsesSubcomponent {",
+            "  @Inject UsesSubcomponent(Sub.Builder subBuilder) {}",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface C {",
+            "  Sub.Builder sBuilder();",
+            "  UsesSubcomponent usesSubcomponent();",
+            "}");
+
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerC",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerC implements C {",
+            "  private Provider<Sub.Builder> sBuilderProvider;",
+            "  private Provider<UsesSubcomponent> usesSubcomponentProvider;",
+            "",
+            "  private DaggerC(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static C create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.sBuilderProvider =",
+            "        new dagger.internal.Factory<Sub.Builder>() {",
+            "          @Override",
+            "          public Sub.Builder get() {",
+            "            return new SubBuilder();",
+            "          }",
+            "        };",
+            "   this.usesSubcomponentProvider = UsesSubcomponent_Factory.create(sBuilderProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Sub.Builder sBuilder() {",
+            "    return new SubBuilder();",
+            "  }",
+            "",
+            "  @Override",
+            "  public UsesSubcomponent usesSubcomponent() {",
+            "    return new UsesSubcomponent(new SubBuilder());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public C build() {",
+            "      return new DaggerC(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class SubBuilder implements Sub.Builder {",
+            "    @Override",
+            "    public Sub build() {",
+            "      return new SubImpl(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class SubImpl implements Sub {",
+            "    private SubImpl(SubBuilder builder) {",
+            "      assert builder != null;",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(subcomponent, usesSubcomponent, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerC")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index 225918e9a..4054a07e2 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -1008,12 +1008,12 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "",
             "  @Override",
             "  public C.Foo.Sub.Builder fooBuilder() {",
-            "    return fooBuilderProvider.get();",
+            "    return new F_SubBuilder();",
             "  }",
             "",
             "  @Override",
             "  public C.Bar.Sub.Builder barBuilder() {",
-            "    return barBuilderProvider.get();",
+            "    return new B_SubBuilder();",
             "  }",
             "",
             "  public static final class Builder {",
