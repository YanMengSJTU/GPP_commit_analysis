diff --git a/java/dagger/internal/codegen/BindingVariableNamer.java b/java/dagger/internal/codegen/BindingVariableNamer.java
index 8537ea0cf..526e2db4c 100644
--- a/java/dagger/internal/codegen/BindingVariableNamer.java
+++ b/java/dagger/internal/codegen/BindingVariableNamer.java
@@ -19,6 +19,7 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
+import static dagger.internal.codegen.SourceFiles.protectAgainstKeywords;
 
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
@@ -89,7 +90,7 @@ static String name(Binding binding) {
     TypeMirror type = typeToName(binding);
     type.accept(TYPE_NAMER, builder);
 
-    return UPPER_CAMEL.to(LOWER_CAMEL, builder.toString());
+    return protectAgainstKeywords(UPPER_CAMEL.to(LOWER_CAMEL, builder.toString()));
   }
 
   private static TypeMirror typeToName(Binding binding) {
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index 18eac4ada..2a53a223c 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -21,6 +21,7 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * A binding expression that implements and uses a component method.
@@ -60,6 +61,16 @@ protected CodeBlock getComponentMethodImplementation(
         : super.getComponentMethodImplementation(componentMethod, componentName);
   }
 
+  @Override
+  Expression getDependencyExpression(ClassName requestingClass) {
+    // If a component method returns a primitive, update the expression's type which might be boxed.
+    Expression expression = super.getDependencyExpression(requestingClass);
+    TypeMirror methodReturnType = componentMethod.methodElement().getReturnType();
+    return methodReturnType.getKind().isPrimitive()
+        ? Expression.create(methodReturnType, expression.codeBlock())
+        : expression;
+  }
+
   @Override
   protected void addMethod() {}
 
diff --git a/java/dagger/internal/codegen/MethodBindingExpression.java b/java/dagger/internal/codegen/MethodBindingExpression.java
index c9e53907b..3d8520a3e 100644
--- a/java/dagger/internal/codegen/MethodBindingExpression.java
+++ b/java/dagger/internal/codegen/MethodBindingExpression.java
@@ -35,7 +35,7 @@ protected MethodBindingExpression(
   }
 
   @Override
-  final Expression getDependencyExpression(ClassName requestingClass) {
+  Expression getDependencyExpression(ClassName requestingClass) {
     addMethod();
     return Expression.create(
         methodImplementation.returnType(),
diff --git a/java/dagger/internal/codegen/SourceFiles.java b/java/dagger/internal/codegen/SourceFiles.java
index b97fc764b..d7ce53550 100644
--- a/java/dagger/internal/codegen/SourceFiles.java
+++ b/java/dagger/internal/codegen/SourceFiles.java
@@ -321,7 +321,7 @@ static String simpleVariableName(TypeElement typeElement) {
     return variableName;
   }
 
-  private static String protectAgainstKeywords(String candidateName) {
+  static String protectAgainstKeywords(String candidateName) {
     switch (candidateName) {
       case "package":
         return "pkg";
diff --git a/java/dagger/internal/codegen/SwitchingProviders.java b/java/dagger/internal/codegen/SwitchingProviders.java
index f2a6a0049..441cd620f 100644
--- a/java/dagger/internal/codegen/SwitchingProviders.java
+++ b/java/dagger/internal/codegen/SwitchingProviders.java
@@ -108,7 +108,10 @@ private CodeBlock createSwitchCaseCodeBlock(Key key) {
 
     // Primitives cannot be cast directly to the method's parameterized type, T. We have to first
     // cast them to their boxed type.
-    if (binding(key).contributedPrimitiveType().isPresent()) {
+    // TODO(user): Shouldn't we be able to rely soley on the instance expression type? However,
+    // that currently fails. Does that indicate that those dependency expression types are wrong?
+    if (binding(key).contributedPrimitiveType().isPresent()
+        || instanceExpression.type().getKind().isPrimitive()) {
       TypeName boxedType = TypeName.get(binding(key).contributedType()).box();
       instanceCodeBlock = CodeBlock.of("($T) $L", boxedType, instanceCodeBlock);
     }
diff --git a/javatests/dagger/functional/ComponentWithReusableBindings.java b/javatests/dagger/functional/ComponentWithReusableBindings.java
index cd5408626..acd9e93ff 100644
--- a/javatests/dagger/functional/ComponentWithReusableBindings.java
+++ b/javatests/dagger/functional/ComponentWithReusableBindings.java
@@ -21,6 +21,7 @@
 import dagger.Provides;
 import dagger.Reusable;
 import dagger.Subcomponent;
+import javax.inject.Provider;
 import javax.inject.Qualifier;
 
 @Component(modules = ComponentWithReusableBindings.ReusableBindingsModule.class)
@@ -42,6 +43,14 @@
   // b/77150738
   int primitive();
 
+  // b/77150738: This is used as a regression test for Android mode with SwitchingProvider. In
+  // particular, it occurs when a @Provides method returns the boxed type but the component method
+  // returns the unboxed type, and the instance is requested from a SwitchingProvider.
+  boolean unboxedPrimitive();
+
+  // b/77150738
+  Provider<Boolean> booleanProvider();
+
   @Subcomponent
   interface ChildOne {
     @InParent
@@ -82,5 +91,12 @@ static Object inChildren() {
     static int primitive() {
       return 0;
     }
+
+    // b/77150738
+    @Provides
+    @Reusable
+    static Boolean boxedPrimitive() {
+      return false;
+    }
   }
 }
