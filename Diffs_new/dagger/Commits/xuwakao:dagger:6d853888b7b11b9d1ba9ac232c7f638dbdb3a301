diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java
deleted file mode 100644
index c711bb257..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Component;
-import dagger.Multibindings;
-import test.sub.ContributionsModule;
-
-/**
- * A component used to test multibindings that use {@link Multibindings @Multibindings}-annotated
- * nested interfaces to declare multibindings.
- */
-@Component(
-  modules = {
-    MultibindingModule.class,
-    MultibindingsInterfaceModule.class,
-    ContributionsModule.class
-  },
-  dependencies = MultibindingDependency.class
-)
-interface MultibindingComponentWithMultibindingsInterface extends MultibindingComponent {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java
deleted file mode 100644
index cc58830a9..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Module;
-import dagger.Multibindings;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Named;
-
-/**
- * A module that uses a {@link Multibindings @Multibindings}-annotated nested interface to declare
- * multibindings.
- */
-@Module
-final class MultibindingsInterfaceModule {
-
-  interface EmptiesSupertype {
-    Set<Object> emptySet();
-
-    Map<String, Object> emptyMap();
-
-    Set<CharSequence> set();
-
-    Map<String, CharSequence> map();
-  }
-
-  @Multibindings
-  interface Empties extends EmptiesSupertype {
-    @Named("complexQualifier")
-    Set<Object> emptyQualifiedSet();
-
-    @Named("complexQualifier")
-    Map<String, Object> emptyQualifiedMap();
-
-    @Named("complexQualifier")
-    Set<CharSequence> qualifiedSet();
-
-    @Named("complexQualifier")
-    Map<String, CharSequence> qualifiedMap();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 89b75cb13..b4989734e 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -17,7 +17,6 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.auto.value.AutoAnnotation;
-import com.google.common.collect.ImmutableList;
 import dagger.multibindings.ClassKey;
 import dagger.multibindings.StringKey;
 import java.math.BigDecimal;
@@ -26,42 +25,14 @@
 import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
+import org.junit.runners.JUnit4;
 
-@RunWith(Parameterized.class)
+/** Tests for {@link MultibindingComponent}. */
+@RunWith(JUnit4.class)
 public class MultibindingTest {
 
-  private static final MultibindingDependency MULTIBINDING_DEPENDENCY =
-      new MultibindingDependency() {
-        @Override
-        public double doubleDependency() {
-          return 0.0;
-        }
-      };
-
-  @Parameters(name = "{0}")
-  public static Iterable<Object[]> parameters() {
-    return ImmutableList.copyOf(
-        new Object[][] {
-          {
-            DaggerMultibindingComponent.builder()
-                .multibindingDependency(MULTIBINDING_DEPENDENCY)
-                .build()
-          },
-          {
-            DaggerMultibindingComponentWithMultibindingsInterface.builder()
-                .multibindingDependency(MULTIBINDING_DEPENDENCY)
-                .build()
-          }
-        });
-  }
-
-  private final MultibindingComponent multibindingComponent;
-
-  public MultibindingTest(MultibindingComponent multibindingComponent) {
-    this.multibindingComponent = multibindingComponent;
-  }
+  private final MultibindingComponent multibindingComponent =
+      DaggerMultibindingComponent.builder().multibindingDependency(() -> 0.0).build();
 
   @Test public void map() {
     Map<String, String> map = multibindingComponent.map();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
index 084224540..0b5f96b09 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -162,8 +162,7 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
    * Adds an error if the method is not declared in a class or interface annotated with one of the
    * {@link #enclosingElementAnnotations}.
    */
-  // TODO(b/28861722): Make private once @Multibindings is deleted.
-  protected void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> builder) {
+  private void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> builder) {
     if (!isAnyAnnotationPresent(
         builder.getSubject().getEnclosingElement(), enclosingElementAnnotations)) {
       builder.addError(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index b47fbf983..c7204278f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -81,8 +81,6 @@ public SourceVersion getSupportedSourceVersion() {
     BindsMethodValidator bindsMethodValidator = new BindsMethodValidator(elements, types);
     MultibindsMethodValidator multibindsMethodValidator =
         new MultibindsMethodValidator(elements, types);
-    MultibindingsMethodValidator multibindingsMethodValidator =
-        new MultibindingsMethodValidator(elements, types);
     BindsOptionalOfMethodValidator bindsOptionalOfMethodValidator =
         new BindsOptionalOfMethodValidator(elements, types);
     AnyBindingMethodValidator anyBindingMethodValidator =
@@ -92,20 +90,11 @@ public SourceVersion getSupportedSourceVersion() {
             bindsMethodValidator,
             multibindsMethodValidator,
             bindsOptionalOfMethodValidator);
-    MultibindingsValidator multibindingsValidator =
-        new MultibindingsValidator(
-            elements,
-            types,
-            keyFactory,
-            keyFormatter,
-            methodSignatureFormatter,
-            multibindingsMethodValidator);
     ModuleValidator moduleValidator =
         new ModuleValidator(
             types,
             elements,
             anyBindingMethodValidator,
-            multibindingsValidator,
             methodSignatureFormatter);
     BuilderValidator builderValidator = new BuilderValidator(elements, types);
     ComponentValidator subcomponentValidator =
@@ -242,7 +231,6 @@ public SourceVersion getSupportedSourceVersion() {
             componentDescriptorFactory,
             bindingGraphFactory,
             componentGenerator),
-        new MultibindingsProcessingStep(messager, multibindingsValidator),
         new BindingMethodProcessingStep(messager, anyBindingMethodValidator));
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 0168e112a..8749eded0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -24,7 +24,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
-import dagger.Multibindings;
 import dagger.multibindings.Multibinds;
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
@@ -583,28 +582,7 @@ protected String process(String s) {
     }
   }
 
-  /** Error messages related to {@link Multibindings @Multibindings}. */
-  static final class MultibindingsMessages {
-    static final String MUST_BE_INTERFACE = "@Multibindings can be applied only to interfaces";
-
-    static final String MUST_NOT_HAVE_TYPE_PARAMETERS =
-        "@Multibindings types must not have type parameters";
-
-    static final String MUST_BE_IN_MODULE =
-        "@Multibindings types must be nested within a @Module or @ProducerModule";
-
-    static String tooManyMethodsForKey(String formattedKey) {
-      return String.format(
-          "Too many @Multibindings methods for %s", stripCommonTypePrefixes(formattedKey));
-    }
-
-    private MultibindingsMessages() {}
-  }
-
-  /**
-   * Error messages related to {@link Multibinds @Multibinds} methods and methods in
-   * {@link Multibindings} interfaces.
-   */
+  /** Error messages related to {@link Multibinds @Multibinds} methods. */
   static final class MultibindsMessages {
     static final String METHOD_MUST_RETURN_MAP_OR_SET =
         "@%s methods must return Map<K, V> or Set<T>";
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 058c09f60..97057dabf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -46,7 +46,6 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Binds;
 import dagger.BindsOptionalOf;
-import dagger.Multibindings;
 import dagger.multibindings.Multibinds;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
@@ -429,8 +428,7 @@ private Key forBindingMethod(
     }
 
     /**
-     * Returns the key for a {@link Multibinds @Multibinds} method or a method in a
-     * {@link Multibindings @Multibindings} interface.
+     * Returns the key for a {@link Multibinds @Multibinds} method.
      *
      * <p>The key's type is either {@code Set<T>} or {@code Map<K, F<V>>}, where {@code F} is either
      * {@link Provider} or {@link Producer}, depending on {@code bindingType}.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index ec665409f..c539bcaa2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -25,7 +25,6 @@
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.NONE;
 import static javax.lang.model.util.ElementFilter.methodsIn;
-import static javax.lang.model.util.ElementFilter.typesIn;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -36,7 +35,6 @@
 import dagger.Binds;
 import dagger.BindsOptionalOf;
 import dagger.Module;
-import dagger.Multibindings;
 import dagger.Provides;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
@@ -184,13 +182,6 @@ ModuleDescriptor create(TypeElement moduleElement) {
         }
       }
 
-      for (TypeElement memberType : typesIn(elements.getAllMembers(moduleElement))) {
-        if (isAnnotationPresent(memberType, Multibindings.class)) {
-          multibindingDeclarations.addAll(
-              multibindingDeclarationFactory.forMultibindingsInterface(memberType));
-        }
-      }
-
       return new AutoValue_ModuleDescriptor(
           moduleElement,
           ImmutableSet.copyOf(collectIncludedModules(new LinkedHashSet<>(), moduleElement)),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 6d24a5c9e..0339287b2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -43,7 +43,6 @@
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.util.ElementFilter.methodsIn;
-import static javax.lang.model.util.ElementFilter.typesIn;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -56,7 +55,6 @@
 import com.google.common.collect.Sets;
 import dagger.Binds;
 import dagger.Module;
-import dagger.Multibindings;
 import dagger.Subcomponent;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
@@ -99,7 +97,6 @@
   private final Types types;
   private final Elements elements;
   private final AnyBindingMethodValidator anyBindingMethodValidator;
-  private final MultibindingsValidator multibindingsValidator;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final Map<TypeElement, ValidationReport<TypeElement>> cache = new HashMap<>();
   private final Set<TypeElement> knownModules = new HashSet<>();
@@ -108,12 +105,10 @@
       Types types,
       Elements elements,
       AnyBindingMethodValidator anyBindingMethodValidator,
-      MultibindingsValidator multibindingsValidator,
       MethodSignatureFormatter methodSignatureFormatter) {
     this.types = types;
     this.elements = elements;
     this.anyBindingMethodValidator = anyBindingMethodValidator;
-    this.multibindingsValidator = multibindingsValidator;
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
@@ -175,20 +170,10 @@ void addKnownModules(Collection<TypeElement> modules) {
     validateModifiers(module, builder);
     validateReferencedModules(module, moduleKind, builder);
     validateReferencedSubcomponents(module, moduleKind, builder);
-    validateNestedMultibindingsTypes(module, builder);
 
     return builder.build();
   }
 
-  private void validateNestedMultibindingsTypes(
-      TypeElement module, ValidationReport.Builder<TypeElement> builder) {
-    for (TypeElement nestedType : typesIn(elements.getAllMembers(module))) {
-      if (isAnnotationPresent(nestedType, Multibindings.class)) {
-        builder.addSubreport(multibindingsValidator.validate(nestedType));
-      }
-    }
-  }
-
   private void validateReferencedSubcomponents(
       final TypeElement subject,
       ModuleDescriptor.Kind moduleKind,
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
index 5be39a059..10c5a1e6f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -16,16 +16,12 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
-import static javax.lang.model.element.ElementKind.INTERFACE;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.collect.ImmutableSet;
 import dagger.Module;
-import dagger.Multibindings;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.multibindings.Multibinds;
@@ -38,7 +34,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
@@ -47,7 +42,7 @@
 /**
  * A declaration that a multibinding with a certain key is available to be injected in a component
  * even if the component has no multibindings for that key. Identified by a map- or set-returning
- * method in a {@link Multibindings @Multibindings}-annotated interface nested within a module.
+ * method annotated with {@link Multibinds @Multibinds}.
  */
 @AutoValue
 abstract class MultibindingDeclaration extends BindingDeclaration
@@ -69,8 +64,8 @@
   public abstract ContributionType contributionType();
 
   /**
-   * {@link BindingType#PROVISION} if the {@link Multibindings @Multibindings}-annotated interface
-   * is nested in a {@link Module @Module}, or {@link BindingType#PROVISION} if it is nested in a
+   * {@link BindingType#PROVISION} if {@link Multibinds @Multibinds}-annotated method
+   * is enclosed in a {@link Module @Module}, or {@link BindingType#PROVISION} if it is nested in a
    * {@link ProducerModule @ProducerModule}.
    */
   @Override
@@ -92,28 +87,6 @@
       this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
     }
 
-    /**
-     * Creates multibinding declarations for each method in a
-     * {@link Multibindings @Multibindings}-annotated interface.
-     */
-    ImmutableSet<MultibindingDeclaration> forMultibindingsInterface(TypeElement interfaceElement) {
-      checkArgument(interfaceElement.getKind().equals(INTERFACE));
-      checkArgument(isAnnotationPresent(interfaceElement, Multibindings.class));
-      BindingType bindingType = bindingType(interfaceElement.getEnclosingElement());
-      DeclaredType interfaceType = MoreTypes.asDeclared(interfaceElement.asType());
-
-      ImmutableSet.Builder<MultibindingDeclaration> declarations = ImmutableSet.builder();
-      for (ExecutableElement method :
-          getLocalAndInheritedMethods(interfaceElement, types, elements)) {
-        if (!method.getEnclosingElement().equals(objectElement)) {
-          ExecutableType methodType =
-              MoreTypes.asExecutable(types.asMemberOf(interfaceType, method));
-          declarations.add(forDeclaredMethod(bindingType, method, methodType, interfaceElement));
-        }
-      }
-      return declarations.build();
-    }
-
     /** A multibinding declaration for a {@link Multibinds @Multibinds} method. */
     MultibindingDeclaration forMultibindsMethod(
         ExecutableElement moduleMethod, TypeElement moduleElement) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
deleted file mode 100644
index fed327ff1..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import com.google.common.collect.ImmutableSet;
-import dagger.Multibindings;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-
-/** A validator for methods in {@link Multibindings @Multibindings} interfaces. */
-final class MultibindingsMethodValidator extends MultibindsMethodValidator {
-
-  MultibindingsMethodValidator(Elements elements, Types types) {
-    super(elements, types, Multibindings.class, ImmutableSet.of(Multibindings.class));
-  }
-
-  @Override
-  protected void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> builder) {
-    // no-op, since @Multibindings interfaces can inherit methods from unannotated supertypes.
-  }
-}
-
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
deleted file mode 100644
index a52d5cd7b..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static javax.lang.model.util.ElementFilter.typesIn;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import dagger.Multibindings;
-import java.lang.annotation.Annotation;
-import java.util.Set;
-import javax.annotation.processing.Messager;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-
-/**
- * Valdiates types annotated with {@link Multibindings @Multibindings} that haven't already been
- * validated while processing their enclosing modules.
- */
-class MultibindingsProcessingStep implements ProcessingStep {
-  private final Messager messager;
-  private final MultibindingsValidator multibindingsValidator;
-
-  MultibindingsProcessingStep(Messager messager, MultibindingsValidator multibindingsValidator) {
-    this.messager = messager;
-    this.multibindingsValidator = multibindingsValidator;
-  }
-
-  @Override
-  public Set<? extends Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(Multibindings.class);
-  }
-
-  @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (TypeElement element : typesIn(elementsByAnnotation.values())) {
-      if (!multibindingsValidator.wasAlreadyValidated(element)) {
-        multibindingsValidator.validate(element).printMessagesTo(messager);
-      }
-    }
-    return ImmutableSet.of();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
deleted file mode 100644
index 4785b64cb..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.auto.common.MoreTypes.asExecutable;
-import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
-import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_INTERFACE;
-import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_NOT_HAVE_TYPE_PARAMETERS;
-import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.tooManyMethodsForKey;
-import static javax.lang.model.element.ElementKind.INTERFACE;
-
-import com.google.common.collect.ImmutableListMultimap;
-import dagger.Module;
-import dagger.Multibindings;
-import dagger.producers.ProducerModule;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Optional;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-
-/**
- * A {@linkplain ValidationReport validator} for {@link Multibindings @Multibindings}-annotated
- * types.
- */
-final class MultibindingsValidator {
-  private final Elements elements;
-  private final Types types;
-  private final Key.Factory keyFactory;
-  private final KeyFormatter keyFormatter;
-  private final MethodSignatureFormatter methodSignatureFormatter;
-  private final TypeElement objectElement;
-  private final MultibindingsMethodValidator multibindingsMethodValidator;
-  private final Map<TypeElement, ValidationReport<TypeElement>> reports = new HashMap<>();
-
-  MultibindingsValidator(
-      Elements elements,
-      Types types,
-      Key.Factory keyFactory,
-      KeyFormatter keyFormatter,
-      MethodSignatureFormatter methodSignatureFormatter,
-      MultibindingsMethodValidator multibindingsMethodValidator) {
-    this.elements = elements;
-    this.types = types;
-    this.keyFactory = keyFactory;
-    this.keyFormatter = keyFormatter;
-    this.methodSignatureFormatter = methodSignatureFormatter;
-    this.multibindingsMethodValidator = multibindingsMethodValidator;
-    this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
-  }
-  
-  /**
-   * Returns a report containing validation errors for a {@link
-   * Multibindings @Multibindings}-annotated type.
-   */
-  public ValidationReport<TypeElement> validate(TypeElement multibindingsType) {
-    return reports.computeIfAbsent(multibindingsType, this::validateUncached);
-  }
-
-  /**
-   * Returns {@code true} if {@code multibindingsType} was already {@linkplain
-   * #validate(TypeElement) validated}.
-   */
-  boolean wasAlreadyValidated(TypeElement multibindingsType) {
-    return reports.containsKey(multibindingsType);
-  }
-
-  private ValidationReport<TypeElement> validateUncached(TypeElement multibindingsType) {
-    ValidationReport.Builder<TypeElement> validation = ValidationReport.about(multibindingsType);
-    if (!multibindingsType.getKind().equals(INTERFACE)) {
-      validation.addError(MUST_BE_INTERFACE, multibindingsType);
-    }
-    if (!multibindingsType.getTypeParameters().isEmpty()) {
-      validation.addError(MUST_NOT_HAVE_TYPE_PARAMETERS, multibindingsType);
-    }
-    Optional<BindingType> bindingType = bindingType(multibindingsType);
-    if (!bindingType.isPresent()) {
-      validation.addError(MUST_BE_IN_MODULE, multibindingsType);
-    }
-
-    ImmutableListMultimap.Builder<Key, ExecutableElement> methodsByKey =
-        ImmutableListMultimap.builder();
-    for (ExecutableElement method :
-        getLocalAndInheritedMethods(multibindingsType, types, elements)) {
-      // Skip methods in Object.
-      if (method.getEnclosingElement().equals(objectElement)) {
-        continue;
-      }
-      
-      ValidationReport<ExecutableElement> methodReport =
-          multibindingsMethodValidator.validate(method);
-      validation.addItems(methodReport.items());
-
-      if (methodReport.isClean() && bindingType.isPresent()) {
-        methodsByKey.put(
-            keyFactory.forMultibindsMethod(
-                bindingType.get(), asExecutable(method.asType()), method),
-            method);
-      }
-    }
-    for (Map.Entry<Key, Collection<ExecutableElement>> entry :
-        methodsByKey.build().asMap().entrySet()) {
-      Collection<ExecutableElement> methods = entry.getValue();
-      if (methods.size() > 1) {
-        Key key = entry.getKey();
-        validation.addError(tooManyMultibindingsMethodsForKey(key, methods), multibindingsType);
-      }
-    }
-    return validation.build();
-  }
-
-  private String tooManyMultibindingsMethodsForKey(Key key, Collection<ExecutableElement> methods) {
-    StringBuilder builder = new StringBuilder(tooManyMethodsForKey(keyFormatter.format(key)));
-    builder.append(':');
-    methodSignatureFormatter.formatIndentedList(builder, methods, 1, DUPLICATE_SIZE_LIMIT);
-    return builder.toString();
-  }
-
-  private static Optional<BindingType> bindingType(TypeElement multibindingsType) {
-    if (isAnnotationPresent(multibindingsType.getEnclosingElement(), Module.class)) {
-      return Optional.of(BindingType.PROVISION);
-    } else if (isAnnotationPresent(multibindingsType.getEnclosingElement(), ProducerModule.class)) {
-      return Optional.of(BindingType.PRODUCTION);
-    } else {
-      return Optional.empty();
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
index 35ae26c00..3be0aa9d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -26,7 +26,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
-import dagger.Multibindings;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
 import java.lang.annotation.Annotation;
@@ -35,7 +34,7 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-/** A validator for {@link Multibinds} methods or methods in {@link Multibindings} interfaces. */
+/** A validator for {@link Multibinds} methods. */
 class MultibindsMethodValidator extends BindingMethodValidator {
 
   /** Creates a validator for {@link Multibinds @Multibinds} methods. */
diff --git a/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java b/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
index 171d36511..a5b91de49 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
@@ -27,7 +27,6 @@
 import com.google.common.truth.Truth;
 import com.google.testing.compile.JavaFileObjects;
 import dagger.Module;
-import dagger.Multibindings;
 import dagger.producers.ProducerModule;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -55,13 +54,6 @@ static DaggerModuleMethodSubject assertThatProductionModuleMethod(String method)
           .withDeclaration("@ProducerModule abstract class %s { %s }");
     }
 
-    /** Starts a clause testing a Dagger {@link Multibindings @Multibindings} interface method. */
-    static DaggerModuleMethodSubject assertThatMultibindingsMethod(String method) {
-      return assertAbout(daggerModuleMethod())
-          .that(method)
-          .withDeclaration("@Module abstract class %s { @Multibindings interface Empties { %s }}");
-    }
-
     /** Starts a clause testing a method in an unannotated class. */
     static DaggerModuleMethodSubject assertThatMethodInUnannotatedClass(String method) {
       return assertAbout(daggerModuleMethod())
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 83ad31d98..949c0c1c5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -967,8 +967,8 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "",
             "import dagger.Component;",
             "import dagger.Module;",
-            "import dagger.Multibindings;",
             "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
             "import java.util.HashMap;",
             "import java.util.HashSet;",
             "import java.util.Map;",
@@ -976,12 +976,9 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "",
             "final class Outer {",
             "  @Module",
-            "  static class TestModule1 {",
-            "    @Multibindings",
-            "    interface Empties {",
-            "      Map<String, String> stringMap();",
-            "      Set<String> stringSet();",
-            "    }",
+            "  abstract static class TestModule1 {",
+            "    @Multibinds abstract Map<String, String> stringMap();",
+            "    @Multibinds abstract Set<String> stringSet();",
             "  }",
             "",
             "  @Module",
@@ -1003,7 +1000,8 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
     String expectedSetError =
         "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
             + "      Set bindings and declarations:\n"
-            + "          Set<String> test.Outer.TestModule1.Empties.stringSet()\n"
+            + "          @dagger.multibindings.Multibinds Set<String> "
+            + "test.Outer.TestModule1.stringSet()\n"
             + "      Unique bindings and declarations:\n"
             + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
 
@@ -1011,7 +1009,8 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
             + "or declarations:\n"
             + "      Map bindings and declarations:\n"
-            + "          Map<String,String> test.Outer.TestModule1.Empties.stringMap()\n"
+            + "          @dagger.multibindings.Multibinds Map<String,String> "
+            + "test.Outer.TestModule1.stringMap()\n"
             + "      Unique bindings and declarations:\n"
             + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
 
@@ -1021,11 +1020,11 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         .failsToCompile()
         .withErrorContaining(expectedSetError)
         .in(component)
-        .onLine(35)
+        .onLine(32)
         .and()
         .withErrorContaining(expectedMapError)
         .in(component)
-        .onLine(36);
+        .onLine(33);
   }
 
   @Test public void duplicateBindings_TruncateAfterLimit() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java
index e3b1a2ebb..a25c53ad0 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java
@@ -279,40 +279,4 @@ public void invalidIncludedModule() {
         .inFile(module)
         .onLine(5);
   }
-
-  @Test
-  public void invalidNestedMultibindingsType() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.IncludesBadMultibindings",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class IncludesBadMultibindings {",
-            "  @Provides static String string() { return \"a string\"; }",
-            "",
-            "  @Multibindings interface BadMultibindings {",
-            "    String notASetOrMap();",
-            "  }",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = IncludesBadMultibindings.class)",
-            "interface TestComponent {",
-            "  String aString();",
-            "}");
-    assertThat(daggerCompiler().compile(module, component))
-        .hadErrorContaining("test.IncludesBadMultibindings has errors")
-        .inFile(component)
-        .onLine(5);
-  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
deleted file mode 100644
index 95248e4c3..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
+++ /dev/null
@@ -1,399 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMultibindingsMethod;
-import static java.util.Arrays.asList;
-
-import com.google.testing.compile.JavaFileObjects;
-import javax.inject.Qualifier;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class MultibindingsValidatorTest {
-
-  private static final JavaFileObject SOME_QUALIFIER =
-      JavaFileObjects.forSourceLines(
-          "test.SomeQualifier",
-          "package test;",
-          "",
-          "import javax.inject.Qualifier;",
-          "",
-          "@Qualifier",
-          "@interface SomeQualifier {}");
-
-  private static final JavaFileObject OTHER_QUALIFIER =
-      JavaFileObjects.forSourceLines(
-          "test.OtherQualifier",
-          "package test;",
-          "",
-          "import javax.inject.Qualifier;",
-          "",
-          "@Qualifier",
-          "@interface OtherQualifier {}");
-
-  @Test
-  public void abstractClass() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  @Multibindings",
-            "  static abstract class Empties {",
-            "    abstract Set<Object> emptySet();",
-            "    @SomeQualifier abstract Set<Object> emptyQualifiedSet();",
-            "    abstract Map<String, Object> emptyMap();",
-            "    @SomeQualifier abstract Map<String, Object> emptyQualifiedMap();",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Multibindings can be applied only to interfaces")
-        .in(testModule)
-        .onLine(11);
-  }
-
-  @Test
-  public void concreteClass() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  @Multibindings",
-            "  static class Empties {",
-            "    Set<Object> emptySet() { return null; }",
-            "    @SomeQualifier Set<Object> emptyQualifiedSet() { return null; }",
-            "    Map<String, Object> emptyMap() { return null; }",
-            "    @SomeQualifier Map<String, Object> emptyQualifiedMap() { return null; }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Multibindings can be applied only to interfaces")
-        .in(testModule)
-        .onLine(11);
-  }
-
-  @Test
-  public void interfaceHasTypeParameters() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  @Multibindings",
-            "  interface Empties<T> {",
-            "    Set<T> emptySet();",
-            "    @SomeQualifier Set<T> emptyQualifiedSet();",
-            "    Map<String, T> emptyMap();",
-            "    @SomeQualifier Map<String, T> emptyQualifiedMap();",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Multibindings types must not have type parameters")
-        .in(testModule)
-        .onLine(11);
-  }
-
-  @Test
-  public void topLevel() {
-    JavaFileObject testInterface =
-        JavaFileObjects.forSourceLines(
-            "test.TestInterface",
-            "package test;",
-            "",
-            "import dagger.Multibindings;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "@Multibindings",
-            "interface Empties {",
-            "  Set<Object> emptySet();",
-            "  @SomeQualifier Set<Object> emptyQualifiedSet();",
-            "  Map<String, Object> emptyMap();",
-            "  @SomeQualifier Map<String, Object> emptyQualifiedMap();",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testInterface, SOME_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "@Multibindings types must be nested within a @Module or @ProducerModule")
-        .in(testInterface)
-        .onLine(8);
-  }
-
-  @Test
-  public void notWithinModule() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Multibindings;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "class TestModule {",
-            "  @Multibindings",
-            "  interface Empties {",
-            "    Set<Object> emptySet();",
-            "    @SomeQualifier Set<Object> emptyQualifiedSet();",
-            "    Map<String, Object> emptyMap();",
-            "    @SomeQualifier Map<String, Object> emptyQualifiedMap();",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "@Multibindings types must be nested within a @Module or @ProducerModule")
-        .in(testModule)
-        .onLine(9);
-  }
-
-  @Test
-  public void voidMethod() {
-    assertThatMultibindingsMethod("void voidMethod();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void primitiveMethod() {
-    assertThatMultibindingsMethod("int primitive();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void rawMap() {
-    assertThatMultibindingsMethod("Map rawMap();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void wildcardMap() {
-    assertThatMultibindingsMethod("Map<?, ?> wildcardMap();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void providerMap() {
-    assertThatMultibindingsMethod("Map<String, Provider<Object>> providerMap();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void producerMap() {
-    assertThatMultibindingsMethod("Map<String, Producer<Object>> producerMap();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void producedMap() {
-    assertThatMultibindingsMethod("Map<String, Produced<Object>> producedMap();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void rawSet() {
-    assertThatMultibindingsMethod("Set rawSet();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void wildcardSet() {
-    assertThatMultibindingsMethod("Set<?> wildcardSet();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void providerSet() {
-    assertThatMultibindingsMethod("Set<Provider<Object>> providerSet();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void producerSet() {
-    assertThatMultibindingsMethod("Set<Producer<Object>> producerSet();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void producedSet() {
-    assertThatMultibindingsMethod("Set<Produced<Object>> producedSet();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void overqualifiedSet() {
-    assertThatMultibindingsMethod(
-            "@SomeQualifier @OtherQualifier Set<Object> tooManyQualifiersSet();")
-        .importing(SomeQualifier.class, OtherQualifier.class)
-        .hasError("Cannot use more than one @Qualifier");
-  }
-
-  @Test
-  public void overqualifiedMap() {
-    assertThatMultibindingsMethod(
-            "@SomeQualifier @OtherQualifier Map<String, Object> tooManyQualifiersMap();")
-        .importing(SomeQualifier.class, OtherQualifier.class)
-        .hasError("Cannot use more than one @Qualifier");
-  }
-
-  @Test
-  public void hasParameters() {
-    assertThatMultibindingsMethod("Set<String> parameters(Object param);")
-        .hasError("@Multibindings methods cannot have parameters");
-  }
-
-  @Test
-  public void badMethodsOnSupertype() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import dagger.producers.Produced;",
-            "import dagger.producers.Producer;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  interface BaseEmpties {",
-            "    void voidMethod();",
-            "  }",
-            "",
-            "  @Multibindings",
-            "  interface Empties extends BaseEmpties {}",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER, OTHER_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "[test.TestModule.BaseEmpties.voidMethod()] "
-                + "@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(18);
-  }
-
-  @Test
-  public void duplicateKeys() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  @Multibindings",
-            "  interface EmptySets {",
-            "    Set<Object> emptySet();",
-            "    Set<Object> emptySet2();",
-            "  }",
-            "",
-            "  @Multibindings",
-            "  interface EmptyQualifiedSets {",
-            "    @SomeQualifier Set<Object> emptyQualifiedSet();",
-            "    @SomeQualifier Set<Object> emptyQualifiedSet2();",
-            "  }",
-            "",
-            "  @Multibindings",
-            "  interface EmptyMaps {",
-            "    Map<String, Object> emptyMap();",
-            "    Map<String, Object> emptyMap2();",
-            "  }",
-            "",
-            "  @Multibindings",
-            "  interface EmptyQualifiedMaps {",
-            "    @SomeQualifier Map<String, Object> emptyQualifiedMap();",
-            "    @SomeQualifier Map<String, Object> emptyQualifiedMap2();",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Too many @Multibindings methods for Set<Object>:")
-        .in(testModule)
-        .onLine(11)
-        .and()
-        .withErrorContaining("Too many @Multibindings methods for @test.SomeQualifier Set<Object>:")
-        .in(testModule)
-        .onLine(17)
-        .and()
-        .withErrorContaining("Too many @Multibindings methods for Map<String,Provider<Object>>:")
-        .in(testModule)
-        .onLine(23)
-        .and()
-        .withErrorContaining(
-            "Too many @Multibindings methods for @test.SomeQualifier Map<String,Provider<Object>>:")
-        .in(testModule)
-        .onLine(29);
-  }
-
-  @Qualifier
-  public @interface SomeQualifier {}
-
-  @Qualifier
-  public @interface OtherQualifier {}
-}
diff --git a/core/src/main/java/dagger/Multibindings.java b/core/src/main/java/dagger/Multibindings.java
deleted file mode 100644
index c544e092f..000000000
--- a/core/src/main/java/dagger/Multibindings.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger;
-
-import static java.lang.annotation.ElementType.TYPE;
-
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/**
- * Annotates interfaces that declare multibindings.
- *
- * <p>You can declare that a multibound set or map is bound by nesting a
- * {@code @Multibindings}-annotated interface within a module, with methods that return the sets or
- * maps you want to declare.
- *
- * <p>You do not have to use {@code @Multibindings} for sets or maps that have at least one
- * contribution, but you do have to declare them if they may be empty.
- *
- * <pre><code>
- * {@literal @Module}
- * class MyModule {
- *   {@literal @Multibindings}
- *   interface MyMultibindings {
- *     {@literal Set<Foo>} aSet();
- *     {@literal @MyQualifier Set<Foo>} aQualifiedSet();
- *     {@literal Map<String, Foo>} aMap();
- *     {@literal @MyQualifier Map<String, Foo>} aQualifiedMap();
- *   }
- *
- *   {@literal @Provides}
- *   static Object usesMultibindings(
- *       {@literal Set<Foo>} set, {@literal @MyQualifier Map<String, Foo>} map) {
- *     return …
- *   }
- * }
- * </code></pre>
- *
- * <p>All methods on the interface and any supertypes (except for methods on {@link Object}) are
- * used to declare multibindings. The names of the interface and its methods are ignored. A given
- * set or map multibinding can be declared any number of times without error. Dagger never
- * implements the interface or calls any of its methods.
- *
- * @see <a href="http://google.github.io/dagger/multibindings">Multibindings</a>
- */
-@Documented
-@Target(TYPE)
-@Beta
-public @interface Multibindings {}
