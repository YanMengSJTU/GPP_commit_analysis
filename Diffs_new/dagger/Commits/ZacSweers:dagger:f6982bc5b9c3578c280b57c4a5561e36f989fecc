diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 8b917b8b7..3b6d72175 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -200,6 +200,16 @@ public void addField(FieldSpec fieldSpec) {
     component.addField(fieldSpec);
   }
 
+  @Override
+  public void addMethod(MethodSpec methodSpec) {
+    component.addMethod(methodSpec);
+  }
+
+  @Override
+  public String getUniqueMethodName(String name) {
+    return componentMethodNames.getUniqueName(name);
+  }
+
   @Override
   public void addType(TypeSpec typeSpec) {
     component.addType(typeSpec);
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 7dd85e4df..6a56b70e1 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -207,13 +207,21 @@ private BindingExpression create(
         case PROVISION:
           if (!provisionBinding.scope().isPresent()
               && provisionBinding.bindingElement().isPresent()) {
-            return new SimpleMethodBindingExpression(
-                compilerOptions,
-                provisionBinding,
-                bindingExpression,
-                componentBindingExpressions,
-                generatedComponentModel,
-                componentRequirementFields);
+            BindingExpression simpleMethodBindingExpression =
+                new SimpleMethodBindingExpression(
+                    compilerOptions,
+                    provisionBinding,
+                    bindingExpression,
+                    componentBindingExpressions,
+                    generatedComponentModel,
+                    componentRequirementFields);
+            return compilerOptions.experimentalAndroidMode()
+                ? new PrivateMethodBindingExpression(
+                    resolvedBindings,
+                    componentName,
+                    generatedComponentModel,
+                    simpleMethodBindingExpression)
+                : simpleMethodBindingExpression;
           }
           // fall through
 
diff --git a/java/dagger/internal/codegen/BindingVariableNamer.java b/java/dagger/internal/codegen/BindingVariableNamer.java
index 36db21ab6..496ef8e08 100644
--- a/java/dagger/internal/codegen/BindingVariableNamer.java
+++ b/java/dagger/internal/codegen/BindingVariableNamer.java
@@ -22,8 +22,11 @@
 
 import java.util.Iterator;
 import javax.lang.model.element.Element;
+import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
 /**
@@ -34,6 +37,44 @@
  * @since 2.0
  */
 final class BindingVariableNamer {
+  private static final TypeVisitor<Void, StringBuilder> TYPE_NAMER =
+      new SimpleTypeVisitor6<Void, StringBuilder>() {
+        @Override
+        public Void visitDeclared(DeclaredType declaredType, StringBuilder builder) {
+          Element element = declaredType.asElement();
+          if (isSubcomponentBuilder(element)) {
+            // Most Subcomponent builders are named "Builder", so add their associated
+            // Subcomponent type so that they're not all "builderProvider{N}"
+            builder.append(element.getEnclosingElement().getSimpleName());
+          }
+          builder.append(element.getSimpleName());
+          Iterator<? extends TypeMirror> argumentIterator =
+              declaredType.getTypeArguments().iterator();
+          if (argumentIterator.hasNext()) {
+            builder.append("Of");
+            TypeMirror first = argumentIterator.next();
+            first.accept(this, builder);
+            while (argumentIterator.hasNext()) {
+              builder.append("And");
+              argumentIterator.next().accept(this, builder);
+            }
+          }
+          return null;
+        }
+
+        @Override
+        public Void visitPrimitive(PrimitiveType type, StringBuilder builder) {
+          builder.append(LOWER_CAMEL.to(UPPER_CAMEL, type.toString()));
+          return null;
+        }
+
+        @Override
+        public Void visitArray(ArrayType type, StringBuilder builder) {
+          type.getComponentType().accept(this, builder);
+          builder.append("Array");
+          return null;
+        }
+      };
 
   private BindingVariableNamer() {}
 
@@ -47,32 +88,7 @@ static String name(Binding binding) {
     }
 
     TypeMirror type = typeToName(binding);
-    type.accept(
-        new SimpleTypeVisitor6<Void, StringBuilder>() {
-          @Override
-          public Void visitDeclared(DeclaredType declaredType, StringBuilder builder) {
-            Element element = declaredType.asElement();
-            if (isSubcomponentBuilder(element)) {
-              // Most Subcomponent builders are named "Builder", so add their associated
-              // Subcomponent type so that they're not all "builderProvider{N}"
-              builder.append(element.getEnclosingElement().getSimpleName());
-            }
-            builder.append(element.getSimpleName());
-            Iterator<? extends TypeMirror> argumentIterator =
-                declaredType.getTypeArguments().iterator();
-            if (argumentIterator.hasNext()) {
-              builder.append("Of");
-              TypeMirror first = argumentIterator.next();
-              first.accept(this, builder);
-              while (argumentIterator.hasNext()) {
-                builder.append("And");
-                argumentIterator.next().accept(this, builder);
-              }
-            }
-            return null;
-          }
-        },
-        builder);
+    type.accept(TYPE_NAMER, builder);
 
     return UPPER_CAMEL.to(LOWER_CAMEL, builder.toString());
   }
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 9800a4d81..54d95187f 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -28,12 +28,20 @@
   /** Adds the given field to the component. */
   void addField(FieldSpec fieldSpec);
 
+  /** Adds the given method to the component. */
+  void addMethod(MethodSpec methodSpec);
+
   /** Adds the given code block to the initialize methods of the component. */
   void addInitialization(CodeBlock codeBlock);
 
   /** Adds the given type to the component. */
   void addType(TypeSpec typeSpec);
 
+  // TODO(user): add getUniqueFieldName(String name).
+
+  /** Returns a unique method name for the component based on the given name. */
+  String getUniqueMethodName(String name);
+
   /** Returns the corresponding subcomponent name for the given subcomponent descriptor. */
   String getSubcomponentName(ComponentDescriptor subcomponentDescriptor);
 
diff --git a/java/dagger/internal/codegen/OptionalBindingExpression.java b/java/dagger/internal/codegen/OptionalBindingExpression.java
index f2d8efdb6..a4cca110a 100644
--- a/java/dagger/internal/codegen/OptionalBindingExpression.java
+++ b/java/dagger/internal/codegen/OptionalBindingExpression.java
@@ -58,6 +58,7 @@ CodeBlock getInstanceDependencyExpression(
 
     // If the dependency type is inaccessible, then we have to use Optional.<Object>of(...), or else
     // we will get "incompatible types: inference variable has incompatible bounds.
+    // TODO(user): Do we need presentObjectExpression in androidExperimentalMode?
     return isTypeAccessibleFrom(dependency.key().type(), requestingClass.packageName())
         ? optionalKind.presentExpression(dependencyExpression)
         : optionalKind.presentObjectExpression(dependencyExpression);
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
new file mode 100644
index 000000000..85611d8d5
--- /dev/null
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.asExecutable;
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import java.util.EnumMap;
+import java.util.Map;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * A binding expression that wraps the dependency expressions in a private, no-arg method.
+ *
+ * <p>Dependents of this binding expression will just called the no-arg method.
+ */
+final class PrivateMethodBindingExpression extends BindingExpression {
+  private final ClassName componentName;
+  private final GeneratedComponentModel generatedComponentModel;
+  private final BindingExpression delegate;
+  private final Map<DependencyRequest.Kind, MethodSpec> methods =
+      new EnumMap<>(DependencyRequest.Kind.class);
+  private final ContributionBinding binding;
+  private final TypeName instanceType;
+
+  PrivateMethodBindingExpression(
+      ResolvedBindings resolvedBindings,
+      ClassName componentName,
+      GeneratedComponentModel generatedComponentModel,
+      BindingExpression delegate) {
+    super(resolvedBindings);
+    this.componentName = componentName;
+    this.generatedComponentModel = generatedComponentModel;
+    this.delegate = delegate;
+    binding = resolvedBindings.contributionBinding();
+    instanceType = accessibleType(binding.contributedType(), componentName);
+  }
+
+  @Override
+  CodeBlock getDependencyExpression(DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    // TODO(user): we should just use the component method if one matches instead of creating one.
+    switch (requestKind) {
+      case INSTANCE:
+        MethodSpec method = methods.computeIfAbsent(requestKind, this::createMethod);
+        return componentName.equals(requestingClass)
+            ? CodeBlock.of("$N()", method)
+            : CodeBlock.of("$T.this.$N()", componentName, method);
+      default:
+        return delegate.getDependencyExpression(requestKind, requestingClass);
+    }
+  }
+
+  /** Creates the no-arg method used for dependency expressions and returns the method's name. */
+  private MethodSpec createMethod(DependencyRequest.Kind requestKind) {
+    MethodSpec method =
+        methodBuilder(generatedComponentModel.getUniqueMethodName(methodName(requestKind)))
+            .addModifiers(PRIVATE)
+            .returns(returnType())
+            .addStatement("return $L", delegate.getDependencyExpression(requestKind, componentName))
+            .build();
+
+    generatedComponentModel.addMethod(method);
+    return method;
+  }
+
+  private TypeName returnType() {
+    // TODO(user): pull ProvisionBinding.providesPrimitiveType() up to ContributionBinding.
+    if (binding.bindingElement().isPresent()) {
+      TypeMirror moduleReturnType = asExecutable(binding.bindingElement().get()).getReturnType();
+      if (moduleReturnType.getKind().isPrimitive()) {
+        return TypeName.get(moduleReturnType);
+      }
+    }
+    return instanceType;
+  }
+
+  /** Returns the canonical name for a no-arg dependency expression method. */
+  private String methodName(DependencyRequest.Kind dependencyKind) {
+    // TODO(user): Use a better name for @MapKey binding instances.
+    return String.format("get%s%s", bindingName(), dependencyKindName(dependencyKind));
+  }
+
+  /** Returns the canonical name for the {@link Binding}. */
+  private String bindingName() {
+    return LOWER_CAMEL.to(UPPER_CAMEL, BindingVariableNamer.name(binding));
+  }
+
+  /** Returns a canonical name for the {@link DependencyRequest.Kind}. */
+  private static String dependencyKindName(DependencyRequest.Kind kind) {
+    return UPPER_UNDERSCORE.to(UPPER_CAMEL, kind.name());
+  }
+
+  // TODO(ronshapiro): Move this logic to some common place.
+  /** Returns a {@link TypeName} for the binding that is accessible to the component. */
+  private static TypeName accessibleType(TypeMirror typeMirror, ClassName componentName) {
+    if (Accessibility.isTypeAccessibleFrom(typeMirror, componentName.packageName())) {
+      return TypeName.get(typeMirror);
+    } else if (Accessibility.isRawTypeAccessible(typeMirror, componentName.packageName())) {
+      return TypeNames.rawTypeName(TypeName.get(typeMirror));
+    } else {
+      return TypeName.OBJECT;
+    }
+  }
+}
diff --git a/javatests/dagger/functional/multipackage/a/InaccessibleGeneric.java b/javatests/dagger/functional/multipackage/a/InaccessibleGeneric.java
new file mode 100644
index 000000000..f5da79db8
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/a/InaccessibleGeneric.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.a;
+
+import javax.inject.Inject;
+
+final class InaccessibleGeneric<T> {
+  @Inject
+  InaccessibleGeneric() {}
+}
diff --git a/javatests/dagger/functional/multipackage/a/UsesInaccessible.java b/javatests/dagger/functional/multipackage/a/UsesInaccessible.java
index 745bb1dc9..7a8ed7f73 100644
--- a/javatests/dagger/functional/multipackage/a/UsesInaccessible.java
+++ b/javatests/dagger/functional/multipackage/a/UsesInaccessible.java
@@ -26,5 +26,6 @@
   public UsesInaccessible(
       Inaccessible inaccessible,
       Set<Inaccessible> inaccessibleSet,
-      Map<String, Inaccessible> inaccessibleMap) {}
+      Map<String, Inaccessible> inaccessibleMap,
+      InaccessibleGeneric<Integer> inaccessibleGeneric) {}
 }
diff --git a/javatests/dagger/internal/codegen/CompilerMode.java b/javatests/dagger/internal/codegen/CompilerMode.java
new file mode 100644
index 000000000..3b4a2e8ea
--- /dev/null
+++ b/javatests/dagger/internal/codegen/CompilerMode.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+
+/** The configuration options for compiler modes. */
+enum CompilerMode {
+  DEFAULT,
+  EXPERIMENTAL_ANDROID("-Adagger.experimentalAndroidMode=enabled");
+
+  /** Returns the compiler modes as a list of parameters for parameterized tests */
+  static final ImmutableList<Object[]> TEST_PARAMETERS =
+      ImmutableList.copyOf(
+          new Object[][] {
+            {CompilerMode.DEFAULT}, {CompilerMode.EXPERIMENTAL_ANDROID},
+          });
+
+  private final ImmutableList<String> javacopts;
+
+  private CompilerMode(String... javacopts) {
+    this.javacopts = ImmutableList.copyOf(javacopts);
+  }
+
+  /** Returns the javacopts for this compiler mode. */
+  FluentIterable<String> javacopts() {
+    return FluentIterable.from(javacopts);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/Compilers.java b/javatests/dagger/internal/codegen/Compilers.java
index 70756c247..fed935886 100644
--- a/javatests/dagger/internal/codegen/Compilers.java
+++ b/javatests/dagger/internal/codegen/Compilers.java
@@ -23,27 +23,24 @@
 
 import com.google.auto.value.processor.AutoAnnotationProcessor;
 import com.google.common.base.Splitter;
+import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compiler;
 
 /** {@link Compiler} instances for testing Dagger. */
 final class Compilers {
+  private static final String GUAVA = "guava";
+
+  static final ImmutableList<String> CLASS_PATH_WITHOUT_GUAVA_OPTION =
+      ImmutableList.of(
+          "-classpath",
+          Splitter.on(PATH_SEPARATOR.value())
+              .splitToList(JAVA_CLASS_PATH.value())
+              .stream()
+              .filter(jar -> !jar.contains(GUAVA))
+              .collect(joining(PATH_SEPARATOR.value())));
 
   /** Returns a compiler that runs the Dagger processor. */
   static Compiler daggerCompiler() {
     return javac().withProcessors(new ComponentProcessor(), new AutoAnnotationProcessor());
   }
-
-  static Compiler daggerCompilerWithoutGuava() {
-    return daggerCompiler().withOptions("-classpath", classpathWithoutGuava());
-  }
-
-  private static final String GUAVA = "guava";
-
-  private static String classpathWithoutGuava() {
-    return Splitter.on(PATH_SEPARATOR.value())
-        .splitToList(JAVA_CLASS_PATH.value())
-        .stream()
-        .filter(jar -> !jar.contains(GUAVA))
-        .collect(joining(PATH_SEPARATOR.value()));
-  }
 }
diff --git a/javatests/dagger/internal/codegen/ComponentBuilderTest.java b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
index e09b2b101..b152c20b9 100644
--- a/javatests/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
@@ -23,14 +23,26 @@
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 /** Tests for {@link dagger.Component.Builder} */
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class ComponentBuilderTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public ComponentBuilderTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
 
   private static final ErrorMessages.ComponentBuilderMessages MSGS =
       ErrorMessages.ComponentBuilderMessages.INSTANCE;
@@ -64,38 +76,82 @@ public void testEmptyBuilder() {
             "     SimpleComponent build();",
             "  }",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {}",
-            "",
-            "  public static SimpleComponent.Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType();",
-            "  }",
-            "",
-            "  private static final class Builder implements SimpleComponent.Builder {",
-            "    @Override",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static SimpleComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return getSomeInjectableTypeInstance();",
+                "  }",
+                "",
+                "  private static final class Builder implements SimpleComponent.Builder {",
+                "    @Override",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static SimpleComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  private static final class Builder implements SimpleComponent.Builder {",
+                "    @Override",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectableTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -134,60 +190,124 @@ public void testUsesBuildAndSetterNames() {
             "    TestComponent create();",
             "  }",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private TestModule testModule;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static TestComponent.Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().create();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.testModule = builder.testModule;",
-            "  }",
-            "",
-            "  @Override",
-            "  public String string() {",
-            "    return Preconditions.checkNotNull(",
-            "        testModule.string()," + NPE_FROM_PROVIDES_METHOD + ");",
-            "  }",
-            "",
-            "  private static final class Builder implements TestComponent.Builder {",
-            "    private TestModule testModule;",
-            "",
-            "    @Override",
-            "    public TestComponent create() {",
-            "      if (testModule == null) {",
-            "        this.testModule = new TestModule();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    @Override",
-            "    public Builder setTestModule(TestModule testModule) {",
-            "      this.testModule = Preconditions.checkNotNull(testModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(moduleFile, componentFile);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule testModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static TestComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().create();",
+                "  }",
+                "",
+                "  private String getStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule.string()," + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule = builder.testModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public String string() {",
+                "    return getStringInstance();",
+                "  }",
+                "",
+                "  private static final class Builder implements TestComponent.Builder {",
+                "    private TestModule testModule;",
+                "",
+                "    @Override",
+                "    public TestComponent create() {",
+                "      if (testModule == null) {",
+                "        this.testModule = new TestModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Override",
+                "    public Builder setTestModule(TestModule testModule) {",
+                "      this.testModule = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule testModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static TestComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().create();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule = builder.testModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public String string() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule.string()," + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private static final class Builder implements TestComponent.Builder {",
+                "    private TestModule testModule;",
+                "",
+                "    @Override",
+                "    public TestComponent create() {",
+                "      if (testModule == null) {",
+                "        this.testModule = new TestModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Override",
+                "    public Builder setTestModule(TestModule testModule) {",
+                "      this.testModule = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(moduleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -239,72 +359,154 @@ public void testIgnoresModulesNotInApi() {
             "    TestComponent build();",
             "  }",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private TestModule1 testModule1;",
-            "  private TestModule2 testModule2;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static TestComponent.Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.testModule1 = builder.testModule1;",
-            "    this.testModule2 = builder.testModule2;",
-            "  }",
-            "",
-            "  @Override",
-            "  public String string() {",
-            "    return Preconditions.checkNotNull(",
-            "        testModule1.string()," + NPE_FROM_PROVIDES_METHOD + ");",
-            "  }",
-            "",
-            "  @Override",
-            "  public Integer integer() {",
-            "    return Preconditions.checkNotNull(",
-            "        testModule2.integer()," + NPE_FROM_PROVIDES_METHOD + ");",
-            "  }",
-            "",
-            "  private static final class Builder implements TestComponent.Builder {",
-            "    private TestModule1 testModule1;",
-            "    private TestModule2 testModule2;",
-            "",
-            "    @Override",
-            "    public TestComponent build() {",
-            "      if (testModule1 == null) {",
-            "        this.testModule1 = new TestModule1();",
-            "      }",
-            "      if (testModule2 == null) {",
-            "        this.testModule2 = new TestModule2();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    @Override",
-            "    public Builder testModule1(TestModule1 testModule1) {",
-            "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(module1, module2, componentFile);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule1 testModule1;",
+                "  private TestModule2 testModule2;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static TestComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private String getStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule1.string()," + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Integer getIntegerInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule2.integer()," + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule1 = builder.testModule1;",
+                "    this.testModule2 = builder.testModule2;",
+                "  }",
+                "",
+                "  @Override",
+                "  public String string() {",
+                "    return getStringInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Integer integer() {",
+                "    return getIntegerInstance();",
+                "  }",
+                "",
+                "  private static final class Builder implements TestComponent.Builder {",
+                "    private TestModule1 testModule1;",
+                "    private TestModule2 testModule2;",
+                "",
+                "    @Override",
+                "    public TestComponent build() {",
+                "      if (testModule1 == null) {",
+                "        this.testModule1 = new TestModule1();",
+                "      }",
+                "      if (testModule2 == null) {",
+                "        this.testModule2 = new TestModule2();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Override",
+                "    public Builder testModule1(TestModule1 testModule1) {",
+                "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule1 testModule1;",
+                "  private TestModule2 testModule2;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static TestComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule1 = builder.testModule1;",
+                "    this.testModule2 = builder.testModule2;",
+                "  }",
+                "",
+                "  @Override",
+                "  public String string() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule1.string()," + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public Integer integer() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule2.integer()," + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private static final class Builder implements TestComponent.Builder {",
+                "    private TestModule1 testModule1;",
+                "    private TestModule2 testModule2;",
+                "",
+                "    @Override",
+                "    public TestComponent build() {",
+                "      if (testModule1 == null) {",
+                "        this.testModule1 = new TestModule1();",
+                "      }",
+                "      if (testModule2 == null) {",
+                "        this.testModule2 = new TestModule2();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Override",
+                "    public Builder testModule1(TestModule1 testModule1) {",
+                "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module1, module2, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -333,7 +535,8 @@ public void testMoreThanOneBuilderFails() {
             "     SimpleComponent build();",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -360,7 +563,8 @@ public void testBuilderGenericsFails() {
             "     SimpleComponent build();",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(MSGS.generics()).inFile(componentFile);
   }
@@ -376,7 +580,8 @@ public void testBuilderNotInComponentFails() {
             "",
             "@Component.Builder",
             "interface Builder {}");
-    Compilation compilation = daggerCompiler().compile(builder);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(builder);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(MSGS.mustBeInComponent()).inFile(builder);
   }
@@ -396,7 +601,8 @@ public void testBuilderMissingBuildMethodFails() {
             "  @Component.Builder",
             "  interface Builder {}",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(MSGS.missingBuildMethod()).inFile(componentFile);
   }
@@ -473,7 +679,8 @@ public void testBuilderBindsInstanceNoCreateGenerated() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -495,7 +702,8 @@ public void testPrivateBuilderFails() {
             "  @Component.Builder",
             "  private interface Builder {}",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(MSGS.isPrivate()).inFile(componentFile);
   }
@@ -515,7 +723,8 @@ public void testNonStaticBuilderFails() {
             "  @Component.Builder",
             "  abstract class Builder {}",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(MSGS.mustBeStatic()).inFile(componentFile);
   }
@@ -535,7 +744,8 @@ public void testNonAbstractBuilderFails() {
             "  @Component.Builder",
             "  static class Builder {}",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(MSGS.mustBeAbstract()).inFile(componentFile);
   }
@@ -557,7 +767,8 @@ public void testBuilderOneCxtorWithArgsFails() {
             "    Builder(String unused) {}",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(MSGS.cxtorOnlyOneAndNoArgs()).inFile(componentFile);
   }
@@ -580,7 +791,8 @@ public void testBuilderMoreThanOneCxtorFails() {
             "    Builder(String unused) {}",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(MSGS.cxtorOnlyOneAndNoArgs()).inFile(componentFile);
   }
@@ -600,7 +812,8 @@ public void testBuilderEnumFails() {
             "  @Component.Builder",
             "  enum Builder {}",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(MSGS.mustBeClassOrInterface()).inFile(componentFile);
   }
@@ -622,7 +835,8 @@ public void testBuilderBuildReturnsWrongTypeFails() {
             "    String build();",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(MSGS.buildMustReturnComponentType())
@@ -649,7 +863,8 @@ public void testInheritedBuilderBuildReturnsWrongTypeFails() {
             "  @Component.Builder",
             "  interface Builder extends Parent {}",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
@@ -675,7 +890,8 @@ public void testTwoBuildMethodsFails() {
             "    SimpleComponent create();",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(String.format(MSGS.twoBuildMethods(), "build"))
@@ -703,7 +919,8 @@ public void testInheritedTwoBuildMethodsFails() {
             "  @Component.Builder",
             "  interface Builder extends Parent {}",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
@@ -730,7 +947,8 @@ public void testMoreThanOneArgFails() {
             "    Builder set(Number n, Double d);",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(MSGS.methodsMustTakeOneArg())
@@ -762,7 +980,8 @@ public void testInheritedMoreThanOneArgFails() {
             "  @Component.Builder",
             "  interface Builder extends Parent {}",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -790,7 +1009,8 @@ public void testSetterReturningNonVoidOrBuilderFails() {
             "    String set(Integer i);",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
@@ -818,7 +1038,8 @@ public void testInheritedSetterReturningNonVoidOrBuilderFails() {
             "  @Component.Builder",
             "  interface Builder extends Parent {}",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -845,7 +1066,8 @@ public void testGenericsOnSetterMethodFails() {
             "    <T> Builder set(T t);",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
@@ -873,7 +1095,8 @@ public void testGenericsOnInheritedSetterMethodFails() {
             "  @Component.Builder",
             "  interface Builder extends Parent {}",
             "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -915,7 +1138,8 @@ public void testMultipleSettersPerTypeFails() {
             "    void set2(TestModule s);",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(moduleFile, componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(moduleFile, componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -963,7 +1187,8 @@ public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
             "    void set2(TestModule s);",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(moduleFile, componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(moduleFile, componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -1001,7 +1226,10 @@ public void testExtraSettersFails() {
             "",
             "@Module",
             "abstract class AbstractModule {}");
-    Compilation compilation = daggerCompiler().compile(componentFile, abstractModule);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(componentFile, abstractModule);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -1130,7 +1358,8 @@ public void covariantBuildMethodReturnType() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(foo, supertype, component);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(foo, supertype, component);
     assertThat(compilation).succeededWithoutWarnings();
   }
 
@@ -1182,7 +1411,10 @@ public void covariantBuildMethodReturnType_hasNewMethod() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(foo, bar, supertype, component);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, bar, supertype, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .hadWarningContaining(
@@ -1249,7 +1481,9 @@ public void covariantBuildMethodReturnType_hasNewMethod_buildMethodInherited() {
             "}");
 
     Compilation compilation =
-        daggerCompiler().compile(foo, bar, supertype, builderSupertype, component);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, bar, supertype, builderSupertype, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .hadWarningContaining(
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index bf6137779..72d5ce4b4 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -36,6 +36,7 @@
 import java.io.IOException;
 import java.io.Writer;
 import java.lang.annotation.Annotation;
+import java.util.Collection;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.ProcessingEnvironment;
@@ -49,10 +50,22 @@
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class ComponentProcessorTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public ComponentProcessorTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
   private static final CodeBlock NPE_FROM_COMPONENT_METHOD =
       stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
   private static final CodeBlock NPE_FROM_PROVIDES_METHOD =
@@ -66,7 +79,8 @@
         "",
         "@Component",
         "final class NotAComponent {}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("interface");
   }
@@ -81,7 +95,8 @@
         "enum NotAComponent {",
         "  INSTANCE",
         "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("interface");
   }
@@ -94,7 +109,8 @@
         "",
         "@Component",
         "@interface NotAComponent {}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("interface");
   }
@@ -107,7 +123,8 @@
         "",
         "@Component(modules = Object.class)",
         "interface NotAComponent {}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("is not annotated with @Module");
   }
@@ -137,7 +154,8 @@ public void componentWithInvalidModule() {
             "interface BadComponent {",
             "  Object object();",
             "}");
-    Compilation compilation = daggerCompiler().compile(module, component);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(module, component);
     assertThat(compilation)
         .hadErrorContaining("test.BadModule has errors")
         .inFile(component)
@@ -188,7 +206,10 @@ public void componentWithInvalidModule() {
         "  List<Integer> listOfInteger();",
         "}");
 
-    Compilation compilation = daggerCompiler().compile(parent, child, another, componentFile);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(parent, child, another, componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("java.util.List<java.lang.Integer> is bound multiple times");
@@ -222,7 +243,8 @@ public void componentWithInvalidModule() {
         "}");
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.privateMemberValidation=WARNING")
+            .withOptions(
+                compilerMode.javacopts().append("-Adagger.privateMemberValidation=WARNING"))
             .compile(outerClass, componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
@@ -251,53 +273,111 @@ public void componentWithInvalidModule() {
         "  Lazy<SomeInjectableType> lazySomeInjectableType();",
         "  Provider<SomeInjectableType> someInjectableTypeProvider();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Lazy;",
-            "import dagger.internal.DoubleCheck;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-            "    return DoubleCheck.lazy(SomeInjectableType_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
-            "    return SomeInjectableType_Factory.create();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.Lazy;",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return getSomeInjectableTypeInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+                "    return DoubleCheck.lazy(SomeInjectableType_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+                "    return SomeInjectableType_Factory.create();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.Lazy;",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+                "    return DoubleCheck.lazy(SomeInjectableType_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+                "    return SomeInjectableType_Factory.create();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectableTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -385,7 +465,10 @@ public void componentWithInvalidModule() {
             "    }",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectableTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -412,53 +495,109 @@ public void componentWithInvalidModule() {
         "  }",
         "}");
 
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerOuterType_SimpleComponent",
-            "package test;",
-            "",
-            "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerOuterType_SimpleComponent",
-            "    implements OuterType.SimpleComponent {",
-            "  private DaggerOuterType_SimpleComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static OuterType.SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public OuterType.A a() {",
-            "    return new OuterType.A();",
-            "  }",
-            "",
-            "  @Override",
-            "  public void inject(OuterType.B b) {",
-            "    injectB(b);",
-            "  }",
-            "",
-            "  @CanIgnoreReturnValue",
-            "  private OuterType.B injectB(OuterType.B instance) {",
-            "    OuterType_B_MembersInjector.injectA(instance, new OuterType.A());",
-            "    return instance;",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public OuterType.SimpleComponent build() {",
-            "      return new DaggerOuterType_SimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(nestedTypesFile);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerOuterType_SimpleComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerOuterType_SimpleComponent",
+                "    implements OuterType.SimpleComponent {",
+                "  private DaggerOuterType_SimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static OuterType.SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private OuterType.A getAInstance() {",
+                "    return new OuterType.A();",
+                "  }",
+                "",
+                "  @Override",
+                "  public OuterType.A a() {",
+                "    return getAInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void inject(OuterType.B b) {",
+                "    injectB(b);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private OuterType.B injectB(OuterType.B instance) {",
+                "    OuterType_B_MembersInjector.injectA(instance, getAInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public OuterType.SimpleComponent build() {",
+                "      return new DaggerOuterType_SimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerOuterType_SimpleComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerOuterType_SimpleComponent",
+                "    implements OuterType.SimpleComponent {",
+                "  private DaggerOuterType_SimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static OuterType.SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public OuterType.A a() {",
+                "    return new OuterType.A();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void inject(OuterType.B b) {",
+                "    injectB(b);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private OuterType.B injectB(OuterType.B instance) {",
+                "    OuterType_B_MembersInjector.injectA(instance, new OuterType.A());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public OuterType.SimpleComponent build() {",
+                "      return new DaggerOuterType_SimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(nestedTypesFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerOuterType_SimpleComponent")
@@ -508,68 +647,141 @@ public void componentWithInvalidModule() {
         "interface TestComponent {",
         "  A a();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private TestModule testModule;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.testModule = builder.testModule;",
-            "  }",
-            "",
-            "  @Override",
-            "  public A a() {",
-            "    return new A(Preconditions.checkNotNull(",
-            "        testModule.b(new C()), " + NPE_FROM_PROVIDES_METHOD + ");",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private TestModule testModule;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (testModule == null) {",
-            "        this.testModule = new TestModule();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder testModule(TestModule testModule) {",
-            "      this.testModule = Preconditions.checkNotNull(testModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(aFile, bFile, cFile, moduleFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule testModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private C getCInstance() {",
+                "    return new C();",
+                "  }",
+                "",
+                "  private B getBInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule.b(getCInstance()), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private A getAInstance() {",
+                "    return new A(getBInstance());",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule = builder.testModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return getAInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private TestModule testModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (testModule == null) {",
+                "        this.testModule = new TestModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder testModule(TestModule testModule) {",
+                "      this.testModule = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule testModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule = builder.testModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return new A(Preconditions.checkNotNull(",
+                "        testModule.b(new C()), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private TestModule testModule;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (testModule == null) {",
+                "        this.testModule = new TestModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder testModule(TestModule testModule) {",
+                "      this.testModule = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(aFile, bFile, cFile, moduleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
   @Test
   public void componentWithAbstractModule() {
     JavaFileObject aFile =
@@ -622,44 +834,98 @@ public void componentWithAbstractModule() {
             "interface TestComponent {",
             "  A a();",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public A a() {",
-            "    return new A(Preconditions.checkNotNull(",
-            "        TestModule.b(new C()), " + NPE_FROM_PROVIDES_METHOD + "));",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private C getCInstance() {",
+                "    return new C();",
+                "  }",
+                "",
+                "  private B getBInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule.b(getCInstance()), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private A getAInstance() {",
+                "    return new A(getBInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return getAInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return new A(Preconditions.checkNotNull(",
+                "        TestModule.b(new C()), " + NPE_FROM_PROVIDES_METHOD + "));",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(aFile, bFile, cFile, moduleFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(aFile, bFile, cFile, moduleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -801,6 +1067,7 @@ public void componentWithAbstractModule() {
         "}");
     Compilation compilation =
         daggerCompiler()
+            .withOptions(compilerMode.javacopts())
             .compile(
                 always,
                 testModule,
@@ -833,7 +1100,9 @@ public void generatedTransitiveModule() {
         "",
         "@Component(modules = RootModule.class)",
         "interface TestComponent {}");
-    assertThat(daggerCompiler().compile(rootModule, component)).failed();
+    assertThat(
+            daggerCompiler().withOptions(compilerMode.javacopts()).compile(rootModule, component))
+        .failed();
     assertThat(
             daggerCompiler(
                     new GeneratingProcessor(
@@ -870,7 +1139,9 @@ public void generatedModuleInSubcomponent() {
             "interface TestComponent {",
             "  ChildComponent childComponent();",
             "}");
-    assertThat(daggerCompiler().compile(subcomponent, component)).failed();
+    assertThat(
+            daggerCompiler().withOptions(compilerMode.javacopts()).compile(subcomponent, component))
+        .failed();
     assertThat(
             daggerCompiler(
                     new GeneratingProcessor(
@@ -926,90 +1197,146 @@ public void subcomponentNotGeneratedIfNotUsedInGraph() {
             "  }",
             "}");
 
-    JavaFileObject generatedComponentWithoutSubcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParent implements Parent {",
-            "",
-            "  private DaggerParent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Parent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public String notSubcomponent() {",
-            "    return Preconditions.checkNotNull(",
-            "        ParentModule.notSubcomponent(), " + NPE_FROM_PROVIDES_METHOD + ");",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "",
-            "    private Builder() {}",
-            "",
-            "    public Parent build() {",
-            "      return new DaggerParent(this);",
-            "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder parentModule(ParentModule parentModule) {",
-            "      Preconditions.checkNotNull(parentModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(component, module, subcomponent);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerParent")
-        .hasSourceEquivalentTo(generatedComponentWithoutSubcomponent);
-  }
-
-  @Test
-  public void testDefaultPackage() {
-    JavaFileObject aClass = JavaFileObjects.forSourceLines("AClass", "class AClass {}");
-    JavaFileObject bClass = JavaFileObjects.forSourceLines("BClass",
-        "import javax.inject.Inject;",
-        "",
-        "class BClass {",
-        "  @Inject BClass(AClass a) {}",
-        "}");
-    JavaFileObject aModule = JavaFileObjects.forSourceLines("AModule",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module class AModule {",
-        "  @Provides AClass aClass() {",
-        "    return new AClass();",
-        "  }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("SomeComponent",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = AModule.class)",
-        "interface SomeComponent {",
-        "  BClass bClass();",
-        "}");
-    assertThat(daggerCompiler().compile(aModule, aClass, bClass, component)).succeeded();
-  }
-
-  @Test public void membersInjection() {
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private DaggerParent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private String getStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        ParentModule.notSubcomponent(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public String notSubcomponent() {",
+                "    return getStringInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "",
+                "  private DaggerParent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public String notSubcomponent() {",
+                "    return Preconditions.checkNotNull(",
+                "        ParentModule.notSubcomponent(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(component, module, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void testDefaultPackage() {
+    JavaFileObject aClass = JavaFileObjects.forSourceLines("AClass", "class AClass {}");
+    JavaFileObject bClass = JavaFileObjects.forSourceLines("BClass",
+        "import javax.inject.Inject;",
+        "",
+        "class BClass {",
+        "  @Inject BClass(AClass a) {}",
+        "}");
+    JavaFileObject aModule = JavaFileObjects.forSourceLines("AModule",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module class AModule {",
+        "  @Provides AClass aClass() {",
+        "    return new AClass();",
+        "  }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("SomeComponent",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = AModule.class)",
+        "interface SomeComponent {",
+        "  BClass bClass();",
+        "}");
+    assertThat(
+            daggerCompiler()
+                .withOptions(compilerMode.javacopts())
+                .compile(aModule, aClass, bClass, component))
+        .succeeded();
+  }
+
+  @Test public void membersInjection() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
         "final class SomeInjectableType {",
         "  @Inject SomeInjectableType() {}",
         "}");
@@ -1034,53 +1361,111 @@ public void testDefaultPackage() {
         "  void inject(SomeInjectedType instance);",
         "  SomeInjectedType injectAndReturn(SomeInjectedType instance);",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private DaggerSimpleComponent(Builder builder) {}",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return new Builder().build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public void inject(SomeInjectedType instance) {",
-        "    injectSomeInjectedType(instance);",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
-        "    return injectSomeInjectedType(instance);",
-        "  }",
-        "",
-        "  @CanIgnoreReturnValue",
-        "  private SomeInjectedType injectSomeInjectedType(SomeInjectedType instance) {",
-        "    SomeInjectedType_MembersInjector.injectInjectedField(",
-        "        instance, new SomeInjectableType());",
-        "    return instance;",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void inject(SomeInjectedType instance) {",
+                "    injectSomeInjectedType(instance);",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
+                "    return injectSomeInjectedType(instance);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private SomeInjectedType injectSomeInjectedType(SomeInjectedType instance) {",
+                "    SomeInjectedType_MembersInjector.injectInjectedField(",
+                "        instance, getSomeInjectableTypeInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void inject(SomeInjectedType instance) {",
+                "    injectSomeInjectedType(instance);",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
+                "    return injectSomeInjectedType(instance);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private SomeInjectedType injectSomeInjectedType(SomeInjectedType instance) {",
+                "    SomeInjectedType_MembersInjector.injectInjectedField(",
+                "        instance, new SomeInjectableType());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(injectableTypeFile, injectedTypeFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectableTypeFile, injectedTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -1108,56 +1493,117 @@ public void testDefaultPackage() {
         "  SomeInjectableType someInjectableType();",
         "  Provider<SimpleComponent> selfProvider();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import dagger.internal.InstanceFactory;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private Provider<SimpleComponent> simpleComponentProvider;",
-            "",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType(this)",
-            "  }",
-            "",
-            "  @Override",
-            "  public Provider<SimpleComponent> selfProvider() {",
-            "    return simpleComponentProvider;",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.internal.InstanceFactory;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private Provider<SimpleComponent> simpleComponentProvider;",
+                "",
+                "  private DaggerSimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType(this);",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return getSomeInjectableTypeInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<SimpleComponent> selfProvider() {",
+                "    return simpleComponentProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.internal.InstanceFactory;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private Provider<SimpleComponent> simpleComponentProvider;",
+                "",
+                "  private DaggerSimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return new SomeInjectableType(this)",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<SimpleComponent> selfProvider() {",
+                "    return simpleComponentProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectableTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -1191,49 +1637,107 @@ public void testDefaultPackage() {
         "interface SimpleComponent {",
         "  SomeInjectedType createAndInject();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private DaggerSimpleComponent(Builder builder) {}",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return new Builder().build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectedType createAndInject() {",
-        "    return injectSomeInjectedType(",
-        "        SomeInjectedType_Factory.newSomeInjectedType());",
-        "  }",
-        "",
-        "  @CanIgnoreReturnValue",
-        "  private SomeInjectedType injectSomeInjectedType(SomeInjectedType instance) {",
-        "    SomeInjectedType_MembersInjector.injectInjectedField(",
-        "        instance, new SomeInjectableType());",
-        "    return instance;",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  private SomeInjectedType getSomeInjectedTypeInstance() {",
+                "    return injectSomeInjectedType(",
+                "        SomeInjectedType_Factory.newSomeInjectedType());",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectedType createAndInject() {",
+                "    return getSomeInjectedTypeInstance();",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private SomeInjectedType injectSomeInjectedType(SomeInjectedType instance) {",
+                "    SomeInjectedType_MembersInjector.injectInjectedField(",
+                "        instance, getSomeInjectableTypeInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectedType createAndInject() {",
+                "    return injectSomeInjectedType(",
+                "        SomeInjectedType_Factory.newSomeInjectedType());",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private SomeInjectedType injectSomeInjectedType(SomeInjectedType instance) {",
+                "    SomeInjectedType_MembersInjector.injectInjectedField(",
+                "        instance, new SomeInjectableType());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(injectableTypeFile, injectedTypeFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectableTypeFile, injectedTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -1263,40 +1767,85 @@ public void testDefaultPackage() {
         "interface SimpleComponent {",
         "  SomeInjectableType someInjectableType();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private DaggerSimpleComponent(Builder builder) {}",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return new Builder().build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return new SomeInjectableType();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return getSomeInjectableTypeInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(genericType, injectableTypeFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(genericType, injectableTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -1339,73 +1888,149 @@ public void testDefaultPackage() {
         "interface BComponent {",
         "  B b();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerBComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerBComponent implements BComponent {",
-            "  private Provider<A> aProvider;",
-            "",
-            "  private DaggerBComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.aProvider = new test_AComponent_a(builder.aComponent);",
-            "  }",
-            "",
-            "  @Override",
-            "  public B b() {",
-            "    return new B(aProvider);",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private AComponent aComponent;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public BComponent build() {",
-            "      if (aComponent == null) {",
-            "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
-            "            + \" must be set\");",
-            "      }",
-            "      return new DaggerBComponent(this);",
-            "    }",
-            "",
-            "    public Builder aComponent(AComponent aComponent) {",
-            "      this.aComponent = Preconditions.checkNotNull(aComponent);",
-            "      return this;",
-            "    }",
-            "  }",
-            "",
-            "  private static class test_AComponent_a implements Provider<A> {",
-            "    private final AComponent aComponent;",
-            "    ",
-            "    test_AComponent_a(AComponent aComponent) {",
-            "        this.aComponent = aComponent;",
-            "    }",
-            "    ",
-            "    @Override()",
-            "    public A get() {",
-            "      return Preconditions.checkNotNull(",
-            "          aComponent.a(), " + NPE_FROM_COMPONENT_METHOD + ");",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerBComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerBComponent implements BComponent {",
+                "  private Provider<A> aProvider;",
+                "",
+                "  private DaggerBComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  private B getBInstance() {",
+                "    return new B(aProvider);",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.aProvider = new test_AComponent_a(builder.aComponent);",
+                "  }",
+                "",
+                "  @Override",
+                "  public B b() {",
+                "    return getBInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private AComponent aComponent;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public BComponent build() {",
+                "      if (aComponent == null) {",
+                "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
+                "            + \" must be set\");",
+                "      }",
+                "      return new DaggerBComponent(this);",
+                "    }",
+                "",
+                "    public Builder aComponent(AComponent aComponent) {",
+                "      this.aComponent = Preconditions.checkNotNull(aComponent);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private static class test_AComponent_a implements Provider<A> {",
+                "    private final AComponent aComponent;",
+                "",
+                "    test_AComponent_a(AComponent aComponent) {",
+                "      this.aComponent = aComponent;",
+                "    }",
+                "",
+                "    @Override",
+                "    public A get() {",
+                "      return Preconditions.checkNotNull(",
+                "          aComponent.a(), " + NPE_FROM_COMPONENT_METHOD + ");",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerBComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerBComponent implements BComponent {",
+                "  private Provider<A> aProvider;",
+                "",
+                "  private DaggerBComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.aProvider = new test_AComponent_a(builder.aComponent);",
+                "  }",
+                "",
+                "  @Override",
+                "  public B b() {",
+                "    return new B(aProvider);",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private AComponent aComponent;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public BComponent build() {",
+                "      if (aComponent == null) {",
+                "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
+                "            + \" must be set\");",
+                "      }",
+                "      return new DaggerBComponent(this);",
+                "    }",
+                "",
+                "    public Builder aComponent(AComponent aComponent) {",
+                "      this.aComponent = Preconditions.checkNotNull(aComponent);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private static class test_AComponent_a implements Provider<A> {",
+                "    private final AComponent aComponent;",
+                "    ",
+                "    test_AComponent_a(AComponent aComponent) {",
+                "        this.aComponent = aComponent;",
+                "    }",
+                "    ",
+                "    @Override()",
+                "    public A get() {",
+                "      return Preconditions.checkNotNull(",
+                "          aComponent.a(), " + NPE_FROM_COMPONENT_METHOD + ");",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(aFile, bFile, aComponentFile, bComponentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(aFile, bFile, aComponentFile, bComponentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerBComponent")
@@ -1443,89 +2068,184 @@ public void testDefaultPackage() {
         "  @Provides A a() { return null; }",
         "}");
 
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {TestModule.class, other.test.TestModule.class})",
-        "interface TestComponent {",
-        "  A a();",
-        "  other.test.A otherA();",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import other.test.TestModule_AFactory;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private TestModule testModule;",
-        "  private other.test.TestModule testModule2;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return new Builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.testModule = builder.testModule;",
-        "    this.testModule2 = builder.testModule2;",
-        "  }",
-        "",
-        "  @Override",
-        "  public A a() {",
-        "    return Preconditions.checkNotNull(testModule.a(), " + NPE_FROM_PROVIDES_METHOD + ");",
-        "  }",
-        "",
-        "  @Override",
-        "  public other.test.A otherA() {",
-        "    return Preconditions.checkNotNull(",
-        "        TestModule_AFactory.proxyA(testModule2), " + NPE_FROM_PROVIDES_METHOD + ");",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private TestModule testModule;",
-        "    private other.test.TestModule testModule2;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (testModule == null) {",
-        "        this.testModule = new TestModule();",
-        "      }",
-        "      if (testModule2 == null) {",
-        "        this.testModule2 = new other.test.TestModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
         "",
-        "    public Builder testModule(TestModule testModule) {",
-        "      this.testModule = Preconditions.checkNotNull(testModule);",
-        "      return this;",
-        "    }",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
         "",
-        "    public Builder testModule(other.test.TestModule testModule) {",
-        "      this.testModule2 = Preconditions.checkNotNull(testModule);",
-        "      return this;",
-        "    }",
-        "  }",
+        "@Component(modules = {TestModule.class, other.test.TestModule.class})",
+        "interface TestComponent {",
+        "  A a();",
+        "  other.test.A otherA();",
         "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import other.test.TestModule_AFactory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule testModule;",
+                "",
+                "  private other.test.TestModule testModule2;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private A getAInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule.a(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private other.test.A getAInstance2() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule_AFactory.proxyA(testModule2),"
+                    + NPE_FROM_PROVIDES_METHOD
+                    + ");",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule = builder.testModule;",
+                "    this.testModule2 = builder.testModule2;",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return getAInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public other.test.A otherA() {",
+                "    return getAInstance2();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private TestModule testModule;",
+                "",
+                "    private other.test.TestModule testModule2;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (testModule == null) {",
+                "        this.testModule = new TestModule();",
+                "      }",
+                "      if (testModule2 == null) {",
+                "        this.testModule2 = new other.test.TestModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder testModule(TestModule testModule) {",
+                "      this.testModule = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder testModule(other.test.TestModule testModule) {",
+                "      this.testModule2 = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import other.test.TestModule_AFactory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule testModule;",
+                "  private other.test.TestModule testModule2;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule = builder.testModule;",
+                "    this.testModule2 = builder.testModule2;",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule.a(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public other.test.A otherA() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule_AFactory.proxyA(testModule2), "
+                    + NPE_FROM_PROVIDES_METHOD
+                    + ");",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private TestModule testModule;",
+                "    private other.test.TestModule testModule2;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (testModule == null) {",
+                "        this.testModule = new TestModule();",
+                "      }",
+                "      if (testModule2 == null) {",
+                "        this.testModule2 = new other.test.TestModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder testModule(TestModule testModule) {",
+                "      this.testModule = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder testModule(other.test.TestModule testModule) {",
+                "      this.testModule2 = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(aFile, otherAFile, moduleFile, otherModuleFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(aFile, otherAFile, moduleFile, otherModuleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -1578,50 +2298,117 @@ public void testDefaultPackage() {
         "  C c();",
         "  X x();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public A a() {",
-            "    return new A(new B(new C()));",
-            "  }",
-            "",
-            "  @Override",
-            "  public C c() {",
-            "    return new C();",
-            "  }",
-            "",
-            "  @Override",
-            "  public X x() {",
-            "    return new X(new C());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(aFile, bFile, cFile, xFile, componentFile);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private C getCInstance() {",
+                "    return new C();",
+                "  }",
+                "",
+                "  private B getBInstance() {",
+                "    return new B(getCInstance());",
+                "  }",
+                "",
+                "  private A getAInstance() {",
+                "    return new A(getBInstance());",
+                "  }",
+                "",
+                "  private X getXInstance() {",
+                "    return new X(getCInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return getAInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public C c() {",
+                "    return getCInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public X x() {",
+                "    return getXInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return new A(new B(new C()));",
+                "  }",
+                "",
+                "  @Override",
+                "  public C c() {",
+                "    return new C();",
+                "  }",
+                "",
+                "  @Override",
+                "  public X x() {",
+                "    return new X(new C());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(aFile, bFile, cFile, xFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -1658,51 +2445,94 @@ public void testDefaultPackage() {
         "@Component",
         "interface SupertypeB {",
         "  SomeInjectableType someInjectableType();",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent extends SupertypeA, SupertypeB {",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent extends SupertypeA, SupertypeB {",
+        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return getSomeInjectableTypeInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
         daggerCompiler()
+            .withOptions(compilerMode.javacopts())
             .compile(
                 injectableTypeFile,
                 componentSupertypeAFile,
@@ -1755,41 +2585,84 @@ public void testDefaultPackage() {
         "interface ComponentWithDep {",
         "  SomeInjectableType someInjectableType();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return getSomeInjectableTypeInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
         daggerCompiler()
+            .withOptions(compilerMode.javacopts())
             .compile(injectableTypeFile, componentSupertype, depComponentFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
@@ -1835,7 +2708,10 @@ public void testDefaultPackage() {
         "interface SimpleComponent {",
         "  C c();",
         "}");
-    Compilation compilation = daggerCompiler().compile(aFile, bFile, cFile, componentFile);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(aFile, bFile, cFile, componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -1856,7 +2732,8 @@ public void arrayKeyRequiresAtProvides() {
             "interface TestComponent {",
             "  String[] array();",
             "}");
-    Compilation compilation = daggerCompiler().compile(component);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("String[] cannot be provided without an @Provides-annotated method");
@@ -1892,6 +2769,7 @@ public void componentImplicitlyDependsOnGeneratedType() {
                     "final class GeneratedType {",
                     "  @Inject GeneratedType() {}",
                     "}"))
+            .withOptions(compilerMode.javacopts())
             .compile(injectableTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation).generatedSourceFile("test.DaggerSimpleComponent");
@@ -1927,6 +2805,7 @@ public void componentSupertypeDependsOnGeneratedType() {
                     "final class GeneratedType {",
                     "  @Inject GeneratedType() {}",
                     "}"))
+            .withOptions(compilerMode.javacopts())
             .compile(componentFile, interfaceFile);
     assertThat(compilation).succeeded();
     assertThat(compilation).generatedSourceFile("test.DaggerSimpleComponent");
@@ -2018,7 +2897,8 @@ public void genericTestToLetMeDebugInEclipse() {
          "    }",
          "  }",
          "}");
-    Compilation compilation = daggerCompiler().compile(aFile, bFile, componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(aFile, bFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -2038,8 +2918,11 @@ public void unprocessedMembersInjectorNotes() {
     Compilation compilation =
         javac()
             .withOptions(
-                "-Xlint:-processing",
-                 "-Adagger.warnIfInjectionFactoryNotGeneratedUpstream=enabled")
+                compilerMode
+                    .javacopts()
+                    .append(
+                        "-Xlint:-processing",
+                        "-Adagger.warnIfInjectionFactoryNotGeneratedUpstream=enabled"))
             .withProcessors(
                 new ElementFilteringComponentProcessor(
                     Predicates.not(
@@ -2169,7 +3052,8 @@ public void scopeAnnotationOnInjectConstructorNotValid() {
             "final class AClass {",
             "  @Inject @AScope AClass() {}",
             "}");
-    Compilation compilation = daggerCompiler().compile(aScope, aClass);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(aScope, aClass);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("@Scope annotations are not allowed on @Inject constructors.")
@@ -2193,7 +3077,8 @@ public void attemptToInjectWildcardGenerics() {
             "  Lazy<? extends Number> wildcardNumberLazy();",
             "  Provider<? super Number> wildcardNumberProvider();",
             "}");
-    Compilation compilation = daggerCompiler().compile(testComponent);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testComponent);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(9);
     assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(10);
@@ -2288,7 +3173,10 @@ public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(foo, module, component, prunedSubcomponent);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, module, component, prunedSubcomponent);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerParent")
@@ -2308,7 +3196,8 @@ public void invalidComponentDependencies() {
             "",
             "@Component(dependencies = int.class)",
             "interface TestComponent {}");
-    Compilation compilation = daggerCompiler().compile(testComponent);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testComponent);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("int is not a valid component dependency type");
   }
@@ -2324,7 +3213,8 @@ public void invalidComponentModules() {
             "",
             "@Component(modules = int.class)",
             "interface TestComponent {}");
-    Compilation compilation = daggerCompiler().compile(testComponent);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testComponent);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("int is not a valid module type");
   }
@@ -2352,7 +3242,8 @@ public void moduleInDependencies() {
             "",
             "@Component(dependencies = TestModule.class)",
             "interface TestComponent {}");
-    Compilation compilation = daggerCompiler().compile(testModule, testComponent);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testModule, testComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("test.TestModule is a module, which cannot be a component dependency");
@@ -2372,7 +3263,8 @@ public void bindsInstanceInModule() {
             "abstract class TestModule {",
             "  @BindsInstance abstract void str(String string);",
             "}");
-    Compilation compilation = daggerCompiler().compile(testModule);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testModule);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -2393,7 +3285,8 @@ public void bindsInstanceInComponent() {
             "interface TestComponent {",
             "  @BindsInstance String s(String s);",
             "}");
-    Compilation compilation = daggerCompiler().compile(testComponent);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -2414,7 +3307,8 @@ public void bindsInstanceNotAbstract() {
             "class BindsInstanceNotAbstract {",
             "  @BindsInstance BindsInstanceNotAbstract bind(int unused) { return this; }",
             "}");
-    Compilation compilation = daggerCompiler().compile(notAbstract);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(notAbstract);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("@BindsInstance methods must be abstract")
@@ -2434,7 +3328,8 @@ public void bindsInstanceNoParameters() {
             "interface BindsInstanceNoParameters {",
             "  @BindsInstance void noParams();",
             "}");
-    Compilation compilation = daggerCompiler().compile(notAbstract);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(notAbstract);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -2455,7 +3350,8 @@ public void bindsInstanceManyParameters() {
             "interface BindsInstanceManyParameters {",
             "  @BindsInstance void manyParams(int i, long l);",
             "}");
-    Compilation compilation = daggerCompiler().compile(notAbstract);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(notAbstract);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -2479,7 +3375,8 @@ public void bindsInstanceFrameworkType() {
             "  @BindsInstance void bindsProvider(Provider<Object> objectProvider);",
             "  @BindsInstance void bindsProducer(Producer<Object> objectProducer);",
             "}");
-    Compilation compilation = daggerCompiler().compile(bindsFrameworkType);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(bindsFrameworkType);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("@BindsInstance parameters may not be framework types")
@@ -2496,6 +3393,7 @@ public void bindsInstanceFrameworkType() {
   public void nullIncorrectlyReturnedFromNonNullableInlinedProvider() {
     Compilation compilation =
         daggerCompiler()
+            .withOptions(compilerMode.javacopts())
             .compile(
                 JavaFileObjects.forSourceLines(
                     "test.TestModule",
@@ -2561,9 +3459,62 @@ public void nullIncorrectlyReturnedFromNonNullableInlinedProvider() {
                 "    return TestModule.nonNullableString();",
                 "  }",
                 "}"));
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import dagger.internal.Preconditions",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private String getStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule.nonNullableString(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public String nonNullableString() {",
+                "    return getStringInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void inject(InjectsMember member) {",
+                "    injectInjectsMember(member);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private InjectsMember injectInjectsMember(InjectsMember instance) {",
+                "    InjectsMember_MembersInjector.injectMember(instance, getStringInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
             JavaFileObjects.forSourceLines(
                 "test.DaggerTestComponent",
                 "package test;",
@@ -2610,13 +3561,18 @@ public void nullIncorrectlyReturnedFromNonNullableInlinedProvider() {
                 "      return new DaggerTestComponent(this);",
                 "    }",
                 "  }",
-                "}"));
+                "}");
+    }
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test
   public void nullCheckingIgnoredWhenProviderReturnsPrimitive() {
     Compilation compilation =
         daggerCompiler()
+            .withOptions(compilerMode.javacopts())
             .compile(
                 JavaFileObjects.forSourceLines(
                     "test.TestModule",
@@ -2679,9 +3635,60 @@ public void nullCheckingIgnoredWhenProviderReturnsPrimitive() {
                 "    return TestModule.primitiveInteger();",
                 "  }",
                 "}"));
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private int getIntegerInstance() {",
+                "    return TestModule.primitiveInteger();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Integer nonNullableInteger() {",
+                "    return getIntegerInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void inject(InjectsMember member) {",
+                "    injectInjectsMember(member);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private InjectsMember injectInjectsMember(InjectsMember instance) {",
+                "    InjectsMember_MembersInjector.injectMember(instance, getIntegerInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
             JavaFileObjects.forSourceLines(
                 "test.DaggerTestComponent",
                 "package test;",
@@ -2725,7 +3732,11 @@ public void nullCheckingIgnoredWhenProviderReturnsPrimitive() {
                 "      return new DaggerTestComponent(this);",
                 "    }",
                 "  }",
-                "}"));
+                "}");
+    }
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   private static Compiler daggerCompiler(Processor... extraProcessors) {
diff --git a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
index 0d35d7db3..79cf4aa9f 100644
--- a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
+++ b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
@@ -23,13 +23,26 @@
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class ComponentRequirementFieldTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public ComponentRequirementFieldTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
   @Test
   public void bindsInstance() {
     JavaFileObject component =
@@ -53,7 +66,8 @@ public void bindsInstance() {
             "    TestComponent build();",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(component);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -166,11 +180,95 @@ public void instanceModuleMethod() {
             "  int i();",
             "  long l();",
             "}");
-    Compilation compilation = daggerCompiler().compile(module, otherPackageModule, component);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, otherPackageModule, component);
     assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import other.OtherPackageModule;",
+                "import other.OtherPackageModule_LFactory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private ParentModule parentModule;",
+                "  private OtherPackageModule otherPackageModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private int getIntegerInstance() {",
+                "    return parentModule.i();",
+                "  }",
+                "",
+                "  private long getLongInstance() {",
+                "    return OtherPackageModule_LFactory.proxyL(otherPackageModule);",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "    this.otherPackageModule = builder.otherPackageModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public int i() {",
+                "    return getIntegerInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public long l() {",
+                "    return getLongInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "    private OtherPackageModule otherPackageModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      if (otherPackageModule == null) {",
+                "        this.otherPackageModule = new OtherPackageModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder otherPackageModule(OtherPackageModule otherPackageModule) {",
+                "      this.otherPackageModule = Preconditions.checkNotNull(otherPackageModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
             JavaFileObjects.forSourceLines(
                 "test.DaggerTestComponent",
                 "package test;",
@@ -239,7 +337,11 @@ public void instanceModuleMethod() {
                 "      return this;",
                 "    }",
                 "  }",
-                "}"));
+                "}");
+    }
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test
@@ -283,7 +385,10 @@ public void componentInstances() {
             "  Dep depFromSubcomponent();",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(dependency, component, subcomponent);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(dependency, component, subcomponent);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -438,7 +543,9 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
             "}");
 
     Compilation compilation =
-        daggerCompiler().compile(parentModule, childModule, component, subcomponent);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(parentModule, childModule, component, subcomponent);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
diff --git a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
index 9a03e3824..ad83170bf 100644
--- a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
+++ b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
@@ -22,13 +22,26 @@
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class ElidedFactoriesTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public ElidedFactoriesTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
   @Test
   public void simpleComponent() {
     JavaFileObject injectedType =
@@ -63,41 +76,89 @@ public void simpleComponent() {
             "interface SimpleComponent {",
             "  DependsOnInjected dependsOnInjected();",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public DependsOnInjected dependsOnInjected() {",
-            "    return new DependsOnInjected(new InjectedType());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private InjectedType getInjectedTypeInstance() {",
+                "    return new InjectedType();",
+                "  }",
+                "",
+                "  private DependsOnInjected getDependsOnInjectedInstance() {",
+                "    return new DependsOnInjected(getInjectedTypeInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public DependsOnInjected dependsOnInjected() {",
+                "    return getDependsOnInjectedInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public DependsOnInjected dependsOnInjected() {",
+                "    return new DependsOnInjected(new InjectedType());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(injectedType, dependsOnInjected, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectedType, dependsOnInjected, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -155,54 +216,113 @@ public void simpleComponent_injectsProviderOf_dependsOnScoped() {
             "interface SimpleComponent {",
             "  NeedsProvider needsProvider();",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import dagger.internal.DoubleCheck;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private Provider<ScopedType> scopedTypeProvider;",
-            "  private Provider<DependsOnScoped> dependsOnScopedProvider;",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
-            "    this.dependsOnScopedProvider = ",
-            "        DependsOnScoped_Factory.create(scopedTypeProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public NeedsProvider needsProvider() {",
-            "    return new NeedsProvider(dependsOnScopedProvider);",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private Provider<ScopedType> scopedTypeProvider;",
+                "",
+                "  private Provider<DependsOnScoped> dependsOnScopedProvider;",
+                "",
+                "  private DaggerSimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private NeedsProvider getNeedsProviderInstance() {",
+                "    return new NeedsProvider(dependsOnScopedProvider);",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
+                "    this.dependsOnScopedProvider = ",
+                "        DependsOnScoped_Factory.create(scopedTypeProvider);",
+                "  }",
+                "",
+                "  @Override",
+                "  public NeedsProvider needsProvider() {",
+                "    return getNeedsProviderInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private Provider<ScopedType> scopedTypeProvider;",
+                "  private Provider<DependsOnScoped> dependsOnScopedProvider;",
+                "  private DaggerSimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
+                "    this.dependsOnScopedProvider = ",
+                "        DependsOnScoped_Factory.create(scopedTypeProvider);",
+                "  }",
+                "",
+                "  @Override",
+                "  public NeedsProvider needsProvider() {",
+                "    return new NeedsProvider(dependsOnScopedProvider);",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(scopedType, dependsOnScoped, componentFile, needsProvider);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(scopedType, dependsOnScoped, componentFile, needsProvider);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -260,61 +380,126 @@ public void scopedBinding_onlyUsedInSubcomponent() {
             "  DependsOnScoped dependsOnScoped();",
             "}");
 
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import dagger.internal.DoubleCheck;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private Provider<ScopedType> scopedTypeProvider;",
-            "",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Sub sub() {",
-            "    return new SubImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "",
-            "  private final class SubImpl implements Sub {",
-            "    private SubImpl() {}",
-            "",
-            "    @Override",
-            "    public DependsOnScoped dependsOnScoped() {",
-            "      return new DependsOnScoped(",
-            "          DaggerSimpleComponent.this.scopedTypeProvider.get());",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private Provider<ScopedType> scopedTypeProvider;",
+                "",
+                "  private DaggerSimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Sub sub() {",
+                "    return new SubImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubImpl implements Sub {",
+                "    private SubImpl() {}",
+                "",
+                "    private DependsOnScoped getDependsOnScopedInstance() {",
+                "      return new DependsOnScoped(",
+                "          DaggerSimpleComponent.this.scopedTypeProvider.get());",
+                "    }",
+                "",
+                "    @Override",
+                "    public DependsOnScoped dependsOnScoped() {",
+                "      return getDependsOnScopedInstance();",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private Provider<ScopedType> scopedTypeProvider;",
+                "",
+                "  private DaggerSimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Sub sub() {",
+                "    return new SubImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubImpl implements Sub {",
+                "    private SubImpl() {}",
+                "",
+                "    @Override",
+                "    public DependsOnScoped dependsOnScoped() {",
+                "      return new DependsOnScoped(",
+                "          DaggerSimpleComponent.this.scopedTypeProvider.get());",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(scopedType, dependsOnScoped, componentFile, subcomponentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(scopedType, dependsOnScoped, componentFile, subcomponentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
diff --git a/javatests/dagger/internal/codegen/InaccessibleTypeTest.java b/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
index 0d885f15c..c338e05f3 100644
--- a/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
+++ b/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
@@ -22,13 +22,26 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class InaccessibleTypeTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public InaccessibleTypeTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
   @Test public void basicInjectedType() {
     JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("foreign.NoDepClass",
         "package foreign;",
@@ -74,49 +87,112 @@
         "interface TestComponent {",
         "  PublicClass publicClass();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import foreign.NoDepClass_Factory;",
-            "import foreign.NonPublicClass1_Factory;",
-            "import foreign.NonPublicClass2_Factory;",
-            "import foreign.PublicClass;",
-            "import foreign.PublicClass_Factory;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public PublicClass publicClass() {",
-            "    return PublicClass_Factory.newPublicClass(",
-            "        NonPublicClass1_Factory.newNonPublicClass1(",
-            "            NoDepClass_Factory.newNoDepClass()),",
-            "        NonPublicClass2_Factory.newNonPublicClass2(",
-            "            NoDepClass_Factory.newNoDepClass()),",
-            "        NoDepClass_Factory.newNoDepClass());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import foreign.NoDepClass;",
+                "import foreign.NoDepClass_Factory;",
+                "import foreign.NonPublicClass1_Factory;",
+                "import foreign.NonPublicClass2_Factory;",
+                "import foreign.PublicClass;",
+                "import foreign.PublicClass_Factory;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private NoDepClass getNoDepClassInstance() {",
+                "    return NoDepClass_Factory.newNoDepClass();",
+                "  }",
+                "",
+                "  private Object getNonPublicClass1Instance() {",
+                "    return NonPublicClass1_Factory.newNonPublicClass1(getNoDepClassInstance());",
+                "  }",
+                "",
+                "  private Object getNonPublicClass2Instance() {",
+                "    return NonPublicClass2_Factory.newNonPublicClass2(getNoDepClassInstance());",
+                "  }",
+                "",
+                "  private PublicClass getPublicClassInstance() {",
+                "    return PublicClass_Factory.newPublicClass(",
+                "        getNonPublicClass1Instance(), ",
+                "        getNonPublicClass2Instance(), ",
+                "        getNoDepClassInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public PublicClass publicClass() {",
+                "    return getPublicClassInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import foreign.NoDepClass_Factory;",
+                "import foreign.NonPublicClass1_Factory;",
+                "import foreign.NonPublicClass2_Factory;",
+                "import foreign.PublicClass;",
+                "import foreign.PublicClass_Factory;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public PublicClass publicClass() {",
+                "    return PublicClass_Factory.newPublicClass(",
+                "        NonPublicClass1_Factory.newNonPublicClass1(",
+                "            NoDepClass_Factory.newNoDepClass()),",
+                "        NonPublicClass2_Factory.newNonPublicClass2(",
+                "            NoDepClass_Factory.newNoDepClass()),",
+                "        NoDepClass_Factory.newNoDepClass());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
         .that(
             ImmutableList.of(
@@ -126,10 +202,13 @@
                 nonPublicClass2File,
                 componentFile))
         .withCompilerOptions(
-            "-Xlint:-processing",
-            "-Xlint:rawtypes",
-            "-Xlint:unchecked",
-            "-Werror")
+            compilerMode
+                .javacopts()
+                .append(
+                    "-Xlint:-processing",
+                    "-Xlint:rawtypes",
+                    "-Xlint:unchecked",
+                    "-Werror"))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -192,60 +271,117 @@
         "interface TestComponent {",
         "  void injectA(A a);",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
-            "import foreign.B_MembersInjector;",
-            "import foreign.C_MembersInjector;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public void injectA(A a) {",
-            "    injectA2(a);",
-            "  }",
-            "",
-            "  @CanIgnoreReturnValue",
-            "  private A injectA2(A instance) {",
-            "    D_MembersInjector.injectDep(instance, new NoDepClass());",
-            "    C_MembersInjector.injectDep(instance, new NoDepClass());",
-            "    B_MembersInjector.injectDep(instance, new NoDepClass());",
-            "    A_MembersInjector.injectDep(instance, new NoDepClass());",
-            "    return instance;",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import foreign.B_MembersInjector;",
+                "import foreign.C_MembersInjector;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private NoDepClass getNoDepClassInstance() {",
+                "    return new NoDepClass();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void injectA(A a) {",
+                "    injectA2(a);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private A injectA2(A instance) {",
+                "    D_MembersInjector.injectDep(instance, getNoDepClassInstance());",
+                "    C_MembersInjector.injectDep(instance, getNoDepClassInstance());",
+                "    B_MembersInjector.injectDep(instance, getNoDepClassInstance());",
+                "    A_MembersInjector.injectDep(instance, getNoDepClassInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import foreign.B_MembersInjector;",
+                "import foreign.C_MembersInjector;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void injectA(A a) {",
+                "    injectA2(a);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private A injectA2(A instance) {",
+                "    D_MembersInjector.injectDep(instance, new NoDepClass());",
+                "    C_MembersInjector.injectDep(instance, new NoDepClass());",
+                "    B_MembersInjector.injectDep(instance, new NoDepClass());",
+                "    A_MembersInjector.injectDep(instance, new NoDepClass());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
         .that(
             ImmutableList.of(
                 noDepClassFile, aClassFile, bClassFile, cClassFile, dClassFile, componentFile))
         .withCompilerOptions(
-            "-Xlint:-processing",
-            "-Xlint:rawtypes",
-            "-Xlint:unchecked",
-            "-Werror")
+            compilerMode
+                .javacopts()
+                .append(
+                    "-Xlint:-processing",
+                    "-Xlint:rawtypes",
+                    "-Xlint:unchecked",
+                    "-Werror"))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index bef33ed50..9023979aa 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -27,13 +27,26 @@
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class MapBindingComponentProcessorTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public MapBindingComponentProcessorTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
   @Test
   public void mapBindingsWithEnumKey() {
     JavaFileObject mapModuleOneFile =
@@ -189,14 +202,17 @@ public void mapBindingsWithEnumKey() {
             "  }",
             "}");
     assertAbout(javaSources())
-        .that(ImmutableList.of(mapModuleOneFile,
-            mapModuleTwoFile,
-            enumKeyFile,
-            pathEnumFile,
-            HandlerFile,
-            LoginHandlerFile,
-            AdminHandlerFile,
-            componentFile))
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                enumKeyFile,
+                pathEnumFile,
+                HandlerFile,
+                LoginHandlerFile,
+                AdminHandlerFile,
+                componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -623,12 +639,15 @@ public void mapBindingsWithStringKey() {
             "  }",
             "}");
     assertAbout(javaSources())
-        .that(ImmutableList.of(mapModuleOneFile,
-            mapModuleTwoFile,
-            HandlerFile,
-            LoginHandlerFile,
-            AdminHandlerFile,
-            componentFile))
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                HandlerFile,
+                LoginHandlerFile,
+                AdminHandlerFile,
+                componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -786,13 +805,16 @@ public void mapBindingsWithWrappedKey() {
             "  }",
             "}");
     assertAbout(javaSources())
-        .that(ImmutableList.of(mapModuleOneFile,
-            mapModuleTwoFile,
-            wrappedClassKeyFile,
-            HandlerFile,
-            LoginHandlerFile,
-            AdminHandlerFile,
-            componentFile))
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                wrappedClassKeyFile,
+                HandlerFile,
+                LoginHandlerFile,
+                AdminHandlerFile,
+                componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
         .compilesWithoutError()
         .and()
@@ -948,17 +970,21 @@ public void mapBindingsWithNonProviderValue() {
             "  }",
             "}");
     assertAbout(javaSources())
-        .that(ImmutableList.of(mapModuleOneFile,
-            mapModuleTwoFile,
-            enumKeyFile,
-            pathEnumFile,
-            HandlerFile,
-            LoginHandlerFile,
-            AdminHandlerFile,
-            componentFile)).
-        processedWith(new ComponentProcessor())
-            .compilesWithoutError()
-            .and().generatesSources(generatedComponent);
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                enumKeyFile,
+                pathEnumFile,
+                HandlerFile,
+                LoginHandlerFile,
+                AdminHandlerFile,
+                componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
@@ -989,62 +1015,132 @@ public void injectMapWithoutMapBinding() {
         "interface TestComponent {",
         "  Map<String, String> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private MapModule mapModule;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return new Builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.mapModule = builder.mapModule;",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<String, String> dispatcher() {",
-        "    return Preconditions.checkNotNull(",
-        "        mapModule.provideAMap(), " + NPE_FROM_PROVIDES_METHOD + ");",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModule mapModule;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModule == null) {",
-        "        this.mapModule = new MapModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModule(MapModule mapModule) {",
-        "      this.mapModule = Preconditions.checkNotNull(mapModule);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))
-        .processedWith(new ComponentProcessor()).compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private MapModule mapModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Map<String, String> getMapOfStringAndStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModule.provideAMap(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.mapModule = builder.mapModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, String> dispatcher() {",
+                "    return getMapOfStringAndStringInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModule mapModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModule == null) {",
+                "        this.mapModule = new MapModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModule(MapModule mapModule) {",
+                "      this.mapModule = Preconditions.checkNotNull(mapModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private MapModule mapModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.mapModule = builder.mapModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, String> dispatcher() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModule.provideAMap(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModule mapModule;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModule == null) {",
+                "        this.mapModule = new MapModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModule(MapModule mapModule) {",
+                "      this.mapModule = Preconditions.checkNotNull(mapModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    assertAbout(javaSources())
+        .that(ImmutableList.of(mapModuleFile, componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
@@ -1084,6 +1180,7 @@ public void mapBindingsWithDuplicateKeys() {
             "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(module, componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("The same map key is bound more than once")
@@ -1142,6 +1239,7 @@ public void mapBindingsWithInconsistentKeyAnnotations() {
             "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(module, stringKeyTwoFile, componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("uses more than one @MapKey annotation type")
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
index 77594192e..36c9621bc 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
@@ -17,20 +17,35 @@
 package dagger.internal.codegen;
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompilerWithoutGuava;
+import static dagger.internal.codegen.Compilers.CLASS_PATH_WITHOUT_GUAVA_OPTION;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.testing.compile.Compilation;
+import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
 import com.squareup.javapoet.CodeBlock;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class MapBindingExpressionTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public MapBindingExpressionTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
   public static final CodeBlock NPE_FROM_PROVIDES =
       CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
 
@@ -72,77 +87,169 @@ public void mapBindings() {
         "  Map<Long, Long> longs();",
         "  Map<Long, Provider<Long>> providerLongs();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.MapBuilder;",
-            "import java.util.Collections;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<String, String> strings() {",
-            "    return Collections.<String, String>emptyMap();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<String, Provider<String>> providerStrings() {",
-            "    return Collections.<String, Provider<String>>emptyMap();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<Integer, Integer> ints() {",
-            "    return Collections.<Integer, Integer>singletonMap(0, MapModule.provideInt());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<Integer, Provider<Integer>> providerInts() {",
-            "    return Collections.<Integer, Provider<Integer>>singletonMap(",
-            "        0, MapModule_ProvideIntFactory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<Long, Long> longs() {",
-            "    return MapBuilder.<Long, Long>newMapBuilder(3)",
-            "      .put(0L, MapModule.provideLong0())",
-            "      .put(1L, MapModule.provideLong1())",
-            "      .put(2L, MapModule.provideLong2())",
-            "      .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<Long, Provider<Long>> providerLongs() {",
-            "    return MapBuilder.<Long, Provider<Long>>newMapBuilder(3)",
-            "      .put(0L, MapModule_ProvideLong0Factory.create())",
-            "      .put(1L, MapModule_ProvideLong1Factory.create())",
-            "      .put(2L, MapModule_ProvideLong2Factory.create())",
-            "      .build();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapBuilder;",
+                "import java.util.Collections;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private int getMapOfIntegerAndProviderOfIntegerInstance() {",
+                "    return MapModule.provideInt();",
+                "  }",
+                "",
+                "  private long getMapOfLongAndProviderOfLongInstance() {",
+                "    return MapModule.provideLong0();",
+                "  }",
+                "",
+                "  private long getMapOfLongAndProviderOfLongInstance2() {",
+                "    return MapModule.provideLong1();",
+                "  }",
+                "",
+                "  private long getMapOfLongAndProviderOfLongInstance3() {",
+                "    return MapModule.provideLong2();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, String> strings() {",
+                "    return Collections.<String, String>emptyMap();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, Provider<String>> providerStrings() {",
+                "    return Collections.<String, Provider<String>>emptyMap();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Integer> ints() {",
+                "    return Collections.<Integer, Integer>singletonMap(",
+                "        0, getMapOfIntegerAndProviderOfIntegerInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Provider<Integer>> providerInts() {",
+                "    return Collections.<Integer, Provider<Integer>>singletonMap(",
+                "        0, MapModule_ProvideIntFactory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Long> longs() {",
+                "    return MapBuilder.<Long, Long>newMapBuilder(3)",
+                "        .put(0L, getMapOfLongAndProviderOfLongInstance())",
+                "        .put(1L, getMapOfLongAndProviderOfLongInstance2())",
+                "        .put(2L, getMapOfLongAndProviderOfLongInstance3())",
+                "        .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Provider<Long>> providerLongs() {",
+                "    return MapBuilder.<Long, Provider<Long>>newMapBuilder(3)",
+                "        .put(0L, MapModule_ProvideLong0Factory.create())",
+                "        .put(1L, MapModule_ProvideLong1Factory.create())",
+                "        .put(2L, MapModule_ProvideLong2Factory.create())",
+                "        .build();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapBuilder;",
+                "import java.util.Collections;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, String> strings() {",
+                "    return Collections.<String, String>emptyMap();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, Provider<String>> providerStrings() {",
+                "    return Collections.<String, Provider<String>>emptyMap();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Integer> ints() {",
+                "    return Collections.<Integer, Integer>singletonMap(0, MapModule.provideInt());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Provider<Integer>> providerInts() {",
+                "    return Collections.<Integer, Provider<Integer>>singletonMap(",
+                "        0, MapModule_ProvideIntFactory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Long> longs() {",
+                "    return MapBuilder.<Long, Long>newMapBuilder(3)",
+                "        .put(0L, MapModule.provideLong0())",
+                "        .put(1L, MapModule.provideLong1())",
+                "        .put(2L, MapModule.provideLong2())",
+                "        .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Provider<Long>> providerLongs() {",
+                "    return MapBuilder.<Long, Provider<Long>>newMapBuilder(3)",
+                "        .put(0L, MapModule_ProvideLong0Factory.create())",
+                "        .put(1L, MapModule_ProvideLong1Factory.create())",
+                "        .put(2L, MapModule_ProvideLong2Factory.create())",
+                "        .build();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation = daggerCompilerWithoutGuava().compile(mapModuleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
@@ -198,43 +305,90 @@ public void inaccessible() {
             "interface TestComponent {",
             "  UsesInaccessible usesInaccessible();",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import java.util.Collections;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import other.UsesInaccessible;",
-            "import other.UsesInaccessible_Factory;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public UsesInaccessible usesInaccessible() {",
-            "    return UsesInaccessible_Factory.newUsesInaccessible(",
-            "        (Map) Collections.emptyMap());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import java.util.Collections;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private UsesInaccessible getUsesInaccessibleInstance() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        (Map) Collections.emptyMap());",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return getUsesInaccessibleInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import java.util.Collections;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        (Map) Collections.emptyMap());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
         daggerCompilerWithoutGuava().compile(module, inaccessible, usesInaccessible, componentFile);
     assertThat(compilation).succeeded();
@@ -285,78 +439,158 @@ public void subcomponentOmitsInheritedBindings() {
             "interface Child {",
             "  Map<String, Object> objectMap();",
             "}");
-    JavaFileObject expected =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Collections;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParent implements Parent {",
-            "  private ParentModule parentModule;",
-            "",
-            "  private DaggerParent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Parent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.parentModule = builder.parentModule;",
-            "  }",
-            "",
-            "  @Override",
-            "  public Child child() {",
-            "    return new ChildImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private ParentModule parentModule;",
-            "",
-            "    private Builder() {}",
-            "",
-            "    public Parent build() {",
-            "      if (parentModule == null) {",
-            "        this.parentModule = new ParentModule();",
-            "      }",
-            "      return new DaggerParent(this);",
-            "    }",
-            "",
-            "    public Builder parentModule(ParentModule parentModule) {",
-            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "",
-            "  private final class ChildImpl implements Child {",
-            "    private ChildImpl() {}",
-            "",
-            "    @Override",
-            "    public Map<String, Object> objectMap() {",
-            "      return Collections.<String, Object>singletonMap(",
-            "          \"parent key\",",
-            "          Preconditions.checkNotNull(",
-            "              DaggerParent.this.parentModule.parentKeyObject(),",
-            "              " + NPE_FROM_PROVIDES_METHOD + ");",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Collections;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private ParentModule parentModule;",
+                "",
+                "  private DaggerParent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Object getMapOfStringAndProviderOfObjectInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        parentModule.parentKeyObject(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    @Override",
+                "    public Map<String, Object> objectMap() {",
+                "      return Collections.<String, Object>singletonMap(",
+                "          \"parent key\",",
+                "          DaggerParent.this.getMapOfStringAndProviderOfObjectInstance());",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Collections;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private ParentModule parentModule;",
+                "",
+                "  private DaggerParent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    @Override",
+                "    public Map<String, Object> objectMap() {",
+                "      return Collections.<String, Object>singletonMap(",
+                "          \"parent key\",",
+                "          Preconditions.checkNotNull(",
+                "              DaggerParent.this.parentModule.parentKeyObject(),",
+                "              " + NPE_FROM_PROVIDES_METHOD + "));",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation = daggerCompilerWithoutGuava().compile(parent, parentModule, child);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerParent")
-        .hasSourceEquivalentTo(expected);
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
+  private Compiler daggerCompilerWithoutGuava() {
+    return daggerCompiler()
+        .withOptions(compilerMode.javacopts().append(CLASS_PATH_WITHOUT_GUAVA_OPTION));
+  }
 }
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
index 0b10fa4b8..33f2345f8 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
@@ -23,13 +23,26 @@
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class MapBindingExpressionWithGuavaTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public MapBindingExpressionWithGuavaTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
   @Test
   public void mapBindings() {
     JavaFileObject mapModuleFile =
@@ -107,108 +120,256 @@ public void mapBindings() {
             "  Map<Long, Long> longs();",
             "  Map<Long, Provider<Long>> providerLongs();",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<String, String> strings() {",
-            "    return ImmutableMap.<String, String>of();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<String, Provider<String>> providerStrings() {",
-            "    return ImmutableMap.<String, Provider<String>>of();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<Integer, Integer> ints() {",
-            "    return ImmutableMap.<Integer, Integer>of(0, MapModule.provideInt());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<Integer, Provider<Integer>> providerInts() {",
-            "    return ImmutableMap.<Integer, Provider<Integer>>of(",
-            "        0, MapModule_ProvideIntFactory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<Long, Long> longs() {",
-            "    return ImmutableMap.<Long, Long>of(",
-            "      0L, MapModule.provideLong0(),",
-            "      1L, MapModule.provideLong1(),",
-            "      2L, MapModule.provideLong2());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<Long, Provider<Long>> providerLongs() {",
-            "    return ImmutableMap.<Long, Provider<Long>>of(",
-            "      0L, MapModule_ProvideLong0Factory.create(),",
-            "      1L, MapModule_ProvideLong1Factory.create(),",
-            "      2L, MapModule_ProvideLong2Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Sub sub() {",
-            "    return new SubImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "  private final class SubImpl implements Sub {",
-            "    private SubImpl() {}",
-            "",
-            "    @Override",
-            "    public Map<Long, Long> longs() {",
-            "      return ImmutableMap.<Long, Long>builder()",
-            "          .put(0L, MapModule.provideLong0())",
-            "          .put(1L, MapModule.provideLong1())",
-            "          .put(2L, MapModule.provideLong2())",
-            "          .put(3L, SubcomponentMapModule.provideLong3())",
-            "          .put(4L, SubcomponentMapModule.provideLong4())",
-            "          .put(5L, SubcomponentMapModule.provideLong5())",
-            "          .build();",
-            "    }",
-            "",
-            "    @Override",
-            "    public Map<Long, Provider<Long>> providerLongs() {",
-            "      return ImmutableMap.<Long, Provider<Long>>builder()",
-            "          .put(0L, MapModule_ProvideLong0Factory.create())",
-            "          .put(1L, MapModule_ProvideLong1Factory.create())",
-            "          .put(2L, MapModule_ProvideLong2Factory.create())",
-            "          .put(3L, SubcomponentMapModule_ProvideLong3Factory.create())",
-            "          .put(4L, SubcomponentMapModule_ProvideLong4Factory.create())",
-            "          .put(5L, SubcomponentMapModule_ProvideLong5Factory.create())",
-            "          .build();",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private int getMapOfIntegerAndProviderOfIntegerInstance() {",
+                "    return MapModule.provideInt();",
+                "  }",
+                "",
+                "  private long getMapOfLongAndProviderOfLongInstance() {",
+                "    return MapModule.provideLong0();",
+                "  }",
+                "",
+                "  private long getMapOfLongAndProviderOfLongInstance2() {",
+                "    return MapModule.provideLong1();",
+                "  }",
+                "",
+                "  private long getMapOfLongAndProviderOfLongInstance3() {",
+                "    return MapModule.provideLong2();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, String> strings() {",
+                "    return ImmutableMap.<String, String>of();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, Provider<String>> providerStrings() {",
+                "    return ImmutableMap.<String, Provider<String>>of();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Integer> ints() {",
+                "    return ImmutableMap.<Integer, Integer>of(",
+                "        0, getMapOfIntegerAndProviderOfIntegerInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Provider<Integer>> providerInts() {",
+                "    return ImmutableMap.<Integer, Provider<Integer>>of(",
+                "        0, MapModule_ProvideIntFactory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Long> longs() {",
+                "    return ImmutableMap.<Long, Long>of(",
+                "        0L, getMapOfLongAndProviderOfLongInstance(),",
+                "        1L, getMapOfLongAndProviderOfLongInstance2(),",
+                "        2L, getMapOfLongAndProviderOfLongInstance3());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Provider<Long>> providerLongs() {",
+                "    return ImmutableMap.<Long, Provider<Long>>of(",
+                "        0L, MapModule_ProvideLong0Factory.create(),",
+                "        1L, MapModule_ProvideLong1Factory.create(),",
+                "        2L, MapModule_ProvideLong2Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Sub sub() {",
+                "    return new SubImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubImpl implements Sub {",
+                "    private SubImpl() {}",
+                "",
+                "    private long getMapOfLongAndProviderOfLongInstance() {",
+                "      return MapModule.provideLong0();",
+                "    }",
+                "",
+                "    private long getMapOfLongAndProviderOfLongInstance2() {",
+                "      return MapModule.provideLong1();",
+                "    }",
+                "",
+                "    private long getMapOfLongAndProviderOfLongInstance3() {",
+                "      return MapModule.provideLong2();",
+                "    }",
+                "",
+                "    private long getMapOfLongAndProviderOfLongInstance4() {",
+                "      return SubcomponentMapModule.provideLong3();",
+                "    }",
+                "",
+                "    private long getMapOfLongAndProviderOfLongInstance5() {",
+                "      return SubcomponentMapModule.provideLong4();",
+                "    }",
+                "",
+                "    private long getMapOfLongAndProviderOfLongInstance6() {",
+                "      return SubcomponentMapModule.provideLong5();",
+                "    }",
+                "",
+                "    @Override",
+                "    public Map<Long, Long> longs() {",
+                "      return ImmutableMap.<Long, Long>builder()",
+                "          .put(0L, getMapOfLongAndProviderOfLongInstance())",
+                "          .put(1L, getMapOfLongAndProviderOfLongInstance2())",
+                "          .put(2L, getMapOfLongAndProviderOfLongInstance3())",
+                "          .put(3L, getMapOfLongAndProviderOfLongInstance4())",
+                "          .put(4L, getMapOfLongAndProviderOfLongInstance5())",
+                "          .put(5L, getMapOfLongAndProviderOfLongInstance6())",
+                "          .build();",
+                "    }",
+                "",
+                "    @Override",
+                "    public Map<Long, Provider<Long>> providerLongs() {",
+                "      return ImmutableMap.<Long, Provider<Long>>builder()",
+                "          .put(0L, MapModule_ProvideLong0Factory.create())",
+                "          .put(1L, MapModule_ProvideLong1Factory.create())",
+                "          .put(2L, MapModule_ProvideLong2Factory.create())",
+                "          .put(3L, SubcomponentMapModule_ProvideLong3Factory.create())",
+                "          .put(4L, SubcomponentMapModule_ProvideLong4Factory.create())",
+                "          .put(5L, SubcomponentMapModule_ProvideLong5Factory.create())",
+                "          .build();",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, String> strings() {",
+                "    return ImmutableMap.<String, String>of();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, Provider<String>> providerStrings() {",
+                "    return ImmutableMap.<String, Provider<String>>of();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Integer> ints() {",
+                "    return ImmutableMap.<Integer, Integer>of(0, MapModule.provideInt());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Provider<Integer>> providerInts() {",
+                "    return ImmutableMap.<Integer, Provider<Integer>>of(",
+                "        0, MapModule_ProvideIntFactory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Long> longs() {",
+                "    return ImmutableMap.<Long, Long>of(",
+                "      0L, MapModule.provideLong0(),",
+                "      1L, MapModule.provideLong1(),",
+                "      2L, MapModule.provideLong2());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Provider<Long>> providerLongs() {",
+                "    return ImmutableMap.<Long, Provider<Long>>of(",
+                "      0L, MapModule_ProvideLong0Factory.create(),",
+                "      1L, MapModule_ProvideLong1Factory.create(),",
+                "      2L, MapModule_ProvideLong2Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Sub sub() {",
+                "    return new SubImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "  private final class SubImpl implements Sub {",
+                "    private SubImpl() {}",
+                "",
+                "    @Override",
+                "    public Map<Long, Long> longs() {",
+                "      return ImmutableMap.<Long, Long>builder()",
+                "          .put(0L, MapModule.provideLong0())",
+                "          .put(1L, MapModule.provideLong1())",
+                "          .put(2L, MapModule.provideLong2())",
+                "          .put(3L, SubcomponentMapModule.provideLong3())",
+                "          .put(4L, SubcomponentMapModule.provideLong4())",
+                "          .put(5L, SubcomponentMapModule.provideLong5())",
+                "          .build();",
+                "    }",
+                "",
+                "    @Override",
+                "    public Map<Long, Provider<Long>> providerLongs() {",
+                "      return ImmutableMap.<Long, Provider<Long>>builder()",
+                "          .put(0L, MapModule_ProvideLong0Factory.create())",
+                "          .put(1L, MapModule_ProvideLong1Factory.create())",
+                "          .put(2L, MapModule_ProvideLong2Factory.create())",
+                "          .put(3L, SubcomponentMapModule_ProvideLong3Factory.create())",
+                "          .put(4L, SubcomponentMapModule_ProvideLong4Factory.create())",
+                "          .put(5L, SubcomponentMapModule_ProvideLong5Factory.create())",
+                "          .build();",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
         daggerCompiler()
+            .withOptions(compilerMode.javacopts())
             .compile(mapModuleFile, componentFile, subcomponentModuleFile, subcomponent);
     assertThat(compilation).succeeded();
     assertThat(compilation)
@@ -261,44 +422,92 @@ public void inaccessible() {
             "interface TestComponent {",
             "  UsesInaccessible usesInaccessible();",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import other.UsesInaccessible;",
-            "import other.UsesInaccessible_Factory;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public UsesInaccessible usesInaccessible() {",
-            "    return UsesInaccessible_Factory.newUsesInaccessible((Map) ImmutableMap.of());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private UsesInaccessible getUsesInaccessibleInstance() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible((Map) ImmutableMap.of());",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return getUsesInaccessibleInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible((Map) ImmutableMap.of());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(module, inaccessible, usesInaccessible, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, inaccessible, usesInaccessible, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -346,78 +555,155 @@ public void subcomponentOmitsInheritedBindings() {
             "interface Child {",
             "  Map<String, Object> objectMap();",
             "}");
-    JavaFileObject expected =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParent",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableMap;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParent implements Parent {",
-            "  private ParentModule parentModule;",
-            "",
-            "  private DaggerParent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Parent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.parentModule = builder.parentModule;",
-            "  }",
-            "",
-            "  @Override",
-            "  public Child child() {",
-            "    return new ChildImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private ParentModule parentModule;",
-            "",
-            "    private Builder() {}",
-            "",
-            "    public Parent build() {",
-            "      if (parentModule == null) {",
-            "        this.parentModule = new ParentModule();",
-            "      }",
-            "      return new DaggerParent(this);",
-            "    }",
-            "",
-            "    public Builder parentModule(ParentModule parentModule) {",
-            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "",
-            "  private final class ChildImpl implements Child {",
-            "    private ChildImpl() {}",
-            "",
-            "    @Override",
-            "    public Map<String, Object> objectMap() {",
-            "      return ImmutableMap.<String, Object>of(",
-            "          \"parent key\",",
-            "          Preconditions.checkNotNull(",
-            "              DaggerParent.this.parentModule.parentKeyObject(),",
-            "              " + NPE_FROM_PROVIDES_METHOD + ");",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(parent, parentModule, child);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private ParentModule parentModule;",
+                "",
+                "  private DaggerParent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Object getMapOfStringAndProviderOfObjectInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        parentModule.parentKeyObject(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    @Override",
+                "    public Map<String, Object> objectMap() {",
+                "      return ImmutableMap.<String, Object>of(",
+                "          \"parent key\",",
+                "          DaggerParent.this.getMapOfStringAndProviderOfObjectInstance());",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private ParentModule parentModule;",
+                "",
+                "  private DaggerParent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    @Override",
+                "    public Map<String, Object> objectMap() {",
+                "      return ImmutableMap.<String, Object>of(",
+                "          \"parent key\",",
+                "          Preconditions.checkNotNull(",
+                "              DaggerParent.this.parentModule.parentKeyObject(),",
+                "              " + NPE_FROM_PROVIDES_METHOD + ");",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(parent, parentModule, child);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerParent")
-        .hasSourceEquivalentTo(expected);
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test
@@ -493,7 +779,9 @@ public void productionComponents() {
             "  }",
             "}");
     Compilation compilation =
-        daggerCompiler().compile(mapModuleFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(mapModuleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
diff --git a/javatests/dagger/internal/codegen/MembersInjectionTest.java b/javatests/dagger/internal/codegen/MembersInjectionTest.java
index 95dd46f66..4100bdcea 100644
--- a/javatests/dagger/internal/codegen/MembersInjectionTest.java
+++ b/javatests/dagger/internal/codegen/MembersInjectionTest.java
@@ -33,6 +33,7 @@
 import com.google.testing.compile.JavaFileObjects;
 import java.io.IOException;
 import java.io.Writer;
+import java.util.Collection;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
@@ -40,10 +41,22 @@
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class MembersInjectionTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public MembersInjectionTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
   @Test
   public void parentClass_noInjectedMembers() {
     JavaFileObject childFile = JavaFileObjects.forSourceLines("test.Child",
@@ -68,43 +81,88 @@ public void parentClass_noInjectedMembers() {
         "interface TestComponent {",
         "  Child child();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private DaggerTestComponent(Builder builder) {}",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return new Builder().build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Child child() {",
-        "    return new Child();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Child getChildInstance() {",
+                "    return new Child();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return getChildInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new Child();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
         .that(ImmutableList.of(childFile, parentFile, componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
@@ -142,47 +200,101 @@ public void parentClass_injectedMembersInSupertype() {
         "interface TestComponent {",
         "  Child child();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Child child() {",
-            "    return injectChild(Child_Factory.newChild());",
-            "  }",
-            "",
-            "  @CanIgnoreReturnValue",
-            "  private Child injectChild(Child instance) {",
-            "    Parent_MembersInjector.injectDep(instance, new Dep());",
-            "    return instance;",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Dep getDepInstance() {",
+                "    return new Dep();",
+                "  }",
+                "",
+                "  private Child getChildInstance() {",
+                "    return injectChild(Child_Factory.newChild());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return getChildInstance();",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private Child injectChild(Child instance) {",
+                "    Parent_MembersInjector.injectDep(instance, getDepInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return injectChild(Child_Factory.newChild());",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private Child injectChild(Child instance) {",
+                "    Parent_MembersInjector.injectDep(instance, new Dep());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
         .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -242,6 +354,7 @@ public void parentClass_injectedMembersInSupertype() {
         "}");
     assertAbout(javaSource())
         .that(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -334,6 +447,7 @@ public void parentClass_injectedMembersInSupertype() {
         "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(a, a2, parent, child))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -400,6 +514,7 @@ public void parentClass_injectedMembersInSupertype() {
             "}");
     assertAbout(javaSource())
         .that(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -475,6 +590,7 @@ public void parentClass_injectedMembersInSupertype() {
             "}");
     assertAbout(javaSource())
         .that(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -552,6 +668,7 @@ public void mixedMemberInjection() {
         "}");
     assertAbout(javaSource())
         .that(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -610,6 +727,7 @@ public void mixedMemberInjection() {
         "}");
     assertAbout(javaSource())
         .that(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -660,6 +778,7 @@ public void mixedMemberInjection() {
         "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(aFile, bFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -719,6 +838,7 @@ public void simpleComponentWithNesting() {
           "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(nestedTypesFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -782,6 +902,7 @@ public void componentWithNestingAndGeneratedType() {
             "}");
     assertAbout(javaSource())
         .that(nestedTypesFile)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(
             new ComponentProcessor(),
             new AbstractProcessor() {
@@ -798,10 +919,10 @@ public boolean process(
                 if (!done) {
                   done = true;
                   try (Writer writer =
-                          processingEnv
-                              .getFiler()
-                              .createSourceFile("test.GeneratedType")
-                              .openWriter()) {
+                      processingEnv
+                          .getFiler()
+                          .createSourceFile("test.GeneratedType")
+                          .openWriter()) {
                     writer.write(
                         Joiner.on('\n')
                             .join(
@@ -862,9 +983,11 @@ public void lowerCaseNamedMembersInjector_forLowerCaseType() {
 
     assertAbout(javaSources())
         .that(ImmutableList.of(foo, fooModule, fooComponent))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesFileNamed(CLASS_OUTPUT, "test", "foo_MembersInjector.class");
+        .and()
+        .generatesFileNamed(CLASS_OUTPUT, "test", "foo_MembersInjector.class");
   }
 
   @Test
@@ -959,9 +1082,11 @@ public void fieldInjectionForShadowedMember() {
 
     assertAbout(javaSources())
         .that(ImmutableList.of(foo, bar, parent, child, component))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expectedMembersInjector);
+        .and()
+        .generatesSources(expectedMembersInjector);
   }
 
   @Test public void privateNestedClassError() {
@@ -977,8 +1102,12 @@ public void fieldInjectionForShadowedMember() {
         "}");
     assertAbout(javaSource())
         .that(file)
-        .processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);
+        .withCompilerOptions(compilerMode.javacopts())
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS)
+        .in(file)
+        .onLine(6);
   }
 
   @Test public void privateNestedClassWarning() {
@@ -994,10 +1123,13 @@ public void fieldInjectionForShadowedMember() {
         "}");
     assertAbout(javaSource())
         .that(file)
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .withCompilerOptions(
+            compilerMode.javacopts().append("-Adagger.privateMemberValidation=WARNING"))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);
+        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS)
+        .in(file)
+        .onLine(6);
   }
 
   @Test public void privateSuperclassIsOkIfNotInjectedInto() {
@@ -1015,6 +1147,7 @@ public void fieldInjectionForShadowedMember() {
         "}");
     assertAbout(javaSource())
         .that(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
@@ -1043,11 +1176,16 @@ public void fieldInjectionForShadowedMember() {
             "  void inject(RawProviderParameter rawProviderParameter);",
             "}");
     assertThat(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("javax.inject.Provider cannot be provided").in(file).onLine(17)
+        .withErrorContaining("javax.inject.Provider cannot be provided")
+        .in(file)
+        .onLine(17)
         .and()
-        .withErrorContaining("javax.inject.Provider cannot be provided").in(file).onLine(18);
+        .withErrorContaining("javax.inject.Provider cannot be provided")
+        .in(file)
+        .onLine(18);
   }
 
   @Test
@@ -1139,7 +1277,8 @@ public void injectsPrimitive() {
             "    return new InjectedType();",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(injectedType);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(injectedType);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.InjectedType_MembersInjector")
@@ -1197,7 +1336,9 @@ public void accessibility() {
             "}");
 
     Compilation compilation =
-        daggerCompiler().compile(foo, inaccessible, usesInaccessible, component);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, inaccessible, usesInaccessible, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("other.Inaccessible_MembersInjector")
@@ -1237,9 +1378,73 @@ public void accessibility() {
                 "    ((Inaccessible) instance).method((Foo) foo);",
                 "  }",
                 "}"));
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "import other.Foo_Factory;",
+                "import other.Inaccessible_Factory;",
+                "import other.Inaccessible_MembersInjector;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Object getFooInstance() {",
+                "    return Foo_Factory.newFoo();",
+                "  }",
+                "",
+                "  private Object getInaccessibleInstance() {",
+                "    return injectInaccessible(Inaccessible_Factory.newInaccessible());",
+                "  }",
+                "",
+                "  private UsesInaccessible getUsesInaccessibleInstance() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        getInaccessibleInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return getUsesInaccessibleInstance();",
+                "  }",
+                "",
+                // TODO(ronshapiro): if possible, it would be great to rename "instance", but we
+                // need to make sure that this doesn't conflict with any framework field in this or
+                // any parent component
+                "  @CanIgnoreReturnValue",
+                "  private Object injectInaccessible(Object instance) {",
+                "    Inaccessible_MembersInjector.injectFoo(instance, getFooInstance());",
+                "    Inaccessible_MembersInjector.injectMethod(instance, getFooInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
             JavaFileObjects.forSourceLines(
                 "test.DaggerTestComponent",
                 "package test;",
@@ -1288,7 +1493,11 @@ public void accessibility() {
                 "      return new DaggerTestComponent(this);",
                 "    }",
                 "  }",
-                "}"));
+                "}");
+    }
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test
@@ -1346,11 +1555,87 @@ public void accessibleRawType_ofInaccessibleType() {
             "}");
 
     Compilation compilation =
-        daggerCompiler().compile(inaccessible, inaccessiblesModule, usesInaccessibles, component);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(inaccessible, inaccessiblesModule, usesInaccessibles, component);
     assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "other.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import dagger.internal.DoubleCheck;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.List;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "import other.InaccessiblesModule;",
+                "import other.InaccessiblesModule_InaccessiblesFactory;",
+                "import other.UsesInaccessibles;",
+                "import other.UsesInaccessibles_Factory;",
+                "import other.UsesInaccessibles_MembersInjector;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  @SuppressWarnings(\"rawtypes\")",
+                "  private Provider inaccessiblesProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private UsesInaccessibles getUsesInaccessiblesInstance() {",
+                "    return injectUsesInaccessibles(",
+                "        UsesInaccessibles_Factory.newUsesInaccessibles());",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.inaccessiblesProvider =",
+                "        DoubleCheck.provider(InaccessiblesModule_InaccessiblesFactory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessibles usesInaccessibles() {",
+                "    return getUsesInaccessiblesInstance();",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private UsesInaccessibles injectUsesInaccessibles(UsesInaccessibles instance) {",
+                "    UsesInaccessibles_MembersInjector.injectInaccessibles(",
+                "        instance, (List) inaccessiblesProvider.get());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder inaccessiblesModule(InaccessiblesModule inaccessiblesModule) {",
+                "      Preconditions.checkNotNull(inaccessiblesModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
             JavaFileObjects.forSourceLines(
                 "other.DaggerTestComponent",
                 "package test;",
@@ -1417,7 +1702,11 @@ public void accessibleRawType_ofInaccessibleType() {
                 "      return this;",
                 "    }",
                 "  }",
-                "}"));
+                "}");
+    }
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test
@@ -1475,11 +1764,73 @@ public void publicSupertypeHiddenSubtype() {
             "}");
 
     Compilation compilation =
-        daggerCompiler().compile(foo, supertype, subtype, injectsSubtype, component);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, supertype, subtype, injectsSubtype, component);
     assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "import other.Foo_Factory;",
+                "import other.InjectsSubtype;",
+                "import other.InjectsSubtype_Factory;",
+                "import other.Subtype_Factory;",
+                "import other.Supertype;",
+                "import other.Supertype_MembersInjector;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Object getFooInstance() {",
+                "    return Foo_Factory.newFoo();",
+                "  }",
+                "",
+                "  private Object getSubtypeInstance() {",
+                "    return injectSubtype(Subtype_Factory.newSubtype());",
+                "  }",
+                "",
+                "  private InjectsSubtype getInjectsSubtypeInstance() {",
+                "    return InjectsSubtype_Factory.newInjectsSubtype(getSubtypeInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public InjectsSubtype injectsSubtype() {",
+                "    return getInjectsSubtypeInstance();",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private Object injectSubtype(Object instance) {",
+                "    Supertype_MembersInjector.injectT((Supertype) instance, getFooInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
             JavaFileObjects.forSourceLines(
                 "test.DaggerTestComponent",
                 "package test;",
@@ -1525,6 +1876,10 @@ public void publicSupertypeHiddenSubtype() {
                 "      return new DaggerTestComponent(this);",
                 "    }",
                 "  }",
-                "}"));
+                "}");
+    }
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 }
diff --git a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
index fe75207cf..dfc2ecae5 100644
--- a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
@@ -23,13 +23,25 @@
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import com.squareup.javapoet.CodeBlock;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class OptionalBindingRequestFulfillmentTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public OptionalBindingRequestFulfillmentTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
 
   public static final CodeBlock NPE_FROM_PROVIDES =
       CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
@@ -91,66 +103,138 @@ public void inlinedOptionalBindings() {
             "  Optional<DefinitelyNot> definitelyNot();",
             "  Optional<Provider<Lazy<DefinitelyNot>>> providerOfLazyOfDefinitelyNot();",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import dagger.Lazy;",
-            "import dagger.internal.Preconditions;",
-            "import dagger.internal.ProviderOfLazy;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "import other.DefinitelyNot;",
-            "import other.Maybe;",
-            "import other.Maybe_MaybeModule_ProvideMaybeFactory;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Optional<Maybe> maybe() {",
-            "    return Optional.of(",
-            "        Preconditions.checkNotNull(",
-            "            Maybe.MaybeModule.provideMaybe(), " + NPE_FROM_PROVIDES + "));",
-            "  }",
-            "",
-            "  @Override",
-            "  public Optional<Provider<Lazy<Maybe>>> providerOfLazyOfMaybe() {",
-            "    return Optional.of(",
-            "        ProviderOfLazy.create(Maybe_MaybeModule_ProvideMaybeFactory.create()));",
-            "  }",
-            "",
-            "  @Override",
-            "  public Optional<DefinitelyNot> definitelyNot() {",
-            "    return Optional.absent();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Optional<Provider<Lazy<DefinitelyNot>>> providerOfLazyOfDefinitelyNot() {",
-            "    return Optional.absent();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.base.Optional;",
+                "import dagger.Lazy;",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.ProviderOfLazy;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "import other.DefinitelyNot;",
+                "import other.Maybe;",
+                "import other.Maybe_MaybeModule_ProvideMaybeFactory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Maybe getMaybeInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        Maybe.MaybeModule.provideMaybe(),",
+                "        " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Maybe> maybe() {",
+                "    return Optional.of(getMaybeInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Provider<Lazy<Maybe>>> providerOfLazyOfMaybe() {",
+                "    return Optional.of(ProviderOfLazy.create(",
+                "        Maybe_MaybeModule_ProvideMaybeFactory.create()));",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<DefinitelyNot> definitelyNot() {",
+                "    return Optional.absent();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Provider<Lazy<DefinitelyNot>>>",
+                "      providerOfLazyOfDefinitelyNot() {",
+                "    return Optional.absent();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.base.Optional;",
+                "import dagger.Lazy;",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.ProviderOfLazy;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "import other.DefinitelyNot;",
+                "import other.Maybe;",
+                "import other.Maybe_MaybeModule_ProvideMaybeFactory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Maybe> maybe() {",
+                "    return Optional.of(",
+                "        Preconditions.checkNotNull(",
+                "            Maybe.MaybeModule.provideMaybe(), " + NPE_FROM_PROVIDES + "));",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Provider<Lazy<Maybe>>> providerOfLazyOfMaybe() {",
+                "    return Optional.of(",
+                "        ProviderOfLazy.create(Maybe_MaybeModule_ProvideMaybeFactory.create()));",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<DefinitelyNot> definitelyNot() {",
+                "    return Optional.absent();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Provider<Lazy<DefinitelyNot>>>",
+                "      providerOfLazyOfDefinitelyNot() {",
+                "    return Optional.absent();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(module, maybe, definitelyNot, component);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, maybe, definitelyNot, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -212,61 +296,127 @@ public void requestForFuture() {
             "  ListenableFuture<Optional<Maybe>> maybe();",
             "  ListenableFuture<Optional<DefinitelyNot>> definitelyNot();",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import com.google.common.util.concurrent.Futures;",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "import other.DefinitelyNot;",
-            "import other.Maybe;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public ListenableFuture<Optional<Maybe>> maybe() {",
-            "    return Futures.immediateFuture(Optional.of(Preconditions.checkNotNull(",
-            "        Maybe.MaybeModule.provideMaybe(), " + NPE_FROM_PROVIDES + ")));",
-            "  }",
-            "",
-            "  @Override",
-            "  public ListenableFuture<Optional<DefinitelyNot>> definitelyNot() {",
-            "    return Futures.immediateFuture(Optional.<DefinitelyNot>absent());",
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.base.Optional;",
+                "import com.google.common.util.concurrent.Futures;",
+                "import com.google.common.util.concurrent.ListenableFuture;",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import other.DefinitelyNot;",
+                "import other.Maybe;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Maybe getMaybeInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        Maybe.MaybeModule.provideMaybe(),",
+                "        " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<Optional<Maybe>> maybe() {",
+                "    return Futures.immediateFuture(Optional.of(getMaybeInstance()));",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<Optional<DefinitelyNot>> definitelyNot() {",
+                "    return Futures.immediateFuture(Optional.<DefinitelyNot>absent());",
 
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder testComponent_ProductionExecutorModule(",
-            "        TestComponent_ProductionExecutorModule",
-            "            testComponent_ProductionExecutorModule) {",
-            "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder testComponent_ProductionExecutorModule(",
+                "        TestComponent_ProductionExecutorModule",
+                "            testComponent_ProductionExecutorModule) {",
+                "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.base.Optional;",
+                "import com.google.common.util.concurrent.Futures;",
+                "import com.google.common.util.concurrent.ListenableFuture;",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import other.DefinitelyNot;",
+                "import other.Maybe;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<Optional<Maybe>> maybe() {",
+                "    return Futures.immediateFuture(Optional.of(Preconditions.checkNotNull(",
+                "        Maybe.MaybeModule.provideMaybe(), " + NPE_FROM_PROVIDES + ")));",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<Optional<DefinitelyNot>> definitelyNot() {",
+                "    return Futures.immediateFuture(Optional.<DefinitelyNot>absent());",
+
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder testComponent_ProductionExecutorModule(",
+                "        TestComponent_ProductionExecutorModule",
+                "            testComponent_ProductionExecutorModule) {",
+                "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(module, maybe, definitelyNot, component);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, maybe, definitelyNot, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
index 226972c21..32348e69a 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
@@ -17,19 +17,33 @@
 package dagger.internal.codegen;
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompilerWithoutGuava;
+import static dagger.internal.codegen.Compilers.CLASS_PATH_WITHOUT_GUAVA_OPTION;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 import com.google.testing.compile.Compilation;
+import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
 import com.squareup.javapoet.CodeBlock;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class SetBindingRequestFulfillmentTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public SetBindingRequestFulfillmentTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
 
   public static final CodeBlock NPE_FROM_PROVIDES =
       CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
@@ -78,59 +92,125 @@ public void setBindings() {
         "  Set<String> strings();",
         "  Set<Object> objects();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetBuilder;",
-            "import java.util.Collections;",
-            "import java.util.Set;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Set<String> strings() {",
-            "    return SetBuilder.<String>newSetBuilder(2)",
-            "        .addAll(Preconditions.checkNotNull(",
-            "            EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + "))",
-            "        .add(Preconditions.checkNotNull(",
-            "            SetModule.string(), " + NPE_FROM_PROVIDES + "))",
-            "        .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Set<Object> objects() {",
-            "    return Collections.<Object>emptySet();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder setModule(SetModule setModule) {",
-            "      Preconditions.checkNotNull(setModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetBuilder;",
+                "import java.util.Collections;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Set<String> getSetOfStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  private String getStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        SetModule.string(), " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<String> strings() {",
+                "    return SetBuilder.<String>newSetBuilder(2)",
+                "        .addAll(getSetOfStringInstance())",
+                "        .add(getStringInstance())",
+                "        .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<Object> objects() {",
+                "    return Collections.<Object>emptySet();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder setModule(SetModule setModule) {",
+                "      Preconditions.checkNotNull(setModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetBuilder;",
+                "import java.util.Collections;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<String> strings() {",
+                "    return SetBuilder.<String>newSetBuilder(2)",
+                "        .addAll(Preconditions.checkNotNull(",
+                "            EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + "))",
+                "        .add(Preconditions.checkNotNull(",
+                "            SetModule.string(), " + NPE_FROM_PROVIDES + "))",
+                "        .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<Object> objects() {",
+                "    return Collections.<Object>emptySet();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder setModule(SetModule setModule) {",
+                "      Preconditions.checkNotNull(setModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
         daggerCompilerWithoutGuava().compile(emptySetModuleFile, setModuleFile, componentFile);
     assertThat(compilation).succeeded();
@@ -201,51 +281,110 @@ public void inaccessible() {
             "interface TestComponent {",
             "  UsesInaccessible usesInaccessible();",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetBuilder;",
-            "import java.util.Collections;",
-            "import java.util.Set;",
-            "import javax.annotation.Generated;",
-            "import other.TestModule_EmptySetFactory;",
-            "import other.UsesInaccessible;",
-            "import other.UsesInaccessible_Factory;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public UsesInaccessible usesInaccessible() {",
-            "    return UsesInaccessible_Factory.newUsesInaccessible(",
-            "        (Set) Collections.emptySet(),",
-            "        (Set) SetBuilder.newSetBuilder(1)",
-            "            .addAll(Preconditions.checkNotNull(",
-            "                TestModule_EmptySetFactory.proxyEmptySet(),",
-            "                " + NPE_FROM_PROVIDES + "))",
-            "            .build());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetBuilder;",
+                "import java.util.Collections;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "import other.TestModule_EmptySetFactory;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Set getSetOfInaccessible2Instance() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule_EmptySetFactory.proxyEmptySet(),",
+                "        " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  private UsesInaccessible getUsesInaccessibleInstance() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        (Set) Collections.emptySet(),",
+                "        (Set) SetBuilder.newSetBuilder(1)",
+                "            .addAll(getSetOfInaccessible2Instance())",
+                "            .build());",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return getUsesInaccessibleInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetBuilder;",
+                "import java.util.Collections;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "import other.TestModule_EmptySetFactory;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        (Set) Collections.emptySet(),",
+                "        (Set) SetBuilder.newSetBuilder(1)",
+                "            .addAll(Preconditions.checkNotNull(",
+                "                TestModule_EmptySetFactory.proxyEmptySet(),",
+                "                " + NPE_FROM_PROVIDES + "))",
+                "            .build());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
         daggerCompilerWithoutGuava()
             .compile(module, inaccessible, inaccessible2, usesInaccessible, componentFile);
@@ -296,62 +435,127 @@ public void subcomponentOmitsInheritedBindings() {
             "interface Child {",
             "  Set<Object> objectSet();",
             "}");
-    JavaFileObject expected =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Collections;",
-            "import java.util.Set;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParent implements Parent {",
-            "  private DaggerParent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Parent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Child child() {",
-            "    return new ChildImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Parent build() {",
-            "      return new DaggerParent(this);",
-            "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder parentModule(ParentModule parentModule) {",
-            "      Preconditions.checkNotNull(parentModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "",
-            "  private final class ChildImpl implements Child {",
-            "    private ChildImpl() {}",
-            "",
-            "    @Override",
-            "    public Set<Object> objectSet() {",
-            "      return Collections.<Object>singleton(Preconditions.checkNotNull(",
-            "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + "));",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Collections;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private DaggerParent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    private Object getObjectInstance() {",
+                "      return Preconditions.checkNotNull(",
+                "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + ");",
+                "    }",
+                "",
+                "    @Override",
+                "    public Set<Object> objectSet() {",
+                "      return Collections.<Object>singleton(getObjectInstance());",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Collections;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private DaggerParent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    @Override",
+                "    public Set<Object> objectSet() {",
+                "      return Collections.<Object>singleton(Preconditions.checkNotNull(",
+                "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + "));",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation = daggerCompilerWithoutGuava().compile(parent, parentModule, child);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerParent")
-        .hasSourceEquivalentTo(expected);
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
+  private Compiler daggerCompilerWithoutGuava() {
+    return daggerCompiler()
+        .withOptions(compilerMode.javacopts().append(CLASS_PATH_WITHOUT_GUAVA_OPTION));
+  }
 }
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index 8de07ec85..6926ab023 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -23,13 +23,25 @@
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import com.squareup.javapoet.CodeBlock;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class SetBindingRequestFulfillmentWithGuavaTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public SetBindingRequestFulfillmentWithGuavaTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
 
   public static final CodeBlock NPE_FROM_PROVIDES =
       CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
@@ -83,68 +95,146 @@ public void setBindings() {
         "  Set<Object> objects();",
         "  Set<Integer> onlyContributionIsElementsIntoSet();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Set;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Set<String> strings() {",
-            "    return ImmutableSet.<String>builder()",
-            "        .addAll(Preconditions.checkNotNull(",
-            "            EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + "))",
-            "        .add(Preconditions.checkNotNull(",
-            "            SetModule.string(), " + NPE_FROM_PROVIDES + "))",
-            "        .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Set<Object> objects() {",
-            "    return ImmutableSet.<Object>of();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Set<Integer> onlyContributionIsElementsIntoSet() {",
-            "    return ImmutableSet.<Integer>copyOf(",
-            "        Preconditions.checkNotNull(",
-            "            EmptySetModule.onlyContributionIsElementsIntoSet(),",
-            "            " + NPE_FROM_PROVIDES + "));",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder setModule(SetModule setModule) {",
-            "      Preconditions.checkNotNull(setModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Set<String> getSetOfStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  private String getStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        SetModule.string(), " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  private Set<Integer> getSetOfIntegerInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        EmptySetModule.onlyContributionIsElementsIntoSet(),",
+                "        " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<String> strings() {",
+                "    return ImmutableSet.<String>builder()",
+                "        .addAll(getSetOfStringInstance())",
+                "        .add(getStringInstance())",
+                "        .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<Object> objects() {",
+                "    return ImmutableSet.<Object>of();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<Integer> onlyContributionIsElementsIntoSet() {",
+                "    return ImmutableSet.<Integer>copyOf(getSetOfIntegerInstance());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder setModule(SetModule setModule) {",
+                "      Preconditions.checkNotNull(setModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<String> strings() {",
+                "    return ImmutableSet.<String>builder()",
+                "        .addAll(Preconditions.checkNotNull(",
+                "            EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + "))",
+                "        .add(Preconditions.checkNotNull(",
+                "            SetModule.string(), " + NPE_FROM_PROVIDES + "))",
+                "        .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<Object> objects() {",
+                "    return ImmutableSet.<Object>of();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<Integer> onlyContributionIsElementsIntoSet() {",
+                "    return ImmutableSet.<Integer>copyOf(",
+                "        Preconditions.checkNotNull(",
+                "            EmptySetModule.onlyContributionIsElementsIntoSet(),",
+                "            " + NPE_FROM_PROVIDES + "));",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder setModule(SetModule setModule) {",
+                "      Preconditions.checkNotNull(setModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(emptySetModuleFile, setModuleFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(emptySetModuleFile, setModuleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -213,51 +303,108 @@ public void inaccessible() {
             "interface TestComponent {",
             "  UsesInaccessible usesInaccessible();",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Set;",
-            "import javax.annotation.Generated;",
-            "import other.TestModule_EmptySetFactory;",
-            "import other.UsesInaccessible;",
-            "import other.UsesInaccessible_Factory;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public UsesInaccessible usesInaccessible() {",
-            "    return UsesInaccessible_Factory.newUsesInaccessible(",
-            "        (Set) ImmutableSet.of(),",
-            "        (Set) ImmutableSet.copyOf(",
-            "            Preconditions.checkNotNull(",
-            "                TestModule_EmptySetFactory.proxyEmptySet(),",
-            "                " + NPE_FROM_PROVIDES + ")));",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "import other.TestModule_EmptySetFactory;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Set getSetOfInaccessible2Instance() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule_EmptySetFactory.proxyEmptySet(),",
+                "        " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  private UsesInaccessible getUsesInaccessibleInstance() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        (Set) ImmutableSet.of(),",
+                "        (Set) ImmutableSet.copyOf(getSetOfInaccessible2Instance()));",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return getUsesInaccessibleInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "import other.TestModule_EmptySetFactory;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        (Set) ImmutableSet.of(),",
+                "        (Set) ImmutableSet.copyOf(",
+                "            Preconditions.checkNotNull(",
+                "                TestModule_EmptySetFactory.proxyEmptySet(),",
+                "                " + NPE_FROM_PROVIDES + ")));",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
         daggerCompiler()
+            .withOptions(compilerMode.javacopts())
             .compile(module, inaccessible, inaccessible2, usesInaccessible, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
@@ -306,62 +453,124 @@ public void subcomponentOmitsInheritedBindings() {
             "interface Child {",
             "  Set<Object> objectSet();",
             "}");
-    JavaFileObject expected =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParent",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Set;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParent implements Parent {",
-            "  private DaggerParent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Parent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Child child() {",
-            "    return new ChildImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Parent build() {",
-            "      return new DaggerParent(this);",
-            "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder parentModule(ParentModule parentModule) {",
-            "      Preconditions.checkNotNull(parentModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "",
-            "  private final class ChildImpl implements Child {",
-            "    private ChildImpl() {}",
-            "",
-            "    @Override",
-            "    public Set<Object> objectSet() {",
-            "      return ImmutableSet.<Object>of(Preconditions.checkNotNull(",
-            "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + "));",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(parent, parentModule, child);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private DaggerParent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    private Object getObjectInstance() {",
+                "      return Preconditions.checkNotNull(",
+                "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + ");",
+                "    }",
+                "",
+                "    @Override",
+                "    public Set<Object> objectSet() {",
+                "      return ImmutableSet.<Object>of(getObjectInstance());",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private DaggerParent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    @Override",
+                "    public Set<Object> objectSet() {",
+                "      return ImmutableSet.<Object>of(Preconditions.checkNotNull(",
+                "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + "));",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(parent, parentModule, child);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerParent")
-        .hasSourceEquivalentTo(expected);
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test
@@ -393,56 +602,116 @@ public void productionComponents() {
         "interface TestComponent {",
         "  ListenableFuture<Set<String>> strings();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import com.google.common.collect.ImmutableSet;",
-            "import com.google.common.util.concurrent.Futures;",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Set;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private DaggerTestComponent(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public ListenableFuture<Set<String>> strings() {",
-            "    return Futures.<Set<String>>immediateFuture(",
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import com.google.common.util.concurrent.Futures;",
+                "import com.google.common.util.concurrent.ListenableFuture;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Set<String> getSetOfStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<Set<String>> strings() {",
+                "    return Futures.<Set<String>>immediateFuture(",
 
-            "        ImmutableSet.<String>copyOf(Preconditions.checkNotNull(",
-            "            EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + "));",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder testComponent_ProductionExecutorModule(",
-            "        TestComponent_ProductionExecutorModule",
-            "            testComponent_ProductionExecutorModule) {",
-            "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
+                "        ImmutableSet.<String>copyOf(getSetOfStringInstance()));",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder testComponent_ProductionExecutorModule(",
+                "        TestComponent_ProductionExecutorModule",
+                "            testComponent_ProductionExecutorModule) {",
+                "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import com.google.common.util.concurrent.Futures;",
+                "import com.google.common.util.concurrent.ListenableFuture;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<Set<String>> strings() {",
+                "    return Futures.<Set<String>>immediateFuture(",
+
+                "        ImmutableSet.<String>copyOf(Preconditions.checkNotNull(",
+                "            EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + "));",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder testComponent_ProductionExecutorModule(",
+                "        TestComponent_ProductionExecutorModule",
+                "            testComponent_ProductionExecutorModule) {",
+                "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(emptySetModuleFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(emptySetModuleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
index 5d6c7ed61..4284b5b18 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
@@ -22,13 +22,26 @@
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class SubcomponentBuilderRequestFulfillmentTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public SubcomponentBuilderRequestFulfillmentTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
   @Test
   public void testInlinedSubcomponentBuilders_componentMethod() {
     JavaFileObject subcomponent =
@@ -68,56 +81,117 @@ public void testInlinedSubcomponentBuilders_componentMethod() {
             "  UsesSubcomponent usesSubcomponent();",
             "}");
 
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerC",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerC implements C {",
-            "  private DaggerC(Builder builder) {}",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static C create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Sub.Builder sBuilder() {",
-            "    return new SubBuilder();",
-            "  }",
-            "",
-            "  @Override",
-            "  public UsesSubcomponent usesSubcomponent() {",
-            "    return new UsesSubcomponent(new SubBuilder());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public C build() {",
-            "      return new DaggerC(this);",
-            "    }",
-            "  }",
-            "",
-            "  private final class SubBuilder implements Sub.Builder {",
-            "    @Override",
-            "    public Sub build() {",
-            "      return new SubImpl(this);",
-            "    }",
-            "  }",
-            "",
-            "  private final class SubImpl implements Sub {",
-            "    private SubImpl(SubBuilder builder) {}",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerC",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerC implements C {",
+                "  private DaggerC(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static C create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private UsesSubcomponent getUsesSubcomponentInstance() {",
+                "    return new UsesSubcomponent(new SubBuilder());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Sub.Builder sBuilder() {",
+                "    return new SubBuilder();",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesSubcomponent usesSubcomponent() {",
+                "    return getUsesSubcomponentInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public C build() {",
+                "      return new DaggerC(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubBuilder implements Sub.Builder {",
+                "    @Override",
+                "    public Sub build() {",
+                "      return new SubImpl(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubImpl implements Sub {",
+                "    private SubImpl(SubBuilder builder) {}",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerC",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerC implements C {",
+                "  private DaggerC(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static C create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Sub.Builder sBuilder() {",
+                "    return new SubBuilder();",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesSubcomponent usesSubcomponent() {",
+                "    return new UsesSubcomponent(new SubBuilder());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public C build() {",
+                "      return new DaggerC(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubBuilder implements Sub.Builder {",
+                "    @Override",
+                "    public Sub build() {",
+                "      return new SubImpl(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubImpl implements Sub {",
+                "    private SubImpl(SubBuilder builder) {}",
+                "  }",
+                "}");
+    }
 
-    Compilation compilation = daggerCompiler().compile(subcomponent, usesSubcomponent, component);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(subcomponent, usesSubcomponent, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerC")
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index 056914e7e..94ba7f33b 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -24,13 +24,26 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class SubcomponentValidationTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public SubcomponentValidationTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
 
-@RunWith(JUnit4.class)
-public final class SubcomponentValidationTest {
   @Test public void factoryMethod_missingModulesWithParameters() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
         "package test;",
@@ -68,14 +81,17 @@
         "    return object;",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
             "test.ChildComponent requires modules which have no visible default constructors. "
                 + "Add the following modules as parameters to this method: "
                 + "test.ModuleWithParameters")
-        .in(componentFile).onLine(7);
+        .in(componentFile)
+        .onLine(7);
   }
 
   @Test public void factoryMethod_nonModuleParameter() {
@@ -95,12 +111,16 @@
         "",
         "@Subcomponent",
         "interface ChildComponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, childComponentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
             "Subcomponent factory methods may only accept modules, but java.lang.String is not.")
-        .in(componentFile).onLine(7).atColumn(43);
+        .in(componentFile)
+        .onLine(7)
+        .atColumn(43);
   }
 
   @Test public void factoryMethod_duplicateParameter() {
@@ -127,13 +147,17 @@
         "",
         "@Subcomponent(modules = TestModule.class)",
         "interface ChildComponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
             "A module may only occur once an an argument in a Subcomponent factory method, "
                 + "but test.TestModule was already passed.")
-        .in(componentFile).onLine(7).atColumn(71);
+        .in(componentFile)
+        .onLine(7)
+        .atColumn(71);
   }
 
   @Test public void factoryMethod_superflouousModule() {
@@ -160,13 +184,16 @@
         "",
         "@Subcomponent",
         "interface ChildComponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-    .processedWith(new ComponentProcessor())
-    .failsToCompile()
-    .withErrorContaining(
-        "test.TestModule is present as an argument to the test.ChildComponent factory method, but "
-            + "is not one of the modules used to implement the subcomponent.")
-                .in(componentFile).onLine(7);
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .withCompilerOptions(compilerMode.javacopts())
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.TestModule is present as an argument to the test.ChildComponent factory method, "
+                + "but is not one of the modules used to implement the subcomponent.")
+        .in(componentFile)
+        .onLine(7);
   }
 
   @Test public void missingBinding() {
@@ -202,6 +229,7 @@
         "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
@@ -220,7 +248,9 @@
         "",
         "@Subcomponent",
         "final class NotASubcomponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(subcomponentFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(subcomponentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("interface");
@@ -258,7 +288,9 @@
         "final class ChildModule {",
         "  @Provides @Singleton Object provideObject() { return null; }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, subcomponentFile, moduleFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, subcomponentFile, moduleFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("@Singleton");
@@ -352,90 +384,191 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
             "  @Inject public void dep2Method() { }",
             "}");
 
-    JavaFileObject componentGeneratedFile =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParentComponent",
-            "package test;",
-            "",
-            "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
-            "import dagger.internal.DoubleCheck;",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParentComponent implements ParentComponent {",
-            "  private Provider<Dep1> dep1Provider;",
-            "  private Provider<Dep2> dep2Provider;",
-            "",
-            "  private DaggerParentComponent(Builder builder) {  ",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {  ",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static ParentComponent create() {  ",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {  ",
-            "    this.dep1Provider = DoubleCheck.provider(Dep1_Factory.create());",
-            "    this.dep2Provider = DoubleCheck.provider(Dep2_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Dep1 getDep1() {  ",
-            "    return dep1Provider.get();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Dep2 getDep2() {  ",
-            "    return dep2Provider.get();",
-            "  }",
-            "",
-            "  @Override",
-            "  public ChildComponent childComponent() {  ",
-            "    return new ChildComponentImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {  ",
-            "    }",
-            "  ",
-            "    public ParentComponent build() {  ",
-            "      return new DaggerParentComponent(this);",
-            "    }",
-            "  }",
-            "",
-            "  private final class ChildComponentImpl implements ChildComponent {",
-            "    private final ChildModule childModule;",
-            "  ",
-            "    private ChildComponentImpl() {  ",
-            "      this.childModule = new ChildModule();",
-            "    }",
-            "  ",
-            "    @Override",
-            "    public Object getObject() {  ",
-            "      return Preconditions.checkNotNull(",
-            "          childModule.provideObject(",
-            "              injectA(",
-            "                  A_Factory.newA(",
-            "                      new NeedsDep1(DaggerParentComponent.this.dep1Provider.get()),",
-            "                      DaggerParentComponent.this.dep1Provider.get(),",
-            "                      DaggerParentComponent.this.dep2Provider.get()))),",
-            "          " + NPE_FROM_PROVIDES_METHOD + ");",
-            "    }",
-            "",
-            "    @CanIgnoreReturnValue",
-            "    private A injectA(A instance) {",
-            "      A_MembersInjector.injectMethodA(instance);",
-            "      return instance;",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParentComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import dagger.internal.DoubleCheck;",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParentComponent implements ParentComponent {",
+                "  private Provider<Dep1> dep1Provider;",
+                "  private Provider<Dep2> dep2Provider;",
+                "",
+                "  private DaggerParentComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static ParentComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.dep1Provider = DoubleCheck.provider(Dep1_Factory.create());",
+                "    this.dep2Provider = DoubleCheck.provider(Dep2_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Dep1 getDep1() {",
+                "    return dep1Provider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Dep2 getDep2() {",
+                "    return dep2Provider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public ChildComponent childComponent() {",
+                "    return new ChildComponentImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public ParentComponent build() {",
+                "      return new DaggerParentComponent(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildComponentImpl implements ChildComponent {",
+                "    private final ChildModule childModule;",
+                "",
+                "    private ChildComponentImpl() {",
+                "      this.childModule = new ChildModule();",
+                "    }",
+                "",
+                "    private NeedsDep1 getNeedsDep1Instance() {",
+                "      return new NeedsDep1(DaggerParentComponent.this.dep1Provider.get());",
+                "    }",
+                "",
+                "    private A getAInstance() {",
+                "      return injectA(",
+                "          A_Factory.newA(",
+                "              getNeedsDep1Instance(),",
+                "              DaggerParentComponent.this.dep1Provider.get(),",
+                "              DaggerParentComponent.this.dep2Provider.get()));",
+                "    }",
+                "",
+                "    private Object getObjectInstance() {",
+                "      return Preconditions.checkNotNull(",
+                "          childModule.provideObject(getAInstance()),",
+                "          " + NPE_FROM_PROVIDES_METHOD + ");",
+                "    }",
+                "",
+                "    @Override",
+                "    public Object getObject() {",
+                "      return getObjectInstance();",
+                "    }",
+                "",
+                "    @CanIgnoreReturnValue",
+                "    private A injectA(A instance) {",
+                "      A_MembersInjector.injectMethodA(instance);",
+                "      return instance;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParentComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import dagger.internal.DoubleCheck;",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParentComponent implements ParentComponent {",
+                "  private Provider<Dep1> dep1Provider;",
+                "  private Provider<Dep2> dep2Provider;",
+                "",
+                "  private DaggerParentComponent(Builder builder) {  ",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {  ",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static ParentComponent create() {  ",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {  ",
+                "    this.dep1Provider = DoubleCheck.provider(Dep1_Factory.create());",
+                "    this.dep2Provider = DoubleCheck.provider(Dep2_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Dep1 getDep1() {  ",
+                "    return dep1Provider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Dep2 getDep2() {  ",
+                "    return dep2Provider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public ChildComponent childComponent() {  ",
+                "    return new ChildComponentImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {  ",
+                "    }",
+                "  ",
+                "    public ParentComponent build() {  ",
+                "      return new DaggerParentComponent(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildComponentImpl implements ChildComponent {",
+                "    private final ChildModule childModule;",
+                "  ",
+                "    private ChildComponentImpl() {  ",
+                "      this.childModule = new ChildModule();",
+                "    }",
+                "  ",
+                "    @Override",
+                "    public Object getObject() {  ",
+                "      return Preconditions.checkNotNull(",
+                "          childModule.provideObject(",
+                "              injectA(",
+                "                  A_Factory.newA(",
+                "                      new NeedsDep1(",
+                "                          DaggerParentComponent.this.dep1Provider.get()),",
+                "                      DaggerParentComponent.this.dep1Provider.get(),",
+                "                      DaggerParentComponent.this.dep2Provider.get()))),",
+                "          " + NPE_FROM_PROVIDES_METHOD + ");",
+                "    }",
+                "",
+                "    @CanIgnoreReturnValue",
+                "    private A injectA(A instance) {",
+                "      A_MembersInjector.injectMethodA(instance);",
+                "      return instance;",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
         .that(
             ImmutableList.of(
@@ -446,10 +579,11 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
                 needsDep1File,
                 dep1File,
                 dep2File))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
-        .generatesSources(componentGeneratedFile);
+        .generatesSources(generatedComponent);
   }
 
   @Test
@@ -576,6 +710,7 @@ public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
 
     assertAbout(javaSources())
         .that(ImmutableList.of(parent, foo, bar, baz, noConflict))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -664,6 +799,7 @@ public void subcomponentSimpleNamesDisambiguated() {
 
     assertAbout(javaSources())
         .that(ImmutableList.of(parent, sub, deepSub))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -746,6 +882,7 @@ public void subcomponentSimpleNamesDisambiguatedInRoot() {
 
     assertAbout(javaSources())
         .that(ImmutableList.of(parent, sub, deepSub))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -839,6 +976,7 @@ public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
 
     assertAbout(javaSources())
         .that(ImmutableList.of(parent, top1, top2))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -908,6 +1046,7 @@ public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubco
 
     assertAbout(javaSources())
         .that(ImmutableList.of(parent, subcomponentWithSameSimpleNameAsParent))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -1012,6 +1151,7 @@ public void subcomponentBuilderNamesShouldNotConflict() {
 
     assertAbout(javaSources())
         .that(ImmutableList.of(parent))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -1064,6 +1204,7 @@ public void duplicateBindingWithSubcomponentDeclaration() {
             "}");
 
     assertThat(module, component, subcomponent)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("test.Sub.Builder is bound multiple times:")
