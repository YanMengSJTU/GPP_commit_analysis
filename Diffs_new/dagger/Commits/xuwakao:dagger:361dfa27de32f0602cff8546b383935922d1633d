diff --git a/java/dagger/internal/codegen/MembersInjectionBinding.java b/java/dagger/internal/codegen/MembersInjectionBinding.java
index 507519966..03228411a 100644
--- a/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -21,12 +21,14 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.DaggerTypes.nonObjectSuperclass;
+import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
@@ -43,6 +45,7 @@
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
@@ -112,13 +115,31 @@ boolean hasLocalInjectionSites() {
     abstract Element element();
 
     abstract ImmutableSet<DependencyRequest> dependencies();
-    
-    static int indexAmongSiblingMembers(InjectionSite injectionSite) {
-      return injectionSite
-          .element()
+
+    int indexAmongSiblingMembers() {
+      return element().getEnclosingElement().getEnclosedElements().indexOf(element());
+    }
+
+    /**
+     * Returns the index of {@link #element()} in its parents {@code @Inject} members that have the
+     * same simple name. This method filters out private elements so that the results will be
+     * consistent independent of whether the build system uses header jars or not.
+     *
+     * <p>This allows {@link MembersInjectorGenerator} to generate unique {@linkplain
+     * MembersInjectorGenerator#injectionSiteDelegateMethodName(InjectionSite)} delegate injection
+     * methods}.
+     */
+    @Memoized
+    int indexAmongAtInjectMembersWithSameSimpleName() {
+      return element()
           .getEnclosingElement()
           .getEnclosedElements()
-          .indexOf(injectionSite.element());
+          .stream()
+          .filter(element -> isAnnotationPresent(element, Inject.class))
+          .filter(element -> !element.getModifiers().contains(Modifier.PRIVATE))
+          .filter(element -> element.getSimpleName().equals(this.element().getSimpleName()))
+          .collect(toList())
+          .indexOf(element());
     }
   }
 
diff --git a/java/dagger/internal/codegen/MembersInjectorGenerator.java b/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 38a98948b..2cac1710d 100644
--- a/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -16,6 +16,8 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
@@ -42,7 +44,6 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
-import com.google.common.base.CaseFormat;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -192,7 +193,6 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     injectorTypeBuilder.addMethod(constructorBuilder.build());
     injectorTypeBuilder.addMethod(createMethodBuilder.build());
 
-    Set<String> delegateMethods = new HashSet<>();
     ImmutableMap<BindingKey, FieldSpec> dependencyFields = dependencyFieldsBuilder.build();
     List<MethodSpec> injectMethodsForSubclasses = new ArrayList<>();
     for (InjectionSite injectionSite : binding.injectionSites()) {
@@ -201,15 +201,10 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
               ? directInjectMemberCodeBlock(binding, dependencyFields, injectionSite)
               : delegateInjectMemberCodeBlock(dependencyFields, injectionSite));
       if (!injectionSite.element().getModifiers().contains(PUBLIC)
-          && injectionSite.element().getEnclosingElement().equals(binding.membersInjectedType())
-          && delegateMethods.add(injectionSiteDelegateMethodName(injectionSite.element()))) {
+          && injectionSite.element().getEnclosingElement().equals(binding.membersInjectedType())) {
         injectMethodsForSubclasses.add(
             injectorMethodForSubclasses(
-                dependencyFields,
-                typeParameters,
-                injectedTypeName,
-                injectionSite.element(),
-                injectionSite.dependencies()));
+                dependencyFields, typeParameters, injectedTypeName, injectionSite));
       }
     }
 
@@ -249,7 +244,7 @@ private CodeBlock delegateInjectMemberCodeBlock(
         "$T.$L($L);",
         membersInjectorNameForType(
             MoreElements.asType(injectionSite.element().getEnclosingElement())),
-        injectionSiteDelegateMethodName(injectionSite.element()),
+        injectionSiteDelegateMethodName(injectionSite),
         makeParametersCodeBlock(
             new ImmutableList.Builder<CodeBlock>()
                 .add(CodeBlock.of("instance"))
@@ -292,26 +287,28 @@ private CodeBlock getInstanceCodeBlockWithPotentialCast(
     return CodeBlock.of("(($T) instance)", injectionSiteName);
   }
 
-  private static String injectionSiteDelegateMethodName(Element injectionSiteElement) {
+  private static String injectionSiteDelegateMethodName(InjectionSite injectionSite) {
+    int index = injectionSite.indexAmongAtInjectMembersWithSameSimpleName();
+    String indexString = index == 0 ? "" : String.valueOf(index + 1);
     return "inject"
-        + CaseFormat.LOWER_CAMEL.to(
-            CaseFormat.UPPER_CAMEL, injectionSiteElement.getSimpleName().toString());
+        + LOWER_CAMEL.to(UPPER_CAMEL, injectionSite.element().getSimpleName().toString())
+        + indexString;
   }
 
   private MethodSpec injectorMethodForSubclasses(
       ImmutableMap<BindingKey, FieldSpec> dependencyFields,
       List<TypeVariableName> typeParameters,
       TypeName injectedTypeName,
-      Element injectionElement,
-      ImmutableSet<DependencyRequest> dependencies) {
+      InjectionSite injectionSite) {
+    Element injectionElement = injectionSite.element();
     MethodSpec.Builder methodBuilder =
-        methodBuilder(injectionSiteDelegateMethodName(injectionElement))
+        methodBuilder(injectionSiteDelegateMethodName(injectionSite))
             .addModifiers(PUBLIC, STATIC)
             .addParameter(injectedTypeName, "instance")
             .addTypeVariables(typeParameters);
     ImmutableList.Builder<CodeBlock> providedParameters = ImmutableList.builder();
     Set<String> parameterNames = new HashSet<>();
-    for (DependencyRequest dependency : dependencies) {
+    for (DependencyRequest dependency : injectionSite.dependencies()) {
       FieldSpec field = dependencyFields.get(dependency.bindingKey());
       ParameterSpec parameter =
           ParameterSpec.builder(
diff --git a/javatests/dagger/functional/membersinject/MembersWithSameName.java b/javatests/dagger/functional/membersinject/MembersWithSameName.java
new file mode 100644
index 000000000..2b0689816
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/MembersWithSameName.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+import javax.inject.Inject;
+
+// https://github.com/google/dagger/issues/755
+public class MembersWithSameName {
+  @Inject String sameName;
+  boolean sameNameStringWasInvoked;
+  boolean sameNameObjectWasInvoked;
+
+  @Inject void sameName(String sameName) {
+    sameNameStringWasInvoked = true;
+  }
+
+  @Inject void sameName(Object sameName) {
+    sameNameObjectWasInvoked = true;
+  }
+}
diff --git a/javatests/dagger/functional/membersinject/MembersWithSameNameTest.java b/javatests/dagger/functional/membersinject/MembersWithSameNameTest.java
new file mode 100644
index 000000000..0f22bf359
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/MembersWithSameNameTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.functional.membersinject.subpackage.ExtendsMembersWithSameName;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+// https://github.com/google/dagger/issues/755
+@RunWith(JUnit4.class)
+public class MembersWithSameNameTest {
+  @Test
+  public void injectsMaskedMembers() {
+    MembersWithSameName membersWithSameName = new MembersWithSameName();
+    TestComponent component = DaggerMembersWithSameNameTest_TestComponent.create();
+    component.inject(membersWithSameName);
+    verifyBaseClassInjection(membersWithSameName);
+  }
+
+  @Test
+  public void subclassInjectsMaskedMembers() {
+    ExtendsMembersWithSameName extendsMembersWithSameName = new ExtendsMembersWithSameName();
+    TestComponent component = DaggerMembersWithSameNameTest_TestComponent.create();
+    component.inject(extendsMembersWithSameName);
+    verifyBaseClassInjection(extendsMembersWithSameName);
+    verifySubclassInjection(extendsMembersWithSameName);
+  }
+
+  private void verifyBaseClassInjection(MembersWithSameName membersWithSameName) {
+    assertThat(membersWithSameName.sameName).isNotNull();
+    assertThat(membersWithSameName.sameNameStringWasInvoked).isTrue();
+    assertThat(membersWithSameName.sameNameObjectWasInvoked).isTrue();
+  }
+
+  private void verifySubclassInjection(ExtendsMembersWithSameName extendsMembersWithSameName) {
+    assertThat(extendsMembersWithSameName.sameName()).isNotNull();
+    assertThat(extendsMembersWithSameName.sameNameStringWasInvoked()).isTrue();
+    assertThat(extendsMembersWithSameName.sameNameObjectWasInvoked()).isTrue();
+  }
+
+  @Module
+  abstract static class TestModule {
+    @Provides
+    static String provideString() {
+      return "";
+    }
+
+    @Binds
+    abstract Object bindObject(String string);
+  }
+
+  @Component(modules = TestModule.class)
+  interface TestComponent {
+    void inject(MembersWithSameName membersWithSameName);
+    void inject(ExtendsMembersWithSameName extendsMembersWithSameName);
+  }
+}
diff --git a/javatests/dagger/functional/membersinject/subpackage/ExtendsMembersWithSameName.java b/javatests/dagger/functional/membersinject/subpackage/ExtendsMembersWithSameName.java
new file mode 100644
index 000000000..1eb1b159a
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/subpackage/ExtendsMembersWithSameName.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject.subpackage;
+
+import dagger.functional.membersinject.MembersWithSameName;
+import javax.inject.Inject;
+
+// https://github.com/google/dagger/issues/755
+public class ExtendsMembersWithSameName extends MembersWithSameName {
+  @Inject String sameName;
+  private boolean sameNameStringWasInvoked;
+  private boolean sameNameObjectWasInvoked;
+
+  @Inject void sameName(String sameName) {
+    sameNameStringWasInvoked = true;
+  }
+
+  @Inject void sameName(Object sameName) {
+    sameNameObjectWasInvoked = true;
+  }
+
+  public String sameName() {
+    return sameName;
+  }
+  public boolean sameNameStringWasInvoked() {
+    return sameNameStringWasInvoked;
+  }
+  public boolean sameNameObjectWasInvoked() {
+    return sameNameObjectWasInvoked;
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MembersInjectionTest.java b/javatests/dagger/internal/codegen/MembersInjectionTest.java
index 35337fce5..f7787758e 100644
--- a/javatests/dagger/internal/codegen/MembersInjectionTest.java
+++ b/javatests/dagger/internal/codegen/MembersInjectionTest.java
@@ -655,6 +655,10 @@ public void mixedMemberInjection() {
         "  public static void injectS(AllInjections instance, Provider<String> sProvider) {",
         "    instance.s = sProvider.get();",
         "  }",
+        "",
+        "  public static void injectS2(AllInjections instance, Provider<String> sProvider) {",
+        "    instance.s(sProvider.get());",
+        "  }",
         "}");
     assertAbout(javaSource())
         .that(file)
