diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index d7e913338..8c84ee32a 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -520,6 +520,18 @@ void claimMethodName(CharSequence name) {
     return modifiableBindingMethodsBuilder.build();
   }
 
+  /**
+   * Returns the names of every modifiable binding method of this implementation and any superclass
+   * implementations.
+   */
+  ImmutableSet<String> getAllModifiableBindingMethodNames() {
+    ImmutableSet.Builder<String> names = ImmutableSet.builder();
+    modifiableBindingMethods.allMethods().forEach(method -> names.add(method.methodSpec().name));
+    superclassImplementation.ifPresent(
+        superclass -> names.addAll(superclass.getAllModifiableBindingMethodNames()));
+    return names.build();
+  }
+
   /**
    * Returns the {@link ModifiableBindingMethod} for this subcomponent for the given binding, if it
    * exists.
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
index ca98509ec..381d7ec09 100644
--- a/java/dagger/internal/codegen/ComponentImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -198,6 +198,14 @@ final ComponentImplementation build() {
 
       getLocalAndInheritedMethods(graph.componentTypeElement(), types, elements)
           .forEach(method -> componentImplementation.claimMethodName(method.getSimpleName()));
+      componentImplementation
+          .superclassImplementation()
+          .ifPresent(
+              superclassImplementation -> {
+                superclassImplementation
+                    .getAllModifiableBindingMethodNames()
+                    .forEach(componentImplementation::claimMethodName);
+              });
 
       addFactoryMethods();
       addInterfaceMethods();
diff --git a/java/dagger/internal/codegen/ModifiableBindingMethods.java b/java/dagger/internal/codegen/ModifiableBindingMethods.java
index 6183ae4d9..e19abb9d6 100644
--- a/java/dagger/internal/codegen/ModifiableBindingMethods.java
+++ b/java/dagger/internal/codegen/ModifiableBindingMethods.java
@@ -70,6 +70,11 @@ void addMethod(
     return Optional.ofNullable(methods.get(request));
   }
 
+  /** Returns all of the {@link ModifiableBindingMethod}s. */
+  ImmutableList<ModifiableBindingMethod> allMethods() {
+    return ImmutableList.copyOf(methods.values());
+  }
+
   /**
    * Mark the {@link ModifiableBindingMethod} as having been implemented, thus modifying the
    * binding.
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index c9e1ab982..2a39f2457 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -6733,6 +6733,153 @@ public void bindsMissingDep_Multibindings() {
         .hasSourceEquivalentTo(generatedLeaf);
   }
 
+  @Test
+  public void modifiableBindingMethods_namesDedupedAcrossImplementations() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "foo.Thing",
+            "package foo;",
+            "", // force multi-line format
+            "public interface Thing extends CharSequence {}"),
+        JavaFileObjects.forSourceLines(
+            "bar.Thing",
+            "package bar;",
+            "", // force multi-line format
+            "public interface Thing extends Runnable {}"),
+        JavaFileObjects.forSourceLines(
+            "test.WillInduceSetOfRunnable",
+            "package test;",
+            "", // force multi-line format
+            "class WillInduceSetOfRunnable {}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Provides",
+            "  static CharSequence depOnFooThing(foo.Thing thing) {",
+            "    return thing.toString();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Runnable depOnBarThing(bar.Thing thing) {",
+            "    return () -> {};",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  CharSequence inducesFoo();",
+            "  WillInduceSetOfRunnable willInduceSetOfRunnable();",
+            "}"));
+
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import foo.Thing;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public CharSequence inducesFoo() {",
+            "    return LeafModule_DepOnFooThingFactory.proxyDepOnFooThing(getThing());",
+            "  }",
+            "",
+            "  protected abstract Thing getThing();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "interface AncestorModule {",
+            "  @Provides",
+            "  static WillInduceSetOfRunnable induce(Set<Runnable> set) {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Multibinds Set<Runnable> runnables();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import bar.Thing;",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    private Runnable getRunnable() {",
+            "      return LeafModule_DepOnBarThingFactory.proxyDepOnBarThing(getThing2());",
+            "    }",
+            "",
+            "    protected abstract Thing getThing2();",
+            "",
+            "    protected Set<Runnable> getSetOfRunnable() {",
+            "      return ImmutableSet.<Runnable>of(getRunnable());",
+            "    }",
+            "",
+            "    @Override",
+            "    public final WillInduceSetOfRunnable willInduceSetOfRunnable() {",
+            "      return AncestorModule_InduceFactory.proxyInduce(getSetOfRunnable());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
     for (String className : ancillaryClasses) {
