diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
index d281c93f8..22c1b4c6e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
@@ -16,16 +16,26 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.Util.requiresAPassedInstance;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
+import com.google.common.collect.ImmutableSet;
+import dagger.Binds;
+import dagger.BindsOptionalOf;
+import dagger.Provides;
+import dagger.multibindings.Multibinds;
+import dagger.producers.Produces;
 import java.util.Optional;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
@@ -88,20 +98,52 @@ NullPolicy nullPolicy(Elements elements, Types types) {
       return overrideNullPolicy().get();
     }
     switch (kind()) {
-      case DEPENDENCY:
-        return NullPolicy.THROW;
       case MODULE:
         return componentCanMakeNewInstances(typeElement())
             ? NullPolicy.NEW
-            : requiresAPassedInstance(elements, types, this)
-                ? NullPolicy.THROW
-                : NullPolicy.ALLOW;
+            : requiresAPassedInstance(elements, types) ? NullPolicy.THROW : NullPolicy.ALLOW;
+      case DEPENDENCY:
       case BINDING:
         return NullPolicy.THROW;
     }
     throw new AssertionError();
   }
 
+  /**
+   * Returns true if the passed {@link ComponentRequirement} requires a passed instance in order
+   * to be used within a component.
+   */
+  boolean requiresAPassedInstance(Elements elements, Types types) {
+    if (kind().equals(ComponentRequirement.Kind.BINDING)) {
+      // A user has explicitly defined in their component builder they will provide an instance.
+      return true;
+    }
+
+    ImmutableSet<ExecutableElement> methods =
+        getLocalAndInheritedMethods(typeElement(), types, elements);
+    boolean foundInstanceMethod = false;
+    for (ExecutableElement method : methods) {
+      if (method.getModifiers().contains(ABSTRACT)
+          && !isAnyAnnotationPresent(
+              method, Binds.class, Multibinds.class, BindsOptionalOf.class)) {
+        // TODO(ronshapiro): it would be cool to have internal meta-annotations that could describe
+        // these, like @AbstractBindingMethod
+        /* We found an abstract method that isn't a binding method. That automatically means that
+         * a user will have to provide an instance because we don't know which subclass to use. */
+        return true;
+      } else if (!method.getModifiers().contains(STATIC)
+          && isAnyAnnotationPresent(method, Provides.class, Produces.class)) {
+        foundInstanceMethod = true;
+      }
+    }
+
+    if (foundInstanceMethod) {
+      return !componentCanMakeNewInstances(typeElement());
+    }
+
+    return false;
+  }
+
   /** The key for this requirement, if one is available. */
   abstract Optional<Key> key();
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index a4101eb90..2c439f24f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -19,7 +19,6 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static dagger.internal.codegen.Util.requiresAPassedInstance;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -191,6 +190,6 @@ protected void addFactoryMethods() {
   private boolean canInstantiateAllRequirements() {
     return !Iterables.any(
         graph.componentRequirements(),
-        dependency -> requiresAPassedInstance(elements, types, dependency));
+        dependency -> dependency.requiresAPassedInstance(elements, types));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 84407a753..60c3df38f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,8 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
-import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static java.util.stream.Collectors.collectingAndThen;
 import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
@@ -25,57 +23,17 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
-import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import dagger.Binds;
-import dagger.Provides;
-import dagger.producers.Produces;
 import java.util.stream.Collector;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * Utilities for handling types in annotation processors
  */
 final class Util {
-  /**
-   * Returns true if the passed {@link ComponentRequirement} requires a passed instance in order
-   * to be used within a component.
-   */
-  static boolean requiresAPassedInstance(
-      Elements elements, Types types, ComponentRequirement componentRequirement) {
-    if (componentRequirement.kind() == ComponentRequirement.Kind.BINDING) {
-      // A user has explicitly defined in their component builder they will provide an instance.
-      return true;
-    }
-
-    TypeElement typeElement = componentRequirement.typeElement();
-    ImmutableSet<ExecutableElement> methods =
-        getLocalAndInheritedMethods(typeElement, types, elements);
-    boolean foundInstanceMethod = false;
-    for (ExecutableElement method : methods) {
-      if (method.getModifiers().contains(ABSTRACT)
-          && !MoreElements.isAnnotationPresent(method, Binds.class)) {
-        /* We found an abstract method that isn't a @Binds method.  That automatically means that
-         * a user will have to provide an instance because we don't know which subclass to use. */
-        return true;
-      } else if (!method.getModifiers().contains(STATIC)
-          && isAnyAnnotationPresent(method, Provides.class, Produces.class)) {
-        foundInstanceMethod = true;
-      }
-    }
-
-    if (foundInstanceMethod) {
-      return !componentCanMakeNewInstances(typeElement);
-    }
-
-    return false;
-  }
-
   /**
    * Returns true if and only if a component can instantiate new instances (typically of a module)
    * rather than requiring that they be passed.
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index e241dcc26..d3ae193b5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -494,12 +494,12 @@ public void testBuilderBindsInstanceNoCreateGenerated() {
             "    }",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
+
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test
