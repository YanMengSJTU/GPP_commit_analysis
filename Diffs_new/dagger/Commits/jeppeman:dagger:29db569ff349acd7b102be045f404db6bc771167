diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index aeec8e2ff..3dd5c1d51 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -199,6 +199,7 @@ java_library(
     srcs = [
         "BindingCycleValidation.java",
         "BindingGraphValidationModule.java",
+        "DependsOnProductionExecutorValidator.java",
         "DuplicateBindingsValidation.java",
         "IncompatiblyScopedBindingsValidation.java",
         "InjectBindingValidation.java",
diff --git a/java/dagger/internal/codegen/BindingGraphValidationModule.java b/java/dagger/internal/codegen/BindingGraphValidationModule.java
index 7fa0d4963..e1137c47c 100644
--- a/java/dagger/internal/codegen/BindingGraphValidationModule.java
+++ b/java/dagger/internal/codegen/BindingGraphValidationModule.java
@@ -30,6 +30,11 @@
   @Validation
   BindingGraphPlugin bindingCycle(BindingCycleValidation validation);
 
+  @Binds
+  @IntoSet
+  @Validation
+  BindingGraphPlugin dependsOnProductionExecutor(DependsOnProductionExecutorValidator validation);
+
   @Binds
   @IntoSet
   @Validation
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index 8dd399103..e6d351752 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -46,11 +46,8 @@
 import dagger.Component;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ComponentRequirement.NullPolicy;
 import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
-import dagger.model.DependencyRequest;
-import dagger.model.Key;
 import dagger.model.Scope;
 import java.util.ArrayDeque;
 import java.util.Deque;
@@ -76,20 +73,17 @@
   private final DaggerTypes types;
   private final CompilerOptions compilerOptions;
   private final MethodSignatureFormatter methodSignatureFormatter;
-  private final KeyFactory keyFactory;
 
   @Inject
   BindingGraphValidator(
       Elements elements,
       DaggerTypes types,
       CompilerOptions compilerOptions,
-      MethodSignatureFormatter methodSignatureFormatter,
-      KeyFactory keyFactory) {
+      MethodSignatureFormatter methodSignatureFormatter) {
     this.elements = elements;
     this.types = types;
     this.compilerOptions = compilerOptions;
     this.methodSignatureFormatter = methodSignatureFormatter;
-    this.keyFactory = keyFactory;
   }
 
   private final class ComponentValidation extends ComponentTreeTraverser {
@@ -102,12 +96,6 @@
       this.rootGraph = rootGraph;
     }
 
-    @Override
-    protected BindingGraphTraverser bindingGraphTraverser(
-        ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
-      return new BindingGraphValidation(componentPath, entryPointMethod);
-    }
-
     /** Returns a report that contains all validation messages found during traversal. */
     ValidationReport<TypeElement> buildReport() {
       ValidationReport.Builder<TypeElement> report =
@@ -450,63 +438,6 @@ private void validateDependencyScopeHierarchy(
       }
       return false;
     }
-
-    final class BindingGraphValidation extends BindingGraphTraverser {
-
-      BindingGraphValidation(
-          ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
-        super(componentPath, entryPointMethod);
-      }
-
-      /** Reports an error for the current component at the entry point. */
-      private void reportErrorAtEntryPoint(String format, Object... args) {
-        reportErrorAtEntryPoint(currentGraph(), format, args);
-      }
-
-      /** Reports an error for the given component at the entry point. */
-      private void reportErrorAtEntryPoint(BindingGraph graph, String format, Object... args) {
-        String message = args.length == 0 ? format : String.format(format, args);
-        report(graph).addError(message, entryPointElement());
-      }
-
-      @Override
-      protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
-        if (!atDependencyCycle()) {
-          super.visitDependencyRequest(dependencyRequest);
-        }
-      }
-
-      @Override
-      protected void visitContributionBinding(
-          ContributionBinding binding, ComponentDescriptor owningComponent) {
-        if (compilerOptions.usesProducers()) {
-          // TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
-          // Only the Dagger-specific binding may depend on the production executor.
-          Key productionImplementationExecutorKey =
-              keyFactory.forProductionImplementationExecutor();
-          if (!binding.key().equals(productionImplementationExecutorKey)) {
-            Key productionExecutorKey = keyFactory.forProductionExecutor();
-            for (DependencyRequest request : binding.explicitDependencies()) {
-              if (request.key().equals(productionExecutorKey)
-                  || request.key().equals(productionImplementationExecutorKey)) {
-                reportDependsOnProductionExecutor();
-              }
-            }
-          }
-        }
-        super.visitContributionBinding(binding, owningComponent);
-      }
-
-      @SuppressWarnings("resource") // Appendable is a StringBuilder.
-      private void reportDependsOnProductionExecutor() {
-        reportErrorAtEntryPoint(
-            "%s may not depend on the production executor", formatCurrentDependencyRequestKey());
-      }
-
-      private String formatCurrentDependencyRequestKey() {
-        return dependencyRequest().key().toString();
-      }
-    }
   }
 
   ValidationReport<TypeElement> validate(BindingGraph graph) {
diff --git a/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
new file mode 100644
index 000000000..01aed7f75
--- /dev/null
+++ b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.Key;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import javax.inject.Inject;
+
+/**
+ * Reports an error on all bindings that depend explicitly on the {@code @Production Executor} key.
+ */
+// TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
+final class DependsOnProductionExecutorValidator implements BindingGraphPlugin {
+  private final CompilerOptions compilerOptions;
+  private final KeyFactory keyFactory;
+
+  @Inject
+  DependsOnProductionExecutorValidator(CompilerOptions compilerOptions, KeyFactory keyFactory) {
+    this.compilerOptions = compilerOptions;
+    this.keyFactory = keyFactory;
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/DependsOnProductionExecutor";
+  }
+
+  @Override
+  public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    if (!compilerOptions.usesProducers()) {
+      return;
+    }
+
+    Key productionImplementationExecutorKey = keyFactory.forProductionImplementationExecutor();
+    Key productionExecutorKey = keyFactory.forProductionExecutor();
+
+    bindingGraph
+        .bindingNodes(productionExecutorKey)
+        .stream()
+        .flatMap(
+            productionExecutorBinding ->
+                bindingGraph.predecessors(productionExecutorBinding).stream())
+        .flatMap(instancesOf(BindingNode.class))
+        .filter(binding -> !binding.binding().key().equals(productionImplementationExecutorKey))
+        .forEach(binding -> reportError(diagnosticReporter, binding));
+  }
+
+  private void reportError(DiagnosticReporter diagnosticReporter, BindingNode bindingNode) {
+    diagnosticReporter.reportBinding(
+        ERROR,
+        bindingNode,
+        "%s may not depend on the production executor",
+        bindingNode.binding().key());
+  }
+}
