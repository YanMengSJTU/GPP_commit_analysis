diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index 7c0525798..4ea1bb888 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -57,8 +57,11 @@
   /**
    * Creates the external {@link dagger.model.BindingGraph} representing the given internal {@link
    * dagger.internal.codegen.BindingGraph}.
+   *
+   * @param fullBindingGraph if {@code true}, include bindings that are not reachable from any entry
+   *     points
    */
-  dagger.model.BindingGraph convert(BindingGraph bindingGraph) {
+  dagger.model.BindingGraph convert(BindingGraph bindingGraph, boolean fullBindingGraph) {
     Traverser traverser = new Traverser(bindingGraph);
     traverser.traverseComponents();
 
@@ -66,15 +69,13 @@
     // multibindings or optional bindings, the parent-owned binding is still there. If that
     // parent-owned binding is not reachable from its component, it doesn't need to be in the graph
     // because it will never be used. So remove all nodes that are not reachable from the root
-    // component—unless the component is a module-binding validation component.
-    if (!bindingGraph.componentDescriptor().kind().isForModuleValidation()) {
+    // component—unless we're building a full binding graph.
+    if (!fullBindingGraph) {
       unreachableNodes(traverser.network.asGraph(), rootComponentNode(traverser.network))
           .forEach(traverser.network::removeNode);
     }
 
-    ComponentKind componentKind = bindingGraph.componentDescriptor().kind();
-    return BindingGraphProxies.bindingGraph(
-        traverser.network, componentKind.isForModuleValidation());
+    return BindingGraphProxies.bindingGraph(traverser.network, fullBindingGraph);
   }
 
   // TODO(dpb): Example of BindingGraph logic applied to derived networks.
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index ad25a6166..bf8eb3a26 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -150,7 +150,7 @@ protected void process(
   }
 
   private boolean isValid(BindingGraph bindingGraph) {
-    dagger.model.BindingGraph modelGraph = bindingGraphConverter.convert(bindingGraph);
+    dagger.model.BindingGraph modelGraph = bindingGraphConverter.convert(bindingGraph, false);
     return bindingGraphValidator.isValid(modelGraph);
   }
 
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index b3ac78c41..1dca8596e 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -590,7 +590,7 @@ private void validateModuleBindings(
       TypeElement module, ValidationReport.Builder<TypeElement> report) {
     BindingGraph bindingGraph =
         bindingGraphConverter.convert(
-            bindingGraphFactory.create(componentDescriptorFactory.forTypeElement(module)));
+            bindingGraphFactory.create(componentDescriptorFactory.forTypeElement(module)), true);
     if (!bindingGraphValidator.isValid(bindingGraph)) {
       // Since the validator uses a DiagnosticReporter to report errors, the ValdiationReport won't
       // have any Items for them. We have to tell the ValidationReport that some errors were
