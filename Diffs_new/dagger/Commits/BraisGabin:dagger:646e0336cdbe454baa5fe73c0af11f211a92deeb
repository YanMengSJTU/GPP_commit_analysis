diff --git a/BUILD b/BUILD
index 8f830e1a5..74c0ab750 100644
--- a/BUILD
+++ b/BUILD
@@ -63,6 +63,7 @@ jarjar_library(
         "//java/dagger/internal/codegen/compileroption",
         "//java/dagger/internal/codegen/extension",
         "//java/dagger/internal/codegen/javapoet",
+        "//java/dagger/internal/codegen/kotlin",
         "//java/dagger/internal/codegen/langmodel",
         "//java/dagger/internal/codegen/statistics",
         "//java/dagger/internal/codegen/validation",
@@ -84,6 +85,7 @@ jarjar_library(
         "//java/dagger/internal/codegen/compileroption:libcompileroption-src.jar",
         "//java/dagger/internal/codegen/extension:libextension-src.jar",
         "//java/dagger/internal/codegen/javapoet:libjavapoet-src.jar",
+        "//java/dagger/internal/codegen/kotlin:libkotlin-src.jar",
         "//java/dagger/internal/codegen/langmodel:liblangmodel-src.jar",
         "//java/dagger/internal/codegen/statistics:libstatistics-src.jar",
         "//java/dagger/internal/codegen/validation:libvalidation-src.jar",
diff --git a/WORKSPACE b/WORKSPACE
index dfc56b562..c694797a8 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -32,3 +32,26 @@ bind(
     name = "zlib",
     actual = "@bazel_tools//third_party/zlib",
 )
+
+RULES_JVM_EXTERNAL_TAG = "2.7"
+
+RULES_JVM_EXTERNAL_SHA = "f04b1466a00a2845106801e0c5cec96841f49ea4e7d1df88dc8e4bf31523df74"
+
+http_archive(
+    name = "rules_jvm_external",
+    sha256 = RULES_JVM_EXTERNAL_SHA,
+    strip_prefix = "rules_jvm_external-%s" % RULES_JVM_EXTERNAL_TAG,
+    url = "https://github.com/bazelbuild/rules_jvm_external/archive/%s.zip" % RULES_JVM_EXTERNAL_TAG,
+)
+
+load("@rules_jvm_external//:defs.bzl", "maven_install")
+
+maven_install(
+    artifacts = [
+        "org.jetbrains.kotlin:kotlin-stdlib:1.3.50",
+        "org.jetbrains.kotlinx:kotlinx-metadata-jvm:0.1.0",
+    ],
+    repositories = [
+        "https://repo1.maven.org/maven2",
+    ],
+)
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 41f89b5ac..cba5bb973 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -27,6 +27,7 @@ DAGGER_DEPS = [
     "//java/dagger/internal/codegen/compileroption",
     "//java/dagger/internal/codegen/extension",
     "//java/dagger/internal/codegen/javapoet",
+    "//java/dagger/internal/codegen/kotlin",
     "//java/dagger/internal/codegen/langmodel",
     "//java/dagger/internal/codegen/statistics",
     "//java/dagger/internal/codegen/validation",
diff --git a/java/dagger/internal/codegen/ProcessingRoundCacheModule.java b/java/dagger/internal/codegen/ProcessingRoundCacheModule.java
index 5efa02f72..35b3baa33 100644
--- a/java/dagger/internal/codegen/ProcessingRoundCacheModule.java
+++ b/java/dagger/internal/codegen/ProcessingRoundCacheModule.java
@@ -21,6 +21,7 @@
 import dagger.internal.codegen.base.ClearableCache;
 import dagger.internal.codegen.binding.BindingGraphFactory;
 import dagger.internal.codegen.binding.ModuleDescriptor;
+import dagger.internal.codegen.kotlin.KotlinMetadataFactory;
 import dagger.multibindings.IntoSet;
 
 /**
@@ -40,4 +41,8 @@
   @Binds
   @IntoSet
   ClearableCache componentImplementationFactory(ComponentImplementationFactory cache);
+
+  @Binds
+  @IntoSet
+  ClearableCache kotlinMetadata(KotlinMetadataFactory cache);
 }
diff --git a/java/dagger/internal/codegen/binding/BUILD b/java/dagger/internal/codegen/binding/BUILD
index 7dd453f54..3b7f91409 100644
--- a/java/dagger/internal/codegen/binding/BUILD
+++ b/java/dagger/internal/codegen/binding/BUILD
@@ -28,6 +28,7 @@ java_library(
         "//java/dagger/internal/codegen/compileroption",
         "//java/dagger/internal/codegen/extension",
         "//java/dagger/internal/codegen/javapoet",
+        "//java/dagger/internal/codegen/kotlin",
         "//java/dagger/internal/codegen/langmodel",
         "//java/dagger/model",
         "//java/dagger/model:internal-proxies",
diff --git a/java/dagger/internal/codegen/binding/BindingFactory.java b/java/dagger/internal/codegen/binding/BindingFactory.java
index f934b6acb..e5a3d626f 100644
--- a/java/dagger/internal/codegen/binding/BindingFactory.java
+++ b/java/dagger/internal/codegen/binding/BindingFactory.java
@@ -22,7 +22,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.base.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.base.MoreAnnotationMirrors.wrapOptionalInEquivalence;
 import static dagger.internal.codegen.base.Scopes.uniqueScopeOf;
 import static dagger.internal.codegen.binding.Binding.hasNonDefaultTypeParameters;
@@ -83,6 +82,7 @@
   private final DependencyRequestFactory dependencyRequestFactory;
   private final InjectionSiteFactory injectionSiteFactory;
   private final DaggerElements elements;
+  private final InjectionAnnotations injectionAnnotations;
 
   @Inject
   BindingFactory(
@@ -90,12 +90,14 @@
       DaggerElements elements,
       KeyFactory keyFactory,
       DependencyRequestFactory dependencyRequestFactory,
-      InjectionSiteFactory injectionSiteFactory) {
+      InjectionSiteFactory injectionSiteFactory,
+      InjectionAnnotations injectionAnnotations) {
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.dependencyRequestFactory = dependencyRequestFactory;
     this.injectionSiteFactory = injectionSiteFactory;
+    this.injectionAnnotations = injectionAnnotations;
   }
 
   /**
@@ -110,7 +112,7 @@ public ProvisionBinding injectionBinding(
       ExecutableElement constructorElement, Optional<TypeMirror> resolvedType) {
     checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
     checkArgument(isAnnotationPresent(constructorElement, Inject.class));
-    checkArgument(!getQualifier(constructorElement).isPresent());
+    checkArgument(!injectionAnnotations.getQualifier(constructorElement).isPresent());
 
     ExecutableType constructorType = MoreTypes.asExecutable(constructorElement.asType());
     DeclaredType constructedType =
diff --git a/java/dagger/internal/codegen/binding/ComponentDescriptorFactory.java b/java/dagger/internal/codegen/binding/ComponentDescriptorFactory.java
index 4f1954d5d..f13aa50c0 100644
--- a/java/dagger/internal/codegen/binding/ComponentDescriptorFactory.java
+++ b/java/dagger/internal/codegen/binding/ComponentDescriptorFactory.java
@@ -21,7 +21,6 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.base.ComponentAnnotation.subcomponentAnnotation;
-import static dagger.internal.codegen.base.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.base.Scopes.productionScope;
 import static dagger.internal.codegen.base.Scopes.scopesOf;
 import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.creatorAnnotationsFor;
@@ -58,17 +57,20 @@
   private final DaggerTypes types;
   private final DependencyRequestFactory dependencyRequestFactory;
   private final ModuleDescriptor.Factory moduleDescriptorFactory;
+  private final InjectionAnnotations injectionAnnotations;
 
   @Inject
   ComponentDescriptorFactory(
       DaggerElements elements,
       DaggerTypes types,
       DependencyRequestFactory dependencyRequestFactory,
-      ModuleDescriptor.Factory moduleDescriptorFactory) {
+      ModuleDescriptor.Factory moduleDescriptorFactory,
+      InjectionAnnotations injectionAnnotations) {
     this.elements = elements;
     this.types = types;
     this.dependencyRequestFactory = dependencyRequestFactory;
     this.moduleDescriptorFactory = moduleDescriptorFactory;
+    this.injectionAnnotations = injectionAnnotations;
   }
 
   /** Returns a descriptor for a root component type. */
@@ -221,7 +223,8 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
         MoreTypes.asExecutable(
             types.asMemberOf(MoreTypes.asDeclared(componentElement.asType()), componentMethod));
     TypeMirror returnType = resolvedComponentMethod.getReturnType();
-    if (returnType.getKind().equals(DECLARED) && !getQualifier(componentMethod).isPresent()) {
+    if (returnType.getKind().equals(DECLARED)
+        && !injectionAnnotations.getQualifier(componentMethod).isPresent()) {
       TypeElement returnTypeElement = asTypeElement(returnType);
       if (subcomponentAnnotation(returnTypeElement).isPresent()) {
         // It's a subcomponent factory method. There is no dependency request, and there could be
diff --git a/java/dagger/internal/codegen/binding/DependencyRequestFactory.java b/java/dagger/internal/codegen/binding/DependencyRequestFactory.java
index 3c3228c7e..43eb1d726 100644
--- a/java/dagger/internal/codegen/binding/DependencyRequestFactory.java
+++ b/java/dagger/internal/codegen/binding/DependencyRequestFactory.java
@@ -34,7 +34,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Lazy;
-import dagger.internal.codegen.base.InjectionAnnotations;
 import dagger.internal.codegen.base.MapType;
 import dagger.internal.codegen.base.OptionalType;
 import dagger.internal.codegen.langmodel.DaggerTypes;
@@ -62,11 +61,14 @@
 public final class DependencyRequestFactory {
   private final KeyFactory keyFactory;
   private final DaggerTypes types;
+  private final InjectionAnnotations injectionAnnotations;
 
   @Inject
-  DependencyRequestFactory(KeyFactory keyFactory, DaggerTypes types) {
+  DependencyRequestFactory(
+      KeyFactory keyFactory, DaggerTypes types, InjectionAnnotations injectionAnnotations) {
     this.keyFactory = keyFactory;
     this.types = types;
+    this.injectionAnnotations = injectionAnnotations;
   }
 
   ImmutableSet<DependencyRequest> forRequiredResolvedVariables(
@@ -134,7 +136,7 @@ DependencyRequest forRequiredResolvedVariable(
       VariableElement variableElement, TypeMirror resolvedType) {
     checkNotNull(variableElement);
     checkNotNull(resolvedType);
-    Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
+    Optional<AnnotationMirror> qualifier = injectionAnnotations.getQualifier(variableElement);
     return newDependencyRequest(variableElement, resolvedType, qualifier);
   }
 
@@ -146,7 +148,7 @@ public DependencyRequest forComponentProvisionMethod(
         provisionMethod.getParameters().isEmpty(),
         "Component provision methods must be empty: %s",
         provisionMethod);
-    Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
+    Optional<AnnotationMirror> qualifier = injectionAnnotations.getQualifier(provisionMethod);
     return newDependencyRequest(provisionMethod, provisionMethodType.getReturnType(), qualifier);
   }
 
@@ -159,7 +161,7 @@ public DependencyRequest forComponentProductionMethod(
         "Component production methods must be empty: %s",
         productionMethod);
     TypeMirror type = productionMethodType.getReturnType();
-    Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(productionMethod);
+    Optional<AnnotationMirror> qualifier = injectionAnnotations.getQualifier(productionMethod);
     // Only a component production method can be a request for a ListenableFuture, so we
     // special-case it here.
     if (isTypeOf(ListenableFuture.class, type)) {
@@ -178,7 +180,7 @@ DependencyRequest forComponentMembersInjectionMethod(
     checkNotNull(membersInjectionMethod);
     checkNotNull(membersInjectionMethodType);
     Optional<AnnotationMirror> qualifier =
-        InjectionAnnotations.getQualifier(membersInjectionMethod);
+        injectionAnnotations.getQualifier(membersInjectionMethod);
     checkArgument(!qualifier.isPresent());
     TypeMirror membersInjectedType = getOnlyElement(membersInjectionMethodType.getParameterTypes());
     return DependencyRequest.builder()
diff --git a/java/dagger/internal/codegen/base/InjectionAnnotations.java b/java/dagger/internal/codegen/binding/InjectionAnnotations.java
similarity index 66%
rename from java/dagger/internal/codegen/base/InjectionAnnotations.java
rename to java/dagger/internal/codegen/binding/InjectionAnnotations.java
index 96a889b7a..57f5319e6 100644
--- a/java/dagger/internal/codegen/base/InjectionAnnotations.java
+++ b/java/dagger/internal/codegen/binding/InjectionAnnotations.java
@@ -14,29 +14,38 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen.base;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static javax.lang.model.util.ElementFilter.constructorsIn;
 
 import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.SuperficialValidation;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import java.util.Optional;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 
-/**
- * Utilities relating to annotations defined in the {@code javax.inject} package.
- */
+/** Utilities relating to annotations defined in the {@code javax.inject} package. */
 public final class InjectionAnnotations {
-  public static Optional<AnnotationMirror> getQualifier(Element e) {
+  private final KotlinMetadataUtil kotlinMetadataUtil;
+
+  @Inject
+  InjectionAnnotations(KotlinMetadataUtil kotlinMetadataUtil) {
+    this.kotlinMetadataUtil = kotlinMetadataUtil;
+  }
+
+  public Optional<AnnotationMirror> getQualifier(Element e) {
     if (!SuperficialValidation.validateElement(e)) {
       throw new TypeNotPresentException(e.toString(), null);
     }
@@ -53,8 +62,18 @@
     }
   }
 
-  public static ImmutableSet<? extends AnnotationMirror> getQualifiers(Element element) {
-    return AnnotationMirrors.getAnnotatedAnnotations(element, Qualifier.class);
+  public ImmutableSet<? extends AnnotationMirror> getQualifiers(Element element) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers =
+        AnnotationMirrors.getAnnotatedAnnotations(element, Qualifier.class);
+    if (kotlinMetadataUtil.hasMetadata(element) && element.getKind() == ElementKind.FIELD) {
+      return Sets.union(
+              qualifiers,
+              kotlinMetadataUtil.getSyntheticPropertyAnnotations(
+                  MoreElements.asVariable(element), Qualifier.class))
+          .immutableCopy();
+    } else {
+      return qualifiers;
+    }
   }
 
   /** Returns the constructors in {@code type} that are annotated with {@link Inject}. */
@@ -63,6 +82,4 @@
         .filter(constructor -> isAnnotationPresent(constructor, Inject.class))
         .toSet();
   }
-
-  private InjectionAnnotations() {}
 }
diff --git a/java/dagger/internal/codegen/binding/KeyFactory.java b/java/dagger/internal/codegen/binding/KeyFactory.java
index 1f1734114..9ba1a21a4 100644
--- a/java/dagger/internal/codegen/binding/KeyFactory.java
+++ b/java/dagger/internal/codegen/binding/KeyFactory.java
@@ -22,7 +22,6 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.base.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.base.RequestKinds.extractKeyType;
 import static dagger.internal.codegen.base.RequestKinds.getRequestKind;
 import static dagger.internal.codegen.binding.MapKeys.getMapKey;
@@ -74,12 +73,14 @@
 public final class KeyFactory {
   private final DaggerTypes types;
   private final DaggerElements elements;
+  private final InjectionAnnotations injectionAnnotations;
 
-  // TODO(user): Make this pkg-private. This is used by KeyFactoryTest.
   @Inject
-  public KeyFactory(DaggerTypes types, DaggerElements elements) {
+  KeyFactory(
+      DaggerTypes types, DaggerElements elements, InjectionAnnotations injectionAnnotations) {
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
+    this.injectionAnnotations = injectionAnnotations;
   }
 
   private TypeMirror boxPrimitives(TypeMirror type) {
@@ -241,7 +242,7 @@ Key forDelegateBinding(DelegateDeclaration delegateDeclaration, Class<?> framewo
   }
 
   private Key forMethod(ExecutableElement method, TypeMirror keyType) {
-    return forQualifiedType(getQualifier(method), keyType);
+    return forQualifiedType(injectionAnnotations.getQualifier(method), keyType);
   }
 
   public Key forInjectConstructorWithResolvedType(TypeMirror type) {
diff --git a/java/dagger/internal/codegen/binding/MethodSignatureFormatter.java b/java/dagger/internal/codegen/binding/MethodSignatureFormatter.java
index afa259544..f00c67b83 100644
--- a/java/dagger/internal/codegen/binding/MethodSignatureFormatter.java
+++ b/java/dagger/internal/codegen/binding/MethodSignatureFormatter.java
@@ -18,7 +18,6 @@
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.base.DiagnosticFormatting.stripCommonTypePrefixes;
-import static dagger.internal.codegen.base.InjectionAnnotations.getQualifier;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -39,10 +38,12 @@
 /** Formats the signature of an {@link ExecutableElement} suitable for use in error messages. */
 public final class MethodSignatureFormatter extends Formatter<ExecutableElement> {
   private final DaggerTypes types;
+  private final InjectionAnnotations injectionAnnotations;
 
   @Inject
-  public MethodSignatureFormatter(DaggerTypes types) {
+  public MethodSignatureFormatter(DaggerTypes types, InjectionAnnotations injectionAnnotations) {
     this.types = types;
+    this.injectionAnnotations = injectionAnnotations;
   }
 
   /**
@@ -119,9 +120,9 @@ private String format(
     return builder.toString();
   }
 
-  private static void appendParameter(StringBuilder builder, VariableElement parameter,
-      TypeMirror type) {
-    getQualifier(parameter)
+  private void appendParameter(StringBuilder builder, VariableElement parameter, TypeMirror type) {
+    injectionAnnotations
+        .getQualifier(parameter)
         .ifPresent(
             qualifier -> {
               builder.append(formatAnnotation(qualifier)).append(' ');
diff --git a/java/dagger/internal/codegen/kotlin/BUILD b/java/dagger/internal/codegen/kotlin/BUILD
new file mode 100644
index 000000000..3f56526e3
--- /dev/null
+++ b/java/dagger/internal/codegen/kotlin/BUILD
@@ -0,0 +1,34 @@
+# Copyright (C) 2019 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Sources related to Kotlin metadata.
+
+package(default_visibility = ["//:src"])
+
+java_library(
+    name = "kotlin",
+    srcs = glob(["*.java"]),
+    plugins = ["//java/dagger/internal/codegen/bootstrap"],
+    tags = ["maven:merged"],
+    deps = [
+        "//java/dagger/internal/codegen/base",
+        "//java/dagger/internal/codegen/langmodel",
+        "@google_bazel_common//third_party/java/auto:common",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/jsr330_inject",
+        "@maven//:org_jetbrains_kotlin_kotlin_stdlib",
+        "@maven//:org_jetbrains_kotlinx_kotlinx_metadata_jvm",
+    ],
+)
diff --git a/java/dagger/internal/codegen/kotlin/KotlinMetadata.java b/java/dagger/internal/codegen/kotlin/KotlinMetadata.java
new file mode 100644
index 000000000..fa86e59d7
--- /dev/null
+++ b/java/dagger/internal/codegen/kotlin/KotlinMetadata.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen.kotlin;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+
+import com.google.common.base.Supplier;
+import com.google.common.base.Suppliers;
+import dagger.internal.codegen.langmodel.DaggerElements;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import javax.inject.Inject;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.ElementFilter;
+import kotlinx.metadata.KmClass;
+import kotlinx.metadata.KmProperty;
+import kotlinx.metadata.jvm.JvmExtensionsKt;
+import kotlinx.metadata.jvm.JvmFieldSignature;
+import kotlinx.metadata.jvm.JvmMethodSignature;
+
+/** Data class of a TypeElement and its Kotlin metadata. */
+final class KotlinMetadata {
+
+  private final TypeElement typeElement;
+  private final KmClass kmClass;
+
+  // Map that associates @Inject field elements with its Kotlin synthetic method for annotations.
+  private final Supplier<Map<VariableElement, Optional<ExecutableElement>>>
+      elementFieldAnnotationMethodMap;
+
+  KotlinMetadata(TypeElement typeElement, KmClass kmClass) {
+    this.typeElement = typeElement;
+    this.kmClass = kmClass;
+    this.elementFieldAnnotationMethodMap =
+        Suppliers.memoize(
+            () -> {
+              Map<String, KmProperty> propertyDescriptors = new HashMap<>();
+              kmClass
+                  .getProperties()
+                  .forEach(
+                      property -> {
+                        JvmFieldSignature signature = JvmExtensionsKt.getFieldSignature(property);
+                        if (signature != null) {
+                          propertyDescriptors.put(signature.asString(), property);
+                        }
+                      });
+              Map<String, ExecutableElement> methodDescriptors =
+                  ElementFilter.methodsIn(typeElement.getEnclosedElements()).stream()
+                      .collect(
+                          Collectors.toMap(DaggerElements::getMethodDescriptor, method -> method));
+              return ElementFilter.fieldsIn(typeElement.getEnclosedElements()).stream()
+                  .filter(field -> isAnnotationPresent(field, Inject.class))
+                  .collect(
+                      Collectors.toMap(
+                          Function.identity(),
+                          field ->
+                              Optional.ofNullable(
+                                      propertyDescriptors.get(
+                                          DaggerElements.getFieldDescriptor(field)))
+                                  .map(JvmExtensionsKt::getSyntheticMethodForAnnotations)
+                                  .map(JvmMethodSignature::asString)
+                                  .map(methodDescriptors::get)));
+            });
+  }
+
+  TypeElement getTypeElement() {
+    return typeElement;
+  }
+
+  KmClass getKmClass() {
+    return kmClass;
+  }
+
+  /** Gets the synthetic method for annotations of a given @Inject annotated field element. */
+  Optional<ExecutableElement> getSyntheticAnnotationMethod(VariableElement fieldElement) {
+    checkArgument(elementFieldAnnotationMethodMap.get().containsKey(fieldElement));
+    return elementFieldAnnotationMethodMap.get().get(fieldElement);
+  }
+}
diff --git a/java/dagger/internal/codegen/kotlin/KotlinMetadataFactory.java b/java/dagger/internal/codegen/kotlin/KotlinMetadataFactory.java
new file mode 100644
index 000000000..387cfa374
--- /dev/null
+++ b/java/dagger/internal/codegen/kotlin/KotlinMetadataFactory.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen.kotlin;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static dagger.internal.codegen.base.MoreAnnotationValues.asAnnotationValues;
+import static dagger.internal.codegen.langmodel.DaggerElements.closestEnclosingTypeElement;
+import static dagger.internal.codegen.langmodel.DaggerElements.getAnnotationMirror;
+
+import dagger.internal.codegen.base.ClearableCache;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import kotlin.Metadata;
+import kotlinx.metadata.KmClass;
+import kotlinx.metadata.jvm.KotlinClassHeader;
+import kotlinx.metadata.jvm.KotlinClassMetadata;
+
+/**
+ * Factory for parsing and creating Kotlin metadata data object.
+ *
+ * <p>The metadata is cache since it can be expensive to parse the information stored in a proto
+ * binary string format in the metadata annotation values.
+ */
+@Singleton
+public final class KotlinMetadataFactory implements ClearableCache {
+  private final Map<TypeElement, Optional<KotlinMetadata>> metadataCache = new HashMap<>();
+
+  @Inject
+  KotlinMetadataFactory() {}
+
+  public Optional<KotlinMetadata> create(Element element) {
+    TypeElement enclosingElement = closestEnclosingTypeElement(element);
+    return metadataCache.computeIfAbsent(
+        enclosingElement,
+        typeElement ->
+            kmClassOf(typeElement)
+                .map(classMetadata -> new KotlinMetadata(typeElement, classMetadata)));
+  }
+
+  private static Optional<KmClass> kmClassOf(TypeElement typeElement) {
+    Optional<AnnotationMirror> metadataAnnotation =
+        getAnnotationMirror(typeElement, Metadata.class);
+    if (!metadataAnnotation.isPresent()) {
+      return Optional.empty();
+    }
+    KotlinClassHeader header =
+        new KotlinClassHeader(
+            getIntValue(metadataAnnotation.get(), "k"),
+            getIntArrayValue(metadataAnnotation.get(), "mv"),
+            getIntArrayValue(metadataAnnotation.get(), "bv"),
+            getStringArrayValue(metadataAnnotation.get(), "d1"),
+            getStringArrayValue(metadataAnnotation.get(), "d2"),
+            getStringValue(metadataAnnotation.get(), "xs"),
+            getStringValue(metadataAnnotation.get(), "pn"),
+            getIntValue(metadataAnnotation.get(), "xi"));
+    KotlinClassMetadata metadata = KotlinClassMetadata.read(header);
+    if (metadata == null) {
+      // Should only happen on Kotlin < 1.0 (i.e. metadata version < 1.1)
+      return Optional.empty();
+    }
+    if (metadata instanceof KotlinClassMetadata.Class) {
+      // TODO(user): If when we need other types of metadata then move to right method.
+      return Optional.of(((KotlinClassMetadata.Class) metadata).toKmClass());
+    } else {
+      // Unsupported
+      return Optional.empty();
+    }
+  }
+
+  private static int getIntValue(AnnotationMirror annotation, String valueName) {
+    return (int) getAnnotationValue(annotation, valueName).getValue();
+  }
+
+  private static String getStringValue(AnnotationMirror annotation, String valueName) {
+    return getAnnotationValue(annotation, valueName).getValue().toString();
+  }
+
+  private static int[] getIntArrayValue(AnnotationMirror annotation, String valueName) {
+    return asAnnotationValues(getAnnotationValue(annotation, valueName)).stream()
+        .mapToInt(it -> (int) it.getValue())
+        .toArray();
+  }
+
+  private static String[] getStringArrayValue(AnnotationMirror annotation, String valueName) {
+    return asAnnotationValues(getAnnotationValue(annotation, valueName)).stream()
+        .map(it -> it.getValue().toString())
+        .toArray(String[]::new);
+  }
+
+  @Override
+  public void clearCache() {
+    metadataCache.clear();
+  }
+}
diff --git a/java/dagger/internal/codegen/kotlin/KotlinMetadataUtil.java b/java/dagger/internal/codegen/kotlin/KotlinMetadataUtil.java
new file mode 100644
index 000000000..f66ded4a6
--- /dev/null
+++ b/java/dagger/internal/codegen/kotlin/KotlinMetadataUtil.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen.kotlin;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static dagger.internal.codegen.langmodel.DaggerElements.closestEnclosingTypeElement;
+
+import com.google.common.collect.ImmutableSet;
+import java.lang.annotation.Annotation;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.VariableElement;
+import kotlin.Metadata;
+
+/** Utility class for interacting with Kotlin Metadata. */
+public final class KotlinMetadataUtil {
+
+  private final KotlinMetadataFactory metadataFactory;
+
+  @Inject
+  KotlinMetadataUtil(KotlinMetadataFactory metadataFactory) {
+    this.metadataFactory = metadataFactory;
+  }
+
+  /**
+   * Returns true if this element has the Kotlin Metadata annotation or if it is enclosed in an
+   * element that does.
+   */
+  public boolean hasMetadata(Element element) {
+    return isAnnotationPresent(closestEnclosingTypeElement(element), Metadata.class);
+  }
+
+  /**
+   * Returns the synthetic annotations of a Kotlin property.
+   *
+   * <p>Note that this method only looks for additional annotations in the synthetic property
+   * method, if any, of a Kotlin property and not for annotations in its backing field.
+   */
+  public ImmutableSet<? extends AnnotationMirror> getSyntheticPropertyAnnotations(
+      VariableElement fieldElement, Class<? extends Annotation> annotationType) {
+    return metadataFactory
+        .create(fieldElement)
+        .flatMap(metadata -> metadata.getSyntheticAnnotationMethod(fieldElement))
+        .map(methodElement -> getAnnotatedAnnotations(methodElement, annotationType))
+        .orElse(ImmutableSet.of());
+  }
+}
diff --git a/java/dagger/internal/codegen/langmodel/DaggerElements.java b/java/dagger/internal/codegen/langmodel/DaggerElements.java
index 873ad3d1d..d40a4877f 100644
--- a/java/dagger/internal/codegen/langmodel/DaggerElements.java
+++ b/java/dagger/internal/codegen/langmodel/DaggerElements.java
@@ -42,6 +42,7 @@
 import java.util.Optional;
 import java.util.Set;
 import java.util.function.Predicate;
+import java.util.stream.Collectors;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
@@ -51,8 +52,22 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.QualifiedNameable;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ErrorType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.IntersectionType;
+import javax.lang.model.type.NoType;
+import javax.lang.model.type.NullType;
+import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.type.UnionType;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.AbstractTypeVisitor8;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleElementVisitor8;
 import javax.lang.model.util.Types;
@@ -230,6 +245,159 @@ public static boolean isAnnotationPresent(Element element, TypeMirror annotation
     return ImmutableSet.copyOf(suppressedWarnings.value());
   }
 
+  /**
+   * Returns the field descriptor of the given {@code element}.
+   *
+   * <p>This is useful for matching Kotlin Metadata JVM Signatures with elements from the AST.
+   *
+   * <p>For reference, see the <a
+   * href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2">JVM
+   * specification, section 4.3.2</a>.
+   */
+  public static String getFieldDescriptor(VariableElement element) {
+    return element.getSimpleName() + ":" + getDescriptor(element.asType());
+  }
+
+  /**
+   * Returns the method descriptor of the given {@code element}.
+   *
+   * <p>This is useful for matching Kotlin Metadata JVM Signatures with elements from the AST.
+   *
+   * <p>For reference, see the <a
+   * href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3">JVM
+   * specification, section 4.3.3</a>.
+   */
+  public static String getMethodDescriptor(ExecutableElement element) {
+    return element.getSimpleName() + getDescriptor(element.asType());
+  }
+
+  private static String getDescriptor(TypeMirror t) {
+    return t.accept(JVM_DESCRIPTOR_TYPE_VISITOR, null);
+  }
+
+  private static final AbstractTypeVisitor8<String, Void> JVM_DESCRIPTOR_TYPE_VISITOR =
+      new AbstractTypeVisitor8<String, Void>() {
+
+        @Override
+        public String visitArray(ArrayType arrayType, Void v) {
+          return "[" + getDescriptor(arrayType.getComponentType());
+        }
+
+        @Override
+        public String visitDeclared(DeclaredType declaredType, Void v) {
+          return "L" + getInternalName(declaredType.asElement()) + ";";
+        }
+
+        @Override
+        public String visitError(ErrorType errorType, Void v) {
+          return visitUnknown(errorType, null);
+        }
+
+        @Override
+        public String visitExecutable(ExecutableType executableType, Void v) {
+          String parameterDescriptors =
+              executableType.getParameterTypes().stream()
+                  .map(DaggerElements::getDescriptor)
+                  .collect(Collectors.joining());
+          String returnDescriptor = getDescriptor(executableType.getReturnType());
+          return "(" + parameterDescriptors + ")" + returnDescriptor;
+        }
+
+        @Override
+        public String visitIntersection(IntersectionType intersectionType, Void v) {
+          // For a type variable with multiple bounds: "the erasure of a type variable is determined
+          // by the first type in its bound" - JVM Spec Sec 4.4
+          return getDescriptor(intersectionType.getBounds().get(0));
+        }
+
+        @Override
+        public String visitNoType(NoType noType, Void v) {
+          return "V";
+        }
+
+        @Override
+        public String visitNull(NullType nullType, Void v) {
+          return visitUnknown(nullType, null);
+        }
+
+        @Override
+        public String visitPrimitive(PrimitiveType primitiveType, Void v) {
+          switch (primitiveType.getKind()) {
+            case BOOLEAN:
+              return "Z";
+            case BYTE:
+              return "B";
+            case SHORT:
+              return "S";
+            case INT:
+              return "I";
+            case LONG:
+              return "J";
+            case CHAR:
+              return "C";
+            case FLOAT:
+              return "F";
+            case DOUBLE:
+              return "D";
+            default:
+              throw new IllegalArgumentException("Unknown primitive type.");
+          }
+        }
+
+        @Override
+        public String visitTypeVariable(TypeVariable typeVariable, Void v) {
+          // The erasure of a type variable is the erasure of its leftmost bound. - JVM Spec Sec 4.6
+          return getDescriptor(typeVariable.getUpperBound());
+        }
+
+        @Override
+        public String visitUnion(UnionType unionType, Void v) {
+          return visitUnknown(unionType, null);
+        }
+
+        @Override
+        public String visitUnknown(TypeMirror typeMirror, Void v) {
+          throw new IllegalArgumentException("Unsupported type: " + typeMirror);
+        }
+
+        @Override
+        public String visitWildcard(WildcardType wildcardType, Void v) {
+          return "";
+        }
+
+        /**
+         * Returns the name of this element in its "internal form".
+         *
+         * <p>For reference, see the <a
+         * href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2">JVM
+         * specification, section 4.2</a>.
+         */
+        private String getInternalName(Element element) {
+          try {
+            TypeElement typeElement = MoreElements.asType(element);
+            switch (typeElement.getNestingKind()) {
+              case TOP_LEVEL:
+                return typeElement.getQualifiedName().toString().replace('.', '/');
+              case MEMBER:
+                return getInternalName(typeElement.getEnclosingElement())
+                    + "$"
+                    + typeElement.getSimpleName();
+              default:
+                throw new IllegalArgumentException("Unsupported nesting kind.");
+            }
+          } catch (IllegalArgumentException e) {
+            // Not a TypeElement, try something else...
+          }
+
+          if (element instanceof QualifiedNameable) {
+            QualifiedNameable qualifiedNameElement = (QualifiedNameable) element;
+            return qualifiedNameElement.getQualifiedName().toString().replace('.', '/');
+          }
+
+          return element.getSimpleName().toString();
+        }
+      };
+
   /**
    * Invokes {@link Elements#getTypeElement(CharSequence)}, throwing {@link TypeNotPresentException}
    * if it is not accessible in the current compilation.
diff --git a/java/dagger/internal/codegen/validation/BUILD b/java/dagger/internal/codegen/validation/BUILD
index 729f30632..5fd3b6187 100644
--- a/java/dagger/internal/codegen/validation/BUILD
+++ b/java/dagger/internal/codegen/validation/BUILD
@@ -29,6 +29,7 @@ java_library(
         "//java/dagger/internal/codegen/compileroption",
         "//java/dagger/internal/codegen/extension",
         "//java/dagger/internal/codegen/javapoet",
+        "//java/dagger/internal/codegen/kotlin",
         "//java/dagger/internal/codegen/langmodel",
         "//java/dagger/model",
         "//java/dagger/producers",
diff --git a/java/dagger/internal/codegen/validation/BindingElementValidator.java b/java/dagger/internal/codegen/validation/BindingElementValidator.java
index 9d5282fb7..70ded51d5 100644
--- a/java/dagger/internal/codegen/validation/BindingElementValidator.java
+++ b/java/dagger/internal/codegen/validation/BindingElementValidator.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen.validation;
 
 import static com.google.common.base.Verify.verifyNotNull;
-import static dagger.internal.codegen.base.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.base.Scopes.scopesOf;
 import static dagger.internal.codegen.base.Util.reentrantComputeIfAbsent;
 import static dagger.internal.codegen.binding.MapKeys.getMapKeys;
@@ -35,6 +34,7 @@
 import dagger.internal.codegen.base.FrameworkTypes;
 import dagger.internal.codegen.base.MultibindingAnnotations;
 import dagger.internal.codegen.base.SetType;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import dagger.model.Key;
 import dagger.model.Scope;
 import dagger.multibindings.ElementsIntoSet;
@@ -58,6 +58,7 @@
   private final AllowsMultibindings allowsMultibindings;
   private final AllowsScoping allowsScoping;
   private final Map<E, ValidationReport<E>> cache = new HashMap<>();
+  private final InjectionAnnotations injectionAnnotations;
 
   /**
    * Creates a validator object.
@@ -67,10 +68,12 @@
   protected BindingElementValidator(
       Class<? extends Annotation> bindingAnnotation,
       AllowsMultibindings allowsMultibindings,
-      AllowsScoping allowsScoping) {
+      AllowsScoping allowsScoping,
+      InjectionAnnotations injectionAnnotations) {
     this.bindingAnnotation = bindingAnnotation;
     this.allowsMultibindings = allowsMultibindings;
     this.allowsScoping = allowsScoping;
+    this.injectionAnnotations = injectionAnnotations;
   }
 
   /** Returns a {@link ValidationReport} for {@code element}. */
@@ -234,7 +237,8 @@ protected final void checkSetValuesType(TypeMirror type) {
      * Adds an error if the element has more than one {@linkplain Qualifier qualifier} annotation.
      */
     private void checkQualifiers() {
-      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(element);
+      ImmutableSet<? extends AnnotationMirror> qualifiers =
+          injectionAnnotations.getQualifiers(element);
       if (qualifiers.size() > 1) {
         for (AnnotationMirror qualifier : qualifiers) {
           report.addError(
diff --git a/java/dagger/internal/codegen/validation/BindingMethodValidator.java b/java/dagger/internal/codegen/validation/BindingMethodValidator.java
index 87b68b4f2..a33742cba 100644
--- a/java/dagger/internal/codegen/validation/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/validation/BindingMethodValidator.java
@@ -23,6 +23,7 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.annotations.FormatMethod;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import java.lang.annotation.Annotation;
@@ -58,7 +59,8 @@ protected BindingMethodValidator(
       Abstractness abstractness,
       ExceptionSuperclass exceptionSuperclass,
       AllowsMultibindings allowsMultibindings,
-      AllowsScoping allowsScoping) {
+      AllowsScoping allowsScoping,
+      InjectionAnnotations injectionAnnotations) {
     this(
         elements,
         types,
@@ -68,7 +70,8 @@ protected BindingMethodValidator(
         abstractness,
         exceptionSuperclass,
         allowsMultibindings,
-        allowsScoping);
+        allowsScoping,
+        injectionAnnotations);
   }
 
   /**
@@ -87,8 +90,9 @@ protected BindingMethodValidator(
       Abstractness abstractness,
       ExceptionSuperclass exceptionSuperclass,
       AllowsMultibindings allowsMultibindings,
-      AllowsScoping allowsScoping) {
-    super(methodAnnotation, allowsMultibindings, allowsScoping);
+      AllowsScoping allowsScoping,
+      InjectionAnnotations injectionAnnotations) {
+    super(methodAnnotation, allowsMultibindings, allowsScoping, injectionAnnotations);
     this.elements = elements;
     this.types = types;
     this.methodAnnotation = methodAnnotation;
diff --git a/java/dagger/internal/codegen/validation/BindsInstanceElementValidator.java b/java/dagger/internal/codegen/validation/BindsInstanceElementValidator.java
index 07fe4edc5..283af7d0b 100644
--- a/java/dagger/internal/codegen/validation/BindsInstanceElementValidator.java
+++ b/java/dagger/internal/codegen/validation/BindsInstanceElementValidator.java
@@ -17,11 +17,16 @@
 package dagger.internal.codegen.validation;
 
 import dagger.BindsInstance;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import javax.lang.model.element.Element;
 
 abstract class BindsInstanceElementValidator<E extends Element> extends BindingElementValidator<E> {
-  BindsInstanceElementValidator() {
-    super(BindsInstance.class, AllowsMultibindings.NO_MULTIBINDINGS, AllowsScoping.NO_SCOPING);
+  BindsInstanceElementValidator(InjectionAnnotations injectionAnnotations) {
+    super(
+        BindsInstance.class,
+        AllowsMultibindings.NO_MULTIBINDINGS,
+        AllowsScoping.NO_SCOPING,
+        injectionAnnotations);
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/validation/BindsInstanceMethodValidator.java b/java/dagger/internal/codegen/validation/BindsInstanceMethodValidator.java
index af1cadcbd..937bc0244 100644
--- a/java/dagger/internal/codegen/validation/BindsInstanceMethodValidator.java
+++ b/java/dagger/internal/codegen/validation/BindsInstanceMethodValidator.java
@@ -23,6 +23,7 @@
 
 import com.google.auto.common.MoreElements;
 import dagger.internal.codegen.base.ModuleAnnotation;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import java.util.List;
 import java.util.Optional;
 import javax.inject.Inject;
@@ -33,7 +34,9 @@
 
 final class BindsInstanceMethodValidator extends BindsInstanceElementValidator<ExecutableElement> {
   @Inject
-  BindsInstanceMethodValidator() {}
+  BindsInstanceMethodValidator(InjectionAnnotations injectionAnnotations) {
+    super(injectionAnnotations);
+  }
 
   @Override
   protected ElementValidator elementValidator(ExecutableElement element) {
diff --git a/java/dagger/internal/codegen/validation/BindsInstanceParameterValidator.java b/java/dagger/internal/codegen/validation/BindsInstanceParameterValidator.java
index 0bb691ff6..24d65a979 100644
--- a/java/dagger/internal/codegen/validation/BindsInstanceParameterValidator.java
+++ b/java/dagger/internal/codegen/validation/BindsInstanceParameterValidator.java
@@ -22,6 +22,7 @@
 import static javax.lang.model.type.TypeKind.TYPEVAR;
 
 import com.google.auto.common.MoreElements;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import java.util.Optional;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
@@ -32,7 +33,9 @@
 
 final class BindsInstanceParameterValidator extends BindsInstanceElementValidator<VariableElement> {
   @Inject
-  BindsInstanceParameterValidator() {}
+  BindsInstanceParameterValidator(InjectionAnnotations injectionAnnotations) {
+    super(injectionAnnotations);
+  }
 
   @Override
   protected ElementValidator elementValidator(VariableElement element) {
diff --git a/java/dagger/internal/codegen/validation/BindsMethodValidator.java b/java/dagger/internal/codegen/validation/BindsMethodValidator.java
index ce8f6c484..3cc27c705 100644
--- a/java/dagger/internal/codegen/validation/BindsMethodValidator.java
+++ b/java/dagger/internal/codegen/validation/BindsMethodValidator.java
@@ -28,6 +28,7 @@
 import dagger.internal.codegen.base.ContributionType;
 import dagger.internal.codegen.base.SetType;
 import dagger.internal.codegen.binding.BindsTypeChecker;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.producers.ProducerModule;
@@ -46,7 +47,8 @@
       DaggerElements elements,
       DaggerTypes types,
       BindsTypeChecker bindsTypeChecker,
-      DependencyRequestValidator dependencyRequestValidator) {
+      DependencyRequestValidator dependencyRequestValidator,
+      InjectionAnnotations injectionAnnotations) {
     super(
         elements,
         types,
@@ -56,7 +58,8 @@
         MUST_BE_ABSTRACT,
         NO_EXCEPTIONS,
         ALLOWS_MULTIBINDINGS,
-        ALLOWS_SCOPING);
+        ALLOWS_SCOPING,
+        injectionAnnotations);
     this.types = types;
     this.bindsTypeChecker = bindsTypeChecker;
   }
diff --git a/java/dagger/internal/codegen/validation/BindsOptionalOfMethodValidator.java b/java/dagger/internal/codegen/validation/BindsOptionalOfMethodValidator.java
index 8c3b21c04..cc123ba1c 100644
--- a/java/dagger/internal/codegen/validation/BindsOptionalOfMethodValidator.java
+++ b/java/dagger/internal/codegen/validation/BindsOptionalOfMethodValidator.java
@@ -16,9 +16,8 @@
 
 package dagger.internal.codegen.validation;
 
-import static dagger.internal.codegen.base.InjectionAnnotations.getQualifiers;
-import static dagger.internal.codegen.base.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.base.Keys.isValidImplicitProvisionKey;
+import static dagger.internal.codegen.binding.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.validation.BindingElementValidator.AllowsMultibindings.NO_MULTIBINDINGS;
 import static dagger.internal.codegen.validation.BindingElementValidator.AllowsScoping.NO_SCOPING;
 import static dagger.internal.codegen.validation.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
@@ -29,6 +28,7 @@
 import com.google.common.collect.ImmutableSet;
 import dagger.BindsOptionalOf;
 import dagger.Module;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.producers.ProducerModule;
@@ -40,12 +40,14 @@
 final class BindsOptionalOfMethodValidator extends BindingMethodValidator {
 
   private final DaggerTypes types;
+  private final InjectionAnnotations injectionAnnotations;
 
   @Inject
   BindsOptionalOfMethodValidator(
       DaggerElements elements,
       DaggerTypes types,
-      DependencyRequestValidator dependencyRequestValidator) {
+      DependencyRequestValidator dependencyRequestValidator,
+      InjectionAnnotations injectionAnnotations) {
     super(
         elements,
         types,
@@ -55,8 +57,10 @@
         MUST_BE_ABSTRACT,
         NO_EXCEPTIONS,
         NO_MULTIBINDINGS,
-        NO_SCOPING);
+        NO_SCOPING,
+        injectionAnnotations);
     this.types = types;
+    this.injectionAnnotations = injectionAnnotations;
   }
 
   @Override
@@ -73,7 +77,7 @@ protected ElementValidator elementValidator(ExecutableElement element) {
     protected void checkKeyType(TypeMirror keyType) {
       super.checkKeyType(keyType);
       if (isValidImplicitProvisionKey(
-              getQualifiers(element).stream().findFirst(), keyType, types)
+              injectionAnnotations.getQualifiers(element).stream().findFirst(), keyType, types)
           && !injectedConstructors(MoreElements.asType(MoreTypes.asDeclared(keyType).asElement()))
               .isEmpty()) {
         report.addError(
diff --git a/java/dagger/internal/codegen/validation/DependencyRequestValidator.java b/java/dagger/internal/codegen/validation/DependencyRequestValidator.java
index d11a0609c..9a173c231 100644
--- a/java/dagger/internal/codegen/validation/DependencyRequestValidator.java
+++ b/java/dagger/internal/codegen/validation/DependencyRequestValidator.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen.validation;
 
-import static dagger.internal.codegen.base.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.base.RequestKinds.extractKeyType;
 import static dagger.internal.codegen.base.RequestKinds.getRequestKind;
 import static javax.lang.model.type.TypeKind.WILDCARD;
@@ -25,6 +24,7 @@
 import com.google.common.collect.ImmutableSet;
 import dagger.MembersInjector;
 import dagger.internal.codegen.base.FrameworkTypes;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -35,10 +35,14 @@
 /** Validation for dependency requests. */
 final class DependencyRequestValidator {
   private final MembersInjectionValidator membersInjectionValidator;
+  private final InjectionAnnotations injectionAnnotations;
 
   @Inject
-  DependencyRequestValidator(MembersInjectionValidator membersInjectionValidator) {
+  DependencyRequestValidator(
+      MembersInjectionValidator membersInjectionValidator,
+      InjectionAnnotations injectionAnnotations) {
     this.membersInjectionValidator = membersInjectionValidator;
+    this.injectionAnnotations = injectionAnnotations;
   }
 
   /**
@@ -47,7 +51,8 @@
    */
   void validateDependencyRequest(
       ValidationReport.Builder<?> report, Element requestElement, TypeMirror requestType) {
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(requestElement);
+    ImmutableSet<? extends AnnotationMirror> qualifiers =
+        injectionAnnotations.getQualifiers(requestElement);
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
         report.addError(
diff --git a/java/dagger/internal/codegen/validation/InjectBindingRegistryImpl.java b/java/dagger/internal/codegen/validation/InjectBindingRegistryImpl.java
index 47b457312..e9f5eb01b 100644
--- a/java/dagger/internal/codegen/validation/InjectBindingRegistryImpl.java
+++ b/java/dagger/internal/codegen/validation/InjectBindingRegistryImpl.java
@@ -19,9 +19,9 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.base.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.base.Keys.isValidImplicitProvisionKey;
 import static dagger.internal.codegen.base.Keys.isValidMembersInjectionKey;
+import static dagger.internal.codegen.binding.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.binding.SourceFiles.generatedClassNameForBinding;
 
 import com.google.auto.common.MoreElements;
diff --git a/java/dagger/internal/codegen/validation/InjectValidator.java b/java/dagger/internal/codegen/validation/InjectValidator.java
index e5105be79..b10d82362 100644
--- a/java/dagger/internal/codegen/validation/InjectValidator.java
+++ b/java/dagger/internal/codegen/validation/InjectValidator.java
@@ -17,9 +17,8 @@
 package dagger.internal.codegen.validation;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.base.InjectionAnnotations.getQualifiers;
-import static dagger.internal.codegen.base.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.base.Scopes.scopesOf;
+import static dagger.internal.codegen.binding.InjectionAnnotations.injectedConstructors;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -29,6 +28,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.langmodel.Accessibility;
 import dagger.internal.codegen.langmodel.DaggerElements;
@@ -59,14 +59,22 @@
   private final CompilerOptions compilerOptions;
   private final DependencyRequestValidator dependencyRequestValidator;
   private final Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind;
+  private final InjectionAnnotations injectionAnnotations;
 
   @Inject
   InjectValidator(
       DaggerTypes types,
       DaggerElements elements,
       DependencyRequestValidator dependencyRequestValidator,
-      CompilerOptions compilerOptions) {
-    this(types, elements, compilerOptions, dependencyRequestValidator, Optional.empty());
+      CompilerOptions compilerOptions,
+      InjectionAnnotations injectionAnnotations) {
+    this(
+        types,
+        elements,
+        compilerOptions,
+        dependencyRequestValidator,
+        Optional.empty(),
+        injectionAnnotations);
   }
 
   private InjectValidator(
@@ -74,12 +82,14 @@ private InjectValidator(
       DaggerElements elements,
       CompilerOptions compilerOptions,
       DependencyRequestValidator dependencyRequestValidator,
-      Optional<Kind> privateAndStaticInjectionDiagnosticKind) {
+      Optional<Kind> privateAndStaticInjectionDiagnosticKind,
+      InjectionAnnotations injectionAnnotations) {
     this.types = types;
     this.elements = elements;
     this.compilerOptions = compilerOptions;
     this.dependencyRequestValidator = dependencyRequestValidator;
     this.privateAndStaticInjectionDiagnosticKind = privateAndStaticInjectionDiagnosticKind;
+    this.injectionAnnotations = injectionAnnotations;
   }
 
   /**
@@ -95,7 +105,8 @@ public InjectValidator whenGeneratingCode() {
             elements,
             compilerOptions,
             dependencyRequestValidator,
-            Optional.of(Diagnostic.Kind.ERROR));
+            Optional.of(Diagnostic.Kind.ERROR),
+            injectionAnnotations);
   }
 
   public ValidationReport<TypeElement> validateConstructor(ExecutableElement constructorElement) {
@@ -106,7 +117,7 @@ public InjectValidator whenGeneratingCode() {
           "Dagger does not support injection into private constructors", constructorElement);
     }
 
-    for (AnnotationMirror qualifier : getQualifiers(constructorElement)) {
+    for (AnnotationMirror qualifier : injectionAnnotations.getQualifiers(constructorElement)) {
       builder.addError(
           "@Qualifier annotations are not allowed on @Inject constructors",
           constructorElement,
diff --git a/java/dagger/internal/codegen/validation/MembersInjectionValidator.java b/java/dagger/internal/codegen/validation/MembersInjectionValidator.java
index 75abfc0b2..afa6270f4 100644
--- a/java/dagger/internal/codegen/validation/MembersInjectionValidator.java
+++ b/java/dagger/internal/codegen/validation/MembersInjectionValidator.java
@@ -17,9 +17,9 @@
 package dagger.internal.codegen.validation;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.base.InjectionAnnotations.getQualifiers;
 
 import com.google.auto.common.MoreElements;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -36,9 +36,12 @@
  * {@code MembersInjector<Foo>}).
  */
 final class MembersInjectionValidator {
+  private final InjectionAnnotations injectionAnnotations;
 
   @Inject
-  MembersInjectionValidator() {}
+  MembersInjectionValidator(InjectionAnnotations injectionAnnotations) {
+    this.injectionAnnotations = injectionAnnotations;
+  }
 
   /** Reports errors if a request for a {@code MembersInjector<Foo>}) is invalid. */
   ValidationReport<Element> validateMembersInjectionRequest(
@@ -67,7 +70,7 @@
   }
 
   private void checkQualifiers(ValidationReport.Builder<?> report, Element element) {
-    for (AnnotationMirror qualifier : getQualifiers(element)) {
+    for (AnnotationMirror qualifier : injectionAnnotations.getQualifiers(element)) {
       report.addError("Cannot inject members into qualified types", element, qualifier);
       break; // just report on the first qualifier, in case there is more than one
     }
diff --git a/java/dagger/internal/codegen/validation/MultibindsMethodValidator.java b/java/dagger/internal/codegen/validation/MultibindsMethodValidator.java
index 4619abe65..f3181dd30 100644
--- a/java/dagger/internal/codegen/validation/MultibindsMethodValidator.java
+++ b/java/dagger/internal/codegen/validation/MultibindsMethodValidator.java
@@ -27,6 +27,7 @@
 import dagger.Module;
 import dagger.internal.codegen.base.MapType;
 import dagger.internal.codegen.base.SetType;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.multibindings.Multibinds;
@@ -43,7 +44,8 @@
   MultibindsMethodValidator(
       DaggerElements elements,
       DaggerTypes types,
-      DependencyRequestValidator dependencyRequestValidator) {
+      DependencyRequestValidator dependencyRequestValidator,
+      InjectionAnnotations injectionAnnotations) {
     super(
         elements,
         types,
@@ -53,7 +55,8 @@
         MUST_BE_ABSTRACT,
         NO_EXCEPTIONS,
         NO_MULTIBINDINGS,
-        NO_SCOPING);
+        NO_SCOPING,
+        injectionAnnotations);
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/validation/ProducesMethodValidator.java b/java/dagger/internal/codegen/validation/ProducesMethodValidator.java
index ee997db8f..35af3e200 100644
--- a/java/dagger/internal/codegen/validation/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/validation/ProducesMethodValidator.java
@@ -25,6 +25,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.internal.codegen.binding.ConfigurationAnnotations;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.multibindings.ElementsIntoSet;
@@ -44,7 +45,8 @@
   ProducesMethodValidator(
       DaggerElements elements,
       DaggerTypes types,
-      DependencyRequestValidator dependencyRequestValidator) {
+      DependencyRequestValidator dependencyRequestValidator,
+      InjectionAnnotations injectionAnnotations) {
     super(
         elements,
         types,
@@ -54,7 +56,8 @@
         MUST_BE_CONCRETE,
         EXCEPTION,
         ALLOWS_MULTIBINDINGS,
-        NO_SCOPING);
+        NO_SCOPING,
+        injectionAnnotations);
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/validation/ProvidesMethodValidator.java b/java/dagger/internal/codegen/validation/ProvidesMethodValidator.java
index dfeecddeb..e47d6c4be 100644
--- a/java/dagger/internal/codegen/validation/ProvidesMethodValidator.java
+++ b/java/dagger/internal/codegen/validation/ProvidesMethodValidator.java
@@ -24,6 +24,7 @@
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.producers.ProducerModule;
@@ -40,7 +41,8 @@
   ProvidesMethodValidator(
       DaggerElements elements,
       DaggerTypes types,
-      DependencyRequestValidator dependencyRequestValidator) {
+      DependencyRequestValidator dependencyRequestValidator,
+      InjectionAnnotations injectionAnnotations) {
     super(
         elements,
         types,
@@ -50,7 +52,8 @@
         MUST_BE_CONCRETE,
         RUNTIME_EXCEPTION,
         ALLOWS_MULTIBINDINGS,
-        ALLOWS_SCOPING);
+        ALLOWS_SCOPING,
+        injectionAnnotations);
     this.dependencyRequestValidator = dependencyRequestValidator;
   }
 
diff --git a/javatests/dagger/internal/codegen/BUILD b/javatests/dagger/internal/codegen/BUILD
index 86e7b6fc0..185f0d5d9 100644
--- a/javatests/dagger/internal/codegen/BUILD
+++ b/javatests/dagger/internal/codegen/BUILD
@@ -25,6 +25,7 @@ GenJavaTests(
     srcs = glob(["*.java"]),
     functional = False,
     javacopts = DOCLINT_HTML_AND_SYNTAX,
+    plugins = ["//java/dagger/internal/codegen/bootstrap"],
     deps = [
         "//java/dagger:core",
         "//java/dagger/internal/codegen:package_info",
@@ -34,6 +35,7 @@ GenJavaTests(
         "//java/dagger/internal/codegen/bindinggraphvalidation",
         "//java/dagger/internal/codegen/compileroption",
         "//java/dagger/internal/codegen/javapoet",
+        "//java/dagger/internal/codegen/kotlin",
         "//java/dagger/internal/codegen/langmodel",
         "//java/dagger/internal/codegen/validation",
         "//java/dagger/internal/codegen/writing",
diff --git a/javatests/dagger/internal/codegen/ElementDescriptorsTest.java b/javatests/dagger/internal/codegen/ElementDescriptorsTest.java
new file mode 100644
index 000000000..e97e36012
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ElementDescriptorsTest.java
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.testing.compile.CompilationRule;
+import dagger.internal.codegen.langmodel.DaggerElements;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ElementDescriptorsTest {
+
+  @Rule public CompilationRule compilation = new CompilationRule();
+
+  static class TestClassA<T> {
+    int field1;
+    String field2;
+    T field3;
+    List<String> field4;
+  }
+
+  @Test
+  public void fieldDescriptor() {
+    assertThat(getFieldDescriptors(TestClassA.class.getCanonicalName()))
+        .containsExactly(
+            "field1:I",
+            "field2:Ljava/lang/String;",
+            "field3:Ljava/lang/Object;",
+            "field4:Ljava/util/List;");
+  }
+
+  static class TestClassB<T> {
+    void method1(boolean yesOrNo, int number) {}
+
+    byte method2(char letter) {
+      return 0;
+    }
+
+    void method3(double realNumber1, float realNummber2) {}
+
+    void method4(long bigNumber, short littlerNumber) {}
+  }
+
+  @Test
+  public void methodDescriptor_primitives() {
+    assertThat(getMethodDescriptors(TestClassB.class.getCanonicalName()))
+        .containsExactly("method1(ZI)V", "method2(C)B", "method3(DF)V", "method4(JS)V");
+  }
+
+  static class TestClassC<T> {
+    void method1(Object something) {}
+
+    Object method2() {
+      return null;
+    }
+
+    List<String> method3(ArrayList<Integer> list) {
+      return null;
+    }
+
+    Map<String, Object> method4() {
+      return null;
+    }
+  }
+
+  @Test
+  public void methodDescriptor_javaTypes() {
+    assertThat(getMethodDescriptors(TestClassC.class.getCanonicalName()))
+        .containsExactly(
+            "method1(Ljava/lang/Object;)V",
+            "method2()Ljava/lang/Object;",
+            "method3(Ljava/util/ArrayList;)Ljava/util/List;",
+            "method4()Ljava/util/Map;");
+  }
+
+  static class TestClassD<T> {
+    void method1(TestDataClass data) {}
+
+    TestDataClass method2() {
+      return null;
+    }
+  }
+
+  @Test
+  public void methodDescriptor_testTypes() {
+    assertThat(getMethodDescriptors(TestClassD.class.getCanonicalName()))
+        .containsExactly(
+            "method1(Ldagger/internal/codegen/TestDataClass;)V",
+            "method2()Ldagger/internal/codegen/TestDataClass;");
+  }
+
+  static class TestClassE<T> {
+    void method1(TestDataClass[] data) {}
+
+    TestDataClass[] method2() {
+      return null;
+    }
+
+    void method3(int[] array) {}
+
+    void method4(int... array) {}
+  }
+
+  @Test
+  public void methodDescriptor_arrays() {
+    assertThat(getMethodDescriptors(TestClassE.class.getCanonicalName()))
+        .containsExactly(
+            "method1([Ldagger/internal/codegen/TestDataClass;)V",
+            "method2()[Ldagger/internal/codegen/TestDataClass;",
+            "method3([I)V",
+            "method4([I)V");
+  }
+
+  static class TestClassF<T> {
+    void method1(TestDataClass.MemberInnerData data) {}
+
+    void method2(TestDataClass.StaticInnerData data) {}
+
+    void method3(TestDataClass.EnumData enumData) {}
+
+    TestDataClass.StaticInnerData method4() {
+      return null;
+    }
+  }
+
+  @Test
+  public void methodDescriptor_innerTestType() {
+    assertThat(getMethodDescriptors(TestClassF.class.getCanonicalName()))
+        .containsExactly(
+            "method1(Ldagger/internal/codegen/TestDataClass$MemberInnerData;)V",
+            "method2(Ldagger/internal/codegen/TestDataClass$StaticInnerData;)V",
+            "method3(Ldagger/internal/codegen/TestDataClass$EnumData;)V",
+            "method4()Ldagger/internal/codegen/TestDataClass$StaticInnerData;");
+  }
+
+  @SuppressWarnings("TypeParameterUnusedInFormals")
+  static class TestClassG<T> {
+    void method1(T something) {}
+
+    T method2() {
+      return null;
+    }
+
+    List<? extends String> method3() {
+      return null;
+    }
+
+    Map<T, String> method4() {
+      return null;
+    }
+
+    ArrayList<Map<T, String>> method5() {
+      return null;
+    }
+
+    static <I, O extends I> O method6(I input) {
+      return null;
+    }
+
+    static <I, O extends String> O method7(I input) {
+      return null;
+    }
+
+    static <P extends Collection<String> & Comparable<String>> P method8() {
+      return null;
+    }
+
+    static <P extends String & List<Character>> P method9() {
+      return null;
+    }
+  }
+
+  @Test
+  public void methodDescriptor_erasure() {
+    assertThat(getMethodDescriptors(TestClassG.class.getCanonicalName()))
+        .containsExactly(
+            "method1(Ljava/lang/Object;)V",
+            "method2()Ljava/lang/Object;",
+            "method3()Ljava/util/List;",
+            "method4()Ljava/util/Map;",
+            "method5()Ljava/util/ArrayList;",
+            "method6(Ljava/lang/Object;)Ljava/lang/Object;",
+            "method7(Ljava/lang/Object;)Ljava/lang/String;",
+            "method8()Ljava/util/Collection;",
+            "method9()Ljava/lang/String;");
+  }
+
+  private Set<String> getFieldDescriptors(String className) {
+    TypeElement testElement = compilation.getElements().getTypeElement(className);
+    return ElementFilter.fieldsIn(testElement.getEnclosedElements()).stream()
+        .map(DaggerElements::getFieldDescriptor)
+        .collect(Collectors.toSet());
+  }
+
+  private Set<String> getMethodDescriptors(String className) {
+    TypeElement testElement = compilation.getElements().getTypeElement(className);
+    return ElementFilter.methodsIn(testElement.getEnclosedElements()).stream()
+        .map(DaggerElements::getMethodDescriptor)
+        .collect(Collectors.toSet());
+  }
+}
+
+@SuppressWarnings("ClassCanBeStatic")
+class TestDataClass {
+  class MemberInnerData {}
+
+  static class StaticInnerData {}
+
+  enum EnumData {
+    VALUE1,
+    VALUE2
+  }
+}
diff --git a/javatests/dagger/internal/codegen/KeyFactoryTest.java b/javatests/dagger/internal/codegen/KeyFactoryTest.java
index fa3d8d3f2..6faaf1164 100644
--- a/javatests/dagger/internal/codegen/KeyFactoryTest.java
+++ b/javatests/dagger/internal/codegen/KeyFactoryTest.java
@@ -24,6 +24,8 @@
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.testing.compile.CompilationRule;
+import dagger.BindsInstance;
+import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.codegen.binding.KeyFactory;
@@ -39,6 +41,7 @@
 import java.util.Set;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
+import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
@@ -58,14 +61,12 @@
 public class KeyFactoryTest {
   @Rule public CompilationRule compilationRule = new CompilationRule();
 
-  private DaggerElements elements;
-  private DaggerTypes types;
-  private KeyFactory keyFactory;
+  @Inject DaggerElements elements;
+  @Inject DaggerTypes types;
+  @Inject KeyFactory keyFactory;
 
   @Before public void setUp() {
-    this.elements = new DaggerElements(compilationRule.getElements(), compilationRule.getTypes());
-    this.types = new DaggerTypes(compilationRule.getTypes(), elements);
-    this.keyFactory = new KeyFactory(types, elements);
+    DaggerKeyFactoryTest_TestComponent.factory().create(compilationRule).inject(this);
   }
 
   @Test public void forInjectConstructorWithResolvedType() {
@@ -328,4 +329,28 @@ static String provideQualifiedString() {
       throw new UnsupportedOperationException();
     }
   }
+
+  @Singleton
+  @Component(modules = {TestModule.class})
+  interface TestComponent {
+    void inject(KeyFactoryTest test);
+
+    @Component.Factory
+    interface Factory {
+      TestComponent create(@BindsInstance CompilationRule compilationRule);
+    }
+  }
+
+  @Module
+  static class TestModule {
+    @Provides
+    static DaggerElements elements(CompilationRule compilationRule) {
+      return new DaggerElements(compilationRule.getElements(), compilationRule.getTypes());
+    }
+
+    @Provides
+    static DaggerTypes types(CompilationRule compilationRule, DaggerElements elements) {
+      return new DaggerTypes(compilationRule.getTypes(), elements);
+    }
+  }
 }
diff --git a/javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java b/javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java
index a1fc220ea..379b7e385 100644
--- a/javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java
+++ b/javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java
@@ -22,13 +22,17 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
+import dagger.Component;
 import dagger.internal.codegen.MethodSignatureFormatterTest.OuterClass.InnerClass;
+import dagger.internal.codegen.binding.InjectionAnnotations;
 import dagger.internal.codegen.binding.MethodSignatureFormatter;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
+import javax.inject.Inject;
 import javax.inject.Singleton;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -38,6 +42,8 @@
 public class MethodSignatureFormatterTest {
   @Rule public CompilationRule compilationRule = new CompilationRule();
 
+  @Inject InjectionAnnotations injectionAnnotations;
+
   static class OuterClass {
     @interface Foo {
        Class<?> bar();
@@ -54,13 +60,18 @@ String foo(
     }
   }
 
+  @Before
+  public void setUp() {
+    DaggerMethodSignatureFormatterTest_TestComponent.create().inject(this);
+  }
+
   @Test public void methodSignatureTest() {
     DaggerElements elements =
         new DaggerElements(compilationRule.getElements(), compilationRule.getTypes());
     DaggerTypes types = new DaggerTypes(compilationRule.getTypes(), elements);
     TypeElement inner = elements.getTypeElement(InnerClass.class);
     ExecutableElement method = Iterables.getOnlyElement(methodsIn(inner.getEnclosedElements()));
-    String formatted = new MethodSignatureFormatter(types).format(method);
+    String formatted = new MethodSignatureFormatter(types, injectionAnnotations).format(method);
     // This is gross, but it turns out that annotation order is not guaranteed when getting
     // all the AnnotationMirrors from an Element, so I have to test this chopped-up to make it
     // less brittle.
@@ -72,4 +83,10 @@ String foo(
     assertThat(formatted).contains(" String "); // return type compressed
     assertThat(formatted).contains("int, ImmutableList<Boolean>)"); // parameters compressed.
   }
+
+  @Singleton
+  @Component
+  interface TestComponent {
+    void inject(MethodSignatureFormatterTest test);
+  }
 }
