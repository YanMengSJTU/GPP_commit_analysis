diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index acb94f359..1b0b9bbea 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -284,6 +284,7 @@ java_library(
 java_library(
     name = "kythe",
     srcs = KYTHE_SRCS,
+    plugins = [":component-codegen"],
     deps = [
         ":base",
         ":binding",
diff --git a/java/dagger/internal/codegen/DaggerKythePlugin.java b/java/dagger/internal/codegen/DaggerKythePlugin.java
index f3d3849c0..d479cfd03 100644
--- a/java/dagger/internal/codegen/DaggerKythePlugin.java
+++ b/java/dagger/internal/codegen/DaggerKythePlugin.java
@@ -19,13 +19,24 @@
 // the regular kythe/java tree.
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.ImmutableSet.toImmutableSet;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.devtools.kythe.analyzers.base.EdgeKind.DEFINES_BINDING;
 import static com.google.devtools.kythe.analyzers.base.EdgeKind.REF;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
+import static dagger.internal.codegen.DaggerTypes.hasTypeVariable;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.KytheFormatting.formatAnnotation;
 import static dagger.internal.codegen.KytheFormatting.formatKey;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableSet;
 import com.google.devtools.kythe.analyzers.base.CorpusPath;
 import com.google.devtools.kythe.analyzers.base.EdgeKind;
 import com.google.devtools.kythe.analyzers.base.EntrySet;
@@ -34,20 +45,40 @@
 import com.google.devtools.kythe.analyzers.java.Plugin;
 import com.google.devtools.kythe.proto.Storage.VName;
 import com.google.devtools.kythe.util.Span;
+import com.sun.source.tree.Tree;
 import com.sun.tools.javac.api.JavacTrees;
+import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.model.JavacElements;
 import com.sun.tools.javac.model.JavacTypes;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 import com.sun.tools.javac.util.Context;
+import dagger.Binds;
+import dagger.BindsInstance;
+import dagger.BindsOptionalOf;
+import dagger.Component;
+import dagger.MembersInjector;
+import dagger.Provides;
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
+import dagger.multibindings.Multibinds;
+import dagger.producers.Produces;
+import java.util.Optional;
+import javax.inject.Inject;
+import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * A plugin which emits nodes and edges for <a href="https://github.com/google/dagger">Dagger</a>
@@ -62,63 +93,122 @@
   private KytheBindingGraphFactory bindingGraphFactory;
   private CorpusPath corpusPath;
   private KeyVNameFactory keys;
+  @Inject BindingFactory bindingFactory;
+  @Inject DelegateDeclaration.Factory delegateDeclarationFactory;
+  @Inject MultibindingDeclaration.Factory multibindingDeclarationFactory;
+  @Inject SubcomponentDeclaration.Factory subcomponentDeclarationFactory;
+  @Inject KeyFactory keyFactory;
+  @Inject DaggerTypes types;
+  @Inject DaggerElements elements;
 
   @Override
   public Void visitClassDef(JCClassDecl tree, Void p) {
-    TypeElement type = MoreElements.asType(trees.getElement(trees.getPath(compilationUnit, tree)));
+    TypeElement type = MoreElements.asType(getElement(tree));
     bindingGraphFactory.create(type).ifPresent(this::addNodesForGraph);
-    return super.visitClassDef(tree, p);
-  }
 
-  private void addNodesForGraph(BindingGraph graph) {
-    for (ResolvedBindings resolvedBindings : graph.resolvedBindings()) {
-      for (Binding binding : resolvedBindings.bindings()) {
-        addBindingDeclarationNode(binding);
+    if (getModuleAnnotation(type).isPresent()) {
+      subcomponentDeclarationFactory.forModule(type).forEach(this::addBindingDeclarationEdge);
+    }
 
-        binding.dependencies().forEach(this::addDependencyNode);
+    Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(type);
+    if (componentAnnotation.isPresent()) {
+      addBindingAndDependencyEdges(bindingFactory.componentBinding(type));
+      for (TypeMirror dependency : getComponentDependencies(componentAnnotation.get())) {
+        ComponentRequirement requirement = ComponentRequirement.forDependency(dependency);
+        addBindingAndDependencyEdges(bindingFactory.componentDependencyBinding(requirement));
       }
+    }
+
+    MembersInjectionBinding membersInjectionBinding =
+        bindingFactory.membersInjectionBinding(
+            MoreTypes.asDeclared(type.asType()), Optional.empty());
+    for (InjectionSite injectionSite : membersInjectionBinding.injectionSites()) {
+      // ignore inherited injection sites
+      if (injectionSite.element().getEnclosingElement().equals(type)) {
+        injectionSite.dependencies().forEach(this::addDependencyEdge);
+      }
+    }
 
-      resolvedBindings.multibindingDeclarations().forEach(this::addBindingDeclarationNode);
-      resolvedBindings.subcomponentDeclarations().forEach(this::addBindingDeclarationNode);
-      resolvedBindings
-          .optionalBindingDeclarations()
-          .forEach(declaration -> addBindingDeclarationNode(declaration, resolvedBindings.key()));
+    if (!membersInjectionBinding.injectionSites().isEmpty()) {
+      Key membersInjectorKey =
+          Key.builder(types.wrapType(membersInjectionBinding.key().type(), MembersInjector.class))
+              .build();
+      addBindingDeclarationEdge(membersInjectorKey, type);
     }
 
+    return super.visitClassDef(tree, p);
+  }
+
+  @Override
+  public Void visitMethodDef(JCMethodDecl tree, Void p) {
+    ExecutableElement element = MoreElements.asExecutable(getElement(tree));
+    if (isAnnotationPresent(element, Inject.class) && element.getKind().equals(CONSTRUCTOR)) {
+      addBindingAndDependencyEdges(bindingFactory.injectionBinding(element, Optional.empty()));
+    } else {
+      TypeElement enclosingType = MoreElements.asType(element.getEnclosingElement());
+      if (isAnnotationPresent(element, Provides.class)){
+        addBindingAndDependencyEdges(bindingFactory.providesMethodBinding(element, enclosingType));
+      } else if (isAnnotationPresent(element, Produces.class)) {
+        addBindingAndDependencyEdges(bindingFactory.producesMethodBinding(element, enclosingType));
+      } else if (isAnnotationPresent(element, Binds.class)) {
+        DelegateDeclaration delegateDeclaration =
+            delegateDeclarationFactory.create(element, enclosingType);
+        addBindingDeclarationEdge(delegateDeclaration);
+        addDependencyEdge(delegateDeclaration.delegateRequest());
+      } else if (isAnnotationPresent(element, Multibinds.class)) {
+        addBindingDeclarationEdge(
+            multibindingDeclarationFactory.forMultibindsMethod(element, enclosingType));
+      } else if (isAnnotationPresent(element, BindsOptionalOf.class)) {
+        Key key = keyFactory.forBindsOptionalOfMethod(element, enclosingType);
+        for (Class<?> optionalClass : optionalClasses()) {
+          Key wrappedOptionalKey =
+              key.toBuilder().type(types.wrapType(key.type(), optionalClass)).build();
+          addBindingDeclarationEdge(wrappedOptionalKey, element);
+        }
+      } else if (isAnnotationPresent(element, BindsInstance.class)) {
+        VariableElement parameter = getOnlyElement(element.getParameters());
+        Key key = Key.builder(parameter.asType()).qualifier(getQualifier(parameter)).build();
+        addBindingDeclarationEdge(key, element);
+      }
+    }
+    return super.visitMethodDef(tree, p);
+  }
+
+  private void addNodesForGraph(BindingGraph graph) {
     for (ComponentDescriptor.ComponentMethodDescriptor componentMethod :
         graph.componentDescriptor().componentMethods()) {
-      componentMethod.dependencyRequest().ifPresent(this::addDependencyNode);
+      componentMethod.dependencyRequest().ifPresent(this::addDependencyEdge);
     }
   }
 
-  private void addBindingDeclarationNode(BindingDeclaration declaration) {
-    addBindingDeclarationNode(declaration, declaration.key());
+  private void addBindingAndDependencyEdges(Binding binding) {
+    addBindingDeclarationEdge(binding);
+    binding.dependencies().forEach(this::addDependencyEdge);
+  }
+
+  private void addBindingDeclarationEdge(BindingDeclaration declaration) {
+    addBindingDeclarationEdge(declaration.key(), declaration.bindingElement().get());
   }
 
   /**
-   * Adds a {@code defines/binding} edge between {@code declaration}'s {@link
-   * BindingDeclaration#bindingElement()} and the node for {@code key}.
-   *
-   * <p>{@link BindingDeclaration#key()} is not used directly, since {@link
-   * OptionalBindingDeclaration}s' keys are the unwrapped {@code Optional} types and can apply to
-   * either {@code java.util.Optional} or {@code com.google.common.base.Optional}.
+   * Adds a {@code defines/binding} edge between {@code bindingElement} and the node for {@code
+   * key}.
    */
-  private void addBindingDeclarationNode(BindingDeclaration declaration, Key key) {
-    if (!declaration.bindingElement().isPresent()) {
+  private void addBindingDeclarationEdge(Key key, Element bindingElement) {
+    if (hasTypeVariable(key.type())) {
       return;
     }
     EntrySet bindingAnchor =
-        entrySets.newAnchorAndEmit(fileVName, bindingElementSpan(declaration), null);
+        entrySets.newAnchorAndEmit(fileVName, bindingElementSpan(bindingElement), null);
 
     entrySets.emitEdge(bindingAnchor, DEFINES_BINDING, keyNode(key));
   }
 
-  private Span bindingElementSpan(BindingDeclaration declaration) {
-    Element bindingElement = declaration.bindingElement().get();
+  private Span bindingElementSpan(Element bindingElement) {
     Name name =
-        bindingElement.getKind().equals(ElementKind.METHOD)
-            ? bindingElement.getSimpleName()
-            : declaration.bindingTypeElement().get().getSimpleName();
+        bindingElement.getKind().equals(ElementKind.CONSTRUCTOR)
+            ? bindingElement.getEnclosingElement().getSimpleName()
+            : bindingElement.getSimpleName();
     return span(name, trees.getTree(bindingElement));
   }
 
@@ -126,8 +216,9 @@ private Span bindingElementSpan(BindingDeclaration declaration) {
    * Adds a {@code ref} edge between {@code dependencyRequest} and it's {@link
    * DependencyRequest#key() key's} node.
    */
-  private void addDependencyNode(DependencyRequest dependencyRequest) {
-    if (!dependencyRequest.requestElement().isPresent()) {
+  private void addDependencyEdge(DependencyRequest dependencyRequest) {
+    if (!dependencyRequest.requestElement().isPresent()
+        || hasTypeVariable(dependencyRequest.key().type())) {
       return;
     }
     EntrySet dependencyRequestAnchor =
@@ -172,6 +263,25 @@ private EntrySet newNode(String nodeKind, String format) {
     return node;
   }
 
+  private ImmutableSet<Class<?>> optionalClasses() {
+    // TODO(user): Can the plugin infrastructure be modified to guarantee certain types are
+    // always available to plugins via kytheGraph.getNode() even if they haven't been scanned yet?
+    return ImmutableSet.of(java.util.Optional.class, com.google.common.base.Optional.class)
+        .stream()
+        .filter(this::isClassAvailable)
+        .collect(toImmutableSet());
+  }
+
+  private boolean isClassAvailable(Class<?> clazz) {
+    return kytheGraph
+        .getNode((Symbol) elements.getTypeElement(clazz.getCanonicalName()))
+        .isPresent();
+  }
+
+  private Element getElement(Tree tree) {
+    return trees.getElement(trees.getPath(compilationUnit, tree));
+  }
+
   @Override
   public void run(
       JCCompilationUnit compilationUnit, KytheEntrySets entrySets, KytheGraph kytheGraph) {
@@ -182,6 +292,11 @@ public void run(
       bindingGraphFactory =
           new KytheBindingGraphFactory(
               JavacTypes.instance(javaContext), JavacElements.instance(javaContext));
+      DaggerDaggerKythePlugin_PluginComponent.builder()
+          .types(JavacTypes.instance(javaContext))
+          .elements(JavacElements.instance(javaContext))
+          .build()
+          .inject(this);
       keys = new KeyVNameFactory(kytheGraph, entrySets, emitter);
     }
     this.compilationUnit = compilationUnit;
@@ -189,4 +304,17 @@ public void run(
     corpusPath = new CorpusPath(fileVName.getCorpus(), "", "");
     super.run(compilationUnit, entrySets, kytheGraph);
   }
+
+  @Singleton
+  @Component
+  interface PluginComponent {
+    void inject(DaggerKythePlugin plugin);
+
+    @Component.Builder
+    interface Builder {
+      @BindsInstance Builder types(Types types);
+      @BindsInstance Builder elements(Elements elements);
+      PluginComponent build();
+    }
+  }
 }
diff --git a/java/dagger/internal/codegen/DaggerTypes.java b/java/dagger/internal/codegen/DaggerTypes.java
index 5a9618e73..269e32658 100644
--- a/java/dagger/internal/codegen/DaggerTypes.java
+++ b/java/dagger/internal/codegen/DaggerTypes.java
@@ -39,8 +39,10 @@
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
 import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor8;
 import javax.lang.model.util.Types;
 
 /** Extension of {@link Types} that adds Dagger-specific methods. */
@@ -155,6 +157,32 @@ static boolean isFutureType(TypeMirror type) {
     return FUTURE_TYPES.stream().anyMatch(t -> MoreTypes.isTypeOf(t, type));
   }
 
+  static boolean hasTypeVariable(TypeMirror type) {
+    return type.accept(
+        new SimpleTypeVisitor8<Boolean, Void>() {
+          @Override
+          public Boolean visitArray(ArrayType arrayType, Void p) {
+            return arrayType.getComponentType().accept(this, p);
+          }
+
+          @Override
+          public Boolean visitDeclared(DeclaredType declaredType, Void p) {
+            return declaredType.getTypeArguments().stream().anyMatch(type -> type.accept(this, p));
+          }
+
+          @Override
+          public Boolean visitTypeVariable(TypeVariable t, Void aVoid) {
+            return true;
+          }
+
+          @Override
+          protected Boolean defaultAction(TypeMirror e, Void aVoid) {
+            return false;
+          }
+        },
+        null);
+  }
+
   // Implementation of Types methods, delegating to types.
 
   @Override
