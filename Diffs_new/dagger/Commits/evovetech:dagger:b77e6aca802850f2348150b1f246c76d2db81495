diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 629a81cfd..1ab1dcf57 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -24,8 +24,6 @@ EXPERIMENTAL_VISUALIZER_SRCS = ["BindingNetworkVisualizer.java"]
 KYTHE_SRCS = [
     "KytheBindingGraphFactory.java",
     "DaggerKythePlugin.java",
-    "KytheFormatting.java",
-    "KeyVNameFactory.java",
 ]
 
 CODEGEN_SRCS = glob(
diff --git a/java/dagger/internal/codegen/DaggerKythePlugin.java b/java/dagger/internal/codegen/DaggerKythePlugin.java
index ef8407041..99e86fe43 100644
--- a/java/dagger/internal/codegen/DaggerKythePlugin.java
+++ b/java/dagger/internal/codegen/DaggerKythePlugin.java
@@ -19,66 +19,34 @@
 // the regular kythe/java tree.
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.devtools.kythe.analyzers.base.EdgeKind.DEFINES_BINDING;
-import static com.google.devtools.kythe.analyzers.base.EdgeKind.PARAM;
-import static com.google.devtools.kythe.analyzers.base.EdgeKind.REF;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
-import static dagger.internal.codegen.DaggerTypes.hasTypeVariable;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.KytheFormatting.formatAnnotation;
-import static dagger.internal.codegen.KytheFormatting.formatKey;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
 import com.google.auto.service.AutoService;
-import com.google.common.collect.ImmutableList;
-import com.google.devtools.kythe.analyzers.base.CorpusPath;
+import com.google.common.collect.Iterables;
 import com.google.devtools.kythe.analyzers.base.EntrySet;
 import com.google.devtools.kythe.analyzers.base.FactEmitter;
 import com.google.devtools.kythe.analyzers.base.KytheEntrySets;
-import com.google.devtools.kythe.analyzers.base.KytheEntrySets.NodeBuilder;
-import com.google.devtools.kythe.analyzers.base.NodeKind;
 import com.google.devtools.kythe.analyzers.java.Plugin;
 import com.google.devtools.kythe.proto.Storage.VName;
-import com.google.devtools.kythe.util.Span;
 import com.sun.source.tree.Tree;
 import com.sun.tools.javac.api.JavacTrees;
+import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.model.JavacElements;
 import com.sun.tools.javac.model.JavacTypes;
-import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
-import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 import com.sun.tools.javac.util.Context;
-import dagger.Binds;
 import dagger.BindsInstance;
-import dagger.BindsOptionalOf;
 import dagger.Component;
-import dagger.MembersInjector;
-import dagger.Provides;
-import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
-import dagger.multibindings.Multibinds;
-import dagger.producers.Produces;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Optional;
+import java.util.logging.Logger;
 import javax.inject.Inject;
 import javax.inject.Singleton;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -88,279 +56,104 @@
  */
 @AutoService(Plugin.class)
 public class DaggerKythePlugin extends Plugin.Scanner<Void, Void> {
+  private static final Logger logger = Logger.getLogger(DaggerKythePlugin.class.getCanonicalName());
   private JavacTrees trees;
   private FactEmitter emitter;
   private JCCompilationUnit compilationUnit;
-  private VName fileVName;
-  private KytheBindingGraphFactory bindingGraphFactory;
-  private CorpusPath corpusPath;
-  private KeyVNameFactory keys;
-  @Inject BindingFactory bindingFactory;
-  @Inject DelegateDeclaration.Factory delegateDeclarationFactory;
-  @Inject MultibindingDeclaration.Factory multibindingDeclarationFactory;
-  @Inject OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory;
-  @Inject SubcomponentDeclaration.Factory subcomponentDeclarationFactory;
-  @Inject KeyFactory keyFactory;
-  @Inject DaggerTypes types;
-  @Inject DaggerElements elements;
+  @Inject KytheBindingGraphFactory bindingGraphFactory;
 
   @Override
   public Void visitClassDef(JCClassDecl tree, Void p) {
     TypeElement type = MoreElements.asType(getElement(tree));
     bindingGraphFactory.create(type).ifPresent(this::addNodesForGraph);
-
-    if (getModuleAnnotation(type).isPresent()) {
-      subcomponentDeclarationFactory.forModule(type).forEach(this::addSubcomponentDeclarationNode);
-    }
-
-    Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(type);
-    if (componentAnnotation.isPresent()) {
-      addBindingAndDependencyEdges(bindingFactory.componentBinding(type));
-      for (TypeMirror dependency : getComponentDependencies(componentAnnotation.get())) {
-        ComponentRequirement requirement = ComponentRequirement.forDependency(dependency);
-        addBindingAndDependencyEdges(bindingFactory.componentDependencyBinding(requirement));
-      }
-    }
-
-    MembersInjectionBinding membersInjectionBinding =
-        bindingFactory.membersInjectionBinding(
-            MoreTypes.asDeclared(type.asType()), Optional.empty());
-    for (InjectionSite injectionSite : membersInjectionBinding.injectionSites()) {
-      // ignore inherited injection sites
-      if (injectionSite.element().getEnclosingElement().equals(type)) {
-        injectionSite.dependencies().forEach(this::addDependencyEdge);
-      }
-    }
-
-    if (!membersInjectionBinding.injectionSites().isEmpty()) {
-      Key membersInjectorKey =
-          Key.builder(types.wrapType(membersInjectionBinding.key().type(), MembersInjector.class))
-              .build();
-      addBindingDeclarationEdge(membersInjectorKey, type);
-    }
-
     return super.visitClassDef(tree, p);
   }
 
-  @Override
-  public Void visitMethodDef(JCMethodDecl tree, Void p) {
-    ExecutableElement element = MoreElements.asExecutable(getElement(tree));
-    if (isAnnotationPresent(element, Inject.class) && element.getKind().equals(CONSTRUCTOR)) {
-      addBindingAndDependencyEdges(bindingFactory.injectionBinding(element, Optional.empty()));
-    } else {
-      TypeElement enclosingType = MoreElements.asType(element.getEnclosingElement());
-      if (isAnnotationPresent(element, Provides.class)){
-        addBindingAndDependencyEdges(bindingFactory.providesMethodBinding(element, enclosingType));
-      } else if (isAnnotationPresent(element, Produces.class)) {
-        addBindingAndDependencyEdges(bindingFactory.producesMethodBinding(element, enclosingType));
-      } else if (isAnnotationPresent(element, Binds.class)) {
-        DelegateDeclaration delegateDeclaration =
-            delegateDeclarationFactory.create(element, enclosingType);
-        addBindingDeclarationEdge(delegateDeclaration);
-        addDependencyEdge(delegateDeclaration.delegateRequest());
-      } else if (isAnnotationPresent(element, Multibinds.class)) {
-        addBindingDeclarationEdge(
-            multibindingDeclarationFactory.forMultibindsMethod(element, enclosingType));
-      } else if (isAnnotationPresent(element, BindsOptionalOf.class)) {
-        addOptionalBindingDeclarationEdge(
-            optionalBindingDeclarationFactory.forMethod(element, enclosingType));
-      } else if (isAnnotationPresent(element, BindsInstance.class)) {
-        VariableElement parameter = getOnlyElement(element.getParameters());
-        Key key = Key.builder(parameter.asType()).qualifier(getQualifier(parameter)).build();
-        addBindingDeclarationEdge(key, element);
+  private void addNodesForGraph(BindingGraph graph) {
+    for (ResolvedBindings resolvedBinding : graph.resolvedBindings()) {
+      for (Binding binding : resolvedBinding.bindings()) {
+        for (DependencyRequest dependency : binding.explicitDependencies()) {
+          addEdgesForDependencyRequest(dependency, dependency.key(), graph);
+        }
       }
     }
-    return super.visitMethodDef(tree, p);
-  }
 
-  private void addNodesForGraph(BindingGraph graph) {
     for (ComponentDescriptor.ComponentMethodDescriptor componentMethod :
         graph.componentDescriptor().componentMethods()) {
-      componentMethod.dependencyRequest().ifPresent(this::addDependencyEdge);
+      componentMethod
+          .dependencyRequest()
+          .ifPresent(request -> addEdgesForDependencyRequest(request, request.key(), graph));
     }
 
-    graph
-        .contributionBindings()
-        .values()
-        .stream()
-        .flatMap(resolvedBindings -> resolvedBindings.contributionBindings().stream())
-        .filter(binding -> binding.kind().equals(BindingKind.OPTIONAL))
-        .forEach(this::addOptionalBindingJoinsEdge);
-  }
-
-  private void addBindingAndDependencyEdges(Binding binding) {
-    addBindingDeclarationEdge(binding);
-    binding.dependencies().forEach(this::addDependencyEdge);
-  }
-
-  private void addBindingDeclarationEdge(BindingDeclaration declaration) {
-    addBindingDeclarationEdge(declaration.key(), declaration.bindingElement().get());
+    graph.subgraphs().forEach(this::addNodesForGraph);
   }
 
   /**
-   * Adds a {@code defines/binding} edge from {@code bindingElement} to the node for {@code key}.
+   * Add {@code /inject/satisfiedby} edges from {@code dependency}'s {@link
+   * DependencyRequest#requestElement()} to any {@link BindingDeclaration#bindingElement() binding
+   * elements} that satisfy the request.
+   *
+   * <p>This collapses requests for synthetic bindings so that a request for a multibound key
+   * points to all of the contributions for the multibound object. It does so by recursively calling
+   * this method, with each dependency's key as the {@code targetKey}.
    */
-  private void addBindingDeclarationEdge(Key key, Element bindingElement) {
-    if (hasTypeVariable(key.type())) {
+  private void addEdgesForDependencyRequest(
+      DependencyRequest dependency, Key targetKey, BindingGraph graph) {
+    if (!dependency.requestElement().isPresent()) {
       return;
     }
-    EntrySet bindingAnchor = anchor(bindingElementSpan(bindingElement));
-    entrySets.emitEdge(bindingAnchor, DEFINES_BINDING, keyNode(key));
-  }
-
-  private Span bindingElementSpan(Element bindingElement) {
-    Name name =
-        bindingElement.getKind().equals(ElementKind.CONSTRUCTOR)
-            ? bindingElement.getEnclosingElement().getSimpleName()
-            : bindingElement.getSimpleName();
-    return span(name, getTree(bindingElement));
-  }
-
-  /**
-   * Adds a {@code ref} edge from {@code dependencyRequest} to its {@link DependencyRequest#key()
-   * key's} node.
-   */
-  private void addDependencyEdge(DependencyRequest dependencyRequest) {
-    if (!dependencyRequest.requestElement().isPresent()
-        || hasTypeVariable(dependencyRequest.key().type())) {
-      return;
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(dependency.kind(), targetKey);
+    for (Binding binding : resolvedBindings.bindings()) {
+      if (binding.bindingElement().isPresent()) {
+        addDependencyEdge(dependency, binding);
+      } else {
+        for (DependencyRequest subsequentDependency : binding.explicitDependencies()) {
+          addEdgesForDependencyRequest(dependency, subsequentDependency.key(), graph);
+        }
+      }
+    }
+    for (BindingDeclaration bindingDeclaration :
+        Iterables.concat(
+            resolvedBindings.multibindingDeclarations(),
+            resolvedBindings.optionalBindingDeclarations())) {
+      addDependencyEdge(dependency, bindingDeclaration);
     }
-    EntrySet dependencyRequestAnchor = anchor(dependencyRequestSpan(dependencyRequest));
-    entrySets.emitEdge(dependencyRequestAnchor, REF, keyNode(dependencyRequest.key()));
   }
 
-  private Span dependencyRequestSpan(DependencyRequest dependency) {
+  private void addDependencyEdge(
+      DependencyRequest dependency, BindingDeclaration bindingDeclaration) {
     Element requestElement = dependency.requestElement().get();
-    return span(requestElement.getSimpleName(), getTree(requestElement));
-  }
-
-  private void addSubcomponentDeclarationNode(SubcomponentDeclaration declaration) {
-    TypeElement module = declaration.contributingModule().get();
-    // getTree(bindingElement) doesn't seem to work as expected, and instead searches for the
-    // subcomponents() attribute's Tree in dagger/Module.java
-    JCTree tree = trees.getTree(module, declaration.moduleAnnotation());
-    EntrySet bindingAnchor = anchor(span(declaration.bindingElement().get().getSimpleName(), tree));
-    entrySets.emitEdge(bindingAnchor, DEFINES_BINDING, keyNode(declaration.key()));
-  }
-
-  /**
-   * Adds a {@code defines/binding} edge from {@code declaration}'s {@link
-   * OptionalBindingDeclaration#bindingElement()} to {@link #bindsOptionalOfKeyNode(Key)}. When a
-   * binding is resolved to {@code declaration}, a {@code /dagger/joins} edge will be added from the
-   * binding's key to the {@link #bindsOptionalOfKeyNode(Key)}. Kythe's post-processing will "merge"
-   * the {@code /dagger/joins} edge so that tools see edges from the {@code @BindsOptionalOf} method
-   * directly to the dependency requests that are resolved by this declaration and the bindings (if
-   * any) that satisfy it.
-   *
-   * <p>This process is used because {@code @BindsOptionalOf} methods may bind several binding keys,
-   * some of which may reference optional types (like {@link com.google.common.base.Optional}) that
-   * are not present in the current compilation, but will be when a component is resolved.
-   */
-  private void addOptionalBindingDeclarationEdge(OptionalBindingDeclaration declaration) {
-    EntrySet declarationAnchor = anchor(bindingElementSpan(declaration.bindingElement().get()));
-    entrySets.emitEdge(
-        declarationAnchor, DEFINES_BINDING, bindsOptionalOfKeyNode(declaration.key()));
-  }
-
-  /**
-   * Adds a {@code /dagger/joins} edge from {@code binding}'s key to the synthetic
-   * {@code @BindsOptionalOf} node created in {@link
-   * #addOptionalBindingDeclarationEdge(OptionalBindingDeclaration)}.
-   */
-  private void addOptionalBindingJoinsEdge(ContributionBinding binding) {
-    emitDaggerJoinsEdge(
-        keyNode(binding.key()),
-        bindsOptionalOfKeyNode(keyFactory.unwrapOptional(binding.key()).get()));
-  }
-
-  /** A synthetic node for a {@link BindsOptionalOf} method. */
-  private EntrySet bindsOptionalOfKeyNode(Key key) {
-    EntrySet node = newInjectNode("key", String.format("@BindsOptionalOf %s", formatKey(key)));
-    entrySets.emitEdge(node, PARAM, bindsOptionalOfTypeApplication(key), 0);
-    addEdgeFromKeyToQualifier(node, key);
-    return node;
-  }
-
-  private EntrySet bindsOptionalOfTypeApplication(Key optionalBindingDeclarationKey) {
-    EntrySet genericBindsOptionalOfNode = newNode(NodeKind.ABS, "abs for @BindsOptionalOf");
-    EntrySet bindsOptionalOfTypeVariable = newNode(NodeKind.ABS_VAR, "absvar for @BindsOptionalOf");
-    entrySets.emitEdge(genericBindsOptionalOfNode, PARAM, bindsOptionalOfTypeVariable, 0);
-
-    return entrySets.newTApplyAndEmit(
-        genericBindsOptionalOfNode.getVName(),
-        hasTypeVariable(optionalBindingDeclarationKey.type())
-            ? ImmutableList.of() /* // TODO(ronshapiro): should this have a /dagger/joins edge?
-             Or should it reuse bindsOptionalOfTypeVariable?*/
-            : ImmutableList.of(keys.vname(optionalBindingDeclarationKey)));
-  }
-
-  private Span span(Name name, JCTree tree) {
-    return kytheGraph.findIdentifier(name, tree.getPreferredPosition()).get();
-  }
-
-  private EntrySet keyNode(Key key) {
-    EntrySet keyNode = newInjectNode("key", formatKey(key));
-
-    entrySets.emitEdge(keyNode.getVName(), PARAM, keys.vname(key), 0);
-    addEdgeFromKeyToQualifier(keyNode, key);
-
-    return keyNode;
-  }
-
-  private void addEdgeFromKeyToQualifier(EntrySet source, Key key) {
-    key.qualifier()
-        .map(qualifier -> newInjectNode("qualifier", formatAnnotation(qualifier)))
-        .ifPresent(qualifier -> entrySets.emitEdge(source, PARAM, qualifier, 1));
-  }
-
-  /** Adds a new node in the {@code inject/} namespace. */
-  private EntrySet newInjectNode(String nodeKind, String format) {
-    return completeNodeAndEmit(
-        entrySets
-            .newNode("inject/" + nodeKind)
-            .setSignature(String.format("inject_%s:%s", nodeKind, format)));
-  }
-
-  private EntrySet newNode(NodeKind nodeKind, String signature) {
-    return completeNodeAndEmit(entrySets.newNode(nodeKind).setSignature(signature));
-  }
+    Element bindingElement = bindingDeclaration.bindingElement().get();
+    Optional<VName> requestElementNode = jvmNode(requestElement);
+    Optional<VName> bindingElementNode = jvmNode(bindingElement);
+    if (requestElementNode.isPresent() && bindingElementNode.isPresent()) {
+      new EntrySet.Builder(
+              requestElementNode.get(), "/inject/satisfiedby", bindingElementNode.get())
+          .build()
+          .emit(emitter);
+      // TODO(ronshapiro): emit facts about the component that satisfies the edge
+    } else {
+      List<String> missingNodes = new ArrayList<>();
+      if (!requestElementNode.isPresent()) {
+        missingNodes.add("requestElement: " + requestElement);
+      }
+      if (!bindingElementNode.isPresent()) {
+        missingNodes.add("bindingElement: " + bindingElement);
+      }
 
-  private EntrySet completeNodeAndEmit(NodeBuilder nodeBuilder) {
-    EntrySet node = nodeBuilder.setCorpusPath(corpusPath).build();
-    node.emit(emitter);
-    return node;
+      // TODO(ronshapiro): use Flogger
+      logger.warning(String.format("Missing JVM nodes: %s ", missingNodes));
+    }
   }
 
-  private EntrySet anchor(Span location) {
-    return entrySets.newAnchorAndEmit(fileVName, location, null);
+  private Optional<VName> jvmNode(Element element) {
+    return kytheGraph.getJvmNode((Symbol) element).map(KytheNode::getVName);
   }
 
   private Element getElement(Tree tree) {
     return trees.getElement(trees.getPath(compilationUnit, tree));
   }
 
-  /**
-   * A wrapper for {@link JavacTrees#getTree(Element)} that checks for {@code null} and reports
-   * debug information in the exception.
-   *
-   * <p>This should only be necessary in cases where there's a bug in the plugin, but it makes
-   * fixing the bug significantly easier.
-   */
-  private JCTree getTree(Element element) {
-    return checkNotNull(
-        trees.getTree(element),
-        "No Tree available for %s. This likely means that the element is being accessed from a "
-            + "different compilation. The current file being scanned is: %s.",
-        element,
-        fileVName.getPath());
-  }
-
-  private void emitDaggerJoinsEdge(EntrySet source, EntrySet target) {
-    new EntrySet.Builder(source.getVName(), "/dagger/joins", target.getVName())
-        .build()
-        .emit(emitter);
-  }
-
   @Override
   public void run(
       JCCompilationUnit compilationUnit, KytheEntrySets entrySets, KytheGraph kytheGraph) {
@@ -368,19 +161,13 @@ public void run(
       Context javaContext = kytheGraph.getJavaContext();
       trees = JavacTrees.instance(javaContext);
       emitter = entrySets.getEmitter();
-      bindingGraphFactory =
-          new KytheBindingGraphFactory(
-              JavacTypes.instance(javaContext), JavacElements.instance(javaContext));
       DaggerDaggerKythePlugin_PluginComponent.builder()
           .types(JavacTypes.instance(javaContext))
           .elements(JavacElements.instance(javaContext))
           .build()
           .inject(this);
-      keys = new KeyVNameFactory(kytheGraph, entrySets, emitter);
     }
     this.compilationUnit = compilationUnit;
-    fileVName = kytheGraph.getNode(compilationUnit).get().getVName();
-    corpusPath = new CorpusPath(fileVName.getCorpus(), "", "");
     super.run(compilationUnit, entrySets, kytheGraph);
   }
 
diff --git a/java/dagger/internal/codegen/KeyVNameFactory.java b/java/dagger/internal/codegen/KeyVNameFactory.java
deleted file mode 100644
index 9849b0a69..000000000
--- a/java/dagger/internal/codegen/KeyVNameFactory.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static dagger.internal.codegen.KytheFormatting.formatKey;
-
-import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableList;
-import com.google.devtools.kythe.analyzers.base.EntrySet;
-import com.google.devtools.kythe.analyzers.base.FactEmitter;
-import com.google.devtools.kythe.analyzers.base.KytheEntrySets;
-import com.google.devtools.kythe.analyzers.base.NodeKind;
-import com.google.devtools.kythe.analyzers.java.Plugin.KytheGraph;
-import com.google.devtools.kythe.proto.Storage.VName;
-import com.sun.tools.javac.code.Symbol.ClassSymbol;
-import dagger.model.Key;
-import java.util.EnumMap;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.PrimitiveType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.SimpleTypeVisitor8;
-
-// TODO(ronshapiro): move this to a dagger.kythe package once Key is a public API
-/** Factory for {@link VName}s of Dagger {@link Key}s. */
-final class KeyVNameFactory {
-  private final KytheGraph kytheGraph;
-  private final KytheEntrySets entrySets;
-  private final FactEmitter emitter;
-  private final EnumMap<TypeKind, VName> typeKindVNames = new EnumMap<>(TypeKind.class);
-
-  // TODO(ronshapiro): use @Inject
-  KeyVNameFactory(KytheGraph kytheGraph, KytheEntrySets entrySets, FactEmitter emitter) {
-    this.kytheGraph = kytheGraph;
-    this.entrySets = entrySets;
-    this.emitter = emitter;
-  }
-
-  VName vname(Key key) {
-    return key.type().accept(new TypeExtractor(), key);
-  }
-
-  private VName forTypeKind(TypeKind typeKind) {
-    return typeKindVNames.computeIfAbsent(
-        typeKind, kind -> entrySets.getBuiltinVName(kind.toString().toLowerCase()));
-  }
-
-  private class TypeExtractor extends SimpleTypeVisitor8<VName, Key> {
-    @Override
-    public VName visitPrimitive(PrimitiveType primitiveType, Key key) {
-      return forTypeKind(primitiveType.getKind());
-    }
-
-    @Override
-    public VName visitArray(ArrayType arrayType, Key key) {
-      return entrySets
-          .newTApplyAndEmit(
-              forTypeKind(TypeKind.ARRAY),
-              ImmutableList.of(arrayType.getComponentType().accept(this, key)))
-          .getVName();
-    }
-
-    @Override
-    public VName visitDeclared(DeclaredType declaredType, Key key) {
-      ClassSymbol classSymbol = (ClassSymbol) MoreTypes.asTypeElement(declaredType);
-      // TODO(user,ronshapiro): is this correct? Will this be the VName for the Symbol but not
-      // the *type*? Also, this seems to return null for all boxed primitive types if boxed
-      // primitive is not mentioned in the compilation (i.e. if you @Provides int and then request
-      // int from a binding, but never java.lang.Integer) - we have to synthesize those
-      VName rawType =
-          kytheGraph
-              .getNode(classSymbol)
-              .orElseThrow(() -> new TypeNotPresentException(classSymbol.toString(), null))
-              .getVName();
-      if (classSymbol.getTypeParameters().isEmpty()) {
-        return rawType;
-      }
-      ImmutableList.Builder<VName> typeArguments = ImmutableList.builder();
-      for (TypeMirror typeArgument : declaredType.getTypeArguments()) {
-        typeArguments.add(typeArgument.accept(this, key));
-      }
-      return entrySets.newTApplyAndEmit(rawType, typeArguments.build()).getVName();
-    }
-
-    private int wildcardCounter = 0;
-
-    @Override
-    public VName visitWildcard(WildcardType wildcardType, Key key) {
-      EntrySet wildcardNode =
-          entrySets
-              .newNode(NodeKind.ABS_VAR)
-              // wildcards should be unique among other keys with similar wildcards, but similar
-              // against equal keys
-              .addSignatureSalt(formatKey(key) + wildcardCounter++)
-              .build();
-      wildcardNode.emit(emitter);
-      return wildcardNode.getVName();
-    }
-
-    @Override
-    public VName visitTypeVariable(TypeVariable typeVariable, Key key) {
-      throw new IllegalArgumentException(
-          "Type Variables are not allowed in resolved bindings, found in key: " + key);
-    }
-  }
-}
diff --git a/java/dagger/internal/codegen/KytheBindingGraphFactory.java b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
index 4b6d1aad1..ba65f8ed4 100644
--- a/java/dagger/internal/codegen/KytheBindingGraphFactory.java
+++ b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
@@ -21,6 +21,7 @@
 import dagger.producers.ProductionComponent;
 import java.util.Optional;
 import javax.annotation.processing.Messager;
+import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
@@ -39,6 +40,7 @@
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraphFactory bindingGraphFactory;
 
+  @Inject
   KytheBindingGraphFactory(Types types, Elements elements) {
     DaggerElements daggerElements = new DaggerElements(elements, types);
     DaggerTypes daggerTypes = new DaggerTypes(types, daggerElements);
diff --git a/java/dagger/internal/codegen/KytheFormatting.java b/java/dagger/internal/codegen/KytheFormatting.java
deleted file mode 100644
index 2c926978f..000000000
--- a/java/dagger/internal/codegen/KytheFormatting.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
-
-import com.google.auto.common.MoreTypes;
-import com.squareup.javapoet.CodeBlock;
-import dagger.model.Key;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.function.Consumer;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.AnnotationValueVisitor;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleAnnotationValueVisitor8;
-
-final class KytheFormatting {
-  /**
-   * Produces a {@link String} representation of a {@link Key} in a deterministic fashion. The
-   * result is a combination of the key's {@link Key#type() type} and an optional {@link
-   * Key#qualifier() qualifier}.
-   */
-  static String formatKey(Key key) {
-    StringBuilder builder = new StringBuilder();
-    if (key.qualifier().isPresent()) {
-      formatAnnotation(key.qualifier().get(), builder);
-      builder.append(' ');
-    }
-    return builder.append(key.type().toString()).toString();
-  }
-
-  /**
-   * Produces a string version of {@code annotation} with its attributes and values, including any
-   * defaults. Attributes are presented in the order in which they are defined in the {@link
-   * AnnotationMirror#getAnnotationType() annotation type}.
-   */
-  static String formatAnnotation(AnnotationMirror annotation) {
-    StringBuilder builder = new StringBuilder();
-    formatAnnotation(annotation, builder);
-    return builder.toString();
-  }
-
-  private static void formatAnnotation(AnnotationMirror annotation, StringBuilder stringBuilder) {
-    stringBuilder.append('@').append(MoreTypes.asTypeElement(annotation.getAnnotationType()));
-    Map<ExecutableElement, AnnotationValue> annotationValues =
-        getAnnotationValuesWithDefaults(annotation);
-    if (!annotationValues.isEmpty()) {
-      stringBuilder.append('(');
-      appendList(
-          stringBuilder,
-          annotationValues.entrySet(),
-          entry -> {
-            stringBuilder.append(entry.getKey().getSimpleName()).append('=');
-            entry.getValue().accept(ANNOTATION_VALUE_FORMATTER, stringBuilder);
-          });
-      stringBuilder.append(')');
-    }
-  }
-
-  private static final AnnotationValueVisitor<Void, StringBuilder> ANNOTATION_VALUE_FORMATTER =
-      new SimpleAnnotationValueVisitor8<Void, StringBuilder>() {
-        @Override
-        public Void visitAnnotation(AnnotationMirror innerAnnotation, StringBuilder stringBuilder) {
-          formatAnnotation(innerAnnotation, stringBuilder);
-          return null;
-        }
-
-        @Override
-        public Void visitArray(List<? extends AnnotationValue> list, StringBuilder stringBuilder) {
-          stringBuilder.append('{');
-          appendList(stringBuilder, list, value -> value.accept(this, stringBuilder));
-          stringBuilder.append('}');
-          return null;
-        }
-
-        @Override
-        public Void visitEnumConstant(VariableElement enumConstant, StringBuilder stringBuilder) {
-          stringBuilder.append(enumConstant.getSimpleName());
-          return null;
-        }
-
-        @Override
-        public Void visitType(TypeMirror typeMirror, StringBuilder stringBuilder) {
-          stringBuilder.append(typeMirror).append(".class");
-          return null;
-        }
-
-        @Override
-        protected Void defaultAction(Object value, StringBuilder stringBuilder) {
-          stringBuilder.append(value);
-          return null;
-        }
-
-        @Override
-        public Void visitString(String value, StringBuilder stringBuilder) {
-          stringBuilder.append(CodeBlock.of("$S", value));
-          return null;
-        }
-      };
-
-  private static <T> void appendList(
-      StringBuilder stringBuilder, Iterable<T> iterable, Consumer<T> consumer) {
-    Iterator<T> iterator = iterable.iterator();
-    while (iterator.hasNext()) {
-      consumer.accept(iterator.next());
-      if (iterator.hasNext()) {
-        stringBuilder.append(", ");
-      }
-    }
-  }
-}
