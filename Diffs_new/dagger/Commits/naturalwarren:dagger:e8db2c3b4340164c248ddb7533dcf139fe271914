diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index 0c7fb960f..5e4ebc144 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -21,6 +21,7 @@
 import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
@@ -2071,6 +2072,7 @@ public void subcomponentBindingConflictsWithParent() {
         .onLine(8);
   }
 
+
   @Test
   public void subcomponentBindingConflictsWithParentWhenSubcomponentPerformsMembersInjection() {
     JavaFileObject parent =
@@ -2265,6 +2267,285 @@ public void subcomponentBindingConflictsWithParentWithNullableViolationAsWarning
         .onLine(9);
   }
 
+  @Test
+  public void subcomponentGeneratedCorrectlyWhenBothComponentsPerformMembersInjection() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Component(modules = Parent.ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "  void inject(Injected injected);",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
+            "    @Provides static Object object() {",
+            "      return \"parent\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  void inject(Injected injected);",
+            "}");
+    JavaFileObject injected =
+        JavaFileObjects.forSourceLines(
+            "test.Injected",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Injected {",
+            "  @Inject Object object;",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private MembersInjector<Injected> injectedMembersInjector;",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder()",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.injectedMembersInjector = Injected_MembersInjector",
+            "        .create(Parent_ParentModule_ObjectFactory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public void inject(Injected injected) {",
+            "    injectedMembersInjector.injectMembers(injected);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return new ChildImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder parentModule(Parent.ParentModule parentModule) {",
+            "      Preconditions.checkNotNull(parentModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildImpl implements Child {",
+            "    private MembersInjector<Injected> injectedMembersInjector;",
+            "",
+            "    private ChildImpl() {",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      this.injectedMembersInjector = Injected_MembersInjector",
+            "          .create(Parent_ParentModule_ObjectFactory.create());",
+            "    }",
+            "",
+            "    @Override",
+            "    public void inject(Injected injected) {",
+            "      injectedMembersInjector.injectMembers(injected);",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, child, injected))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void subcomponentGeneratedCorrectlyWhenBothComponentsPerformMultiboundMembersInjection() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Component(modules = Parent.ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "  void inject(Injected injected);",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
+            "    @Provides @IntoSet static Object object() {",
+            "      return \"parent\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Subcomponent(modules = Child.ChildModule.class)",
+            "interface Child {",
+            "  void inject(Injected injected);",
+            "",
+            "  @Module",
+            "  static class ChildModule {",
+            "    @Provides @IntoSet static Object object() {",
+            "      return \"child\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject injected =
+        JavaFileObjects.forSourceLines(
+            "test.Injected",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import java.util.Set;",
+            "",
+            "final class Injected {",
+            "  @Inject Set<Object> object;",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Preconditions;",
+            "import dagger.internal.SetFactory",
+            "import java.util.Set",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private Provider<Set<Object>> setOfObjectProvider;",
+            "  private MembersInjector<Injected> injectedMembersInjector;",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.setOfObjectProvider = SetFactory.<Object>builder(1, 0)",
+            "        .addProvider(Parent_ParentModule_ObjectFactory.create())",
+            "        .build();",
+            "    this.injectedMembersInjector = Injected_MembersInjector",
+            "        .create(setOfObjectProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public void inject(Injected injected) {",
+            "    injectedMembersInjector.injectMembers(injected);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return new ChildImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder parentModule(Parent.ParentModule parentModule) {",
+            "      Preconditions.checkNotNull(parentModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildImpl implements Child {",
+            "    private Provider<Set<Object>> setOfObjectProvider;",
+            "    private MembersInjector<Injected> injectedMembersInjector;",
+            "",
+            "    private ChildImpl() {",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      this.setOfObjectProvider = SetFactory.<Object>builder(2, 0)",
+            "          .addProvider(Parent_ParentModule_ObjectFactory.create())",
+            "          .addProvider(Child_ChildModule_ObjectFactory.create())",
+            "          .build();",
+            "",
+            "      this.injectedMembersInjector = Injected_MembersInjector",
+            "          .create(setOfObjectProvider);",
+            "    }",
+            "",
+            "    @Override",
+            "    public void inject(Injected injected) {",
+            "      injectedMembersInjector.injectMembers(injected);",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, child, injected))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
   @Test
   public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
     JavaFileObject parent =
