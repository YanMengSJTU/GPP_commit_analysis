diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 5b568508c..aeec8e2ff 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -197,6 +197,7 @@ java_library(
 java_library(
     name = "internal_validation",
     srcs = [
+        "BindingCycleValidation.java",
         "BindingGraphValidationModule.java",
         "DuplicateBindingsValidation.java",
         "IncompatiblyScopedBindingsValidation.java",
diff --git a/java/dagger/internal/codegen/BindingCycleValidation.java b/java/dagger/internal/codegen/BindingCycleValidation.java
new file mode 100644
index 000000000..2d6108408
--- /dev/null
+++ b/java/dagger/internal/codegen/BindingCycleValidation.java
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.getLast;
+import static com.google.common.collect.Iterables.limit;
+import static com.google.common.collect.Iterables.skip;
+import static com.google.common.collect.Sets.newHashSetWithExpectedSize;
+import static dagger.internal.codegen.DaggerGraphs.shortestPath;
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static dagger.internal.codegen.DaggerStreams.toImmutableList;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.RequestKinds.extractKeyType;
+import static dagger.internal.codegen.RequestKinds.getRequestKind;
+import static java.util.Comparator.comparingInt;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.graph.EndpointPair;
+import com.google.common.graph.ImmutableNetwork;
+import com.google.common.graph.MutableNetwork;
+import com.google.common.graph.NetworkBuilder;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.Node;
+import dagger.model.BindingKind;
+import dagger.model.DependencyRequest;
+import dagger.model.RequestKind;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Stream;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.lang.model.type.TypeMirror;
+
+/** Reports errors for binding cycles. */
+final class BindingCycleValidation implements BindingGraphPlugin {
+
+  private final DependencyRequestFormatter dependencyRequestFormatter;
+
+  @Inject
+  BindingCycleValidation(DependencyRequestFormatter dependencyRequestFormatter) {
+    this.dependencyRequestFormatter = dependencyRequestFormatter;
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/BindingCycle";
+  }
+
+  @Override
+  public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    ImmutableNetwork<Node, DependencyEdge> dependencyGraph =
+        nonCycleBreakingDependencyGraph(bindingGraph);
+    // Check each endpoint pair only once, no matter how many parallel edges connect them.
+    Set<EndpointPair<Node>> dependencyEndpointPairs = dependencyGraph.asGraph().edges();
+    Set<EndpointPair<Node>> visited = newHashSetWithExpectedSize(dependencyEndpointPairs.size());
+    for (EndpointPair<Node> endpointPair : dependencyEndpointPairs) {
+      cycleContainingEndpointPair(endpointPair, dependencyGraph, visited)
+          .ifPresent(cycle -> reportCycle(cycle, bindingGraph, diagnosticReporter));
+    }
+  }
+
+  private Optional<Cycle<Node>> cycleContainingEndpointPair(
+      EndpointPair<Node> endpoints,
+      ImmutableNetwork<Node, DependencyEdge> dependencyGraph,
+      Set<EndpointPair<Node>> visited) {
+    if (!visited.add(endpoints)) {
+      // don't recheck endpoints we already know are part of a cycle
+      return Optional.empty();
+    }
+
+    // If there's a path from the target back to the source, there's a cycle.
+    ImmutableList<Node> cycleNodes =
+        shortestPath(dependencyGraph, endpoints.target(), endpoints.source());
+    if (cycleNodes.isEmpty()) {
+      return Optional.empty();
+    }
+
+    Cycle<Node> cycle = Cycle.fromPath(cycleNodes);
+    visited.addAll(cycle.endpointPairs()); // no need to check any edge in this cycle again
+    return Optional.of(cycle);
+  }
+
+  /**
+   * Reports a dependency cycle at the dependency into the cycle that is closest to an entry point.
+   */
+  private void reportCycle(
+      Cycle<Node> cycle, BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    ImmutableList<Node> path = shortestPathToCycleFromAnEntryPoint(cycle, bindingGraph);
+    Node cycleStartNode = path.get(path.size() - 1);
+    Node previousNode = path.get(path.size() - 2);
+    DependencyEdge dependencyToReport =
+        chooseDependencyEdgeConnecting(previousNode, cycleStartNode, bindingGraph);
+    diagnosticReporter.reportDependency(
+        ERROR, dependencyToReport, errorMessage(cycle.shift(cycleStartNode), bindingGraph));
+  }
+
+  private ImmutableList<Node> shortestPathToCycleFromAnEntryPoint(
+      Cycle<Node> cycle, BindingGraph bindingGraph) {
+    Node someCycleNode = cycle.nodes().asList().get(0);
+    return bindingGraph
+        .componentNodes()
+        .stream()
+        .map(componentNode -> shortestPath(bindingGraph, componentNode, someCycleNode))
+        // Ignore paths that go through subcomponents by requiring all nodes after the first to be
+        // BindingNodes. We can't just use nonCycleBreakingDependencyGraph because that filters out
+        // edges that might break a cycle, but those edges might still be part of the shortest path
+        // TO a cycle.
+        .filter(path -> path.stream().skip(1).allMatch(node -> node instanceof BindingNode))
+        .map(path -> subpathToCycle(path, cycle))
+        .min(comparingInt(ImmutableList::size))
+        .get();
+  }
+
+  /**
+   * Returns the subpath from the head of {@code path} to the first node in {@code path} that's in
+   * the cycle.
+   */
+  private ImmutableList<Node> subpathToCycle(ImmutableList<Node> path, Cycle<Node> cycle) {
+    ImmutableList.Builder<Node> subpath = ImmutableList.builder();
+    for (Node node : path) {
+      subpath.add(node);
+      if (cycle.nodes().contains(node)) {
+        return subpath.build();
+      }
+    }
+    throw new IllegalArgumentException(
+        "path " + path + " doesn't contain any nodes in cycle " + cycle);
+  }
+
+  private String errorMessage(Cycle<Node> cycle, BindingGraph graph) {
+    StringBuilder message = new StringBuilder("Found a dependency cycle:");
+    ImmutableList<DependencyRequest> cycleRequests =
+        cycle
+            .endpointPairs()
+            .stream()
+            // TODO(dpb): Would be nice to take the dependency graph here.
+            .map(endpointPair -> nonCycleBreakingEdge(endpointPair, graph))
+            .map(DependencyEdge::dependencyRequest)
+            .collect(toImmutableList())
+            .reverse();
+    dependencyRequestFormatter.formatIndentedList(message, cycleRequests, 0);
+    return message.toString();
+  }
+
+  /**
+   * Returns one of the edges between two nodes that doesn't {@linkplain
+   * #breaksCycle(DependencyEdge, BindingGraph) break} a cycle.
+   */
+  private DependencyEdge nonCycleBreakingEdge(EndpointPair<Node> endpointPair, BindingGraph graph) {
+    return graph
+        .edgesConnecting(endpointPair.source(), endpointPair.target())
+        .stream()
+        .flatMap(instancesOf(DependencyEdge.class))
+        .filter(edge -> !breaksCycle(edge, graph))
+        .findFirst()
+        .get();
+  }
+
+  private boolean breaksCycle(DependencyEdge edge, BindingGraph graph) {
+    if (edge.dependencyRequest().key().multibindingContributionIdentifier().isPresent()) {
+      return false;
+    }
+    if (breaksCycle(edge.dependencyRequest().key().type(), edge.dependencyRequest().kind())) {
+      return true;
+    }
+    Node target = graph.incidentNodes(edge).target();
+    if (target instanceof BindingNode
+        && ((BindingNode) target).binding().kind().equals(BindingKind.OPTIONAL)) {
+      /* For @BindsOptionalOf bindings, unwrap the type inside the Optional. If the unwrapped type
+       * breaks the cycle, so does the optional binding. */
+      TypeMirror optionalValueType = OptionalType.from(edge.dependencyRequest().key()).valueType();
+      RequestKind requestKind = getRequestKind(optionalValueType);
+      return breaksCycle(extractKeyType(requestKind, optionalValueType), requestKind);
+    }
+    return false;
+  }
+
+  private boolean breaksCycle(TypeMirror requestedType, RequestKind requestKind) {
+    switch (requestKind) {
+      case PROVIDER:
+      case LAZY:
+      case PROVIDER_OF_LAZY:
+        return true;
+
+      case INSTANCE:
+        if (MapType.isMap(requestedType)) {
+          MapType mapType = MapType.from(requestedType);
+          return !mapType.isRawType() && mapType.valuesAreTypeOf(Provider.class);
+        }
+        // fall through
+
+      default:
+        return false;
+    }
+  }
+
+  private DependencyEdge chooseDependencyEdgeConnecting(
+      Node source, Node target, BindingGraph bindingGraph) {
+    return bindingGraph
+        .edgesConnecting(source, target)
+        .stream()
+        .flatMap(instancesOf(DependencyEdge.class))
+        .findFirst()
+        .get();
+  }
+
+  /** Returns the subgraph containing only {@link DependencyEdge}s that would not break a cycle. */
+  private ImmutableNetwork<Node, DependencyEdge> nonCycleBreakingDependencyGraph(
+      BindingGraph bindingGraph) {
+    MutableNetwork<Node, DependencyEdge> dependencyNetwork =
+        NetworkBuilder.directed()
+            .allowsParallelEdges(true)
+            .allowsSelfLoops(true)
+            .nodeOrder(bindingGraph.nodeOrder())
+            .edgeOrder(bindingGraph.edgeOrder())
+            .expectedNodeCount(
+                bindingGraph.bindingNodes().size() + bindingGraph.componentNodes().size())
+            .expectedEdgeCount(bindingGraph.dependencyEdges().size())
+            .build();
+    bindingGraph
+        .dependencyEdges()
+        .stream()
+        .filter(edge -> !breaksCycle(edge, bindingGraph))
+        .forEach(
+            edge -> {
+              EndpointPair<Node> endpoints = bindingGraph.incidentNodes(edge);
+              dependencyNetwork.addEdge(endpoints.source(), endpoints.target(), edge);
+            });
+    return ImmutableNetwork.copyOf(dependencyNetwork);
+  }
+
+  /**
+   * An ordered set of endpoint pairs representing the edges in the cycle. The target of each pair
+   * is the source of the next pair. The target of the last pair is the source of the first pair.
+   */
+  @AutoValue
+  abstract static class Cycle<N> {
+    /**
+     * The ordered set of endpoint pairs representing the edges in the cycle. The target of each
+     * pair is the source of the next pair. The target of the last pair is the source of the first
+     * pair.
+     */
+    abstract ImmutableSet<EndpointPair<N>> endpointPairs();
+
+    /** Returns the nodes that participate in the cycle. */
+    ImmutableSet<N> nodes() {
+      return endpointPairs()
+          .stream()
+          .flatMap(pair -> Stream.of(pair.source(), pair.target()))
+          .collect(toImmutableSet());
+    }
+
+    /** Returns the number of edges in the cycle. */
+    int size() {
+      return endpointPairs().size();
+    }
+
+    /**
+     * Shifts this cycle so that it starts with a specific node.
+     *
+     * @return a cycle equivalent to this one but whose first pair starts with {@code startNode}
+     */
+    Cycle<N> shift(N startNode) {
+      int startIndex = Iterables.indexOf(endpointPairs(), pair -> pair.source().equals(startNode));
+      checkArgument(
+          startIndex >= 0, "startNode (%s) is not part of this cycle: %s", startNode, this);
+      if (startIndex == 0) {
+        return this;
+      }
+      ImmutableSet.Builder<EndpointPair<N>> shifted = ImmutableSet.builder();
+      shifted.addAll(skip(endpointPairs(), startIndex));
+      shifted.addAll(limit(endpointPairs(), size() - startIndex));
+      return new AutoValue_BindingCycleValidation_Cycle<>(shifted.build());
+    }
+
+    @Override
+    public String toString() {
+      return endpointPairs().toString();
+    }
+
+    /**
+     * Creates a {@link Cycle} from a nonempty list of nodes, assuming there is an edge between each
+     * pair of nodes as well as an edge from the last node to the first.
+     */
+    static <N> Cycle<N> fromPath(List<N> nodes) {
+      checkArgument(!nodes.isEmpty());
+      ImmutableSet.Builder<EndpointPair<N>> cycle = ImmutableSet.builder();
+      cycle.add(EndpointPair.ordered(getLast(nodes), nodes.get(0)));
+      for (int i = 0; i < nodes.size() - 1; i++) {
+        cycle.add(EndpointPair.ordered(nodes.get(i), nodes.get(i + 1)));
+      }
+      return new AutoValue_BindingCycleValidation_Cycle<>(cycle.build());
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/BindingGraphValidationModule.java b/java/dagger/internal/codegen/BindingGraphValidationModule.java
index 54c245a1f..7fa0d4963 100644
--- a/java/dagger/internal/codegen/BindingGraphValidationModule.java
+++ b/java/dagger/internal/codegen/BindingGraphValidationModule.java
@@ -25,6 +25,11 @@
 @Module
 interface BindingGraphValidationModule {
 
+  @Binds
+  @IntoSet
+  @Validation
+  BindingGraphPlugin bindingCycle(BindingCycleValidation validation);
+
   @Binds
   @IntoSet
   @Validation
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index 2727da473..8dd399103 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -28,8 +28,6 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Formatter.INDENT;
-import static dagger.internal.codegen.RequestKinds.extractKeyType;
-import static dagger.internal.codegen.RequestKinds.getRequestKind;
 import static dagger.internal.codegen.Scopes.getReadableSource;
 import static dagger.internal.codegen.Scopes.scopesOf;
 import static dagger.internal.codegen.Scopes.singletonScope;
@@ -43,12 +41,9 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-import dagger.BindsOptionalOf;
 import dagger.Component;
-import dagger.Lazy;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
@@ -56,7 +51,6 @@
 import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
-import dagger.model.RequestKind;
 import dagger.model.Scope;
 import java.util.ArrayDeque;
 import java.util.Deque;
@@ -65,9 +59,7 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
-import java.util.concurrent.atomic.AtomicBoolean;
 import javax.inject.Inject;
-import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -84,7 +76,6 @@
   private final DaggerTypes types;
   private final CompilerOptions compilerOptions;
   private final MethodSignatureFormatter methodSignatureFormatter;
-  private final DependencyRequestFormatter dependencyRequestFormatter;
   private final KeyFactory keyFactory;
 
   @Inject
@@ -93,13 +84,11 @@
       DaggerTypes types,
       CompilerOptions compilerOptions,
       MethodSignatureFormatter methodSignatureFormatter,
-      DependencyRequestFormatter dependencyRequestFormatter,
       KeyFactory keyFactory) {
     this.elements = elements;
     this.types = types;
     this.compilerOptions = compilerOptions;
     this.methodSignatureFormatter = methodSignatureFormatter;
-    this.dependencyRequestFormatter = dependencyRequestFormatter;
     this.keyFactory = keyFactory;
   }
 
@@ -480,15 +469,9 @@ private void reportErrorAtEntryPoint(BindingGraph graph, String format, Object..
         report(graph).addError(message, entryPointElement());
       }
 
-      private String formatDependencyTrace() {
-        return dependencyRequestFormatter.format(dependencyTrace());
-      }
-
       @Override
       protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
-        if (atDependencyCycle()) {
-          reportDependencyCycle();
-        } else {
+        if (!atDependencyCycle()) {
           super.visitDependencyRequest(dependencyRequest);
         }
       }
@@ -520,79 +503,6 @@ private void reportDependsOnProductionExecutor() {
             "%s may not depend on the production executor", formatCurrentDependencyRequestKey());
       }
 
-      // TODO(cgruber): Provide a hint for the start and end of the cycle.
-      private void reportDependencyCycle() {
-        if (!providersBreakingCycle().isEmpty()) {
-          return;
-        }
-        ImmutableList.Builder<ContributionBinding> cycleBindings = ImmutableList.builder();
-        cycleDependencyTrace()
-            .forEach(
-                (dependencyRequest, resolvedBindings) ->
-                    cycleBindings.addAll(resolvedBindings.contributionBindings()));
-        reportErrorAtEntryPoint(
-            owningGraph(cycleBindings.build()),
-            "Found a dependency cycle:\n%s",
-            formatDependencyTrace());
-      }
-
-      /**
-       * Returns any steps in a dependency cycle that "break" the cycle. These are any nonsynthetic
-       * {@link Provider}, {@link Lazy}, or {@code Map<K, Provider<V>>} requests after the first
-       * request in the cycle.
-       *
-       * <p>The synthetic request for a {@code Map<K, Provider<V>>} as a dependency of a multibound
-       * {@code Map<K, V>} does not break cycles because the map's {@link Provider}s' {@link
-       * Provider#get() get()} methods are called during provision.
-       *
-       * <p>A request for an instance of {@code Optional} breaks the cycle if it is resolved to a
-       * {@link BindsOptionalOf} binding and a request for the {@code Optional}'s type parameter
-       * would.
-       */
-      private ImmutableSet<DependencyRequest> providersBreakingCycle() {
-        ImmutableSet.Builder<DependencyRequest> providers = ImmutableSet.builder();
-        AtomicBoolean first = new AtomicBoolean(true);
-        cycleDependencyTrace()
-            .forEach(
-                (dependencyRequest, resolvedBindings) -> {
-                  // Skip the first request in the cycle and any synthetic requests.
-                  if (first.getAndSet(false) || !dependencyRequest.requestElement().isPresent()) {
-                    return;
-                  }
-
-                  if (breaksCycle(dependencyRequest.key().type(), dependencyRequest.kind())) {
-                    providers.add(dependencyRequest);
-                  } else if (!resolvedBindings.optionalBindingDeclarations().isEmpty()) {
-                    /* Request resolved to a @BindsOptionalOf binding, so test the type inside the
-                     * Optional. Optional<Provider or Lazy or Provider of Lazy or Map of Provider>
-                     * breaks the cycle. */
-                    TypeMirror optionalValueType =
-                        OptionalType.from(dependencyRequest.key()).valueType();
-                    RequestKind requestKind = getRequestKind(optionalValueType);
-                    if (breaksCycle(extractKeyType(requestKind, optionalValueType), requestKind)) {
-                      providers.add(dependencyRequest);
-                    }
-                  }
-                });
-        return providers.build();
-      }
-
-      private boolean breaksCycle(TypeMirror requestedType, RequestKind requestKind) {
-        switch (requestKind) {
-          case PROVIDER:
-          case LAZY:
-          case PROVIDER_OF_LAZY:
-            return true;
-
-          case INSTANCE:
-            return MapType.isMap(requestedType)
-                && MapType.from(requestedType).valuesAreTypeOf(Provider.class);
-
-          default:
-            return false;
-        }
-      }
-
       private String formatCurrentDependencyRequestKey() {
         return dependencyRequest().key().toString();
       }
diff --git a/java/dagger/internal/codegen/DependencyRequestFormatter.java b/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 9fb3b885e..4ccf8aa18 100644
--- a/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -22,6 +22,7 @@
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Provides;
 import dagger.internal.codegen.ComponentTreeTraverser.DependencyTrace;
 import dagger.model.DependencyRequest;
@@ -98,6 +99,19 @@ public String format(DependencyRequest request) {
         .orElse("");
   }
 
+  /**
+   * Appends a newline and the formatted dependency request unless {@link
+   * #format(DependencyRequest)} returns the empty string.
+   */
+  @CanIgnoreReturnValue
+  StringBuilder appendFormatLine(StringBuilder builder, DependencyRequest dependencyRequest) {
+    String formatted = format(dependencyRequest);
+    if (!formatted.isEmpty()) {
+      builder.append('\n').append(formatted);
+    }
+    return builder;
+  }
+
   private final ElementVisitor<String, DependencyRequest> formatVisitor =
       new ElementKindVisitor8<String, DependencyRequest>() {
 
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index ddb98e8fc..62f940ee7 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -128,10 +128,9 @@ public void reportBinding(
     @Override
     public void reportDependency(
         Diagnostic.Kind diagnosticKind, DependencyEdge dependencyEdge, String message) {
-      StringBuilder messageBuilder =
-          new StringBuilder(message)
-              .append('\n')
-              .append(dependencyRequestFormatter.format(dependencyEdge.dependencyRequest()));
+      StringBuilder messageBuilder = new StringBuilder(message);
+      dependencyRequestFormatter.appendFormatLine(
+          messageBuilder, dependencyEdge.dependencyRequest());
 
       if (dependencyEdge.isEntryPoint()) {
         printAtEntryPoint(diagnosticKind, messageBuilder, dependencyEdge);
@@ -190,9 +189,9 @@ private CharSequence dependencyTrace(DependencyEdge entryPoint, BindingNode bind
             // If a binding requests a key more than once, any of them should be fine to get to
             // the shortest path
             ((DependencyEdge) Iterables.get(dependenciesBetween, 0)).dependencyRequest();
-        trace.append('\n').append(dependencyRequestFormatter.format(dependencyRequest));
+        dependencyRequestFormatter.appendFormatLine(trace, dependencyRequest);
       }
-      trace.append('\n').append(dependencyRequestFormatter.format(entryPoint.dependencyRequest()));
+      dependencyRequestFormatter.appendFormatLine(trace, entryPoint.dependencyRequest());
       return trace;
     }
 
diff --git a/java/dagger/internal/codegen/Formatter.java b/java/dagger/internal/codegen/Formatter.java
index 674f2cb40..53d4f9ade 100644
--- a/java/dagger/internal/codegen/Formatter.java
+++ b/java/dagger/internal/codegen/Formatter.java
@@ -56,9 +56,13 @@ public final String apply(T object) {
   public void formatIndentedList(
       StringBuilder builder, Iterable<? extends T> items, int indentLevel) {
     for (T item : Iterables.limit(items, LIST_LIMIT)) {
+      String formatted = format(item);
+      if (formatted.isEmpty()) {
+        continue;
+      }
       builder.append('\n');
       appendIndent(builder, indentLevel);
-      builder.append(format(item));
+      builder.append(formatted);
     }
     int numberOfOtherItems = Iterables.size(items) - LIST_LIMIT;
     if (numberOfOtherItems > 0) {
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index a36fd23d4..024ee9466 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -467,24 +467,24 @@ public void cyclicDependencyNotBrokenByMapBinding() {
             "  }",
             "}");
 
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.CModule.c(c)",
-                "      java.util.Map<java.lang.String,test.Outer.C> is injected at",
-                "          test.Outer.A.<init>(cMap)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is provided at",
-                "          test.Outer.CComponent.getC()");
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(26);
+    assertThat(compilation)
+        .hadErrorContaining(
+            error(
+                "Found a dependency cycle:",
+                "test.Outer.C is injected at",
+                "    test.Outer.CModule.c(c)",
+                "java.util.Map<java.lang.String,test.Outer.C> is injected at",
+                "    test.Outer.A.<init>(cMap)",
+                "test.Outer.A is injected at",
+                "    test.Outer.B.<init>(aParam)",
+                "test.Outer.B is injected at",
+                "    test.Outer.C.<init>(bParam)",
+                "test.Outer.C is provided at",
+                "    test.Outer.CComponent.getC()"))
+        .inFile(component)
+        .onLineContaining("C getC();");
   }
 
   @Test
@@ -635,7 +635,7 @@ public void cyclicDependencyInSubcomponents() {
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = GrandchildModule.class)",
+            "@Subcomponent",
             "interface Grandchild {",
             "  String entry();",
             "}");
@@ -652,37 +652,26 @@ public void cyclicDependencyInSubcomponents() {
             "  @Provides static Object object(String string) {",
             "    return string;",
             "  }",
-            "}");
-    JavaFileObject grandchildModule =
-        JavaFileObjects.forSourceLines(
-            "test.GrandchildModule",
-            "package test;",
             "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class GrandchildModule {",
             "  @Provides static String string(Object object) {",
             "    return object.toString();",
             "  }",
             "}");
 
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "[test.Grandchild.entry()] Found a dependency cycle:",
-                "      java.lang.String is injected at",
-                "          test.ChildModule.object(string)",
-                "      java.lang.Object is injected at",
-                "          test.GrandchildModule.string(object)",
-                "      java.lang.String is provided at",
-                "          test.Grandchild.entry()");
-
-    Compilation compilation =
-        daggerCompiler().compile(parent, child, grandchild, childModule, grandchildModule);
+    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, childModule);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(child).onLine(6);
+    assertThat(compilation)
+        .hadErrorContaining(
+            error(
+                "[test.Grandchild.entry()] Found a dependency cycle:",
+                "java.lang.String is injected at",
+                "    test.ChildModule.object(string)",
+                "java.lang.Object is injected at",
+                "    test.ChildModule.string(object)",
+                "java.lang.String is provided at",
+                "    test.Grandchild.entry()"))
+        .inFile(parent)
+        .onLineContaining("interface Parent {");
   }
 
   @Test
@@ -718,35 +707,22 @@ public void circularBindsMethods() {
             "@Component(modules = TestModule.class)",
             "interface TestComponent {",
             "  Object unqualified();",
-            "  @SomeQualifier Object qualified();",
             "}");
 
     Compilation compilation = daggerCompiler().compile(qualifier, module, component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "Found a dependency cycle:\n"
-                + "      java.lang.Object is injected at\n"
-                + "          test.TestModule.bindQualified(unqualified)\n"
-                + "      @test.SomeQualifier java.lang.Object is injected at\n"
-                + "          test.TestModule.bindUnqualified(qualified)\n"
-                + "      java.lang.Object is provided at\n"
-                + "          test.TestComponent.unqualified()")
-        .inFile(component)
-        .onLine(7);
-    assertThat(compilation)
-        .hadErrorContaining(
-            // TODO(gak): cl/126230644 produces a better error message in this case. Here it isn't
-            // unclear what is going wrong.
-            "Found a dependency cycle:\n"
-                + "      @test.SomeQualifier java.lang.Object is injected at\n"
-                + "          test.TestModule.bindUnqualified(qualified)\n"
-                + "      java.lang.Object is injected at\n"
-                + "          test.TestModule.bindQualified(unqualified)\n"
-                + "      @test.SomeQualifier java.lang.Object is provided at\n"
-                + "          test.TestComponent.qualified()")
+            error(
+                "Found a dependency cycle:",
+                "java.lang.Object is injected at",
+                "    test.TestModule.bindQualified(unqualified)",
+                "@test.SomeQualifier java.lang.Object is injected at",
+                "    test.TestModule.bindUnqualified(qualified)",
+                "java.lang.Object is provided at",
+                "    test.TestComponent.unqualified()"))
         .inFile(component)
-        .onLine(8);
+        .onLineContaining("unqualified();");
   }
 
   @Test
@@ -843,6 +819,39 @@ public void cycleFromMembersInjectionMethod_WithSameKeyAsMembersInjectionMethod(
         .onLineContaining("void inject(A a);");
   }
 
+  @Test
+  public void longCycleMaskedByShortBrokenCycles() {
+    JavaFileObject cycles =
+        JavaFileObjects.forSourceLines(
+            "test.Cycles",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "import dagger.Component;",
+            "",
+            "final class Cycles {",
+            "  static class A {",
+            "    @Inject A(Provider<A> aProvider, B b) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(Provider<B> bProvider, A a) {}",
+            "  }",
+            "",
+            "  @Component",
+            "  interface C {",
+            "    A a();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(cycles);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Found a dependency cycle:")
+        .inFile(cycles)
+        .onLineContaining("A a();");
+  }
+
   @Test
   public void missingBindingWithSameKeyAsMembersInjectionMethod() {
     JavaFileObject self =
