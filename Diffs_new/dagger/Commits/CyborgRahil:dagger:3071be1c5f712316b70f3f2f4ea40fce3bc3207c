diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 0c89e24e9..999cae3fa 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -20,6 +20,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
+import static dagger.internal.codegen.Accessibility.isRawTypePubliclyAccessible;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
@@ -171,8 +172,24 @@ Expression getDependencyArgumentExpression(
       DependencyRequest dependencyRequest, ClassName requestingClass) {
 
     TypeMirror dependencyType = dependencyRequest.key().type();
+    BindingRequest bindingRequest = bindingRequest(dependencyRequest);
     Expression dependencyExpression =
-        getDependencyExpression(bindingRequest(dependencyRequest), requestingClass);
+        getDependencyExpression(bindingRequest, requestingClass);
+
+    if (compilerOptions.aheadOfTimeSubcomponents()) {
+      TypeMirror requestedType =
+          bindingRequest.requestedType(dependencyRequest.key().type(), types);
+      // If dependencyExpression.type() has been erased to it's publicly accessible type in AOT,
+      // we must sometimes cast the expression so that it is usable in the current component. To do
+      // so, we check that without the cast the assignment would fail, that argument to this proxy
+      // method erased the type, and that the raw type of the requested type is actually accessible
+      // in the current class so that the cast is valid.
+      if (!types.isAssignable(dependencyExpression.type(), requestedType)
+          && !isRawTypePubliclyAccessible(requestedType)
+          && isRawTypeAccessible(requestedType, requestingClass.packageName())) {
+        return dependencyExpression.castTo(types.erasure(requestedType));
+      }
+    }
 
     if (dependencyRequest.kind().equals(RequestKind.INSTANCE)
         && !isTypeAccessibleFrom(dependencyType, requestingClass.packageName())
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index cb67eb055..79fe6dfae 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -206,8 +206,7 @@ public void missingBindings_dependsOnMissingBinding() {
             "",
             "  @Override",
             "  public DependsOnMissingBinding dependsOnMissingBinding() {",
-            "    return DependsOnMissingBinding_Factory.newDependsOnMissingBinding(",
-            "        getMissingInLeaf());",
+            "    return new DependsOnMissingBinding((MissingInLeaf) getMissingInLeaf());",
             "  }",
             "",
             "  protected abstract Object getMissingInLeaf();",
@@ -859,9 +858,8 @@ public void prunedGeneratedInstanceBinding() {
             "",
             "  @Override",
             "  public DependsOnPrunedSubcomponentBuilder dependsOnPrunedSubcomponentBuilder() {",
-            "    return DependsOnPrunedSubcomponentBuilder_Factory",
-            "        .newDependsOnPrunedSubcomponentBuilder(",
-            "            getPrunedSubcomponentBuilder());",
+            "    return new DependsOnPrunedSubcomponentBuilder(",
+            "        (PrunedSubcomponent.Builder) getPrunedSubcomponentBuilder());",
             "  }",
             "",
             "  protected abstract Object getPrunedSubcomponentBuilder();",
@@ -4147,7 +4145,7 @@ public void provisionOverInjection_indirectDependency() {
             "",
             "  @Override",
             "  public InjectedInLeaf injectedInLeaf() {",
-            "    return InjectedInLeaf_Factory.newInjectedInLeaf(getProvidedInAncestor());",
+            "    return new InjectedInLeaf((ProvidedInAncestor) getProvidedInAncestor());",
             "  }",
             "",
             "  protected abstract String getString();",
@@ -4256,8 +4254,7 @@ public void provisionOverInjection_prunedIndirectDependency() {
             "",
             "  @Override",
             "  public InjectsPrunedDependency injectsPrunedDependency() {",
-            "    return InjectsPrunedDependency_Factory.newInjectsPrunedDependency(",
-            "        getPrunedDependency());",
+            "    return new InjectsPrunedDependency((PrunedDependency) getPrunedDependency());",
             "  }",
             "",
             "  protected abstract Object getPrunedDependency();",
@@ -4407,8 +4404,7 @@ public void provisionOverInjection_prunedDirectDependency_prunedInConcreteImplem
             "",
             "  @Override",
             "  public InjectsPrunedDependency injectsPrunedDependency() {",
-            "    return InjectsPrunedDependency_Factory.newInjectsPrunedDependency(",
-            "        getPrunedDependency());",
+            "    return new InjectsPrunedDependency((PrunedDependency) getPrunedDependency());",
             "  }",
             "",
             "  protected Object getPrunedDependency() {",
@@ -4555,8 +4551,7 @@ public void provisionOverInjection_prunedDirectDependency_prunedInAbstractImplem
             "",
             "  @Override",
             "  public InjectsPrunedDependency injectsPrunedDependency() {",
-            "    return InjectsPrunedDependency_Factory.newInjectsPrunedDependency(",
-            "        getPrunedDependency());",
+            "    return new InjectsPrunedDependency((PrunedDependency) getPrunedDependency());",
             "  }",
             "",
             "  protected Object getPrunedDependency() {",
@@ -5173,9 +5168,11 @@ public void missingBindingAccessInLeafAndAncestor() {
             "  @Override",
             "  public DependsOnMissing instance() {",
             "    return LeafModule_TestFactory.proxyTest(",
-            "        getMissing(),",
+            // TODO(b/117833324): remove these unnecessary casts
+            "        (Missing) getMissing(),",
             "        getMissingProvider(),",
-            "        getProvidedInAncestor_InducesSetBinding());",
+            "        (ProvidedInAncestor_InducesSetBinding)",
+            "            getProvidedInAncestor_InducesSetBinding());",
             "  }",
             "",
             "  @Override",
@@ -5261,7 +5258,8 @@ public void missingBindingAccessInLeafAndAncestor() {
             "",
             "    private Object getUnresolvedSetBinding() {",
             "      return LeafModule_UnresolvedSetBindingFactory.proxyUnresolvedSetBinding(",
-            "          getMissing(), getMissingProvider());",
+            // TODO(b/117833324): remove this unnecessary cast
+            "          (Missing) getMissing(), getMissingProvider());",
             "    }",
             "",
             "    @SuppressWarnings(\"unchecked\")",
@@ -6763,7 +6761,8 @@ public void subcomponentInducedFromAncestor() {
             "",
             "    private Object getInducedSet() {",
             "      return InducedSubcomponentModule_InducedSetFactory.proxyInducedSet(",
-            "          getInducedSubcomponentBuilder());",
+            // TODO(b/117833324): remove this unnecessary cast
+            "          (InducedSubcomponent.Builder) getInducedSubcomponentBuilder());",
             "    }",
             "",
             "    protected abstract Object getInducedSubcomponentBuilder();",
@@ -7220,6 +7219,72 @@ public void componentBuilderFields_consistencyAcrossImplementations() {
 
   }
 
+  @Test
+  public void dependencyExpressionCasting() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.PublicType",
+            "package test;",
+            "", //
+            "public class PublicType {}"),
+        JavaFileObjects.forSourceLines(
+            "test.ModifiableNonPublicSubclass",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class ModifiableNonPublicSubclass extends PublicType {",
+            "  @Inject ModifiableNonPublicSubclass() {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Parameterized",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Parameterized<T extends PublicType> {",
+            "  @Inject Parameterized(T t) {}",
+            "}"),
+
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  Parameterized<ModifiableNonPublicSubclass> parameterizedWithNonPublicSubtype();",
+            "}"));
+
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  @Override",
+            "  public Parameterized<ModifiableNonPublicSubclass> ",
+            "      parameterizedWithNonPublicSubtype() {",
+            "    return Parameterized_Factory.newParameterized(",
+            "        (ModifiableNonPublicSubclass) getModifiableNonPublicSubclass());",
+            "  }",
+            "",
+            "  protected Object getModifiableNonPublicSubclass() {",
+            "    return new ModifiableNonPublicSubclass();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .containsElementsIn(generatedLeaf);
+  }
+
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
     for (String className : ancillaryClasses) {
