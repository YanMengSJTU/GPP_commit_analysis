diff --git a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
index 9eaddddbc..60a40adc5 100644
--- a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
+++ b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
@@ -69,14 +69,12 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
               scope -> {
                 ComponentNode componentNode =
                     bindingGraph.componentNode(binding.componentPath()).get();
-                if (bindingGraph.isModuleBindingGraph() && componentNode.componentPath().atRoot()) {
-                  // @Inject bindings in the root "component" for module binding graphs will appear
-                  // at the properly scoped ancestor component of the component that installs the
-                  // module, so ignore them here.
-                  if (!binding.kind().equals(INJECTION)) {
-                    incompatibleBindings.put(componentNode, binding);
+                if (!componentNode.scopes().contains(scope)) {
+                  // @Inject bindings in for module binding graphs will appear at the properly
+                  // scoped ancestor component, so ignore them here.
+                  if (binding.kind().equals(INJECTION) && bindingGraph.isModuleBindingGraph()) {
+                    return;
                   }
-                } else if (!componentNode.scopes().contains(scope)) {
                   incompatibleBindings.put(componentNode, binding);
                 }
               });
diff --git a/javatests/dagger/internal/codegen/ScopingValidationTest.java b/javatests/dagger/internal/codegen/ScopingValidationTest.java
index 659c42384..c8322063f 100644
--- a/javatests/dagger/internal/codegen/ScopingValidationTest.java
+++ b/javatests/dagger/internal/codegen/ScopingValidationTest.java
@@ -262,7 +262,9 @@ public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
   public void moduleBindingValidationDoesNotReportForOneScope() {
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .withOptions(
+                "-Adagger.moduleBindingValidation=ERROR",
+                "-Adagger.moduleHasDifferentScopesValidation=ERROR")
             .compile(
                 JavaFileObjects.forSourceLines(
                     "test.TestModule",
@@ -281,6 +283,106 @@ public void moduleBindingValidationDoesNotReportForOneScope() {
     assertThat(compilation).succeededWithoutWarnings();
   }
 
+  @Test
+  public void moduleBindingValidationDoesNotReportInjectBindings() {
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(
+                "-Adagger.moduleBindingValidation=ERROR",
+                "-Adagger.moduleHasDifferentScopesValidation=ERROR")
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "test.UsedInRootRedScoped",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "@RedScope",
+                    "final class UsedInRootRedScoped {",
+                    "  @Inject UsedInRootRedScoped() {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.UsedInRootBlueScoped",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "@BlueScope",
+                    "final class UsedInRootBlueScoped {",
+                    "  @Inject UsedInRootBlueScoped() {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.RedScope",
+                    "package test;",
+                    "",
+                    "import javax.inject.Scope;",
+                    "",
+                    "@Scope",
+                    "@interface RedScope {}"),
+                JavaFileObjects.forSourceLines(
+                    "test.BlueScope",
+                    "package test;",
+                    "",
+                    "import javax.inject.Scope;",
+                    "",
+                    "@Scope",
+                    "@interface BlueScope {}"),
+                JavaFileObjects.forSourceLines(
+                    "test.TestModule",
+                    "package test;",
+                    "",
+                    "import dagger.Module;",
+                    "import dagger.Provides;",
+                    "import javax.inject.Singleton;",
+                    "",
+                    "@Module(subcomponents = Child.class)",
+                    "interface TestModule {",
+                    "  @Provides @Singleton",
+                    "  static Object object(",
+                    "      UsedInRootRedScoped usedInRootRedScoped,",
+                    "      UsedInRootBlueScoped usedInRootBlueScoped) {",
+                    "    return \"object\";",
+                    "  }",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.Child",
+                    "package test;",
+                    "",
+                    "import dagger.Subcomponent;",
+                    "",
+                    "@Subcomponent",
+                    "interface Child {",
+                    "  UsedInChildRedScoped usedInChildRedScoped();",
+                    "  UsedInChildBlueScoped usedInChildBlueScoped();",
+                    "",
+                    "  @Subcomponent.Builder",
+                    "  interface Builder {",
+                    "    Child child();",
+                    "  }",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.UsedInChildRedScoped",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "@RedScope",
+                    "final class UsedInChildRedScoped {",
+                    "  @Inject UsedInChildRedScoped() {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.UsedInChildBlueScoped",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "@BlueScope",
+                    "final class UsedInChildBlueScoped {",
+                    "  @Inject UsedInChildBlueScoped() {}",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
   @Test
   public void componentWithScopeMayDependOnOnlyOneScopedComponent() {
     // If a scoped component will have dependencies, they must only include, at most, a single
