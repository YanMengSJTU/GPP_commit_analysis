diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index c4161f773..4ab86cb71 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -26,7 +26,6 @@
 import static com.google.common.collect.Iterables.isEmpty;
 import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
-import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
@@ -75,7 +74,6 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 
 /**
@@ -190,18 +188,14 @@ private BindingGraph create(
           : ImmutableSet.<TypeElement>of();
       for (TypeElement componentDependency : componentDependencyTypes) {
         explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
-        List<ExecutableElement> dependencyMethods =
-            ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
-        for (ExecutableElement method : dependencyMethods) {
-          // MembersInjection methods aren't "provided" explicitly, so ignore them.
-          if (isComponentContributionMethod(elements, method)) {
-            explicitBindingsBuilder.add(
+      }
+      ImmutableSet<ExecutableElement> dependencyMethods = componentDescriptor.dependencyMethodIndex().keySet();
+      for (ExecutableElement dependencyMethod : dependencyMethods) {
+        explicitBindingsBuilder.add(
                 componentDescriptor.kind().equals(PRODUCTION_COMPONENT)
-                        && isComponentProductionMethod(elements, method)
-                    ? productionBindingFactory.forComponentMethod(method)
-                    : provisionBindingFactory.forComponentMethod(method));
-          }
-        }
+                        && isComponentProductionMethod(elements, dependencyMethod)
+                    ? productionBindingFactory.forComponentMethod(dependencyMethod)
+                    : provisionBindingFactory.forComponentMethod(dependencyMethod));
       }
 
       for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor>
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 1d19ee815..39cfc7a4a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -51,6 +51,7 @@
 import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.EnumSet;
+import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -63,7 +64,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -451,10 +451,15 @@ private ComponentDescriptor create(
           ImmutableMap.builder();
 
       for (TypeElement componentDependency : componentDependencyTypes) {
-        List<ExecutableElement> dependencyMethods =
-            ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
+        Set<ExecutableElement> dependencyMethods =
+            MoreElements.getLocalAndInheritedMethods(componentDependency, elements);
+        Set<MethodSignatureWithReturnType> methodSignatures = new HashSet<>();
         for (ExecutableElement dependencyMethod : dependencyMethods) {
-          if (isComponentContributionMethod(elements, dependencyMethod)) {
+          MethodSignatureWithReturnType methodSignature =
+              MethodSignatureWithReturnType.fromExecutableElement(dependencyMethod);
+          if (!methodSignatures.contains(methodSignature)
+              && isComponentContributionMethod(elements, dependencyMethod)) {
+            methodSignatures.add(methodSignature);
             dependencyMethodIndex.put(dependencyMethod, componentDependency);
           }
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
index c510e091c..14976ae66 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
@@ -1,14 +1,17 @@
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableList;
+
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 @AutoValue
 abstract class MethodSignature {
   abstract String name();
@@ -30,4 +33,20 @@ static MethodSignature fromExecutableType(String methodName, ExecutableType meth
         parameters.build(),
         thrownTypes.build());
   }
+
+  static MethodSignature fromExecutableElement(ExecutableElement executableElement) {
+    checkNotNull(executableElement);
+    ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> parameters = ImmutableList.builder();
+    ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> thrownTypes = ImmutableList.builder();
+    for (TypeParameterElement parameter : executableElement.getTypeParameters()) {
+      parameters.add(MoreTypes.equivalence().wrap(parameter.asType()));
+    }
+    for (TypeMirror thrownType : executableElement.getThrownTypes()) {
+      thrownTypes.add(MoreTypes.equivalence().wrap(thrownType));
+    }
+    return new AutoValue_MethodSignature(
+            executableElement.getSimpleName().toString(),
+            parameters.build(),
+            thrownTypes.build());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureWithReturnType.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureWithReturnType.java
new file mode 100644
index 000000000..c51b1286f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureWithReturnType.java
@@ -0,0 +1,26 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
+
+/**
+ * Unlike {@link MethodSignature}, this class also contains the return type.
+ */
+@AutoValue
+abstract class MethodSignatureWithReturnType {
+  abstract MethodSignature methodSignature();
+  abstract Equivalence.Wrapper<TypeMirror> returnType();
+  static MethodSignatureWithReturnType fromExecutableElement(ExecutableElement executableElement) {
+    checkNotNull(executableElement);
+    return new AutoValue_MethodSignatureWithReturnType(MethodSignature.fromExecutableElement(executableElement),
+        MoreTypes.equivalence().wrap(executableElement.getReturnType()));
+    }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
index 6f850cdb0..0b523994b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -393,4 +393,207 @@ public void reusableNotAllowedOnSubcomponent() {
         .in(someSubcomponent)
         .onLine(6);
   }
+
+
+  @Test public void componentDependencyExtendsMultipleInterfacesWithSameMethod() {
+    // Unit test to verify we don't see "duplicate binding" error in the following scenario: when a component depends on
+    // an interface that extends two other interfaces with the same method. See original bug:
+    // https://github.com/williamlian/daggerbug.
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {}");
+    JavaFileObject componentA = JavaFileObjects.forSourceLines("test.ComponentA",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "interface ComponentA {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject componentB = JavaFileObjects.forSourceLines("test.ComponentB",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "interface ComponentB {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject simpleComponent = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentC.class)",
+        "interface SimpleComponent {",
+        "  SimpleType theType();",
+        "}");
+    JavaFileObject componentC = JavaFileObjects.forSourceLines("test.ComponentC",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "interface ComponentC extends test.ComponentA, test.ComponentB { }");
+    assertAbout(javaSources())
+        .that(
+                asList(type, simpleComponent, componentA, componentB, componentC))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void componentDependencyExtendsInterfacesThatAlsoExtendsInterface() {
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {}");
+    JavaFileObject componentA = JavaFileObjects.forSourceLines("test.ComponentA",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "interface ComponentA {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject componentB = JavaFileObjects.forSourceLines("test.ComponentB",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "interface ComponentB extends ComponentA {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject simpleComponent = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentC.class)",
+        "interface SimpleComponent {",
+        "  SimpleType theType();",
+        "}");
+    JavaFileObject componentC = JavaFileObjects.forSourceLines("test.ComponentC",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "interface ComponentC extends test.ComponentB { }");
+    assertAbout(javaSources())
+            .that(
+                    asList(type, simpleComponent, componentA, componentB, componentC))
+            .processedWith(new ComponentProcessor())
+            .compilesWithoutError();
+  }
+
+  @Test public void componentContainsSameTypeTwice() {
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {}");
+    JavaFileObject simpleComponent = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentC.class)",
+        "interface SimpleComponent {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject componentC = JavaFileObjects.forSourceLines("test.ComponentC",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "interface ComponentC {",
+        "  SimpleType type();",
+        "  SimpleType sameType();",
+        "}");
+    String error = "test.SimpleType is bound multiple times";
+    assertAbout(javaSources())
+        .that(
+                asList(type, simpleComponent, componentC))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(error);
+  }
+
+  @Test public void componentDependenciesContainsSameKey() {
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {}");
+    JavaFileObject simpleComponent = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = {ComponentC.class, ComponentB.class})",
+        "interface SimpleComponent {",
+        "  SimpleType theType();",
+        "}");
+    JavaFileObject componentC = JavaFileObjects.forSourceLines("test.ComponentC",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "interface ComponentC {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject componentB = JavaFileObjects.forSourceLines("test.ComponentB",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "interface ComponentB {",
+        "  SimpleType type();",
+        "}");
+    String error = "test.SimpleType is bound multiple times";
+    assertAbout(javaSources())
+        .that(
+                asList(type, simpleComponent, componentB, componentC))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(error);
+  }
+
+  @Test public void componentDependenciesHavePolymorphicReturnTypesMustBuild() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "interface A {",
+        "  Object method();",
+        "}");
+    JavaFileObject b = JavaFileObjects.forSourceLines("test.B",
+        "interface B {",
+        "  String method();",
+        "}");
+    JavaFileObject ab = JavaFileObjects.forSourceLines("test.AB",
+        "interface AB extends A, B {}");
+    JavaFileObject ba = JavaFileObjects.forSourceLines("test.BA",
+        "interface BA extends B, A {}");
+    JavaFileObject componentAB = JavaFileObjects.forSourceLines("test.ComponentAB",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = AB.class)",
+        "interface ComponentAB {",
+        "  String method();",
+        "}");
+    JavaFileObject componentBA = JavaFileObjects.forSourceLines("test.ComponentBA",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = BA.class)",
+        "interface ComponentBA {",
+        "  String method();",
+        "}");
+    assertAbout(javaSources())
+            .that(
+                    asList(a, b, ab, ba, componentAB, componentBA))
+            .processedWith(new ComponentProcessor())
+            .compilesWithoutError();
+  }
 }
