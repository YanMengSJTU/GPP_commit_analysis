diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index ba704c09e..5061b2cd3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -1,17 +1,15 @@
 /*
  * Copyright (C) 2014 Google, Inc.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package dagger.internal.codegen;
 
@@ -68,7 +66,7 @@
 
   /**
    * The list of {@link DependencyRequest} instances whose sources are methods on the component
-   * definition type.  These are the user-requested dependencies.
+   * definition type. These are the user-requested dependencies.
    */
   abstract ImmutableList<DependencyRequest> interfaceRequests();
 
@@ -79,16 +77,15 @@
   abstract ImmutableSet<TypeElement> moduleDependencies();
 
   /**
-   * Returns the mapping from {@link Key} to {@link ProvisionBinding} that
-   * (with {@link #resolvedMembersInjectionBindings}) represents the full adjacency matrix for the
-   * object graph.
+   * Returns the mapping from {@link Key} to {@link ProvisionBinding} that (with
+   * {@link #resolvedMembersInjectionBindings}) represents the full adjacency matrix for the object
+   * graph.
    */
   abstract ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings();
 
   /**
-   * Returns the mapping from {@link Key} to {@link MembersInjectionBinding} that
-   * (with {@link #resolvedProvisionBindings}) represents the full adjacency matrix for the object
-   * graph.
+   * Returns the mapping from {@link Key} to {@link MembersInjectionBinding} that (with
+   * {@link #resolvedProvisionBindings}) represents the full adjacency matrix for the object graph.
    */
   abstract ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings();
 
@@ -97,7 +94,7 @@
    * {@link MembersInjector} implementations to initialize properly.
    */
   abstract ImmutableList<FrameworkKey> initializationOrdering();
-  
+
 
   static final class Factory {
     private final Elements elements;
@@ -119,12 +116,10 @@
     private ImmutableSet<TypeElement> getTransitiveModules(ImmutableSet<TypeElement> seedModules) {
       Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
       LinkedHashSet<TypeElement> moduleElements = Sets.newLinkedHashSet();
-      for (TypeElement moduleElement = moduleQueue.poll();
-          moduleElement != null;
+      for (TypeElement moduleElement = moduleQueue.poll(); moduleElement != null;
           moduleElement = moduleQueue.poll()) {
         moduleElements.add(moduleElement);
-        AnnotationMirror moduleMirror =
-            getAnnotationMirror(moduleElement, Module.class).get();
+        AnnotationMirror moduleMirror = getAnnotationMirror(moduleElement, Module.class).get();
         ImmutableSet<TypeElement> moduleDependencies = MoreTypes.asTypeElements(types,
             ConfigurationAnnotations.getModuleIncludes(elements, moduleMirror));
         for (TypeElement dependencyType : moduleDependencies) {
@@ -147,8 +142,8 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
           provisionBindingFactory.forComponent(componentDefinitionType);
 
       ImmutableSetMultimap.Builder<Key, ProvisionBinding> bindingIndexBuilder =
-          new ImmutableSetMultimap.Builder<Key, ProvisionBinding>()
-              .put(componentBinding.providedKey(), componentBinding);
+          new ImmutableSetMultimap.Builder<Key, ProvisionBinding>().put(
+              componentBinding.providedKey(), componentBinding);
 
 
       for (TypeElement module : transitiveModules) {
@@ -156,7 +151,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
         List<ExecutableElement> moduleMethods =
             ElementFilter.methodsIn(elements.getAllMembers(module));
         for (ExecutableElement moduleMethod : moduleMethods) {
-          //TODO Do we need to validate the method???
+          // TODO Do we need to validate the method???
           if (moduleMethod.getAnnotation(Provides.class) != null) {
             ProvisionBinding providesMethodBinding =
                 provisionBindingFactory.forProvidesMethod(moduleMethod);
@@ -171,8 +166,8 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
 
       Deque<DependencyRequest> requestsToResolve = Queues.newArrayDeque();
 
-      for (ExecutableElement componentMethod
-          : ElementFilter.methodsIn(elements.getAllMembers(componentDefinitionType))) {
+      for (ExecutableElement componentMethod :
+          ElementFilter.methodsIn(elements.getAllMembers(componentDefinitionType))) {
         if (componentMethod.getModifiers().contains(ABSTRACT)) {
           List<? extends VariableElement> parameters = componentMethod.getParameters();
           switch (parameters.size()) {
@@ -202,8 +197,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
       ImmutableSet.Builder<FrameworkKey> resolutionOrder = ImmutableSet.builder();
 
       for (DependencyRequest requestToResolve = requestsToResolve.pollLast();
-          requestToResolve != null;
-          requestToResolve = requestsToResolve.pollLast()) {
+          requestToResolve != null; requestToResolve = requestsToResolve.pollLast()) {
         Key key = requestToResolve.key();
         if (requestToResolve.kind().equals(MEMBERS_INJECTOR)) {
           if (!resolvedMembersInjectionBindings.containsKey(key)) {
@@ -226,16 +220,15 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
                 requestsToResolve.addAll(injectBinding.get().dependencies());
                 resolvedProvisionBindings.put(key, injectBinding.get());
                 if (injectBinding.get().requiresMemberInjection()) {
-                  DependencyRequest forMembersInjectedType =
-                      dependencyRequestFactory.forMembersInjectedType(
-                          injectBinding.get().providedKey().type());
+                  DependencyRequest forMembersInjectedType = dependencyRequestFactory
+                      .forMembersInjectedType(injectBinding.get().providedKey().type());
                   requestsToResolve.add(forMembersInjectedType);
                 }
               } else {
                 // TODO(gak): support this
                 throw new UnsupportedOperationException(
                     "@Injected classes that weren't run with the compoenent processor are "
-                        + "(briefly) unsupported: " + key);
+                    + "(briefly) unsupported: " + key);
               }
             } else {
               resolvedProvisionBindings.putAll(key, explicitBindingsForKey);
@@ -248,8 +241,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
         resolutionOrder.add(FrameworkKey.forDependencyRequest(requestToResolve));
       }
 
-      return new AutoValue_ComponentDescriptor(
-          componentDefinitionType,
+      return new AutoValue_ComponentDescriptor(componentDefinitionType,
           interfaceRequestsBuilder.build(),
           moduleTypes,
           ImmutableSetMultimap.copyOf(resolvedProvisionBindings),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 7ddc29117..035fda76d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -1,17 +1,15 @@
 /*
  * Copyright (C) 2014 Google, Inc.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package dagger.internal.codegen;
 
@@ -47,6 +45,7 @@
 import dagger.Component;
 import dagger.MembersInjector;
 import dagger.internal.InstanceFactory;
+import dagger.internal.MapProviderFactory;
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
 import dagger.internal.codegen.writer.ClassName;
@@ -113,7 +112,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
   }
 
   @Override
-  JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
+  JavaWriter write(ClassName componentName, ComponentDescriptor input) {
     JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
 
     ClassWriter componentWriter = writer.addClass(componentName.simpleName());
@@ -131,11 +130,11 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
     ImmutableBiMap<Key, String> membersInjectorNames =
         generateMembersInjectorNamesForBindings(resolvedMembersInjectionBindings);
 
-    ImmutableBiMap<TypeElement, String> moduleNames =
-        ImmutableBiMap.copyOf(Maps.asMap(input.moduleDependencies(), Functions.compose(
-            CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
-            new Function<TypeElement, String>() {
-              @Override public String apply(TypeElement input) {
+    ImmutableBiMap<TypeElement, String> moduleNames = ImmutableBiMap.copyOf(Maps.asMap(
+        input.moduleDependencies(), Functions.compose(
+            CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL), new Function<TypeElement, String>() {
+              @Override
+              public String apply(TypeElement input) {
                 return input.getSimpleName().toString();
               }
             })));
@@ -143,10 +142,10 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
     ConstructorWriter constructorWriter = componentWriter.addConstructor();
     constructorWriter.addModifiers(PUBLIC);
     for (Entry<TypeElement, String> entry : moduleNames.entrySet()) {
-      componentWriter.addField(entry.getKey(), entry.getValue())
-          .addModifiers(PRIVATE, FINAL);
+      componentWriter.addField(entry.getKey(), entry.getValue()).addModifiers(PRIVATE, FINAL);
       constructorWriter.addParameter(entry.getKey(), entry.getValue());
-      constructorWriter.body()
+      constructorWriter
+          .body()
           .addSnippet("if (%s == null) {", entry.getValue())
           .addSnippet("  throw new NullPointerException(%s);",
               StringLiteral.forValue(entry.getValue()))
@@ -159,8 +158,7 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
       Key key = providerEntry.getKey();
       // TODO(gak): provide more elaborate information about which requests relate
       TypeName providerTypeReferece = ParameterizedTypeName.create(
-          ClassName.fromClass(Provider.class),
-          TypeReferences.forTypeMirror(key.type()));
+          ClassName.fromClass(Provider.class), TypeReferences.forTypeMirror(key.type()));
       FieldWriter providerField =
           componentWriter.addField(providerTypeReferece, providerEntry.getValue());
       providerField.addModifiers(PRIVATE, FINAL);
@@ -169,8 +167,7 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
       Key key = providerEntry.getKey();
       // TODO(gak): provide more elaborate information about which requests relate
       TypeName membersInjectorTypeReferece = ParameterizedTypeName.create(
-          ClassName.fromClass(MembersInjector.class),
-          TypeReferences.forTypeMirror(key.type()));
+          ClassName.fromClass(MembersInjector.class), TypeReferences.forTypeMirror(key.type()));
       FieldWriter membersInjectorField =
           componentWriter.addField(membersInjectorTypeReferece, providerEntry.getValue());
       membersInjectorField.addModifiers(PRIVATE, FINAL);
@@ -185,60 +182,54 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
         if ((setBinding = ProvisionBinding.isSetBindingCollection(bindings)) == true) {
           ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
           for (ProvisionBinding binding : bindings) {
-            setFactoryParameters.add(initializeFactoryForBinding(
-                binding, moduleNames, providerNames,membersInjectorNames));
+            setFactoryParameters.add(initializeFactoryForBinding(binding, moduleNames,
+                providerNames, membersInjectorNames));
           }
-          constructorWriter.body().addSnippet("this.%s = %s.create(%n%s);",
-              providerNames.get(key),
+          constructorWriter.body().addSnippet("this.%s = %s.create(%n%s);", providerNames.get(key),
               ClassName.fromClass(SetFactory.class),
               Snippet.makeParametersSnippet(setFactoryParameters.build()));
         } else if ((mapBinding = ProvisionBinding.isMapBindingCollection(bindings)) == true) {
-          ImmutableList.Builder<Snippet> mapFactoryParameters = ImmutableList.builder();
           boolean isFirstBinding = true;
           for (ProvisionBinding binding : bindings) {
             ExecutableElement e = (ExecutableElement) binding.bindingElement();
             ImmutableSet<? extends AnnotationMirror> annotationmirrors = getMapKey(e);
-            Map<? extends ExecutableElement, ? extends AnnotationValue> map = annotationmirrors.iterator().next().getElementValues();
-            //get the key and value type of the map 
+            Map<? extends ExecutableElement, ? extends AnnotationValue> map =
+                annotationmirrors.iterator().next().getElementValues();
+            // get the key and value type of the map
             if (isFirstBinding) {
               DeclaredType declaredMapType = (DeclaredType) binding.providedKey().type();
               List<? extends TypeMirror> mapArgs = declaredMapType.getTypeArguments();
-              TypeMirror keyType =  mapArgs.get(0);
+              TypeMirror keyType = mapArgs.get(0);
               DeclaredType declaredValueType = (DeclaredType) mapArgs.get(1);
               List<? extends TypeMirror> mapValueArgs = declaredValueType.getTypeArguments();
               TypeMirror valueType = mapValueArgs.get(0);
-
-             /* mapFactoryParameters.add(Snippet.create(providerNames.get(key), null)); 
-              mapFactoryParameters.add(Snippet.create(keyType.toString(), null));
-              mapFactoryParameters.add(Snippet.create(valueType.toString(), null)); 
-              mapFactoryParameters.add(Snippet.create(Integer.toString(bindings.size()), null));*/
-
+              constructorWriter.body().addSnippet("this.%s = %s.<%s, %s>builder(%d)",
+                  providerNames.get(key),
+                  ClassName.fromClass(MapProviderFactory.class),
+                  keyType.toString(),
+                  valueType.toString(),
+                  bindings.size());
               isFirstBinding = false;
             }
-            mapFactoryParameters.add(Snippet.create(map.entrySet().iterator().next().getValue().toString(), null));
-            mapFactoryParameters.add(initializeFactoryForBinding(
-                binding, moduleNames, providerNames,membersInjectorNames));
-          }
-          
-          StringBuilder mapPattern = new StringBuilder("this.%s = MapProviderFactory.<%s, %s>builder(%s)");
-          for (int i = 0; i < mapFactoryParameters.build().size() - 4; i += 2) {
-            mapPattern.append("%n.put(%s, %s)");
+            constructorWriter.body().addSnippet("%n%s%s%s%s%s",
+                ".put(",
+                map.entrySet().iterator().next().getValue().toString(),
+                ", ",
+                initializeFactoryForBinding(binding, moduleNames, providerNames,
+                    membersInjectorNames),
+                ")");
           }
-          mapPattern.append("%n.build()");
-          constructorWriter.body().addSnippet(mapPattern.toString(),
-              mapFactoryParameters.build().toArray()); 
+          constructorWriter.body().addSnippet("%n%s", ".build();");
         } else if (ProvisionBinding.isNotACollection(setBinding, mapBinding, bindings)) {
           ProvisionBinding binding = Iterables.getOnlyElement(bindings);
           constructorWriter.body().addSnippet("this.%s = %s;",
-              providerNames.get(key),
-              initializeFactoryForBinding(
-                  binding, moduleNames, providerNames, membersInjectorNames));
+              providerNames.get(key), initializeFactoryForBinding(binding, moduleNames,
+                  providerNames, membersInjectorNames));
         }
       } else if (frameworkKey.frameworkClass().equals(MembersInjector.class)) {
         constructorWriter.body().addSnippet("this.%s = %s;",
-            membersInjectorNames.get(key),
-            initializeMembersInjectorForBinding(resolvedMembersInjectionBindings.get(key),
-                providerNames, membersInjectorNames));
+            membersInjectorNames.get(key), initializeMembersInjectorForBinding(
+                resolvedMembersInjectionBindings.get(key), providerNames, membersInjectorNames));
       } else {
         throw new IllegalStateException(
             "unknown framework class: " + frameworkKey.frameworkClass());
@@ -247,20 +238,21 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
 
     for (DependencyRequest interfaceRequest : input.interfaceRequests()) {
       ExecutableElement requestElement = (ExecutableElement) interfaceRequest.requestElement();
-      MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
-          ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
-          : componentWriter.addMethod(requestElement.getReturnType(),
-              requestElement.getSimpleName().toString());
+      MethodWriter interfaceMethod =
+          requestElement.getReturnType().getKind().equals(VOID) ? componentWriter.addMethod(
+              VoidName.VOID, requestElement.getSimpleName().toString())
+              : componentWriter.addMethod(requestElement.getReturnType(),
+                  requestElement.getSimpleName().toString());
       interfaceMethod.annotate(Override.class);
       interfaceMethod.addModifiers(PUBLIC);
       if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
         String membersInjectorName = membersInjectorNames.get(interfaceRequest.key());
         VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
         Name parameterName = parameter.getSimpleName();
-        interfaceMethod.addParameter(
-            TypeReferences.forTypeMirror(parameter.asType()), parameterName.toString());
-        interfaceMethod.body()
-            .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
+        interfaceMethod.addParameter(TypeReferences.forTypeMirror(parameter.asType()),
+            parameterName.toString());
+        interfaceMethod.body().addSnippet("%s.injectMembers(%s);", membersInjectorName,
+            parameterName);
         if (!requestElement.getReturnType().getKind().equals(VOID)) {
           interfaceMethod.body().addSnippet("return %s;", parameterName);
         }
@@ -268,7 +260,7 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
         // provision requests
         String providerName = providerNames.get(interfaceRequest.key());
 
-        // look up the provider in the Key->name map and invoke.  Done.
+        // look up the provider in the Key->name map and invoke. Done.
         interfaceMethod.body().addSnippet("return %s;",
             frameworkTypeUsageStatement(providerName, interfaceRequest.kind()));
       }
@@ -278,12 +270,10 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
   }
 
   private Snippet initializeFactoryForBinding(ProvisionBinding binding,
-      ImmutableBiMap<TypeElement, String> moduleNames,
-      ImmutableBiMap<Key, String> providerNames,
+      ImmutableBiMap<TypeElement, String> moduleNames, ImmutableBiMap<Key, String> providerNames,
       ImmutableBiMap<Key, String> membersInjectorNames) {
     if (binding.bindingKind().equals(COMPONENT)) {
-      return Snippet.format("%s.<%s>create(this)",
-          ClassName.fromClass(InstanceFactory.class),
+      return Snippet.format("%s.<%s>create(this)", ClassName.fromClass(InstanceFactory.class),
           TypeReferences.forTypeMirror(binding.providedKey().type()));
     } else {
       List<String> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
@@ -301,36 +291,30 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
       }
       parameters.addAll(
           getDependencyParameters(binding.dependencies(), providerNames, membersInjectorNames));
-      return binding.scope().isPresent()
-          ? Snippet.format("%s.create(new %s(%s))",
-              ClassName.fromClass(ScopedProvider.class),
-              factoryNameForProvisionBinding(binding).toString(),
-              Joiner.on(", ").join(parameters))
-          : Snippet.format("new %s(%s)",
-              factoryNameForProvisionBinding(binding).toString(),
+      return binding.scope().isPresent() ? Snippet.format("%s.create(new %s(%s))",
+          ClassName.fromClass(ScopedProvider.class),
+          factoryNameForProvisionBinding(binding).toString(), Joiner.on(", ").join(parameters))
+          : Snippet.format("new %s(%s)", factoryNameForProvisionBinding(binding).toString(),
               Joiner.on(", ").join(parameters));
     }
   }
 
-  private static Snippet initializeMembersInjectorForBinding(
-      MembersInjectionBinding binding,
-      ImmutableBiMap<Key, String> providerNames,
-      ImmutableBiMap<Key, String> membersInjectorNames) {
-    List<String> parameters = getDependencyParameters(binding.dependencySet(),
-        providerNames, membersInjectorNames);
+  private static Snippet initializeMembersInjectorForBinding(MembersInjectionBinding binding,
+      ImmutableBiMap<Key, String> providerNames, ImmutableBiMap<Key, String> membersInjectorNames) {
+    List<String> parameters =
+        getDependencyParameters(binding.dependencySet(), providerNames, membersInjectorNames);
     return Snippet.format("new %s(%s)",
-       membersInjectorNameForMembersInjectionBinding(binding).toString(),
+        membersInjectorNameForMembersInjectionBinding(binding).toString(),
         Joiner.on(", ").join(parameters));
   }
 
   private static List<String> getDependencyParameters(Iterable<DependencyRequest> dependencies,
-      ImmutableBiMap<Key, String> providerNames,
-      ImmutableBiMap<Key, String> membersInjectorNames) {
+      ImmutableBiMap<Key, String> providerNames, ImmutableBiMap<Key, String> membersInjectorNames) {
     ImmutableList.Builder<String> parameters = ImmutableList.builder();
     for (DependencyRequest dependency : dependencies) {
-        parameters.add(dependency.kind().equals(MEMBERS_INJECTOR)
-            ? membersInjectorNames.get(dependency.key())
-            : providerNames.get(dependency.key()));
+      parameters.add(
+          dependency.kind().equals(MEMBERS_INJECTOR) ? membersInjectorNames.get(dependency.key())
+              : providerNames.get(dependency.key()));
     }
     return parameters.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 3e7fb72c6..5bc21bcbb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -1,26 +1,24 @@
 /*
  * Copyright (C) 2014 Google, Inc.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package dagger.internal.codegen;
 
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-
 import com.google.common.collect.Lists;
 
+import dagger.Provides.Type;
 import dagger.Factory;
 import dagger.MembersInjector;
 import dagger.internal.codegen.writer.ClassName;
@@ -33,16 +31,24 @@
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeReferences;
-import java.util.Collections;
 
-import java.util.List;
+import static dagger.internal.codegen.InjectionAnnotations.getMapKey;
 
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
 import java.util.Map.Entry;
+
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
 import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
@@ -83,19 +89,33 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
   @Override
   JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
-    TypeName providedTypeName = TypeReferences.forTypeMirror(binding.providedKey().type());
+    TypeMirror keyType;
+    if (binding.provisionType().equals(Type.MAP)) {
+      ExecutableElement e = (ExecutableElement) binding.bindingElement();
+      ImmutableSet<? extends AnnotationMirror> annotationmirrors = getMapKey(e);
+      Map<? extends ExecutableElement, ? extends AnnotationValue> map =
+          annotationmirrors.iterator().next().getElementValues();
+      DeclaredType declaredMapType = (DeclaredType) binding.providedKey().type();
+      List<? extends TypeMirror> mapArgs = declaredMapType.getTypeArguments();
+      DeclaredType declaredValueType = (DeclaredType) mapArgs.get(1);
+      List<? extends TypeMirror> mapValueArgs = declaredValueType.getTypeArguments();
+      TypeMirror mapValueType = mapValueArgs.get(0);
+      keyType = mapValueType;
+    } else {
+      keyType = binding.providedKey().type();
+    }
+    TypeName providedTypeName = TypeReferences.forTypeMirror(keyType);
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
 
     ClassWriter factoryWriter = writer.addClass(generatedTypeName.simpleName());
     factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
     factoryWriter.addModifiers(PUBLIC, FINAL);
-    factoryWriter.addImplementedType(ParameterizedTypeName.create(
-        ClassName.fromClass(Factory.class),
-        providedTypeName));
+    factoryWriter.addImplementedType(
+        ParameterizedTypeName.create(ClassName.fromClass(Factory.class), providedTypeName));
 
 
 
-    MethodWriter getMethodWriter = factoryWriter.addMethod(binding.providedKey().type(), "get");
+    MethodWriter getMethodWriter = factoryWriter.addMethod(keyType, "get");
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
 
@@ -104,18 +124,16 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
     if (binding.bindingKind().equals(PROVISION)) {
       factoryWriter.addField(binding.bindingTypeElement(), "module").addModifiers(PRIVATE, FINAL);
       constructorWriter.addParameter(binding.bindingTypeElement(), "module");
-      constructorWriter.body()
-          .addSnippet("assert module != null;")
+      constructorWriter.body().addSnippet("assert module != null;")
           .addSnippet("this.module = module;");
     }
 
     if (binding.requiresMemberInjection()) {
-      ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
-          MembersInjector.class, providedTypeName);
+      ParameterizedTypeName membersInjectorType =
+          ParameterizedTypeName.create(MembersInjector.class, providedTypeName);
       factoryWriter.addField(membersInjectorType, "membersInjector").addModifiers(PRIVATE, FINAL);
       constructorWriter.addParameter(membersInjectorType, "membersInjector");
-      constructorWriter.body()
-          .addSnippet("assert membersInjector != null;")
+      constructorWriter.body().addSnippet("assert membersInjector != null;")
           .addSnippet("this.membersInjector = membersInjector;");
     }
 
@@ -140,8 +158,7 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
       }
       field.addModifiers(PRIVATE, FINAL);
       constructorWriter.addParameter(field.type(), field.name());
-      constructorWriter.body()
-          .addSnippet("assert %s != null;", field.name())
+      constructorWriter.body().addSnippet("assert %s != null;", field.name())
           .addSnippet("this.%1$s = %1$s;", field.name());
     }
 
@@ -153,7 +170,6 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
     Snippet parametersSnippet = makeParametersSnippet(parameters);
 
     if (binding.bindingKind().equals(PROVISION)) {
-      //check whether there are mapbinding
       switch (binding.provisionType()) {
         case UNIQUE:
         case SET_VALUES:
@@ -162,26 +178,23 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
           break;
         case SET:
           getMethodWriter.body().addSnippet("return %s.singleton(module.%s(%s));",
-              ClassName.fromClass(Collections.class),
-              binding.bindingElement().getSimpleName(), parametersSnippet);
+              ClassName.fromClass(Collections.class), binding.bindingElement().getSimpleName(),
+              parametersSnippet);
           break;
         case MAP:
-          //TODO add implementation for mapbinding
           getMethodWriter.body().addSnippet("return module.%s(%s);",
-              ClassName.fromClass(Collections.class),
               binding.bindingElement().getSimpleName(), parametersSnippet);
           break;
         default:
           throw new AssertionError();
       }
     } else if (binding.requiresMemberInjection()) {
-      getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
-          providedTypeName, parametersSnippet);
+      getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);", providedTypeName,
+          parametersSnippet);
       getMethodWriter.body().addSnippet("membersInjector.injectMembers(instance);");
       getMethodWriter.body().addSnippet("return instance;");
     } else {
-      getMethodWriter.body()
-          .addSnippet("return new %s(%s);", providedTypeName, parametersSnippet);
+      getMethodWriter.body().addSnippet("return new %s(%s);", providedTypeName, parametersSnippet);
     }
 
     // TODO(gak): write a sensible toString
diff --git a/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor
deleted file mode 100644
index 6d7a2940a..000000000
--- a/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ /dev/null
@@ -1,5 +0,0 @@
-dagger.internal.codegen.ComponentProcessor
-#dagger.internal.codegen.ValidationProcessor
-#dagger.internal.codegen.InjectAdapterProcessor
-#dagger.internal.codegen.ModuleAdapterProcessor
-#dagger.internal.codegen.GraphAnalysisProcessor
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index efeaed02b..60c0c8abf 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -115,16 +115,11 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent",
-        "    implements TestComponent {",
+        "public final class Dagger_TestComponent implements TestComponent",
         "  private final MapModuleOne mapModuleOne;",
         "  private final MapModuleTwo mapModuleTwo;",
-        "  /**",
-        "   * Key{type=java.util.Map<test.PathEnum,javax.inject.Provider<test.Handler>>}",
-        "   */",
         "  private final Provider<Map<PathEnum, Provider<Handler>>> mapOfPathEnumAndProviderOfHandlerProvider;",
         "",
-        "",
         "  public Dagger_TestComponent(MapModuleOne mapModuleOne, MapModuleTwo mapModuleTwo) {",
         "    if (mapModuleOne == null) {",
         "      throw new NullPointerException(\"mapModuleOne\");",
@@ -134,10 +129,10 @@
         "      throw new NullPointerException(\"mapModuleTwo\");",
         "    }",
         "    this.mapModuleTwo = mapModuleTwo;", 
-        "    this.mapOfPathEnumAndProviderOfHandlerProvider = MapProviderFactory.<test.PathEnum, test.Handler>builder(2)",
-        "        .put(test.PathEnum.ADMIN, new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
-        "        .put(test.PathEnum.LOGIN, new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
-        "        .build();",
+        "    this.mapOfPathEnumAndProviderOfHandlerProvider = MapProviderFactory.<PathEnum, Handler>builder(2)",
+        "    .put(PathEnum.ADMIN, new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "    .put(PathEnum.LOGIN, new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "    .build();",
         "  }",
         "",
         "  @Override",
@@ -151,7 +146,7 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
-  @Ignore
+
   @Test public void mapBindingsWithStringKey() {
     JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
         "package test;",
@@ -228,13 +223,9 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent",
-        "    implements TestComponent {",
+        "public final class Dagger_TestComponent implements TestComponent {",
         "  private final MapModuleOne mapModuleOne;",
         "  private final MapModuleTwo mapModuleTwo;",
-        "  /**",
-        "   * Key{type=java.util.Map<java.lang.String,javax.inject.Provider<test.Handler>>}",
-        "   */",
         "  private final Provider<Map<String, Provider<Handler>>> mapOfStringAndProviderOfHandlerProvider;",
         "",
         "",
@@ -247,10 +238,10 @@
         "      throw new NullPointerException(\"mapModuleTwo\");",
         "    }",
         "    this.mapModuleTwo = mapModuleTwo;",
-        "    this.mapOfStringAndProviderOfHandlerProvider = MapProviderFactory.<java.lang.String, test.Handler>builder(2)",
-        "        .put(\"Admin\", new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
-        "        .put(\"Login\", new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
-        "        .build();",
+        "    this.mapOfStringAndProviderOfHandlerProvider = MapProviderFactory.<java.lang.String, Handler>builder(2)",
+        "    .put(\"Admin\", new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "    .put(\"Login\", new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "    .build();",
         "  }",
         "",
         "  @Override",
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index 9b869d778..307768dd5 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -54,6 +54,13 @@
      * otherwise not possible using {@link #SET}.
      */
     SET_VALUES,
+    
+    /**
+     * The method's return type forms the generic type argument of a {@code MAP<K, Provider<V>>}, and the
+     * returned value is contributed to the map. The object graph will pass dependencies to the
+     * method as parameters. The {@code Map<K, Provider<T>>} produced from the accumulation of values will be
+     * immutable.
+     */
     MAP;
   }
 
