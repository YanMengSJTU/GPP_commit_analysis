diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index f4d613345..16b80307f 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -22,8 +22,10 @@
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -68,6 +70,7 @@
   Expression getDependencyExpression(ClassName requestingClass) {
     // TODO(ronshapiro): We should also make an ImmutableMap version of MapFactory
     boolean isImmutableMapAvailable = isImmutableMapAvailable();
+    boolean isBuilderWithExpectedSizeAvailable = isBuilderWithExpectedSizeAvailable();
     // TODO(ronshapiro, gak): Use Maps.immutableEnumMap() if it's available?
     if (isImmutableMapAvailable && dependencies.size() <= MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS) {
       return Expression.create(
@@ -99,7 +102,11 @@ Expression getDependencyExpression(ClassName requestingClass) {
             .add("$T.", isImmutableMapAvailable ? ImmutableMap.class : MapBuilder.class)
             .add(maybeTypeParameters(requestingClass));
         if (isImmutableMapAvailable) {
-          instantiation.add("builderWithExpectedSize($L)", dependencies.size());
+          if (isBuilderWithExpectedSizeAvailable) {
+            instantiation.add("builderWithExpectedSize($L)", dependencies.size());
+          } else {
+            instantiation.add("builder()");
+          }
         } else {
           instantiation.add("newMapBuilder($L)", dependencies.size());
         }
@@ -149,4 +156,10 @@ private CodeBlock maybeTypeParameters(ClassName requestingClass) {
   private boolean isImmutableMapAvailable() {
     return elements.getTypeElement(ImmutableMap.class) != null;
   }
+
+  private boolean isBuilderWithExpectedSizeAvailable() {
+    return methodsIn(elements.getTypeElement(ImmutableMap.class).getEnclosedElements())
+        .stream()
+        .anyMatch(method -> method.getSimpleName().contentEquals("builderWithExpectedSize"));
+  }
 }
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
index 19c8c5e33..d53cd05bc 100644
--- a/java/dagger/internal/codegen/SetBindingExpression.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -19,6 +19,7 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
@@ -55,6 +56,7 @@
   Expression getDependencyExpression(ClassName requestingClass) {
     // TODO(ronshapiro): We should also make an ImmutableSet version of SetFactory
     boolean isImmutableSetAvailable = isImmutableSetAvailable();
+    boolean isBuilderWithExpectedSizeAvailable = isBuilderWithExpectedSizeAvailable();
     // TODO(ronshapiro, gak): Use Sets.immutableEnumSet() if it's available?
     if (isImmutableSetAvailable && binding.dependencies().stream().allMatch(this::isSingleValue)) {
       return Expression.create(
@@ -98,7 +100,11 @@ Expression getDependencyExpression(ClassName requestingClass) {
             .add("$T.", isImmutableSetAvailable ? ImmutableSet.class : SetBuilder.class)
             .add(maybeTypeParameter(requestingClass));
         if (isImmutableSetAvailable) {
-          instantiation.add("builderWithExpectedSize($L)", binding.dependencies().size());
+          if (isBuilderWithExpectedSizeAvailable) {
+            instantiation.add("builderWithExpectedSize($L)", binding.dependencies().size());
+          } else {
+            instantiation.add("builder()");
+          }
         } else {
           instantiation.add("newSetBuilder($L)", binding.dependencies().size());
         }
@@ -156,4 +162,10 @@ private boolean isSingleValue(DependencyRequest dependency) {
   private boolean isImmutableSetAvailable() {
     return elements.getTypeElement(ImmutableSet.class) != null;
   }
+
+  private boolean isBuilderWithExpectedSizeAvailable() {
+    return methodsIn(elements.getTypeElement(ImmutableSet.class).getEnclosedElements())
+        .stream()
+        .anyMatch(method -> method.getSimpleName().contentEquals("builderWithExpectedSize"));
+  }
 }
