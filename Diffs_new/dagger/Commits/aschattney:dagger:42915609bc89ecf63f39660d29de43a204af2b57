diff --git a/android-compiler/pom.xml b/android-compiler/pom.xml
index 373af4923..06f60c1ef 100644
--- a/android-compiler/pom.xml
+++ b/android-compiler/pom.xml
@@ -9,14 +9,25 @@
     </parent>
     <modelVersion>4.0.0</modelVersion>
 
+    <packaging>jar</packaging>
+
     <artifactId>dagger-android-compiler</artifactId>
 
     <dependencies>
         <dependency>
-            <groupId>com.google.dagger</groupId>
+            <groupId>${project.groupId}</groupId>
             <artifactId>dagger</artifactId>
             <version>${project.version}</version>
         </dependency>
+        <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>dagger-android</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.google.auto</groupId>
+            <artifactId>auto-common</artifactId>
+        </dependency>
         <dependency>
             <groupId>com.google.auto.service</groupId>
             <artifactId>auto-service</artifactId>
@@ -67,20 +78,6 @@
                             <verbose>true</verbose>
                         </configuration>
                     </execution>
-                    <!--<execution>
-                      <id>default-test-compile</id>
-                      <goals><goal>testCompile</goal></goals>
-                      <configuration>
-                        <annotationProcessors>
-                          <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
-                        </annotationProcessors>
-                        <compilerArguments>
-                          <Xlint/>
-                          <Averbose>true</Averbose>
-                        </compilerArguments>
-                        <verbose>true</verbose>
-                      </configuration>
-                    </execution>-->
                 </executions>
             </plugin>
             <plugin>
@@ -104,8 +101,8 @@
                                     <exclude>com.google.auto.value</exclude>
                                     <!-- projects should depend on api projects directly -->
                                     <exclude>com.google.dagger:dagger</exclude>
-                                    <exclude>com.google.dagger:dagger-producers</exclude>
                                     <exclude>javax.inject</exclude>
+                                    <exclude>com.google.dagger:dagger-android</exclude>
                                 </excludes>
                             </artifactSet>
                             <relocations>
diff --git a/android-compiler/src/main/java/dagger/android/AndroidInjector.java b/android-compiler/src/main/java/dagger/android/AndroidInjector.java
deleted file mode 100644
index e5e85aa45..000000000
--- a/android-compiler/src/main/java/dagger/android/AndroidInjector.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android;
-import dagger.BindsInstance;
-import dagger.internal.Beta;
-
-@Beta
-public interface AndroidInjector<T> {
-
-  /** Injects the members of {@code instance}. */
-  void inject(T instance);
-
-  /**
-   * Creates {@link AndroidInjector}s for a concrete subtype of a core Android type.
-   *
-   * @param <T> the concrete type to be injected
-   */
-  interface Factory<T> {
-    /**
-     * Creates an {@link AndroidInjector} for {@code instance}. This should be the same instance
-     * that will be passed to {@link #inject(Object)}.
-     */
-    AndroidInjector<T> create(T instance);
-  }
-
-  /**
-   * An adapter that lets the common {@link dagger.Subcomponent.Builder} pattern implement {@link
-   * Factory}.
-   *
-   * @param <T> the concrete type to be injected
-   */
-  abstract class Builder<T> implements Factory<T> {
-    @Override
-    public final AndroidInjector<T> create(T instance) {
-      seedInstance(instance);
-      return build();
-    }
-
-    /**
-     * Provides {@code instance} to be used in the binding graph of the built {@link
-     * AndroidInjector}. By default, this is used as a {@link BindsInstance} method, but it may be
-     * overridden to provide any modules which need a reference to the activity.
-     *
-     * <p>This should be the same instance that will be passed to {@link #inject(Object)}.
-     */
-    @BindsInstance
-    public abstract void seedInstance(T instance);
-
-    /** Returns a newly-constructed {@link AndroidInjector}. */
-    public abstract AndroidInjector<T> build();
-  }
-}
diff --git a/android-compiler/src/main/java/dagger/android/ContributesAndroidInjector.java b/android-compiler/src/main/java/dagger/android/ContributesAndroidInjector.java
deleted file mode 100644
index 22f244c58..000000000
--- a/android-compiler/src/main/java/dagger/android/ContributesAndroidInjector.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.android;
-
-import java.lang.annotation.Target;
-
-import static java.lang.annotation.ElementType.METHOD;
-
-/**
- * Generates an {@link AndroidInjector} for the return type of this method. The injector is
- * implemented with a {@link dagger.Subcomponent} and will be a child of the {@link dagger.Module}'s
- * component.
- *
- * <p>This annotation must be applied to an abstract method in a {@link dagger.Module} that returns
- * a concrete Android framework type (e.g. {@code FooActivity}, {@code BarFragment}, {@code
- * MyService}, etc). The method should have no parameters.
- *
- * <p>For more information, see <a href="https://google.github.io/dagger/android">the docs</a>
- */
-@Target(METHOD)
-public @interface ContributesAndroidInjector {
-  /** Modules to be installed in the generated {@link dagger.Subcomponent}. */
-  Class<?>[] modules() default {};
-}
diff --git a/android-compiler/src/main/java/dagger/android/processor/AndroidInjectorDescriptor.java b/android-compiler/src/main/java/dagger/android/processor/AndroidInjectorDescriptor.java
index 33553f316..6b1689027 100644
--- a/android-compiler/src/main/java/dagger/android/processor/AndroidInjectorDescriptor.java
+++ b/android-compiler/src/main/java/dagger/android/processor/AndroidInjectorDescriptor.java
@@ -16,10 +16,6 @@
 
 package dagger.android.processor;
 
-import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.android.processor.AndroidMapKeys.annotationsAndFrameworkTypes;
 import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.ABSTRACT;
diff --git a/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeyValidator.java b/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeyValidator.java
index f4dff3dcc..a580be611 100644
--- a/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeyValidator.java
+++ b/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeyValidator.java
@@ -16,11 +16,6 @@
 
 package dagger.android.processor;
 
-import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.android.processor.AndroidMapKeys.annotationsAndFrameworkTypes;
 
 import com.google.auto.common.AnnotationMirrors;
diff --git a/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeys.java b/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeys.java
index 4fbfaab4a..46d88702d 100644
--- a/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeys.java
+++ b/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeys.java
@@ -16,8 +16,6 @@
 
 package dagger.android.processor;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static java.util.stream.Collectors.toMap;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 import static javax.lang.model.util.ElementFilter.typesIn;
diff --git a/android-compiler/src/main/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java b/android-compiler/src/main/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
index 80ac5afa6..36cc21b5e 100644
--- a/android-compiler/src/main/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
+++ b/android-compiler/src/main/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
@@ -16,18 +16,10 @@
 
 package dagger.android.processor;
 
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.squareup.javapoet.MethodSpec.constructorBuilder;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static com.squareup.javapoet.TypeSpec.interfaceBuilder;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.util.ElementFilter.methodsIn;
-
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Joiner;
diff --git a/android-support/pom.xml b/android-support/pom.xml
index 78b2bb0bb..83a51b8f9 100644
--- a/android-support/pom.xml
+++ b/android-support/pom.xml
@@ -11,7 +11,7 @@
 
     <artifactId>dagger-android-support</artifactId>
     <name>Dagger for Android Support</name>
-    <packaging>aar</packaging>
+    <packaging>jar</packaging>
 
     <repositories>
         <repository>
diff --git a/android/pom.xml b/android/pom.xml
index aea93b781..2423a6e18 100644
--- a/android/pom.xml
+++ b/android/pom.xml
@@ -26,7 +26,7 @@
   <artifactId>dagger-android</artifactId>
   <name>Dagger for Android</name>
 
-  <packaging>pom</packaging>
+  <packaging>jar</packaging>
 
   <properties>
     <java.version>1.6</java.version>
diff --git a/android/src/main/java/dagger/android/AndroidInjector.java b/android/src/main/java/dagger/android/AndroidInjector.java
index df778e2d5..d07f5b9d0 100644
--- a/android/src/main/java/dagger/android/AndroidInjector.java
+++ b/android/src/main/java/dagger/android/AndroidInjector.java
@@ -76,7 +76,7 @@
      * <p>This should be the same instance that will be passed to {@link #inject(Object)}.
      */
     @BindsInstance
-    public abstract void seedInstance(T instance);
+    public abstract Builder<T> seedInstance(T instance);
 
     /** Returns a newly-constructed {@link AndroidInjector}. */
     public abstract AndroidInjector<T> build();
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 4be1384d3..64600d6e5 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -76,13 +76,6 @@
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
-    <!--<dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>dagger</artifactId>
-      <classifier>tests</classifier>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>-->
     <dependency>
       <groupId>com.google.testing.compile</groupId>
       <artifactId>compile-testing</artifactId>
@@ -138,47 +131,8 @@
               <verbose>true</verbose>
             </configuration>
           </execution>
-          <!--<execution>
-            <id>default-test-compile</id>
-            <goals><goal>testCompile</goal></goals>
-            <configuration>
-              <annotationProcessors>
-                <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
-              </annotationProcessors>
-              <compilerArguments>
-                <Xlint/>
-                <Averbose>true</Averbose>
-              </compilerArguments>
-              <verbose>true</verbose>
-            </configuration>
-          </execution>-->
         </executions>
       </plugin>
-      <!--<plugin>
-        <artifactId>maven-invoker-plugin</artifactId>
-        <configuration>
-          <addTestClassPath>true</addTestClassPath>
-          <cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>
-          <cloneClean>true</cloneClean>
-          <profiles>
-            <profile>!sonatype-oss-release</profile>
-          </profiles>
-          <pomIncludes>
-            <pomInclude>*/pom.xml</pomInclude>
-          </pomIncludes>
-          <localRepositoryPath>${project.build.directory}/it-repo</localRepositoryPath>
-          <streamLogs>true</streamLogs>
-        </configuration>
-        <executions>
-          <execution>
-            <id>integration-test</id>
-            <goals>
-              <goal>install</goal>
-              <goal>run</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>-->
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-shade-plugin</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index bdc325fc9..caef30ee6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -125,6 +125,7 @@
 import java.util.Optional;
 import java.util.Set;
 import java.util.*;
+import java.util.stream.Collectors;
 import javax.inject.Provider;
 import javax.lang.model.element.*;
 import javax.lang.model.type.DeclaredType;
@@ -146,6 +147,7 @@
   protected final Types types;
   protected final Key.Factory keyFactory;
   protected final CompilerOptions compilerOptions;
+  private boolean forTests;
   protected final ClassName name;
   protected final BindingGraph graph;
   protected final ImmutableMap<ComponentDescriptor, String> subcomponentNames;
@@ -155,7 +157,7 @@
   private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
   private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
   private final RequestFulfillmentRegistry requestFulfillmentRegistry;
-  protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
+  protected final MethodSpec.Builder constructor = constructorBuilder();
   protected Optional<ClassName> builderName = Optional.empty();
   private Map<Key, String> delegateFieldNames = new HashMap<>();
   private final OptionalFactories optionalFactories;
@@ -191,11 +193,13 @@
       ClassName name,
       BindingGraph graph,
       ImmutableMap<ComponentDescriptor, String> subcomponentNames,
-      OptionalFactories optionalFactories) {
+      OptionalFactories optionalFactories,
+      boolean forTests) {
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.compilerOptions = compilerOptions;
+    this.forTests = forTests;
     this.component = classBuilder(name);
     this.name = name;
     this.graph = graph;
@@ -206,7 +210,7 @@
   }
 
   protected AbstractComponentWriter(
-      AbstractComponentWriter parent, ClassName name, BindingGraph graph) {
+      AbstractComponentWriter parent, ClassName name, BindingGraph graph, boolean forTests) {
     this(
         parent.types,
         parent.elements,
@@ -215,7 +219,8 @@ protected AbstractComponentWriter(
         name,
         graph,
         parent.subcomponentNames,
-        parent.optionalFactories
+        parent.optionalFactories,
+        forTests
     );
   }
 
@@ -317,6 +322,9 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
     initializeFrameworkTypes();
     implementInterfaceMethods();
     addSubcomponents();
+    if (forTests) {
+      implementProvisionMethodsForDebug();
+    }
     component.addMethod(constructor.build());
     if (graph.componentDescriptor().kind().isTopLevel()) {
       optionalFactories.addMembers(component);
@@ -325,6 +333,80 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
     return component;
   }
 
+  private void implementProvisionMethodsForDebug() {
+      List<ResolvedBindings> result =
+              this.graph.resolvedBindings().values().stream()
+              .filter(resolvedBindings -> !resolvedBindings.ownedContributionBindings().isEmpty())
+              .filter(resolvedBindings -> resolvedBindings.contributionBinding().bindingType() == BindingType.PROVISION)
+              .filter(resolvedBindings -> Util.bindingCanBeProvidedInTest(resolvedBindings.contributionBinding()))
+              .filter(resolvedBindings -> !resolvedBindings.isMultibindingContribution())
+              .filter(resolvedBindings -> !resolvedBindings.contributionBinding().contributedType().toString().contains("DispatchingAndroidInjector"))
+              .filter(resolvedBindings -> !resolvedBindings.contributionBinding().contributedType().toString().equals(graph.application().get().toString()))
+              .collect(Collectors.toList());
+
+      result.forEach(this::implementProvisionMethodForDebug);
+
+    final List<ResolvedBindings> subcomponentBuilderBindings =
+            this.graph.resolvedBindings().values().stream()
+            .filter(resolvedBindings -> !resolvedBindings.ownedContributionBindings().isEmpty())
+            .filter(resolvedBindings -> resolvedBindings.contributionBinding().bindingType() == BindingType.PROVISION)
+            .filter(resolvedBindings -> resolvedBindings.contributionBinding().bindingKind() == ContributionBinding.Kind.SUBCOMPONENT_BUILDER)
+            .collect(Collectors.toList());
+
+    subcomponentBuilderBindings.forEach(this::implementSubcomponentBuilderBindingForDebug);
+
+  }
+
+  private void implementSubcomponentBuilderBindingForDebug(ResolvedBindings resolvedBindings) {
+
+    final ComponentDescriptor subcomponentDescriptor = graph.componentDescriptor()
+            .subcomponentsByBuilderType()
+            .get(MoreTypes.asTypeElement(resolvedBindings.contributionBinding().key().type()));
+    String subcomponentName = subcomponentNames.get(subcomponentDescriptor);
+    final ClassName subcomponent = this.name.nestedClass("Test" + subcomponentName + "Impl");
+
+    final MethodSpec.Builder builder = MethodSpec.methodBuilder("get" + subcomponentName);
+    builder.addModifiers(Modifier.PUBLIC);
+    final CodeBlock memberSelectExpression = getMemberSelectExpression(BindingKey.contribution(resolvedBindings.key()));
+
+    final Optional<TypeMirror> param = getParameterFromSeedInstanceMethod(subcomponentDescriptor.componentDefinitionType());
+    if (param.isPresent()) {
+      final TypeMirror injecteeParam = param.get();
+      builder.addParameter(ClassName.get(injecteeParam), "instance");
+      builder.addStatement("return ($T) $L.get().seedInstance(instance).build()", subcomponent, memberSelectExpression);
+    }else {
+      builder.addStatement("return ($T) $L.get().build()", subcomponent, memberSelectExpression);
+    }
+    builder.returns(subcomponent);
+    this.component.addMethod(builder.build());
+  }
+
+  private Optional<TypeMirror> getParameterFromSeedInstanceMethod(TypeElement element) {
+    final List<? extends TypeMirror> typeMirrors = types.directSupertypes(element.asType());
+    if (typeMirrors.isEmpty()) {
+      return Optional.empty();
+    }
+    for (TypeMirror typeMirror : typeMirrors) {
+      final DeclaredType declaredType = (DeclaredType) typeMirror;
+      if (declaredType.toString().contains("AndroidInjector")) {
+        if (declaredType.getTypeArguments().size() == 1) {
+          return Optional.of(declaredType.getTypeArguments().get(0));
+        }
+      }
+    }
+    return Optional.empty();
+  }
+
+  private void implementProvisionMethodForDebug(ResolvedBindings resolvedBindings) {
+    final FieldSpec frameworkField = createFrameworkField(resolvedBindings, Optional.empty());
+    final MethodSpec.Builder builder = MethodSpec.methodBuilder(Util.getProvisionMethodName(resolvedBindings.contributionBinding()));
+    builder.addModifiers(Modifier.PUBLIC);
+    builder.returns(frameworkField.type);
+    final CodeBlock memberSelectExpression = getMemberSelectExpression(BindingKey.contribution(resolvedBindings.key()));
+    builder.addStatement("return $L", memberSelectExpression);
+    this.component.addMethod(builder.build());
+  }
+
   /**
    * Adds Javadoc, modifiers, supertypes, and annotations to the component implementation class
    * declaration.
@@ -337,7 +419,7 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
   protected void addBuilder() {
     builderName = Optional.of(builderName());
     TypeSpec.Builder componentBuilder =
-        createBuilder(builderName.get().simpleName()).addModifiers(FINAL);
+        createBuilder(builderName.get().simpleName()).addModifiers(PUBLIC, FINAL);
 
     Optional<BuilderSpec> builderSpec = graph.componentDescriptor().builderSpec();
     if (builderSpec.isPresent()) {
@@ -647,6 +729,12 @@ private void addField(ResolvedBindings resolvedBindings) {
    */
   private FieldSpec addFrameworkField(
       ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
+    FieldSpec field = createFrameworkField(resolvedBindings, frameworkClass);
+    component.addField(field);
+    return field;
+  }
+
+  private FieldSpec createFrameworkField(ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
     boolean useRawType = useRawType(resolvedBindings);
 
     FrameworkField contributionBindingField =
@@ -657,13 +745,11 @@ private FieldSpec addFrameworkField(
                 ? contributionBindingField.type().rawType
                 : contributionBindingField.type(),
             contributionBindingField.name());
-    //contributionField.addModifiers(PRIVATE);
+
     if (useRawType) {
       contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
     }
-    FieldSpec field = contributionField.build();
-    component.addField(field);
-    return field;
+    return contributionField.build();
   }
 
   private boolean useRawType(ResolvedBindings resolvedBindings) {
@@ -916,7 +1002,7 @@ private void addSubcomponents() {
               .inverse()
               .get(subgraph.componentDescriptor());
       SubcomponentWriter subcomponent =
-          new SubcomponentWriter(this, Optional.ofNullable(componentMethodDescriptor), subgraph);
+          new SubcomponentWriter(this, Optional.ofNullable(componentMethodDescriptor), subgraph, forTests);
       component.addType(subcomponent.write().build());
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 8ee5e6bce..b3ab3cb23 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -20,6 +20,8 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.Component;
+
+import java.io.IOException;
 import java.util.Optional;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
@@ -38,18 +40,24 @@
   private final Elements elements;
   private final Key.Factory keyFactory;
   private final CompilerOptions compilerOptions;
+  private final TestRegistry testRegistry;
+  private final AppConfig.Provider appConfigProvider;
 
   private ComponentGenerator(
           Filer filer,
           Elements elements,
           Types types,
           Key.Factory keyFactory,
-          CompilerOptions compilerOptions) {
+          CompilerOptions compilerOptions,
+          TestRegistry testRegistry,
+          AppConfig.Provider appConfigProvider) {
     super(filer, elements);
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.compilerOptions = compilerOptions;
+    this.testRegistry = testRegistry;
+    this.appConfigProvider = appConfigProvider;
   }
 
   public static class Factory {
@@ -58,16 +66,22 @@ private ComponentGenerator(
     private final Types types;
     private final Key.Factory keyFactory;
     private final CompilerOptions compilerOptions;
+    private final AppConfig.Provider appConfigProvider;
+    private final TestRegistry testRegistry;
 
-    public Factory(Filer filer, Elements elements, Types types, Key.Factory keyFactory, CompilerOptions compilerOptions) {
+    public Factory(Filer filer, Elements elements, Types types, Key.Factory keyFactory, CompilerOptions compilerOptions,
+                   AppConfig.Provider appConfigProvider,
+                   TestRegistry testRegistry) {
       this.filer = filer;
       this.elements = elements;
       this.types = types;
       this.keyFactory = keyFactory;
       this.compilerOptions = compilerOptions;
+      this.appConfigProvider = appConfigProvider;
+      this.testRegistry = testRegistry;
     }
     public ComponentGenerator createComponentGenerator() {
-      return new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
+      return new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions, testRegistry, appConfigProvider);
     }
   }
 
@@ -84,8 +98,22 @@ ClassName nameGeneratedType(BindingGraph input) {
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
+    if (appConfigProvider.get().debug()) {
+      final ClassName name = componentName.topLevelClassName().peerClass("Test" + Joiner.on('_').join(componentName.simpleNames()));
+      System.out.println("generating test dagger component");
+      final TypeSpec.Builder testComponentBuilder =
+              new ComponentWriter(types, elements, keyFactory, compilerOptions, name, input, true).write();
+      System.out.println("DONE generating test dagger component");
+      try {
+        System.out.println("adding to registry");
+        testRegistry.addEncodedClass(name, buildJavaFile(name, testComponentBuilder));
+        System.out.println("DONE - adding to registry");
+      } catch (IOException e) {
+        throw new IllegalStateException(e);
+      }
+    }
     return Optional.of(
-        new ComponentWriter(types, elements, keyFactory, compilerOptions, componentName, input).write()
+        new ComponentWriter(types, elements, keyFactory, compilerOptions, componentName, input, false).write()
     );
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 66ca845f5..609fbcdf0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -32,6 +32,7 @@
 import javax.lang.model.SourceVersion;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
 
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
@@ -66,6 +67,7 @@ public SourceVersion getSupportedSourceVersion() {
 
   @Override
   protected Iterable<? extends ProcessingStep> initSteps() {
+
     messager = processingEnv.getMessager();
     Types types = processingEnv.getTypeUtils();
     Elements elements = processingEnv.getElementUtils();
@@ -113,11 +115,12 @@ public SourceVersion getSupportedSourceVersion() {
             elements, types, moduleValidator, subcomponentValidator, builderValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator(elements);
 
+    appConfigProvider = new AppConfig.Provider();
     StubGenerator stubGenerator = new StubGenerator(filer, elements, types);
     FactoryGenerator factoryGenerator = new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);
     multipleGenerator = new MultipleSourceFileGenerator<>(filer, elements, Arrays.asList(stubGenerator, factoryGenerator));
     membersInjectorGenerator = new MembersInjectorGenerator(filer, elements, injectValidatorWhenGeneratingCode);
-    ComponentGenerator.Factory componentGeneratorFactory = new ComponentGenerator.Factory(filer, elements, types, keyFactory, compilerOptions);
+    ComponentGenerator.Factory componentGeneratorFactory = new ComponentGenerator.Factory(filer, elements, types, keyFactory, compilerOptions, appConfigProvider, testRegistry);
     ProducerFactoryGenerator producerFactoryGenerator =
             new ProducerFactoryGenerator(filer, elements, compilerOptions);
     MonitoringModuleGenerator monitoringModuleGenerator =
@@ -167,8 +170,6 @@ public SourceVersion getSupportedSourceVersion() {
     ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
             elements, types, dependencyRequestFactory, moduleDescriptorFactory);
 
-    appConfigProvider = new AppConfig.Provider();
-
     BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
             elements,
             injectBindingRegistry,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 1d36014b8..d563ff6df 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -59,7 +59,8 @@
           Key.Factory keyFactory,
           CompilerOptions compilerOptions,
           ClassName name,
-          BindingGraph graph) {
+          BindingGraph graph,
+          boolean forTests) {
     super(
         types,
         elements,
@@ -68,7 +69,8 @@
         name,
         graph,
         new UniqueSubcomponentNamesGenerator(graph).generate(),
-        new OptionalFactories());
+        new OptionalFactories(),
+        forTests);
   }
 
   /**
@@ -184,7 +186,7 @@ String uniquingPrefix() {
 
   @Override
   protected void decorateComponent() {
-    component.addModifiers(PUBLIC, FINAL);
+    component.addModifiers(PUBLIC);
     addSupertype(component, graph.componentType());
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Decorator.java b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
index 3174e7ab4..2be03ecad 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Decorator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
@@ -107,29 +107,12 @@ private void addDecoratorType(TypeSpec.Builder builder, String className, TypeNa
         int counter = 0;
         while(it.hasNext()) {
             final BindingGraph bindingGraph = it.next();
-            final CodeBlock.Builder codeBuilder = CodeBlock.builder();
             ComponentDescriptor topDescriptor = getTopDescriptor(bindingGraph.componentDescriptor());
             final BindingGraph parentGraph = factory.create(topDescriptor);
             final ClassName name = ClassName.bestGuess(TriggerComponentInfo.resolveBuilderName(bindingGraph, parentGraph));
-            codeBuilder.beginControlFlow("if (builder instanceof $T)", name);
-            codeBuilder.add(CodeBlock.of("$T impl = ($T) builder;\n", name, name));
-            TypeName interfaceName = getAccessorTypeName(ClassName.bestGuess(testAppClassName.toString()),
-                    bindingGraph.componentDescriptor().componentDefinitionType().getSimpleName().toString());
-            for (ContributionBinding contributionBinding : delegateRequirements) {
-                if (counter == 0) {
-                    Util.createDelegateField(builder, contributionBinding);
-                    Util.createDelegateMethodImplementation(interfaceName, builder, contributionBinding);
-                    if (!contributionBinding.dependencies().isEmpty()) {
-                        Util.createMockMethodImplementation(interfaceName, builder, contributionBinding);
-                    }
-                }
-                final String delegateFieldName = Util.getDelegateFieldName(contributionBinding.key());
-                final ClassName delegateTypeName = Util.getDelegateTypeName(contributionBinding.key());
-                codeBuilder.add(CodeBlock.of("impl.$L(this.$L);\n", Util.getDelegateMethodName(delegateTypeName), delegateFieldName));
-            }
-            codeBuilder.add(CodeBlock.of("return impl;\n"));
-            codeBuilder.endControlFlow();
-            statements.add(codeBuilder.build());
+            final ClassName testName = ClassName.bestGuess(TriggerComponentInfo.resolveTestBuilderName(bindingGraph, parentGraph));
+            apply(builder, delegateRequirements, statements, counter, bindingGraph, CodeBlock.builder(), name);
+            applyTest(delegateRequirements, statements, CodeBlock.builder(), testName);
             counter++;
         }
 
@@ -150,6 +133,41 @@ private void addDecoratorType(TypeSpec.Builder builder, String className, TypeNa
 
     }
 
+    private void apply(TypeSpec.Builder builder, ImmutableSet<ContributionBinding> delegateRequirements, List<CodeBlock> statements, int counter, BindingGraph bindingGraph, CodeBlock.Builder codeBuilder, ClassName name) {
+        codeBuilder.beginControlFlow("if (builder instanceof $T)", name);
+        codeBuilder.add(CodeBlock.of("$T impl = ($T) builder;\n", name, name));
+        TypeName interfaceName = getAccessorTypeName(ClassName.bestGuess(testAppClassName.toString()),
+                bindingGraph.componentDescriptor().componentDefinitionType().getSimpleName().toString());
+        for (ContributionBinding contributionBinding : delegateRequirements) {
+            if (counter == 0) {
+                Util.createDelegateField(builder, contributionBinding);
+                Util.createDelegateMethodImplementation(interfaceName, builder, contributionBinding);
+                if (!contributionBinding.dependencies().isEmpty()) {
+                    Util.createMockMethodImplementation(interfaceName, builder, contributionBinding);
+                }
+            }
+            final String delegateFieldName = Util.getDelegateFieldName(contributionBinding.key());
+            final ClassName delegateTypeName = Util.getDelegateTypeName(contributionBinding.key());
+            codeBuilder.add(CodeBlock.of("impl.$L(this.$L);\n", Util.getDelegateMethodName(delegateTypeName), delegateFieldName));
+        }
+        codeBuilder.add(CodeBlock.of("return impl;\n"));
+        codeBuilder.endControlFlow();
+        statements.add(codeBuilder.build());
+    }
+
+    private void applyTest(ImmutableSet<ContributionBinding> delegateRequirements, List<CodeBlock> statements, CodeBlock.Builder codeBuilder, ClassName name) {
+        codeBuilder.beginControlFlow("if (builder instanceof $T)", name);
+        codeBuilder.add(CodeBlock.of("$T impl = ($T) builder;\n", name, name));
+        for (ContributionBinding contributionBinding : delegateRequirements) {
+            final String delegateFieldName = Util.getDelegateFieldName(contributionBinding.key());
+            final ClassName delegateTypeName = Util.getDelegateTypeName(contributionBinding.key());
+            codeBuilder.add(CodeBlock.of("impl.$L(this.$L);\n", Util.getDelegateMethodName(delegateTypeName), delegateFieldName));
+        }
+        codeBuilder.add(CodeBlock.of("return impl;\n"));
+        codeBuilder.endControlFlow();
+        statements.add(codeBuilder.build());
+    }
+
     @Override
     void generate(ImmutableSet<BindingGraph> input) throws SourceFileGenerationException {
         final ClassName generatedTypeName = this.nameGeneratedType(input);
diff --git a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
index 0dc4918d8..44a059954 100644
--- a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
@@ -38,6 +38,7 @@ ClassName nameGeneratedType(ProvisionBinding input) {
 
     @Override
     Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProvisionBinding input) {
+
         final String o = generatedTypeName.packageName() + "." + generatedTypeName.simpleName();
         if (generated.contains(o) || !Util.bindingSupportsTestDelegate(input)) {
             return Optional.empty();
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 1b276ebf5..dd6da0cff 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -65,14 +65,16 @@
   SubcomponentWriter(
       AbstractComponentWriter parent,
       Optional<ComponentMethodDescriptor> subcomponentFactoryMethod,
-      BindingGraph subgraph) {
-    super(parent, subcomponentName(parent, subgraph), subgraph);
+      BindingGraph subgraph,
+      boolean forTests) {
+    super(parent, subcomponentName(parent, subgraph, forTests), subgraph, forTests);
     this.parent = parent;
     this.subcomponentFactoryMethod = subcomponentFactoryMethod;
   }
 
-  private static ClassName subcomponentName(AbstractComponentWriter parent, BindingGraph subgraph) {
+  private static ClassName subcomponentName(AbstractComponentWriter parent, BindingGraph subgraph, boolean forTests) {
     return parent.name.nestedClass(
+            (forTests ? "Test" : "") +
         parent.subcomponentNames.get(subgraph.componentDescriptor()) + "Impl");
   }
 
@@ -119,7 +121,7 @@ private ExecutableType resolvedSubcomponentFactoryMethod() {
 
   @Override
   protected void decorateComponent() {
-    component.addModifiers(PUBLIC, FINAL);
+    component.addModifiers(PUBLIC);
     addSupertype(
         component,
         MoreTypes.asTypeElement(
@@ -189,7 +191,7 @@ private void writeSubcomponentWithoutBuilder(
             CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleTypeElement.getSimpleName().toString());
         FieldSpec contributionField =
             componentField(ClassName.get(moduleTypeElement), preferredModuleName)
-                .addModifiers(PRIVATE, FINAL)
+                .addModifiers(FINAL)
                 .build();
         component.addField(contributionField);
 
@@ -218,7 +220,7 @@ private void writeSubcomponentWithoutBuilder(
           CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleType.getSimpleName().toString());
       FieldSpec contributionField =
           componentField(ClassName.get(moduleType), preferredModuleName)
-              .addModifiers(PRIVATE, FINAL)
+              .addModifiers(FINAL)
               .build();
       component.addField(contributionField);
       String actualModuleName = contributionField.name;
diff --git a/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java b/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
index 949ce0d16..c393108f6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
@@ -1,6 +1,7 @@
 package dagger.internal.codegen;
 
-import java.util.Optional;
+import java.util.*;
+
 import com.squareup.javapoet.*;
 import dagger.Trigger;
 
@@ -8,10 +9,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
-import java.util.UUID;
 
 public class TestClassGenerator extends SourceFileGenerator<TestRegistry> {
 
@@ -47,8 +44,13 @@ ClassName nameGeneratedType(TestRegistry input) {
 
             final TestRegistry.EncodedClass encodedClass = it.next();
             final String randomMethodName = getRandomMethodName();
+            List<CodeBlock> valueBlocks = new ArrayList<>();
+            for (String encodedPart : encodedClass.encodedParts) {
+                valueBlocks.add(CodeBlock.of("$S", encodedPart));
+            }
+            final CodeBlock values = valueBlocks.stream().collect(CodeBlocks.joiningCodeBlocks(","));
             final AnnotationSpec annotation = AnnotationSpec.builder(Trigger.class)
-                    .addMember("value", CodeBlock.of("$S", encodedClass.encoded))
+                    .addMember("value", "$L", "{" + values + "}")
                     .addMember("qualifiedName", CodeBlock.of("$S", encodedClass.qualifiedName))
                     .build();
 
@@ -60,7 +62,7 @@ ClassName nameGeneratedType(TestRegistry input) {
         }
 
         builder.addAnnotation(AnnotationSpec.builder(Trigger.class)
-            .addMember("value", CodeBlock.of("$S", "injector"))
+            .addMember("value", "$L", CodeBlock.of("{}"))
             .addMember("qualifiedName", CodeBlock.of("$S", injector.getQualifiedName().toString()))
             .build());
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java b/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
index efdab2f6e..bea968ae0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
@@ -1,5 +1,7 @@
 package dagger.internal.codegen;
 
+import com.google.common.base.Splitter;
+import com.google.common.collect.Iterables;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.JavaFile;
 import javax.tools.JavaFileObject;
@@ -24,8 +26,10 @@ public void addEncodedClass(ClassName className, JavaFile javaFile) throws IOExc
         final JavaFileObject javaFileObject = javaFile.toJavaFileObject();
         final InputStream inputStream = javaFileObject.openInputStream();
         final String encodedClass = java.util.Base64.getEncoder().encodeToString(toByteArray(inputStream));
+        Iterable<String> result = Splitter.fixedLength(65000).split(encodedClass);
+        String[] parts = Iterables.toArray(result, String.class);
         final String name = className.packageName() + "." + className.simpleName();
-        encodedClasses.add(new EncodedClass(name, encodedClass));
+        encodedClasses.add(new EncodedClass(name, parts));
     }
 
     public ClassName getClassName() {
@@ -50,12 +54,12 @@ public boolean isDebug() {
 
     public static class EncodedClass {
 
-        public EncodedClass(String qualifiedName, String encoded) {
+        public EncodedClass(String qualifiedName, String[] encodedParts) {
             this.qualifiedName = qualifiedName;
-            this.encoded = encoded;
+            this.encodedParts = encodedParts;
         }
 
         public String qualifiedName;
-        public String encoded;
+        public String[] encodedParts;
     }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
index f566347f3..72c0866b4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
@@ -65,6 +65,34 @@ protected ParameterSpec getBuilderParameterSpec(ClassName builderClassName) {
         return ParameterSpec.builder(builderClassName, "builder").build();
     }
 
+    public static String resolveTestBuilderName(BindingGraph graph, BindingGraph parentGraph) {
+
+        final ComponentDescriptor descriptor = graph.componentDescriptor();
+        final ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap =
+                new ComponentWriter.UniqueSubcomponentNamesGenerator(parentGraph).generate();
+
+        if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
+            final ClassName daggerComponentClassName = Util.getDaggerComponentClassName(descriptor.componentDefinitionType());
+            return daggerComponentClassName.packageName() + ".Test" + daggerComponentClassName.simpleName() + ".Builder";
+        }else if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            return resolveTestSubcomponentBuilderName(subcomponentNamesMap, descriptor);
+        }else {
+            throw new IllegalStateException(String.format("Unknown component kind: %s", descriptor.kind()));
+        }
+    }
+
+    protected static String resolveTestSubcomponentBuilderName(ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap,
+                                                           ComponentDescriptor descriptor) {
+        final String parentClassName = internalResolveTestClassName(subcomponentNamesMap, descriptor.getParentDescriptor());
+        final String subcomponentName = subcomponentNamesMap.get(descriptor);
+        if (subcomponentName == null) {
+            final String name = descriptor.componentDefinitionType().getQualifiedName().toString();
+            throw new NullPointerException(String.format("Name for Subcomponent '%s' not found", name));
+        }
+        final String name = descriptor.componentDefinitionType().getSimpleName().toString();
+        return parentClassName + "." + name + "Builder";
+    }
+
     public static String resolveBuilderName(BindingGraph graph, BindingGraph parentGraph) {
 
         final ComponentDescriptor descriptor = graph.componentDescriptor();
@@ -98,6 +126,34 @@ private static String internalResolveClassName(ImmutableBiMap<ComponentDescripto
         return internalResolveClassName("", subcomponentNamesMap, descriptor);
     }
 
+    private static String internalResolveTestClassName(ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap,
+                                                   ComponentDescriptor descriptor) {
+        return internalResolveTestClassName("", subcomponentNamesMap, descriptor);
+    }
+
+
+    private static String internalResolveTestClassName(String parentClassName,
+                                                   ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap,
+                                                   ComponentDescriptor descriptor) {
+        if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
+            final ClassName daggerComponentClassName = Util.getDaggerComponentClassName(descriptor.componentDefinitionType());
+            return testClassNameToString(daggerComponentClassName);
+        }else if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            final String name = subcomponentNamesMap.get(descriptor);
+            String newParentClass = builderImplString(parentClassName, name);
+            final String resolvedClassName = internalResolveTestClassName(newParentClass,
+                    subcomponentNamesMap, descriptor.getParentDescriptor());
+            StringBuilder sb = new StringBuilder(resolvedClassName);
+            sb.append(".");
+            sb.append("Test");
+            sb.append(name);
+            sb.append("Impl");
+            return sb.toString();
+        }else {
+            throw new IllegalStateException(String.format("Unknown component kind: %s", descriptor.kind()));
+        }
+    }
+
     private static String internalResolveClassName(String parentClassName,
                                                    ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap,
                                                    ComponentDescriptor descriptor) {
@@ -120,11 +176,15 @@ private static String internalResolveClassName(String parentClassName,
     }
 
     private static String builderImplString(String parentClassName, String subcomponentName) {
-        return parentClassName + "." + subcomponentName + "Impl";
+        return parentClassName + ".Test" + subcomponentName + "Impl";
     }
 
     private static String classNameToString(ClassName daggerComponentClassName) {
         return daggerComponentClassName.packageName() + "." + daggerComponentClassName.simpleName();
     }
 
+    private static String testClassNameToString(ClassName daggerComponentClassName) {
+        return daggerComponentClassName.packageName() + ".Test" + daggerComponentClassName.simpleName();
+    }
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/TriggerProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/TriggerProcessingStep.java
deleted file mode 100644
index 796ff67ac..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/TriggerProcessingStep.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package dagger.internal.codegen;
-
-import com.google.auto.common.BasicAnnotationProcessor;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import dagger.Trigger;
-import javax.annotation.processing.Filer;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.tools.JavaFileObject;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.lang.annotation.Annotation;
-import java.util.List;
-import java.util.Set;
-import java.util.stream.Collectors;
-
-/**
- * Created by Andy on 07.05.2017.
- */
-public class TriggerProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
-
-    private TestRegistry testRegistry;
-    private Filer filer;
-
-    public TriggerProcessingStep(TestRegistry testRegistry, Filer filer) {
-        this.testRegistry = testRegistry;
-        this.filer = filer;
-    }
-
-    @Override
-    public Set<? extends Class<? extends Annotation>> annotations() {
-        return ImmutableSet.of(Trigger.class);
-    }
-
-    @Override
-    public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> setMultimap) {
-        final Set<Element> elements = setMultimap.get(Trigger.class);
-        final List<ExecutableElement> executableElements = elements.stream()
-                .map(element -> (ExecutableElement) element)
-                .collect(Collectors.toList());
-
-        for (ExecutableElement executableElement : executableElements) {
-            final Trigger annotation = executableElement.getAnnotation(Trigger.class);
-            final String value = annotation.value();
-            try {
-                byte[] decodedClass = testRegistry.decodeClass(value);
-                final JavaFileObject sourceFile = filer.createSourceFile(annotation.qualifiedName());
-                final OutputStream os = sourceFile.openOutputStream();
-                os.write(decodedClass);
-                os.flush();
-                os.close();
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-        return ImmutableSet.of();
-    }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index a9df3dca3..3104e1df7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -480,6 +480,11 @@ public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
                 return null;
             }
 
+            @Override
+            public Void visitWildcard(WildcardType t, Void aVoid) {
+                return null;
+            }
+
             @Override
             public Void visitError(ErrorType errorType, Void v) {
                 // Error type found, a type may not yet have been generated, but we need the type
@@ -543,14 +548,18 @@ public static String lowerCaseFirstLetter(String original) {
         return original.substring(0, 1).toLowerCase() + original.substring(1);
     }
 
-    public static boolean bindingSupportsTestDelegate(ContributionBinding binding) {
+    public static boolean bindingCanBeProvidedInTest(ContributionBinding binding) {
         final ImmutableList<ContributionBinding.Kind> kinds = ImmutableList.of(
                 ContributionBinding.Kind.PROVISION,
                 ContributionBinding.Kind.INJECTION,
                 ContributionBinding.Kind.BUILDER_BINDING
         );
         final ContributionBinding.Kind kind = binding.bindingKind();
-        return kinds.contains(kind) && !binding.genericParameter() && !binding.ignoreStubGeneration();
+        return kinds.contains(kind);
+    }
+
+    public static boolean bindingSupportsTestDelegate(ContributionBinding binding) {
+        return bindingCanBeProvidedInTest(binding) && !binding.genericParameter() && !binding.ignoreStubGeneration();
     }
 
     private Util() {
@@ -693,6 +702,9 @@ public static void createDelegateFieldAndMethod(TypeName generatedTypeName, Type
         }
     }
 
+    public static String getProvisionMethodName(ContributionBinding binding) {
+        return "get" + getDelegateTypeName(binding.key()).simpleName().replaceAll("Delegate$", "");
+    }
 
     public static String getDelegateMethodName(ClassName delegateType) {
         return "with" + delegateType.simpleName().replaceAll("Delegate$", "");
@@ -721,4 +733,5 @@ public static ClassName getDaggerComponentClassName(Element component) {
     public static final ClassName TYPENAME_INJECTOR_SPEC = ClassName.bestGuess("injector.InjectorSpec");
     public static final ClassName TYPENAME_ANDROID_APPLICATION = ClassName.bestGuess("android.app.Application");
     public static final ClassName TYPENAME_DAGGER_ANDROID_APPLICATION = TYPENAME_ANDROID_APPLICATION.topLevelClassName().peerClass("DaggerApplication");
+
 }
diff --git a/core/pom.xml b/core/pom.xml
index 7daaf0b0e..37dd6322e 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -30,6 +30,7 @@
     <dependency>
       <groupId>javax.inject</groupId>
       <artifactId>javax.inject</artifactId>
+      <scope>compile</scope>
     </dependency>
 
     <dependency>
diff --git a/core/src/main/java/dagger/Trigger.java b/core/src/main/java/dagger/Trigger.java
index 24deb6e97..911d0ce1c 100644
--- a/core/src/main/java/dagger/Trigger.java
+++ b/core/src/main/java/dagger/Trigger.java
@@ -15,6 +15,6 @@
 @Target({METHOD, TYPE})
 @Documented
 public @interface Trigger {
-    String value();
+    String[] value();
     String qualifiedName();
 }
diff --git a/decoder/src/main/java/dagger/decoder/DecodingProcessingStep.java b/decoder/src/main/java/dagger/decoder/DecodingProcessingStep.java
index 4f4a0fc15..0f4f9ad5c 100644
--- a/decoder/src/main/java/dagger/decoder/DecodingProcessingStep.java
+++ b/decoder/src/main/java/dagger/decoder/DecodingProcessingStep.java
@@ -52,11 +52,15 @@ private boolean isMethod(Element element) {
     }
 
     private void process(Trigger annotation) throws IOException {
-        final String value = annotation.value();
+        final String[] values = annotation.value();
+        StringBuilder sb = new StringBuilder();
+        for (String value : values) {
+            sb.append(value);
+        }
         final String qualifiedName = annotation.qualifiedName();
         final JavaFileObject sourceFile = filer.createSourceFile(qualifiedName);
         final OutputStream os = sourceFile.openOutputStream();
-        os.write(decodeClass(value));
+        os.write(decodeClass(sb.toString()));
         os.flush();
         os.close();
     }
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 540af05ce..a18e51b03 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -44,6 +44,14 @@
       <optional>true</optional>
     </dependency>
 
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger-android-compiler</artifactId>
+      <version>3.0</version>
+      <scope>provided</scope>
+      <optional>true</optional>
+    </dependency>
+
     <dependency>
       <groupId>com.google.android</groupId>
       <artifactId>android</artifactId>
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/AppConfig.java b/examples/android-simple/src/main/java/com/example/dagger/simple/AppConfig.java
index 50c50732d..b7cc05edd 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/AppConfig.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/AppConfig.java
@@ -2,6 +2,6 @@
 
 import dagger.Config;
 
-@Config(applicationClass = DemoApplication1.class)
+@Config(applicationClass = DemoApplication1.class, debug = true)
 public class AppConfig {
 }
