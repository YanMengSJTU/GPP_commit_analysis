diff --git a/java/dagger/android/DaggerFragment.java b/java/dagger/android/DaggerFragment.java
index df0b0d6d5..c95c457ce 100644
--- a/java/dagger/android/DaggerFragment.java
+++ b/java/dagger/android/DaggerFragment.java
@@ -25,8 +25,13 @@
  * A {@link Fragment} that injects its members in {@link #onAttach(Context)} and can be used to
  * inject child {@link Fragment}s attached to it. Note that when this fragment gets reattached, its
  * members will be injected again.
+ *
+ * @deprecated Framework fragments are deprecated in Android P; prefer {@code
+ *     dagger.android.support.DaggerFragment} to use a support-library-friendly {@code
+ *     dagger.android} fragment implementation.
  */
 @Beta
+@Deprecated
 public abstract class DaggerFragment extends Fragment implements HasFragmentInjector {
 
   @Inject DispatchingAndroidInjector<Fragment> childFragmentInjector;
diff --git a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
index 1210ed6d6..dfb84ab69 100644
--- a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -22,12 +22,14 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
+import static dagger.internal.codegen.Scopes.scopesOf;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import dagger.BindsOptionalOf;
 import dagger.Module;
+import dagger.model.Scope;
 import dagger.producers.ProducerModule;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
@@ -77,4 +79,14 @@ private void checkParameters(ValidationReport.Builder<ExecutableElement> builder
       builder.addError("@BindsOptionalOf methods cannot have parameters");
     }
   }
+
+  @Override
+  protected void checkScopes(ValidationReport.Builder<ExecutableElement> builder) {
+    for (Scope scope : scopesOf(builder.getSubject())) {
+      builder.addError(
+          "@BindsOptionalOf methods cannot be scoped",
+          builder.getSubject(),
+          scope.scopeAnnotation());
+    }
+  }
 }
diff --git a/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java b/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
index 9f48dd308..64942ccdc 100644
--- a/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
+++ b/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
@@ -26,6 +26,7 @@
 import java.util.Collection;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
+import javax.inject.Singleton;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -124,6 +125,13 @@ public void implicitlyProvidedType() {
         .hasError("return unqualified types that have an @Inject-annotated constructor");
   }
 
+  @Test
+  public void hasScope() {
+    assertThatMethod("@BindsOptionalOf @Singleton abstract String scoped();")
+        .importing(Singleton.class)
+        .hasError("cannot be scoped");
+  }
+
   private DaggerModuleMethodSubject assertThatMethod(String method) {
     return assertThatModuleMethod(method).withDeclaration(moduleDeclaration);
   }
