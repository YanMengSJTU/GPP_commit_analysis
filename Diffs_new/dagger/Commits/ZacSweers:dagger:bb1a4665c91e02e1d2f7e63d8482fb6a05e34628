diff --git a/BUILD b/BUILD
index 651372aef..7240db8f7 100644
--- a/BUILD
+++ b/BUILD
@@ -63,6 +63,7 @@ jarjar_library(
         "//java/dagger/internal/codegen:processor",
         "//java/dagger/internal/codegen:validation",
         "//java/dagger/internal/codegen:writing",
+        "//java/dagger/internal/codegen/serialization",
         "//java/dagger/model:internal-proxies",
         "//java/dagger/errorprone",
         "@com_google_auto_auto_common//jar",
@@ -80,6 +81,7 @@ jarjar_library(
         "//java/dagger/internal/codegen:libprocessor-src.jar",
         "//java/dagger/internal/codegen:libvalidation-src.jar",
         "//java/dagger/internal/codegen:libwriting-src.jar",
+        # TODO(ronshapiro): is there a generated src.jar for protos in Bazel?
         "//java/dagger/errorprone:liberrorprone-src.jar",
     ],
 )
diff --git a/java/dagger/internal/ComponentDefinitionType.java b/java/dagger/internal/ComponentDefinitionType.java
new file mode 100644
index 000000000..1ab8b1337
--- /dev/null
+++ b/java/dagger/internal/ComponentDefinitionType.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+import java.lang.annotation.Target;
+
+/** Specifies the user-defined component that is being implemented by the annotated class. */
+@Target(TYPE)
+public @interface ComponentDefinitionType {
+  Class<?> value();
+}
diff --git a/java/dagger/internal/ConfigureInitializationParameters.java b/java/dagger/internal/ConfigureInitializationParameters.java
new file mode 100644
index 000000000..1ca0fbb76
--- /dev/null
+++ b/java/dagger/internal/ConfigureInitializationParameters.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import java.lang.annotation.Target;
+
+/**
+ * Annotates a {@code configureInitialization()} method with {@code ComponentRequirement}s that it
+ * accepts as parameters.
+ */
+@Target(METHOD)
+public @interface ConfigureInitializationParameters {
+  /**
+   * The list of parameters.
+   *
+   * Each value is a {@link dagger.internal.codegen.serialization.ComponentRequirementProto}
+   * serialized in Base64.
+   */
+  String[] value() default {};
+}
diff --git a/java/dagger/internal/ModifiableBinding.java b/java/dagger/internal/ModifiableBinding.java
new file mode 100644
index 000000000..1e658e42c
--- /dev/null
+++ b/java/dagger/internal/ModifiableBinding.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import java.lang.annotation.Target;
+
+/** Annotates methods that implement bindings that may be modified by subclass implementations. */
+@Target(METHOD)
+public @interface ModifiableBinding {
+  /** {@code ModifiableBindingType} of the binding. */
+  // TODO(ronshapiro): should this be a shared enum with dagger.internal.codegen?
+  String modifiableBindingType();
+
+  /** A {@link dagger.internal.codegen.serialization.BindingRequestProto} serialized in Base64. */
+  String bindingRequest();
+
+  /**
+   * For a multibinding, the keys of all contributions it depends on in this implementation.
+   */
+  String[] multibindingContributions() default {};
+}
diff --git a/java/dagger/internal/ModifiableModule.java b/java/dagger/internal/ModifiableModule.java
new file mode 100644
index 000000000..983321e85
--- /dev/null
+++ b/java/dagger/internal/ModifiableModule.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+/**
+ * Annotates methods that return {@linkplain dagger.Module modules} that may be modified by subclass
+ * implementations.
+ */
+public @interface ModifiableModule {
+  /** The serialized {@code ComponentRequirement} of this method's module. */
+  String value();
+}
diff --git a/java/dagger/internal/codegen/AnnotationProtoConverter.java b/java/dagger/internal/codegen/AnnotationProtoConverter.java
new file mode 100644
index 000000000..e1350fe19
--- /dev/null
+++ b/java/dagger/internal/codegen/AnnotationProtoConverter.java
@@ -0,0 +1,273 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Maps.transformValues;
+import static dagger.internal.codegen.DaggerStreams.toImmutableList;
+import static javax.lang.model.util.ElementFilter.fieldsIn;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import dagger.internal.codegen.serialization.AnnotationProto;
+import dagger.internal.codegen.serialization.AnnotationValueProto;
+import java.util.List;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleAnnotationValueVisitor8;
+
+/** Converts {@link AnnotationMirror}s to {@link AnnotationProto}s and vice-versa. */
+final class AnnotationProtoConverter {
+  private final TypeProtoConverter typeProtoConverter;
+
+  @Inject
+  AnnotationProtoConverter(TypeProtoConverter typeProtoConverter) {
+    this.typeProtoConverter = typeProtoConverter;
+  }
+
+  /** Translates an {@link AnnotationMirror} to a proto representation. */
+  static AnnotationProto toProto(AnnotationMirror annotationMirror) {
+    AnnotationProto.Builder builder = AnnotationProto.newBuilder();
+    builder.setAnnotationType(TypeProtoConverter.toProto(annotationMirror.getAnnotationType()));
+    getAnnotationValuesWithDefaults(annotationMirror)
+        .forEach(
+            (attribute, value) ->
+                builder.putValues(
+                    attribute.getSimpleName().toString(), annotationValueProto(value)));
+    return builder.build();
+  }
+
+  /** Creates an {@link AnnotationMirror} from its proto representation. */
+  AnnotationMirror fromProto(AnnotationProto annotation) {
+    return SimpleAnnotationMirror.of(
+        MoreTypes.asTypeElement(typeProtoConverter.fromProto(annotation.getAnnotationType())),
+        transformValues(annotation.getValuesMap(), AnnotationValueFromProto::new));
+  }
+
+  private static final AnnotationValueVisitor<
+          AnnotationValueProto.Builder, AnnotationValueProto.Builder>
+      ANNOTATION_VALUE_TO_PROTO =
+          new SimpleAnnotationValueVisitor8<
+              AnnotationValueProto.Builder, AnnotationValueProto.Builder>() {
+            @Override
+            public AnnotationValueProto.Builder visitAnnotation(
+                AnnotationMirror nestedAnnotation, AnnotationValueProto.Builder builder) {
+              return builder
+                  .setNestedAnnotation(toProto(nestedAnnotation))
+                  .setKind(AnnotationValueProto.Kind.ANNOTATION);
+            }
+
+            @Override
+            public AnnotationValueProto.Builder visitBoolean(
+                boolean b, AnnotationValueProto.Builder builder) {
+              return builder.setBooleanValue(b).setKind(AnnotationValueProto.Kind.BOOLEAN);
+            }
+
+            @Override
+            public AnnotationValueProto.Builder visitChar(
+                char c, AnnotationValueProto.Builder builder) {
+              return builder
+                  .setStringValue(String.valueOf(c))
+                  .setKind(AnnotationValueProto.Kind.CHAR);
+            }
+
+            @Override
+            public AnnotationValueProto.Builder visitByte(
+                byte b, AnnotationValueProto.Builder builder) {
+              return builder.setIntValue(b).setKind(AnnotationValueProto.Kind.BYTE);
+            }
+
+            @Override
+            public AnnotationValueProto.Builder visitShort(
+                short s, AnnotationValueProto.Builder builder) {
+              return builder.setIntValue(s).setKind(AnnotationValueProto.Kind.SHORT);
+            }
+
+            @Override
+            public AnnotationValueProto.Builder visitInt(
+                int i, AnnotationValueProto.Builder builder) {
+              return builder.setIntValue(i).setKind(AnnotationValueProto.Kind.INT);
+            }
+
+            @Override
+            public AnnotationValueProto.Builder visitFloat(
+                float f, AnnotationValueProto.Builder builder) {
+              return builder.setFloatValue(f).setKind(AnnotationValueProto.Kind.FLOAT);
+            }
+
+            @Override
+            public AnnotationValueProto.Builder visitLong(
+                long l, AnnotationValueProto.Builder builder) {
+              return builder.setLongValue(l).setKind(AnnotationValueProto.Kind.LONG);
+            }
+
+            @Override
+            public AnnotationValueProto.Builder visitDouble(
+                double d, AnnotationValueProto.Builder builder) {
+              return builder.setDoubleValue(d).setKind(AnnotationValueProto.Kind.DOUBLE);
+            }
+
+            @Override
+            public AnnotationValueProto.Builder visitString(
+                String s, AnnotationValueProto.Builder builder) {
+              return builder.setStringValue(s).setKind(AnnotationValueProto.Kind.STRING);
+            }
+
+            @Override
+            public AnnotationValueProto.Builder visitType(
+                TypeMirror t, AnnotationValueProto.Builder builder) {
+              return builder
+                  .setClassLiteral(TypeProtoConverter.toProto(t))
+                  .setKind(AnnotationValueProto.Kind.CLASS_LITERAL);
+            }
+
+            @Override
+            public AnnotationValueProto.Builder visitEnumConstant(
+                VariableElement c, AnnotationValueProto.Builder builder) {
+              return builder
+                  .setEnumType(TypeProtoConverter.toProto(c.asType()))
+                  .setEnumName(c.getSimpleName().toString())
+                  .setKind(AnnotationValueProto.Kind.ENUM);
+            }
+
+            @Override
+            public AnnotationValueProto.Builder visitArray(
+                List<? extends AnnotationValue> values, AnnotationValueProto.Builder builder) {
+              values.forEach(value -> builder.addArrayValues(annotationValueProto(value)));
+              return builder.setKind(AnnotationValueProto.Kind.ARRAY);
+            }
+
+            @Override
+            public AnnotationValueProto.Builder visitUnknown(
+                AnnotationValue av, AnnotationValueProto.Builder builder) {
+              throw new UnsupportedOperationException(av.toString());
+            }
+          };
+
+  /** Translates an {@link AnnotationValue} to a proto representation. */
+  private static AnnotationValueProto annotationValueProto(AnnotationValue annotationValue) {
+    return annotationValue
+        .accept(ANNOTATION_VALUE_TO_PROTO, AnnotationValueProto.newBuilder())
+        .build();
+  }
+
+  private class AnnotationValueFromProto implements AnnotationValue {
+    private final AnnotationValueProto proto;
+
+    AnnotationValueFromProto(AnnotationValueProto proto) {
+      this.proto = proto;
+    }
+
+    @Override
+    public Object getValue() {
+      switch (proto.getKind()) {
+        case BOOLEAN:
+          return proto.getBooleanValue();
+        case BYTE:
+          return (byte) proto.getIntValue();
+        case SHORT:
+          return (short) proto.getIntValue();
+        case CHAR:
+          return getCharValue();
+        case INT:
+          return proto.getIntValue();
+        case FLOAT:
+          return proto.getFloatValue();
+        case LONG:
+          return proto.getLongValue();
+        case DOUBLE:
+          return proto.getDoubleValue();
+        case STRING:
+          return proto.getStringValue();
+        case CLASS_LITERAL:
+          return typeProtoConverter.fromProto(proto.getClassLiteral());
+        case ENUM:
+          return getEnumConstant();
+        case ANNOTATION:
+          return fromProto(proto.getNestedAnnotation());
+        case ARRAY:
+          return getArrayValues();
+        case UNKNOWN:
+        case UNRECOGNIZED:
+          // fall through
+      }
+      throw new AssertionError(proto);
+    }
+
+    @Override
+    public <R, P> R accept(AnnotationValueVisitor<R, P> visitor, P passedValue) {
+      switch (proto.getKind()) {
+        case BOOLEAN:
+          return visitor.visitBoolean(proto.getBooleanValue(), passedValue);
+        case BYTE:
+          return visitor.visitByte((byte) proto.getIntValue(), passedValue);
+        case SHORT:
+          return visitor.visitShort((short) proto.getIntValue(), passedValue);
+        case CHAR:
+          return visitor.visitChar(getCharValue(), passedValue);
+        case INT:
+          return visitor.visitInt(proto.getIntValue(), passedValue);
+        case FLOAT:
+          return visitor.visitFloat(proto.getFloatValue(), passedValue);
+        case LONG:
+          return visitor.visitLong(proto.getLongValue(), passedValue);
+        case DOUBLE:
+          return visitor.visitDouble(proto.getDoubleValue(), passedValue);
+        case STRING:
+          return visitor.visitString((String) getValue(), passedValue);
+        case CLASS_LITERAL:
+          return visitor.visitType((TypeMirror) getValue(), passedValue);
+        case ENUM:
+          return visitor.visitEnumConstant((VariableElement) getValue(), passedValue);
+        case ANNOTATION:
+          return visitor.visitAnnotation((AnnotationMirror) getValue(), passedValue);
+        case ARRAY:
+          return visitor.visitArray(getArrayValues(), passedValue);
+        case UNKNOWN:
+        case UNRECOGNIZED:
+          // fall through
+      }
+      throw new AssertionError(proto);
+    }
+
+    private char getCharValue() {
+      checkState(proto.getKind().equals(AnnotationValueProto.Kind.CHAR));
+      return proto.getStringValue().charAt(0);
+    }
+
+    private VariableElement getEnumConstant() {
+      checkState(proto.getKind().equals(AnnotationValueProto.Kind.ENUM));
+      TypeMirror enumType = typeProtoConverter.fromProto(proto.getEnumType());
+      return fieldsIn(MoreTypes.asTypeElement(enumType).getEnclosedElements()).stream()
+          .filter(value -> value.getSimpleName().contentEquals(proto.getEnumName()))
+          .findFirst()
+          .get();
+    }
+
+    private ImmutableList<AnnotationValue> getArrayValues() {
+      checkState(proto.getKind().equals(AnnotationValueProto.Kind.ARRAY));
+      return proto.getArrayValuesList().stream()
+          .map(AnnotationValueFromProto::new)
+          .collect(toImmutableList());
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 7f0481a03..1e197c77c 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -47,6 +47,7 @@ CODEGEN_SHARED_DEPS = [
     "@google_bazel_common//third_party/java/jsr250_annotations",
     "@google_bazel_common//third_party/java/jsr330_inject",
     "//java/dagger:core",
+    "//java/dagger/internal/codegen/serialization",
     "//java/dagger/producers",
     "//java/dagger/model",
     "//java/dagger/spi",
@@ -79,6 +80,7 @@ java_library(
     name = "base",
     srcs = [
         "Accessibility.java",
+        "AnnotationProtoConverter.java",
         "AnnotationSpecs.java",
         "ClearableCache.java",
         "CodeBlocks.java",
@@ -117,6 +119,7 @@ java_library(
         "SourceFileGenerator.java",  # Needed by InjectBindingRegistry in :binding and also :writing
         "TypeCheckingProcessingStep.java",
         "TypeNames.java",
+        "TypeProtoConverter.java",
         "TypeSpecs.java",
         "UniqueNameSet.java",
         "Util.java",
@@ -357,6 +360,7 @@ java_library(
         "ComponentProcessingStep.java",
         "ComponentProcessor.java",
         "CurrentImplementationSubcomponent.java",
+        "DeserializedComponentImplementationBuilder.java",
         "GenerationOptionsModule.java",
         "InjectBindingRegistryImpl.java",
         "InjectBindingRegistryModule.java",
@@ -393,6 +397,7 @@ pom_file(
         ":binding_graph_validation",
         ":writing",
         ":validation",
+        "//java/dagger/internal/codegen/serialization",
     ],
 )
 
diff --git a/java/dagger/internal/codegen/BindingRequest.java b/java/dagger/internal/codegen/BindingRequest.java
index 432e76f8d..d1dd6b38d 100644
--- a/java/dagger/internal/codegen/BindingRequest.java
+++ b/java/dagger/internal/codegen/BindingRequest.java
@@ -19,6 +19,9 @@
 import static dagger.internal.codegen.RequestKinds.requestType;
 
 import com.google.auto.value.AutoValue;
+import dagger.internal.codegen.serialization.BindingRequestProto;
+import dagger.internal.codegen.serialization.FrameworkTypeWrapper;
+import dagger.internal.codegen.serialization.RequestKindWrapper;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
@@ -105,4 +108,17 @@ final boolean canBeSatisfiedByProductionBinding() {
     }
     return frameworkType().get().equals(FrameworkType.PRODUCER_NODE);
   }
+
+  /** Creates a proto representation of this binding request. */
+  BindingRequestProto toProto() {
+    BindingRequestProto.Builder builder =
+        BindingRequestProto.newBuilder().setKey(KeyFactory.toProto(key()));
+    if (frameworkType().isPresent()) {
+      builder.setFrameworkType(
+          FrameworkTypeWrapper.FrameworkType.valueOf(frameworkType().get().name()));
+    } else {
+      builder.setRequestKind(RequestKindWrapper.RequestKind.valueOf(requestKind().get().name()));
+    }
+    return builder.build();
+  }
 }
diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index 2109989f9..0462ad68c 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -66,6 +66,21 @@ final boolean doCheckForNulls() {
 
   abstract boolean aheadOfTimeSubcomponents();
 
+  /**
+   * Enables a testing configuration where all superclass {@link ComponentImplementation}s are
+   * derived from their serialized forms.
+   */
+  abstract boolean forceUseSerializedComponentImplementations();
+
+  /**
+   * If {@code true}, in {@link #aheadOfTimeSubcomponents()} mode, Dagger will emit metadata
+   * annotations to deserialize aspects of the {@link ComponentImplementation}.
+   *
+   * This should only be disabled in compile-testing tests that want to ignore the annotations when
+   * asserting on generated source.
+   */
+  abstract boolean emitModifiableMetadataAnnotations();
+
   abstract boolean useGradleIncrementalProcessing();
 
   /** Returns the binding {@link ValidationType} for the element. */
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
index 077840390..13f79c9d3 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
@@ -68,7 +68,7 @@
 
   /** Returns a new creator implementation for the given component, if necessary. */
   Optional<ComponentCreatorImplementation> create(
-      ComponentImplementation componentImplementation, BindingGraph graph) {
+      ComponentImplementation componentImplementation, Optional<BindingGraph> graph) {
     if (!componentImplementation.componentDescriptor().hasCreator()) {
       return Optional.empty();
     }
@@ -378,12 +378,12 @@ private CodeBlock newModuleInstance(ComponentRequirement requirement) {
   /** Builder for a creator type defined by a {@code ComponentCreatorDescriptor}. */
   private final class BuilderForCreatorDescriptor extends Builder {
     final ComponentCreatorDescriptor creatorDescriptor;
-    private final BindingGraph graph;
+    private final Optional<BindingGraph> graph;
 
     BuilderForCreatorDescriptor(
         ComponentImplementation componentImplementation,
         ComponentCreatorDescriptor creatorDescriptor,
-        BindingGraph graph) {
+        Optional<BindingGraph> graph) {
       super(componentImplementation);
       this.creatorDescriptor = creatorDescriptor;
       this.graph = graph;
@@ -409,8 +409,7 @@ protected Modifier visibility() {
     protected void setSupertype() {
       if (componentImplementation.baseCreatorImplementation().isPresent()) {
         // If an abstract base implementation for this creator exists, extend that class.
-        classBuilder.superclass(
-            componentImplementation.baseCreatorImplementation().get().name());
+        classBuilder.superclass(componentImplementation.baseCreatorImplementation().get().name());
       } else {
         addSupertype(classBuilder, creatorDescriptor.typeElement());
       }
@@ -476,7 +475,7 @@ final boolean isRepeatedModule(ComponentRequirement requirement) {
      * Returns whether the given {@code requirement} is for a module type owned by the component.
      */
     private boolean isOwnedModule(ComponentRequirement requirement) {
-      return graph.ownedModuleTypes().contains(requirement.typeElement());
+      return graph.map(g -> g.ownedModuleTypes().contains(requirement.typeElement())).orElse(true);
     }
 
     private boolean hasBaseCreatorImplementation() {
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index de979dfd8..4655f0de4 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -32,6 +32,7 @@
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.CheckReturnValue;
 import dagger.Component;
@@ -194,6 +195,12 @@ final ComponentRequirement getDependencyThatDefinesMethod(Element method) {
   abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
       childComponentsDeclaredByFactoryMethods();
 
+  /** Returns a map of {@link #childComponents()} indexed by {@link #typeElement()}. */
+  @Memoized
+  ImmutableMap<TypeElement, ComponentDescriptor> childComponentsByElement() {
+    return Maps.uniqueIndex(childComponents(), ComponentDescriptor::typeElement);
+  }
+
   /** Returns the factory method that declares a child component. */
   final Optional<ComponentMethodDescriptor> getFactoryMethodForChildComponent(
       ComponentDescriptor childComponent) {
diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index d435e3086..2c2acf41b 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -25,6 +25,7 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
+import static dagger.internal.codegen.serialization.ProtoSerialization.toAnnotationValue;
 import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -47,6 +48,9 @@
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
+import dagger.internal.ConfigureInitializationParameters;
+import dagger.internal.ModifiableBinding;
+import dagger.internal.ModifiableModule;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
@@ -172,8 +176,9 @@ static ConfigureInitializationMethod create(
     abstract ImmutableSet<ComponentRequirement> parameters();
   }
 
+  private final CompilerOptions compilerOptions;
   private final ComponentDescriptor componentDescriptor;
-  private final BindingGraph graph;
+  private final Optional<BindingGraph> graph;
   private final ClassName name;
   private final NestingKind nestingKind;
   private final boolean isAbstract;
@@ -181,7 +186,7 @@ static ConfigureInitializationMethod create(
   private Optional<ComponentCreatorImplementation> creatorImplementation;
   private final Map<TypeElement, ComponentImplementation> childImplementations = new HashMap<>();
   private final TypeSpec.Builder component;
-  private final SubcomponentNames subcomponentNames;
+  private final Optional<SubcomponentNames> subcomponentNames;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
   private final List<CodeBlock> initializations = new ArrayList<>();
@@ -205,13 +210,15 @@ static ConfigureInitializationMethod create(
 
   private ComponentImplementation(
       ComponentDescriptor componentDescriptor,
-      BindingGraph graph,
+      Optional<BindingGraph> graph,
       ClassName name,
       NestingKind nestingKind,
       Optional<ComponentImplementation> superclassImplementation,
-      SubcomponentNames subcomponentNames,
+      Optional<SubcomponentNames> subcomponentNames,
+      CompilerOptions compilerOptions,
       Modifier... modifiers) {
     checkName(name, nestingKind);
+    this.compilerOptions = compilerOptions;
     this.componentDescriptor = componentDescriptor;
     this.graph = graph;
     this.name = name;
@@ -226,14 +233,16 @@ private ComponentImplementation(
   static ComponentImplementation topLevelComponentImplementation(
       BindingGraph graph,
       ClassName name,
-      SubcomponentNames subcomponentNames) {
+      SubcomponentNames subcomponentNames,
+      CompilerOptions compilerOptions) {
     return new ComponentImplementation(
         graph.componentDescriptor(),
-        graph,
+        Optional.of(graph),
         name,
         NestingKind.TOP_LEVEL,
         Optional.empty(), // superclass implementation
-        subcomponentNames,
+        Optional.of(subcomponentNames),
+        compilerOptions,
         PUBLIC,
         graph.componentDescriptor().isSubcomponent() ? ABSTRACT : FINAL);
   }
@@ -245,14 +254,38 @@ ComponentImplementation childComponentImplementation(
       Modifier... modifiers) {
     return new ComponentImplementation(
         graph.componentDescriptor(),
-        graph,
+        Optional.of(graph),
         getSubcomponentName(graph.componentDescriptor()),
         NestingKind.MEMBER,
         superclassImplementation,
         subcomponentNames,
+        compilerOptions,
         modifiers);
   }
 
+  /**
+   * Returns a component implementation that models a previously compiled class. This {@link
+   * ComponentImplementation} is not used for code generation itself; it is used to determine what
+   * methods need to be implemented in a subclass implementation.
+   */
+  static ComponentImplementation forDeserializedComponent(
+      ComponentDescriptor componentDescriptor,
+      ClassName name,
+      NestingKind nestingKind,
+      Optional<ComponentImplementation> superclassImplementation,
+      CompilerOptions compilerOptions) {
+    return new ComponentImplementation(
+        componentDescriptor,
+        Optional.empty(),
+        name,
+        nestingKind,
+        superclassImplementation,
+        Optional.empty(),
+        compilerOptions,
+        PUBLIC,
+        ABSTRACT);
+  }
+
   // TODO(dpb): Just determine the nesting kind from the name.
   private static void checkName(ClassName name, NestingKind nestingKind) {
     switch (nestingKind) {
@@ -271,9 +304,22 @@ private static void checkName(ClassName name, NestingKind nestingKind) {
     }
   }
 
+  /**
+   * Returns {@code true} if this component implementation represents a component that has already
+   * been compiled. If this returns true, the implementation will have no {@link #graph
+   * BindingGraph}.
+   */
+  boolean isDeserializedImplementation() {
+    return !graph.isPresent();
+  }
+
+  // TODO(ronshapiro): see if we can remove this method and instead inject it in the objects that
+  // need it.
   /** Returns the binding graph for the component being generated. */
   BindingGraph graph() {
-    return graph;
+    checkState(!isDeserializedImplementation(),
+        "A BindingGraph is not available for deserialized component implementations.");
+    return graph.get();
   }
 
   /** Returns the descriptor for the component being generated. */
@@ -362,7 +408,22 @@ boolean isAbstract() {
    */
   void setConfigureInitializationMethod(ConfigureInitializationMethod method) {
     configureInitializationMethod = Optional.of(method);
-    addMethod(MethodSpecKind.CONFIGURE_INITIALIZATION_METHOD, method.spec());
+    addMethod(
+        MethodSpecKind.CONFIGURE_INITIALIZATION_METHOD,
+        addConfigureInitializationMetadata(method));
+  }
+
+  private MethodSpec addConfigureInitializationMetadata(ConfigureInitializationMethod method) {
+    if (!shouldEmitModifiableMetadataAnnotations()) {
+      return method.spec();
+    }
+    AnnotationSpec.Builder annotation =
+        AnnotationSpec.builder(ConfigureInitializationParameters.class);
+    for (ComponentRequirement parameter : method.parameters()) {
+      annotation.addMember("value", toAnnotationValue(parameter.toProto()));
+    }
+
+    return method.spec().toBuilder().addAnnotation(annotation.build()).build();
   }
 
   void setCreatorImplementation(Optional<ComponentCreatorImplementation> creatorImplementation) {
@@ -403,7 +464,7 @@ private ComponentCreatorKind creatorKind() {
    */
   ClassName getCreatorName() {
     return isNested()
-        ? name.peerClass(subcomponentNames.getCreatorName(componentDescriptor()))
+        ? name.peerClass(subcomponentNames().getCreatorName(componentDescriptor()))
         : name.nestedClass(creatorKind().typeName());
   }
 
@@ -414,7 +475,7 @@ ClassName getSubcomponentName(ComponentDescriptor childDescriptor) {
         "%s is not a child component of %s",
         childDescriptor.typeElement(),
         componentDescriptor().typeElement());
-    return name.nestedClass(subcomponentNames.get(childDescriptor) + "Impl");
+    return name.nestedClass(subcomponentNames().get(childDescriptor) + "Impl");
   }
 
   /**
@@ -422,7 +483,14 @@ ClassName getSubcomponentName(ComponentDescriptor childDescriptor) {
    * {@link Key}.
    */
   String getSubcomponentCreatorSimpleName(Key key) {
-    return subcomponentNames.getCreatorName(key);
+    return subcomponentNames().getCreatorName(key);
+  }
+
+  private SubcomponentNames subcomponentNames() {
+    checkState(
+        subcomponentNames.isPresent(),
+        "SubcomponentNames is not available for deserialized component implementations.");
+    return subcomponentNames.get();
   }
 
   /** Returns the child implementation. */
@@ -482,37 +550,94 @@ void addModifiableBindingMethod(
       TypeMirror returnType,
       MethodSpec methodSpec,
       boolean finalized) {
-    modifiableBindingMethods.addNewModifiableMethod(
-        type, request, returnType, methodSpec, finalized);
-    methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, methodSpec);
+    addModifiableMethod(
+        MethodSpecKind.MODIFIABLE_BINDING_METHOD, type, request, returnType, methodSpec, finalized);
   }
 
   /**
-   * Registers a known method as encapsulating a modifiable binding without adding the method to the
-   * current component. This is relevant when a method of a different type, such as a component
-   * method, encapsulates a modifiable binding.
+   * Adds a component method that is modifiable to the component. In this case, the method
+   * represents an encapsulation of a modifiable binding between implementations of a subcomponent.
+   * This is only relevant for ahead-of-time subcomponents.
    */
-  void registerModifiableBindingMethod(
+  void addModifiableComponentMethod(
       ModifiableBindingType type,
       BindingRequest request,
       TypeMirror returnType,
       MethodSpec methodSpec,
       boolean finalized) {
-    modifiableBindingMethods.addNewModifiableMethod(
+    addModifiableMethod(
+        MethodSpecKind.COMPONENT_METHOD, type, request, returnType, methodSpec, finalized);
+  }
+
+  private void addModifiableMethod(
+      MethodSpecKind methodKind,
+      ModifiableBindingType type,
+      BindingRequest request,
+      TypeMirror returnType,
+      MethodSpec methodSpec,
+      boolean finalized) {
+    modifiableBindingMethods.addModifiableMethod(
         type, request, returnType, methodSpec, finalized);
+    methodSpecsMap.put(methodKind, withModifiableBindingMetadata(methodSpec, type, request));
   }
 
   /** Adds the implementation for the given {@link ModifiableBindingMethod} to the component. */
   void addImplementedModifiableBindingMethod(ModifiableBindingMethod method) {
     modifiableBindingMethods.addReimplementedMethod(method);
-    methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, method.methodSpec());
+    methodSpecsMap.put(
+        MethodSpecKind.MODIFIABLE_BINDING_METHOD,
+        withModifiableBindingMetadata(method.methodSpec(), method.type(), method.request()));
+  }
+
+  private MethodSpec withModifiableBindingMetadata(
+      MethodSpec method, ModifiableBindingType type, BindingRequest request) {
+    if (!shouldEmitModifiableMetadataAnnotations()) {
+      return method;
+    }
+    AnnotationSpec.Builder metadata =
+        AnnotationSpec.builder(ModifiableBinding.class)
+            .addMember("modifiableBindingType", "$S", type.name())
+            .addMember("bindingRequest", toAnnotationValue(request.toProto()));
+    for (Key multibindingContribution : multibindingContributionsMade.get(request)) {
+      metadata.addMember(
+          "multibindingContributions",
+          toAnnotationValue(KeyFactory.toProto(multibindingContribution)));
+    }
+    return method.toBuilder().addAnnotation(metadata.build()).build();
   }
 
   /** Add's a modifiable module method to this implementation. */
   void addModifiableModuleMethod(ComponentRequirement module, MethodSpec method) {
+    registerModifiableModuleMethod(module, method.name);
+    methodSpecsMap.put(
+        MethodSpecKind.MODIFIABLE_BINDING_METHOD, withModifiableModuleMetadata(module, method));
+  }
+
+  /** Registers a modifiable module method with {@code name} for {@code module}. */
+  void registerModifiableModuleMethod(ComponentRequirement module, String name) {
     checkArgument(module.kind().isModule());
-    checkState(modifiableModuleMethods.put(module, method.name) == null);
-    methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, method);
+    checkState(modifiableModuleMethods.put(module, name) == null);
+  }
+
+  private MethodSpec withModifiableModuleMetadata(ComponentRequirement module, MethodSpec method) {
+    if (!shouldEmitModifiableMetadataAnnotations()) {
+      return method;
+    }
+    return method
+        .toBuilder()
+        .addAnnotation(
+            AnnotationSpec.builder(ModifiableModule.class)
+                .addMember("value", toAnnotationValue(module.toProto()))
+                .build())
+        .build();
+  }
+
+  /**
+   * Returns {@code true} if the generated component should include metadata annotations with
+   * information to deserialize this {@link ComponentImplementation} in future compilations.
+   */
+  boolean shouldEmitModifiableMetadataAnnotations() {
+    return isAbstract && compilerOptions.emitModifiableMetadataAnnotations();
   }
 
   /** Adds the given type to the component. */
@@ -757,12 +882,22 @@ void registerImplementedMultibinding(
     // We register a multibinding as implemented each time we request the multibinding expression,
     // so only modify the set of contributions once.
     if (!multibindingContributionsMade.containsKey(bindingRequest)) {
-      multibindingContributionsMade.putAll(
+      registerImplementedMultibindingKeys(
           bindingRequest,
           multibinding.dependencies().stream().map(DependencyRequest::key).collect(toList()));
     }
   }
 
+  /**
+   * Registers the multibinding contributions represented by {@code keys} as having been implemented
+   * in this component. Multibindings are modifiable across subcomponent implementations and this
+   * allows us to know whether a contribution has been made by a superclass implementation. This is
+   * only relevant for ahead-of-time subcomponents.
+   */
+  void registerImplementedMultibindingKeys(BindingRequest bindingRequest, Iterable<Key> keys) {
+    multibindingContributionsMade.putAll(bindingRequest, keys);
+  }
+
   /**
    * Returns the set of multibinding contributions associated with all superclass implementations of
    * a multibinding.
diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index 19cf55b06..883d17fca 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -55,12 +55,14 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
+import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
+import dagger.internal.ComponentDefinitionType;
 import dagger.internal.Preconditions;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ComponentImplementation.ConfigureInitializationMethod;
@@ -116,7 +118,7 @@ final ComponentImplementation build() {
     setSupertype();
     componentImplementation.setCreatorImplementation(
         componentCreatorImplementationFactory.create(
-            componentImplementation, componentImplementation.graph()));
+            componentImplementation, Optional.of(componentImplementation.graph())));
     componentImplementation
         .creatorImplementation()
         .map(ComponentCreatorImplementation::spec)
@@ -149,6 +151,13 @@ final ComponentImplementation build() {
       componentImplementation.addAnnotation(compilerOptions.toGenerationOptionsAnnotation());
     }
 
+    if (componentImplementation.shouldEmitModifiableMetadataAnnotations()) {
+      componentImplementation.addAnnotation(
+          AnnotationSpec.builder(ComponentDefinitionType.class)
+              .addMember("value", "$T.class", graph.componentTypeElement())
+              .build());
+    }
+
     done = true;
     return componentImplementation;
   }
@@ -207,16 +216,11 @@ private void addPossiblyModifiableInterfaceMethod(
       componentImplementation.addMethod(
           COMPONENT_METHOD, implementedComponentMethod.toBuilder().addModifiers(FINAL).build());
     } else {
-      // If the binding for the component method is modifiable, register it as such.
-      ModifiableBindingType modifiableBindingType =
-          bindingExpressions
-              .modifiableBindingExpressions()
-              .registerComponentMethodIfModifiable(methodDescriptor, implementedComponentMethod);
-
-      // If the method should be implemented in this component, implement it.
-      if (modifiableBindingType.hasBaseClassImplementation()) {
-        componentImplementation.addMethod(COMPONENT_METHOD, implementedComponentMethod);
-      }
+      // TODO(b/117833324): Can this class be the one to interface with ComponentImplementation
+      // instead of having it go through ModifiableBindingExpressions?
+      bindingExpressions
+          .modifiableBindingExpressions()
+          .addPossiblyModifiableComponentMethod(methodDescriptor, implementedComponentMethod);
     }
   }
 
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
index 5ecdac02d..ca780c43e 100644
--- a/java/dagger/internal/codegen/ComponentImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -19,10 +19,14 @@
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ComponentGenerator.componentName;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
+import static javax.tools.Diagnostic.Kind.WARNING;
 
+import com.squareup.javapoet.ClassName;
+import dagger.internal.codegen.serialization.ProtoSerialization.InconsistentSerializedProtoException;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Optional;
+import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.inject.Singleton;
 import javax.lang.model.element.TypeElement;
@@ -35,17 +39,27 @@
   private final CompilerOptions compilerOptions;
   private final BindingGraphFactory bindingGraphFactory;
   private final TopLevelImplementationComponent.Builder topLevelImplementationComponentBuilder;
+  private final DeserializedComponentImplementationBuilder
+      deserializedComponentImplementationBuilder;
+  private final DaggerElements elements;
+  private final Messager messager;
 
   @Inject
   ComponentImplementationFactory(
       KeyFactory keyFactory,
       CompilerOptions compilerOptions,
       BindingGraphFactory bindingGraphFactory,
-      TopLevelImplementationComponent.Builder topLevelImplementationComponentBuilder) {
+      TopLevelImplementationComponent.Builder topLevelImplementationComponentBuilder,
+      DeserializedComponentImplementationBuilder deserializedComponentImplementationBuilder,
+      DaggerElements elements,
+      Messager messager) {
     this.keyFactory = keyFactory;
     this.compilerOptions = compilerOptions;
     this.bindingGraphFactory = bindingGraphFactory;
     this.topLevelImplementationComponentBuilder = topLevelImplementationComponentBuilder;
+    this.deserializedComponentImplementationBuilder = deserializedComponentImplementationBuilder;
+    this.elements = elements;
+    this.messager = messager;
   }
 
   /**
@@ -66,7 +80,9 @@ private ComponentImplementation createComponentImplementationUncached(BindingGra
         ComponentImplementation.topLevelComponentImplementation(
             bindingGraph,
             componentName(bindingGraph.componentTypeElement()),
-            new SubcomponentNames(bindingGraph, keyFactory));
+            new SubcomponentNames(bindingGraph, keyFactory),
+            compilerOptions);
+
     // TODO(dpb): explore using optional bindings for the "parent" bindings
     CurrentImplementationSubcomponent currentImplementationSubcomponent =
         topLevelImplementationComponentBuilder
@@ -109,6 +125,28 @@ ComponentImplementation findChildSuperclassImplementation(
       }
     }
 
+    if (compilerOptions.emitModifiableMetadataAnnotations()) {
+      ClassName childSuperclassName = componentName(child.typeElement());
+      TypeElement generatedChildSuperclassImplementation =
+          elements.getTypeElement(childSuperclassName);
+      if (generatedChildSuperclassImplementation != null) {
+        try {
+          return deserializedComponentImplementationBuilder.create(
+              child, generatedChildSuperclassImplementation);
+        } catch (InconsistentSerializedProtoException e) {
+          messager.printMessage(
+              WARNING,
+              String.format(
+                  "%s was compiled with a different version of Dagger than the version in this "
+                      + "compilation. To ensure the validity of Dagger's generated code, compile "
+                      + "all Dagger code with the same version.",
+                  child.typeElement().getQualifiedName()));
+        }
+      } else if (compilerOptions.forceUseSerializedComponentImplementations()) {
+        throw new TypeNotPresentException(childSuperclassName.toString(), null);
+      }
+    }
+
     // Otherwise, the superclass implementation is top-level, so we must recreate the
     // implementation object for the base implementation of the child by truncating the binding
     // graph at the child.
diff --git a/java/dagger/internal/codegen/ComponentRequirement.java b/java/dagger/internal/codegen/ComponentRequirement.java
index 924ed95b8..9ffc786c7 100644
--- a/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/java/dagger/internal/codegen/ComponentRequirement.java
@@ -34,6 +34,8 @@
 import dagger.Binds;
 import dagger.BindsOptionalOf;
 import dagger.Provides;
+import dagger.internal.codegen.serialization.ComponentRequirementProto;
+import dagger.internal.codegen.serialization.ComponentRequirementProto.BoundInstanceRequirement;
 import dagger.model.BindingKind;
 import dagger.model.Key;
 import dagger.multibindings.Multibinds;
@@ -183,6 +185,29 @@ ParameterSpec toParameterSpec() {
     return ParameterSpec.builder(TypeName.get(type()), variableName()).build();
   }
 
+  /** Creates a proto representation of this requirement. */
+  ComponentRequirementProto toProto() {
+    switch (kind()) {
+      case DEPENDENCY:
+        return ComponentRequirementProto.newBuilder()
+            .setDependency(TypeProtoConverter.toProto(type()))
+            .build();
+      case MODULE:
+        return ComponentRequirementProto.newBuilder()
+            .setModule(TypeProtoConverter.toProto(type()))
+            .build();
+      case BOUND_INSTANCE:
+        return ComponentRequirementProto.newBuilder()
+            .setBoundInstance(
+                BoundInstanceRequirement.newBuilder()
+                    .setKey(KeyFactory.toProto(key().get()))
+                    .setNullable(overrideNullPolicy().equals(Optional.of(NullPolicy.ALLOW)))
+                    .setVariableName(variableName()))
+            .build();
+    }
+    throw new AssertionError(this);
+  }
+
   static ComponentRequirement forDependency(TypeMirror type) {
     return new AutoValue_ComponentRequirement(
         Kind.DEPENDENCY,
diff --git a/java/dagger/internal/codegen/DeserializedComponentImplementationBuilder.java b/java/dagger/internal/codegen/DeserializedComponentImplementationBuilder.java
new file mode 100644
index 000000000..39bd2d687
--- /dev/null
+++ b/java/dagger/internal/codegen/DeserializedComponentImplementationBuilder.java
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.DaggerStreams.toImmutableList;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.MoreAnnotationValues.asAnnotationValues;
+import static dagger.internal.codegen.serialization.ProtoSerialization.fromAnnotationValue;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import dagger.internal.ComponentDefinitionType;
+import dagger.internal.ConfigureInitializationParameters;
+import dagger.internal.ModifiableBinding;
+import dagger.internal.ModifiableModule;
+import dagger.internal.codegen.ComponentImplementation.ConfigureInitializationMethod;
+import dagger.internal.codegen.serialization.BindingRequestProto;
+import dagger.internal.codegen.serialization.ComponentRequirementProto;
+import dagger.internal.codegen.serialization.FrameworkTypeWrapper;
+import dagger.internal.codegen.serialization.KeyProto;
+import dagger.model.Key;
+import dagger.model.RequestKind;
+import java.util.Optional;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Reconstructs {@link ComponentImplementation}s that have already been compiled. Uses metadata
+ * annotations on the generated type and it's methods to reconstitute the equivalent {@link
+ * ComponentImplementation} state.
+ */
+final class DeserializedComponentImplementationBuilder {
+  private final CompilerOptions compilerOptions;
+  private final ComponentCreatorImplementationFactory componentCreatorImplementationFactory;
+  private final TypeProtoConverter typeProtoConverter;
+  private final KeyFactory keyFactory;
+
+  @Inject
+  DeserializedComponentImplementationBuilder(
+      CompilerOptions compilerOptions,
+      ComponentCreatorImplementationFactory componentCreatorImplementationFactory,
+      TypeProtoConverter typeProtoConverter,
+      KeyFactory keyFactory) {
+    this.compilerOptions = compilerOptions;
+    this.componentCreatorImplementationFactory = componentCreatorImplementationFactory;
+    this.typeProtoConverter = typeProtoConverter;
+    this.keyFactory = keyFactory;
+  }
+
+  /** Creates a new {@link ComponentImplementation} from a compiled component. */
+  ComponentImplementation create(ComponentDescriptor component, TypeElement generatedComponent) {
+    Optional<ComponentImplementation> superclassImplementation =
+        deserializedSuperclassImplementation(
+            component, MoreTypes.asTypeElement(generatedComponent.getSuperclass()));
+
+    ComponentImplementation componentImplementation =
+        ComponentImplementation.forDeserializedComponent(
+            component,
+            ClassName.get(generatedComponent),
+            generatedComponent.getNestingKind(),
+            superclassImplementation,
+            compilerOptions);
+
+    componentImplementation.setCreatorImplementation(
+        superclassImplementation.isPresent()
+            ? Optional.empty()
+            : componentCreatorImplementationFactory.create(
+                componentImplementation, Optional.empty()));
+
+    // TODO(b/117833324): Consider omitting superclass implementations, so that only one instance of
+    // ComponentImplementation needs to be created (in most cases, we don't care about nested levels
+    // of superclass implementations, except for the base implementation). If that's possible, use
+    // getLocalAndInheritedMethods instead of getEnclosedElements() here.
+    for (ExecutableElement method : methodsIn(generatedComponent.getEnclosedElements())) {
+      getAnnotationMirror(method, ModifiableBinding.class)
+          .toJavaUtil()
+          .ifPresent(
+              annotation ->
+                  addModifiableBindingMethod(componentImplementation, method, annotation));
+
+      getAnnotationMirror(method, ModifiableModule.class)
+          .toJavaUtil()
+          .ifPresent(
+              annotation -> addModifiableModuleMethod(componentImplementation, method, annotation));
+
+      getAnnotationMirror(method, ConfigureInitializationParameters.class)
+          .toJavaUtil()
+          .ifPresent(
+              annotation ->
+                  setConfigureInitializationMethod(componentImplementation, method, annotation));
+    }
+
+    for (TypeElement nestedType : typesIn(generatedComponent.getEnclosedElements())) {
+      addChildImplementation(component, componentImplementation, nestedType);
+    }
+
+    return componentImplementation;
+  }
+
+  private Optional<ComponentImplementation> deserializedSuperclassImplementation(
+      ComponentDescriptor component, TypeElement superclassElement) {
+    return isAnnotationPresent(superclassElement, ComponentDefinitionType.class)
+        ? Optional.of(create(component, superclassElement))
+        : Optional.empty();
+  }
+
+  private void addModifiableBindingMethod(
+      ComponentImplementation componentImplementation,
+      ExecutableElement method,
+      AnnotationMirror metadataAnnotation) {
+    ModifiableBindingType modifiableBindingType =
+        ModifiableBindingType.valueOf(
+            getAnnotationValue(metadataAnnotation, "modifiableBindingType").getValue().toString());
+
+    BindingRequest request =
+        parseBindingRequest(getAnnotationValue(metadataAnnotation, "bindingRequest"));
+
+    ImmutableList<Key> multibindingContributions =
+        asAnnotationValues(getAnnotationValue(metadataAnnotation, "multibindingContributions"))
+            .stream()
+            .map(this::parseKey)
+            .collect(toImmutableList());
+
+    componentImplementation.addModifiableBindingMethod(
+        modifiableBindingType,
+        request,
+        method.getReturnType(),
+        methodDeclaration(method),
+        method.getModifiers().contains(FINAL));
+    componentImplementation.registerImplementedMultibindingKeys(request, multibindingContributions);
+  }
+
+  private BindingRequest fromProto(BindingRequestProto bindingRequest) {
+    Key key = keyFactory.fromProto(bindingRequest.getKey());
+    return bindingRequest.getFrameworkType().equals(FrameworkTypeWrapper.FrameworkType.UNKNOWN)
+        ? bindingRequest(key, RequestKind.valueOf(bindingRequest.getRequestKind().name()))
+        : bindingRequest(key, FrameworkType.valueOf(bindingRequest.getFrameworkType().name()));
+  }
+
+  /**
+   * Returns a {@link MethodSpec} for a {@link
+   * dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod}. The method contents
+   * are not relevant since this represents a method that has already been compiled.
+   *
+   * <p>Ideally this could be {@code MethodSpec.overriding(method).build()}, but that doesn't work
+   * for {@code final} methods
+   */
+  private MethodSpec methodDeclaration(ExecutableElement method) {
+    return methodBuilder(method.getSimpleName().toString())
+        .addModifiers(method.getModifiers())
+        .returns(TypeName.get(method.getReturnType()))
+        .build();
+  }
+
+  private void addModifiableModuleMethod(
+      ComponentImplementation componentImplementation,
+      ExecutableElement method,
+      AnnotationMirror metadataAnnotation) {
+    ComponentRequirement moduleRequirement =
+        parseComponentRequirement(getAnnotationValue(metadataAnnotation, "value"));
+    componentImplementation.registerModifiableModuleMethod(
+        moduleRequirement, method.getSimpleName().toString());
+  }
+
+  private void setConfigureInitializationMethod(
+      ComponentImplementation componentImplementation,
+      ExecutableElement method,
+      AnnotationMirror metadataAnnotation) {
+    ImmutableSet<ComponentRequirement> parameters =
+        asAnnotationValues(getAnnotationValue(metadataAnnotation, "value")).stream()
+            .map(this::parseComponentRequirement)
+            .collect(toImmutableSet());
+
+    componentImplementation.setConfigureInitializationMethod(
+        ConfigureInitializationMethod.create(MethodSpec.overriding(method).build(), parameters));
+  }
+
+  private void addChildImplementation(
+      ComponentDescriptor component,
+      ComponentImplementation componentImplementation,
+      TypeElement nestedType) {
+    getAnnotationMirror(nestedType, ComponentDefinitionType.class)
+        .toJavaUtil()
+        .map(annotation -> (TypeMirror) getAnnotationValue(annotation, "value").getValue())
+        .map(MoreTypes::asTypeElement)
+        .ifPresent(
+            componentDefinitionType -> {
+              ComponentDescriptor child =
+                  component.childComponentsByElement().get(componentDefinitionType);
+              componentImplementation.addChild(child, create(child, nestedType));
+            });
+  }
+
+  private Key parseKey(AnnotationValue annotationValue) {
+    return keyFactory.fromProto(
+        fromAnnotationValue(annotationValue, KeyProto.getDefaultInstance()));
+  }
+
+  private BindingRequest parseBindingRequest(AnnotationValue annotationValue) {
+    return fromProto(
+        fromAnnotationValue(annotationValue, BindingRequestProto.getDefaultInstance()));
+  }
+
+  private ComponentRequirement parseComponentRequirement(AnnotationValue annotationValue) {
+    return fromProto(
+        fromAnnotationValue(annotationValue, ComponentRequirementProto.getDefaultInstance()));
+  }
+
+  private ComponentRequirement fromProto(ComponentRequirementProto proto) {
+    switch (proto.getRequirementCase()) {
+      case MODULE:
+        return ComponentRequirement.forModule(typeProtoConverter.fromProto(proto.getModule()));
+      case DEPENDENCY:
+        return ComponentRequirement.forDependency(
+            typeProtoConverter.fromProto(proto.getDependency()));
+      case BOUND_INSTANCE:
+        return ComponentRequirement.forBoundInstance(
+            keyFactory.fromProto(proto.getBoundInstance().getKey()),
+            proto.getBoundInstance().getNullable(),
+            proto.getBoundInstance().getVariableName());
+      case REQUIREMENT_NOT_SET:
+        // fall through
+    }
+    throw new AssertionError(proto);
+  }
+}
diff --git a/java/dagger/internal/codegen/ForwardingCompilerOptions.java b/java/dagger/internal/codegen/ForwardingCompilerOptions.java
index 2272d3598..5c98b570a 100644
--- a/java/dagger/internal/codegen/ForwardingCompilerOptions.java
+++ b/java/dagger/internal/codegen/ForwardingCompilerOptions.java
@@ -90,6 +90,16 @@ boolean aheadOfTimeSubcomponents() {
     return delegate.aheadOfTimeSubcomponents();
   }
 
+  @Override
+  boolean forceUseSerializedComponentImplementations() {
+    return delegate.forceUseSerializedComponentImplementations();
+  }
+
+  @Override
+  boolean emitModifiableMetadataAnnotations() {
+    return delegate.emitModifiableMetadataAnnotations();
+  }
+
   @Override
   boolean useGradleIncrementalProcessing() {
     return delegate.useGradleIncrementalProcessing();
diff --git a/java/dagger/internal/codegen/JavacPluginModule.java b/java/dagger/internal/codegen/JavacPluginModule.java
index 7f55573fd..29e46a99d 100644
--- a/java/dagger/internal/codegen/JavacPluginModule.java
+++ b/java/dagger/internal/codegen/JavacPluginModule.java
@@ -103,6 +103,16 @@ boolean aheadOfTimeSubcomponents() {
         return false;
       }
 
+      @Override
+      boolean forceUseSerializedComponentImplementations() {
+        return false;
+      }
+
+      @Override
+      boolean emitModifiableMetadataAnnotations() {
+        return false;
+      }
+
       @Override
       boolean useGradleIncrementalProcessing() {
         return false;
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
index 633c30604..b6b355f8d 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -37,6 +37,7 @@
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.BindsOptionalOf;
+import dagger.internal.codegen.serialization.KeyProto;
 import dagger.model.Key;
 import dagger.model.Key.MultibindingContributionIdentifier;
 import dagger.model.RequestKind;
@@ -65,11 +66,19 @@
 final class KeyFactory {
   private final DaggerTypes types;
   private final DaggerElements elements;
+  private final TypeProtoConverter typeProtoConverter;
+  private final AnnotationProtoConverter annotationProtoConverter;
 
   @Inject
-  KeyFactory(DaggerTypes types, DaggerElements elements) {
+  KeyFactory(
+      DaggerTypes types,
+      DaggerElements elements,
+      TypeProtoConverter typeProtoConverter,
+      AnnotationProtoConverter annotationProtoConverter) {
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
+    this.typeProtoConverter = typeProtoConverter;
+    this.annotationProtoConverter = annotationProtoConverter;
   }
 
   private TypeMirror boxPrimitives(TypeMirror type) {
@@ -424,4 +433,36 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
             .type(extractKeyType(getRequestKind(optionalValueType), optionalValueType))
             .build());
   }
+
+  /** Translates a {@link Key} to a proto representation. */
+  static KeyProto toProto(Key key) {
+    KeyProto.Builder builder =
+        KeyProto.newBuilder().setType(TypeProtoConverter.toProto(key.type()));
+    key.qualifier().map(AnnotationProtoConverter::toProto).ifPresent(builder::setQualifier);
+    key.multibindingContributionIdentifier()
+        .ifPresent(
+            mci ->
+                builder
+                    .getMultibindingContributionIdentifierBuilder()
+                    .setModule(mci.module())
+                    .setBindingElement(mci.bindingElement()));
+    return builder.build();
+  }
+
+  /** Creates a {@link Key} from its proto representation. */
+  Key fromProto(KeyProto key) {
+    Key.Builder builder = Key.builder(typeProtoConverter.fromProto(key.getType()));
+    if (key.hasQualifier()) {
+      builder.qualifier(annotationProtoConverter.fromProto(key.getQualifier()));
+    }
+    if (key.hasMultibindingContributionIdentifier()) {
+      KeyProto.MultibindingContributionIdentifier multibindingContributionIdentifier =
+          key.getMultibindingContributionIdentifier();
+      builder.multibindingContributionIdentifier(
+          new MultibindingContributionIdentifier(
+              multibindingContributionIdentifier.getBindingElement(),
+              multibindingContributionIdentifier.getModule()));
+    }
+    return builder.build();
+  }
 }
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index 4481f3e54..28bf76454 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -27,6 +27,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.MethodSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ComponentImplementation.MethodSpecKind;
 import dagger.internal.codegen.MethodBindingExpression.MethodImplementationStrategy;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.model.BindingKind;
@@ -62,22 +63,23 @@
   }
 
   /**
-   * Records the binding exposed by the given component method as modifiable, if it is, and returns
-   * the {@link ModifiableBindingType} associated with the binding.
+   * Adds {@code method} to the component implementation. If the binding for the method is
+   * modifiable, also registers the relevant modifiable binding information.
    */
-  ModifiableBindingType registerComponentMethodIfModifiable(
+  void addPossiblyModifiableComponentMethod(
       ComponentMethodDescriptor componentMethod, MethodSpec method) {
     BindingRequest request = bindingRequest(componentMethod.dependencyRequest().get());
     ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
     if (modifiableBindingType.isModifiable()) {
-      componentImplementation.registerModifiableBindingMethod(
+      componentImplementation.addModifiableComponentMethod(
           modifiableBindingType,
           request,
           componentMethod.resolvedReturnType(types),
           method,
           newModifiableBindingWillBeFinalized(modifiableBindingType, request));
+    } else {
+      componentImplementation.addMethod(MethodSpecKind.COMPONENT_METHOD, method);
     }
-    return modifiableBindingType;
   }
 
   /**
@@ -381,8 +383,17 @@ private boolean shouldModifyImplementation(
           // Futures backed by provision bindings are inlined and contain no wrapping producer, so
           // if the binding is modifiable and is resolved as a provision binding in a superclass
           // but later resolved as a production binding, we can't take the same shortcut as before.
-          if (componentImplementation.superclassImplementation().isPresent()) {
-            return bindingTypeChanged(request, resolvedBindings);
+          Optional<ComponentImplementation> superclassImplementation =
+              componentImplementation.superclassImplementation();
+          if (superclassImplementation.isPresent()) {
+            if (superclassImplementation.get().isDeserializedImplementation()) {
+              // TODO(b/117833324): consider serializing the binding type so that we don't need to
+              // branch here. Or, instead, consider removing this optimization entirely if there
+              // aren't that many FUTURE entry point methods to justify the extra code.
+              break;
+            } else {
+              return bindingTypeChanged(request, resolvedBindings);
+            }
           }
           return false;
 
diff --git a/java/dagger/internal/codegen/ModifiableBindingMethods.java b/java/dagger/internal/codegen/ModifiableBindingMethods.java
index 55dd1ef13..ead708df6 100644
--- a/java/dagger/internal/codegen/ModifiableBindingMethods.java
+++ b/java/dagger/internal/codegen/ModifiableBindingMethods.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 
 import com.google.auto.common.MoreTypes;
@@ -43,13 +42,14 @@
   private final Map<BindingRequest, ModifiableBindingMethod> methods = Maps.newLinkedHashMap();
 
   /** Registers a new method encapsulating a modifiable binding. */
-  void addNewModifiableMethod(
+  void addModifiableMethod(
       ModifiableBindingType type,
       BindingRequest request,
       TypeMirror returnType,
       MethodSpec method,
       boolean finalized) {
-    checkArgument(type.isModifiable());
+    // It's ok for the type to not be modifiable, since it could be overriding a previously
+    // modifiable method (such as with addReimplementedMethod).
     addMethod(ModifiableBindingMethod.create(type, request, returnType, method, finalized));
   }
 
diff --git a/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java b/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java
index 8cd104fae..ba9fe4146 100644
--- a/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java
+++ b/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java
@@ -22,10 +22,12 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.FeatureStatus.DISABLED;
 import static dagger.internal.codegen.FeatureStatus.ENABLED;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.EMIT_MODIFIABLE_METADATA_ANNOTATIONS;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.EXPERIMENTAL_AHEAD_OF_TIME_SUBCOMPONENTS;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.EXPERIMENTAL_ANDROID_MODE;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.FAST_INIT;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.FLOATING_BINDS_METHODS;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.FORCE_USE_SERIALIZED_COMPONENT_IMPLEMENTATIONS;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.FORMAT_GENERATED_SOURCE;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT;
 import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM;
@@ -128,6 +130,16 @@ boolean aheadOfTimeSubcomponents() {
     return isEnabled(EXPERIMENTAL_AHEAD_OF_TIME_SUBCOMPONENTS);
   }
 
+  @Override
+  boolean forceUseSerializedComponentImplementations() {
+    return isEnabled(FORCE_USE_SERIALIZED_COMPONENT_IMPLEMENTATIONS);
+  }
+
+  @Override
+  boolean emitModifiableMetadataAnnotations() {
+    return isEnabled(EMIT_MODIFIABLE_METADATA_ANNOTATIONS);
+  }
+
   @Override
   boolean useGradleIncrementalProcessing() {
     return isEnabled(USE_GRADLE_INCREMENTAL_PROCESSING);
@@ -250,6 +262,10 @@ public boolean isEnabled(ProcessingEnvironment processingEnvironment) {
 
     EXPERIMENTAL_AHEAD_OF_TIME_SUBCOMPONENTS,
 
+    FORCE_USE_SERIALIZED_COMPONENT_IMPLEMENTATIONS,
+
+    EMIT_MODIFIABLE_METADATA_ANNOTATIONS(ENABLED),
+
     FLOATING_BINDS_METHODS,
     ;
 
diff --git a/java/dagger/internal/codegen/TypeProtoConverter.java b/java/dagger/internal/codegen/TypeProtoConverter.java
new file mode 100644
index 000000000..4e4f6151c
--- /dev/null
+++ b/java/dagger/internal/codegen/TypeProtoConverter.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+import com.google.auto.common.MoreTypes;
+import dagger.internal.codegen.serialization.TypeProto;
+import dagger.internal.codegen.serialization.TypeProto.PrimitiveKind;
+import javax.inject.Inject;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.WildcardType;
+
+/** Converts {@link TypeMirror}s to {@link TypeProto}s and vice-versa. */
+final class TypeProtoConverter {
+  // TODO(ronshapiro): if DaggerTypes and DaggerElements become public, move this file to
+  // dagger.internal.codegen.serialization
+  private final DaggerTypes types;
+  private final DaggerElements elements;
+
+  @Inject
+  TypeProtoConverter(DaggerTypes types, DaggerElements elements) {
+    this.types = types;
+    this.elements = elements;
+  }
+
+  /** Translates a {@link TypeMirror} to a proto representation. */
+  static TypeProto toProto(TypeMirror type) {
+    TypeProto.Builder builder = TypeProto.newBuilder();
+    int arrayDimensions = 0;
+    while (type.getKind().equals(TypeKind.ARRAY)) {
+      type = MoreTypes.asArray(type).getComponentType();
+      arrayDimensions++;
+    }
+    builder.setArrayDimensions(arrayDimensions);
+    if (type.getKind().isPrimitive()) {
+      builder.setPrimitiveKind(PrimitiveKind.valueOf(type.getKind().name()));
+    } else if (type.getKind().equals(TypeKind.WILDCARD)) {
+      WildcardType wildcardType = MoreTypes.asWildcard(type);
+      TypeProto.Wildcard.Builder wildcardBuilder = TypeProto.Wildcard.newBuilder();
+      if (wildcardType.getExtendsBound() != null) {
+        wildcardBuilder.setExtendsBound(toProto(wildcardType.getExtendsBound()));
+      } else if (wildcardType.getSuperBound() != null) {
+        wildcardBuilder.setSuperBound(toProto(wildcardType.getSuperBound()));
+      }
+      builder.setWildcard(wildcardBuilder);
+    } else {
+      TypeElement typeElement = MoreTypes.asTypeElement(type);
+      DeclaredType declaredType = MoreTypes.asDeclared(type);
+      TypeMirror enclosingType = declaredType.getEnclosingType();
+      if (enclosingType.getKind().equals(TypeKind.NONE)) {
+        builder.setQualifiedName(typeElement.getQualifiedName().toString());
+      } else {
+        builder
+            .setEnclosingType(toProto(enclosingType))
+            .setSimpleName(typeElement.getSimpleName().toString());
+      }
+      declaredType.getTypeArguments().stream()
+          .map(TypeProtoConverter::toProto)
+          .forEachOrdered(builder::addTypeArguments);
+    }
+    return builder.build();
+  }
+
+  /** Creates an {@link TypeMirror} from its proto representation. */
+  TypeMirror fromProto(TypeProto type) {
+    if (type.hasWildcard()) {
+      return wildcardType(type.getWildcard());
+    }
+
+    TypeMirror[] typeArguments =
+        type.getTypeArgumentsList().stream().map(this::fromProto).toArray(TypeMirror[]::new);
+    TypeMirror typeMirror;
+    if (!type.getPrimitiveKind().equals(PrimitiveKind.UNKNOWN)) {
+      typeMirror = types.getPrimitiveType(TypeKind.valueOf(type.getPrimitiveKind().name()));
+    } else if (type.hasEnclosingType()) {
+      DeclaredType enclosingType = MoreTypes.asDeclared(fromProto(type.getEnclosingType()));
+      TypeElement typeElement =
+          typesIn(enclosingType.asElement().getEnclosedElements()).stream()
+              .filter(inner -> inner.getSimpleName().contentEquals(type.getSimpleName()))
+              .findFirst()
+              .get();
+      typeMirror = types.getDeclaredType(enclosingType, typeElement, typeArguments);
+    } else {
+      typeMirror =
+          types.getDeclaredType(elements.getTypeElement(type.getQualifiedName()), typeArguments);
+    }
+    for (int i = 0; i < type.getArrayDimensions(); i++) {
+      typeMirror = types.getArrayType(typeMirror);
+    }
+    return typeMirror;
+  }
+
+  private TypeMirror wildcardType(TypeProto.Wildcard wildcard) {
+    if (wildcard.hasExtendsBound()) {
+      return types.getWildcardType(fromProto(wildcard.getExtendsBound()), null);
+    } else if (wildcard.hasSuperBound()) {
+      return types.getWildcardType(null, fromProto(wildcard.getSuperBound()));
+    } else {
+      return types.getWildcardType(null, null);
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/serialization/BUILD b/java/dagger/internal/codegen/serialization/BUILD
new file mode 100644
index 000000000..2bc02b420
--- /dev/null
+++ b/java/dagger/internal/codegen/serialization/BUILD
@@ -0,0 +1,41 @@
+# Copyright (C) 2019 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#    Serialized forms of types used in the Dagger processor.
+
+package(default_visibility = ["//:src"])
+
+proto_library(
+    name = "serialization_proto",
+    srcs = ["serialization.proto"],
+    visibility = ["//visibility:private"],
+)
+
+java_proto_library(
+    name = "serialization_java_proto",
+    visibility = ["//visibility:private"],
+    deps = [":serialization_proto"],
+)
+
+java_library(
+    name = "serialization",
+    srcs = glob(["*.java"]),
+    exports = [":serialization_java_proto"],
+    deps = [
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/javapoet",
+        "@google_bazel_common//third_party/java/protobuf",
+    ],
+)
diff --git a/java/dagger/internal/codegen/serialization/ProtoSerialization.java b/java/dagger/internal/codegen/serialization/ProtoSerialization.java
new file mode 100644
index 000000000..1449e9d0b
--- /dev/null
+++ b/java/dagger/internal/codegen/serialization/ProtoSerialization.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen.serialization;
+
+import static com.google.common.io.BaseEncoding.base64;
+
+import com.google.common.io.BaseEncoding;
+import com.google.protobuf.InvalidProtocolBufferException;
+import com.google.protobuf.Message;
+import com.squareup.javapoet.CodeBlock;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.util.SimpleAnnotationValueVisitor8;
+
+/**
+ * Serializes and deserializes {@link Message}s using {@link BaseEncoding#base64()} for use in
+ * annotation values.
+ */
+public final class ProtoSerialization {
+  /** Returns a {@link CodeBlock} of {@code message} serialized as a String. */
+  public static CodeBlock toAnnotationValue(Message message) {
+    return CodeBlock.of("$S", base64().encode(message.toByteArray()));
+  }
+
+  /**
+   * Returns a {@link Message T} from the deserialized the String {@code value}.
+   *
+   * @throws IllegalArgumentException if {@code value} represents an {@link AnnotationValue} who's
+   *     type is not {@link String}
+   */
+  public static <T extends Message> T fromAnnotationValue(
+      AnnotationValue value, T defaultInstance) {
+    byte[] bytes = base64().decode(value.accept(STRING_VALUE, null));
+    Message message;
+    try {
+      message = defaultInstance.getParserForType().parseFrom(bytes);
+    } catch (InvalidProtocolBufferException e) {
+      throw new InconsistentSerializedProtoException(e);
+    }
+    @SuppressWarnings("unchecked") // guaranteed by proto API
+    T t = (T) message;
+    return t;
+  }
+
+  private static final AnnotationValueVisitor<String, Void> STRING_VALUE =
+      new SimpleAnnotationValueVisitor8<String, Void>() {
+        @Override
+        public String visitString(String s, Void ignored) {
+          return s;
+        }
+
+        @Override
+        protected String defaultAction(Object o, Void ignored) {
+          throw new IllegalArgumentException(o + " is not a String");
+        }
+      };
+
+  /**
+   * An exception thrown when the proto that's serialized in a compiled subcomponent implementation
+   * is from a different version than the current compiler's.
+   */
+  public static final class InconsistentSerializedProtoException extends RuntimeException {
+    InconsistentSerializedProtoException(Throwable cause) {
+      super(cause);
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/serialization/serialization.proto b/java/dagger/internal/codegen/serialization/serialization.proto
new file mode 100644
index 000000000..e6c957765
--- /dev/null
+++ b/java/dagger/internal/codegen/serialization/serialization.proto
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Serialized forms of types used in the Dagger processor. The wire format of
+// these types is not guaranteed to remain compatible over time; serialization
+// is only expected to function correctly within an individual version of the
+// Dagger processor.
+
+syntax = "proto3";
+
+package dagger.internal.codegen.serialization;
+option java_package = "dagger.internal.codegen.serialization";
+option java_multiple_files = true;
+
+// TODO(ronshapiro): consider exposing some of these in
+// dagger.model.serialization
+
+// Serialized form of `dagger.internal.codegen.BindingRequest`
+message BindingRequestProto {
+  KeyProto key = 1;
+  RequestKindWrapper.RequestKind request_kind = 2;
+  FrameworkTypeWrapper.FrameworkType framework_type = 3;
+}
+
+message RequestKindWrapper {
+  // Serialized form of `dagger.model.RequestKind`
+  enum RequestKind {
+    UNKNOWN = 0;
+    INSTANCE = 1;
+    PROVIDER = 2;
+    LAZY = 3;
+    PROVIDER_OF_LAZY = 4;
+    MEMBERS_INJECTION = 5;
+    PRODUCER = 6;
+    PRODUCED = 7;
+    FUTURE = 8;
+  }
+}
+
+message FrameworkTypeWrapper {
+  // Serialized form of `dagger.internal.codegen.FrameworkType`
+  enum FrameworkType {
+    UNKNOWN = 0;
+    PROVIDER = 1;
+    PRODUCER_NODE = 2;
+  }
+}
+
+// Serialized form of `dagger.model.Key`
+message KeyProto {
+  TypeProto type = 1;
+  AnnotationProto qualifier = 2;
+  MultibindingContributionIdentifier multibinding_contribution_identifier =
+      3;
+
+  // Serialized form of `dagger.model.Key.MultibindingContributionIdentifier`
+  message MultibindingContributionIdentifier {
+    string module = 1;
+    string binding_element = 2;
+  }
+}
+
+// Serialized form of `javax.lang.model.type.TypeMirror`
+message TypeProto {
+  PrimitiveKind primitive_kind = 1;
+
+  // The qualified name of the type. Absent if this is an inner type.
+  string qualified_name = 2;
+
+  // The enclosing type if this is an inner type, otherwise absent.
+  TypeProto enclosing_type = 3;
+
+  // Simple name of the type if this is an inner type, otherwise absent.
+  string simple_name = 4;
+
+  repeated TypeProto type_arguments = 5;
+
+  message Wildcard {
+    TypeProto extends_bound = 1;
+    TypeProto super_bound = 2;
+  }
+  Wildcard wildcard = 6;
+
+  int32 array_dimensions = 7;
+
+  // Kinds of primitive types
+  enum PrimitiveKind {
+    UNKNOWN = 0;
+    BOOLEAN = 1;
+    BYTE = 2;
+    SHORT = 3;
+    CHAR = 4;
+    INT = 5;
+    FLOAT = 6;
+    LONG = 7;
+    DOUBLE = 8;
+  }
+}
+
+// Serialized form of `javax.lang.model.element.AnnotationMirror`
+message AnnotationProto {
+  TypeProto annotation_type = 1;
+  map<string, AnnotationValueProto> values = 2;
+}
+
+// Serialized form of `javax.lang.model.element.AnnotationValue`
+message AnnotationValueProto {
+  Kind kind = 1;
+  bool boolean_value = 2;
+  int32 int_value = 3;
+  int64 long_value = 4;
+  float float_value = 5;
+  double double_value = 6;
+  string string_value = 7;
+  TypeProto class_literal = 8;
+  TypeProto enum_type = 9;
+  string enum_name = 10;
+  AnnotationProto nested_annotation = 11;
+
+  repeated AnnotationValueProto array_values = 12;
+
+  // The type of annotation value
+  enum Kind {
+    UNKNOWN = 0;
+    BOOLEAN = 1;
+    BYTE = 2;
+    SHORT = 3;
+    CHAR = 4;
+    INT = 5;
+    FLOAT = 6;
+    LONG = 7;
+    DOUBLE = 8;
+    STRING = 9;
+    CLASS_LITERAL = 10;
+    ENUM = 11;
+    ANNOTATION = 12;
+    ARRAY = 13;
+  }
+}
+
+// Serialized form of `dagger.internal.codegen.ComponentRequirement`
+message ComponentRequirementProto {
+  oneof requirement {
+    TypeProto dependency = 1;
+    TypeProto module = 2;
+    BoundInstanceRequirement bound_instance = 3;
+  }
+
+  message BoundInstanceRequirement {
+    KeyProto key = 1;
+    bool nullable = 2;
+    string variable_name = 3;
+  }
+}
diff --git a/java/dagger/model/Key.java b/java/dagger/model/Key.java
index 53ee39194..03dd41c76 100644
--- a/java/dagger/model/Key.java
+++ b/java/dagger/model/Key.java
@@ -27,6 +27,8 @@
 import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableMap;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.CheckReturnValue;
 import com.squareup.javapoet.CodeBlock;
 import java.util.List;
 import java.util.Objects;
@@ -176,6 +178,7 @@ public static Builder builder(TypeMirror type) {
   }
 
   /** A builder for {@link Key}s. */
+  @CanIgnoreReturnValue
   @AutoValue.Builder
   public abstract static class Builder {
     abstract Builder wrappedType(Equivalence.Wrapper<TypeMirror> wrappedType);
@@ -203,6 +206,7 @@ public abstract Builder multibindingContributionIdentifier(
     public abstract Builder multibindingContributionIdentifier(
         MultibindingContributionIdentifier identifier);
 
+    @CheckReturnValue
     public abstract Key build();
   }
 
@@ -222,9 +226,27 @@ public abstract Builder multibindingContributionIdentifier(
      */
     @Deprecated
     public MultibindingContributionIdentifier(
+        // TODO(ronshapiro): reverse the order of these parameters
         ExecutableElement bindingMethod, TypeElement contributingModule) {
-      this.module = contributingModule.getQualifiedName().toString();
-      this.bindingElement = bindingMethod.getSimpleName().toString();
+      this(
+          bindingMethod.getSimpleName().toString(),
+          contributingModule.getQualifiedName().toString());
+    }
+
+    // TODO(ronshapiro,dpb): create KeyProxies so that these constructors don't need to be public.
+    @Deprecated
+    public MultibindingContributionIdentifier(String bindingElement, String module) {
+      this.module = module;
+      this.bindingElement = bindingElement;
+    }
+
+    /**
+     * @deprecated This is only meant to be called from code in {@code dagger.internal.codegen}.
+     * It is not part of a specified API and may change at any point.
+     */
+    @Deprecated
+    public String module() {
+      return module;
     }
 
     /**
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java
index c92beb3e9..a02f7d32a 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java
@@ -118,12 +118,16 @@ public void setMultibindings_contributionsInAncestorOnly() {
             "package test;",
             "",
             "import dagger.internal.GenerationOptions;",
+            "import java.util.Set;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATION_OPTIONS_ANNOTATION,
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
             "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public abstract Set<InAncestor> contributionsInAncestor();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -652,6 +656,9 @@ public void setMultibindings_newSubclass() {
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
             "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public abstract RequiresInAncestorSet missingWithSetDependency();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -791,6 +798,10 @@ public void setMultibinding_requestedAsInstanceInLeaf_requestedAsFrameworkInstan
             "    return ImmutableSet.<Multibound>of(",
             "        LeafModule_ContributionFactory.contribution());",
             "  }",
+            "",
+            "  @Override",
+            "  public abstract MissingInLeaf_WillDependOnFrameworkInstance",
+            "      willDependOnFrameworkInstance();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -903,12 +914,16 @@ public void missingMultibindingInLeaf_onlyContributionsInAncestor_notReModifiedI
             "package test;",
             "",
             "import dagger.internal.GenerationOptions;",
+            "import java.util.Set;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATION_OPTIONS_ANNOTATION,
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
             "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public abstract Set<Object> set();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -1291,12 +1306,16 @@ public void mapMultibindings_contributionsInAncestorOnly() {
             "package test;",
             "",
             "import dagger.internal.GenerationOptions;",
+            "import java.util.Map;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATION_OPTIONS_ANNOTATION,
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
             "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public abstract Map<String, InAncestor> contributionsInAncestor();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -2010,6 +2029,10 @@ public void mapMultibinding_requestedAsInstanceInLeaf_requestedAsFrameworkInstan
             "    return ImmutableMap.<Integer, Multibound>of(",
             "        111, LeafModule_ContributionFactory.contribution());",
             "  }",
+            "",
+            "  @Override",
+            "  public abstract MissingInLeaf_WillDependOnFrameworkInstance",
+            "      willDependOnFrameworkInstance();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index f8770c457..a651def68 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -67,6 +67,9 @@ public void missingBindings_fromComponentMethod() {
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
             "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public abstract MissingInLeaf missingFromComponentMethod();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -165,6 +168,9 @@ public void missingBindings_dependsOnBindingWithMatchingComponentMethod() {
             "  protected DaggerLeaf() {}",
             "",
             "  @Override",
+            "  public abstract MissingInLeaf missingComponentMethod();",
+            "",
+            "  @Override",
             "  public DependsOnComponentMethod dependsOnComponentMethod() {",
             "    return new DependsOnComponentMethod(missingComponentMethod());",
             "  }",
@@ -751,6 +757,9 @@ public void generatedInstanceBinding() {
             "public abstract class DaggerAncestor implements Ancestor {",
             "  protected DaggerAncestor() {}",
             "",
+            "  @Override",
+            "  public abstract Leaf.Builder leaf();",
+            "",
             "  protected abstract class LeafImpl extends DaggerLeaf {",
             "    protected LeafImpl() {}",
             "  }",
@@ -1484,12 +1493,17 @@ public void optionalBindings_boundInAncestorAndSatisfiedInGrandAncestor() {
             "package test;",
             "",
             "import dagger.internal.GenerationOptions;",
+            "import java.util.Optional;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATION_OPTIONS_ANNOTATION,
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
             "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public abstract Optional<SatisfiedInGrandAncestor>",
+            "      boundInAncestorSatisfiedInGrandAncestor();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -3190,6 +3204,10 @@ public void subcomponentBuilders() {
             "    return LeafModule_FromModuleFactory.fromModule(leafModule());",
             "  }",
             "",
+            "  @Override",
+            "  public abstract InducesDependenciesOnBuilderFields",
+            "      inducesDependenciesOnBuilderFields();",
+            "",
             "  protected LeafModule leafModule() {",
             "    return leafModule;",
             "  }",
@@ -3270,6 +3288,9 @@ public void subcomponentBuilders() {
             "public abstract class DaggerAncestor implements Ancestor {",
             "  protected DaggerAncestor() {}",
             "",
+            "  @Override",
+            "  public abstract Leaf.Builder leaf();",
+            "",
             "  protected abstract class LeafImpl extends DaggerLeaf {",
             "    private String inducedInSubclass;",
             "",
@@ -3778,6 +3799,9 @@ public void bindsWithMissingDependency() {
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
             "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public abstract Object bindsWithMissingDependencyInLeaf();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -4324,6 +4348,9 @@ public void modifiableBindingMethods_namesDedupedAcrossImplementations() {
             "    return LeafModule_DepOnFooThingFactory.depOnFooThing(getThing());",
             "  }",
             "",
+            "  @Override",
+            "  public abstract WillInduceSetOfRunnable willInduceSetOfRunnable();",
+            "",
             "  protected abstract Thing getThing();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
@@ -4471,6 +4498,9 @@ public void subcomponentInducedFromAncestor() {
             GENERATED_ANNOTATION,
             "public abstract class DaggerMaybeLeaf implements MaybeLeaf {",
             "  protected DaggerMaybeLeaf() {}",
+            "",
+            "  @Override",
+            "  public abstract Inducer inducer();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -4604,6 +4634,9 @@ public void rootScopedAtInjectConstructor_effectivelyMissingInSubcomponent() {
             GENERATED_ANNOTATION,
             "public abstract class DaggerLeaf implements Leaf {",
             "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public abstract AtInjectRootScoped shouldBeEffectivelyMissingInLeaf();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
diff --git a/javatests/dagger/internal/codegen/AnnotationProtoConverterTest.java b/javatests/dagger/internal/codegen/AnnotationProtoConverterTest.java
new file mode 100644
index 000000000..cfd528742
--- /dev/null
+++ b/javatests/dagger/internal/codegen/AnnotationProtoConverterTest.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.testing.compile.CompilationRule;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.lang.model.element.AnnotationMirror;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests {@link TypeProtoConverter}. */
+@RunWith(JUnit4.class)
+public class AnnotationProtoConverterTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  private DaggerElements elements;
+  private DaggerTypes types;
+  private AnnotationProtoConverter annotationProtoConverter;
+
+  @Before
+  public void setUp() {
+    this.elements = new DaggerElements(compilationRule.getElements(), compilationRule.getTypes());
+    this.types = new DaggerTypes(compilationRule.getTypes(), elements);
+    this.annotationProtoConverter =
+        new AnnotationProtoConverter(new TypeProtoConverter(types, elements));
+  }
+
+  @Retention(RetentionPolicy.RUNTIME)
+  @interface TestAnnotation {
+    byte b();
+    boolean bool();
+    short s();
+    char c();
+    int i();
+    long l();
+    double d();
+    float f();
+
+    String string();
+    RetentionPolicy enumValue();
+    Class<?> classValue();
+    HasDefaults[] nestedAnnotations();
+  }
+
+  @Retention(RetentionPolicy.RUNTIME)
+  @interface HasDefaults {
+    int value() default 2;
+  }
+
+  @TestAnnotation(
+      b = 1,
+      bool = true,
+      s = 2,
+      c = 'c',
+      i = 4,
+      l = 5,
+      d = 6.0d,
+      f = 7.0f,
+      string = "hello, world",
+      enumValue = RetentionPolicy.CLASS,
+      classValue = AnnotationProtoConverter.class,
+      nestedAnnotations = {@HasDefaults, @HasDefaults(8)})
+  static class TestSubject {}
+
+  @Test
+  public void conversion() {
+    AnnotationMirror actual =
+        getOnlyElement(elements.getTypeElement(TestSubject.class).getAnnotationMirrors());
+    AnnotationMirror translated =
+        annotationProtoConverter.fromProto(AnnotationProtoConverter.toProto(actual));
+    assertThat(AnnotationMirrors.equivalence().equivalent(actual, translated)).isTrue();
+  }
+}
diff --git a/javatests/dagger/internal/codegen/BUILD b/javatests/dagger/internal/codegen/BUILD
index bb902baef..250d75faf 100644
--- a/javatests/dagger/internal/codegen/BUILD
+++ b/javatests/dagger/internal/codegen/BUILD
@@ -33,6 +33,7 @@ GenJavaTests(
         "//java/dagger/internal/codegen:processor",
         "//java/dagger/internal/codegen:validation",
         "//java/dagger/internal/codegen:writing",
+        "//java/dagger/internal/codegen/serialization",
         "//java/dagger/model",
         "//java/dagger/model/testing",
         "//java/dagger/producers",
diff --git a/javatests/dagger/internal/codegen/CompilerMode.java b/javatests/dagger/internal/codegen/CompilerMode.java
index bd46bf99f..23aa3127a 100644
--- a/javatests/dagger/internal/codegen/CompilerMode.java
+++ b/javatests/dagger/internal/codegen/CompilerMode.java
@@ -23,8 +23,11 @@
 enum CompilerMode {
   DEFAULT_MODE,
   FAST_INIT_MODE("-Adagger.fastInit=enabled"),
-  AHEAD_OF_TIME_SUBCOMPONENTS_MODE("-Adagger.experimentalAheadOfTimeSubcomponents=enabled"),
-  JAVA7("-source", "7", "-target", "7");
+  AHEAD_OF_TIME_SUBCOMPONENTS_MODE(
+      "-Adagger.experimentalAheadOfTimeSubcomponents=enabled",
+      "-Adagger.emitModifiableMetadataAnnotations=disabled"),
+  JAVA7("-source", "7", "-target", "7"),
+  ;
 
   /** Returns the compiler modes as a list of parameters for parameterized tests */
   static final ImmutableList<Object[]> TEST_PARAMETERS =
diff --git a/javatests/dagger/internal/codegen/KeyFactoryTest.java b/javatests/dagger/internal/codegen/KeyFactoryTest.java
index 69dfeaa50..f1b48550c 100644
--- a/javatests/dagger/internal/codegen/KeyFactoryTest.java
+++ b/javatests/dagger/internal/codegen/KeyFactoryTest.java
@@ -61,7 +61,9 @@
   @Before public void setUp() {
     this.elements = new DaggerElements(compilationRule.getElements(), compilationRule.getTypes());
     this.types = new DaggerTypes(compilationRule.getTypes(), elements);
-    this.keyFactory = new KeyFactory(types, elements);
+    TypeProtoConverter typeProtoConverter = new TypeProtoConverter(types, elements);
+    this.keyFactory = new KeyFactory(
+        types, elements, typeProtoConverter, new AnnotationProtoConverter(typeProtoConverter));
   }
 
   @Test public void forInjectConstructorWithResolvedType() {
diff --git a/javatests/dagger/internal/codegen/TypeProtoConverterTest.java b/javatests/dagger/internal/codegen/TypeProtoConverterTest.java
new file mode 100644
index 000000000..056fe5ac4
--- /dev/null
+++ b/javatests/dagger/internal/codegen/TypeProtoConverterTest.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertWithMessage;
+import static javax.lang.model.util.ElementFilter.fieldsIn;
+
+import com.google.testing.compile.CompilationRule;
+import dagger.internal.Factory;
+import dagger.internal.codegen.serialization.TypeProto;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.type.TypeMirror;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests {@link TypeProtoConverter}. */
+@RunWith(JUnit4.class)
+public class TypeProtoConverterTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  private DaggerElements elements;
+  private DaggerTypes types;
+  private TypeProtoConverter typeProtoConverter;
+
+  @Before
+  public void setUp() {
+    this.elements = new DaggerElements(compilationRule.getElements(), compilationRule.getTypes());
+    this.types = new DaggerTypes(compilationRule.getTypes(), elements);
+    this.typeProtoConverter = new TypeProtoConverter(types, elements);
+  }
+
+  static class Outer<O> {
+    @SuppressWarnings("ClassCanBeStatic") // We want to specifically test inner classes
+    class Inner<I> {}
+  }
+
+  @SuppressWarnings({"rawtypes", "unused"})
+  static class TypeMirrorConversionSubjects {
+    private Map rawMap;
+    private List<String> listOfString;
+    private List<HashMap<String, Integer>> listOfHashMapOfStringToInteger;
+    private Map<HashMap<String, Integer>, Set<Factory>> mapOfHashMapOfStringToIntegerToSetOfFactory;
+    private Map<HashMap<String, Integer>, Set<Factory>>[][]
+        arrayOfArrayOfMapOfHashMapOfStringToIntegerToSetOfFactory;
+    private Map<HashMap<?, Integer>, ?> mapOfHashMapOfWildcardToIntegerToWildcard;
+    private List<? extends String> listOfWildcardExtendsString;
+    private List<? extends Set<? super String>> listOfWildcardExtendsSetOfWildcardSuperString;
+    private Outer<Object>.Inner<Integer> outerOfObjectDotInnerOfInteger;
+    private List<int[]> listOfIntArray;
+    private List<? extends CharSequence[]> listOfWildcardExtendsCharSequenceArray;
+  }
+
+  @Test
+  public void typeMirrorProtoConversions() {
+    assertProtoConversionEquality(fieldType("rawMap"));
+    assertProtoConversionEquality(fieldType("listOfString"));
+    assertProtoConversionEquality(fieldType("listOfHashMapOfStringToInteger"));
+    assertProtoConversionEquality(fieldType("mapOfHashMapOfStringToIntegerToSetOfFactory"));
+    assertProtoConversionEquality(
+        fieldType("arrayOfArrayOfMapOfHashMapOfStringToIntegerToSetOfFactory"));
+    assertProtoConversionEquality(fieldType("mapOfHashMapOfWildcardToIntegerToWildcard"));
+    assertProtoConversionEquality(fieldType("listOfWildcardExtendsString"));
+    assertProtoConversionEquality(fieldType("listOfWildcardExtendsSetOfWildcardSuperString"));
+    assertProtoConversionEquality(fieldType("outerOfObjectDotInnerOfInteger"));
+    assertProtoConversionEquality(fieldType("listOfIntArray"));
+    assertProtoConversionEquality(fieldType("listOfWildcardExtendsCharSequenceArray"));
+  }
+
+  private TypeMirror fieldType(String fieldName) {
+    return fieldsIn(
+            elements.getTypeElement(TypeMirrorConversionSubjects.class).getEnclosedElements())
+        .stream()
+        .filter(field -> field.getSimpleName().contentEquals(fieldName))
+        .findFirst()
+        .get()
+        .asType();
+  }
+
+  /**
+   * Converts {@link TypeMirror} to a {@link dagger.internal.codegen.serialization.TypeProto} and
+   * back to a {@link TypeMirror}. Asserts that the round-trip conversion is lossless.
+   */
+  private void assertProtoConversionEquality(TypeMirror typeMirror) {
+    TypeProto toProto = TypeProtoConverter.toProto(typeMirror);
+    TypeMirror fromProto = typeProtoConverter.fromProto(toProto);
+    assertWithMessage("expected: %s\nactual  : %s", typeMirror, fromProto)
+        .that(types.isSameType(typeMirror, fromProto))
+        .isTrue();
+  }
+}
diff --git a/test_defs.bzl b/test_defs.bzl
index f72927a0a..15ab299f3 100644
--- a/test_defs.bzl
+++ b/test_defs.bzl
@@ -22,6 +22,10 @@ BUILD_VARIANTS = {
         "-Adagger.fastInit=enabled",
         "-Adagger.experimentalAheadOfTimeSubcomponents=enabled",
     ],
+    "AheadOfTimeSubcomponents_ForceUseSerializedComponentImplementations": [
+        "-Adagger.experimentalAheadOfTimeSubcomponents=enabled",
+        "-Adagger.forceUseSerializedComponentImplementations=enabled",
+    ],
 }
 
 # TODO(ronshapiro): convert this to use bazel_common
