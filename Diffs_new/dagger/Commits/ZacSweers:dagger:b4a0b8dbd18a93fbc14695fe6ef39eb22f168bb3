diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 292378d4d..cb5f9d974 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -200,6 +200,7 @@ java_library(
     name = "internal_validation",
     srcs = [
         "BindingGraphValidationModule.java",
+        "MapMultibindingValidation.java",
         "MembersInjectionBindingValidation.java",
         "NonNullableRequestForNullableBindingValidation.java",
         "ProvisionDependencyOnProducerBindingValidation.java",
@@ -208,6 +209,7 @@ java_library(
     deps = CODEGEN_DEPS + [
         ":base",
         ":binding",
+        ":validation",
     ],
 )
 
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
index 58ef85858..23e0745c7 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -225,7 +225,7 @@ B setMethodBindingProperties(
         .dependencies(
             dependencyRequestFactory.forRequiredResolvedVariables(
                 method.getParameters(), methodType.getParameterTypes()))
-        .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(method)));
+        .wrappedMapKeyAnnotation(wrapOptionalInEquivalence(getMapKey(method)));
   }
 
   /**
@@ -425,7 +425,7 @@ private ContributionBinding buildDelegateBinding(
         .contributingModule(delegateDeclaration.contributingModule().get())
         .key(keyFactory.forDelegateBinding(delegateDeclaration, frameworkType))
         .dependencies(delegateDeclaration.delegateRequest())
-        .wrappedMapKey(delegateDeclaration.wrappedMapKey())
+        .wrappedMapKeyAnnotation(delegateDeclaration.wrappedMapKey())
         .kind(DELEGATE)
         .build();
   }
diff --git a/java/dagger/internal/codegen/BindingGraphValidationModule.java b/java/dagger/internal/codegen/BindingGraphValidationModule.java
index e42b77c18..8cc72275e 100644
--- a/java/dagger/internal/codegen/BindingGraphValidationModule.java
+++ b/java/dagger/internal/codegen/BindingGraphValidationModule.java
@@ -25,6 +25,11 @@
 @Module
 interface BindingGraphValidationModule {
 
+  @Binds
+  @IntoSet
+  @Validation
+  BindingGraphPlugin mapMultibinding(MapMultibindingValidation validation);
+
   @Binds
   @IntoSet
   @Validation
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index d960a196e..ada129508 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -22,7 +22,6 @@
 import static com.google.auto.common.MoreTypes.asTypeElements;
 import static com.google.auto.common.MoreTypes.isType;
 import static com.google.auto.common.MoreTypes.isTypeOf;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.BindingType.PROVISION;
@@ -30,8 +29,6 @@
 import static dagger.internal.codegen.ComponentRequirement.Kind.MODULE;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
-import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
@@ -43,8 +40,6 @@
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.abstractModuleHasInstanceBindingMethods;
-import static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;
-import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
 import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeMetadataMissingCanReleaseReferences;
 import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotAnnotatedWithMetadata;
 import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotInComponentHierarchy;
@@ -60,7 +55,6 @@
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static dagger.model.BindingKind.INJECTION;
-import static dagger.model.BindingKind.MULTIBOUND_MAP;
 import static java.util.function.Predicate.isEqual;
 import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.joining;
@@ -77,14 +71,12 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.ImmutableSortedMap;
 import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Multimap;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import dagger.BindsOptionalOf;
 import dagger.Component;
 import dagger.Lazy;
-import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
@@ -101,7 +93,6 @@
 import dagger.releasablereferences.ReleasableReferenceManager;
 import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.ArrayDeque;
-import java.util.Collection;
 import java.util.Deque;
 import java.util.Formatter;
 import java.util.LinkedHashMap;
@@ -636,9 +627,6 @@ protected void visitContributionBinding(
             }
           }
         }
-        if (binding.kind().equals(MULTIBOUND_MAP)) {
-          validateMapKeys(binding, owningComponent);
-        }
         super.visitContributionBinding(binding, owningComponent);
       }
 
@@ -694,47 +682,6 @@ protected void visitContributionBinding(
         return declarations.build();
       }
 
-      private void validateMapKeys(
-          ContributionBinding binding, ComponentDescriptor owningComponent) {
-        checkArgument(
-            binding.kind().equals(MULTIBOUND_MAP),
-            "binding must be a synthetic multibound map: %s",
-            binding);
-        ImmutableSet<ContributionBinding> multibindingContributions =
-            componentTreePath()
-                .graphForComponent(owningComponent)
-                .resolvedDependencies(binding)
-                .stream()
-                .map(ResolvedBindings::contributionBinding)
-                .collect(toImmutableSet());
-        validateMapKeySet(multibindingContributions);
-        validateMapKeyAnnotationTypes(multibindingContributions);
-      }
-
-      /**
-       * Reports errors if there is more than one map binding contribution with the same map key.
-       */
-      private void validateMapKeySet(Set<ContributionBinding> mapBindingContributions) {
-        for (Collection<ContributionBinding> mapBindingsForMapKey :
-            indexMapBindingsByMapKey(mapBindingContributions).asMap().values()) {
-          if (mapBindingsForMapKey.size() > 1) {
-            reportDuplicateMapKeys(mapBindingsForMapKey);
-          }
-        }
-      }
-
-      /**
-       * Reports errors if there is more than one {@link MapKey} annotation type within the map
-       * binding contributions' map keys.
-       */
-      private void validateMapKeyAnnotationTypes(Set<ContributionBinding> mapBindingContributions) {
-        ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
-            mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(mapBindingContributions);
-        if (mapBindingsByAnnotationType.keySet().size() > 1) {
-          reportInconsistentMapKeyAnnotations(mapBindingsByAnnotationType);
-        }
-      }
-
       /**
        * Descriptive portion of the error message for when the given request has no binding.
        * Currently, the only other portions of the message are the dependency path, line number and
@@ -911,34 +858,6 @@ private void reportMultipleContributionTypes() {
             componentTreePath().rootmostGraph(duplicateDeclarations.keySet()), builder.toString());
       }
 
-      private void reportDuplicateMapKeys(Collection<ContributionBinding> mapBindings) {
-        StringBuilder builder = new StringBuilder();
-        builder.append(duplicateMapKeysError(formatCurrentDependencyRequestKey()));
-        bindingDeclarationFormatter.formatIndentedList(
-            builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
-        reportErrorAtEntryPoint(owningGraph(mapBindings), builder.toString());
-      }
-
-      private void reportInconsistentMapKeyAnnotations(
-          Multimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
-              mapBindingsByAnnotationType) {
-        StringBuilder builder =
-            new StringBuilder(
-                inconsistentMapKeyAnnotationsError(formatCurrentDependencyRequestKey()));
-        for (Map.Entry<Equivalence.Wrapper<DeclaredType>, Collection<ContributionBinding>> entry :
-            mapBindingsByAnnotationType.asMap().entrySet()) {
-          DeclaredType annotationType = entry.getKey().get();
-          Collection<ContributionBinding> bindings = entry.getValue();
-
-          builder.append('\n').append(INDENT).append(annotationType).append(':');
-
-          bindingDeclarationFormatter.formatIndentedList(
-              builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
-        }
-        reportErrorAtEntryPoint(
-            owningGraph(mapBindingsByAnnotationType.values()), builder.toString());
-      }
-
       // TODO(cgruber): Provide a hint for the start and end of the cycle.
       private void reportDependencyCycle() {
         if (!providersBreakingCycle().isEmpty()) {
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index 1dae93bc5..9b7685103 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.CLASS_CONSTRUCTOR;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
@@ -26,14 +27,9 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Equivalence.Wrapper;
-import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Multimaps;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.CheckReturnValue;
-import dagger.MapKey;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
@@ -58,10 +54,21 @@
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
-  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
+  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKeyAnnotation();
 
-  final Optional<AnnotationMirror> mapKey() {
-    return unwrapOptionalEquivalence(wrappedMapKey());
+  final Optional<AnnotationMirror> mapKeyAnnotation() {
+    return unwrapOptionalEquivalence(wrappedMapKeyAnnotation());
+  }
+
+  /**
+   * If this is a map contribution, returns the key of its map entry.
+   *
+   * @throws IllegalStateException if {@link #mapKeyAnnotation()} returns an empty value.
+   */
+  final Object mapKey() {
+    checkState(mapKeyAnnotation().isPresent());
+    AnnotationMirror mapKeyAnnotation = mapKeyAnnotation().get();
+    return unwrapValue(mapKeyAnnotation).map(AnnotationValue::getValue).orElse(mapKeyAnnotation);
   }
 
   /**
@@ -173,34 +180,6 @@ static BindingKind bindingKindForMultibindingKey(Key key) {
     }
   }
 
-  /**
-   * Indexes map-multibindings by map key (the result of calling
-   * {@link AnnotationValue#getValue()} on a single member or the whole {@link AnnotationMirror}
-   * itself, depending on {@link MapKey#unwrapValue()}).
-   */
-  static ImmutableSetMultimap<Object, ContributionBinding> indexMapBindingsByMapKey(
-      Set<ContributionBinding> mapBindings) {
-    return ImmutableSetMultimap.copyOf(
-        Multimaps.index(
-            mapBindings,
-            mapBinding -> {
-              AnnotationMirror mapKey = mapBinding.mapKey().get();
-              return unwrapValue(mapKey).map(AnnotationValue::getValue).orElse(mapKey);
-            }));
-  }
-
-  /**
-   * Indexes map-multibindings by map key annotation type.
-   */
-  static ImmutableSetMultimap<Wrapper<DeclaredType>, ContributionBinding>
-      indexMapBindingsByAnnotationType(Set<ContributionBinding> mapBindings) {
-    return ImmutableSetMultimap.copyOf(
-        Multimaps.index(
-            mapBindings,
-            mapBinding ->
-                MoreTypes.equivalence().wrap(mapBinding.mapKey().get().getAnnotationType())));
-  }
-
   /**
    * Base builder for {@link com.google.auto.value.AutoValue @AutoValue} subclasses of {@link
    * ContributionBinding}.
@@ -225,7 +204,8 @@ B dependencies(DependencyRequest... dependencies) {
 
     abstract B nullableType(Optional<DeclaredType> nullableType);
 
-    abstract B wrappedMapKey(Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey);
+    abstract B wrappedMapKeyAnnotation(
+        Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKeyAnnotation);
 
     abstract B kind(BindingKind kind);
 
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 0176721bf..9d408488a 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -121,14 +121,6 @@
   static final String DUPLICATE_BINDINGS_FOR_KEY_FORMAT =
       "%s is bound multiple times:";
 
-  static String duplicateMapKeysError(String key) {
-    return "The same map key is bound more than once for " + key;
-  }
-
-  static String inconsistentMapKeyAnnotationsError(String key) {
-    return key + " uses more than one @MapKey annotation type";
-  }
-
   static final String COMPONENT_ANNOTATED_REUSABLE =
       "@Reusable cannot be applied to components or subcomponents.";
 
diff --git a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
index b8c255bcd..0a042332c 100644
--- a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
+++ b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
@@ -31,8 +31,8 @@
 import javax.lang.model.element.Element;
 
 /**
- * Generates a class that exposes a non-{@code public} {@link ContributionBinding#mapKey()} @MapKey}
- * annotation.
+ * Generates a class that exposes a non-{@code public} {@link
+ * ContributionBinding#mapKeyAnnotation()} @MapKey} annotation.
  */
 final class InaccessibleMapKeyProxyGenerator extends SourceFileGenerator<ContributionBinding> {
   private final DaggerTypes types;
diff --git a/java/dagger/internal/codegen/MapKeys.java b/java/dagger/internal/codegen/MapKeys.java
index d0a80e05c..59dea8660 100644
--- a/java/dagger/internal/codegen/MapKeys.java
+++ b/java/dagger/internal/codegen/MapKeys.java
@@ -137,16 +137,16 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
   }
 
   /**
-   * Returns a code block for {@code binding}'s {@link ContributionBinding#mapKey() map key}. If for
-   * whatever reason the map key is not accessible from within {@code requestingClass} (i.e. it has
-   * a package-private {@code enum} from a different package), this will return an invocation of a
-   * proxy-method giving it access.
+   * Returns a code block for {@code binding}'s {@link ContributionBinding#mapKeyAnnotation() map
+   * key}. If for whatever reason the map key is not accessible from within {@code requestingClass}
+   * (i.e. it has a package-private {@code enum} from a different package), this will return an
+   * invocation of a proxy-method giving it access.
    *
    * @throws IllegalStateException if {@code binding} is not a {@link dagger.multibindings.IntoMap
    *     map} contribution.
    */
   static CodeBlock getMapKeyExpression(ContributionBinding binding, ClassName requestingClass) {
-    AnnotationMirror mapKeyAnnotation = binding.mapKey().get();
+    AnnotationMirror mapKeyAnnotation = binding.mapKeyAnnotation().get();
     return MapKeyAccessibility.isMapKeyAccessibleFrom(
             mapKeyAnnotation, requestingClass.packageName())
         ? directMapKeyExpression(mapKeyAnnotation)
@@ -193,7 +193,7 @@ static ClassName mapKeyProxyClassName(ContributionBinding binding) {
    */
   static Optional<MethodSpec> mapKeyFactoryMethod(ContributionBinding binding, Types types) {
     return binding
-        .mapKey()
+        .mapKeyAnnotation()
         .filter(mapKey -> !isMapKeyPubliclyAccessible(mapKey))
         .map(
             mapKey ->
diff --git a/java/dagger/internal/codegen/MapMultibindingValidation.java b/java/dagger/internal/codegen/MapMultibindingValidation.java
new file mode 100644
index 000000000..ff0df9f04
--- /dev/null
+++ b/java/dagger/internal/codegen/MapMultibindingValidation.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
+import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.model.BindingKind.MULTIBOUND_MAP;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Equivalence;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Multimaps;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.Key;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.lang.model.type.DeclaredType;
+
+/**
+ * Reports an error for any map binding with either more than one contribution with the same map key
+ * or contributions with inconsistent map key annotation types.
+ */
+final class MapMultibindingValidation implements BindingGraphPlugin {
+
+  private final BindingDeclarationFormatter bindingDeclarationFormatter;
+
+  @Inject
+  MapMultibindingValidation(BindingDeclarationFormatter bindingDeclarationFormatter) {
+    this.bindingDeclarationFormatter = bindingDeclarationFormatter;
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/MapKeys";
+  }
+
+  @Override
+  public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    for (BindingNode node : bindingGraph.bindingNodes()) {
+      if (node.binding().kind().equals(MULTIBOUND_MAP)) {
+        ImmutableSet<ContributionBinding> contributions =
+            mapBindingContributions(node, bindingGraph);
+        checkForDuplicateMapKeys(node, contributions, diagnosticReporter);
+        checkForInconsistentMapKeyAnnotationTypes(node, contributions, diagnosticReporter);
+      }
+    }
+  }
+
+  private ImmutableSet<ContributionBinding> mapBindingContributions(
+      BindingNode bindingNode, BindingGraph bindingGraph) {
+    checkArgument(bindingNode.binding().kind().equals(MULTIBOUND_MAP));
+    return bindingGraph
+        .successors(bindingNode)
+        .stream()
+        .flatMap(instancesOf(BindingNode.class))
+        .map(node -> (ContributionBinding) node.binding())
+        .collect(toImmutableSet());
+  }
+
+  private void checkForDuplicateMapKeys(
+      BindingNode multiboundMapBindingNode,
+      ImmutableSet<ContributionBinding> contributions,
+      DiagnosticReporter diagnosticReporter) {
+    ImmutableSetMultimap<Object, ContributionBinding> contributionsByMapKey =
+        ImmutableSetMultimap.copyOf(Multimaps.index(contributions, ContributionBinding::mapKey));
+
+    for (Set<ContributionBinding> contributionsForOneMapKey :
+        Multimaps.asMap(contributionsByMapKey).values()) {
+      if (contributionsForOneMapKey.size() > 1) {
+        diagnosticReporter.reportBinding(
+            ERROR,
+            multiboundMapBindingNode,
+            duplicateMapKeyErrorMessage(
+                contributionsForOneMapKey, multiboundMapBindingNode.binding().key()));
+      }
+    }
+  }
+
+  private void checkForInconsistentMapKeyAnnotationTypes(
+      BindingNode multiboundMapBindingNode,
+      ImmutableSet<ContributionBinding> contributions,
+      DiagnosticReporter diagnosticReporter) {
+    ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+        contributionsByMapKeyAnnotationType = indexByMapKeyAnnotationType(contributions);
+
+    if (contributionsByMapKeyAnnotationType.keySet().size() > 1) {
+      diagnosticReporter.reportBinding(
+          ERROR,
+          multiboundMapBindingNode,
+          inconsistentMapKeyAnnotationTypesErrorMessage(
+              contributionsByMapKeyAnnotationType, multiboundMapBindingNode.binding().key()));
+    }
+  }
+
+  private static ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+      indexByMapKeyAnnotationType(ImmutableSet<ContributionBinding> contributions) {
+    return ImmutableSetMultimap.copyOf(
+        Multimaps.index(
+            contributions,
+            mapBinding ->
+                MoreTypes.equivalence()
+                    .wrap(mapBinding.mapKeyAnnotation().get().getAnnotationType())));
+  }
+
+  private String inconsistentMapKeyAnnotationTypesErrorMessage(
+      ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+          contributionsByMapKeyAnnotationType,
+      Key mapBindingKey) {
+    StringBuilder message =
+        new StringBuilder(mapBindingKey.toString())
+            .append(" uses more than one @MapKey annotation type");
+    Multimaps.asMap(contributionsByMapKeyAnnotationType)
+        .forEach(
+            (annotationType, contributions) -> {
+              message.append('\n').append(INDENT).append(annotationType.get()).append(':');
+              bindingDeclarationFormatter.formatIndentedList(
+                  message, contributions, 2, DUPLICATE_SIZE_LIMIT);
+            });
+    return message.toString();
+  }
+
+  private String duplicateMapKeyErrorMessage(
+      Set<ContributionBinding> contributionsForOneMapKey, Key mapBindingKey) {
+    StringBuilder message =
+        new StringBuilder("The same map key is bound more than once for ").append(mapBindingKey);
+    bindingDeclarationFormatter.formatIndentedList(
+        message, contributionsForOneMapKey, 1, DUPLICATE_SIZE_LIMIT);
+    return message.toString();
+  }
+}
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index 01da55889..93f1df27c 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -1532,21 +1532,32 @@ public void bindsMissingRightHandSide() {
             "  Map<Long, BoundTwice> longMap();",
             "}");
 
-    assertThat(duplicates, component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("test.Duplicates.BoundTwice is bound multiple times:")
-            .in(component).onLine(10)
-        .and().withErrorContaining("test.Duplicates.DuplicatesModule.bindWithUnresolvedKey")
-            .in(component).onLine(10)
-        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
-            .in(component).onLine(11)
-        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
-            .in(component).onLine(12)
-        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
-            .in(component).onLine(13)
-        .and().withErrorContaining("same map key is bound more than once")
-            .in(component).onLine(14);
+    Compilation compilation = daggerCompiler().compile(duplicates, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.Duplicates.BoundTwice is bound multiple times:")
+        .inFile(component)
+        .onLineContaining("boundTwice();");
+    assertThat(compilation)
+        .hadErrorContaining("test.Duplicates.DuplicatesModule.bindWithUnresolvedKey")
+        .inFile(component)
+        .onLineContaining("boundTwice();");
+    assertThat(compilation)
+        .hadErrorContaining("test.Duplicates.NotBound cannot be provided")
+        .inFile(component)
+        .onLineContaining("object();");
+    assertThat(compilation)
+        .hadErrorContaining("test.Duplicates.NotBound cannot be provided")
+        .inFile(component)
+        .onLineContaining("set();");
+    assertThat(compilation)
+        .hadErrorContaining("test.Duplicates.NotBound cannot be provided")
+        .inFile(component)
+        .onLineContaining("intMap();");
+    assertThat(compilation)
+        .hadErrorContaining("test.Duplicates.NotBound cannot be provided")
+        .inFile(component)
+        .onLineContaining("longMap();");
   }
 
   @Test public void resolvedParametersInDependencyTrace() {
