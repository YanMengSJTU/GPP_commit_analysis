diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 80a2bd6bd..e266539e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -72,8 +72,7 @@
 import static dagger.internal.codegen.TypeNames.UNSUPPORTED_OPERATION_EXCEPTION;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.Util.requiresAPassedInstance;
+import static dagger.internal.codegen.Util.*;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -120,20 +119,10 @@
 import dagger.releasablereferences.ForReleasableReferences;
 import dagger.releasablereferences.ReleasableReferenceManager;
 import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.util.Arrays;
-import java.util.EnumSet;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
+
+import java.util.*;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
+import javax.lang.model.element.*;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
@@ -164,6 +153,7 @@
   private final RequestFulfillmentRegistry requestFulfillmentRegistry;
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   protected Optional<ClassName> builderName = Optional.absent();
+  private Map<Key, String> delegateFieldNames = new HashMap<>();
   private final OptionalFactories optionalFactories;
   private boolean done;
 
@@ -301,7 +291,6 @@ private void setInitializationState(BindingKey bindingKey, InitializationState s
   protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
     return referenceReleasingProviderManagerFields.get(scope).getExpressionFor(name);
   }
-
   /**
    * Constructs a {@link TypeSpec.Builder} that models the {@link BindingGraph} for this component.
    * This is only intended to be called once (and will throw on successive invocations). If the
@@ -596,7 +585,6 @@ private void addFrameworkFields() {
 
   private void addField(ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
-
     // If the binding can be satisfied with a static method call without dependencies or state,
     // no field is necessary.
     Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
@@ -636,9 +624,28 @@ private FieldSpec addFrameworkField(
     if (useRawType) {
       contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
     }
-
     FieldSpec field = contributionField.build();
     component.addField(field);
+   // try {
+      //ContributionBinding binding = resolvedBindings.contributionBinding();
+      createDelegateFieldAndMethod(name, component, resolvedBindings, delegateFieldNames);
+      /*if (supportsTestDelegate(binding)) {
+        final String delegateFieldName = contributionBindingField.name() + "Delegate";
+        final ClassName delegateType = getDelegateTypeName(resolvedBindings.binding().key());
+        final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
+        delegateFieldNames.put(resolvedBindings.key(), delegateFieldName);
+        final FieldSpec fieldSpec = builder.build();
+        component.addField(fieldSpec);
+        final String methodName = "with" + delegateType.simpleName().toString();
+        component.addMethod(MethodSpec.methodBuilder(methodName)
+                              .addModifiers(Modifier.PUBLIC)
+                              .returns(name)
+                              .addParameter(delegateType, "delegate")
+                              .addStatement("this.$N = delegate", fieldSpec)
+                              .addStatement("return this")
+                              .build());
+      }*/
+    //}catch(Exception e) {}
     return field;
   }
 
@@ -784,12 +791,11 @@ private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
 
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
-    for (ComponentMethodDescriptor componentMethod :
-        graph.componentDescriptor().componentMethods()) {
+    final ImmutableSet<ComponentMethodDescriptor> componentMethodDescriptors = graph.componentDescriptor().componentMethods();
+    for (ComponentMethodDescriptor componentMethod : componentMethodDescriptors) {
       if (componentMethod.dependencyRequest().isPresent()) {
         DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
-        ExecutableElement methodElement =
-            MoreElements.asExecutable(componentMethod.methodElement());
+        ExecutableElement methodElement = MoreElements.asExecutable(componentMethod.methodElement());
         ExecutableType requestType =
             MoreTypes.asExecutable(
                 types.asMemberOf(
@@ -818,7 +824,20 @@ private void implementInterfaceMethods() {
               }
               // fall through
             default:
+              CodeBlock.Builder builder = CodeBlock.builder();
+              final boolean supportsTestDelegate = !componentMethod.methodElement().getReturnType().toString().equals(void.class.getName());
+              if (supportsTestDelegate) {
+                final ClassName delegateTypeName = Util.getDelegateTypeName(interfaceRequest.key());
+                final String fieldName = Util.getDelegateFieldName(interfaceRequest.key());
+                builder.beginControlFlow("if ($S != null)", fieldName)
+                        .add("return $S.get($L)", fieldName, codeBlock)
+                        .nextControlFlow("else");
+              }
               interfaceMethod.addStatement("return $L", codeBlock);
+              if (supportsTestDelegate) {
+                builder.endControlFlow();
+              }
+
               break;
           }
           component.addMethod(interfaceMethod.build());
@@ -1003,15 +1022,13 @@ private CodeBlock initializeDeferredDependencies(Binding binding) {
   private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {
     ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
 
-    for (BindingKey dependencyKey :
-        FluentIterable.from(binding.dependencies())
+    final ImmutableSet<BindingKey> bindingKeys = FluentIterable.from(binding.dependencies())
             .transform(DependencyRequest::bindingKey)
-            .toSet()) {
-      if (!getMemberSelect(dependencyKey).staticMember()
-          && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
-        initializations.add(
-            CodeBlock.of(
-                "this.$L = new $T();", getMemberSelectExpression(dependencyKey), DELEGATE_FACTORY));
+            .toSet();
+    for (BindingKey dependencyKey : bindingKeys) {
+      if (!getMemberSelect(dependencyKey).staticMember() && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
+        final CodeBlock codeBlock = CodeBlock.of("this.$L = new $T();", getMemberSelectExpression(dependencyKey), DELEGATE_FACTORY);
+        initializations.add(codeBlock);
         setInitializationState(dependencyKey, DELEGATED);
       }
     }
@@ -1073,6 +1090,7 @@ private CodeBlock delegateFactoryVariableExpression(BindingKey key) {
 
   private CodeBlock initializeFactoryForContributionBinding(ContributionBinding binding) {
     TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
+    final String delegateFieldName = delegateFieldNames.get(binding.key());
     switch (binding.bindingKind()) {
       case COMPONENT:
         return CodeBlock.of(
@@ -1097,14 +1115,12 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           // We can easily include the raw type (no generics) + annotation type (no values),
           // using .class & String.format -- but that wouldn't be the whole story.
           // What should we do?
-          CodeBlock getMethodBody =
-              binding.nullableType().isPresent()
-                      || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
-                  ? CodeBlock.of("return $L;", callFactoryMethod)
-                  : CodeBlock.of("return $T.checkNotNull($L, $S);",
-                      Preconditions.class,
-                      callFactoryMethod,
-                      CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+          CodeBlock.Builder getMethodBodyBuilder = CodeBlock.builder();
+          /*getMethodBodyBuilder.beginControlFlow("if (" + delegateFieldName + " != null)");
+          getMethodBodyBuilder.add(CodeBlock.of("return " + delegateFieldName + ".get();"));
+          getMethodBodyBuilder.nextControlFlow("else");*/
+          getMethodBodyBuilder.add(getCodeBlock(binding, callFactoryMethod));
+          //getMethodBodyBuilder.endControlFlow();
           return CodeBlock.of(
               Joiner.on('\n')
                   .join(
@@ -1120,7 +1136,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               /* 4 */ nullableAnnotation(binding.nullableType()),
               /* 5 */ TypeName.get(dependencyType.asType()),
               /* 6 */ dependencyVariable,
-              /* 7 */ getMethodBody);
+              /* 7 */ getMethodBodyBuilder.build());
         }
 
       case SUBCOMPONENT_BUILDER:
@@ -1145,12 +1161,16 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
       case PROVISION:
         {
           List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
+              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 2);
           if (binding.requiresModuleInstance()) {
             arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
           }
           arguments.addAll(getDependencyArguments(binding));
 
+          if (supportsTestDelegate(binding)) {
+            arguments.add(0, CodeBlock.of(delegateFieldName));
+          }
+
           CodeBlock factoryCreate =
               CodeBlock.of(
                   "$T.create($L)",
@@ -1223,6 +1243,16 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
     }
   }
 
+  private CodeBlock getCodeBlock(ContributionBinding binding, CodeBlock callFactoryMethod) {
+    return binding.nullableType().isPresent()
+            || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
+        ? CodeBlock.of("return $L;", callFactoryMethod)
+        : CodeBlock.of("return $T.checkNotNull($L, $S);",
+            Preconditions.class,
+            callFactoryMethod,
+            CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+  }
+
   private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
     return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
   }
@@ -1253,10 +1283,11 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
       case NO_OP:
         return CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS);
       case INJECT_MEMBERS:
+        final ImmutableList<CodeBlock> arguments = getDependencyArguments(binding);
         return CodeBlock.of(
             "$T.create($L)",
             membersInjectorNameForType(binding.membersInjectedType()),
-            makeParametersCodeBlock(getDependencyArguments(binding)));
+            makeParametersCodeBlock(arguments));
       default:
         throw new AssertionError();
     }
@@ -1504,7 +1535,7 @@ private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBindi
     }
   }
 
-  private static String simpleVariableName(TypeElement typeElement) {
+  public static String simpleVariableName(Element typeElement) {
     return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index b9b646315..e922610c3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -39,11 +39,11 @@
   private final CompilerOptions compilerOptions;
 
   ComponentGenerator(
-      Filer filer,
-      Elements elements,
-      Types types,
-      Key.Factory keyFactory,
-      CompilerOptions compilerOptions) {
+          Filer filer,
+          Elements elements,
+          Types types,
+          Key.Factory keyFactory,
+          CompilerOptions compilerOptions) {
     super(filer, elements);
     this.types = types;
     this.elements = elements;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 80648b717..e62ac994e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -23,12 +23,16 @@
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
 import com.google.googlejavaformat.java.filer.FormattingFiler;
+import dagger.Injector;
+
+import java.util.Arrays;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -46,6 +50,8 @@
   private InjectBindingRegistry injectBindingRegistry;
   private FactoryGenerator factoryGenerator;
   private MembersInjectorGenerator membersInjectorGenerator;
+  private StubGenerator stubGenerator;
+  private MultipleSourceFileGenerator<ProvisionBinding> multipleGenerator;
 
   @Override
   public SourceVersion getSupportedSourceVersion() {
@@ -106,8 +112,11 @@ public SourceVersion getSupportedSourceVersion() {
             methodSignatureFormatter,
             multibindingsMethodValidator);
 
+    this.stubGenerator =
+            new StubGenerator(filer, elements, types);
     this.factoryGenerator =
         new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);
+    this.multipleGenerator = new MultipleSourceFileGenerator<>(filer, elements, Arrays.asList(this.stubGenerator, this.factoryGenerator));
     this.membersInjectorGenerator =
         new MembersInjectorGenerator(filer, elements, injectValidatorWhenGeneratingCode);
     ComponentGenerator componentGenerator =
@@ -205,7 +214,7 @@ public SourceVersion getSupportedSourceVersion() {
             messager,
             moduleValidator,
             provisionBindingFactory,
-            factoryGenerator,
+            this.multipleGenerator,
             providesMethodValidator,
             bindsMethodValidator,
             multibindsMethodValidator,
@@ -225,7 +234,7 @@ public SourceVersion getSupportedSourceVersion() {
             messager,
             moduleValidator,
             provisionBindingFactory,
-            factoryGenerator,
+            this.multipleGenerator,
             providesMethodValidator,
             productionBindingFactory,
             producerFactoryGenerator,
@@ -243,7 +252,14 @@ public SourceVersion getSupportedSourceVersion() {
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
-            componentGenerator));
+            componentGenerator),
+         new InjectorProcessingStep(
+                 messager,
+                 new InjectorGenerator(filer, elements),
+                 ComponentDescriptor.Kind.COMPONENT,
+                 bindingGraphFactory,
+                 componentDescriptorFactory)
+    );
   }
 
   @Override
@@ -251,7 +267,7 @@ protected void postRound(RoundEnvironment roundEnv) {
     if (!roundEnv.processingOver()) {
       try {
         injectBindingRegistry.generateSourcesForRequiredBindings(
-            factoryGenerator, membersInjectorGenerator);
+            multipleGenerator, membersInjectorGenerator);
       } catch (SourceFileGenerationException e) {
         e.printMessageTo(processingEnv.getMessager());
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index bb90d0a46..06720d3bb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -48,12 +48,12 @@
 final class ComponentWriter extends AbstractComponentWriter {
 
   ComponentWriter(
-      Types types,
-      Elements elements,
-      Key.Factory keyFactory,
-      CompilerOptions compilerOptions,
-      ClassName name,
-      BindingGraph graph) {
+          Types types,
+          Elements elements,
+          Key.Factory keyFactory,
+          CompilerOptions compilerOptions,
+          ClassName name,
+          BindingGraph graph) {
     super(
         types,
         elements,
diff --git a/compiler/src/main/java/dagger/internal/codegen/DI.java b/compiler/src/main/java/dagger/internal/codegen/DI.java
new file mode 100644
index 000000000..3e3c04816
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DI.java
@@ -0,0 +1,34 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ClassName;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import java.util.List;
+
+/**
+ * Created by Andy on 05.05.2017.
+ */
+public class DI {
+    private final TypeElement injector;
+    private final List<InjectorType> injectors;
+
+    public DI(TypeElement injector, List<InjectorType> injectors) {
+        this.injector = injector;
+        this.injectors = injectors;
+    }
+
+    public TypeElement getInjector() {
+        return injector;
+    }
+
+    public List<InjectorType> getInjectors() {
+        return ImmutableList.copyOf(injectors);
+    }
+
+    public ClassName getClassName() {
+        final ClassName className = ClassName.bestGuess(injector.asType().toString());
+        return ClassName.bestGuess(className.packageName() + "." + "Test" + className.simpleName());
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 5513ae77b..1f79703a1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -35,6 +35,9 @@
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
 import static dagger.internal.codegen.TypeNames.factoryOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static dagger.internal.codegen.Util.getDelegateFieldName;
+import static dagger.internal.codegen.Util.getDelegateTypeName;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -62,8 +65,10 @@
 import java.util.Map;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
+import javax.inject.Named;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
 
@@ -80,10 +85,10 @@
   private final InjectValidator injectValidator;
 
   FactoryGenerator(
-      Filer filer,
-      Elements elements,
-      CompilerOptions compilerOptions,
-      InjectValidator injectValidator) {
+          Filer filer,
+          Elements elements,
+          CompilerOptions compilerOptions,
+          InjectValidator injectValidator) {
     super(filer, elements);
     this.compilerOptions = compilerOptions;
     this.injectValidator = injectValidator;
@@ -140,7 +145,14 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         break;
       case CLASS_CONSTRUCTOR:
         constructorBuilder = Optional.of(constructorBuilder().addModifiers(PUBLIC));
+        addConstructorParameterAndTypeField(
+                getDelegateTypeName(binding.key()),
+                getDelegateFieldName(binding.key()),
+                factoryBuilder,
+                constructorBuilder.get()
+        );
         if (binding.requiresModuleInstance()) {
+
           addConstructorParameterAndTypeField(
               TypeName.get(binding.bindingTypeElement().get().asType()),
               "module",
@@ -235,18 +247,25 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             .addModifiers(PUBLIC);
 
     if (binding.bindingKind().equals(PROVISION)) {
+      final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+      getMethodBuilder.beginControlFlow("if ($S != null)", delegateFieldName);
+      getMethodBuilder.addStatement("return $S.get($L)", delegateFieldName, parametersCodeBlock);
+      getMethodBuilder.nextControlFlow("else");
       CodeBlock.Builder providesMethodInvocationBuilder = CodeBlock.builder();
       if (binding.requiresModuleInstance()) {
         providesMethodInvocationBuilder.add("module");
       } else {
         providesMethodInvocationBuilder.add(
-            "$T", ClassName.get(binding.bindingTypeElement().get()));
+                "$T", ClassName.get(binding.bindingTypeElement().get()));
       }
       providesMethodInvocationBuilder.add(
-          ".$L($L)", binding.bindingElement().get().getSimpleName(), parametersCodeBlock);
+              ".$L($L)", binding.bindingElement().get().getSimpleName(), parametersCodeBlock);
+
       CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
+      getMethodBuilder.addStatement("return $L", providesMethodInvocation);
+      getMethodBuilder.endControlFlow();
 
-      if (binding.nullableType().isPresent()
+      /*if (binding.nullableType().isPresent()
           || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)) {
         if (binding.nullableType().isPresent()) {
           getMethodBuilder.addAnnotation((ClassName) TypeName.get(binding.nullableType().get()));
@@ -257,16 +276,29 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             Preconditions.class,
             providesMethodInvocation,
             CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-      }
+      }*/
     } else if (binding.membersInjectionRequest().isPresent()) {
+
+      getMethodBuilder.beginControlFlow("if (delegate != null)");
+      getMethodBuilder.addStatement(
+              "return $T.injectMembers($N, delegate.get($L))",
+              MembersInjectors.class,
+              fields.get(binding.membersInjectionRequest().get().bindingKey()),
+              parametersCodeBlock);
+      getMethodBuilder.nextControlFlow("else");
       getMethodBuilder.addStatement(
           "return $T.injectMembers($N, new $T($L))",
           MembersInjectors.class,
           fields.get(binding.membersInjectionRequest().get().bindingKey()),
           providedTypeName,
           parametersCodeBlock);
+      getMethodBuilder.endControlFlow();
     } else {
+      getMethodBuilder.beginControlFlow("if (delegate != null)");
+      getMethodBuilder.addStatement("return delegate.get($L)", parametersCodeBlock);
+      getMethodBuilder.nextControlFlow("else");
       getMethodBuilder.addStatement("return new $T($L)", providedTypeName, parametersCodeBlock);
+      getMethodBuilder.endControlFlow();
     }
 
     factoryBuilder.addMethod(getMethodBuilder.build());
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 3eff8ec54..80c36d3a2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -125,4 +125,5 @@ public String visitType(TypeElement e, Binding p) {
 
   abstract ParameterizedTypeName type();
   abstract String name();
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index be4bcf922..e4b287bbc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -168,10 +168,10 @@ private void tryToCacheBinding(B binding) {
    * {@linkplain #registerBinding explicitly} or implicitly via
    * {@link #getOrFindMembersInjectionBinding} or {@link #getOrFindProvisionBinding}) are generated.
    */
-  void generateSourcesForRequiredBindings(FactoryGenerator factoryGenerator,
-      MembersInjectorGenerator membersInjectorGenerator) throws SourceFileGenerationException {
-    provisionBindings.generateBindings(factoryGenerator);
+  void generateSourcesForRequiredBindings(SourceFileGenerator<ProvisionBinding> factoryGenerator,
+                                          MembersInjectorGenerator membersInjectorGenerator) throws SourceFileGenerationException {
     membersInjectionBindings.generateBindings(membersInjectorGenerator);
+    provisionBindings.generateBindings(factoryGenerator);
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 818e5f510..f7a0d9aca 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -51,7 +51,7 @@ static ModuleProcessingStep moduleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
       final ProvisionBinding.Factory provisionBindingFactory,
-      FactoryGenerator factoryGenerator,
+      MultipleSourceFileGenerator<ProvisionBinding> multipleSourceFileGenerator,
       ProvidesMethodValidator providesMethodValidator,
       BindsMethodValidator bindsMethodValidator,
       MultibindsMethodValidator multibindsMethodValidator,
@@ -61,7 +61,7 @@ static ModuleProcessingStep moduleProcessingStep(
         Module.class,
         moduleValidator,
         ImmutableSet.<ModuleMethodFactoryGenerator>of(
-            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator)),
+            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, multipleSourceFileGenerator)),
         ImmutableSet.of(
             providesMethodValidator,
             bindsMethodValidator,
@@ -77,7 +77,7 @@ static ModuleProcessingStep producerModuleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
       ProvisionBinding.Factory provisionBindingFactory,
-      FactoryGenerator factoryGenerator,
+      MultipleSourceFileGenerator<ProvisionBinding> multipleSourceFileGenerator,
       ProvidesMethodValidator providesMethodValidator,
       ProductionBinding.Factory productionBindingFactory,
       ProducerFactoryGenerator producerFactoryGenerator,
@@ -90,7 +90,7 @@ static ModuleProcessingStep producerModuleProcessingStep(
         ProducerModule.class,
         moduleValidator,
         ImmutableSet.of(
-            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator),
+            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, multipleSourceFileGenerator),
             new ProductionModuleMethodFactoryGenerator(
                 productionBindingFactory, producerFactoryGenerator)),
         ImmutableSet.of(
@@ -207,10 +207,10 @@ private boolean moduleMethodsAreValid(
       implements ModuleMethodFactoryGenerator {
 
     private final ProvisionBinding.Factory provisionBindingFactory;
-    private final FactoryGenerator factoryGenerator;
+    private final MultipleSourceFileGenerator<ProvisionBinding> factoryGenerator;
 
     ProvisionModuleMethodFactoryGenerator(
-        ProvisionBinding.Factory provisionBindingFactory, FactoryGenerator factoryGenerator) {
+        ProvisionBinding.Factory provisionBindingFactory, MultipleSourceFileGenerator<ProvisionBinding> factoryGenerator) {
       this.provisionBindingFactory = provisionBindingFactory;
       this.factoryGenerator = factoryGenerator;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
index add65fd31..8ce126fb2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
@@ -105,7 +105,7 @@ private CodeBlock invokeMethod(ClassName requestingClass) {
     ExecutableElement method = asExecutable(provisionBinding.bindingElement().get());
     switch (method.getKind()) {
       case CONSTRUCTOR:
-        return CodeBlock.of("new $T($L)", provisionBinding.key().type(), parametersCodeBlock);
+          return CodeBlock.of("new $T($L)", provisionBinding.key().type(), parametersCodeBlock);
       case METHOD:
         checkState(method.getModifiers().contains(STATIC));
         return CodeBlock.of(
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 36a13b28a..309f4c319 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -34,17 +34,19 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
 import dagger.Binds;
 import dagger.Provides;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
 import java.util.Comparator;
+import java.util.Map;
 import java.util.stream.Collector;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementVisitor;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
+import javax.inject.Named;
+import javax.lang.model.element.*;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
@@ -238,5 +240,128 @@ static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
     return collectingAndThen(toList(), ImmutableSet::copyOf);
   }
 
+  static ClassName getDelegateTypeName(Key key) {
+    final ClassName topLevelClassName = getTopLevelClassName(key.type());
+    if (key.qualifier().isPresent()) {
+      final AnnotationMirror annotationMirror = key.qualifier().get();
+      String value = "";
+      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationMirror.getElementValues().entrySet()) {
+        if (entry.getKey().getSimpleName().toString().equals("value")) {
+          value = entry.getValue().getValue().toString();
+          break;
+        }
+      }
+      return ClassName.bestGuess(topLevelClassName.packageName() + "." + capitalizeFirstLetter(value) + "Delegate");
+    }else {
+      return ClassName.bestGuess(getBaseDelegateClassName(key.type()) + "Delegate");
+    }
+  }
+
+  static String getDelegateFieldName(Key key) {
+
+    if (key.qualifier().isPresent()) {
+      final AnnotationMirror annotationMirror = key.qualifier().get();
+      String value = "";
+      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationMirror.getElementValues().entrySet()) {
+        if (entry.getKey().getSimpleName().toString().equals("value")) {
+          value = entry.getValue().getValue().toString();
+          break;
+        }
+      }
+      return lowerCaseFirstLetter(value) + "Delegate";
+    }else {
+      return lowerCaseFirstLetter(ClassName.bestGuess(key.type().toString()).simpleName()) + "Delegate";
+    }
+  }
+
+  static ClassName getDelegateTypeName(ProvisionBinding binding) {
+    String baseClassName;
+    if (binding.requiresModuleInstance()) {
+      ExecutableElement element = (ExecutableElement) binding.bindingElement().get();
+      baseClassName = getBaseDelegateClassName(binding.contributedType(), element);
+      return ClassName.bestGuess(baseClassName + "Delegate");
+    }else {
+      baseClassName = getBaseDelegateClassName(binding.key().type());
+      return ClassName.bestGuess(baseClassName + "Delegate");
+    }
+  }
+
+  private static String getBaseDelegateClassName(TypeMirror typeMirror, Element element) {
+    String baseClassName;
+    ClassName bestGuess = getTopLevelClassName(typeMirror);
+    if (element.getAnnotation(Named.class) != null) {
+      baseClassName = bestGuess.packageName() + "." + getCapitalizedAnnotationValue(element);
+    }else if (typeMirror.getAnnotation(Named.class) != null) {
+      baseClassName = bestGuess.packageName() + "." + getCapitalizedAnnotationValue(typeMirror);
+    }else {
+      baseClassName = typeMirror.toString();
+    }
+    return baseClassName;
+  }
+
+  private static String getCapitalizedAnnotationValue(Element element) {
+    return capitalizeFirstLetter(element.getAnnotation(Named.class).value());
+  }
+
+  private static ClassName getTopLevelClassName(TypeMirror typeMirror) {
+    return ClassName.bestGuess(typeMirror.toString()).topLevelClassName();
+  }
+
+  private static String getBaseDelegateClassName(TypeMirror typeMirror) {
+    String baseClassName;
+    ClassName bestGuess = getTopLevelClassName(typeMirror);
+    if (typeMirror.getAnnotation(Named.class) != null) {
+      baseClassName = bestGuess.packageName() + "." + getCapitalizedAnnotationValue(typeMirror);
+    }else {
+      baseClassName = typeMirror.toString();
+    }
+    return baseClassName;
+  }
+
+  private static String getCapitalizedAnnotationValue(TypeMirror typeMirror) {
+    return capitalizeFirstLetter(typeMirror.getAnnotation(Named.class).value());
+  }
+
+  private static String capitalizeFirstLetter(String original) {
+    if (original == null || original.length() == 0) {
+      return original;
+    }
+    return original.substring(0, 1).toUpperCase() + original.substring(1);
+  }
+
+  private static String lowerCaseFirstLetter(String original) {
+    if (original == null || original.length() == 0) {
+      return original;
+    }
+    return original.substring(0, 1).toLowerCase() + original.substring(1);
+  }
+
+  public static boolean supportsTestDelegate(ContributionBinding binding) {
+    return binding.factoryCreationStrategy() != ContributionBinding.FactoryCreationStrategy.DELEGATE;
+  }
+
   private Util() {}
+
+  public static void createDelegateFieldAndMethod(ClassName generatedTypeName, TypeSpec.Builder classBuilder, ResolvedBindings resolvedBindings, Map<Key, String> delegateFieldNames) {
+      try {
+          final FrameworkField contributionBindingField = FrameworkField.forResolvedBindings(resolvedBindings, Optional.absent());
+          ContributionBinding binding = resolvedBindings.contributionBinding();
+          if (supportsTestDelegate(binding)) {
+              final String delegateFieldName = contributionBindingField.name() + "Delegate";
+              final ClassName delegateType = getDelegateTypeName(resolvedBindings.binding().key());
+              final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
+              delegateFieldNames.put(resolvedBindings.key(), delegateFieldName);
+              final FieldSpec fieldSpec = builder.build();
+              classBuilder.addField(fieldSpec);
+              final String methodName = "with" + delegateType.simpleName().toString();
+              classBuilder.addMethod(MethodSpec.methodBuilder(methodName)
+                      .addModifiers(Modifier.PUBLIC)
+                      .returns(generatedTypeName)
+                      .addParameter(delegateType, "delegate")
+                      .addStatement("this.$N = delegate", fieldSpec)
+                      .addStatement("return this")
+                      .build());
+          }
+      }catch(Exception e) {}
+  }
 }
diff --git a/core/src/main/java/dagger/Injector.java b/core/src/main/java/dagger/Injector.java
new file mode 100644
index 000000000..5f5eb6a92
--- /dev/null
+++ b/core/src/main/java/dagger/Injector.java
@@ -0,0 +1,13 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target(TYPE)
+@Documented
+public @interface Injector {}
diff --git a/core/src/main/java/dagger/ProvidesComponent.java b/core/src/main/java/dagger/ProvidesComponent.java
new file mode 100644
index 000000000..52aa468f8
--- /dev/null
+++ b/core/src/main/java/dagger/ProvidesComponent.java
@@ -0,0 +1,14 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target(METHOD)
+@Documented
+public @interface ProvidesComponent {}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
index 1174a62bf..b18f7d1dc 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
@@ -18,8 +18,12 @@
 
 import android.app.Application;
 import android.location.LocationManager;
+import dagger.Injector;
+import dagger.ProvidesComponent;
+
 import javax.inject.Inject;
 
+@Injector
 public class DemoApplication extends Application {
   private ApplicationComponent applicationComponent;
 
@@ -33,6 +37,7 @@
         .build();
   }
 
+  @ProvidesComponent
   public ApplicationComponent component() {
     return applicationComponent;
   }
diff --git a/examples/android-simple/src/main/AndroidManifest.xml b/examples/android-simple/src/main/AndroidManifest.xml
index 53c83bfd3..245570178 100644
--- a/examples/android-simple/src/main/AndroidManifest.xml
+++ b/examples/android-simple/src/main/AndroidManifest.xml
@@ -9,7 +9,7 @@
 
   <application
       android:label="app_name"
-      android:name=".DemoApplication">
+      android:name=".DemoApplication1">
     <activity
         android:label="app_name"
         android:name=".ui.HomeActivity">
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
index 574fa727c..6cf8c3c79 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
@@ -30,9 +30,9 @@
  */
 @Module
 public class AndroidModule {
-  private final DemoApplication application;
+  private final DemoApplication1 application;
 
-  public AndroidModule(DemoApplication application) {
+  public AndroidModule(DemoApplication1 application) {
     this.application = application;
   }
 
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
index 4847b101c..507cf35ea 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
@@ -23,6 +23,6 @@
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     // Perform injection so that when this call returns all dependencies will be available for use.
-    ((DemoApplication) getApplication()).component().inject(this);
+    ((DemoApplication1) getApplication()).component().inject(this);
   }
 }
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
similarity index 75%
rename from examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
rename to examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
index d6b3868f5..5d407243d 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
@@ -20,31 +20,39 @@
 import android.location.LocationManager;
 import com.example.dagger.simple.ui.HomeActivity;
 import dagger.Component;
+import dagger.Injector;
+import dagger.ProvidesComponent;
+
 import javax.inject.Inject;
+import javax.inject.Named;
 import javax.inject.Singleton;
 
-public class DemoApplication extends Application {
+@Injector
+public class DemoApplication1 extends Application {
   
   @Singleton
-  @Component(modules = AndroidModule.class)
+  @Component(modules = {AndroidModule.class, SingletonModule.class})
   public interface ApplicationComponent {
-    void inject(DemoApplication application);
+    void inject(DemoApplication1 application);
     void inject(HomeActivity homeActivity);
     void inject(DemoActivity demoActivity);
   }
   
   @Inject LocationManager locationManager; // for some reason.
-  
+  @Inject @Named("apiKey") String someString;
+  @Inject @Named("apiKey1") String anotherString;
   private ApplicationComponent component;
 
   @Override public void onCreate() {
     super.onCreate();
-    component = DaggerDemoApplication_ApplicationComponent.builder()
+    component = DaggerDemoApplication1_ApplicationComponent.builder()
         .androidModule(new AndroidModule(this))
+
         .build();
     component().inject(this); // As of now, LocationManager should be injected into this.
   }
 
+  @ProvidesComponent
   public ApplicationComponent component() {
     return component;
   }
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java b/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java
new file mode 100644
index 000000000..38db0e8d6
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java
@@ -0,0 +1,25 @@
+package com.example.dagger.simple;
+
+import dagger.Module;
+import dagger.Provides;
+
+import javax.inject.Named;
+
+/**
+ * Created by Andy on 04.05.2017.
+ */
+@Module
+public class SingletonModule {
+
+    @Provides
+    @Named("apiKey")
+    public String someString() {
+       return "";
+    }
+
+    @Provides
+    @Named("apiKey1")
+    public String secondString() {
+        return "";
+    }
+}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
index f0669c61d..a4c2c040d 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
@@ -20,7 +20,7 @@
 import android.os.Bundle;
 import android.util.Log;
 import com.example.dagger.simple.DemoActivity;
-import com.example.dagger.simple.DemoApplication;
+import com.example.dagger.simple.DemoApplication1;
 import javax.inject.Inject;
 
 public class HomeActivity extends DemoActivity {
@@ -28,7 +28,7 @@
 
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
-    ((DemoApplication) getApplication()).component().inject(this);
+    ((DemoApplication1) getApplication()).component().inject(this);
 
     // TODO do something with the injected dependencies here!
     Log.d("HomeActivity", locationManager.toString());
diff --git a/examples/simple/src/main/java/coffee/ActivityScope.java b/examples/simple/src/main/java/coffee/ActivityScope.java
new file mode 100644
index 000000000..9cd2e7c90
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/ActivityScope.java
@@ -0,0 +1,17 @@
+package coffee;
+
+import javax.inject.Qualifier;
+import javax.inject.Scope;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Scope
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+public @interface ActivityScope {
+}
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index b0a93ec3c..c499bbc52 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -1,6 +1,8 @@
 package coffee;
 
 import dagger.Component;
+
+import javax.inject.Named;
 import javax.inject.Singleton;
 
 public class CoffeeApp {
@@ -8,6 +10,13 @@
   @Component(modules = { DripCoffeeModule.class })
   public interface Coffee {
     CoffeeMaker maker();
+    Thermosiphon thermosiphon();
+  }
+
+  @ActivityScope
+  @Component(dependencies = {Coffee.class})
+  public interface Bleu {
+    Thermosiphon thermosiphon();
   }
 
   public static void main(String[] args) {
diff --git a/examples/simple/src/main/java/coffee/CoffeeMaker.java b/examples/simple/src/main/java/coffee/CoffeeMaker.java
index 6410336d0..b9829ba32 100644
--- a/examples/simple/src/main/java/coffee/CoffeeMaker.java
+++ b/examples/simple/src/main/java/coffee/CoffeeMaker.java
@@ -4,18 +4,19 @@
 import javax.inject.Inject;
 
 class CoffeeMaker {
-  private final Lazy<Heater> heater; // Create a possibly costly heater only when we use it.
+
   private final Pump pump;
+  @Inject
+  Heater heater;
 
-  @Inject CoffeeMaker(Lazy<Heater> heater, Pump pump) {
-    this.heater = heater;
+  @Inject public CoffeeMaker(Pump pump) {
     this.pump = pump;
   }
 
   public void brew() {
-    heater.get().on();
+    heater.on();
     pump.pump();
     System.out.println(" [_]P coffee! [_]P ");
-    heater.get().off();
+    heater.off();
   }
 }
diff --git a/examples/simple/src/main/java/coffee/DependencyInjector.java b/examples/simple/src/main/java/coffee/DependencyInjector.java
new file mode 100644
index 000000000..5d1403eaf
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/DependencyInjector.java
@@ -0,0 +1,17 @@
+package coffee;
+
+import dagger.Injector;
+import dagger.ProvidesComponent;
+
+
+@Injector
+public class DependencyInjector {
+
+    @ProvidesComponent
+    public CoffeeApp.Coffee coffee() {
+        return DaggerCoffeeApp_Coffee.builder()
+                .dripCoffeeModule(new DripCoffeeModule())
+                .build();
+    }
+
+}
diff --git a/examples/simple/src/main/java/coffee/DripCoffeeModule.java b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
index e50d249e1..0a18d917a 100644
--- a/examples/simple/src/main/java/coffee/DripCoffeeModule.java
+++ b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
@@ -9,4 +9,7 @@
   @Provides @Singleton Heater provideHeater() {
     return new ElectricHeater();
   }
+  @Provides @Singleton String provideString() {
+    return "";
+  }
 }
diff --git a/examples/simple/src/main/java/coffee/Thermosiphon.java b/examples/simple/src/main/java/coffee/Thermosiphon.java
index c9f9828b0..f5f45a957 100644
--- a/examples/simple/src/main/java/coffee/Thermosiphon.java
+++ b/examples/simple/src/main/java/coffee/Thermosiphon.java
@@ -1,17 +1,18 @@
 package coffee;
 
 import javax.inject.Inject;
+import javax.inject.Provider;
 
 class Thermosiphon implements Pump {
-  private final Heater heater;
+  private final Provider<Heater> heater;
 
   @Inject
-  Thermosiphon(Heater heater) {
+  Thermosiphon(Provider<Heater> heater) {
     this.heater = heater;
   }
 
   @Override public void pump() {
-    if (heater.isHot()) {
+    if (heater.get().isHot()) {
       System.out.println("=> => pumping => =>");
     }
   }
