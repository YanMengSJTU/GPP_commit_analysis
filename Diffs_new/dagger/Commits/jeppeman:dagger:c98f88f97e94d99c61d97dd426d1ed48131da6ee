diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 1dab29f47..37f246e6a 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -27,6 +27,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.DaggerTypes.isFutureType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.Scopes.productionScope;
 import static dagger.internal.codegen.Scopes.scopesOf;
@@ -45,7 +46,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.collect.TreeTraverser;
-import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.ClassName;
 import dagger.BindsInstance;
 import dagger.Component;
@@ -752,7 +752,6 @@ static boolean isComponentContributionMethod(Elements elements, ExecutableElemen
   }
 
   static boolean isComponentProductionMethod(Elements elements, ExecutableElement method) {
-    return isComponentContributionMethod(elements, method)
-        && MoreTypes.isTypeOf(ListenableFuture.class, method.getReturnType());
+    return isComponentContributionMethod(elements, method) && isFutureType(method.getReturnType());
   }
 }
diff --git a/java/dagger/internal/codegen/DaggerTypes.java b/java/dagger/internal/codegen/DaggerTypes.java
index c78e3b1a1..72ed8b579 100644
--- a/java/dagger/internal/codegen/DaggerTypes.java
+++ b/java/dagger/internal/codegen/DaggerTypes.java
@@ -22,6 +22,9 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.FluentFuture;
+import com.google.common.util.concurrent.ListenableFuture;
 import java.util.List;
 import java.util.Optional;
 import javax.annotation.processing.ProcessingEnvironment;
@@ -143,6 +146,13 @@ static void checkTypePresent(TypeMirror type) {
     }
   }
 
+  private static final ImmutableSet<Class<?>> FUTURE_TYPES =
+      ImmutableSet.of(ListenableFuture.class, FluentFuture.class);
+
+  static boolean isFutureType(TypeMirror type) {
+    return FUTURE_TYPES.stream().anyMatch(t -> MoreTypes.isTypeOf(t, type));
+  }
+
   // Implementation of Types methods, delegating to types.
 
   @Override
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
index 726cf605f..d00f10270 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -19,11 +19,11 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.isType;
-import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.DaggerTypes.isFutureType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MapKeys.mapKeyType;
@@ -35,7 +35,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Binds;
 import dagger.BindsOptionalOf;
 import dagger.model.Key;
@@ -65,14 +64,13 @@
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /** A factory for {@link Key}s. */
 final class KeyFactory {
-  private final Types types;
+  private final DaggerTypes types;
   private final Elements elements;
 
-  KeyFactory(Types types, Elements elements) {
+  KeyFactory(DaggerTypes types, Elements elements) {
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
   }
@@ -114,7 +112,7 @@ Key forProductionComponentMethod(ExecutableElement componentMethod) {
     checkArgument(componentMethod.getKind().equals(METHOD));
     TypeMirror returnType = componentMethod.getReturnType();
     TypeMirror keyType =
-        isTypeOf(ListenableFuture.class, returnType)
+        isFutureType(returnType)
             ? getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments())
             : returnType;
     return forMethod(componentMethod, keyType);
@@ -167,15 +165,15 @@ private Key forBindingMethod(
     if (frameworkType.isPresent()
         && frameworkType.get().equals(getClassElement(Producer.class))
         && isType(returnType)) {
-      if (isTypeOf(ListenableFuture.class, returnType)) {
+      if (isFutureType(methodType.getReturnType())) {
         returnType = getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
       } else if (contributionType.equals(ContributionType.SET_VALUES)
           && SetType.isSet(returnType)) {
         SetType setType = SetType.from(returnType);
-        if (setType.elementsAreTypeOf(ListenableFuture.class)) {
+        if (isFutureType(setType.elementType())) {
           returnType =
               types.getDeclaredType(
-                  getClassElement(Set.class), setType.unwrappedElementType(ListenableFuture.class));
+                  getClassElement(Set.class), types.unwrapType(setType.elementType()));
         }
       }
     }
diff --git a/java/dagger/internal/codegen/ProductionBinding.java b/java/dagger/internal/codegen/ProductionBinding.java
index 3c4be36cb..015edfe0a 100644
--- a/java/dagger/internal/codegen/ProductionBinding.java
+++ b/java/dagger/internal/codegen/ProductionBinding.java
@@ -19,6 +19,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.DaggerTypes.isFutureType;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -27,7 +28,6 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.CheckReturnValue;
 import dagger.model.Key;
@@ -154,11 +154,10 @@ ProductionBinding forProducesMethod(
           dependencyRequestFactory.forProductionImplementationExecutor();
       DependencyRequest monitorRequest = dependencyRequestFactory.forProductionComponentMonitor();
       final ProductionKind productionKind;
-      if (MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())) {
+      if (isFutureType(producesMethod.getReturnType())) {
         productionKind = ProductionKind.FUTURE;
       } else if (contributionType.equals(ContributionType.SET_VALUES)
-          && SetType.from(producesMethod.getReturnType())
-              .elementsAreTypeOf(ListenableFuture.class)) {
+          && isFutureType(SetType.from(producesMethod.getReturnType()).elementType())) {
         productionKind = ProductionKind.SET_OF_FUTURE;
       } else {
         productionKind = ProductionKind.IMMEDIATE;
@@ -200,7 +199,7 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
-      checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));
+      checkArgument(isFutureType(componentMethod.getReturnType()));
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .bindingElement(componentMethod)
diff --git a/java/dagger/producers/Produces.java b/java/dagger/producers/Produces.java
index d133a5865..dc00f2444 100644
--- a/java/dagger/producers/Produces.java
+++ b/java/dagger/producers/Produces.java
@@ -19,17 +19,17 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.util.concurrent.ListenableFuture;
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 /**
- * Annotates methods of a producer module to create a production binding. If the method returns
- * a {@link ListenableFuture}, then the parameter type of the future is bound to the value that the
- * future provides; otherwise, the return type is bound to the returned value. The production
- * component will pass dependencies to the method as parameters.
+ * Annotates methods of a producer module to create a production binding. If the method returns a
+ * {@link com.google.common.util.concurrent.ListenableFuture} or {@link
+ * com.google.common.util.concurrent.FluentFuture}, then the parameter type of the future is bound
+ * to the value that the future produces; otherwise, the return type is bound to the returned value.
+ * The production component will pass dependencies to the method as parameters.
  *
  * @author Jesse Beder
  */
diff --git a/javatests/dagger/functional/producers/fluentfuture/FluentFutures.java b/javatests/dagger/functional/producers/fluentfuture/FluentFutures.java
new file mode 100644
index 000000000..7bb25f64e
--- /dev/null
+++ b/javatests/dagger/functional/producers/fluentfuture/FluentFutures.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.fluentfuture;
+
+import static com.google.common.util.concurrent.Futures.immediateFuture;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.FluentFuture;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.BindsInstance;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import java.util.Set;
+import java.util.concurrent.Executor;
+
+final class FluentFutures {
+  interface Dependency {
+    FluentFuture<Float> floatFuture();
+  }
+
+  @ProducerModule
+  static final class Module {
+    @Produces
+    static FluentFuture<Integer> intFuture() {
+      return FluentFuture.from(immediateFuture(5));
+    }
+
+    @Produces
+    static FluentFuture<String> stringFuture(int i) {
+      return FluentFuture.from(immediateFuture("hello"));
+    }
+
+    @Produces
+    @IntoSet
+    static FluentFuture<Double> doubleFuture(int i) {
+      return FluentFuture.from(immediateFuture((double) i));
+    }
+
+    @Produces
+    @IntoSet
+    static double dependencyInput(float f) {
+      return (double) f;
+    }
+
+    @Produces
+    @ElementsIntoSet
+    static Set<FluentFuture<Double>> setOfDoubleFutures(int i) {
+      return ImmutableSet.of(
+          FluentFuture.from(immediateFuture((double) i + 1)),
+          FluentFuture.from(immediateFuture((double) i + 2)));
+    }
+  }
+
+  @ProductionComponent(modules = Module.class, dependencies = Dependency.class)
+  interface Component {
+    ListenableFuture<String> string();
+
+    ListenableFuture<Set<Double>> setOfDouble();
+
+    @ProductionComponent.Builder
+    interface Builder {
+      Builder dependency(Dependency dependency);
+
+      @BindsInstance
+      Builder executor(@Production Executor executor);
+
+      Component build();
+    }
+  }
+}
diff --git a/javatests/dagger/functional/producers/fluentfuture/FluentFuturesTest.java b/javatests/dagger/functional/producers/fluentfuture/FluentFuturesTest.java
new file mode 100644
index 000000000..8745860d9
--- /dev/null
+++ b/javatests/dagger/functional/producers/fluentfuture/FluentFuturesTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.fluentfuture;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.util.concurrent.Futures.immediateFuture;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
+import com.google.common.util.concurrent.FluentFuture;
+import dagger.functional.producers.fluentfuture.FluentFutures.Component;
+import dagger.functional.producers.fluentfuture.FluentFutures.Dependency;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class FluentFuturesTest {
+
+  @Test
+  public void testFluentFutures() throws Exception {
+    Component component =
+        DaggerFluentFutures_Component.builder()
+            .executor(directExecutor())
+            .dependency(
+                new Dependency() {
+                  @Override
+                  public FluentFuture<Float> floatFuture() {
+                    return FluentFuture.from(immediateFuture(42.0f));
+                  }
+                })
+            .build();
+    assertThat(component.string().isDone()).isTrue();
+    assertThat(component.string().get()).isEqualTo("hello");
+    assertThat(component.setOfDouble().isDone()).isTrue();
+    assertThat(component.setOfDouble().get()).containsExactly(5.0, 6.0, 7.0, 42.0);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/KeyFactoryTest.java b/javatests/dagger/internal/codegen/KeyFactoryTest.java
index 4bf8b4498..fe3112867 100644
--- a/javatests/dagger/internal/codegen/KeyFactoryTest.java
+++ b/javatests/dagger/internal/codegen/KeyFactoryTest.java
@@ -40,7 +40,6 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -55,12 +54,12 @@
   @Rule public CompilationRule compilationRule = new CompilationRule();
 
   private Elements elements;
-  private Types types;
+  private DaggerTypes types;
   private KeyFactory keyFactory;
 
   @Before public void setUp() {
-    this.types = compilationRule.getTypes();
     this.elements = compilationRule.getElements();
+    this.types = new DaggerTypes(compilationRule.getTypes(), compilationRule.getElements());
     this.keyFactory = new KeyFactory(types, elements);
   }
 
