diff --git a/subcomponents.md b/subcomponents.md
index 020585e24..383ac35a3 100644
--- a/subcomponents.md
+++ b/subcomponents.md
@@ -24,151 +24,56 @@ Just like for top-level components, you create a subcomponent by writing an
 abstract class or interface that declares [abstract methods that return the
 types your application cares about][component-methods]. Instead of annotating a
 subcomponent with [`@Component`], you annotate it with [`@Subcomponent`] and
-install [`@Module`]s.
+install [`@Module`]s. Similar to [component builders], a
+[`@Subcomponent.Builder`] specifies an interface to supply necessary modules to
+construct the subcomponent.
 
 ```java
 @Subcomponent(modules = RequestModule.class)
 inferface RequestComponent {
   RequestHandler requestHandler();
-}
-```
-
-## Adding a subcomponent to a parent component
-
-To add a subcomponent to a parent component, add an [abstract factory
-method][component-subcomponents] to the parent component that returns the
-subcomponent. If the subcomponent requires a module that does not have a no-arg
-public constructor, and that module is not installed into the parent component,
-then the factory method must have a parameter of that module's type.  The
-factory method may have other parameters for any other modules that are
-installed on the subcomponent but not on the parent component. (The subcomponent
-will automatically share the instance of any module shared between it and its
-parent.)
-
-```java
-@Component(modules = {ServerModule.class, AuthModule.class})
-interface ServerComponent {
-  Server server();
-  SessionComponent sessionComponent(SessionModule sessionModule);
-}
-
-@Subcomponent(modules = SessionModule.class)
-interface SessionComponent {
-  SessionInfo sessionInfo();
-  RequestComponent requestComponent();
-}
-
-@Subcomponent(modules = {RequestModule.class, AuthModule.class})
-interface RequestComponent {
-  RequestHandler requestHandler();
-}
-```
-
-Bindings from `SessionComponent`'s modules can depend on bindings from
-`ServerComponent`'s modules, and bindings from `RequestComponent`'s modules can
-depend on bindings from both `SessionComponent`'s and `ServerComponent`'s
-modules.
-
-In order to create an instance of a subcomponent, you call the factory method on
-an instance of its parent component.
-
-```java
-ServerComponent serverComponent = DaggerServerComponent.create();
-SessionComponent sessionComponent =
-    serverComponent.sessionComponent(new SessionModule(…));
-RequestComponent requestComponent = sessionComponent.requestComponent();
-```
 
-Often you need to create subcomponents from within an object bound inside a
-parent component. To do that, you can rely on the fact that any binding in a
-component can depend on the component type itself.
-
-```java
-class BoundInServerComponent {
-  @Inject ServerComponent serverComponent;
-
-  void doSomethingWithSessionInfo() {
-    SessionComponent sessionComponent =
-        serverComponent.sessionComponent(new SessionModule(…));
-    sessionComponent.sessionInfo().doSomething();
+  @Subcomponent.Builder
+  interface Builder {
+    Builder requestModule(RequestModule module);
+    RequestComponent build();
   }
 }
 ```
 
-### Subcomponent builders
+## Adding a subcomponent to a parent component
 
-You can also define a builder for your subcomponent, similarly to how
-[component builders] are defined.
+To add a subcomponent to a parent component, add the subcomponent class to the
+[`subcomponents`][subcomponents-attribute] attribute of a `@Module` that the
+parent component installs Then the subcomponent's `builder can be requested from
+within the parent.
 
 ```java
-@Component(modules = {ServerModule.class, AuthModule.class})
+@Module(subcomponents = RequestComponent.class)
+class ServerModule {}
+
+@Singleton
+@Component(modules = ServerModule.class)
 interface ServerComponent {
-  Server server();
-  SessionComponent.Builder sessionComponentBuilder();
+  RequestRouter requestRouter();
 }
 
-@Subcomponent(modules = SessionModule.class)
-interface SessionComponent {
-  @Subcomponent.Builder
-  interface Builder {
-    Builder sessionModule(SessionModule sessionModule);
-    SessionComponent build();
+@Singleton
+class RequestRouter {
+  @Inject RequestRouter(
+      Provider<RequestComponent.Builder> requestComponentProvider) {}
+
+  void dataReceived(Data data) {
+    RequestComponent requestComponent =
+        requestComponentProvider.get()
+            .data(data)
+            .build();
+    requestComponent.requestHandler()
+        .writeResponse(200, "hello, world");
   }
 }
-
-ServerComponent serverComponent = DaggerServerComponent.create();
-SessionComponent sessionComponent = serverComponent.sessionComponentBuilder()
-    .sessionModule(new SessionModule(…))
-    .build();
-```
-
-#### Injecting subcomponent builders
-
-Like the component itself, subcomponent builders are bound in the graph and can
-be injected, too. So instead of injecting the component and calling the subcomponent
-builder method on it, you can inject the builder itself:
-
-```java
-  /** Injecting the subcomponent builder. This is simpler than what's below. */
-  class SessionStarterInjectingSubcomponentBuilder {
-    private final SessionComponent.Builder sessionComponentBuilder;
-    
-    @Inject SessionStarterInjectingSubcomponentBuilder(
-        SessionComponent.Builder sessionComponentBuilder) {
-      this.sessionComponentBuilder = sessionComponentBuilder;
-    }
-    
-    Session startSession() {
-      return sessionComponentBuilder
-          .sessionModule(new SessionModule(…))
-          .build()
-          .session();
-    }
-  }
-
-  /**
-   * Injecting the component and calling the factory method. Not as simple as
-   * what's above.
-   */
-  class SessionStarterInjectingComponent {
-    private final ServerComponent serverComponent;
-    
-    @Inject SessionStarterInjectingComponent(ServerComponent serverComponent) {
-      this.serverComponent = serverComponent;
-    }
-
-    Session startSession() {
-      return serverComponent.sessionComponentBuilder()
-          .sessionModule(new SessionModule(…))
-          .build()
-          .session();
-    }
-  }
 ```
 
-Note that `SessionStarterInjectingSubcomponentBuilder` doesn't refer to
-`ServerComponent` at all.
-
 <!-- TODO(dpb):
      Describe the "subcomponent framework" pattern in detail elsewhere.
 -->
@@ -212,9 +117,9 @@ type in another.
 ```java
 @RootScope @Component
 interface RootComponent {
-  BadChildComponent badChildComponent(); // ERROR!
-  SiblingComponentOne siblingComponentOne();
-  SiblingComponentTwo siblingComponentTwo();
+  BadChildComponent.Builder badChildComponent(); // ERROR!
+  SiblingComponentOne.Builder siblingComponentOne();
+  SiblingComponentTwo.Builder siblingComponentTwo();
 }
 
 @RootScope @Subcomponent
@@ -227,11 +132,10 @@ interface SiblingComponentOne {…}
 interface SiblingComponentTwo {…}
 ```
 
-Because a subcomponent is instantiated by calling a method on its parent, its
-lifetime is strictly smaller than its parent's. That means that it makes sense
-to associate smaller scopes with subcomponents and larger scope with parent
-components. In fact, you almost always want the root component to use the
-[`@Singleton`] scope.
+Because a subcomponent is created from within its parent, its lifetime is
+strictly smaller than its parent's. That means that it makes sense to consider
+subcomponents' scopes as "smaller" and parent components' scopes as "larger". In
+fact, you almost always want the root component to use the [`@Singleton`] scope.
 
 In the example below, `RootComponent` is in [`@Singleton`] scope.
 `@SessionScope` is nested within [`@Singleton`] scope, and `@RequestScope` is
@@ -242,13 +146,13 @@ because they are siblings; neither is an ancestor of the other.
 ```java
 @Singleton @Component
 interface RootComponent {
-  SessionComponent sessionComponent();
+  SessionComponent.Builder sessionComponent();
 }
 
 @SessionScope @Subcomponent
 interface SessionComponent {
-  FooRequestComponent fooRequestComponent();
-  BarRequestComponent barRequestComponent();
+  FooRequestComponent.Builder fooRequestComponent();
+  BarRequestComponent.Builder barRequestComponent();
 }
 
 @RequestScope @Subcomponent
@@ -266,15 +170,72 @@ two screens in your application) share some bindings, say those used for
 authentication and authorization, but each have other bindings that really have
 nothing to do with each other, it might make sense to create separate
 subcomponents for each service or screen, and to put the shared bindings into
-the parent component. In the example above, `FooRequestComponent` and
-`BarRequestComponent` are separate, sibling components. You could combine them
-into one `@RequestScope` component with all their modules, but you might have
-some conflicting bindings.
+the parent component.
+
+In the following example, the `Database` is provided within the `@Singleton`
+component, but all of its implementation details are encapsulated within the
+`DatabaseComponent`. Rest assured that no UI will have access to the
+`DatabaseConnectionPool` to schedule their own queries without going through the
+`Database` since that binding only exists in the subcomponent.
+
+```java
+@Singleton
+@Component(modules = DatabaseModule.class)
+interface ApplicationComponent {
+  Database database();
+}
+
+@Module(subcomponents = DatabaseComponent.class)
+class DatabaseModule {
+  @Provides
+  @Singleton 
+  Database provideDatabase(
+      @NumberOfCores int numberOfCores,
+      DatabaseComponent.Builder databaseComponentBuilder) {
+    return databaseComponentBuilder
+        .databaseImplModule(new DatabaseImplModule(numberOfCores / 2))
+        .build()
+        .database();
+  }
+}
+
+@Module
+class DatabaseImplModule {
+  DatabaseModule(int concurrencyLevel) {}
+  @Provides DatabaseConnectionPool provideDatabaseConnectionPool() {}
+  @Provides DatabaseSchema provideDatabaseSchema() {}
+}
+
+@Subcomponent(modules = DatabaseImplModule.class)
+interface DatabaseComponent {
+  @PrivateToDatabase Database database();
+}
+```
 
 <!-- TODO(dpb): Explore this idea further. -->
 
 <!-- TODO(dpb): ## Subcomponents vs. dependent components -->
 
+## Defining subcomponents with abstract factory methods
+
+In addition to `@Module.subcomponents`, a subcomponent can be installed in a
+parent by declaring an `abstract` factory method in the parent component that
+returns the subcomponent. If the subcomponent requires a module that does not
+have a no-arg public constructor, and that module is not installed into the
+parent component, then the factory method must have a parameter of that module's
+type.  The factory method may have other parameters for any other modules that
+are installed on the subcomponent but not on the parent component. (The
+subcomponent will automatically share the instance of any module shared between
+it and its parent.) Alternatively, the `abstract` method on the parent component
+may return the `@Subcomponent.Builder` and no modules need to be listed as
+parameters.
+
+Using `@Module.subcomponents` is better since it allows Dagger to detect if the
+subcomponent is ever requested. Installing a subcomponent via a method on the
+parent component is an explicit request for that component, even if that method
+is never called. Dagger can't detect that, and thus must generate the
+subcomponent even if you never use it.
+
 ## Details
 
 ### Extending multibindings
@@ -358,10 +319,10 @@ assertThat(child.set()).containsExactly("a", "b", "c", "d");
 
 When the same module type is installed in a component and any of its
 subcomponents, then each of those components will automatically use the same
-instance of the module. This means that it is an error if a subcomponent factory
-method includes a repeated module as a parameter or if you call a subcomponent
-builder method for a repeated module. (The latter cannot be checked at compile
-time, and is a runtime error.)
+instance of the module. This means that it is an error if you call a
+subcomponent builder method for a repeated module or if a subcomponent factory
+method defines a repeated module as a parameter. (The former cannot be checked
+at compile time, and is thus a runtime error.)
 
 ```java
 @Component(modules = {RepeatedModule.class, …})
@@ -392,11 +353,12 @@ DaggerComponentOne.create().componentThreeBuilder()
 [`@Component`]: http://google.github.io/dagger/api/latest/dagger/Component.html
 [component builders]: http://google.github.io/dagger/api/latest/dagger/Component.Builder.html
 [component-methods]: http://google.github.io/dagger/api/latest/dagger/Component.html#component-methods
-[component-subcomponents]: http://google.github.io/dagger/api/latest/dagger/Component.html#subcomponents
 [`@Inject`]: http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html
 [`@Module`]: http://google.github.io/dagger/api/latest/dagger/Module.html
 [`@Provides`]: http://google.github.io/dagger/api/latest/dagger/Provides.html
 [`@Scope`]: http://docs.oracle.com/javaee/7/api/javax/inject/Scope.html
 [`@Singleton`]: http://docs.oracle.com/javaee/7/api/javax/inject/Singleton.html
 [`@Subcomponent`]: http://google.github.io/dagger/api/latest/dagger/Subcomponent.html
+[`@Subcomponent.Builder`]: http://google.github.io/dagger/api/latest/dagger/Subcomponent.Builder.html
+[`subcomponents-attribute`]: http://google.github.io/dagger/api/latest/dagger/Module.html#subcomponents()
 
