diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 814314114..cc12fb2cb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -90,6 +90,12 @@
 
   static final String PROVIDES_METHOD_SET_VALUES_RETURN_SET =
       "@Provides methods of type set values must return a Set";
+  
+  static final String PROVIDES_METHOD_MAP_VALUES_RAW_MAP =
+      "@Provides methods of type map values cannot return a raw Map";
+
+  static final String PROVIDES_METHOD_MAP_VALUES_RETURN_MAP =
+      "@Provides methods of type map values must return a Map";
 
   static final String PROVIDES_METHOD_MUST_RETURN_A_VALUE =
       "@Provides methods must return a value (not void).";
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 6c1965284..2dc0bcb75 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -222,6 +222,10 @@ private void writeGetMethod(JavaWriter writer, ProvisionBinding binding,
           writer.emitStatement("return Collections.singletonMap(module.%s(%s))",
               binding.bindingElement().getSimpleName(), parameterString);
         break;
+        case MAP_VALUES:
+          writer.emitStatement("return module.%s(%s)",
+              binding.bindingElement().getSimpleName(), parameterString);
+        break;
         default:
           throw new AssertionError();
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index f2f1f331d..8be1ab727 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -24,6 +24,8 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RAW_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MAP_VALUES_RAW_MAP;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MAP_VALUES_RETURN_MAP;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -38,6 +40,9 @@
 import dagger.Module;
 import dagger.Provides;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import javax.lang.model.element.Element;
@@ -65,6 +70,11 @@
   private TypeElement getSetElement() {
     return elements.getTypeElement(Set.class.getCanonicalName());
   }
+  
+  private TypeElement getMapElement() {
+    return elements.getTypeElement(Map.class.getCanonicalName());
+  }
+
 
   @Override
   public ValidationReport<ExecutableElement> validate(ExecutableElement providesMethodElement) {
@@ -109,6 +119,7 @@ private TypeElement getSetElement() {
         break;
       case MAP:
         validateKeyType(builder, returnType);
+        break;
       case SET_VALUES:
         if (!returnTypeKind.equals(DECLARED)) {
           builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
@@ -125,6 +136,26 @@ private TypeElement getSetElement() {
           }
         }
         break;
+      case MAP_VALUES:
+        if (!returnTypeKind.equals(DECLARED)) {
+          builder.addItem(PROVIDES_METHOD_MAP_VALUES_RETURN_MAP, providesMethodElement);
+        } else {
+          DeclaredType declaredReturnType = (DeclaredType) returnType;
+          // TODO(gak): should we allow "covariant return" for set values?
+          if (!declaredReturnType.asElement().equals(getMapElement())) {
+            builder.addItem(PROVIDES_METHOD_MAP_VALUES_RETURN_MAP, providesMethodElement);
+          } else if (declaredReturnType.getTypeArguments().isEmpty()) {
+            builder.addItem(PROVIDES_METHOD_MAP_VALUES_RAW_MAP, providesMethodElement);
+          } else {
+            for (TypeMirror type: declaredReturnType.getTypeArguments()) {
+              List<TypeMirror> tmp = new ArrayList<TypeMirror>();
+              tmp.add(type);
+              validateKeyType(builder,
+                  Iterables.getOnlyElement(tmp));
+            }
+          }
+        }
+        break;
       default:
         throw new AssertionError();
     }
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index 4da6a7752..c610602f1 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -47,6 +47,7 @@
     if (rest == null) {
       throw new NullPointerException();
     }
+
     Set<Provider<Set<T>>> contributingProviders = newLinkedHashSetWithExpectedSize(1 + rest.length);
     contributingProviders.add(first);
     for (Provider<Set<T>> provider : rest) {
diff --git a/examples/simple/src/main/java/coffee/PlayEnum.java b/examples/simple/src/main/java/coffee/PlayEnum.java
new file mode 100644
index 000000000..6bdfc0d4c
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/PlayEnum.java
@@ -0,0 +1,96 @@
+package coffee;
+
+import java.util.Calendar;  
+   
+/** 
+ * 演示如何使用 Enum 
+ */  
+public class PlayEnum {  
+   
+    public static void main(String[] args) {  
+   
+  
+        Weekday w = Weekday.Monday;  
+        System.out.println("w = " + w.toString());  
+        System.out.println("Monday compares to Friday = "  
+                + Weekday.Monday.compareTo(Weekday.Friday));  
+   
+        System.out.println("Enum value of Sunday is " + Weekday.valueOf("Sunday"));  
+   
+        try {  
+            System.out.println("Enum value of AnotherDay is "  
+                    + Weekday.valueOf("AnotherDay")); // 这里将会抛出 IllegalArgumentException  
+        } catch (IllegalArgumentException e) {  
+            System.out.println("exception: " + e.getMessage());  
+        }  
+        System.out.println();  
+
+        System.out.println("The first month is " + Month.Jan);  
+        System.out.println("The full name of the first month is " + Month.Jan.getFullName());  
+        System.out.println("The fifth month is " + Month.valueByIndex(5).getFullName());  
+        System.out.println("Index of August is " + Month.valueByFullName("August").getIndex());  
+        System.out.println("Now is " + Month.thisMonth().getFullName());  
+    }  
+}  
+   
+/** 
+ * 一个表示星期几的 enum （这是一个简单的例子） 
+ */  
+enum Weekday {  
+    Monday, Tuesday, Wednesday, Thirsday, Friday, Saturday, Sunday  
+}  
+   
+/** 
+ * 一个表示月份的 enum （这是一个稍微复杂的例子） 
+ */  
+enum Month {  
+   
+    // 十二个月份  
+    Jan("January"),  Feb("Febrary"),   Mar("March"),  
+    Apr("April"),    May("May"),       June("June"),  
+    July("July"),    Aug("August"),    Sept("September"),  
+    Oct("October"),  Nov("November"),  Dec("December");  
+   
+    // 全名  
+    private String fullName;  
+   
+    // 构造方法  
+    Month(String fullName) {  
+        this.fullName = fullName;  
+    }  
+   
+    public String getFullName() {  
+        return fullName;  
+    }  
+   
+    // 获取当前 Enum 值是第几个月份。一月份则返回 1。  
+    public int getIndex() {  
+        return ordinal() + 1;  
+    }  
+   
+    // 根据月数获得 enum 对象  
+    public static Month valueByIndex(int index) {  
+        for (Month month : Month.values()) {  
+            if (month.getIndex() == index) {  
+                return month;  
+            }  
+        }  
+        return null;  
+    }  
+   
+    // 根据全名获得 enum 对象  
+    public static Month valueByFullName(String fullName) {  
+        for (Month month : Month.values()) {  
+            if (month.getFullName().equals(fullName)) {  
+                return month;  
+            }  
+        }  
+        return null;  
+    }  
+   
+    public static Month thisMonth() {  
+        // Calendar 的月份从 0 算起，而 Month 的月份从 1 算起  
+        int index = Calendar.getInstance().get(Calendar.MONTH) + 1;  
+        return valueByIndex(index);  
+    }  
+}  
diff --git a/examples/simple/src/main/java/coffee/RandomClass.java b/examples/simple/src/main/java/coffee/RandomClass.java
new file mode 100644
index 000000000..a2fed5de3
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/RandomClass.java
@@ -0,0 +1,174 @@
+package coffee;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import java.io.OutputStreamWriter;
+import java.util.Map;
+import java.util.Properties;
+import javax.inject.Inject;
+import javax.inject.Scope;
+import javax.inject.Singleton;
+
+import static coffee.RandomClass.WebPath.ADMIN;
+
+public class RandomClass {
+
+  @Scope @interface PerRequest {}
+
+  static enum WebPath {
+    LOGIN("/login"),
+    ADMIN("/admin"),
+    CUSTOM_SHOP("/shop/custom/.*"),
+    SHOP("/shop/.*");
+
+    public final String path;
+    WebPath(String path) {
+      this.path = path;
+    }
+
+    static WebPath match(String string) {
+      for (WebPath path : values()) {
+        if(path.path.matches(string)) {
+          return path;
+        }
+      }
+      throw new IllegalArgumentException("No such path bound: " + string);
+    }
+  }
+
+  @MapKey @interface ForPath {
+    WebPath value();
+  }
+
+  @Component
+  interface Server {
+    Main main();
+  }
+
+  @PerRequest
+  @Component(
+      /*dependencies = Server.class*/
+      modules = {MyModule.class, MyOtherModule.class, RequestModule.class}
+  )
+  interface WebRequest {
+    Map<WebRequest, Handler> handlers();
+  }
+
+  class Main implements Runnable {
+    @Inject HttpListener listener;
+    @Inject Server server;
+    @Inject Dispatcher dispatcher;
+
+    @Override public void run() {
+
+      boolean notQuitting = true;
+      while (notQuitting) {
+        HttpTransaction tx = listener.poll();
+        WebRequest webRequest = new Dagger_WebRequest(server);
+        dispatcher.dispatch(tx);
+      }
+    }
+  }
+
+  @Singleton
+  class Dispatcher {
+    @Inject Map<WebPath, Handler> handlers;
+
+    public void dispatch(HttpTransaction transaction) {
+      WebPath path = WebPath.match(transaction.request().getPath());
+      Handler handler = handlers.get(path);
+      if (handler == null) {
+        throw new IllegalArgumentException("No page found for " + transaction.request().getPath());
+      }
+      handler.handle(transaction);
+    }
+  }
+
+  @Module
+  @PerRequest
+  static class RequestModule {
+    @Provides User user(HttpRequest request, UserDAO dao) {
+      User user = dao.find(request.getCookie("cookie_id"));
+      throw new Redirect(WebPath.LOGIN);
+    }
+  }
+
+  @PerRequest
+  @Module
+  static class MyModule {
+    @PerRequest
+    @Provides(type=MAP)
+    @ForPath(ADMIN)
+    Handler adminHandler(User user) {
+      return new Handler(/* use user*/){
+        @Override public void handle(HttpTransaction transaction) {
+         transaction.response().getOutout().append("Server down.").flush();
+        }
+      };
+    }
+  }
+
+  @Module
+  static class MyOtherModule {
+    @PerRequest
+    @Provides(type=MAP)
+    @ForPath(ADMIN)
+    Handler loginHandler() {
+      return new Handler(){
+        @Override public void handle(HttpTransaction transaction) {
+         transaction.response().getOutout().append("... some login page...").flush();
+        }
+      };
+    }
+  }
+
+  public static void main(String[] args) {
+    Server server = new Dagger_Server();
+    new Thread(server.main()).start();
+  }
+
+  //// Pretend it exists
+
+  interface Handler {
+    void handle(HttpTransaction transaction);
+  }
+  interface HttpListener {
+    HttpTransaction poll();
+  }
+  interface HttpTransaction {
+    HttpRequest request();
+    HttpResponse response();
+  }
+  interface HttpRequest {
+    Properties getAttributes();
+    Object getCookie(String string);
+    String getPath();
+    String[] getQueryParameters();
+  }
+  interface HttpResponse {
+    OutputStreamWriter getOutout();
+  }
+
+  static class MapEntries {
+    static <K, V> Map.Entry<K, V> create(K key, V value) {
+      return null; // in real life we would do something.
+    }
+  }
+
+  interface User {}
+
+  static class Redirect extends Throwable {
+    Redirect(WebPath path) {
+      super();
+    }
+  }
+
+  interface UserDAO {
+
+    User find(Object cookie);
+
+  }
+
+  @interface MapKey {}
+}
\ No newline at end of file
