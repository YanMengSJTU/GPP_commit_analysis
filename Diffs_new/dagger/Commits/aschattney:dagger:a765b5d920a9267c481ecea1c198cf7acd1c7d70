diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index ba5274f35..a925f8d56 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -614,9 +614,9 @@ private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
 
   private void addFrameworkFields() {
     graph.resolvedBindings().values().forEach(this::addField);
-    for (ContributionBinding contributionBinding : graph.delegateRequirements()) {
+    /*for (ContributionBinding contributionBinding : graph.delegateRequirements()) {
       createDelegateField(component, contributionBinding, delegateFieldNames);
-    }
+    }*/
   }
 
   private void addField(ResolvedBindings resolvedBindings) {
@@ -840,18 +840,18 @@ private void implementInterfaceMethods() {
               }
               // fall through
             default:
-              CodeBlock.Builder builder = CodeBlock.builder();
+              /*CodeBlock.Builder builder = CodeBlock.builder();
               final boolean supportsTestDelegate = !componentMethod.methodElement().getReturnType().toString().equals(void.class.getName());
               if (supportsTestDelegate) {
                 final String fieldName = getDelegateFieldName(interfaceRequest.key());
                 builder.beginControlFlow("if ($L != null)", CodeBlock.of(fieldName))
                         .add("return $L.get($L)", CodeBlock.of(fieldName), codeBlock)
                         .nextControlFlow("else");
-              }
+              }*/
               interfaceMethod.addStatement("return $L", codeBlock);
-              if (supportsTestDelegate) {
+              /*if (supportsTestDelegate) {
                 builder.endControlFlow();
-              }
+              }*/
 
               break;
           }
@@ -911,7 +911,7 @@ private void addSubcomponents() {
   private void initializeFrameworkTypes() {
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
 
-    codeBlocks.add(initDelegateFields());
+    //codeBlocks.add(initDelegateFields());
 
     for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
       initializeFrameworkType(bindingKey).ifPresent(codeBlocks::add);
@@ -945,7 +945,7 @@ private void initializeFrameworkTypes() {
     }
   }
 
-  private CodeBlock initDelegateFields() {
+  /*private CodeBlock initDelegateFields() {
     List<CodeBlock> codeBlocks = new ArrayList<>();
     for (ContributionBinding contributionBinding : graph.delegateRequirements()) {
       try {
@@ -954,7 +954,7 @@ private CodeBlock initDelegateFields() {
       }catch(Exception e){}
     }
     return CodeBlocks.concat(codeBlocks);
-  }
+  }*/
 
   /**
    * Returns a single code block representing the initialization of the framework type.
@@ -1192,7 +1192,12 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
 
       case BUILDER_BINDING:
         final CodeBlock parameter = getComponentContributionExpression(ComponentRequirement.forBinding(binding));
-        CodeBlock parameterDecision = CodeBlock.of("$L == null ? $L : $L.get()", delegateFieldName, parameter, delegateFieldName);
+        CodeBlock parameterDecision;
+        if (delegateFieldName != null && bindingSupportsTestDelegate(binding)) {
+          parameterDecision = CodeBlock.of("builder.$L == null ? $L : builder.$L.get()", delegateFieldName, parameter, delegateFieldName);
+        }else {
+          parameterDecision = CodeBlock.of("$L", parameter);
+        }
         return CodeBlock.of(
             "$T.$L($L)",
             InstanceFactory.class,
@@ -1212,7 +1217,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           arguments.addAll(getDependencyArguments(binding));
 
           if (delegateFieldName != null && bindingSupportsTestDelegate(binding)) {
-            arguments.add(0, CodeBlock.of(delegateFieldName));
+            arguments.add(0, CodeBlock.of("builder.$L", delegateFieldName));
           }
 
           CodeBlock factoryCreate =
diff --git a/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
index e540d4b73..e8ef80fa1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
@@ -56,12 +56,6 @@ ClassName nameGeneratedType(DI input) {
             for (MethodSpec.Builder methodBuilder : methodBuilders) {
                 List<CodeBlock> blocks = new ArrayList<>();
                 blocks.add(CodeBlock.of("$L", "return builder"));
-                /*final List<ParameterSpec> parameters = methodBuilder.build().parameters;
-                if (parameters.size() > 1) {
-                    for (ParameterSpec parameter : parameters.subList(1, parameters.size() - 1)) {
-                        blocks.add(CodeBlock.of(".$L($L)", parameter.name, parameter.name));
-                    }
-                }*/
                 final CodeBlock collect = blocks.stream().collect(CodeBlocks.joiningCodeBlocks("\n"));
                 methodBuilder.addStatement("$L", collect);
                 final MethodSpec build = methodBuilder.build();
@@ -90,7 +84,7 @@ ClassName nameGeneratedType(DI input) {
         final java.util.Optional<ExecutableElement> onCreateMethod = applicationClass.getEnclosedElements().stream()
                 .filter(e -> e.getKind() == ElementKind.METHOD)
                 .map(e -> (ExecutableElement) e)
-                .filter(e -> e.getSimpleName().toString().equals("onCreate"))
+                .filter(e -> e.getSimpleName().toString().equals("onCreate") && e.getParameters().isEmpty())
                 .findFirst();
         final com.google.common.base.Optional<DeclaredType> declaredTypeOptional = MoreTypes.nonObjectSuperclass(types, elements, MoreTypes.asDeclared(applicationClass.asType()));
         if (!onCreateMethod.isPresent() && declaredTypeOptional.isPresent()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Decorator.java b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
index 5292d151e..9eb60d9eb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Decorator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
@@ -60,6 +60,20 @@ private ClassName getClassName(BindingGraph input) {
         return Optional.of(builder);
     }
 
+    public TypeSpec.Builder getAccessorType(ClassName appClassName, BindingGraph bindingGraph) {
+        ClassName name = this.getAccessorTypeName(appClassName, bindingGraph);
+        final TypeSpec.Builder interfaceBuilder = TypeSpec.interfaceBuilder(name)
+                .addModifiers(Modifier.PUBLIC);
+        for (ContributionBinding contributionBinding : bindingGraph.delegateRequirements()) {
+            Util.createDelegateMethod(name, interfaceBuilder, contributionBinding);
+        }
+        interfaceBuilder.addMethod(MethodSpec.methodBuilder("and")
+                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
+                .returns(appClass)
+                .build());
+        return interfaceBuilder;
+    }
+
     private void addDecoratorType(TypeSpec.Builder builder, ClassName returnType, String className, TypeName builderClassName, BindingGraph bindingGraph) {
 
         builder.addModifiers(Modifier.PUBLIC);
@@ -72,8 +86,13 @@ private void addDecoratorType(TypeSpec.Builder builder, ClassName returnType, St
         List<CodeBlock> statements = new ArrayList<>();
         final ClassName name = ClassName.bestGuess(className);
         statements.add(CodeBlock.of("$T impl = ($T) builder;", name, name));
+
+        TypeName interfaceName = this.getAccessorTypeName(appClass, bindingGraph);
+
+        builder.addSuperinterface(interfaceName);
+
         for (ContributionBinding contributionBinding : bindingGraph.delegateRequirements()) {
-            Util.createDelegateFieldAndMethod(returnType, builder, contributionBinding, new HashMap<>(1), true);
+            Util.createDelegateFieldAndMethod(interfaceName, builder, contributionBinding, new HashMap<>(1), true);
             final String delegateFieldName = Util.getDelegateFieldName(contributionBinding.key());
             final ClassName delegateTypeName = Util.getDelegateTypeName(contributionBinding.key());
             statements.add(CodeBlock.of("impl.$L(this.$L);", Util.getDelegateMethodName(delegateTypeName), delegateFieldName));
@@ -93,6 +112,9 @@ private void addDecoratorType(TypeSpec.Builder builder, ClassName returnType, St
                 .addCode("$L", statements.stream().collect(CodeBlocks.joiningCodeBlocks("\n")))
                 .returns(builderClassName)
                 .build());
+
+
+
     }
 
     @Override
@@ -106,6 +128,10 @@ void generate(BindingGraph input) throws SourceFileGenerationException {
         }
     }
 
+    public ClassName getAccessorTypeName(ClassName app, BindingGraph bindingGraph) {
+        return app.nestedClass(bindingGraph.componentDescriptor().componentDefinitionType().getSimpleName() + "Accessor");
+    }
+
     public static class Factory {
 
         private final Filer filer;
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
index 05c5a8181..9f68d315f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
@@ -52,13 +52,13 @@ ClassName nameGeneratedType(DI input) {
 
         builder.superclass(ClassName.get(input.getAppClass()));
 
-        final java.util.Optional<ExecutableElement> onCreateMethod = findOnCreateMethod(input.getAppClass());
+        /*final java.util.Optional<ExecutableElement> onCreateMethod = findOnCreateMethod(input.getAppClass());
         if (!onCreateMethod.isPresent()) {
             throw new IllegalStateException("onCreate method not found!");
         }
-        final MethodSpec.Builder overriding = MethodSpec.overriding(onCreateMethod.get());
-        createDecoratorClasses(builder, overriding, components, input.getAppClass());
-        overriding.addStatement("super.onCreate()");
+        final MethodSpec.Builder overriding = MethodSpec.overriding(onCreateMethod.get());*/
+        createDecoratorClasses(builder, components, input.getAppClass());
+        //overriding.addStatement("super.onCreate()");
 
         //builder.addMethod(overriding.build());
 
@@ -71,21 +71,22 @@ ClassName nameGeneratedType(DI input) {
         return Optional.of(builder);
     }
 
-    private void createDecoratorClasses(TypeSpec.Builder builder, MethodSpec.Builder methodBuilder, Set<TypeElement> components, TypeElement appClass) {
+    private void createDecoratorClasses(TypeSpec.Builder builder, Set<TypeElement> components, TypeElement appClass) {
         for (TypeElement component : components) {
             ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(component);
             final BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-            createDecoratorClass(builder, methodBuilder, bindingGraph, appClass);
+            createDecoratorClass(builder, bindingGraph, appClass);
         }
     }
 
-    private void createDecoratorClass(TypeSpec.Builder builder, MethodSpec.Builder methodBuilder, BindingGraph bindingGraph, TypeElement appClass) {
+    private void createDecoratorClass(TypeSpec.Builder builder, BindingGraph bindingGraph, TypeElement appClass) {
         final ClassName appClassName = ClassName.get(appClass);
         ClassName testAppClassName = appClassName.topLevelClassName().peerClass("Test" + appClassName.simpleName());
         final Decorator decorator = decoratorFactory.create(testAppClassName);
         try {
             decorator.generate(bindingGraph);
             final ClassName decoratorName = decorator.nameGeneratedType(bindingGraph);
+            final TypeName accessorName = decorator.getAccessorTypeName(testAppClassName, bindingGraph);
             final String fieldName = Util.lowerCaseFirstLetter(decoratorName.simpleName());
             final String methodName = "decorate" + Util.capitalize(fieldName.replaceAll("Decorator$", ""));
             final FieldSpec.Builder fieldBuilder = FieldSpec.builder(decoratorName, fieldName, Modifier.PRIVATE);
@@ -94,14 +95,15 @@ private void createDecoratorClass(TypeSpec.Builder builder, MethodSpec.Builder m
             builder.addField(field);
             builder.addMethod(MethodSpec.methodBuilder(methodName)
                     .addModifiers(Modifier.PUBLIC)
-                    .returns(decoratorName)
+                    .returns(accessorName)
                     .addStatement("return this.$L", fieldName)
                     .build());
+            builder.addType(decorator.getAccessorType(testAppClassName, bindingGraph).build());
         } catch (SourceFileGenerationException e) {
             throw new IllegalStateException("Exception while generating decorator: " + e);
         }
         for (BindingGraph subGraph : bindingGraph.subgraphs()) {
-            createDecoratorClass(builder, methodBuilder, subGraph, appClass);
+            createDecoratorClass(builder, subGraph, appClass);
         }
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 79265877d..e11537526 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -37,8 +37,8 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import java.util.Optional;
-import dagger.IgnoreStubGeneration;
-import java.util.Set;
+import dagger.AllowStubGeneration;
+
 import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -159,7 +159,7 @@ ProvisionBinding forInjectConstructor(
           ProvisionBinding.builder()
               .contributionType(ContributionType.UNIQUE)
               .bindingElement(constructorElement)
-              .ignoreStubGeneration(constructorElement.getAnnotation(IgnoreStubGeneration.class) != null)
+              .ignoreStubGeneration(constructorElement.getAnnotation(AllowStubGeneration.class) == null)
               .key(key)
               .explicitDependencies(dependencies)
               .membersInjectionRequest(membersInjectionRequest)
@@ -208,7 +208,7 @@ ProvisionBinding forProvidesMethod(
       return ProvisionBinding.builder()
           .contributionType(ContributionType.fromBindingMethod(providesMethod))
           .bindingElement(providesMethod)
-          .ignoreStubGeneration(providesMethod.getAnnotation(IgnoreStubGeneration.class) != null)
+          .ignoreStubGeneration(providesMethod.getAnnotation(AllowStubGeneration.class) == null)
           .contributingModule(contributedBy)
           .key(key)
           .genericParameter(genericParameter)
@@ -286,7 +286,7 @@ ProvisionBinding forBuilderBinding(BuilderRequirementMethod method) {
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .bindingElement(builderMethod)
-          .ignoreStubGeneration(builderMethod.getAnnotation(IgnoreStubGeneration.class) != null)
+          .ignoreStubGeneration(builderMethod.getAnnotation(AllowStubGeneration.class) == null)
           .key(method.requirement().key().get())
           .nullableType(ConfigurationAnnotations.getNullableType(parameterElement))
           .bindingKind(Kind.BUILDER_BINDING)
@@ -301,7 +301,7 @@ ProvisionBinding forSubcomponentBuilderMethod(
       DeclaredType declaredContainer = asDeclared(contributedBy.asType());
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
-          .ignoreStubGeneration(subcomponentBuilderMethod.getAnnotation(IgnoreStubGeneration.class) != null)
+          .ignoreStubGeneration(subcomponentBuilderMethod.getAnnotation(AllowStubGeneration.class) == null)
           .bindingElement(subcomponentBuilderMethod)
           .key(
               keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer))
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 9d89396bf..e6c0aa855 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -549,7 +549,24 @@ public static void createDelegateField(TypeSpec.Builder classBuilder, Contributi
         }
     }
 
-    public static void createDelegateFieldAndMethod(ClassName generatedTypeName, TypeSpec.Builder classBuilder, ContributionBinding binding, Map<Key, String> delegateFieldNames, boolean publicMethod) {
+    public static void createDelegateMethod(TypeName generatedTypeName, TypeSpec.Builder classBuilder, ContributionBinding binding) {
+        try {
+            if (bindingSupportsTestDelegate(binding)) {
+                final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+                final ClassName delegateType = getDelegateTypeName(binding.key());
+                final String methodName = getDelegateMethodName(delegateType);
+                final MethodSpec.Builder delegateMethodBuilder = MethodSpec.methodBuilder(methodName);
+                delegateMethodBuilder.addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);
+                classBuilder.addMethod(delegateMethodBuilder
+                        .returns(generatedTypeName)
+                        .addParameter(delegateType, delegateFieldName)
+                        .build());
+            }
+        } catch (Exception e) {
+        }
+    }
+
+    public static void createDelegateFieldAndMethod(TypeName generatedTypeName, TypeSpec.Builder classBuilder, ContributionBinding binding, Map<Key, String> delegateFieldNames, boolean publicMethod) {
         try {
             if (bindingSupportsTestDelegate(binding)) {
                 final String delegateFieldName = Util.getDelegateFieldName(binding.key());
diff --git a/core/src/main/java/dagger/IgnoreStubGeneration.java b/core/src/main/java/dagger/AllowStubGeneration.java
similarity index 91%
rename from core/src/main/java/dagger/IgnoreStubGeneration.java
rename to core/src/main/java/dagger/AllowStubGeneration.java
index 5ee236329..bdf518cd0 100644
--- a/core/src/main/java/dagger/IgnoreStubGeneration.java
+++ b/core/src/main/java/dagger/AllowStubGeneration.java
@@ -12,5 +12,5 @@
 @Retention(RUNTIME)
 @Target({METHOD, CONSTRUCTOR})
 @Documented
-public @interface IgnoreStubGeneration {
+public @interface AllowStubGeneration {
 }
