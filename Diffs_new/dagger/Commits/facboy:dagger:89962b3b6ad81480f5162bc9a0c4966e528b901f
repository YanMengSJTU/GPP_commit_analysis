diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index f348a2551..7161fbc79 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -247,6 +247,7 @@ java_library(
         "InaccessibleMapKeyProxyGenerator.java",
         "InjectionMethods.java",
         "InjectionOrProvisionProviderCreationExpression.java",
+        "InnerSwitchingProviders.java",
         "InstanceFactoryCreationExpression.java",
         "MapBindingExpression.java",
         "MapFactoryCreationExpression.java",
@@ -273,6 +274,7 @@ java_library(
         "SimpleInvocationBindingExpression.java",
         "SimpleMethodBindingExpression.java",
         "SingleCheckedMethodImplementation.java",
+        "StaticSwitchingProviders.java",
         "SubcomponentBuilderBindingExpression.java",
         "SubcomponentBuilderProviderCreationExpression.java",
         "SubcomponentNames.java",
@@ -305,6 +307,7 @@ java_library(
         "InjectProcessingStep.java",
         "MapKeyProcessingStep.java",
         "ModuleProcessingStep.java",
+        "ProcessingEnvironmentModule.java",
         "ProcessingOptions.java",
         "ProductionExecutorModuleProcessingStep.java",
     ],
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index 63eab5c55..9f17dc9aa 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -16,16 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.asType;
-import static com.google.auto.common.MoreTypes.asTypeElement;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.collect.Iterables.concat;
-import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.model.BindingGraphProxies.childFactoryMethodEdge;
 import static dagger.model.BindingGraphProxies.componentNode;
 import static dagger.model.BindingGraphProxies.dependencyEdge;
-import static dagger.model.BindingGraphProxies.subcomponentBuilderBindingEdge;
-import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
@@ -34,14 +28,14 @@
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
-import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
 import dagger.model.BindingGraph.Node;
 import dagger.model.BindingGraphProxies;
+import dagger.model.DependencyRequest;
+import java.util.Collection;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 
 /** Converts {@link dagger.internal.codegen.BindingGraph}s to {@link dagger.model.BindingGraph}s. */
 final class BindingGraphConverter {
@@ -57,8 +51,8 @@
    * Creates the external {@link dagger.model.BindingGraph} representing the given internal root
    * {@link dagger.internal.codegen.BindingGraph}.
    */
-  dagger.model.BindingGraph convert(BindingGraph graph) {
-    Traverser traverser = new Traverser(graph);
+  dagger.model.BindingGraph convert(BindingGraph rootGraph) {
+    Traverser traverser = new Traverser(rootGraph);
     traverser.traverseComponents();
     return BindingGraphProxies.bindingGraph(traverser.network);
   }
@@ -77,13 +71,26 @@
 
     @Override
     protected void visitComponent(BindingGraph graph) {
-      ComponentNode grandparentNode = parentComponent;
+      ComponentNode grandparentComponent = parentComponent;
       parentComponent = currentComponent;
-      currentComponent = componentNode(componentTreePath().toComponentPath());
+      currentComponent =
+          componentNode(
+              componentTreePath().toComponentPath(), graph.componentDescriptor().entryPoints());
+
       network.addNode(currentComponent);
+
+      for (ComponentMethodDescriptor method : graph.componentDescriptor().entryPointMethods()) {
+        addDependencyEdges(currentComponent, method.dependencyRequest().get(), graph);
+      }
+
+      for (ResolvedBindings resolvedBindings : graph.resolvedBindings()) {
+        bindingNodes(resolvedBindings).forEach(node -> addBindingNode(node, graph));
+      }
+
       super.visitComponent(graph);
+
       currentComponent = parentComponent;
-      parentComponent = grandparentNode;
+      parentComponent = grandparentComponent;
     }
 
     @Override
@@ -93,85 +100,59 @@ protected void visitSubcomponentFactoryMethod(
       super.visitSubcomponentFactoryMethod(graph, parent, factoryMethod);
     }
 
-    @Override
-    protected BindingGraphTraverser bindingGraphTraverser(
-        ComponentTreePath componentTreePath, ComponentMethodDescriptor entryPointMethod) {
-      return new BindingGraphVisitor(componentTreePath, entryPointMethod);
+    /**
+     * Adds a {@link dagger.model.BindingGraph.DependencyEdge} from a node to the binding(s) that
+     * satisfy a dependency request.
+     */
+    private void addDependencyEdges(
+        Node source, DependencyRequest dependencyRequest, BindingGraph graph) {
+      for (BindingNode dependency :
+          bindingNodes(graph.resolvedBindings(dependencyRequest.kind(), dependencyRequest.key()))) {
+        network.addEdge(
+            source, dependency, dependencyEdge(dependencyRequest, source instanceof ComponentNode));
+      }
     }
 
-    private final class BindingGraphVisitor extends BindingGraphTraverser {
-
-      private Node current;
-
-      BindingGraphVisitor(
-          ComponentTreePath componentTreePath, ComponentMethodDescriptor entryPointMethod) {
-        super(componentTreePath, entryPointMethod);
-        current = currentComponent;
-        network.addNode(current);
-      }
+    private ImmutableSet<BindingNode> bindingNodes(ResolvedBindings resolvedBindings) {
+      ImmutableSet.Builder<BindingNode> bindingNodes = ImmutableSet.builder();
+      resolvedBindings
+          .allBindings()
+          .asMap()
+          .forEach(
+              (component, bindings) -> {
+                for (Binding binding : bindings) {
+                  bindingNodes.add(bindingNode(resolvedBindings, binding, component));
+                }
+              });
+      return bindingNodes.build();
+    }
 
-      @Override
-      protected void visitBinding(Binding binding, ComponentDescriptor owningComponent) {
-        // TODO(dpb): Should we visit only bindings owned by the current component, since other
-        // bindings will be visited in the parent?
-        Node previous = current;
-        current = bindingNode(resolvedBindings(), binding, owningComponent);
-        network.addNode(current);
-        if (binding instanceof ContributionBinding) {
-          ContributionBinding contributionBinding = (ContributionBinding) binding;
-          if (contributionBinding.kind().equals(SUBCOMPONENT_BUILDER)) {
-            ImmutableSet.Builder<TypeElement> modules = ImmutableSet.builder();
-            for (SubcomponentDeclaration subcomponentDeclaration :
-                resolvedBindings().subcomponentDeclarations()) {
-              modules.add(subcomponentDeclaration.contributingModule().get());
-            }
-            network.addEdge(
-                current,
-                subcomponentNode(contributionBinding, owningComponent),
-                subcomponentBuilderBindingEdge(modules.build()));
-          }
-        }
-        if (network
-            .edgesConnecting(previous, current)
-            .stream()
-            .flatMap(instancesOf(DependencyEdge.class))
-            .noneMatch(e -> e.dependencyRequest().equals(dependencyRequest()))) {
-          network.addEdge(previous, current, dependencyEdge(dependencyRequest(), atEntryPoint()));
-          super.visitBinding(binding, owningComponent);
-        }
-        current = previous;
+    /** Adds a binding node and edges for all its dependencies. */
+    private void addBindingNode(BindingNode node, BindingGraph graph) {
+      network.addNode(node);
+      for (DependencyRequest dependencyRequest : node.binding().dependencies()) {
+        addDependencyEdges(node, dependencyRequest, graph);
       }
+    }
 
-      private ComponentNode subcomponentNode(
-          ContributionBinding binding, ComponentDescriptor subcomponentParent) {
-        checkArgument(binding.kind().equals(SUBCOMPONENT_BUILDER));
-        TypeElement builderType = asTypeElement(binding.key().type());
-        TypeElement subcomponentType = asType(builderType.getEnclosingElement());
-        ComponentTreePath childPath =
-            componentTreePath()
-                .pathFromRootToAncestor(subcomponentParent)
-                .childPath(subcomponentType);
-        ComponentNode childNode = componentNode(childPath.toComponentPath());
-        network.addNode(childNode);
-        return childNode;
-      }
+    private BindingNode bindingNode(
+        ResolvedBindings resolvedBindings, Binding binding, ComponentDescriptor owningComponent) {
+      return BindingGraphProxies.bindingNode(
+          componentTreePath().pathFromRootToAncestor(owningComponent).toComponentPath(),
+          binding,
+          associatedDeclaringElements(resolvedBindings),
+          () -> bindingDeclarationFormatter.format(binding));
+    }
 
-      private BindingNode bindingNode(
-          ResolvedBindings resolvedBindings, Binding binding, ComponentDescriptor owningComponent) {
-        ImmutableList.Builder<Element> associatedDeclarations = ImmutableList.builder();
-        for (BindingDeclaration declaration :
-            concat(
-                resolvedBindings.multibindingDeclarations(),
-                resolvedBindings.optionalBindingDeclarations(),
-                resolvedBindings.subcomponentDeclarations())) {
-          associatedDeclarations.add(declaration.bindingElement().get());
-        }
-        return BindingGraphProxies.bindingNode(
-            componentTreePath().pathFromRootToAncestor(owningComponent).toComponentPath(),
-            binding,
-            associatedDeclarations.build(),
-            () -> bindingDeclarationFormatter.format(binding));
-      }
+    private ImmutableSet<Element> associatedDeclaringElements(ResolvedBindings resolvedBindings) {
+      return ImmutableList.of(
+              resolvedBindings.multibindingDeclarations(),
+              resolvedBindings.optionalBindingDeclarations(),
+              resolvedBindings.subcomponentDeclarations())
+          .stream()
+          .flatMap(Collection::stream)
+          .map(declaration -> declaration.bindingElement().get())
+          .collect(toImmutableSet());
     }
   }
 }
diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index d1aa53c90..7d97e2a26 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -16,6 +16,8 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableSet;
@@ -88,6 +90,11 @@ static Builder builder() {
   }
 
   static CompilerOptions create(ProcessingEnvironment processingEnv, DaggerElements elements) {
+    checkState(
+        !(experimentalAndroidModeFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED)
+            && experimentalAndroidMode2FeatureStatus(processingEnv).equals(FeatureStatus.ENABLED)),
+        "experimentalAndroidMode and experimentalAndroidMode2 cannot be used together.");
+
     return builder()
         .usesProducers(elements.getTypeElement(Produces.class) != null)
         .headerCompilation(processingEnv.getOptions().containsKey(HEADER_COMPILATION))
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index e86a85679..57a23ede9 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -68,7 +68,8 @@
   private final DaggerElements elements;
   private final CompilerOptions compilerOptions;
   private final MembersInjectionMethods membersInjectionMethods;
-  private final SwitchingProviders switchingProviders;
+  private final InnerSwitchingProviders innerSwitchingProviders;
+  private final StaticSwitchingProviders staticSwitchingProviders;
   private final Table<Key, RequestKind, BindingExpression> expressions = HashBasedTable.create();
 
   ComponentBindingExpressions(
@@ -87,6 +88,7 @@
         subcomponentNames,
         componentRequirementFields,
         new ReferenceReleasingManagerFields(graph, generatedComponentModel),
+        new StaticSwitchingProviders(generatedComponentModel, types),
         optionalFactories,
         types,
         elements,
@@ -100,6 +102,7 @@ private ComponentBindingExpressions(
       SubcomponentNames subcomponentNames,
       ComponentRequirementFields componentRequirementFields,
       ReferenceReleasingManagerFields referenceReleasingManagerFields,
+      StaticSwitchingProviders staticSwitchingProviders,
       OptionalFactories optionalFactories,
       DaggerTypes types,
       DaggerElements elements,
@@ -116,7 +119,9 @@ private ComponentBindingExpressions(
     this.compilerOptions = checkNotNull(compilerOptions);
     this.membersInjectionMethods =
         new MembersInjectionMethods(generatedComponentModel, this, graph, elements, types);
-    this.switchingProviders = new SwitchingProviders(generatedComponentModel, this, types);
+    this.innerSwitchingProviders =
+        new InnerSwitchingProviders(generatedComponentModel, this, types);
+    this.staticSwitchingProviders = staticSwitchingProviders;
   }
 
   /**
@@ -133,6 +138,7 @@ ComponentBindingExpressions forChildComponent(
         subcomponentNames,
         childComponentRequirementFields,
         referenceReleasingManagerFields,
+        staticSwitchingProviders,
         optionalFactories,
         types,
         elements,
@@ -355,7 +361,9 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
 
       case INJECTION:
       case PROVISION:
-        return new InjectionOrProvisionProviderCreationExpression(binding, this);
+        return compilerOptions.experimentalAndroidMode2()
+            ? staticSwitchingProviders.newCreationExpression(binding, this)
+            : new InjectionOrProvisionProviderCreationExpression(binding, this);
 
       case COMPONENT_PRODUCTION:
         return new DependencyMethodProducerCreationExpression(
@@ -589,7 +597,8 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
    * {@code SetFactory}.
    */
   private boolean useStaticFactoryCreation(ContributionBinding binding) {
-    return !compilerOptions.experimentalAndroidMode()
+    return !(compilerOptions.experimentalAndroidMode2()
+            || compilerOptions.experimentalAndroidMode())
         || binding.kind().equals(MULTIBOUND_MAP)
         || binding.kind().equals(MULTIBOUND_SET);
   }
@@ -630,7 +639,7 @@ private BindingExpression providerBindingExpression(ResolvedBindings resolvedBin
         return wrapInMethod(
             resolvedBindings,
             RequestKind.PROVIDER,
-            switchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
+            innerSwitchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
       }
     } else if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
         && !needsCaching(resolvedBindings)) {
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index d6b7141b1..1ce30aefb 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -310,6 +310,14 @@ boolean isProducer() {
         .collect(toImmutableSet());
   }
 
+  /** The entry point dependency requests on the component type. */
+  ImmutableSet<DependencyRequest> entryPoints() {
+    return entryPointMethods()
+        .stream()
+        .map(method -> method.dependencyRequest().get())
+        .collect(toImmutableSet());
+  }
+
   // TODO(gak): Consider making this non-optional and revising the
   // interaction between the spec & generation
   abstract Optional<BuilderSpec> builderSpec();
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index 0614a7873..a77509fc5 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -23,7 +23,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.CheckReturnValue;
-import com.google.googlejavaformat.java.filer.FormattingFiler;
 import dagger.Binds;
 import dagger.BindsInstance;
 import dagger.Component;
@@ -32,18 +31,13 @@
 import dagger.internal.codegen.BindingGraphPlugins.TestingPlugins;
 import dagger.spi.BindingGraphPlugin;
 import java.util.Arrays;
-import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
-import javax.annotation.processing.Filer;
-import javax.annotation.processing.Messager;
 import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.inject.Inject;
 import javax.inject.Singleton;
 import javax.lang.model.SourceVersion;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
@@ -104,28 +98,12 @@ public SourceVersion getSupportedSourceVersion() {
 
   @Override
   protected Iterable<? extends ProcessingStep> initSteps() {
-    Messager messager = processingEnv.getMessager();
-    DaggerElements elements = new DaggerElements(processingEnv);
-    CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
-    ProcessorComponent.Builder builder =
-        DaggerComponentProcessor_ProcessorComponent.builder()
-            .types(processingEnv.getTypeUtils())
-            .elements(elements)
-            .sourceVersion(processingEnv.getSourceVersion())
-            .messager(messager)
-            .processingOptions(processingEnv.getOptions())
-            .compilerOptions(compilerOptions)
-            .testingPlugins(testingPlugins);
-
-    Filer filer;
-    if (compilerOptions.headerCompilation()) {
-      builder.filer(processingEnv.getFiler());
-    } else {
-      builder.filer(new FormattingFiler(processingEnv.getFiler()));
-    }
+    ProcessorComponent.builder()
+        .processingEnvironmentModule(new ProcessingEnvironmentModule(processingEnv))
+        .testingPlugins(testingPlugins)
+        .build()
+        .inject(this);
 
-    ProcessorComponent component = builder.build();
-    component.inject(this);
     spiPlugins.initializePlugins();
     validationPlugins.initializePlugins();
     return processingSteps;
@@ -133,29 +111,24 @@ public SourceVersion getSupportedSourceVersion() {
 
   @Singleton
   @Component(
-    modules = {
-      BindingGraphPluginsModule.class,
-      BindingGraphValidationModule.class,
-      BindingMethodValidatorsModule.class,
-      ProcessingStepsModule.class,
-    }
-  )
+      modules = {
+        ProcessingEnvironmentModule.class,
+        BindingGraphPluginsModule.class,
+        BindingGraphValidationModule.class,
+        BindingMethodValidatorsModule.class,
+        ProcessingStepsModule.class,
+      })
   interface ProcessorComponent {
     void inject(ComponentProcessor processor);
 
+    static Builder builder() {
+      return DaggerComponentProcessor_ProcessorComponent.builder();
+    }
+
     @CanIgnoreReturnValue
     @Component.Builder
     interface Builder {
-      @BindsInstance Builder messager(Messager messager);
-      @BindsInstance Builder filer(Filer filer);
-      @BindsInstance Builder types(Types types);
-      @BindsInstance Builder elements(Elements elements);
-
-      @BindsInstance
-      Builder sourceVersion(SourceVersion sourceVersion);
-
-      @BindsInstance Builder compilerOptions(CompilerOptions compilerOptions);
-      @BindsInstance Builder processingOptions(@ProcessingOptions Map<String, String> options);
+      Builder processingEnvironmentModule(ProcessingEnvironmentModule module);
 
       @BindsInstance
       Builder testingPlugins(
diff --git a/java/dagger/internal/codegen/DaggerElements.java b/java/dagger/internal/codegen/DaggerElements.java
index 0e9d330ef..6aacc5437 100644
--- a/java/dagger/internal/codegen/DaggerElements.java
+++ b/java/dagger/internal/codegen/DaggerElements.java
@@ -26,8 +26,10 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import dagger.Reusable;
 import java.io.Writer;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
@@ -37,7 +39,6 @@
 import java.util.Set;
 import java.util.function.Predicate;
 import javax.annotation.processing.ProcessingEnvironment;
-import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
@@ -52,12 +53,13 @@
 import javax.lang.model.util.Types;
 
 /** Extension of {@link Elements} that adds Dagger-specific methods. */
+@Reusable
 final class DaggerElements implements Elements {
 
   private final Elements elements;
   private final Types types;
 
-  @Inject
+  @VisibleForTesting
   DaggerElements(Elements elements, Types types) {
     this.elements = checkNotNull(elements);
     this.types = checkNotNull(types);
diff --git a/java/dagger/internal/codegen/FactoryGenerator.java b/java/dagger/internal/codegen/FactoryGenerator.java
index 58833b79e..01dcd9e03 100644
--- a/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/java/dagger/internal/codegen/FactoryGenerator.java
@@ -24,6 +24,7 @@
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
@@ -115,6 +116,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
     addConstructorAndFields(binding, factoryBuilder);
     factoryBuilder.addMethod(getMethod(binding));
+    factoryBuilder.addMethod(provideInstanceMethod(binding));
     addCreateMethod(binding, factoryBuilder);
 
     factoryBuilder.addMethod(ProvisionMethod.create(binding, compilerOptions));
@@ -211,12 +213,33 @@ private void addCreateMethod(ProvisionBinding binding, TypeSpec.Builder factoryB
   }
 
   private MethodSpec getMethod(ProvisionBinding binding) {
-    TypeName providedTypeName = providedTypeName(binding);
-    MethodSpec.Builder getMethodBuilder =
+    MethodSpec.Builder methodBuilder =
         methodBuilder("get")
-            .returns(providedTypeName)
             .addAnnotation(Override.class)
-            .addModifiers(PUBLIC);
+            .addModifiers(PUBLIC)
+            .returns(providedTypeName(binding))
+            .addStatement(
+                "return provideInstance($L)",
+                constructorParams(binding)
+                    .stream()
+                    .map(parameter -> CodeBlock.of("$N", parameter))
+                    .collect(toParametersCodeBlock()));
+
+    binding
+        .nullableType()
+        .ifPresent(nullableType -> CodeBlocks.addAnnotation(methodBuilder, nullableType));
+
+    return methodBuilder.build();
+  }
+
+  private MethodSpec provideInstanceMethod(ProvisionBinding binding) {
+    TypeName providedTypeName = providedTypeName(binding);
+    MethodSpec.Builder provideInstanceMethod =
+        methodBuilder("provideInstance")
+            .returns(providedTypeName)
+            .addTypeVariables(bindingTypeElementTypeVariableNames(binding))
+            .addParameters(constructorParams(binding))
+            .addModifiers(PUBLIC, STATIC);
 
     ImmutableMap<Key, FieldSpec> frameworkFields = frameworkFields(binding);
     CodeBlock parametersCodeBlock =
@@ -226,8 +249,8 @@ private MethodSpec getMethod(ProvisionBinding binding) {
     if (binding.kind().equals(PROVISION)) {
       binding
           .nullableType()
-          .ifPresent(nullableType -> CodeBlocks.addAnnotation(getMethodBuilder, nullableType));
-      getMethodBuilder.addStatement(
+          .ifPresent(nullableType -> CodeBlocks.addAnnotation(provideInstanceMethod, nullableType));
+      provideInstanceMethod.addStatement(
           "return $L",
           ProvisionMethod.invoke(
               binding,
@@ -241,7 +264,7 @@ private MethodSpec getMethod(ProvisionBinding binding) {
               compilerOptions));
     } else if (!binding.injectionSites().isEmpty()) {
       CodeBlock instance = CodeBlock.of("instance");
-      getMethodBuilder
+      provideInstanceMethod
           .addStatement("$1T $2L = new $1T($3L)", providedTypeName, instance, parametersCodeBlock)
           .addCode(
               InjectionSiteMethod.invokeAll(
@@ -253,9 +276,10 @@ private MethodSpec getMethod(ProvisionBinding binding) {
                   frameworkFieldUsages(binding.dependencies(), frameworkFields)::get))
           .addStatement("return $L", instance);
     } else {
-      getMethodBuilder.addStatement("return new $T($L)", providedTypeName, parametersCodeBlock);
+      provideInstanceMethod.addStatement(
+          "return new $T($L)", providedTypeName, parametersCodeBlock);
     }
-    return getMethodBuilder.build();
+    return provideInstanceMethod.build();
   }
 
   private static TypeName providedTypeName(ProvisionBinding binding) {
diff --git a/java/dagger/internal/codegen/InnerSwitchingProviders.java b/java/dagger/internal/codegen/InnerSwitchingProviders.java
new file mode 100644
index 000000000..c3c590e3f
--- /dev/null
+++ b/java/dagger/internal/codegen/InnerSwitchingProviders.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static dagger.model.RequestKind.INSTANCE;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.model.Key;
+import javax.inject.Provider;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Generates {@linkplain BindingExpression binding expressions} for a binding that is represented by
+ * an inner {@code SwitchingProvider} class.
+ */
+final class InnerSwitchingProviders extends SwitchingProviders {
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final DaggerTypes types;
+
+  InnerSwitchingProviders(
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions,
+      DaggerTypes types) {
+    super(generatedComponentModel, types);
+    this.componentBindingExpressions = componentBindingExpressions;
+    this.types = types;
+  }
+
+  /**
+   * Returns the binding expression for a binding that satisfies a {@link Provider} requests with a
+   * inner {@code SwitchingProvider} class.
+   */
+  BindingExpression newBindingExpression(ContributionBinding binding) {
+    return new BindingExpression() {
+      @Override
+      Expression getDependencyExpression(ClassName requestingClass) {
+        return getProviderExpression(new SwitchCase(binding, requestingClass));
+      }
+    };
+  }
+
+  @Override
+  protected TypeSpec createSwitchingProviderType(TypeSpec.Builder builder) {
+    return builder
+        .addModifiers(PRIVATE, FINAL)
+        .addField(TypeName.INT, "id", PRIVATE, FINAL)
+        .addMethod(
+            constructorBuilder()
+                .addParameter(TypeName.INT, "id")
+                .addStatement("this.id = id")
+                .build())
+        .build();
+  }
+
+  private final class SwitchCase implements SwitchingProviders.SwitchCase {
+    private final ContributionBinding binding;
+    private final ClassName requestingClass;
+
+    SwitchCase(ContributionBinding binding, ClassName requestingClass) {
+      this.binding = binding;
+      this.requestingClass = requestingClass;
+    }
+
+    @Override
+    public Key key() {
+      return binding.key();
+    }
+
+    @Override
+    public Expression getProviderExpression(ClassName switchType, int switchId) {
+      TypeMirror instanceType = types.accessibleType(binding.contributedType(), requestingClass);
+      return Expression.create(
+          types.wrapType(instanceType, Provider.class),
+          CodeBlock.of("new $T<>($L)", switchType, switchId));
+    }
+
+    @Override
+    public Expression getReturnExpression() {
+      return componentBindingExpressions.getDependencyExpression(
+          binding.key(), INSTANCE, requestingClass);
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/ProcessingEnvironmentModule.java b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
new file mode 100644
index 000000000..786955570
--- /dev/null
+++ b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.googlejavaformat.java.filer.FormattingFiler;
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Reusable;
+import dagger.internal.codegen.ProcessingEnvironmentModule.ElementsModule;
+import java.util.Map;
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/** Bindings that depend on the {@link ProcessingEnvironment}. */
+@Module(includes = ElementsModule.class)
+final class ProcessingEnvironmentModule {
+
+  private final ProcessingEnvironment processingEnvironment;
+
+  ProcessingEnvironmentModule(ProcessingEnvironment processingEnvironment) {
+    this.processingEnvironment = checkNotNull(processingEnvironment);
+  }
+
+  @Provides
+  @ProcessingOptions
+  Map<String, String> processingOptions() {
+    return processingEnvironment.getOptions();
+  }
+
+  @Provides
+  Messager messager() {
+    return processingEnvironment.getMessager();
+  }
+
+  @Provides
+  @Reusable // to avoid noting about disabling the formatter more than once
+  Filer filer(CompilerOptions compilerOptions, Messager messager) {
+    if (compilerOptions.headerCompilation()) {
+      return processingEnvironment.getFiler();
+    } else {
+      return new FormattingFiler(processingEnvironment.getFiler());
+    }
+  }
+
+  @Provides
+  Types types() {
+    return processingEnvironment.getTypeUtils();
+  }
+
+  @Provides
+  SourceVersion sourceVersion() {
+    return processingEnvironment.getSourceVersion();
+  }
+
+  @Provides
+  DaggerElements daggerElements() {
+    return new DaggerElements(processingEnvironment);
+  }
+
+  @Provides
+  @Reusable // to avoid parsing options more than once
+  CompilerOptions compilerOptions(DaggerElements elements) {
+    return CompilerOptions.create(processingEnvironment, elements);
+  }
+
+  @Module
+  interface ElementsModule {
+    @Binds
+    Elements elements(DaggerElements daggerElements);
+  }
+}
diff --git a/java/dagger/internal/codegen/ResolvedBindings.java b/java/dagger/internal/codegen/ResolvedBindings.java
index 10b76a427..4aadf633a 100644
--- a/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/java/dagger/internal/codegen/ResolvedBindings.java
@@ -80,32 +80,32 @@
   /**
    * All bindings for {@link #key()}, indexed by the component in which the binding was resolved.
    */
-  private ImmutableSetMultimap<ComponentDescriptor, ? extends Binding> allBindings() {
+  final ImmutableSetMultimap<ComponentDescriptor, ? extends Binding> allBindings() {
     return !allMembersInjectionBindings().isEmpty()
         ? allMembersInjectionBindings().asMultimap()
         : allContributionBindings();
   }
 
   /** All bindings for {@link #key()}, regardless of in which component they were resolved. */
-  ImmutableSet<? extends Binding> bindings() {
+  final ImmutableSet<? extends Binding> bindings() {
     return ImmutableSet.copyOf(allBindings().values());
   }
 
   /**
    * Returns the single binding.
    *
-   * @throws IllegalStateException if there is not exactly one element in {@link #bindings()},
-   *     which will never happen for contributions in valid graphs
+   * @throws IllegalStateException if there is not exactly one element in {@link #bindings()}, which
+   *     will never happen for contributions in valid graphs
    */
-  Binding binding() {
+  final Binding binding() {
     return getOnlyElement(bindings());
   }
 
   /**
-   * {@code true} if there are no {@link #bindings()}, {@link #multibindingDeclarations()},
-   * {@link #optionalBindingDeclarations()}, or {@link #subcomponentDeclarations()}.
+   * {@code true} if there are no {@link #bindings()}, {@link #multibindingDeclarations()}, {@link
+   * #optionalBindingDeclarations()}, or {@link #subcomponentDeclarations()}.
    */
-  boolean isEmpty() {
+  final boolean isEmpty() {
     return bindings().isEmpty()
         && multibindingDeclarations().isEmpty()
         && optionalBindingDeclarations().isEmpty()
@@ -121,12 +121,12 @@ boolean isEmpty() {
    * All contribution bindings, regardless of owning component. Empty if this is a members-injection
    * binding.
    */
-  ImmutableSet<ContributionBinding> contributionBindings() {
+  final ImmutableSet<ContributionBinding> contributionBindings() {
     return ImmutableSet.copyOf(allContributionBindings().values());
   }
 
   /** The component that owns {@code binding}. */
-  ComponentDescriptor owningComponent(ContributionBinding binding) {
+  final ComponentDescriptor owningComponent(ContributionBinding binding) {
     checkArgument(
         contributionBindings().contains(binding),
         "binding is not resolved for %s: %s",
@@ -139,7 +139,7 @@ ComponentDescriptor owningComponent(ContributionBinding binding) {
    * The members-injection binding, regardless of owning component. Absent if these are contribution
    * bindings, or if there is no members-injection binding because the type fails validation.
    */
-  Optional<MembersInjectionBinding> membersInjectionBinding() {
+  final Optional<MembersInjectionBinding> membersInjectionBinding() {
     ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
         FluentIterable.from(allMembersInjectionBindings().values()).toSet();
     return membersInjectionBindings.isEmpty()
@@ -164,7 +164,7 @@ static ResolvedBindings forContributionBindings(
         ImmutableSet.copyOf(subcomponentDeclarations),
         ImmutableSet.copyOf(optionalBindingDeclarations));
   }
-  
+
   /**
    * Creates a {@link ResolvedBindings} for members injection bindings.
    */
diff --git a/java/dagger/internal/codegen/StaticSwitchingProviders.java b/java/dagger/internal/codegen/StaticSwitchingProviders.java
new file mode 100644
index 000000000..f0918dec4
--- /dev/null
+++ b/java/dagger/internal/codegen/StaticSwitchingProviders.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.squareup.javapoet.ClassName.OBJECT;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.TypeName.INT;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ArrayTypeName;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.model.Key;
+import java.util.stream.Stream;
+import javax.inject.Provider;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Generates {@linkplain BindingExpression binding expressions} for a binding that is represented by
+ * a static {@code SwitchingProvider} class.
+ *
+ * <p>Currently, the generated {@code SwitchingProvider} class is generated as a static nested class
+ * in the root component. Ideally, each component would get its own {@code SwitchingProvider}, but
+ * since the subcomponents are inner classes they cannot contain static classes.
+ */
+final class StaticSwitchingProviders extends SwitchingProviders {
+  private final DaggerTypes types;
+  private final ClassName owningComponent;
+
+  StaticSwitchingProviders(GeneratedComponentModel generatedComponentModel, DaggerTypes types) {
+    super(generatedComponentModel, types);
+    this.types = types;
+    this.owningComponent = generatedComponentModel.name();
+  }
+
+  /**
+   * Returns the {@link FrameworkInstanceCreationExpression} for a binding that satisfies a {@link
+   * Provider} requests with a static {@code SwitchingProvider} class.
+   */
+  FrameworkInstanceCreationExpression newCreationExpression(
+      ContributionBinding binding, ComponentBindingExpressions componentBindingExpressions) {
+    return new FrameworkInstanceCreationExpression() {
+      @Override
+      public CodeBlock creationExpression() {
+        return getProviderExpression(new SwitchCase(binding, componentBindingExpressions))
+            .codeBlock();
+      }
+    };
+  }
+
+  @Override
+  protected TypeSpec createSwitchingProviderType(TypeSpec.Builder builder) {
+    return builder
+        .addModifiers(PRIVATE, FINAL, STATIC)
+        .addField(INT, "id", PRIVATE, FINAL)
+        .addField(ArrayTypeName.of(OBJECT), "dependencies", PRIVATE, FINAL)
+        .addMethod(
+            constructorBuilder()
+                .addParameter(INT, "id")
+                .addParameter(ArrayTypeName.of(OBJECT), "dependencies")
+                .varargs()
+                .addStatement("this.id = id")
+                .addStatement("this.dependencies = dependencies")
+                .build())
+        .build();
+  }
+
+  private final class SwitchCase implements SwitchingProviders.SwitchCase {
+    private final ComponentBindingExpressions componentBindingExpressions;
+    private final ContributionBinding binding;
+
+    SwitchCase(
+        ContributionBinding binding, ComponentBindingExpressions componentBindingExpressions) {
+      this.binding = binding;
+      this.componentBindingExpressions = componentBindingExpressions;
+    }
+
+    @Override
+    public Key key() {
+      return binding.key();
+    }
+
+    @Override
+    public Expression getProviderExpression(ClassName switchType, int switchId) {
+      TypeMirror accessibleType = types.accessibleType(binding.contributedType(), owningComponent);
+      // Java 7 type inference can't figure out that instance in
+      // DoubleCheck.provider(new SwitchingProvider<>()) is Provider<T> and not Provider<Object>
+      CodeBlock typeParameter = CodeBlock.of("$T", accessibleType);
+
+      CodeBlock arguments =
+          Stream.of(
+                  CodeBlock.of("$L", switchId),
+                  componentBindingExpressions.getCreateMethodArgumentsCodeBlock(binding))
+              .filter(codeBlock -> !codeBlock.isEmpty())
+              .collect(toParametersCodeBlock());
+
+      return Expression.create(
+          types.wrapType(accessibleType, Provider.class),
+          CodeBlock.of("new $T<$L>($L)", switchType, typeParameter, arguments));
+    }
+
+    @Override
+    public Expression getReturnExpression() {
+      return Expression.create(
+          binding.contributedType(),
+          CodeBlock.of(
+              "$T.provideInstance($L)",
+              generatedClassNameForBinding(binding),
+              getMethodArguments()));
+    }
+
+    private CodeBlock getMethodArguments() {
+      int i = 0;
+      ImmutableList.Builder<CodeBlock> arguments = ImmutableList.builder();
+      if (binding.requiresModuleInstance()) {
+        arguments.add(argument(binding.contributingModule().get().asType(), i++));
+      }
+
+      for (FrameworkDependency dependency : binding.frameworkDependencies()) {
+        TypeMirror type =
+            componentBindingExpressions.getDependencyExpression(dependency, owningComponent).type();
+        arguments.add(argument(type, i++));
+      }
+      return makeParametersCodeBlock(arguments.build());
+    }
+
+    private CodeBlock argument(TypeMirror type, int index) {
+      CodeBlock.Builder builder = CodeBlock.builder();
+      TypeName accessibleType = TypeName.get(types.accessibleType(type, owningComponent));
+      if (!accessibleType.equals(ClassName.OBJECT)) {
+        builder.add("($T) ", accessibleType);
+      }
+      return builder.add("dependencies[$L]", index).build();
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/SwitchingProviders.java b/java/dagger/internal/codegen/SwitchingProviders.java
index 4cb08f601..ba4dbc671 100644
--- a/java/dagger/internal/codegen/SwitchingProviders.java
+++ b/java/dagger/internal/codegen/SwitchingProviders.java
@@ -19,15 +19,12 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getLast;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 import static dagger.internal.codegen.TypeNames.providerOf;
-import static dagger.model.RequestKind.INSTANCE;
-import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
@@ -36,7 +33,6 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
 import dagger.model.Key;
@@ -44,7 +40,6 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.TreeMap;
-import javax.inject.Provider;
 
 /**
  * Keeps track of all provider expression requests for a component.
@@ -52,7 +47,29 @@
  * <p>The provider expression request will be satisfied by a single generated {@code Provider} inner
  * class that can provide instances for all types by switching on an id.
  */
-final class SwitchingProviders {
+abstract class SwitchingProviders {
+  /**
+   * Defines the {@linkplain Expression expressions} for a switch case in a {@code SwitchProvider}
+   * for a particular binding.
+   */
+  // TODO(user): Consider handling SwitchingProviders with dependency arguments in this class,
+  // then we wouldn't need the getProviderExpression method.
+  // TODO(user): Consider making this an abstract class with equals/hashCode defined by the key
+  // and then using this class directly in Map types instead of Key.
+  interface SwitchCase {
+    /** Returns the {@link Key} for this switch case. */
+    Key key();
+
+    /** Returns the {@link Expression} that returns the provided instance for this case. */
+    Expression getReturnExpression();
+
+    /**
+     * Returns the {@link Expression} that returns the {@code SwitchProvider} instance for this
+     * case.
+     */
+    Expression getProviderExpression(ClassName switchType, int switchId);
+  }
+
   /**
    * Each switch size is fixed at 100 cases each and put in its own method. This is to limit the
    * size of the methods so that we don't reach the "huge" method size limit for Android that will
@@ -67,106 +84,84 @@
   private static final TypeVariableName T = TypeVariableName.get("T");
 
   /**
-   * Maps a {@link Key} to an instance of a {@link SwitchingProviderExpressions}. Each group of
-   * {@code MAX_CASES_PER_CLASS} keys will share the same instance.
+   * Maps a {@link Key} to an instance of a {@link SwitchingProviderBuilder}. Each group of {@code
+   * MAX_CASES_PER_CLASS} keys will share the same instance.
    */
-  private final Map<Key, SwitchingProviderExpressions> switchingProviderExpressionsMap =
+  private final Map<Key, SwitchingProviderBuilder> switchingProviderBuilders =
       new LinkedHashMap<>();
 
-  private final ComponentBindingExpressions componentBindingExpressions;
   private final GeneratedComponentModel generatedComponentModel;
   private final ClassName owningComponent;
   private final DaggerTypes types;
   private final UniqueNameSet switchingProviderNames = new UniqueNameSet();
 
-  SwitchingProviders(
-      GeneratedComponentModel generatedComponentModel,
-      ComponentBindingExpressions componentBindingExpressions,
-      DaggerTypes types) {
+  SwitchingProviders(GeneratedComponentModel generatedComponentModel, DaggerTypes types) {
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.types = checkNotNull(types);
     this.owningComponent = checkNotNull(generatedComponentModel).name();
   }
 
+  /** Returns the {@link TypeSpec} for a {@code SwitchingProvider} based on the given builder. */
+  protected abstract TypeSpec createSwitchingProviderType(TypeSpec.Builder builder);
+
   /**
-   * Returns the binding expression for a binding that satisfies its {link Provider} requests with
-   * the generated {@code SwitchingProvider}.
+   * Returns the {@link Expression} that returns the {@code SwitchProvider} instance for the case.
    */
-  BindingExpression newBindingExpression(ContributionBinding binding) {
-    return new BindingExpression() {
-      @Override
-      Expression getDependencyExpression(ClassName requestingClass) {
-        return switchingProviderExpressionsMap
-            .computeIfAbsent(binding.key(), key -> getSwitchingProviderExpressions())
-            .getExpression(binding);
-      }
-    };
+  protected final Expression getProviderExpression(SwitchCase switchCase) {
+    return switchingProviderBuilders
+        .computeIfAbsent(switchCase.key(), key -> getSwitchingProviderBuilder())
+        .getProviderExpression(switchCase);
   }
 
-  private SwitchingProviderExpressions getSwitchingProviderExpressions() {
-    if (switchingProviderExpressionsMap.size() % MAX_CASES_PER_CLASS == 0) {
+  private SwitchingProviderBuilder getSwitchingProviderBuilder() {
+    if (switchingProviderBuilders.size() % MAX_CASES_PER_CLASS == 0) {
       String name = switchingProviderNames.getUniqueName("SwitchingProvider");
-      SwitchingProviderExpressions switchingProviderExpressions =
-          new SwitchingProviderExpressions(owningComponent.nestedClass(name));
-      generatedComponentModel.addSwitchingProvider(
-          switchingProviderExpressions::createSwitchingProviderType);
-      return switchingProviderExpressions;
+      SwitchingProviderBuilder switchingProviderBuilder =
+          new SwitchingProviderBuilder(owningComponent.nestedClass(name));
+      generatedComponentModel.addSwitchingProvider(switchingProviderBuilder::build);
+      return switchingProviderBuilder;
     }
-    return getLast(switchingProviderExpressionsMap.values());
+    return getLast(switchingProviderBuilders.values());
   }
 
   // TODO(user): Consider just merging this class with SwitchingProviders.
-  private final class SwitchingProviderExpressions {
+  private final class SwitchingProviderBuilder {
     // Keep the switch cases ordered by switch id. The switch Ids are assigned in pre-order
     // traversal, but the switch cases are assigned in post-order traversal of the binding graph.
     private final Map<Integer, CodeBlock> switchCases = new TreeMap<>();
     private final Map<Key, Integer> switchIds = new HashMap<>();
     private final ClassName switchingProviderType;
 
-    SwitchingProviderExpressions(ClassName switchingProviderType) {
+    SwitchingProviderBuilder(ClassName switchingProviderType) {
       this.switchingProviderType = checkNotNull(switchingProviderType);
     }
 
-    private Expression getExpression(ContributionBinding binding) {
-      if (!switchIds.containsKey(binding.key())) {
+    Expression getProviderExpression(SwitchCase switchCase) {
+      Key key = switchCase.key();
+      if (!switchIds.containsKey(key)) {
         int switchId = switchIds.size();
-        switchIds.put(binding.key(), switchId);
-        switchCases.put(switchId, createSwitchCaseCodeBlock(binding));
+        switchIds.put(key, switchId);
+        switchCases.put(switchId, createSwitchCaseCodeBlock(switchCase));
       }
-
-      return Expression.create(
-          types.wrapType(binding.key().type(), Provider.class),
-          CodeBlock.of("new $T<>($L)", switchingProviderType, switchIds.get(binding.key())));
+      return switchCase.getProviderExpression(switchingProviderType, switchIds.get(key));
     }
 
-    private CodeBlock createSwitchCaseCodeBlock(ContributionBinding binding) {
-      CodeBlock instanceCodeBlock =
-          componentBindingExpressions
-              .getDependencyExpression(binding.key(), INSTANCE, owningComponent)
-              .box(types)
-              .codeBlock();
+    private CodeBlock createSwitchCaseCodeBlock(SwitchCase switchCase) {
+      CodeBlock instanceCodeBlock = switchCase.getReturnExpression().box(types).codeBlock();
 
       return CodeBlock.builder()
           // TODO(user): Is there something else more useful than the key?
-          .add("case $L: // $L \n", switchIds.get(binding.key()), binding.key())
+          .add("case $L: // $L \n", switchIds.get(switchCase.key()), switchCase.key())
           .addStatement("return ($T) $L", T, instanceCodeBlock)
           .build();
     }
 
-    private TypeSpec createSwitchingProviderType() {
-      return classBuilder(switchingProviderType)
-          .addModifiers(PRIVATE, FINAL)
-          .addTypeVariable(T)
-          .addSuperinterface(providerOf(T))
-          .addField(TypeName.INT, "id", PRIVATE, FINAL)
-          .addMethod(
-              constructorBuilder()
-                  .addParameter(TypeName.INT, "id")
-                  .addStatement("this.id = id")
-                  .build())
-          .addMethods(getMethods())
-          .build();
+    private TypeSpec build() {
+      return createSwitchingProviderType(
+          classBuilder(switchingProviderType)
+              .addTypeVariable(T)
+              .addSuperinterface(providerOf(T))
+              .addMethods(getMethods()));
     }
 
     private ImmutableList<MethodSpec> getMethods() {
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index e880bba29..9b578b816 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -341,14 +341,18 @@ public String toString() {
    */
   @AutoValue
   public abstract static class ComponentNode implements Node {
-    static ComponentNode create(ComponentPath componentPath) {
-      return new AutoValue_BindingGraph_ComponentNode(componentPath);
+    static ComponentNode create(
+        ComponentPath componentPath, ImmutableSet<DependencyRequest> entryPoints) {
+      return new AutoValue_BindingGraph_ComponentNode(componentPath, entryPoints);
     }
 
     /** The component represented by this node. */
     @Override
     public abstract ComponentPath componentPath();
 
+    /** The entry points on this component. */
+    public abstract ImmutableSet<DependencyRequest> entryPoints();
+
     @Override
     public final String toString() {
       return componentPath().toString();
diff --git a/java/dagger/model/BindingGraphProxies.java b/java/dagger/model/BindingGraphProxies.java
index 76598b1cd..1bdd17fd9 100644
--- a/java/dagger/model/BindingGraphProxies.java
+++ b/java/dagger/model/BindingGraphProxies.java
@@ -16,6 +16,7 @@
 
 package dagger.model;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.common.graph.Network;
 import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ChildFactoryMethodEdge;
@@ -50,8 +51,9 @@ public static BindingNode bindingNode(
   }
 
   /** Creates a new {@link ComponentNode}. */
-  public static ComponentNode componentNode(ComponentPath component) {
-    return ComponentNode.create(component);
+  public static ComponentNode componentNode(
+      ComponentPath component, ImmutableSet<DependencyRequest> entryPoints) {
+    return ComponentNode.create(component, entryPoints);
   }
 
   /** Creates a new {@link DependencyEdge}. */
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index f2884dc43..312a918e4 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -2564,6 +2564,10 @@ public void nullIncorrectlyReturnedFromNonNullableInlinedProvider() {
                 "    implements Factory<String> {",
                 "  @Override",
                 "  public String get() {",
+                "    return provideInstance();",
+                "  }",
+                "",
+                "  public static String provideInstance() {",
                 "    return proxyNonNullableString();",
                 "  }",
                 "",
@@ -2656,6 +2660,10 @@ public void nullCheckingIgnoredWhenProviderReturnsPrimitive() {
                 "",
                 "  @Override",
                 "  public Integer get() {",
+                "    return provideInstance();",
+                "  }",
+                "",
+                "  public static Integer provideInstance() {",
                 "    return proxyPrimitiveInteger();",
                 "  }",
                 "",
diff --git a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index a35fdc087..7941803af 100644
--- a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -152,6 +152,10 @@
             "",
             "  @Override",
             "  public GenericClass<T> get() {",
+            "    return provideInstance(tProvider);",
+            "  }",
+            "",
+            "  public static <T> GenericClass<T> provideInstance(Provider<T> tProvider) {",
             "    return new GenericClass<T>(tProvider.get());",
             "  }",
             "",
@@ -204,6 +208,11 @@
             "",
             "  @Override",
             "  public GenericClass<A, B> get() {",
+            "    return provideInstance(aProvider, bProvider);",
+            "  }",
+            "",
+            "  public static <A, B> GenericClass<A, B>  provideInstance(",
+            "      Provider<A> aProvider, Provider<B> bProvider) {",
             "    GenericClass<A, B> instance = new GenericClass<A, B>();",
             "    GenericClass_MembersInjector.injectA(instance, aProvider.get());",
             "    GenericClass_MembersInjector.injectRegister(instance, bProvider.get());",
@@ -249,6 +258,10 @@
             "",
             "  @Override",
             "  public GenericClass<T> get() {",
+            "    return provideInstance();",
+            "  }",
+            "",
+            "  public static <T> GenericClass<T> provideInstance() {",
             "    return new GenericClass<T>();",
             "  }",
             "",
@@ -297,6 +310,11 @@
             "",
             "  @Override",
             "  public GenericClass<A, B> get() {",
+            "    return provideInstance(aProvider, bProvider);",
+            "  }",
+            "",
+            "  public static <A, B> GenericClass<A, B> provideInstance(",
+            "      Provider<A> aProvider, Provider<B> bProvider) {",
             "    return new GenericClass<A, B>(aProvider.get(), bProvider.get());",
             "  }",
             "",
@@ -356,6 +374,13 @@
             "",
             "  @Override",
             "  public GenericClass<A, B, C> get() {",
+            "    return provideInstance(aProvider, bProvider, cProvider);",
+            "  }",
+            "",
+            "  public static <A extends Number & Comparable<A>,",
+            "      B extends List<? extends String>,",
+            "      C extends List<? super String>> GenericClass<A, B, C> provideInstance(",
+            "          Provider<A> aProvider, Provider<B> bProvider, Provider<C> cProvider) {",
             "    return new GenericClass<A, B, C>(",
             "        aProvider.get(), bProvider.get(), cProvider.get());",
             "  }",
@@ -432,6 +457,22 @@
             "",
             "  @Override",
             "  public GenericClass<A, B> get() {",
+            "    return provideInstance(",
+            "        aAndA2AndPaAndLaProvider,",
+            "        qaProvider,",
+            "        sAndS2AndPsAndLsProvider,",
+            "        qsProvider,",
+            "        bAndB2AndPbAndLbProvider,",
+            "        qbProvider);",
+            "  }",
+            "",
+            "  public static <A, B> GenericClass<A, B> provideInstance(",
+            "      Provider<A> aAndA2AndPaAndLaProvider,",
+            "      Provider<A> qaProvider,",
+            "      Provider<String> sAndS2AndPsAndLsProvider,",
+            "      Provider<String> qsProvider,",
+            "      Provider<B> bAndB2AndPbAndLbProvider,",
+            "      Provider<B> qbProvider) {",
             "    return new GenericClass<A, B>(",
             "      aAndA2AndPaAndLaProvider.get(),",
             "      aAndA2AndPaAndLaProvider.get(),",
@@ -987,6 +1028,10 @@
             "  }",
             "",
             "  @Override public InjectConstructor get() {",
+            "    return provideInstance(sProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor provideInstance(Provider<String> sProvider) {",
             "    return new InjectConstructor(sProvider.get());",
             "  }",
             "",
@@ -1032,6 +1077,10 @@
             "  }",
             "",
             "  @Override public AllInjections get() {",
+            "    return provideInstance(sProvider);",
+            "  }",
+            "",
+            "  public static AllInjections provideInstance(Provider<String> sProvider) {",
             "    AllInjections instance = new AllInjections(sProvider.get());",
             "    AllInjections_MembersInjector.injectS(instance, sProvider.get());",
             "    AllInjections_MembersInjector.injectS2(instance, sProvider.get());",
@@ -1079,6 +1128,10 @@ public void neitherTypeNorSupertypeRequiresMemberInjection() {
             "  private static final B_Factory INSTANCE = new B_Factory();",
             "",
             "  @Override public B get() {",
+            "    return provideInstance();",
+            "  }",
+            "",
+            "  public static B provideInstance() {",
             "    return new B();",
             "  }",
             "",
@@ -1128,6 +1181,11 @@ public void wildcardDependency() {
             "  }",
             "",
             "  @Override public InjectConstructor get() {",
+            "    return provideInstance(objectsProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor provideInstance(",
+            "      Provider<List<?>> objectsProvider) {",
             "    return new InjectConstructor(objectsProvider.get());",
             "  }",
             "",
@@ -1180,6 +1238,11 @@ public void basicNameCollision() {
             "  }",
             "",
             "  @Override public InjectConstructor get() {",
+            "    return provideInstance(factoryProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor provideInstance(",
+            "      Provider<other.pkg.Factory> factoryProvider) {",
             "    return new InjectConstructor(factoryProvider.get());",
             "  }",
             "",
@@ -1237,6 +1300,11 @@ public void nestedNameCollision() {
             "  }",
             "",
             "  @Override public InjectConstructor get() {",
+            "    return provideInstance(factoryProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor provideInstance(",
+            "      Provider<Outer.Factory> factoryProvider) {",
             "    return new InjectConstructor(factoryProvider.get());",
             "  }",
             "",
@@ -1299,6 +1367,12 @@ public void samePackageNameCollision() {
             "  }",
             "",
             "  @Override public InjectConstructor get() {",
+            "    return provideInstance(otherPackageProvider, samePackageProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor provideInstance(",
+            "      Provider<other.pkg.CommonName> otherPackageProvider,",
+            "      Provider<CommonName> samePackageProvider) {",
             "    return new InjectConstructor(",
             "        otherPackageProvider.get(), samePackageProvider.get());",
             "  }",
@@ -1344,6 +1418,10 @@ public void noDeps() {
             "  private static final SimpleType_Factory INSTANCE = new SimpleType_Factory();",
             "",
             "  @Override public SimpleType get() {",
+            "    return provideInstance();",
+            "  }",
+            "",
+            "  public static SimpleType provideInstance() {",
             "    return new SimpleType();",
             "  }",
             "",
@@ -1394,6 +1472,10 @@ public void noDeps() {
             "  private static final OuterType_A_Factory INSTANCE = new OuterType_A_Factory();",
             "",
             "  @Override public OuterType.A get() {",
+            "    return provideInstance();",
+            "  }",
+            "",
+            "  public static OuterType.A provideInstance() {",
             "    return new OuterType.A();",
             "  }",
             "",
diff --git a/javatests/dagger/internal/codegen/MembersInjectionTest.java b/javatests/dagger/internal/codegen/MembersInjectionTest.java
index 203249564..160005095 100644
--- a/javatests/dagger/internal/codegen/MembersInjectionTest.java
+++ b/javatests/dagger/internal/codegen/MembersInjectionTest.java
@@ -1132,6 +1132,11 @@ public void injectsPrimitive() {
             "",
             "  @Override",
             "  public InjectedType get() {",
+            "    return provideInstance(boxedIntAndPrimitiveIntProvider);",
+            "  }",
+            "",
+            "  public static InjectedType provideInstance(",
+            "      Provider<Integer> boxedIntAndPrimitiveIntProvider) {",
             "    InjectedType instance = new InjectedType();",
             "    InjectedType_MembersInjector.injectPrimitiveInt(",
             "        instance, boxedIntAndPrimitiveIntProvider.get());",
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 34adab965..3c0751d4c 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -266,6 +266,10 @@ public void providesMethodReturnsProduced() {
             "  }",
             "",
             "  @Override public String get() {",
+            "    return provideInstance(module);",
+            "  }",
+            "",
+            "  public static String provideInstance(TestModule module) {",
             "    return proxyProvideString(module);",
             "  }",
             "",
@@ -313,6 +317,10 @@ public void providesMethodReturnsProduced() {
             "  }",
             "",
             "  @Override public String get() {",
+            "    return provideInstance(module);",
+            "  }",
+            "",
+            "  public static String provideInstance(TestModule module) {",
             "    return proxyProvideString(module);",
             "  }",
             "",
@@ -361,6 +369,11 @@ public void providesMethodReturnsProduced() {
             "  @Override",
             "  @Nullable",
             "  public String get() {",
+            "    return provideInstance(module);",
+            "  }",
+            "",
+            "  @Nullable",
+            "  public static String provideInstance(TestModule module) {",
             "    return proxyProvideString(module);",
             "  }",
             "",
@@ -459,6 +472,14 @@ public void providesMethodReturnsProduced() {
             "  }",
             "",
             "  @Override public List<Object> get() {",
+            "    return provideInstance(module, aProvider, bProvider, xInjectorProvider);",
+            "  }",
+            "",
+            "  public static List<Object> provideInstance(",
+            "      TestModule module,",
+            "      Provider<Object> aProvider,",
+            "      Provider<Object> bProvider,",
+            "      Provider<MembersInjector<X>> xInjectorProvider) {",
             "    return proxyProvideObjects(",
             "        module, aProvider.get(), bProvider.get(), xInjectorProvider.get());",
             "  }",
@@ -518,6 +539,10 @@ public void providesMethodReturnsProduced() {
             "  }",
             "",
             "  @Override public String get() {",
+            "    return provideInstance(module);",
+            "  }",
+            "",
+            "  public static String provideInstance(TestModule module) {",
             "    return proxyProvideString(module);",
             "  }",
             "",
@@ -572,6 +597,10 @@ public void providesMethodReturnsProduced() {
             "  }",
             "",
             "  @Override public List<List<?>> get() {",
+            "    return provideInstance(module);",
+            "  }",
+            "",
+            "  public static List<List<?>> provideInstance(TestModule module) {",
             "    return proxyProvideWildcardList(module);",
             "  }",
             "",
@@ -624,6 +653,10 @@ public void providesMethodReturnsProduced() {
             "  }",
             "",
             "  @Override public Set<String> get() {",
+            "    return provideInstance(module);",
+            "  }",
+            "",
+            "  public static Set<String> provideInstance(TestModule module) {",
             "    return proxyProvideStrings(module);",
             "  }",
             "",
@@ -918,6 +951,11 @@ public void genericSubclassedModule() {
             "",
             "  @Override",
             "  public List<B> get() {  ",
+            "    return provideInstance(module, bProvider);",
+            "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+            "      List<B> provideInstance(ParentModule<A, B, C> module, Provider<B> bProvider) {",
             "    return proxyProvideListB(module, bProvider.get());",
             "  }",
             "",
@@ -956,6 +994,11 @@ public void genericSubclassedModule() {
             "",
             "  @Override",
             "  public B get() {  ",
+            "    return provideInstance(module, bProvider);",
+            "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+            "      B provideInstance(ParentModule<A, B, C> module, Provider<B> bProvider) {",
             "    return proxyProvideBElement(module, bProvider.get());",
             "  }",
             "",
@@ -996,6 +1039,11 @@ public void genericSubclassedModule() {
             "",
             "  @Override",
             "  public B get() {  ",
+            "    return provideInstance(module, bProvider);",
+            "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+            "      B provideInstance(ParentModule<A, B, C> module, Provider<B> bProvider) {",
             "    return proxyProvideBEntry(module, bProvider.get());",
             "  }",
             "",
@@ -1032,6 +1080,10 @@ public void genericSubclassedModule() {
             "",
             "  @Override",
             "  public Number get() {  ",
+            "    return provideInstance(module);",
+            "  }",
+            "",
+            "  public static Number provideInstance(ChildNumberModule module) {",
             "    return proxyProvideNumber(module);",
             "  }",
             "",
@@ -1064,6 +1116,10 @@ public void genericSubclassedModule() {
             "",
             "  @Override",
             "  public Integer get() {  ",
+            "    return provideInstance(module);",
+            "  }",
+            "",
+            "  public static Integer provideInstance(ChildIntegerModule module) {",
             "    return proxyProvideInteger(module);",
             "  }",
             "",
@@ -1135,6 +1191,10 @@ public void genericSubclassedModule() {
             "",
             "  @Override",
             "  public Map<String, Number> get() {",
+            "    return provideInstance();",
+            "  }",
+            "",
+            "  public static Map<String, Number> provideInstance() {",
             "    return proxyProvideMapStringNumber();",
             "  }",
             "",
@@ -1165,6 +1225,10 @@ public void genericSubclassedModule() {
             "",
             "  @Override",
             "  public Object get() {",
+            "    return provideInstance();",
+            "  }",
+            "",
+            "  public static Object provideInstance() {",
             "    return proxyProvideNonGenericType();",
             "  }",
             "",
@@ -1200,6 +1264,10 @@ public void genericSubclassedModule() {
             "",
             "  @Override",
             "  public String get() {",
+            "    return provideInstance(oProvider);",
+            "  }",
+            "",
+            "  public static String provideInstance(Provider<Object> oProvider) {",
             "    return proxyProvideNonGenericTypeWithDeps(oProvider.get());",
             "  }",
             "",
