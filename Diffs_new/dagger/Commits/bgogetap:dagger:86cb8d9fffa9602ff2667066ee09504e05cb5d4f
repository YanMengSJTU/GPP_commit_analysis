diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
index 65bcfb9dc..208db35ad 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -298,7 +298,7 @@ ContributionBinding componentDependencyMethodBinding(
     checkArgument(dependencyMethod.getKind().equals(METHOD));
     checkArgument(dependencyMethod.getParameters().isEmpty());
     ContributionBinding.Builder<?, ?> builder;
-    if (componentDescriptor.kind().isProducer()
+    if (componentDescriptor.isProduction()
         && isComponentProductionMethod(elements, dependencyMethod)) {
       builder =
           ProductionBinding.builder()
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 69dac084b..21b046b5d 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -174,7 +174,7 @@ TypeElement componentTypeElement() {
    */
   @Memoized
   ImmutableSet<ComponentRequirement> possiblyNecessaryRequirements() {
-    checkState(!componentDescriptor().kind().isRoot());
+    checkState(componentDescriptor().isSubcomponent());
     return componentRequirements(
         StreamSupport.stream(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this).spliterator(), false)
             .flatMap(graph -> graph.ownedModules().stream())
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index ffe647712..921867da0 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -98,7 +98,7 @@
   /** Creates a binding graph for a root component. */
   BindingGraph create(ComponentDescriptor componentDescriptor) {
     checkArgument(
-        componentDescriptor.kind().isRoot() || compilerOptions.aheadOfTimeSubcomponents());
+        !componentDescriptor.isSubcomponent() || compilerOptions.aheadOfTimeSubcomponents());
     return create(Optional.empty(), componentDescriptor);
   }
 
@@ -108,7 +108,7 @@ private BindingGraph create(
     ImmutableSet.Builder<DelegateDeclaration> delegatesBuilder = ImmutableSet.builder();
     ImmutableSet.Builder<OptionalBindingDeclaration> optionalsBuilder = ImmutableSet.builder();
 
-    if (!componentDescriptor.kind().isForModuleValidation()) {
+    if (componentDescriptor.isRealComponent()) {
       // binding for the component itself
       explicitBindingsBuilder.add(
           bindingFactory.componentBinding(componentDescriptor.typeElement()));
@@ -186,7 +186,7 @@ private BindingGraph create(
               }
             });
 
-    if (requestResolver.rootComponent().kind().isForModuleValidation()) {
+    if (!requestResolver.rootComponent().isRealComponent()) {
       // For module-binding validation, resolve the keys for all bindings in all modules, stripping
       // any multibinding contribution identifier so that the multibinding itself is resolved.
       modules(componentDescriptor, parentResolver).stream()
@@ -246,12 +246,11 @@ private BindingGraph create(
   }
 
   private boolean shouldIncludeImplicitProductionModules(
-      ComponentDescriptor componentDescriptor, Optional<Resolver> parentResolver) {
-    ComponentKind kind = componentDescriptor.kind();
-    return kind.isProducer()
-        && ((kind.isRoot() && !kind.isForModuleValidation())
+      ComponentDescriptor component, Optional<Resolver> parentResolver) {
+    return component.isProduction()
+        && ((!component.isSubcomponent() && component.isRealComponent())
             || (parentResolver.isPresent()
-                && !parentResolver.get().componentDescriptor.kind().isProducer()));
+                && !parentResolver.get().componentDescriptor.isProduction()));
   }
 
   /**
@@ -409,7 +408,7 @@ private boolean isIncorrectlyScopedInPartialGraph(ProvisionBinding binding) {
       checkArgument(binding.kind().equals(INJECTION));
       Resolver owningResolver = getOwningResolver(binding).orElse(this);
       ComponentDescriptor owningComponent = owningResolver.componentDescriptor;
-      return !rootComponent().kind().isRoot()
+      return rootComponent().isSubcomponent()
           && binding.scope().isPresent()
           && !binding.scope().get().isReusable()
           && !owningComponent.scopes().contains(binding.scope().get());
@@ -611,7 +610,7 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
         for (Resolver requestResolver : getResolverLineage()) {
           // Resolve @Inject @ProductionScope bindings at the highest production component.
           if (binding.kind().equals(INJECTION)
-              && requestResolver.componentDescriptor.kind().isProducer()) {
+              && requestResolver.componentDescriptor.isProduction()) {
             return Optional.of(requestResolver);
           }
 
diff --git a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index 8d6fed0a2..7441e448a 100644
--- a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -18,11 +18,8 @@
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentOrSubcomponentAnnotation;
-import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
-import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
-import static java.util.Arrays.stream;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
 import com.google.auto.common.MoreElements;
@@ -32,7 +29,6 @@
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -42,13 +38,6 @@
  * correct elements.
  */
 final class BindsInstanceProcessingStep extends TypeCheckingProcessingStep<ExecutableElement> {
-
-  private static final ImmutableSet<Class<? extends Annotation>> COMPONENT_ANNOTATIONS =
-      stream(ComponentKind.values())
-          .filter(kind -> !kind.isForModuleValidation())
-          .map(ComponentKind::annotation)
-          .collect(toImmutableSet());
-
   private final Messager messager;
 
   @Inject
@@ -81,15 +70,14 @@ protected void process(
     TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
     moduleAnnotation(enclosingType)
         .ifPresent(moduleAnnotation -> report.addError(didYouMeanBinds(moduleAnnotation)));
-    if (isAnyAnnotationPresent(enclosingType, COMPONENT_ANNOTATIONS)) {
-      AnnotationMirror componentAnnotation =
-          getComponentOrSubcomponentAnnotation(enclosingType).get();
-      report.addError(
-          String.format(
-              "@BindsInstance methods should not be included in @%1$ss. "
-                  + "Did you mean to put it in a @%1$s.Builder?",
-              simpleName(componentAnnotation)));
-    }
+    getComponentOrSubcomponentAnnotation(enclosingType)
+        .ifPresent(
+            componentAnnotation ->
+                report.addError(
+                    String.format(
+                        "@BindsInstance methods should not be included in @%1$ss. "
+                            + "Did you mean to put it in a @%1$s.Builder?",
+                        simpleName(componentAnnotation))));
     report.build().printMessagesTo(messager);
   }
 
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 970f371bc..da4dc1960 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
@@ -24,7 +25,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedAnnotatedTypes;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
-import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentCreator;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerStreams.toImmutableMap;
@@ -55,10 +55,14 @@
 import dagger.model.DependencyRequest;
 import dagger.model.Scope;
 import dagger.producers.CancellationPolicy;
+import dagger.producers.ProducerModule;
 import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.function.Predicate;
 import java.util.stream.Stream;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -82,12 +86,40 @@
  */
 @AutoValue
 abstract class ComponentDescriptor {
-  /** The kind of the component. */
-  abstract ComponentKind kind();
-
   /** The annotation that specifies that {@link #typeElement()} is a component. */
   abstract AnnotationMirror annotation();
 
+  /** Returns {@code true} if this is a subcomponent. */
+  final boolean isSubcomponent() {
+    return Stream.of(Subcomponent.class, ProductionSubcomponent.class).anyMatch(isAnnotationType());
+  }
+
+  /**
+   * Returns {@code true} if this is a production component or subcomponent, or a
+   * {@code @ProducerModule} when doing module binding validation.
+   */
+  final boolean isProduction() {
+    return Stream.of(ProductionComponent.class, ProductionSubcomponent.class, ProducerModule.class)
+        .anyMatch(isAnnotationType());
+  }
+
+  /**
+   * Returns {@code true} if this is a real component, and not a fictional one used to validate
+   * module bindings.
+   */
+  final boolean isRealComponent() {
+    return Stream.of(
+            Component.class,
+            Subcomponent.class,
+            ProductionComponent.class,
+            ProductionSubcomponent.class)
+        .anyMatch(isAnnotationType());
+  }
+
+  private Predicate<Class<? extends Annotation>> isAnnotationType() {
+    return clazz -> isTypeOf(clazz, annotation().getAnnotationType());
+  }
+
   /**
    * The element that defines the component. This is the element to which the {@link #annotation()}
    * was applied.
@@ -240,7 +272,7 @@ private static boolean doesComponentMethodMatch(
    * builder.
    */
   final boolean hasCreator() {
-    return kind().isRoot() || creatorDescriptor().isPresent();
+    return !isSubcomponent() || creatorDescriptor().isPresent();
   }
 
   /**
@@ -248,7 +280,7 @@ final boolean hasCreator() {
    * component is not a production component or no {@code CancellationPolicy} annotation is present.
    */
   final Optional<CancellationPolicy> cancellationPolicy() {
-    return kind().isProducer()
+    return isProduction()
         ? Optional.ofNullable(typeElement().getAnnotation(CancellationPolicy.class))
         : Optional.empty();
   }
@@ -256,7 +288,8 @@ final boolean hasCreator() {
   @Memoized
   @Override
   public int hashCode() {
-    return Objects.hash(typeElement(), kind());
+    // TODO(b/122962745): Only use typeElement().hashCode()
+    return Objects.hash(typeElement(), annotation());
   }
 
   // TODO(ronshapiro): simplify the equality semantics
@@ -486,7 +519,6 @@ private ComponentDescriptor create(TypeElement typeElement, ComponentKind kind)
       }
 
       return new AutoValue_ComponentDescriptor(
-          kind,
           componentAnnotation,
           typeElement,
           componentDependencies,
@@ -509,15 +541,14 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
               types.asMemberOf(MoreTypes.asDeclared(componentElement.asType()), componentMethod));
       TypeMirror returnType = resolvedComponentMethod.getReturnType();
       if (returnType.getKind().equals(DECLARED)) {
-        if (MoreTypes.isTypeOf(Provider.class, returnType)
-            || MoreTypes.isTypeOf(Lazy.class, returnType)) {
+        if (isTypeOf(Provider.class, returnType) || isTypeOf(Lazy.class, returnType)) {
           return ComponentMethodDescriptor.forProvision(
               componentMethod,
               dependencyRequestFactory.forComponentProvisionMethod(
                   componentMethod, resolvedComponentMethod));
         } else if (!getQualifier(componentMethod).isPresent()) {
           Element returnTypeElement = MoreTypes.asElement(returnType);
-          if (isSubcomponent(returnTypeElement)) {
+          if (ConfigurationAnnotations.isSubcomponent(returnTypeElement)) {
             return ComponentMethodDescriptor.forSubcomponent(
                 isAnnotationPresent(returnTypeElement, Subcomponent.class)
                     ? ComponentMethodKind.SUBCOMPONENT
diff --git a/java/dagger/internal/codegen/ComponentDescriptorValidator.java b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
index b0ea96da8..fe60695a8 100644
--- a/java/dagger/internal/codegen/ComponentDescriptorValidator.java
+++ b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
@@ -271,7 +271,7 @@ private void validateCreators(ComponentDescriptor component) {
       }
 
       ComponentCreatorDescriptor creator = component.creatorDescriptor().get();
-      ComponentCreatorMessages msgs = ErrorMessages.creatorMessagesFor(component.kind());
+      ComponentCreatorMessages msgs = ErrorMessages.creatorMessagesFor(component);
 
       // Requirements for modules and dependencies that the creator can set
       Set<ComponentRequirement> creatorModuleAndDependencyRequirements =
diff --git a/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index 521be5293..d1e53330f 100644
--- a/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -141,7 +141,7 @@ private void validateScopeHierarchy(
     scopesByComponent.removeAll(subject);
 
     Predicate<Scope> subjectScopes =
-        subject.kind().isProducer()
+        subject.isProduction()
             // TODO(beder): validate that @ProductionScope is only applied on production components
             ? and(in(subject.scopes()), not(Scope::isProductionScope))
             : in(subject.scopes());
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index 7f8f31757..c6ff1d8eb 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -187,7 +187,7 @@ Element originatingElement(ComponentDescriptor input) {
                   generatedComponent.addMethod(
                       emptyComponentMethod(componentElement, method.methodElement())));
 
-      if (componentDescriptor.kind().isProducer()) {
+      if (componentDescriptor.isProduction()) {
         generatedComponent
             .addSuperinterface(ClassName.get(CancellationListener.class))
             .addMethod(onProducerFutureCancelledMethod());
@@ -211,7 +211,7 @@ private MethodSpec privateConstructor() {
    * ComponentDescriptor#creatorDescriptor()}.
    */
   private Stream<ComponentRequirement> componentRequirements(ComponentDescriptor component) {
-    checkArgument(component.kind().isRoot());
+    checkArgument(!component.isSubcomponent());
     return Stream.concat(
         component.dependencies().stream(),
         component.modules().stream()
diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index de55350ba..c9cd1a35b 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -138,7 +138,7 @@ final ComponentImplementation build() {
 
     addConstructorAndInitializationMethods();
 
-    if (graph.componentDescriptor().kind().isProducer()) {
+    if (graph.componentDescriptor().isProduction()) {
       addCancellationListenerImplementation();
     }
 
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
index 3137e0f54..b49072292 100644
--- a/java/dagger/internal/codegen/ComponentImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -89,7 +89,7 @@ ComponentImplementation topLevelImplementation(ClassName name, BindingGraph grap
         Optional.empty(), // superclassImplementation
         new SubcomponentNames(graph, keyFactory),
         PUBLIC,
-        graph.componentDescriptor().kind().isRoot() ? FINAL : ABSTRACT);
+        graph.componentDescriptor().isSubcomponent() ? ABSTRACT : FINAL);
   }
 
   /** Returns the superclass of the child nested within a superclass of the parent component. */
diff --git a/java/dagger/internal/codegen/ComponentNodeImpl.java b/java/dagger/internal/codegen/ComponentNodeImpl.java
index 64bf8e7a2..3534102a5 100644
--- a/java/dagger/internal/codegen/ComponentNodeImpl.java
+++ b/java/dagger/internal/codegen/ComponentNodeImpl.java
@@ -35,7 +35,7 @@ static ComponentNode create(
 
   @Override
   public final boolean isSubcomponent() {
-    return !componentDescriptor().kind().isRoot();
+    return componentDescriptor().isSubcomponent();
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/ComponentTreeTraverser.java
index f78f2caf8..e77ca3d34 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -52,7 +52,7 @@
   /** Constructs a traverser for a root (component, not subcomponent) binding graph. */
   public ComponentTreeTraverser(BindingGraph rootGraph, CompilerOptions compilerOptions) {
     checkArgument(
-        rootGraph.componentDescriptor().kind().isRoot()
+        !rootGraph.componentDescriptor().isSubcomponent()
             || compilerOptions.aheadOfTimeSubcomponents(),
         "only root graphs can be traversed, not %s",
         rootGraph.componentTypeElement().getQualifiedName());
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 76c9e58bb..d61d8a278 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -27,6 +27,16 @@
  */
 final class ErrorMessages {
 
+  static ComponentCreatorMessages creatorMessagesFor(ComponentDescriptor component) {
+    return component.isProduction()
+        ? component.isSubcomponent()
+            ? ProductionSubcomponentCreatorMessages.INSTANCE
+            : ProductionComponentCreatorMessages.INSTANCE
+        : component.isSubcomponent()
+            ? SubcomponentCreatorMessages.INSTANCE
+            : ComponentCreatorMessages.INSTANCE;
+  }
+
   static ComponentCreatorMessages creatorMessagesFor(ComponentKind kind) {
     switch(kind) {
       case COMPONENT:
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index 41885c096..4fc8b8977 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -275,7 +275,7 @@ ModifiableBindingType getModifiableBindingType(BindingRequest request) {
 
     // When generating a component the binding is not considered modifiable. Bindings are modifiable
     // only across subcomponent implementations.
-    if (componentImplementation.componentDescriptor().kind().isRoot()) {
+    if (!componentImplementation.componentDescriptor().isSubcomponent()) {
       return ModifiableBindingType.NONE;
     }
 
diff --git a/java/dagger/internal/codegen/ProducerEntryPointView.java b/java/dagger/internal/codegen/ProducerEntryPointView.java
index c796ea2eb..8cb41ff23 100644
--- a/java/dagger/internal/codegen/ProducerEntryPointView.java
+++ b/java/dagger/internal/codegen/ProducerEntryPointView.java
@@ -55,7 +55,7 @@
       BindingExpression producerExpression,
       ComponentMethodDescriptor componentMethod,
       ComponentImplementation component) {
-    if (component.componentDescriptor().kind().isProducer()
+    if (component.componentDescriptor().isProduction()
         && (componentMethod.dependencyRequest().get().kind().equals(RequestKind.FUTURE)
             || componentMethod.dependencyRequest().get().kind().equals(RequestKind.PRODUCER))) {
       return Optional.of(
