diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 990316c3e..07b3e5b6f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -626,26 +626,7 @@ private FieldSpec addFrameworkField(
     }
     FieldSpec field = contributionField.build();
     component.addField(field);
-   // try {
-      //ContributionBinding binding = resolvedBindings.contributionBinding();
-      createDelegateFieldAndMethod(name, component, resolvedBindings, delegateFieldNames);
-      /*if (bindingSupportsTestDelegate(binding)) {
-        final String delegateFieldName = contributionBindingField.name() + "Delegate";
-        final ClassName delegateType = getDelegateTypeName(resolvedBindings.binding().key());
-        final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
-        delegateFieldNames.put(resolvedBindings.key(), delegateFieldName);
-        final FieldSpec fieldSpec = builder.build();
-        component.addField(fieldSpec);
-        final String methodName = "with" + delegateType.simpleName().toString();
-        component.addMethod(MethodSpec.methodBuilder(methodName)
-                              .addModifiers(Modifier.PUBLIC)
-                              .returns(name)
-                              .addParameter(delegateType, "delegate")
-                              .addStatement("this.$N = delegate", fieldSpec)
-                              .addStatement("return this")
-                              .build());
-      }*/
-    //}catch(Exception e) {}
+    createDelegateFieldAndMethod(name, component, resolvedBindings, delegateFieldNames);
     return field;
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 129619bb5..4f5215306 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -302,6 +302,7 @@ private BindingGraph create(
       for (ComponentDescriptor subcomponent :
           Iterables.consumingIterable(requestResolver.subcomponentsToResolve)) {
         if (resolvedSubcomponents.add(subcomponent)) {
+          subcomponent.setParentDescriptor(componentDescriptor);
           subgraphs.add(create(Optional.of(requestResolver), subcomponent));
         }
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderModuleStatement.java b/compiler/src/main/java/dagger/internal/codegen/BuilderModuleStatement.java
new file mode 100644
index 000000000..290146399
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderModuleStatement.java
@@ -0,0 +1,129 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.Preconditions;
+
+import javax.lang.model.element.*;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+public class BuilderModuleStatement extends ModuleStatement implements InitializationStatement {
+
+    private ExecutableElement executableElement;
+
+    public BuilderModuleStatement(Types types, TypeElement injector, ComponentDescriptor descriptor, Map<TypeElement, ExecutableElement> moduleMethodMap, Map<Key, VariableElement> providedParams) {
+        super(types, injector, descriptor, moduleMethodMap, providedParams);
+    }
+
+    public void setExecutableElement(ExecutableElement executableElement) {
+        this.executableElement = executableElement;
+    }
+
+    @Override
+    public CodeBlock get() {
+        List<CodeBlock> moduleInitStatements = new ArrayList<>();
+        final ImmutableSet<ModuleDescriptor> modules = descriptor.modules();
+
+        if (isSubComponent() && !descriptor.builderSpec().isPresent()) {
+
+            final Map<Key, ModuleDescriptor> moduleDescriptorMap = modules.stream()
+                    .collect(Collectors.toMap(p -> Key.builder(p.moduleElement().asType()).build(), Function.identity()));
+
+            final List<? extends VariableElement> parameters = executableElement.getParameters();
+            for (VariableElement parameter : parameters) {
+                final Key key = Key.builder(parameter.asType()).build();
+                if (!moduleDescriptorMap.containsKey(key)) {
+                    throw new IllegalStateException(String.format("%s | %s not found", moduleDescriptorMap.entrySet().toString(), parameter.asType().toString()));
+                }
+                final ModuleDescriptor moduleDescriptor = moduleDescriptorMap.get(key);
+                moduleInitStatements.add(processModule(moduleDescriptor));
+            }
+        }
+
+        return makeParametersCodeBlock(moduleInitStatements);
+    }
+
+    private CodeBlock processModule(ModuleDescriptor moduleDescriptor) {
+        final CodeBlock.Builder codeBuilder = CodeBlock.builder();
+        final TypeElement moduleElement = moduleDescriptor.moduleElement();
+        final ExecutableElement method = moduleMethodMap.get(moduleElement);
+        Map<Key, VariableElement> parameterMap;
+        if (method != null) {
+            parameterMap = buildParameterMapWithProvidingModuleMethod(method);
+        }else {
+            parameterMap = getConstructorParameterMap(moduleElement);
+        }
+        final List<CodeBlock> arguments = new ArrayList<>();
+        for (Map.Entry<Key, VariableElement> entry : parameterMap.entrySet()) {
+            if (resolvesToInjectorType(entry)) {
+                arguments.add(CodeBlock.of("$L", "this"));
+            } else {
+                final VariableElement variableElement = providedParams.get(entry.getKey());
+                if (variableElement == null) {
+                    throw new IllegalStateException("parameter is null in providedParams in ModuleStatement for param:" + entry.getValue().asType().toString() + " in module: " + moduleElement.getSimpleName().toString());
+                }
+                arguments.add(CodeBlock.of("$L", variableElement.getSimpleName().toString()));
+            }
+        }
+
+        if (method != null) {
+            codeBuilder.add("this.$L($L)",
+                    method.getSimpleName().toString(),
+                    makeParametersCodeBlock(arguments)
+            );
+        }else {
+            codeBuilder.add("new $T($L)",
+                    ClassName.get(moduleElement),
+                    makeParametersCodeBlock(arguments)
+            );
+        }
+        return codeBuilder.build();
+    }
+
+    private boolean isSubComponent() {
+        return descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT;
+    }
+
+    private Map<Key, VariableElement> buildParameterMapWithProvidingModuleMethod(ExecutableElement providingModuleMethod) {
+        return getMethodParameterMap(providingModuleMethod);
+    }
+
+    private boolean resolvesToInjectorType(Map.Entry<Key, VariableElement> entry) {
+        final TypeMirror type = entry.getKey().type();
+        return types.isAssignable(injector.asType(), type);
+    }
+
+    private Map<Key, VariableElement> getMethodParameterMap(ExecutableElement element) {
+        return element.getParameters()
+                .stream()
+                .collect(Collectors.toMap(e -> Key.builder(e.asType()).build(), Function.identity()));
+    }
+
+    private Map<Key, VariableElement> getConstructorParameterMap(TypeElement element) {
+        Map<Key, VariableElement> result = new HashMap<>();
+        final List<? extends Element> enclosedElements = element.getEnclosedElements();
+        for (Element enclosedElement : enclosedElements) {
+            if (enclosedElement.getKind() == ElementKind.CONSTRUCTOR) {
+                ExecutableElement executableElement = (ExecutableElement) enclosedElement;
+                final List<? extends VariableElement> parameters = executableElement.getParameters();
+                for (VariableElement parameter : parameters) {
+                    result.put(Key.builder(parameter.asType()).build(), parameter);
+                }
+            }
+        }
+        return result;
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java b/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java
index 99ca16dde..ce9df2e15 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java
@@ -4,6 +4,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.Component;
 import dagger.Subcomponent;
@@ -16,19 +17,37 @@
 
 public class BuilderStatement implements InitializationStatement {
 
+    private final BindingGraph.Factory graphFactory;
     private ComponentDescriptor descriptor;
-    private ComponentDescriptor parentDescriptor;
     private ExecutableElement providingMethod;
+    private BuilderModuleStatement builderModuleStatement;
 
-    public BuilderStatement(ComponentDescriptor descriptor, ComponentDescriptor parentDescriptor, ExecutableElement providingMethod) {
+    public BuilderStatement(ComponentDescriptor descriptor, ExecutableElement providingMethod, BuilderModuleStatement builderModuleStatement, BindingGraph.Factory graphFactory) {
         this.descriptor = descriptor;
-        this.parentDescriptor = parentDescriptor;
         this.providingMethod = providingMethod;
+        this.builderModuleStatement = builderModuleStatement;
+        this.graphFactory = graphFactory;
     }
 
     @Override
     public CodeBlock get() {
         if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            CodeBlock.Builder codeBlockBuilder = CodeBlock.builder();
+            final ComponentDescriptor parentDescriptor = descriptor.getParentDescriptor();
+            /*final ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap =
+                    new ComponentWriter.UniqueSubcomponentNamesGenerator(graphFactory.create(parentDescriptor)).generate();
+
+            if (parentDescriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+                final ClassName className = ClassName.bestGuess(resolveSubcomponentClassName(parentDescriptor));
+                packageName = className.packageName() + "." + className.simpleName();
+            }else {
+                final ClassName daggerComponentClassName = Util.getDaggerComponentClassName(parentDescriptor.componentDefinitionType());
+                packageName = daggerComponentClassName.packageName() + "." + daggerComponentClassName.simpleName();
+            }
+            final String subComponentClassName = subcomponentNamesMap.get(descriptor) + "Impl";*/
+            final String subComponentClassName = resolveClassName(descriptor);
+            final ClassName className = ClassName.bestGuess(subComponentClassName);
+            codeBlockBuilder.add("(($T)", className);
             final List<? extends VariableElement> parameters = providingMethod.getParameters();
             for (VariableElement parameter : parameters) {
                 final TypeElement element = MoreTypes.asTypeElement(parameter.asType());
@@ -41,13 +60,41 @@ public CodeBlock get() {
                             typeToSearch = descriptor.builderSpec().get().builderDefinitionType().asType();
                         }
                         if (executableElement.getReturnType().toString().equals(typeToSearch.toString())) {
-                            return CodeBlock.of("$L.$L()", parameter.getSimpleName().toString(), executableElement.getSimpleName().toString());
+                            final String parameterName = parameter.getSimpleName().toString();
+                            final String methodName = executableElement.getSimpleName().toString();
+                            if (!descriptor.builderSpec().isPresent() ) {
+                                // check if method has parameters ...
+                                builderModuleStatement.setExecutableElement(executableElement);
+                                return codeBlockBuilder.add("$L.$L($L))\n", parameterName, methodName, builderModuleStatement.get()).build();
+                            }else {
+                                return codeBlockBuilder.add("$L.$L()\n", parameterName, methodName).build();
+                            }
                         }
                     }
                 }
             }
         }
-        return CodeBlock.of("$T.builder()", Util.getDaggerComponentClassName(descriptor.componentDefinitionType()));
+        final ClassName componentClassName = Util.getDaggerComponentClassName(descriptor.componentDefinitionType());
+        return CodeBlock.of("(($T)$T.builder()\n", componentClassName, componentClassName);
+    }
+
+    private String resolveClassName(ComponentDescriptor descriptor) {
+        if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
+            final ClassName daggerComponentClassName = Util.getDaggerComponentClassName(descriptor.componentDefinitionType());
+            return daggerComponentClassName.packageName() + "." + daggerComponentClassName.simpleName();
+        }else if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            final String parentClassName = resolveClassName(descriptor.getParentDescriptor());
+            final BindingGraph parentGraph = graphFactory.create(descriptor.getParentDescriptor());
+            final ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap =
+                    new ComponentWriter.UniqueSubcomponentNamesGenerator(parentGraph).generate();
+            final String s = subcomponentNamesMap.get(descriptor);
+            if (s == null) {
+                throw new NullPointerException("s is null | " + subcomponentNamesMap.values().toString() + "|" + descriptor.componentDefinitionType().asType().toString());
+            }
+            return parentClassName + "." + s + "Impl";
+        }else {
+            throw new IllegalStateException("unknown");
+        }
     }
 
     private boolean isComponentOrSubcomponent(TypeElement element) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 6c4601229..28ac77235 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -80,6 +80,9 @@
  */
 @AutoValue
 public abstract class ComponentDescriptor {
+
+  private ComponentDescriptor parent;
+
   ComponentDescriptor() {}
 
   enum Kind {
@@ -287,6 +290,14 @@ private static void addTransitiveModules(
   abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
       subcomponentsByFactoryMethod();
 
+  void setParentDescriptor(ComponentDescriptor parent) {
+      this.parent = parent;
+  }
+
+  ComponentDescriptor getParentDescriptor() {
+      return this.parent;
+  }
+
   /**
    * All {@linkplain Subcomponent direct child} components that are declared by a subcomponent
    * builder method.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 2010695d4..ae5c85e15 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -23,6 +23,7 @@
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
 import com.google.googlejavaformat.java.filer.FormattingFiler;
+import com.squareup.javapoet.JavaFile;
 import dagger.Injector;
 
 import java.util.Arrays;
@@ -51,6 +52,7 @@
   private FactoryGenerator factoryGenerator;
   private MembersInjectorGenerator membersInjectorGenerator;
   private StubGenerator stubGenerator;
+  private TestRegistry testRegistry = new TestRegistry();
   private MultipleSourceFileGenerator<ProvisionBinding> multipleGenerator;
 
   @Override
@@ -256,10 +258,14 @@ public SourceVersion getSupportedSourceVersion() {
          new InjectorProcessingStep(
                  types,
                  messager,
-                 new InjectorGenerator(filer, elements),
+                 new InjectorGenerator.Factory(filer, elements, new TestClassGenerator(filer, elements), testRegistry),
                  ComponentDescriptor.Kind.COMPONENT,
                  bindingGraphFactory,
-                 componentDescriptorFactory)
+                 componentDescriptorFactory),
+         new TriggerProcessingStep(
+                 testRegistry,
+                 filer
+         )
     );
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentStatement.java b/compiler/src/main/java/dagger/internal/codegen/ComponentStatement.java
index 760f5fe36..f0b532a66 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentStatement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentStatement.java
@@ -62,7 +62,7 @@ public CodeBlock get() {
                 arguments.add(CodeBlock.of("$L", CodeBlock.of(variableElement.getSimpleName().toString())));
             }
 
-            builder.add(".$L(this.$L($L))", CodeBlock.of(methodName), CodeBlock.of(executableElement.getSimpleName().toString()), makeParametersCodeBlock(arguments));
+            builder.add(".$L(this.$L($L))\n", CodeBlock.of(methodName), CodeBlock.of(executableElement.getSimpleName().toString()), makeParametersCodeBlock(arguments));
         }
         return builder.build();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 06720d3bb..6802ccc82 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -69,7 +69,7 @@
    * Generates a map of unique simple names for all subcomponents, keyed by their {@link
    * ComponentDescriptor}.
    */
-  private static class UniqueSubcomponentNamesGenerator {
+  public static class UniqueSubcomponentNamesGenerator {
 
     private static final Splitter QUALIFIED_NAME_SPLITTER = Splitter.on('.');
     private static final Joiner QUALIFIED_NAME_JOINER = Joiner.on('_');
@@ -79,7 +79,7 @@
         componentDescriptorsBySimpleName;
     private final ImmutableListMultimap<ComponentDescriptor, String> componentQualifiedNamePieces;
 
-    private UniqueSubcomponentNamesGenerator(BindingGraph graph) {
+    public UniqueSubcomponentNamesGenerator(BindingGraph graph) {
       this.graph = graph;
       componentDescriptorsBySimpleName =
           Multimaps.index(
@@ -89,7 +89,7 @@ private UniqueSubcomponentNamesGenerator(BindingGraph graph) {
       componentQualifiedNamePieces = qualifiedNames(graph.componentDescriptors());
     }
 
-    private ImmutableBiMap<ComponentDescriptor, String> generate() {
+    public ImmutableBiMap<ComponentDescriptor, String> generate() {
       Map<ComponentDescriptor, String> subcomponentImplSimpleNames = new LinkedHashMap<>();
       for (Entry<String, Collection<ComponentDescriptor>> componentEntry :
           componentDescriptorsBySimpleName.asMap().entrySet()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java b/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java
index 53cefe955..216dbb9d2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java
@@ -1,6 +1,8 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableCollection;
+import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
@@ -18,28 +20,39 @@
  */
 public class DelegateInitialization implements InitializationStatement {
 
+    private ComponentDescriptor descriptor;
     private final BindingGraph graph;
 
-    public DelegateInitialization(BindingGraph graph) {
+    public DelegateInitialization(ComponentDescriptor descriptor, BindingGraph graph) {
+        this.descriptor = descriptor;
         this.graph = graph;
     }
 
     @Override
     public CodeBlock get() {
         final CodeBlock.Builder codeBuilder = CodeBlock.builder();
-        try {
-            HashMap<Key, String> delegateFieldNames = new HashMap<>();
-            for (ResolvedBindings resolvedBindings : graph.resolvedBindings().values()) {
+        final ImmutableCollection<ResolvedBindings> values = graph.resolvedBindings().values();
+        for (ResolvedBindings resolvedBindings : values) {
+            try {
+
+                if (resolvedBindings.ownedBindings().isEmpty()) {
+                    continue;
+                }
+
                 ContributionBinding binding = resolvedBindings.contributionBinding();
-                if (bindingSupportsTestDelegate(binding)) {
+                if (bindingSupportsTestDelegate(binding) && shouldCreateDelegate(binding)) {
                     final String delegateFieldName = Util.getDelegateFieldName(resolvedBindings.binding().key());
                     final ClassName delegateType = getDelegateTypeName(resolvedBindings.binding().key());
-                    delegateFieldNames.put(resolvedBindings.key(), delegateFieldName);
                     final String methodName = "with" + delegateType.simpleName();
-                    codeBuilder.add(".$L($L)", methodName, delegateFieldName);
+                    codeBuilder.add(".$L($L)\n", methodName, delegateFieldName);
                 }
+            } catch (Exception e) {
             }
-        }catch(Exception e) {}
+        }
         return codeBuilder.build();
     }
+
+    private boolean shouldCreateDelegate(ContributionBinding binding) {
+        return descriptor.kind() != ComponentDescriptor.Kind.SUBCOMPONENT || binding.requiresModuleInstance();
+    }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java b/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java
index de5feb9cc..10490d8a4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java
@@ -7,8 +7,18 @@
  */
 public class FinishBuilderStatement implements InitializationStatement{
 
+    private ComponentDescriptor descriptor;
+
+    public FinishBuilderStatement(ComponentDescriptor descriptor) {
+        this.descriptor = descriptor;
+    }
+
     @Override
     public CodeBlock get() {
-        return CodeBlock.of(".build()");
+        final CodeBlock.Builder builder = CodeBlock.builder();
+        if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            return (this.descriptor.builderSpec().isPresent()) ? builder.add(".build())\n").build() : builder.build();
+        }
+        return CodeBlock.of(".build())\n");
     }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
index b89dec567..a6dbf2a68 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
@@ -2,27 +2,27 @@
 
 import com.google.common.base.Optional;
 import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
 
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.*;
 import javax.lang.model.util.Elements;
+import java.io.IOException;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
-import java.util.function.Consumer;
-
-import static dagger.internal.codegen.Util.createDelegateFieldAndMethod;
 
 /**
  * Created by Andy on 05.05.2017.
  */
 public class InjectorGenerator extends SourceFileGenerator<DI>{
 
-    InjectorGenerator(Filer filer, Elements elements) {
+    private TestClassGenerator testClassGenerator;
+    private final TestRegistry registry;
+
+    InjectorGenerator(Filer filer, Elements elements, TestClassGenerator testClassGenerator, TestRegistry registry) {
         super(filer, elements);
+        this.testClassGenerator = testClassGenerator;
+        this.registry = registry;
     }
 
     @Override
@@ -58,4 +58,36 @@ ClassName nameGeneratedType(DI input) {
         return Optional.of(builder);
     }
 
+    @Override
+    void generate(DI input) throws SourceFileGenerationException {
+        final Optional<TypeSpec.Builder> builder = write(input.getClassName(), input);
+        try {
+            registry.addEncodedClass(input.getClassName(), buildJavaFile(input.getClassName(), builder.get()));
+            testClassGenerator.generate(registry);
+        } catch (IOException e) {
+            throw new IllegalStateException(e);
+        }
+
+    }
+
+    public static class Factory {
+
+        private final Filer filer;
+        private final Elements elements;
+        private final TestClassGenerator generator;
+        private TestRegistry registry;
+
+        public Factory(Filer filer, Elements elements, TestClassGenerator generator, TestRegistry registry) {
+            this.filer = filer;
+            this.elements = elements;
+            this.generator = generator;
+            this.registry = registry;
+        }
+
+        public InjectorGenerator create() {
+            return new InjectorGenerator(filer, elements, generator, registry);
+        }
+
+    }
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
index 9cd5e56e1..f70cff724 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
@@ -26,7 +26,7 @@
 
     private Types types;
     private final Messager messager;
-    private final InjectorGenerator injectorGenerator;
+    private final InjectorGenerator.Factory injectorGeneratorFactory;
     private final ComponentDescriptor.Kind component;
     private final BindingGraph.Factory bindingGraphFactory;
     private final ComponentDescriptor.Factory componentDescriptorFactory;
@@ -34,10 +34,10 @@
     private Map<TypeElement, ExecutableElement> moduleMethodMap;
     private Map<TypeElement, ExecutableElement> subcomponentMethodMap;
 
-    public InjectorProcessingStep(Types types, Messager messager, InjectorGenerator injectorGenerator, ComponentDescriptor.Kind component, BindingGraph.Factory bindingGraphFactory, ComponentDescriptor.Factory componentDescriptorFactory) {
+    public InjectorProcessingStep(Types types, Messager messager, InjectorGenerator.Factory injectorGeneratorFactory, ComponentDescriptor.Kind component, BindingGraph.Factory bindingGraphFactory, ComponentDescriptor.Factory componentDescriptorFactory) {
         this.types = types;
         this.messager = messager;
-        this.injectorGenerator = injectorGenerator;
+        this.injectorGeneratorFactory = injectorGeneratorFactory;
         this.component = component;
         this.bindingGraphFactory = bindingGraphFactory;
         this.componentDescriptorFactory = componentDescriptorFactory;
@@ -83,7 +83,7 @@ public InjectorProcessingStep(Types types, Messager messager, InjectorGenerator
             }
         }
         final DI di = new DI(injector, componentOverriderMap, injectorTypeList);
-        this.injectorGenerator.generate(di, messager);
+        this.injectorGeneratorFactory.create().generate(di, messager);
         return rejectedElements;
     }
 
@@ -104,7 +104,7 @@ private ProvidingMethodOverrider createOverrider(Element element, TypeElement in
         final TypeElement component = MoreTypes.asTypeElement(executableElement.getReturnType());
         final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
         final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
-        List<InitializationStatement> statements = this.createInitializationsStatements(injector, descriptor, null, this.moduleMethodMap, executableElement, bindingGraph);
+        List<InitializationStatement> statements = this.createInitializationsStatements(injector, descriptor, this.moduleMethodMap, executableElement, bindingGraph);
         final ProvidingMethodOverrider componentMethodOverrider = new ProvidingMethodOverrider(component, descriptor, executableElement, statements, bindingGraph);
         findSubcomponentsToOverride(injector, descriptor, componentMethodOverrider);
         return componentMethodOverrider;
@@ -120,7 +120,7 @@ private void findSubcomponentsToOverride(TypeElement injector, ComponentDescript
             final TypeElement subcomponentType = MoreTypes.asTypeElement(e.getReturnType());
             final BindingGraph bindingGraph = bindingGraphFactory.create(subcomponentDescriptor);
             List<InitializationStatement> s =
-                    this.createInitializationsStatements(injector, subcomponentDescriptor, descriptor, this.moduleMethodMap, e, bindingGraph);
+                    this.createInitializationsStatements(injector, subcomponentDescriptor, this.moduleMethodMap, e, bindingGraph);
             final ProvidingMethodOverrider subcomponentOverrider =
                     new ProvidingMethodOverrider(subcomponentType, subcomponentDescriptor, e, s, bindingGraph);
             componentMethodOverrider.add(subcomponentOverrider);
@@ -135,18 +135,19 @@ private void findSubcomponentsToOverride(TypeElement injector, ComponentDescript
 
     private List<InitializationStatement> createInitializationsStatements(TypeElement injector,
                                                                           ComponentDescriptor componentDescriptor,
-                                                                          ComponentDescriptor parentDescriptor,
                                                                           Map<TypeElement, ExecutableElement> moduleMethodMap,
                                                                           ExecutableElement providingMethod,
                                                                           BindingGraph bindingGraph) {
 
         Map<Key, VariableElement> providedParams = toParameterMap(providingMethod.getParameters());
+        BuilderModuleStatement builderModuleStatement =
+                new BuilderModuleStatement(this.types, injector, componentDescriptor, moduleMethodMap, providedParams);
         return ImmutableList.of(
-                new BuilderStatement(componentDescriptor, parentDescriptor, providingMethod),
+                new BuilderStatement(componentDescriptor, providingMethod, builderModuleStatement, bindingGraphFactory),
                 new ComponentStatement(this.types, injector, componentDescriptorFactory, componentDescriptor, providedParams),
                 new ModuleStatement(this.types, injector, componentDescriptor, moduleMethodMap, providedParams),
-                new DelegateInitialization(bindingGraph),
-                new FinishBuilderStatement()
+                new FinishBuilderStatement(componentDescriptor),
+                new DelegateInitialization(componentDescriptor, bindingGraph)
         );
     }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java b/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java
index c48ae0423..aea85d0b1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java
@@ -24,11 +24,11 @@
  */
 public class ModuleStatement implements InitializationStatement {
 
-    private Types types;
-    private TypeElement injector;
-    private ComponentDescriptor descriptor;
-    private Map<TypeElement, ExecutableElement> moduleMethodMap;
-    private Map<Key, VariableElement> providedParams;
+    protected Types types;
+    protected TypeElement injector;
+    protected ComponentDescriptor descriptor;
+    protected Map<TypeElement, ExecutableElement> moduleMethodMap;
+    protected Map<Key, VariableElement> providedParams;
 
     public ModuleStatement(Types types, TypeElement injector, ComponentDescriptor descriptor, Map<TypeElement, ExecutableElement> moduleMethodMap, Map<Key, VariableElement> providedParams) {
         Preconditions.checkNotNull(types, "types is null!");
@@ -47,6 +47,11 @@ public ModuleStatement(Types types, TypeElement injector, ComponentDescriptor de
     public CodeBlock get() {
         final CodeBlock.Builder codeBuilder = CodeBlock.builder();
         final ImmutableSet<ModuleDescriptor> modules = descriptor.modules();
+
+        if (isSubComponent() && !descriptor.builderSpec().isPresent()) {
+            return CodeBlock.builder().build();
+        }
+
         for (ModuleDescriptor moduleDescriptor : modules) {
             final TypeElement moduleElement = moduleDescriptor.moduleElement();
             final ExecutableElement method = moduleMethodMap.get(moduleElement);
@@ -77,13 +82,13 @@ public CodeBlock get() {
             }
 
             if (method != null) {
-                codeBuilder.add(".$L(this.$L($L))",
+                codeBuilder.add(".$L(this.$L($L))\n",
                         methodName,
                         method.getSimpleName().toString(),
                         makeParametersCodeBlock(arguments)
                 );
             }else {
-                codeBuilder.add(".$L(new $T($L))",
+                codeBuilder.add(".$L(new $T($L))\n",
                         methodName,
                         ClassName.get(moduleElement),
                         makeParametersCodeBlock(arguments)
@@ -93,6 +98,10 @@ public CodeBlock get() {
         return codeBuilder.build();
     }
 
+    private boolean isSubComponent() {
+        return descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT;
+    }
+
     private Map<Key, VariableElement> buildParameterMapWithProvidingModuleMethod(ExecutableElement providingModuleMethod) {
         return getMethodParameterMap(providingModuleMethod);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index dd451e97b..9fa5e740d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -17,18 +17,29 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.io.ByteStreams.toByteArray;
 
+import com.google.common.base.Charsets;
 import com.google.common.base.Optional;
 import com.google.common.base.Throwables;
-import com.squareup.javapoet.AnnotationSpec;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.JavaFile;
-import com.squareup.javapoet.TypeSpec;
+import com.google.common.io.ByteStreams;
+import com.google.common.io.CharStreams;
+import com.squareup.javapoet.*;
+import com.sun.org.apache.xml.internal.security.utils.Base64;
+
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
+import javax.tools.JavaFileObject;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.UUID;
 
 /**
  * A template class that provides a framework for properly handling IO while generating source files
@@ -74,7 +85,8 @@ void generate(T input) throws SourceFileGenerationException {
       return;
     }
     try {
-      buildJavaFile(generatedTypeName, type.get()).writeTo(filer);
+      final JavaFile javaFile = buildJavaFile(generatedTypeName, type.get());
+      javaFile.writeTo(filer);
     } catch (Exception e) {
       // if the code above threw a SFGE, use that
       Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
@@ -84,7 +96,7 @@ void generate(T input) throws SourceFileGenerationException {
     }
   }
 
-  private JavaFile buildJavaFile(
+  protected JavaFile buildJavaFile(
       ClassName generatedTypeName, TypeSpec.Builder typeSpecBuilder) {
     if (generatedAnnotationAvailable) {
       typeSpecBuilder.addAnnotation(GENERATED);
diff --git a/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java b/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
new file mode 100644
index 000000000..eba2a14fd
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
@@ -0,0 +1,52 @@
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.squareup.javapoet.*;
+import dagger.Trigger;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.util.Elements;
+import java.util.Iterator;
+import java.util.UUID;
+
+/**
+ * Created by Andy on 07.05.2017.
+ */
+public class TestClassGenerator extends SourceFileGenerator<TestRegistry> {
+
+    TestClassGenerator(Filer filer, Elements elements) {
+        super(filer, elements);
+    }
+
+    @Override
+    ClassName nameGeneratedType(TestRegistry input) {
+        return input.getClassName();
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(TestRegistry input) {
+        return Optional.absent();
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TestRegistry input) {
+        final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName);
+        final Iterator<TestRegistry.EncodedClass> it = input.iterator();
+        UniqueNameSet uniqueNameSet = new UniqueNameSet();
+        while(it.hasNext()) {
+            final TestRegistry.EncodedClass encodedClass = it.next();
+            final String randomString = UUID.randomUUID().toString().replace("-", "_");
+            final String randomMethodName = uniqueNameSet.getUniqueName("Method_" + randomString);
+            builder.addMethod(MethodSpec.methodBuilder(randomMethodName)
+                                .addAnnotation(AnnotationSpec.builder(Trigger.class)
+                                    .addMember("value", CodeBlock.of("$S", encodedClass.encoded))
+                                    .addMember("qualifiedName", CodeBlock.of("$S", encodedClass.qualifiedName))
+                                    .build())
+                                .build()
+            );
+        }
+        return Optional.of(builder);
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java b/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
new file mode 100644
index 000000000..f011a2f78
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
@@ -0,0 +1,54 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.JavaFile;
+import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException;
+import com.sun.org.apache.xml.internal.security.utils.Base64;
+
+import javax.tools.JavaFileObject;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import static com.google.common.io.ByteStreams.toByteArray;
+
+/**
+ * Created by Andy on 07.05.2017.
+ */
+public class TestRegistry {
+
+    private List<EncodedClass> encodedClasses = new ArrayList<>();
+
+    public void addEncodedClass(ClassName className, JavaFile javaFile) throws IOException {
+        final JavaFileObject javaFileObject = javaFile.toJavaFileObject();
+        final InputStream inputStream = javaFileObject.openInputStream();
+        final String encodedClass = Base64.encode(toByteArray(inputStream));
+        final String name = className.packageName() + "." + className.simpleName();
+        encodedClasses.add(new EncodedClass(name, encodedClass));
+    }
+
+    public ClassName getClassName() {
+        return ClassName.bestGuess("dagger.TestTrigger");
+    }
+
+    public Iterator<EncodedClass> iterator() {
+        return encodedClasses.iterator();
+    }
+
+    public byte[] decodeClass(String value) throws Base64DecodingException {
+        return Base64.decode(value);
+    }
+
+    public static class EncodedClass {
+
+        public EncodedClass(String qualifiedName, String encoded) {
+            this.qualifiedName = qualifiedName;
+            this.encoded = encoded;
+        }
+
+        public String qualifiedName;
+        public String encoded;
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/TriggerProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/TriggerProcessingStep.java
new file mode 100644
index 000000000..d3665ea4d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/TriggerProcessingStep.java
@@ -0,0 +1,64 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import com.squareup.javapoet.JavaFile;
+import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException;
+import dagger.Trigger;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.tools.JavaFileObject;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/**
+ * Created by Andy on 07.05.2017.
+ */
+public class TriggerProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+
+    private TestRegistry testRegistry;
+    private Filer filer;
+
+    public TriggerProcessingStep(TestRegistry testRegistry, Filer filer) {
+        this.testRegistry = testRegistry;
+        this.filer = filer;
+    }
+
+    @Override
+    public Set<? extends Class<? extends Annotation>> annotations() {
+        return ImmutableSet.of(Trigger.class);
+    }
+
+    @Override
+    public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> setMultimap) {
+        final Set<Element> elements = setMultimap.get(Trigger.class);
+        final List<ExecutableElement> executableElements = elements.stream()
+                .map(element -> (ExecutableElement) element)
+                .collect(Collectors.toList());
+
+        for (ExecutableElement executableElement : executableElements) {
+            final Trigger annotation = executableElement.getAnnotation(Trigger.class);
+            final String value = annotation.value();
+            try {
+                byte[] decodedClass = testRegistry.decodeClass(value);
+                final JavaFileObject sourceFile = filer.createSourceFile(annotation.qualifiedName());
+                final OutputStream os = sourceFile.openOutputStream();
+                os.write(decodedClass);
+                os.flush();
+                os.close();
+            } catch (Base64DecodingException e) {
+                e.printStackTrace();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        return ImmutableSet.of();
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index e208270cf..df0ade229 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -352,7 +352,6 @@ private Util() {}
 
   public static void createDelegateFieldAndMethod(ClassName generatedTypeName, TypeSpec.Builder classBuilder, ResolvedBindings resolvedBindings, Map<Key, String> delegateFieldNames) {
       try {
-          final FrameworkField contributionBindingField = FrameworkField.forResolvedBindings(resolvedBindings, Optional.absent());
           ContributionBinding binding = resolvedBindings.contributionBinding();
           if (bindingSupportsTestDelegate(binding)) {
               final String delegateFieldName = Util.getDelegateFieldName(resolvedBindings.binding().key());
diff --git a/core/src/main/java/dagger/Trigger.java b/core/src/main/java/dagger/Trigger.java
index db560fa89..dfe9b4411 100644
--- a/core/src/main/java/dagger/Trigger.java
+++ b/core/src/main/java/dagger/Trigger.java
@@ -9,7 +9,9 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 @Retention(RUNTIME)
-@Target(TYPE)
+@Target(METHOD)
 @Documented
 public @interface Trigger {
+    String value();
+    String qualifiedName();
 }
diff --git a/examples/simple/src/main/java/coffee/BModule.java b/examples/simple/src/main/java/coffee/BModule.java
index c7596af63..4973ccea3 100644
--- a/examples/simple/src/main/java/coffee/BModule.java
+++ b/examples/simple/src/main/java/coffee/BModule.java
@@ -9,9 +9,15 @@
 @Module
 public class BModule {
 
+    private final double A;
+
+    public BModule (double A) {
+        this.A = A;
+    }
+
     @Provides
     public Double aDouble() {
-        return 1.0;
+        return A;
     }
 
 }
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index 4afc9533f..bacd465ff 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -1,6 +1,7 @@
 package coffee;
 
 import dagger.Component;
+import dagger.Module;
 import dagger.ProvidesModule;
 import dagger.Subcomponent;
 
@@ -13,19 +14,14 @@
   public interface Coffee {
     CoffeeMaker maker();
     Thermosiphon thermosiphon();
-    Bleu.Builder any();
-    Bleu2.Builder bleu2();
+    Bleu plus(AModule module, BModule moduleB);
   }
 
   @ActivityScope
-  @Subcomponent(modules = {AModule.class})
+  @Subcomponent(modules = {AModule.class, BModule.class})
   public interface Bleu {
     Integer integer();
-    @Subcomponent.Builder
-    interface Builder {
-      Builder requestModule(AModule module);
-      Bleu build();
-    }
+    Bleu2.Builder someComponent();
   }
 
   @Subcomponent(modules = {BModule.class})
@@ -33,7 +29,7 @@
     CoffeeMaker dou();
     @Subcomponent.Builder
     interface Builder {
-      Builder requestModule(BModule module);
+      Bleu2.Builder someModule(BModule whaaat);
       Bleu2 build();
     }
   }
diff --git a/examples/simple/src/main/java/coffee/DependencyInjector.java b/examples/simple/src/main/java/coffee/DependencyInjector.java
index c137c29e6..861e52be2 100644
--- a/examples/simple/src/main/java/coffee/DependencyInjector.java
+++ b/examples/simple/src/main/java/coffee/DependencyInjector.java
@@ -17,16 +17,20 @@
     }
 
     @ProvidesSubcomponent
-    public CoffeeApp.Bleu bleu(CoffeeApp.Coffee coffee) {
-        return coffee.any()
-                .requestModule(new AModule())
-                .build();
+    public CoffeeApp.Bleu bleu(CoffeeApp.Coffee coffee, double d) {
+        return coffee.plus(new AModule(), new BModule(d));
     }
 
     @ProvidesSubcomponent
-    public CoffeeApp.Bleu2 bleu2(CoffeeApp.Coffee bleu) {
-        return bleu.bleu2()
-                .requestModule(new BModule())
+    public CoffeeApp.Bleu2 bleu2(CoffeeApp.Bleu bleu, double d) {
+        return bleu.someComponent()
+                .someModule(new BModule(d))
                 .build();
     }
+
+
+    @ProvidesModule
+    public BModule moduleB(double a) {
+        return new BModule(a);
+    }
 }
