diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index 7121ceb47..e11658151 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -54,7 +54,6 @@
 import static dagger.internal.codegen.Scopes.singletonScope;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
-import static dagger.model.BindingKind.INJECTION;
 import static java.util.function.Predicate.isEqual;
 import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.joining;
@@ -583,8 +582,9 @@ private String formatDependencyTrace() {
       protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
         if (atDependencyCycle()) {
           reportDependencyCycle();
+        } else {
+          super.visitDependencyRequest(dependencyRequest);
         }
-        super.visitDependencyRequest(dependencyRequest);
       }
 
       @Override
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/ComponentTreeTraverser.java
index 6d02accc7..5a19a67be 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -243,13 +243,12 @@ public void traverseDependencies() {
      * request. They should call the {@code super} implementation if they want to continue the
      * traversal in the standard order.
      *
-     * <p>This implementation calls {@link #visitResolvedBindings(ResolvedBindings)} unless the
-     * dependency request introduces a cycle.
+     * <p>This implementation calls {@link #visitResolvedBindings(ResolvedBindings)}.
      *
      * @param dependencyRequest the object returned by {@link #dependencyRequest()}
      */
     protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
-      if (visitedDependencyRequests.add(dependencyRequest) && !atDependencyCycle()) {
+      if (visitedDependencyRequests.add(dependencyRequest)) {
         visitResolvedBindings(resolvedBindingsPath.getLast());
       }
     }
@@ -373,13 +372,17 @@ protected void visitContributionBinding(
      *
      * <p>This implementation calls {@link #visitDependencyRequest(DependencyRequest)} for each
      * dependency of the binding, resolved within {@code owningComponent}, that has not already been
-     * visited while traversing the current entry point.
+     * visited while traversing the current entry point â€” unless the dependency request introduces a
+     * cycle.
      *
      * @param binding a value of {@code resolvedBindings().allBindings()}
      * @param owningComponent the key of {@code resolvedBindings().allBindings()} for {@code
      *     binding}. The binding's dependencies should be resolved within this component.
      */
     protected void visitBinding(Binding binding, ComponentDescriptor owningComponent) {
+      if (atDependencyCycle()) {
+        return;
+      }
       BindingGraph owningGraph = componentTreePath.graphForComponent(owningComponent);
       for (DependencyRequest dependency : binding.dependencies()) {
         nextDependencyRequest(dependency, owningGraph);
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 9202f2ddb..e880bba29 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -348,5 +348,10 @@ static ComponentNode create(ComponentPath componentPath) {
     /** The component represented by this node. */
     @Override
     public abstract ComponentPath componentPath();
+
+    @Override
+    public final String toString() {
+      return componentPath().toString();
+    }
   }
 }
diff --git a/javatests/dagger/internal/codegen/BUILD b/javatests/dagger/internal/codegen/BUILD
index 31925565d..19b68e8e5 100644
--- a/javatests/dagger/internal/codegen/BUILD
+++ b/javatests/dagger/internal/codegen/BUILD
@@ -34,7 +34,9 @@ GenJavaTests(
         "//java/dagger/internal/codegen:validation",
         "//java/dagger/internal/codegen:writing",
         "//java/dagger/model",
+        "//java/dagger/model/testing",
         "//java/dagger/producers",
+        "//java/dagger/spi",
         "//third_party:auto_common",
         "//third_party:auto_value",
         "//third_party:compile_testing",
diff --git a/javatests/dagger/internal/codegen/BindingGraphCapturer.java b/javatests/dagger/internal/codegen/BindingGraphCapturer.java
new file mode 100644
index 000000000..b06b504b0
--- /dev/null
+++ b/javatests/dagger/internal/codegen/BindingGraphCapturer.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableMap;
+import dagger.model.BindingGraph;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+
+/**
+ * A testing plugin that captures {@link dagger.model.BindingGraph}s for tests to make assertions
+ * about.
+ */
+// TODO(dpb): Move to dagger.spi.testing?
+final class BindingGraphCapturer implements BindingGraphPlugin {
+
+  private final ImmutableMap.Builder<String, BindingGraph> bindingGraphs = ImmutableMap.builder();
+
+  @Override
+  public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    bindingGraphs.put(bindingGraph.rootComponentNode().toString(), bindingGraph);
+  }
+
+  /** Returns a map of binding graphs, indexed by the canonical name of the root component type. */
+  public ImmutableMap<String, BindingGraph> bindingGraphs() {
+    return bindingGraphs.build();
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ModelTest.java b/javatests/dagger/internal/codegen/ModelTest.java
new file mode 100644
index 000000000..ee4cf47b7
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ModelTest.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static dagger.model.testing.BindingGraphSubject.assertThat;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.model.BindingGraph;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ModelTest {
+
+  @Test
+  public void cycleTest() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(B b) {}",
+            "}");
+    JavaFileObject b =
+        JavaFileObjects.forSourceLines(
+            "test.B",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class B {",
+            "  @Inject B(Provider<A> a) {}",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+
+    BindingGraphCapturer capturer = new BindingGraphCapturer();
+    Compilation compilation =
+        javac().withProcessors(ComponentProcessor.forTesting(capturer)).compile(a, b, component);
+    assertThat(compilation).succeeded();
+    BindingGraph bindingGraph = capturer.bindingGraphs().get("test.TestComponent");
+    assertThat(bindingGraph).bindingWithKey("test.A").dependsOnBindingWithKey("test.B");
+    assertThat(bindingGraph).bindingWithKey("test.B").dependsOnBindingWithKey("test.A");
+  }
+}
