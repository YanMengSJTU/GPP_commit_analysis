diff --git a/multibindings.md b/multibindings.md
new file mode 100644
index 000000000..6c5712c29
--- /dev/null
+++ b/multibindings.md
@@ -0,0 +1,417 @@
+# Multibindings
+
+
+Dagger allows you to bind several objects into a collection even when the
+objects are bound in different modules using mutlbindings. Dagger assembles the
+collection so that application code can inject it without depending directly on
+the individual bindings.
+
+You could use multibindings to implement a plugin architecture, for example,
+where several modules can contribute individual plugin interface implementations
+so that a central class can use the entire set of plugins. Or you could have
+several modules contribute individual service providers to a map, keyed by name.
+
+[TOC]
+
+## Set multibindings {#set-multibindings}
+
+In order to contribute one element to an injectable multibound set, add a method
+to a module that returns an element and is annotated with
+[`@Provides(type = SET)`][PTS]:
+
+```java
+@Module
+class MyModuleA {
+  @Provides(type = SET)
+  String provideOneString(DepA depA, DepB depB) {
+    return "ABC";
+  }
+}
+```
+
+You can also contribute several elements at one time by adding a module method
+that returns a subset and is annotated with
+[`@Provides(type = SET_VALUES)`][PTSV]:
+
+```java
+@Module
+class MyModuleB {
+  @Provides(type = SET_VALUES)
+  Set<String> provideSomeStrings(DepA depA, DepB depB) {
+    return new HashSet<Foo>(Arrays.asList("DEF", "GHI"));
+  }
+}
+```
+
+If no `type = SET` or `type = SET_VALUES` multibindings exist for a set, then
+depending on that set is an error. If you want to allow an empty set, then add a
+`type = SET_VALUES` method that returns an empty set.
+
+```java
+@Module
+class MyEmptySetModule {
+  @Provides(type = SET_VALUES)
+  Set<Foo> primeEmptyFooSet() {
+    return Collections.emptySet();
+  }
+}
+```
+
+Now a binding in that component can depend on the set:
+
+```java
+class Bar {
+  @Inject Bar(Set<Foo> foos) {
+    assert foos.contains("ABC");
+    assert foos.contains("DEF");
+    assert foos.contains("GHI");
+  }
+}
+```
+
+Or the component can provide the set:
+
+```java
+@Component(modules = {MyModuleA.class, MyModuleB.class})
+interface MyComponent {
+  Set<Foo> foos();
+}
+
+@Test void testMyComponent() {
+  MyComponent myComponent = DaggerMyComponent.create();
+  assertThat(myComponent.foos()).containsExactly("ABC", "DEF", "GHI");
+}
+```
+
+As with any other binding, in addition to depending on a multibound `Set<Foo>`,
+you can also depend on `Provider<Set<Foo>>` or `Lazy<Set<Foo>>`. You cannot,
+however, depend on `Set<Provider<Foo>>`.
+
+To contribute to a qualified multibound set, annotate each `@Provides` method
+with the qualifier:
+
+```java
+@Module
+class MyModuleC {
+  @Provides(type = SET)
+  @MyQualifier
+  Foo provideOneFoo(DepA depA, DepB depB) {
+    return new Foo(depA, depB);
+  }
+}
+
+@Module
+class MyModuleD {
+  @Provides
+  FooSetUser provideFooSetUser(@MyQualifier Set<Foo> foos) { … }
+}
+```
+
+## Map multibindings {#map-multibindings}
+
+Dagger lets you use multibindings to contribute entries to an injectable map as
+long as the map keys are known at compile time.
+
+To contribute an entry to a multibound map, add a method to a module that
+returns the value and is annotated with [`@Provides(type = MAP)`][PTM] and with
+another custom annotation that specifies the map key for that entry. To
+contribute an entry to a qualified multibound map, annotate each
+`@Provides(type = MAP)` method with the qualifier.
+
+Then you can inject either the map itself (`Map<K, V>`) or a map containing
+value providers (`Map<K, Provider<V>>`). The latter is useful when you don't
+want all of the values to be instantiated because you're going to extract one
+value at a time, or because you want to get a potentially new instance of each
+value each time you query the map.
+
+### Simple map keys
+
+For maps with keys that are strings, enums, classes, or boxed primitives, write
+an annotation type with one member whose type is the (unboxed if necessary) map
+key type, and annotate it with [`@MapKey`][MapKey]:
+
+```java
+enum MyEnum {
+  ABC, DEF;
+}
+
+@MapKey
+@interface MyEnumKey {
+  MyEnum value();
+}
+
+@MapKey
+@interface MyLongKey {
+  long value();
+}
+
+@MapKey
+@interface MyNumberClassKey {
+  Class<? extends Number> value();
+}
+
+@Module
+class MyModule {
+  @Provides(type = MAP)
+  @MyEnumKey(MyEnum.ABC)
+  String provideABCValue() {
+    return "value for ABC";
+  }
+
+  @Provides(type = MAP)
+  @MyLongKey(100L)
+  String provide100Value() {
+    return "value for 100";
+  }
+
+  @Provides(type = MAP)
+  @MyNumberClassKey(BigDecimal.class)
+  String provideBigDecimalValue() {
+    return "value for BigDecimal";
+  }
+}
+
+@Component(modules = MyModule.class)
+interface MyComponent {
+  Map<MyEnum, String> myEnumStringMap();
+  Map<Long, String> longStringMap();
+  Map<Class<? extends Number>, String> numberClassStringMap();
+}
+
+@Test void testMyComponent() {
+  MyComponent myComponent = DaggerMyComponent.create();
+  assertThat(myEnumStringMap.get(MyEnum.ABC)).isEqualTo("value for ABC");
+  assertThat(longStringMap.get(100L)).isEqualTo("value for 100");
+  assertThat(numberClassStringMap.get(BigDecimal.class))
+      .isEqualTo("value for BigDecimal");
+}
+```
+
+Your annotation's single member can be any valid annotation member type except
+for arrays, and can have any name.
+
+### Complex map keys
+
+If your map's key is more than can be expressed by a single annotation member,
+you can use the entire annotation as the map key by setting `@MapKey`'s
+`unwrapValue` to `false`. In that case, the annotation can have array members as
+well.
+
+```java
+@MapKey(unwrapValue = false)
+@interface MyKey {
+  String name();
+  Class<?> implementingClass();
+  int[] thresholds();
+}
+
+@Module
+class MyModule {
+  @Provides(type = MAP)
+  @MyKey(name = "abc", implementingClass = Abc.class, thresholds = {1, 5, 10})
+  String provideAbc1510Value() {
+    return "foo";
+  }
+}
+
+@Component(modules = MyModule.class)
+interface MyComponent {
+  Map<MyKey, String> myKeyStringMap();
+}
+```
+
+#### Using `@AutoAnnotation` to create annotation instances
+
+If your map uses complex keys, then you may need to create an instance of your
+`@MapKey` annotation at run-time to pass to the map's `get(Object)` method. The
+easiest way to do that is to use the `@AutoAnnotation` annotation to create a
+static method that instantiates your annotation. See
+`@AutoAnnotation`'s [documentation][AutoAnnotation] for more details.
+
+```java
+class MyComponentTest {
+  @Test void testMyComponent() {
+    MyComponent myComponent = DaggerMyComponent.create();
+    assertThat(myComponent.myKeyStringMap()
+        .get(createMyKey("abc", Abc.class, new int[] {1, 5, 10}))
+        .isEqualTo("foo");
+  }
+
+  @AutoAnnotation
+  static MyKey createMyKey(String name, Class<?> implementingClass, int[] thresholds) {
+    return new AutoAnnotation_MyComponentTest_createMyKey(name, implementingClass, thresholds);
+  }
+}
+```
+
+### Maps whose keys are not known at compile time
+
+Map multibindings work only if your map's keys are known at compile time and can
+be expressed in an annotation. If your map's keys don't fit in those
+constraints, then you cannot create a multibound map, but you can work around
+that by using set multibindings to bind a set of objects that you can then
+transform into a non-multibound map.
+
+```java
+@Module
+class MyModule {
+  @Provides(type = SET)
+  Map.Entry<Foo, Bar> entryOne(…) {
+    Foo key = …;
+    Bar value = …;
+    return new SimpleImmutableEntry(key, value);
+  }
+
+  @Provides(type = SET)
+  Map.Entry<Foo, Bar> entryTwo(…) {
+    Foo key = …;
+    Bar value = …;
+    return new SimpleImmutableEntry(key, value);
+  }
+}
+
+@Module
+class MyMapModule {
+  @Provides
+  Map<Foo, Bar> fooBarMap(Set<Map.Entry<Foo, Bar>> entries) {
+    Map<Foo, Bar> fooBarMap = new LinkedHashMap<>(entries.size());
+    for (Map.Entry<Foo, Bar> entry : entries) {
+      fooBarMap.put(entry.getKey(), entry.getValue());
+    }
+    return fooBarMap;
+  }
+}
+```
+
+Note that this technique does not give you the automatic binding of
+`Map<Foo, Provider<Bar>>` as well. If you want a map of providers, the
+`Map.Entry` objects in your multibound set should include the providers. Then
+your non-multibound map can have `Provider` values.
+
+```java
+@Module
+class MyModule {
+  @Provides(type = SET)
+  Map.Entry<Foo, Provider<Bar>> entry(Provider<BarSubclass> barSubclassProvider) {
+    Foo key = …;
+    return new SimpleImmutableEntry(key, barSubclassProvider);
+  }
+}
+
+@Module
+class MyProviderMapModule {
+  @Provides
+  Map<Foo, Provider<Bar>> fooBarProviderMap(Set<Map.Entry<Foo, Provider<Bar>>> entries) {
+    return …;
+  }
+}
+```
+
+## Inherited subcomponent multibindings
+
+A binding in a subcomponent can depend on a multibound set or map from its
+parent, just as it can depend on any other binding from its parent. But a
+subcomponent can *add* elements to multibound sets or maps that are bound in its
+parent as well, by simply including the appropriate `@Provides` methods in its
+modules.
+
+When that happens, the set or map is different depending on where it is
+injected. When it is injected into a binding defined on the subcomponent, then
+it has the values or entries defined by the subcomponent's multibindings as well
+as those defined by the parent component's multibindings. When it is injected
+into a binding defined on the parent component, it has only the values or
+entries defined there.
+
+```java
+@Component(modules = ParentModule.class)
+interface ParentComponent {
+  Set<String> strings();
+  Map<String, String> stringMap();
+  ChildComponent childComponent();
+}
+
+@Module
+class ParentModule {
+  @Provides(type = SET)
+  String string1() {
+    "parent string 1";
+  }
+
+  @Provides(type = SET)
+  String string2() {
+    "parent string 2";
+  }
+
+  @Provides(type = MAP)
+  @StringKey("a")
+  String stringA() {
+    "parent string A";
+  }
+
+  @Provides(type = MAP)
+  @StringKey("b")
+  String stringB() {
+    "parent string B";
+  }
+}
+
+@Subcomponent(modules = ChildModule.class)
+interface ChildComponent {
+  Set<String> strings();
+  Map<String, String> stringMap();
+}
+
+@Module
+class ChildModule {
+  @Provides(type = SET)
+  String string3() {
+    "child string 3";
+  }
+
+  @Provides(type = SET)
+  String string4() {
+    "child string 4";
+  }
+
+  @Provides(type = MAP)
+  @StringKey("c")
+  String stringC() {
+    "child string C";
+  }
+
+  @Provides(type = MAP)
+  @StringKey("d")
+  String stringD() {
+    "child string D";
+  }
+}
+
+@Test void testMultibindings() {
+  ParentComponent parentComponent = DaggerParentComponent.create();
+  assertThat(parentComponent.strings()).containsExactly(
+      "parent string 1", "parent string 2");
+  assertThat(parentComponent.stringMap().keySet()).containsExactly("a", "b");
+
+  ChildComponent childComponent = parentComponent.childComponent();
+  assertThat(childComponent.strings()).containsExactly(
+      "parent string 1", "parent string 2", "child string 3", "child string 4");
+  assertThat(childComponent.stringMap().keySet()).containsExactly(
+      "a", "b", "c", "d");
+}
+```
+
+<!-- references & footnotes -->
+
+[^AutoAnnotation]:
+    You can use [`@AutoAnnotation`][AutoAnnotation] to create annotation
+    instances to pass to the map's `get(Object)` method.
+
+[PTS]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#SET
+
+[PTS]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#SET_VALUES
+
+[PTM]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#MAP
+
+[AutoAnnotation]: https://github.com/google/auto/blob/master/value/src/main/java/com/google/auto/value/AutoAnnotation.java
+
+[MapKey]: http://google.github.io/dagger/api/latest/dagger/MapKey.html
diff --git a/sitemap.md b/sitemap.md
new file mode 100644
index 000000000..1d563c291
--- /dev/null
+++ b/sitemap.md
@@ -0,0 +1,7 @@
+ * [Home](index.md)
+ * [User's Guide](users-guide.md)
+   * [Multibindings](multibindings.md)
+   * [Migrating from Dagger 1](dagger-1-migration.md)
+   * [Producers](producers.md)
+ * [Overview](overview.md)
+ * [Disambiguation](disambiguation.md)
diff --git a/users-guide.md b/users-guide.md
new file mode 100644
index 000000000..b15697ff3
--- /dev/null
+++ b/users-guide.md
@@ -0,0 +1,455 @@
+---
+layout: default
+title: User's Guide
+---
+
+# User's Guide
+
+
+The best classes in any application are the ones that do stuff: the
+`BarcodeDecoder`, the `KoopaPhysicsEngine`, and the `AudioStreamer`. These
+classes have dependencies; perhaps a `BarcodeCameraFinder`,
+`DefaultPhysicsEngine`, and an `HttpStreamer`.
+
+To contrast, the worst classes in any application are the ones that take up
+space without doing much at all: the `BarcodeDecoderFactory`, the
+`CameraServiceLoader`, and the `MutableContextWrapper`. These classes are the
+clumsy duct tape that wires the interesting stuff together.
+
+Dagger is a replacement for these `FactoryFactory` classes that implements the
+[dependency injection][DI] design pattern without the burden of writing the
+boilerplate. It allows you to focus on the interesting classes. Declare
+dependencies, specify how to satisfy them, and ship your app.
+
+By building on standard
+[`javax.inject`](http://docs.oracle.com/javaee/7/api/javax/inject/package-summary.html)
+annotations ([JSR 330](https://jcp.org/en/jsr/detail?id=330)), each class is
+**easy to test**. You don't need a bunch of boilerplate just to swap the
+`RpcCreditCardService` out for a `FakeCreditCardService`.
+
+Dependency injection isn't just for testing. It also makes it easy to create
+**reusable, interchangeable modules**. You can share the same
+`AuthenticationModule` across all of your apps. And you can run
+`DevLoggingModule` during development and `ProdLoggingModule` in production to
+get the right behavior in each situation.
+
+## Why Dagger 2 is Different
+
+[Dependency injection][DI] frameworks have existed for years with a whole
+variety of APIs for configuring and injecting.  So, why reinvent the wheel?
+Dagger 2 is the first to **implement the full stack with generated code**. The
+guiding principle is to generate code that mimics the code that a user might
+have hand-written to ensure that dependency injection is a simple, traceable and
+performant as it can be. For more background on the design, watch
+[this talk](https://www.youtube.com/watch?v=oK_XtfXPkqw)
+([slides](https://docs.google.com/presentation/d/1fby5VeGU9CN8zjw4lAb2QPPsKRxx6mSwCe9q7ECNSJQ/pub?start=false&loop=false&delayms=3000))
+by [+Gregory Kick](https://google.com/+GregoryKick/).
+
+## Using Dagger We'll demonstrate dependency injection and Dagger by building a
+coffee maker. For complete sample code that you can compile and run, see
+Dagger's
+[coffee example](https://github.com/google/dagger/tree/master/examples/simple/src/main/java/coffee).
+
+### Declaring Dependencies
+
+Dagger constructs instances of your application classes and satisfies their
+dependencies. It uses the
+[`javax.inject.Inject`](http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html)
+annotation to identify which constructors and fields it is interested in.
+
+Use `@Inject` to annotate the constructor that Dagger should use to create
+instances of a class. When a new instance is requested, Dagger will obtain the
+required parameters values and invoke this constructor.
+
+```java
+class Thermosiphon implements Pump {
+  private final Heater heater;
+
+  @Inject
+  Thermosiphon(Heater heater) {
+    this.heater = heater;
+  }
+
+  ...
+}
+```
+
+Dagger can inject fields directly. In this example it obtains a `Heater`
+instance for the `heater` field and a `Pump` instance for the `pump` field.
+
+```java
+class CoffeeMaker {
+  @Inject Heater heater;
+  @Inject Pump pump;
+
+  ...
+}
+```
+
+If your class has `@Inject`-annotated fields but no `@Inject`-annotated
+constructor, Dagger will inject those fields if requested, but will not create
+new instances. Add a no-argument constructor with the `@Inject` annotation to
+indicate that Dagger may create instances as well.
+
+Dagger also supports method injection, though constructor or field injection are
+typically preferred.
+
+Classes that lack `@Inject` annotations cannot be constructed by Dagger.
+
+### Satisfying Dependencies
+
+By default, Dagger satisfies each dependency by constructing an instance of the
+requested type as described above. When you request a `CoffeeMaker`, it'll
+obtain one by calling `new CoffeeMaker()` and setting its injectable fields.
+
+But `@Inject` doesn't work everywhere:
+
+  * Interfaces can't be constructed.
+  * Third-party classes can't be annotated.
+  * Configurable objects must be configured!
+
+For these cases where `@Inject` is insufficient or awkward, use an
+[`@Provides`][Provides]-annotated method to satisfy a dependency. The method's
+return type defines which dependency it satisfies.
+
+For example, `provideHeater()` is invoked whenever a `Heater` is required:
+
+```java
+@Provides Heater provideHeater() {
+  return new ElectricHeater();
+}
+```
+
+It's possible for `@Provides` methods to have dependencies of their own. This
+one returns a `Thermosiphon` whenever a `Pump` is required:
+
+```java
+@Provides Pump providePump(Thermosiphon pump) {
+  return pump;
+}
+```
+
+All `@Provides` methods must belong to a module. These are just classes that
+have an [`@Module`][Module] annotation.
+
+```java
+@Module
+class DripCoffeeModule {
+  @Provides Heater provideHeater() {
+    return new ElectricHeater();
+  }
+
+  @Provides Pump providePump(Thermosiphon pump) {
+    return pump;
+  }
+}
+```
+
+By convention, `@Provides` methods are named with a `provide` prefix and module classes are named with a `Module` suffix.
+
+### Building the Graph
+
+The `@Inject` and `@Provides`-annotated classes form a graph of objects, linked
+by their dependencies. Calling code like an application's `main` method or an
+Android
+[`Application`](http://developer.android.com/reference/android/app/Application.html)
+accesses that graph via a well-defined set of roots. In Dagger 2, that set is
+defined by an interface with methods that have no arguments and return the
+desired type. By applying the [`@Component`][Component] annotation to such an
+interface and passing the [module][Module] types to the `modules` parameter,
+Dagger 2 then fully generates an implementation of that contract.
+
+```java
+@Component(modules = DripCoffeeModule.class)
+interface CoffeeShop {
+  CoffeeMaker maker();
+}
+```
+
+The implementation has the same name as the interface prefixed with `Dagger`.
+Obtain an instance by invoking the `builder()` method on that implementation and
+use the returned [builder](http://en.wikipedia.org/wiki/Builder_pattern) to set
+dependencies and `build()` a new instance.
+
+```java
+CoffeeShop coffeeShop = DaggerCoffeeShop.builder()
+    .dripCoffeeModule(new DripCoffeeModule())
+    .build();
+```
+
+Any module with an accessible default constructor can be elided as the builder
+will construct an instance automatically if none is set.  If all dependencies
+can be constructed in that manner, the generated implementation will also have a
+`create()` method that can be used to get a new instance without having to deal
+with the builder.
+
+```java
+CoffeeShop coffeeShop = DaggerCoffeeShop.create();
+```
+
+Now, our `CoffeeApp` can simply use the Dagger-generated implementation of
+`CoffeeShop` to get a fully-injected `CoffeeMaker`.
+
+```java
+public class CoffeeApp {
+  public static void main(String[] args) {
+    CoffeeShop coffeeShop = DaggerCoffeeShop.create();
+    coffeeShop.maker().brew();
+  }
+}
+```
+
+Now that the graph is constructed and the entry point is injected, we run our
+coffee maker app. Fun.
+
+```
+$ java -cp ... coffee.CoffeeApp
+~ ~ ~ heating ~ ~ ~
+=> => pumping => =>
+ [_]P coffee! [_]P
+```
+
+### Singletons and Scoped Bindings
+
+Annotate an `@Provides` method or injectable class with
+[`@Singleton`][Singleton]. The graph will use a single instance of the value for
+all of its clients.
+
+```java
+@Provides @Singleton Heater provideHeater() {
+  return new ElectricHeater();
+}
+```
+
+The `@Singleton` annotation on an injectable class also serves as
+[documentation](http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Documented.html). It
+reminds potential maintainers that this class may be shared by multiple threads.
+
+```java
+@Singleton
+class CoffeeMaker {
+  ...
+}
+```
+
+Since Dagger 2 associates scoped instances in the graph with instances of
+component implementations, the components themselves need to declare which scope
+they intend to represent. For example, it wouldn't make any sense to have a
+`@Singleton` binding and a `@RequestScoped` binding in the same component
+because those scopes have different lifecycles and thus must live in components
+with different lifecycles. To declare that a component is associated with a
+given scope, simply apply the scope annotation to the component interface.
+
+```java
+@Component(modules = DripCoffeeModule.class)
+@Singleton
+interface CoffeeShop {
+  CoffeeMaker maker();
+}
+```
+
+### Lazy injections
+
+Sometimes you need an object to be instantiated lazily.  For any binding `T`,
+you can create a [`Lazy<T>`][Lazy] which defers instantiation until the first
+call to `Lazy<T>`'s `get()` method. If `T` is a singleton, then `Lazy<T>` will
+be the same instance for all injections within the `ObjectGraph`.  Otherwise,
+each injection site will get its own `Lazy<T>` instance.  Regardless, subsequent
+calls to any given instance of `Lazy<T>` will return the same underlying
+instance of `T`.
+
+```java
+class GridingCoffeeMaker {
+  @Inject Lazy<Grinder> lazyGrinder;
+
+  public void brew() {
+    while (needsGrinding()) {
+      // Grinder created once on first call to .get() and cached.
+      lazyGrinder.get().grind();
+    }
+  }
+}
+```
+
+### Provider injections
+
+Sometimes you need multiple instances to be returned instead of just injecting a
+single value.  While you have several options (Factories, Builders, etc.), one
+option is to inject a [`Provider<T>`][Provider] instead of just `T`.  A
+`Provider<T>` invokes the _binding logic_ for `T` each time `.get()` is called.
+If that binding logic is an `@Inject` constructor, a new instance will be
+created, but a `@Provides` method has no such guarantee.
+
+```java
+class BigCoffeeMaker {
+  @Inject Provider<Filter> filterProvider;
+
+  public void brew(int numberOfPots) {
+  ...
+    for (int p = 0; p < numberOfPots; p++) {
+      maker.addFilter(filterProvider.get()); //new filter every time.
+      maker.addCoffee(...);
+      maker.percolate();
+      ...
+    }
+  }
+}
+```
+
+***Note:*** Injecting `Provider<T>` has the possibility of creating confusing
+   code, and may be a design smell of mis-scoped or mis-structured objects in
+   your graph.  Often you will want to use a
+   [factory](http://en.wikipedia.org/wiki/Factory_(object-oriented_programming))
+   or a `Lazy<T>` or re-organize the lifetimes and structure of your code to be
+   able to just inject a `T`.  Injecting `Provider<T>` can, however, be a life
+   saver in some cases.  A common use is when you must use a legacy architecture
+   that doesn't line up with your object's natural lifetimes (e.g. servlets are
+   singletons by design, but only are valid in the context of request-specfic
+   data).
+
+### Qualifiers
+
+Sometimes the type alone is insufficient to identify a dependency. For example,
+a sophisticated coffee maker app may want separate heaters for the water and the
+hot plate.
+
+In this case, we add a **qualifier annotation**. This is any annotation that
+itself has a [`@Qualifier`][Qualifier] annotation. Here's the declaration of
+[`@Named`][Named], a qualifier annotation included in `javax.inject`:
+
+```java
+@Qualifier
+@Documented
+@Retention(RUNTIME)
+public @interface Named {
+  String value() default "";
+}
+```
+
+You can create your own qualifier annotations, or just use `@Named`. Apply
+qualifiers by annotating the field or parameter of interest. The type and
+qualifier annotation will both be used to identify the dependency.
+
+```java
+class ExpensiveCoffeeMaker {
+  @Inject @Named("water") Heater waterHeater;
+  @Inject @Named("hot plate") Heater hotPlateHeater;
+  ...
+}
+```
+
+Supply qualified values by annotating the corresponding `@Provides` method.
+
+```java
+@Provides @Named("hot plate") Heater provideHotPlateHeater() {
+  return new ElectricHeater(70);
+}
+
+@Provides @Named("water") Heater provideWaterHeater() {
+  return new ElectricHeater(93);
+}
+```
+
+Dependencies may not have multiple qualifier annotations.
+
+### Compile-time Validation
+
+The Dagger
+[annotation processor](http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html)
+is strict and will cause a compiler error if any bindings are invalid or
+incomplete. For example, this module is installed in a component, which is
+missing a binding for `Executor`:
+
+```java
+@Module
+class DripCoffeeModule {
+  @Provides Heater provideHeater(Executor executor) {
+    return new CpuHeater(executor);
+  }
+}
+```
+
+When compiling it, `javac` rejects the missing binding:
+
+```
+[ERROR] COMPILATION ERROR :
+[ERROR] error: java.util.concurrent.Executor cannot be provided without an @Provides-annotated method.
+```
+
+Fix the problem by adding an `@Provides`-annotated method for `Executor` to
+_any_ of the modules in the component.  While `@Inject`, `@Module` and
+`@Provides` annotations are validated individually, all validation of the
+relationship between bindings happens at the `@Component` level.  Dagger 1
+relied strictly on `@Module`-level validation (which may or may not have
+reflected runtime behavior), but Dagger 2 elides such validation (and the
+accompanying configuration parameters on `@Module`) in favor of full graph
+validation.
+
+### Compile-time Code Generation
+
+Dagger's annotation processor may also generate source files with names like
+`CoffeeMaker$$Factory.java` or `CoffeeMaker$$MembersInjector.java`. These files
+are Dagger implementation details. You shouldn't need to use them directly,
+though they can be handy when step-debugging through an injection.
+
+## Using Dagger In Your Build
+
+You will need to include the `dagger-{{site.dagger.version}}.jar` in your
+application's runtime.  In order to activate code generation you will need to
+include `dagger-compiler-{{site.dagger.version}}.jar` in your build at compile
+time.
+
+In a Maven project, one would include the runtime in the dependencies section of
+your `pom.xml`, and the `dagger-compiler` artifact as a dependency of the
+compiler plugin:
+
+```xml
+<dependencies>
+  <dependency>
+    <groupId>{{site.dagger.groupId}}</groupId>
+    <artifactId>dagger</artifactId>
+    <version>{{site.dagger.version}}</version>
+  </dependency>
+  <dependency>
+    <groupId>{{site.dagger.groupId}}</groupId>
+    <artifactId>dagger-compiler</artifactId>
+    <version>{{site.dagger.version}}</version>
+    <optional>true</optional>
+  </dependency>
+</dependencies>
+```
+
+## License
+
+```
+Copyright 2014 Google, Inc.
+Copyright 2012 Square, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+```
+
+[DI]: <http://en.wikipedia.org/wiki/Dependency_injection>
+
+[Component]: </api/latest/dagger/Component.html>
+[Lazy]: </api/latest/dagger/Lazy.html>
+[Module]: </api/latest/dagger/Module.html>
+[Provides]: </api/latest/dagger/Provides.html>
+
+
+
+
+[Named]: <http://docs.oracle.com/javaee/7/api/javax/inject/Named.html>
+[Provider]: <http://docs.oracle.com/javaee/7/api/javax/inject/Provider.html>
+[Qualifier]: <http://docs.oracle.com/javaee/7/api/javax/inject/Qualifier.html>
+[Scope]: <http://docs.oracle.com/javaee/7/api/javax/inject/Scope.html>
+[Singleton]: <http://docs.oracle.com/javaee/7/api/javax/inject/Singleton.html>
