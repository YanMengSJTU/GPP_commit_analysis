diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index b8ec1e251..cc13efa02 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -126,7 +126,7 @@ public SourceVersion getSupportedSourceVersion() {
     ComponentGenerator componentGenerator =
         new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
     ProducerFactoryGenerator producerFactoryGenerator =
-        new ProducerFactoryGenerator(filer, elements, compilerOptions);
+        new ProducerFactoryGenerator(filer, elements, types, compilerOptions);
     MonitoringModuleGenerator monitoringModuleGenerator =
         new MonitoringModuleGenerator(filer, elements);
     ProductionExecutorModuleGenerator productionExecutorModuleGenerator =
diff --git a/java/dagger/internal/codegen/FactoryGenerator.java b/java/dagger/internal/codegen/FactoryGenerator.java
index fe0fec709..8cfe3d889 100644
--- a/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/java/dagger/internal/codegen/FactoryGenerator.java
@@ -28,6 +28,7 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
+import static dagger.internal.codegen.MapKeys.mapKeyFactoryMethod;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkFieldUsages;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
@@ -272,8 +273,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     }
 
     ProvisionMethod.create(binding).ifPresent(factoryBuilder::addMethod);
-
     gwtIncompatibleAnnotation(binding).ifPresent(factoryBuilder::addAnnotation);
+    mapKeyFactoryMethod(binding, types).ifPresent(factoryBuilder::addMethod);
 
     return Optional.of(factoryBuilder);
   }
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index 3cad7ee2d..f5ddfb423 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -459,7 +459,7 @@ private CodeBlock factoryForMapMultibindingInitialization(ContributionBinding bi
               getDependencyExpression(frameworkDependency));
       codeBlocks.add(
           CodeBlock.of(
-              ".put($L, $L)", getMapKeyExpression(contributionBinding.mapKey().get()), value));
+              ".put($L, $L)", getMapKeyExpression(contributionBinding, componentName), value));
     }
     codeBlocks.add(CodeBlock.of(".build()"));
 
diff --git a/java/dagger/internal/codegen/Key.java b/java/dagger/internal/codegen/Key.java
index 4871e4b30..9deac5626 100644
--- a/java/dagger/internal/codegen/Key.java
+++ b/java/dagger/internal/codegen/Key.java
@@ -25,7 +25,7 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
-import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
+import static dagger.internal.codegen.MapKeys.mapKeyType;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
 import static dagger.internal.codegen.Optionals.firstPresent;
@@ -460,11 +460,10 @@ private TypeMirror bindingMethodKeyType(
         case SET:
           return setOf(returnType);
         case MAP:
-          if (frameworkType.isPresent()) {
-            return mapOfFrameworkType(mapKeyType(method), frameworkType.get(), returnType);
-          } else {
-            return mapOf(mapKeyType(method), returnType);
-          }
+          TypeMirror mapKeyType = mapKeyType(getMapKey(method).get(), types);
+          return frameworkType.isPresent()
+              ? mapOfFrameworkType(mapKeyType, frameworkType.get(), returnType)
+              : mapOf(mapKeyType, returnType);
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(SetType.isSet(returnType));
@@ -488,13 +487,6 @@ Key forDelegateBinding(
           : delegateDeclaration.key();
     }
 
-    private TypeMirror mapKeyType(ExecutableElement method) {
-      AnnotationMirror mapKeyAnnotation = getMapKey(method).get();
-      return MapKeys.unwrapValue(mapKeyAnnotation).isPresent()
-          ? getUnwrappedMapKeyType(mapKeyAnnotation.getAnnotationType(), types)
-          : mapKeyAnnotation.getAnnotationType();
-    }
-
     private Key forMethod(ExecutableElement method, TypeMirror keyType) {
       return forQualifiedType(getQualifier(method), keyType);
     }
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index 8e5746c19..eba95111b 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -110,7 +110,7 @@ CodeBlock getInstanceDependencyExpression(
   private CodeBlock keyAndValueExpression(DependencyRequest dependency, ClassName requestingClass) {
     return CodeBlock.of(
         "$L, $L",
-        getMapKeyExpression(dependencies.get(dependency).mapKey().get()),
+        getMapKeyExpression(dependencies.get(dependency), requestingClass),
         componentBindingExpressions.getDependencyExpression(dependency, requestingClass));
   }
 
diff --git a/java/dagger/internal/codegen/MapKeyAccessibility.java b/java/dagger/internal/codegen/MapKeyAccessibility.java
new file mode 100644
index 000000000..fe52e3bb3
--- /dev/null
+++ b/java/dagger/internal/codegen/MapKeyAccessibility.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.function.Predicate;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleAnnotationValueVisitor8;
+
+final class MapKeyAccessibility extends SimpleAnnotationValueVisitor8<Boolean, Void> {
+  private final Predicate<TypeMirror> accessibilityChecker;
+
+  private MapKeyAccessibility(Predicate<TypeMirror> accessibilityChecker) {
+    this.accessibilityChecker = accessibilityChecker;
+  }
+
+  @Override
+  public Boolean visitAnnotation(AnnotationMirror annotation, Void aVoid) {
+    // The annotation type is not checked, as the generated code will refer to the @AutoAnnotation
+    // generated type which is always public
+    return visitValues(annotation.getElementValues().values());
+  }
+
+  @Override
+  public Boolean visitArray(List<? extends AnnotationValue> values, Void aVoid) {
+    return visitValues(values);
+  }
+
+  private boolean visitValues(Collection<? extends AnnotationValue> values) {
+    return values.stream().allMatch(value -> value.accept(this, null));
+  }
+
+  @Override
+  public Boolean visitEnumConstant(VariableElement enumConstant, Void aVoid) {
+    return accessibilityChecker.test(enumConstant.getEnclosingElement().asType());
+  }
+
+  @Override
+  public Boolean visitType(TypeMirror type, Void aVoid) {
+    return accessibilityChecker.test(type);
+  }
+
+  @Override
+  protected Boolean defaultAction(Object o, Void aVoid) {
+    return true;
+  }
+
+  static boolean isMapKeyAccessibleFrom(AnnotationMirror annotation, String accessingPackage) {
+    return new MapKeyAccessibility(type -> isTypeAccessibleFrom(type, accessingPackage))
+        .visitAnnotation(annotation, null);
+  }
+
+  static boolean isMapKeyPubliclyAccessible(AnnotationMirror annotation) {
+    return new MapKeyAccessibility(Accessibility::isTypePubliclyAccessible)
+        .visitAnnotation(annotation, null);
+  }
+}
diff --git a/java/dagger/internal/codegen/MapKeys.java b/java/dagger/internal/codegen/MapKeys.java
index 3db146551..ad7e5e62a 100644
--- a/java/dagger/internal/codegen/MapKeys.java
+++ b/java/dagger/internal/codegen/MapKeys.java
@@ -20,11 +20,19 @@
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static dagger.internal.codegen.MapKeyAccessibility.isMapKeyPubliclyAccessible;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
 import dagger.MapKey;
 import java.util.NoSuchElementException;
 import java.util.Optional;
@@ -81,6 +89,12 @@
         : Optional.empty();
   }
 
+  static TypeMirror mapKeyType(AnnotationMirror mapKeyAnnotation, Types types) {
+    return unwrapValue(mapKeyAnnotation).isPresent()
+        ? getUnwrappedMapKeyType(mapKeyAnnotation.getAnnotationType(), types)
+        : mapKeyAnnotation.getAnnotationType();
+  }
+
   /**
    * Returns the map key type for an unwrapped {@link MapKey} annotation type. If the single member
    * type is primitive, returns the boxed type.
@@ -89,7 +103,7 @@
    *     has more than one member, or if its single member is an array
    * @throws NoSuchElementException if the annotation has no members
    */
-  public static DeclaredType getUnwrappedMapKeyType(
+  static DeclaredType getUnwrappedMapKeyType(
       final DeclaredType mapKeyAnnotationType, final Types types) {
     checkArgument(
         MoreTypes.asTypeElement(mapKeyAnnotationType).getKind() == ElementKind.ANNOTATION_TYPE,
@@ -122,15 +136,35 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
   }
 
   /**
-   * Returns a code block for the map key specified by the {@link MapKey} annotation on
-   * {@code bindingElement}.
+   * Returns a code block for {@code binding}'s {@link ContributionBinding#mapKey() map key}. If for
+   * whatever reason the map key is not accessible from within {@code requestingClass} (i.e. it has
+   * a package-private {@code enum} from a different package), this will return an invocation of a
+   * proxy-method giving it access.
+   *
+   * @throws IllegalStateException if {@code binding} is not a {@link dagger.multibindings.IntoMap
+   *     map} contribution.
+   */
+  static CodeBlock getMapKeyExpression(ContributionBinding binding, ClassName requestingClass) {
+    AnnotationMirror mapKeyAnnotation = binding.mapKey().get();
+    return MapKeyAccessibility.isMapKeyAccessibleFrom(
+            mapKeyAnnotation, requestingClass.packageName())
+        ? directMapKeyExpression(mapKeyAnnotation)
+        : CodeBlock.of("$T.mapKey()", generatedClassNameForBinding(binding));
+  }
+
+  /**
+   * Returns a code block for the map key annotation {@code mapKey}.
+   *
+   * <p>This method assumes the map key will be accessible in the context that the returned {@link
+   * CodeBlock} is used. Use {@link #getMapKeyExpression(ContributionBinding, ClassName)} when that
+   * assumption is not guaranteed.
    *
    * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
    *     annotation
    * @throws IllegalStateException if {@code bindingElement} is not annotated with a {@code MapKey}
    *     annotation
    */
-  static CodeBlock getMapKeyExpression(AnnotationMirror mapKey) {
+  private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
     Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
     AnnotationExpression annotationExpression = new AnnotationExpression(mapKey);
     if (unwrappedValue.isPresent()) {
@@ -142,5 +176,22 @@ static CodeBlock getMapKeyExpression(AnnotationMirror mapKey) {
     }
   }
 
+  /**
+   * A {@code static mapKey()} method to be added to generated factories when the {@code @MapKey}
+   * annotation is not publicly accessible.
+   */
+  static Optional<MethodSpec> mapKeyFactoryMethod(ContributionBinding binding, Types types) {
+    return binding
+        .mapKey()
+        .filter(mapKey -> !isMapKeyPubliclyAccessible(mapKey))
+        .map(
+            mapKey ->
+                methodBuilder("mapKey")
+                    .addModifiers(PUBLIC, STATIC)
+                    .returns(TypeName.get(mapKeyType(mapKey, types)))
+                    .addStatement("return $L", directMapKeyExpression(mapKey))
+                    .build());
+  }
+
   private MapKeys() {}
 }
diff --git a/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 7b9f0e059..fc38de52a 100644
--- a/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -24,6 +24,7 @@
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
+import static dagger.internal.codegen.MapKeys.mapKeyFactoryMethod;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
@@ -63,6 +64,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * Generates {@link Producer} implementations from {@link ProductionBinding} instances.
@@ -71,10 +73,13 @@
  * @since 2.0
  */
 final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
+  private final Types types;
   private final CompilerOptions compilerOptions;
 
-  ProducerFactoryGenerator(Filer filer, Elements elements, CompilerOptions compilerOptions) {
+  ProducerFactoryGenerator(
+      Filer filer, Elements elements, Types types, CompilerOptions compilerOptions) {
     super(filer, elements);
+    this.types = types;
     this.compilerOptions = compilerOptions;
   }
 
@@ -208,6 +213,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     factoryBuilder.addMethod(executeMethodBuilder.build());
 
     gwtIncompatibleAnnotation(binding).ifPresent(factoryBuilder::addAnnotation);
+    mapKeyFactoryMethod(binding, types).ifPresent(factoryBuilder::addMethod);
 
     // TODO(gak): write a sensible toString
     return Optional.of(factoryBuilder);
diff --git a/javatests/dagger/internal/codegen/Compilers.java b/javatests/dagger/internal/codegen/Compilers.java
index 3eee251f3..70756c247 100644
--- a/javatests/dagger/internal/codegen/Compilers.java
+++ b/javatests/dagger/internal/codegen/Compilers.java
@@ -21,6 +21,7 @@
 import static com.google.testing.compile.Compiler.javac;
 import static java.util.stream.Collectors.joining;
 
+import com.google.auto.value.processor.AutoAnnotationProcessor;
 import com.google.common.base.Splitter;
 import com.google.testing.compile.Compiler;
 
@@ -29,7 +30,7 @@
 
   /** Returns a compiler that runs the Dagger processor. */
   static Compiler daggerCompiler() {
-    return javac().withProcessors(new ComponentProcessor());
+    return javac().withProcessors(new ComponentProcessor(), new AutoAnnotationProcessor());
   }
 
   static Compiler daggerCompilerWithoutGuava() {
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index cc22bae84..bef33ed50 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -17,12 +17,15 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.auto.value.processor.AutoAnnotationProcessor;
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -200,6 +203,288 @@ public void mapBindingsWithEnumKey() {
         .generatesSources(generatedComponent);
   }
 
+  @Test
+  public void mapBindingsWithInaccessibleKeys() {
+    JavaFileObject mapKeys =
+        JavaFileObjects.forSourceLines(
+            "mapkeys.MapKeys",
+            "package mapkeys;",
+            "",
+            "import dagger.MapKey;",
+            "import dagger.multibindings.ClassKey;",
+            "",
+            "public class MapKeys {",
+            "  @MapKey(unwrapValue = false)",
+            "  public @interface ComplexKey {",
+            "    Class<?>[] manyClasses();",
+            "    Class<?> oneClass();",
+            "    ClassKey annotation();",
+            "  }",
+            "",
+            "  @MapKey",
+            "  @interface EnumKey {",
+            "    PackagePrivateEnum value();",
+            "  }",
+            "",
+            "  enum PackagePrivateEnum { INACCESSIBLE }",
+            "",
+            "  interface Inaccessible {}",
+            "}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "mapkeys.MapModule",
+            "package mapkeys;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ClassKey;",
+            "import dagger.multibindings.IntoMap;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "public interface MapModule {",
+            "  @Provides @IntoMap @ClassKey(MapKeys.Inaccessible.class)",
+            "  static int classKey() { return 1; }",
+            "",
+            "  @Provides @IntoMap @MapKeys.EnumKey(MapKeys.PackagePrivateEnum.INACCESSIBLE)",
+            "  static int enumKey() { return 1; }",
+            "",
+            "  @Binds Object bindInaccessibleEnumMapToAccessibleTypeForComponent(",
+            "    Map<MapKeys.PackagePrivateEnum, Integer> map);",
+            "",
+            "  @Provides @IntoMap",
+            "  @MapKeys.ComplexKey(",
+            "    manyClasses = {java.lang.Object.class, java.lang.String.class},",
+            "    oneClass = MapKeys.Inaccessible.class,",
+            "    annotation = @ClassKey(java.lang.Object.class)",
+            "  )",
+            "  static int complexKeyWithInaccessibleValue() { return 1; }",
+            "",
+            "  @Provides @IntoMap",
+            "  @MapKeys.ComplexKey(",
+            "    manyClasses = {MapKeys.Inaccessible.class, java.lang.String.class},",
+            "    oneClass = java.lang.String.class,",
+            "    annotation = @ClassKey(java.lang.Object.class)",
+            "  )",
+            "  static int complexKeyWithInaccessibleArrayValue() { return 1; }",
+            "",
+            "  @Provides @IntoMap",
+            "  @MapKeys.ComplexKey(",
+            "    manyClasses = {java.lang.String.class},",
+            "    oneClass = java.lang.String.class,",
+            "    annotation = @ClassKey(MapKeys.Inaccessible.class)",
+            "  )",
+            "  static int complexKeyWithInaccessibleAnnotationValue() { return 1; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "import mapkeys.MapKeys;",
+            "import mapkeys.MapModule;",
+            "",
+            "@Component(modules = MapModule.class)",
+            "interface TestComponent {",
+            "  Map<Class<?>, Integer> classKey();",
+            "  Provider<Map<Class<?>, Integer>> classKeyProvider();",
+            "",
+            "  Object inaccessibleEnum();",
+            "  Provider<Object> inaccessibleEnumProvider();",
+            "",
+            "  Map<MapKeys.ComplexKey, Integer> complexKey();",
+            "  Provider<Map<MapKeys.ComplexKey, Integer>> complexKeyProvider();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(mapKeys, moduleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import dagger.internal.MapFactory;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "import mapkeys.MapKeys;",
+                "import mapkeys.MapModule;",
+                "import mapkeys.MapModule_ClassKeyFactory;",
+                "import mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory;",
+                "import mapkeys.MapModule_ComplexKeyWithInaccessibleArrayValueFactory;",
+                "import mapkeys.MapModule_ComplexKeyWithInaccessibleValueFactory;",
+                "import mapkeys.MapModule_EnumKeyFactory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Provider<Map<Class<?>, Integer>> mapOfClassOfAndIntegerProvider;",
+                "",
+                "  @SuppressWarnings(\"rawtypes\")",
+                "  private Provider mapOfPackagePrivateEnumAndIntegerProvider;",
+                "",
+                "  private Provider<Object>",
+                "      bindInaccessibleEnumMapToAccessibleTypeForComponentProvider;",
+                "",
+                "  private Provider<Map<MapKeys.ComplexKey, Integer>>",
+                "      mapOfComplexKeyAndIntegerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.mapOfClassOfAndIntegerProvider =",
+                "        MapFactory.<Class<?>, Integer>builder(1)",
+                "            .put(MapModule_ClassKeyFactory.mapKey(),",
+                "                 MapModule_ClassKeyFactory.create())",
+                "            .build();",
+                "    this.mapOfPackagePrivateEnumAndIntegerProvider =",
+                "        MapFactory.builder(1)",
+                "            .put(MapModule_EnumKeyFactory.mapKey(), ",
+                "                 (Provider) MapModule_EnumKeyFactory.create())",
+                "            .build();",
+                "    this.bindInaccessibleEnumMapToAccessibleTypeForComponentProvider =",
+                "        (Provider) mapOfPackagePrivateEnumAndIntegerProvider;",
+                "    this.mapOfComplexKeyAndIntegerProvider =",
+                "       MapFactory.<MapKeys.ComplexKey, Integer>builder(3)",
+                "          .put(",
+                "             MapModule_ComplexKeyWithInaccessibleValueFactory.mapKey(),",
+                "             MapModule_ComplexKeyWithInaccessibleValueFactory.create())",
+                "          .put(",
+                "             MapModule_ComplexKeyWithInaccessibleArrayValueFactory.mapKey(),",
+                "             MapModule_ComplexKeyWithInaccessibleArrayValueFactory.create())",
+                "          .put(",
+                "             MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory.mapKey(),",
+                "             MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory.create())",
+                "          .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Class<?>, Integer> classKey() {",
+                "    return ImmutableMap.<Class<?>, Integer>of(",
+                "        MapModule_ClassKeyFactory.mapKey(), MapModule.classKey());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<Class<?>, Integer>> classKeyProvider() {",
+                "    return mapOfClassOfAndIntegerProvider;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object inaccessibleEnum() {",
+                "    return bindInaccessibleEnumMapToAccessibleTypeForComponentProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Object> inaccessibleEnumProvider() {",
+                "    return bindInaccessibleEnumMapToAccessibleTypeForComponentProvider;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<MapKeys.ComplexKey, Integer> complexKey() {",
+                "    return ImmutableMap.<MapKeys.ComplexKey, Integer>of(",
+                "        MapModule_ComplexKeyWithInaccessibleValueFactory.mapKey(),",
+                "        MapModule.complexKeyWithInaccessibleValue(),",
+                "        MapModule_ComplexKeyWithInaccessibleArrayValueFactory.mapKey(),",
+                "        MapModule.complexKeyWithInaccessibleArrayValue(),",
+                "        MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory.mapKey(),",
+                "        MapModule.complexKeyWithInaccessibleAnnotationValue());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<MapKeys.ComplexKey, Integer>> complexKeyProvider() {",
+                "    return mapOfComplexKeyAndIntegerProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}"));
+    assertThat(compilation)
+        .generatedSourceFile(
+            "mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory",
+                "package mapkeys;",
+                "",
+                "import dagger.internal.Factory;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class",
+                "    MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory",
+                "        implements Factory<Integer> {",
+                "  private static final",
+                "    MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory INSTANCE =",
+                "      new MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory();",
+                "",
+                "  @Override",
+                "  public Integer get() {",
+                "    return MapModule.complexKeyWithInaccessibleAnnotationValue();",
+                "  }",
+                "",
+                "  public static Factory<Integer> create() {",
+                "    return INSTANCE;",
+                "  }",
+                "",
+                "  public static MapKeys.ComplexKey mapKey() {",
+                "    return MapKeys_ComplexKeyCreator.createComplexKey(",
+                "        new Class[] {String.class},",
+                "        String.class,",
+                "        MapKeys_ComplexKeyCreator.createClassKey(MapKeys.Inaccessible.class));",
+                "  }",
+                "}"));
+    assertThat(compilation)
+        .generatedSourceFile("mapkeys.MapModule_ClassKeyFactory")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "mapkeys.MapModule_ClassKeyFactory",
+                "package mapkeys;",
+                "",
+                "import dagger.internal.Factory;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class MapModule_ClassKeyFactory implements Factory<Integer> {",
+                "  private static final MapModule_ClassKeyFactory INSTANCE = ",
+                "      new MapModule_ClassKeyFactory();",
+                "",
+                "  @Override",
+                "  public Integer get() {",
+                "    return MapModule.classKey();",
+                "  }",
+                "",
+                "  public static Factory<Integer> create() {",
+                "    return INSTANCE;",
+                "  }",
+                "",
+                "  public static Class<?> mapKey() {",
+                "    return MapKeys.Inaccessible.class;",
+                "  }",
+                "}"));
+  }
+
   @Test
   public void mapBindingsWithStringKey() {
     JavaFileObject mapModuleOneFile =
