diff --git a/java/dagger/internal/codegen/Expression.java b/java/dagger/internal/codegen/Expression.java
index b6d215c4e..c38fd5795 100644
--- a/java/dagger/internal/codegen/Expression.java
+++ b/java/dagger/internal/codegen/Expression.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.squareup.javapoet.CodeBlock;
 import javax.lang.model.type.TypeMirror;
 
@@ -63,16 +62,6 @@ Expression castTo(TypeMirror newType) {
     return create(newType, "($T) $L", newType, codeBlock);
   }
 
-  /**
-   * Returns a new expression that {@link #castTo(TypeMirror)} casts the current expression to its
-   * boxed type if this expression has a primitive type.
-   */
-  Expression box(DaggerTypes types) {
-    return type.getKind().isPrimitive()
-        ? castTo(types.boxedClass(MoreTypes.asPrimitiveType(type)).asType())
-        : this;
-  }
-
   /** The {@link TypeMirror type} to which the expression evaluates. */
   TypeMirror type() {
     return type;
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index 47cba7540..9e615c9db 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -98,12 +98,7 @@ private Expression invokeMethod(ClassName requestingClass) {
       default:
         throw new IllegalStateException();
     }
-
-    return Expression.create(
-        method.getReturnType().getKind().isPrimitive()
-            ? method.getReturnType()
-            : provisionBinding.key().type(),
-        invocation);
+    return Expression.create(provisionBinding.key().type(), invocation);
   }
 
   private TypeName constructorTypeName(ClassName requestingClass) {
diff --git a/java/dagger/internal/codegen/SwitchingProviders.java b/java/dagger/internal/codegen/SwitchingProviders.java
index 306ec61f7..fd706532c 100644
--- a/java/dagger/internal/codegen/SwitchingProviders.java
+++ b/java/dagger/internal/codegen/SwitchingProviders.java
@@ -141,11 +141,21 @@ private Expression getExpression(ContributionBinding binding) {
     }
 
     private CodeBlock createSwitchCaseCodeBlock(ContributionBinding binding) {
-      CodeBlock instanceCodeBlock =
-        componentBindingExpressions
-            .getDependencyExpression(binding.key(), INSTANCE, owningComponent)
-            .box(types)
-            .codeBlock();
+      Expression instanceExpression =
+          componentBindingExpressions
+              .getDependencyExpression(binding.key(), INSTANCE, owningComponent);
+
+      CodeBlock instanceCodeBlock = instanceExpression.codeBlock();
+
+      // Primitives cannot be cast directly to the method's parameterized type, T. We have to first
+      // cast them to their boxed type.
+      // TODO(user): Shouldn't we be able to rely soley on the instance expression type? However,
+      // that currently fails. Does that indicate that those dependency expression types are wrong?
+      if (binding.contributedPrimitiveType().isPresent()
+          || instanceExpression.type().getKind().isPrimitive()) {
+        TypeName boxedType = TypeName.get(binding.contributedType()).box();
+        instanceCodeBlock = CodeBlock.of("($T) $L", boxedType, instanceCodeBlock);
+      }
 
       return CodeBlock.builder()
           // TODO(user): Is there something else more useful than the key?
