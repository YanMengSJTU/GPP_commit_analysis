diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
index 6b3a9f25e..859c8bea8 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
@@ -50,6 +50,7 @@
 import dagger.internal.codegen.binding.ComponentRequirement;
 import dagger.internal.codegen.binding.ComponentRequirement.NullPolicy;
 import dagger.internal.codegen.javapoet.TypeNames;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.internal.codegen.writing.ComponentCreatorImplementation;
@@ -68,11 +69,14 @@
 
   private final DaggerElements elements;
   private final DaggerTypes types;
+  private final KotlinMetadataUtil metadataUtil;
 
   @Inject
-  ComponentCreatorImplementationFactory(DaggerElements elements, DaggerTypes types) {
+  ComponentCreatorImplementationFactory(
+      DaggerElements elements, DaggerTypes types, KotlinMetadataUtil metadataUtil) {
     this.elements = elements;
     this.types = types;
+    this.metadataUtil = metadataUtil;
   }
 
   /** Returns a new creator implementation for the given component, if necessary. */
@@ -218,7 +222,7 @@ private MethodSpec normalSetterMethod(ComponentRequirement requirement) {
       method.addStatement(
           "this.$N = $L",
           fields.get(requirement),
-          requirement.nullPolicy(elements, types).equals(NullPolicy.ALLOW)
+          requirement.nullPolicy(elements, types, metadataUtil).equals(NullPolicy.ALLOW)
               ? CodeBlock.of("$N", parameter)
               : CodeBlock.of("$T.checkNotNull($N)", Preconditions.class, parameter));
       return maybeReturnThis(method);
@@ -291,7 +295,7 @@ MethodSpec factoryMethod() {
 
     private void addNullHandlingForField(
         ComponentRequirement requirement, FieldSpec field, MethodSpec.Builder factoryMethod) {
-      switch (requirement.nullPolicy(elements, types)) {
+      switch (requirement.nullPolicy(elements, types, metadataUtil)) {
         case NEW:
           checkState(requirement.kind().isModule());
           factoryMethod
@@ -315,7 +319,7 @@ private void addNullHandlingForField(
 
     private void addNullHandlingForParameter(
         ComponentRequirement requirement, String parameter, MethodSpec.Builder factoryMethod) {
-      if (!requirement.nullPolicy(elements, types).equals(NullPolicy.ALLOW)) {
+      if (!requirement.nullPolicy(elements, types, metadataUtil).equals(NullPolicy.ALLOW)) {
         // Factory method parameters are always required unless they are a nullable
         // binds-instance (i.e. ALLOW)
         factoryMethod.addStatement("$T.checkNotNull($L)", Preconditions.class, parameter);
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index 5e66904f7..4417e9fac 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -49,6 +49,7 @@
 import dagger.internal.codegen.binding.ComponentDescriptorFactory;
 import dagger.internal.codegen.binding.ComponentRequirement;
 import dagger.internal.codegen.binding.MethodSignature;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.internal.codegen.validation.ComponentValidator;
@@ -89,6 +90,7 @@
   private final Messager messager;
   private final ComponentValidator componentValidator;
   private final ComponentDescriptorFactory componentDescriptorFactory;
+  private final KotlinMetadataUtil metadataUtil;
 
   @Inject
   ComponentHjarProcessingStep(
@@ -98,7 +100,8 @@
       Filer filer,
       Messager messager,
       ComponentValidator componentValidator,
-      ComponentDescriptorFactory componentDescriptorFactory) {
+      ComponentDescriptorFactory componentDescriptorFactory,
+      KotlinMetadataUtil metadataUtil) {
     super(MoreElements::asType);
     this.sourceVersion = sourceVersion;
     this.elements = elements;
@@ -107,6 +110,7 @@
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
+    this.metadataUtil = metadataUtil;
   }
 
   @Override
@@ -194,7 +198,9 @@ public Element originatingElement(ComponentDescriptor input) {
       if (noArgFactoryMethod
           && !hasBindsInstanceMethods(componentDescriptor)
           && componentRequirements(componentDescriptor)
-              .noneMatch(requirement -> requirement.requiresAPassedInstance(elements, types))) {
+              .noneMatch(
+                  requirement ->
+                      requirement.requiresAPassedInstance(elements, types, metadataUtil))) {
         generatedComponent.addMethod(createMethod(componentDescriptor));
       }
 
diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index 4e2b7faa0..dc8937d0e 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -63,6 +63,7 @@
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.javapoet.AnnotationSpecs;
 import dagger.internal.codegen.javapoet.CodeBlocks;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.internal.codegen.writing.ComponentBindingExpressions;
@@ -106,6 +107,7 @@
   @Inject CompilerOptions compilerOptions;
   @Inject ComponentImplementationFactory componentImplementationFactory;
   @Inject TopLevelImplementationComponent topLevelImplementationComponent;
+  @Inject KotlinMetadataUtil metadataUtil;
   private boolean done;
 
   /**
@@ -462,7 +464,7 @@ protected void addFactoryMethods() {
     private boolean canInstantiateAllRequirements() {
       return !Iterables.any(
           graph.componentRequirements(),
-          dependency -> dependency.requiresAPassedInstance(elements, types));
+          dependency -> dependency.requiresAPassedInstance(elements, types, metadataUtil));
     }
 
     private ClassName componentCreatorName() {
diff --git a/java/dagger/internal/codegen/base/Util.java b/java/dagger/internal/codegen/base/Util.java
index 9c4f0f8b5..e92b8ab5a 100644
--- a/java/dagger/internal/codegen/base/Util.java
+++ b/java/dagger/internal/codegen/base/Util.java
@@ -16,71 +16,11 @@
 
 package dagger.internal.codegen.base;
 
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
-
 import java.util.Map;
 import java.util.function.Function;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 
-/**
- * Utilities for handling types in annotation processors
- */
+/** General utilities for the annotation processor. */
 public final class Util {
-  /**
-   * Returns true if and only if a component can instantiate new instances (typically of a module)
-   * rather than requiring that they be passed.
-   */
-  public static boolean componentCanMakeNewInstances(TypeElement typeElement) {
-    switch (typeElement.getKind()) {
-      case CLASS:
-        break;
-      case ENUM:
-      case ANNOTATION_TYPE:
-      case INTERFACE:
-        return false;
-      default:
-        throw new AssertionError("TypeElement cannot have kind: " + typeElement.getKind());
-    }
-
-    if (typeElement.getModifiers().contains(ABSTRACT)) {
-      return false;
-    }
-
-    if (requiresEnclosingInstance(typeElement)) {
-      return false;
-    }
-
-    for (Element enclosed : typeElement.getEnclosedElements()) {
-      if (enclosed.getKind().equals(CONSTRUCTOR)
-          && ((ExecutableElement) enclosed).getParameters().isEmpty()
-          && !enclosed.getModifiers().contains(PRIVATE)) {
-        return true;
-      }
-    }
-
-    // TODO(gak): still need checks for visibility
-
-    return false;
-  }
-
-  private static boolean requiresEnclosingInstance(TypeElement typeElement) {
-    switch (typeElement.getNestingKind()) {
-      case TOP_LEVEL:
-        return false;
-      case MEMBER:
-        return !typeElement.getModifiers().contains(STATIC);
-      case ANONYMOUS:
-      case LOCAL:
-        return true;
-    }
-    throw new AssertionError(
-        "TypeElement cannot have nesting kind: " + typeElement.getNestingKind());
-  }
 
   /**
    * A version of {@link Map#computeIfAbsent(Object, Function)} that allows {@code mappingFunction}
diff --git a/java/dagger/internal/codegen/binding/BindingFactory.java b/java/dagger/internal/codegen/binding/BindingFactory.java
index e5a3d626f..9d03c12a3 100644
--- a/java/dagger/internal/codegen/binding/BindingFactory.java
+++ b/java/dagger/internal/codegen/binding/BindingFactory.java
@@ -56,6 +56,7 @@
 import dagger.internal.codegen.base.SetType;
 import dagger.internal.codegen.binding.MembersInjectionBinding.InjectionSite;
 import dagger.internal.codegen.binding.ProductionBinding.ProductionKind;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.DependencyRequest;
@@ -83,6 +84,7 @@
   private final InjectionSiteFactory injectionSiteFactory;
   private final DaggerElements elements;
   private final InjectionAnnotations injectionAnnotations;
+  private final KotlinMetadataUtil metadataUtil;
 
   @Inject
   BindingFactory(
@@ -91,13 +93,15 @@
       KeyFactory keyFactory,
       DependencyRequestFactory dependencyRequestFactory,
       InjectionSiteFactory injectionSiteFactory,
-      InjectionAnnotations injectionAnnotations) {
+      InjectionAnnotations injectionAnnotations,
+      KotlinMetadataUtil metadataUtil) {
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.dependencyRequestFactory = dependencyRequestFactory;
     this.injectionSiteFactory = injectionSiteFactory;
     this.injectionAnnotations = injectionAnnotations;
+    this.metadataUtil = metadataUtil;
   }
 
   /**
@@ -214,6 +218,7 @@ B setMethodBindingProperties(
         .contributionType(ContributionType.fromBindingElement(method))
         .bindingElement(method)
         .contributingModule(contributedBy)
+        .isModuleKotlinObject(metadataUtil.isObjectClass(contributedBy))
         .key(key)
         .dependencies(
             dependencyRequestFactory.forRequiredResolvedVariables(
@@ -419,6 +424,8 @@ private ContributionBinding buildDelegateBinding(
         .contributionType(delegateDeclaration.contributionType())
         .bindingElement(delegateDeclaration.bindingElement().get())
         .contributingModule(delegateDeclaration.contributingModule().get())
+        .isModuleKotlinObject(
+            metadataUtil.isObjectClass(delegateDeclaration.contributingModule().get()))
         .key(keyFactory.forDelegateBinding(delegateDeclaration, frameworkType))
         .dependencies(delegateDeclaration.delegateRequest())
         .wrappedMapKeyAnnotation(delegateDeclaration.wrappedMapKey())
diff --git a/java/dagger/internal/codegen/binding/ComponentRequirement.java b/java/dagger/internal/codegen/binding/ComponentRequirement.java
index 264d06f21..8c6a3c708 100644
--- a/java/dagger/internal/codegen/binding/ComponentRequirement.java
+++ b/java/dagger/internal/codegen/binding/ComponentRequirement.java
@@ -19,12 +19,14 @@
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.base.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.binding.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.langmodel.DaggerElements.isAnyAnnotationPresent;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
@@ -34,6 +36,7 @@
 import dagger.Binds;
 import dagger.BindsOptionalOf;
 import dagger.Provides;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.BindingKind;
@@ -41,6 +44,7 @@
 import dagger.multibindings.Multibinds;
 import dagger.producers.Produces;
 import java.util.Optional;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
@@ -117,15 +121,18 @@ public TypeElement typeElement() {
   abstract Optional<NullPolicy> overrideNullPolicy();
 
   /** The requirement's null policy. */
-  public NullPolicy nullPolicy(DaggerElements elements, DaggerTypes types) {
+  public NullPolicy nullPolicy(
+      DaggerElements elements, DaggerTypes types, KotlinMetadataUtil metadataUtil) {
     if (overrideNullPolicy().isPresent()) {
       return overrideNullPolicy().get();
     }
     switch (kind()) {
       case MODULE:
-        return componentCanMakeNewInstances(typeElement())
+        return componentCanMakeNewInstances(typeElement(), metadataUtil)
             ? NullPolicy.NEW
-            : requiresAPassedInstance(elements, types) ? NullPolicy.THROW : NullPolicy.ALLOW;
+            : requiresAPassedInstance(elements, types, metadataUtil)
+                ? NullPolicy.THROW
+                : NullPolicy.ALLOW;
       case DEPENDENCY:
       case BOUND_INSTANCE:
         return NullPolicy.THROW;
@@ -137,12 +144,14 @@ public NullPolicy nullPolicy(DaggerElements elements, DaggerTypes types) {
    * Returns true if the passed {@link ComponentRequirement} requires a passed instance in order to
    * be used within a component.
    */
-  public boolean requiresAPassedInstance(DaggerElements elements, DaggerTypes types) {
+  public boolean requiresAPassedInstance(
+      DaggerElements elements, DaggerTypes types, KotlinMetadataUtil metadataUtil) {
     if (!kind().isModule()) {
       // Bound instances and dependencies always require the user to provide an instance.
       return true;
     }
-    return requiresModuleInstance(elements, types) && !componentCanMakeNewInstances(typeElement());
+    return requiresModuleInstance(elements, types, metadataUtil)
+        && !componentCanMakeNewInstances(typeElement(), metadataUtil);
   }
 
   /**
@@ -151,14 +160,19 @@ public boolean requiresAPassedInstance(DaggerElements elements, DaggerTypes type
    * <p>An instance is only needed if there is a binding method on the module that is neither {@code
    * abstract} nor {@code static}; if all bindings are one of those, then there should be no
    * possible dependency on instance state in the module's bindings.
+   *
+   * <p>Alternatively, if the module is a Kotlin Object then the binding methods are considered
+   * {@code static}, requiring no module instance.
    */
-  private boolean requiresModuleInstance(DaggerElements elements, DaggerTypes types) {
+  private boolean requiresModuleInstance(
+      DaggerElements elements, DaggerTypes types, KotlinMetadataUtil metadataUtil) {
     ImmutableSet<ExecutableElement> methods =
         getLocalAndInheritedMethods(typeElement(), types, elements);
-    return methods.stream()
-        .filter(this::isBindingMethod)
-        .map(ExecutableElement::getModifiers)
-        .anyMatch(modifiers -> !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC));
+    return !metadataUtil.isObjectClass(typeElement())
+        && methods.stream()
+            .filter(this::isBindingMethod)
+            .map(ExecutableElement::getModifiers)
+            .anyMatch(modifiers -> !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC));
   }
 
   private boolean isBindingMethod(ExecutableElement method) {
@@ -220,4 +234,61 @@ public static ComponentRequirement forBoundInstance(ContributionBinding binding)
         binding.nullableType().isPresent(),
         binding.bindingElement().get().getSimpleName().toString());
   }
+
+  /**
+   * Returns true if and only if a component can instantiate new instances (typically of a module)
+   * rather than requiring that they be passed.
+   */
+  // TODO(user): Should this method throw if its called knowing that an instance is not needed?
+  public static boolean componentCanMakeNewInstances(
+      TypeElement typeElement, KotlinMetadataUtil metadataUtil) {
+    switch (typeElement.getKind()) {
+      case CLASS:
+        break;
+      case ENUM:
+      case ANNOTATION_TYPE:
+      case INTERFACE:
+        return false;
+      default:
+        throw new AssertionError("TypeElement cannot have kind: " + typeElement.getKind());
+    }
+
+    if (typeElement.getModifiers().contains(ABSTRACT)) {
+      return false;
+    }
+
+    if (requiresEnclosingInstance(typeElement)) {
+      return false;
+    }
+
+    if (metadataUtil.isObjectClass(typeElement)) {
+      return false;
+    }
+
+    for (Element enclosed : typeElement.getEnclosedElements()) {
+      if (enclosed.getKind().equals(CONSTRUCTOR)
+          && MoreElements.asExecutable(enclosed).getParameters().isEmpty()
+          && !enclosed.getModifiers().contains(PRIVATE)) {
+        return true;
+      }
+    }
+
+    // TODO(gak): still need checks for visibility
+
+    return false;
+  }
+
+  private static boolean requiresEnclosingInstance(TypeElement typeElement) {
+    switch (typeElement.getNestingKind()) {
+      case TOP_LEVEL:
+        return false;
+      case MEMBER:
+        return !typeElement.getModifiers().contains(STATIC);
+      case ANONYMOUS:
+      case LOCAL:
+        return true;
+    }
+    throw new AssertionError(
+        "TypeElement cannot have nesting kind: " + typeElement.getNestingKind());
+  }
 }
diff --git a/java/dagger/internal/codegen/binding/ContributionBinding.java b/java/dagger/internal/codegen/binding/ContributionBinding.java
index b991b4910..4232663df 100644
--- a/java/dagger/internal/codegen/binding/ContributionBinding.java
+++ b/java/dagger/internal/codegen/binding/ContributionBinding.java
@@ -24,6 +24,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Preconditions;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.CheckReturnValue;
 import dagger.internal.codegen.base.ContributionType;
@@ -64,11 +65,18 @@
         .filter(type -> type.getKind().isPrimitive());
   }
 
+  @Override
+  public boolean requiresModuleInstance() {
+    return !isModuleKotlinObject().orElse(false) && super.requiresModuleInstance();
+  }
+
   @Override
   public final boolean isNullable() {
     return nullableType().isPresent();
   }
 
+  abstract Optional<Boolean> isModuleKotlinObject();
+
   /** The strategy for getting an instance of a factory for a {@link ContributionBinding}. */
   public enum FactoryCreationStrategy {
     /** The factory class is a single instance. */
@@ -158,7 +166,9 @@ public B dependencies(DependencyRequest... dependencies) {
 
     public abstract B bindingElement(Element bindingElement);
 
-    public abstract B contributingModule(TypeElement contributingModule);
+    abstract B contributingModule(TypeElement contributingModule);
+
+    abstract B isModuleKotlinObject(boolean isModuleKotlinObject);
 
     public abstract B key(Key key);
 
@@ -170,6 +180,15 @@ abstract B wrappedMapKeyAnnotation(
     public abstract B kind(BindingKind kind);
 
     @CheckReturnValue
-    public abstract C build();
+    abstract C autoBuild();
+
+    @CheckReturnValue
+    public C build() {
+      C binding = autoBuild();
+      Preconditions.checkState(
+          binding.contributingModule().isPresent() == binding.isModuleKotlinObject().isPresent(),
+          "The contributionModule and isModuleKotlinObject must both be set together.");
+      return binding;
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/bindinggraphvalidation/BUILD b/java/dagger/internal/codegen/bindinggraphvalidation/BUILD
index 930d3c00e..151f6cd6a 100644
--- a/java/dagger/internal/codegen/bindinggraphvalidation/BUILD
+++ b/java/dagger/internal/codegen/bindinggraphvalidation/BUILD
@@ -28,6 +28,7 @@ java_library(
         "//java/dagger/internal/codegen/binding",
         "//java/dagger/internal/codegen/compileroption",
         "//java/dagger/internal/codegen/extension",
+        "//java/dagger/internal/codegen/kotlin",
         "//java/dagger/internal/codegen/langmodel",
         "//java/dagger/internal/codegen/validation",
         "//java/dagger/model",
diff --git a/java/dagger/internal/codegen/bindinggraphvalidation/SubcomponentFactoryMethodValidator.java b/java/dagger/internal/codegen/bindinggraphvalidation/SubcomponentFactoryMethodValidator.java
index 9d8c2e494..bf83a69f9 100644
--- a/java/dagger/internal/codegen/bindinggraphvalidation/SubcomponentFactoryMethodValidator.java
+++ b/java/dagger/internal/codegen/bindinggraphvalidation/SubcomponentFactoryMethodValidator.java
@@ -20,7 +20,7 @@
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.asTypeElements;
 import static com.google.common.collect.Sets.union;
-import static dagger.internal.codegen.base.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.binding.ComponentRequirement.componentCanMakeNewInstances;
 import static dagger.internal.codegen.extension.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableSet;
 import static javax.tools.Diagnostic.Kind.ERROR;
@@ -31,6 +31,7 @@
 import com.google.common.collect.Sets.SetView;
 import dagger.internal.codegen.base.Util;
 import dagger.internal.codegen.binding.ComponentNodeImpl;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.BindingGraph;
 import dagger.model.BindingGraph.ChildFactoryMethodEdge;
@@ -50,11 +51,13 @@
 final class SubcomponentFactoryMethodValidator implements BindingGraphPlugin {
 
   private final DaggerTypes types;
+  private final KotlinMetadataUtil metadataUtil;
   private final Map<ComponentNode, Set<TypeElement>> inheritedModulesCache = new HashMap<>();
 
   @Inject
-  SubcomponentFactoryMethodValidator(DaggerTypes types) {
+  SubcomponentFactoryMethodValidator(DaggerTypes types, KotlinMetadataUtil metadataUtil) {
     this.types = types;
+    this.metadataUtil = metadataUtil;
   }
 
   @Override
@@ -100,7 +103,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
         // module not in the method parameters
         .filter(module -> !factoryMethodParameters.contains(module))
         // module doesn't have an accessible no-arg constructor
-        .filter(moduleType -> !componentCanMakeNewInstances(moduleType))
+        .filter(moduleType -> !componentCanMakeNewInstances(moduleType, metadataUtil))
         .collect(toImmutableSet());
   }
 
diff --git a/java/dagger/internal/codegen/kotlin/KotlinMetadata.java b/java/dagger/internal/codegen/kotlin/KotlinMetadata.java
index fa86e59d7..691e4b418 100644
--- a/java/dagger/internal/codegen/kotlin/KotlinMetadata.java
+++ b/java/dagger/internal/codegen/kotlin/KotlinMetadata.java
@@ -32,6 +32,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.ElementFilter;
+import kotlinx.metadata.Flag;
 import kotlinx.metadata.KmClass;
 import kotlinx.metadata.KmProperty;
 import kotlinx.metadata.jvm.JvmExtensionsKt;
@@ -96,4 +97,8 @@ KmClass getKmClass() {
     checkArgument(elementFieldAnnotationMethodMap.get().containsKey(fieldElement));
     return elementFieldAnnotationMethodMap.get().get(fieldElement);
   }
+
+  boolean isObjectClass() {
+    return Flag.Class.IS_OBJECT.invoke(kmClass.getFlags());
+  }
 }
diff --git a/java/dagger/internal/codegen/kotlin/KotlinMetadataFactory.java b/java/dagger/internal/codegen/kotlin/KotlinMetadataFactory.java
index 387cfa374..b41c3406b 100644
--- a/java/dagger/internal/codegen/kotlin/KotlinMetadataFactory.java
+++ b/java/dagger/internal/codegen/kotlin/KotlinMetadataFactory.java
@@ -17,10 +17,12 @@
 package dagger.internal.codegen.kotlin;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.base.MoreAnnotationValues.asAnnotationValues;
 import static dagger.internal.codegen.langmodel.DaggerElements.closestEnclosingTypeElement;
 import static dagger.internal.codegen.langmodel.DaggerElements.getAnnotationMirror;
 
+import com.google.common.base.Preconditions;
 import dagger.internal.codegen.base.ClearableCache;
 import java.util.HashMap;
 import java.util.Map;
@@ -50,6 +52,9 @@
 
   public Optional<KotlinMetadata> create(Element element) {
     TypeElement enclosingElement = closestEnclosingTypeElement(element);
+    if (!isAnnotationPresent(enclosingElement, Metadata.class)) {
+      return Optional.empty();
+    }
     return metadataCache.computeIfAbsent(
         enclosingElement,
         typeElement ->
@@ -60,9 +65,7 @@
   private static Optional<KmClass> kmClassOf(TypeElement typeElement) {
     Optional<AnnotationMirror> metadataAnnotation =
         getAnnotationMirror(typeElement, Metadata.class);
-    if (!metadataAnnotation.isPresent()) {
-      return Optional.empty();
-    }
+    Preconditions.checkState(metadataAnnotation.isPresent());
     KotlinClassHeader header =
         new KotlinClassHeader(
             getIntValue(metadataAnnotation.get(), "k"),
diff --git a/java/dagger/internal/codegen/kotlin/KotlinMetadataUtil.java b/java/dagger/internal/codegen/kotlin/KotlinMetadataUtil.java
index f66ded4a6..7e71ac3b6 100644
--- a/java/dagger/internal/codegen/kotlin/KotlinMetadataUtil.java
+++ b/java/dagger/internal/codegen/kotlin/KotlinMetadataUtil.java
@@ -25,6 +25,7 @@
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import kotlin.Metadata;
 
@@ -60,4 +61,9 @@ public boolean hasMetadata(Element element) {
         .map(methodElement -> getAnnotatedAnnotations(methodElement, annotationType))
         .orElse(ImmutableSet.of());
   }
+
+  /** Returns true if this type element is a Kotlin Object. */
+  public boolean isObjectClass(TypeElement typeElement) {
+    return metadataFactory.create(typeElement).map(KotlinMetadata::isObjectClass).orElse(false);
+  }
 }
diff --git a/java/dagger/internal/codegen/validation/ComponentDescriptorValidator.java b/java/dagger/internal/codegen/validation/ComponentDescriptorValidator.java
index e888ef63e..cfed10b2e 100644
--- a/java/dagger/internal/codegen/validation/ComponentDescriptorValidator.java
+++ b/java/dagger/internal/codegen/validation/ComponentDescriptorValidator.java
@@ -52,6 +52,7 @@
 import dagger.internal.codegen.binding.ModuleDescriptor;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.compileroption.ValidationType;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.Scope;
@@ -93,6 +94,7 @@
   private final CompilerOptions compilerOptions;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final ComponentHierarchyValidator componentHierarchyValidator;
+  private final KotlinMetadataUtil metadataUtil;
 
   @Inject
   ComponentDescriptorValidator(
@@ -100,12 +102,14 @@
       DaggerTypes types,
       CompilerOptions compilerOptions,
       MethodSignatureFormatter methodSignatureFormatter,
-      ComponentHierarchyValidator componentHierarchyValidator) {
+      ComponentHierarchyValidator componentHierarchyValidator,
+      KotlinMetadataUtil metadataUtil) {
     this.elements = elements;
     this.types = types;
     this.compilerOptions = compilerOptions;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.componentHierarchyValidator = componentHierarchyValidator;
+    this.metadataUtil = metadataUtil;
   }
 
   public ValidationReport<TypeElement> validate(ComponentDescriptor component) {
@@ -323,7 +327,7 @@ private void validateCreators(ComponentDescriptor component) {
       Set<ComponentRequirement> mustBePassed =
           Sets.filter(
               componentModuleAndDependencyRequirements,
-              input -> input.nullPolicy(elements, types).equals(NullPolicy.THROW));
+              input -> input.nullPolicy(elements, types, metadataUtil).equals(NullPolicy.THROW));
       // Component requirements that the creator must be able to set, but can't
       Set<ComponentRequirement> missingRequirements =
           Sets.difference(mustBePassed, creatorModuleAndDependencyRequirements);
diff --git a/java/dagger/internal/codegen/validation/ModuleValidator.java b/java/dagger/internal/codegen/validation/ModuleValidator.java
index a1dc71b01..6dd46f9e8 100644
--- a/java/dagger/internal/codegen/validation/ModuleValidator.java
+++ b/java/dagger/internal/codegen/validation/ModuleValidator.java
@@ -60,6 +60,7 @@
 import dagger.internal.codegen.binding.ComponentDescriptorFactory;
 import dagger.internal.codegen.binding.MethodSignatureFormatter;
 import dagger.internal.codegen.binding.ModuleKind;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.BindingGraph;
@@ -124,6 +125,7 @@
   private final BindingGraphFactory bindingGraphFactory;
   private final BindingGraphConverter bindingGraphConverter;
   private final BindingGraphValidator bindingGraphValidator;
+  private final KotlinMetadataUtil metadataUtil;
   private final Map<TypeElement, ValidationReport<TypeElement>> cache = new HashMap<>();
   private final Set<TypeElement> knownModules = new HashSet<>();
 
@@ -136,7 +138,8 @@
       ComponentDescriptorFactory componentDescriptorFactory,
       BindingGraphFactory bindingGraphFactory,
       BindingGraphConverter bindingGraphConverter,
-      BindingGraphValidator bindingGraphValidator) {
+      BindingGraphValidator bindingGraphValidator,
+      KotlinMetadataUtil metadataUtil) {
     this.types = types;
     this.elements = elements;
     this.anyBindingMethodValidator = anyBindingMethodValidator;
@@ -145,6 +148,7 @@
     this.bindingGraphFactory = bindingGraphFactory;
     this.bindingGraphConverter = bindingGraphConverter;
     this.bindingGraphValidator = bindingGraphValidator;
+    this.metadataUtil = metadataUtil;
   }
 
   /**
@@ -576,7 +580,8 @@ private void validateModuleVisibility(
   /**
    * Returns {@code true} if a module instance is needed for any of the binding methods on the given
    * {@code module}. This is the case when the module has any binding methods that are neither
-   * {@code abstract} nor {@code static}.
+   * {@code abstract} nor {@code static}. Alternatively, if the module is a Kotlin Object then the
+   * binding methods are considered {@code static}, requiring no module instance.
    */
   private boolean requiresModuleInstance(TypeElement module) {
     // Note elements.getAllMembers(module) rather than module.getEnclosedElements() here: we need to
@@ -584,10 +589,11 @@ private boolean requiresModuleInstance(TypeElement module) {
     // done in this class, which assume that supertype binding methods will be validated in a
     // separate call to the validator since the supertype itself must be a @Module, we need to look
     // at all the binding methods in the module's type hierarchy here.
-    return methodsIn(elements.getAllMembers(module)).stream()
-        .filter(method -> anyBindingMethodValidator.isBindingMethod(method))
-        .map(ExecutableElement::getModifiers)
-        .anyMatch(modifiers -> !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC));
+    return !metadataUtil.isObjectClass(module)
+        && methodsIn(elements.getAllMembers(module)).stream()
+            .filter(anyBindingMethodValidator::isBindingMethod)
+            .map(ExecutableElement::getModifiers)
+            .anyMatch(modifiers -> !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC));
   }
 
   private void validateNoScopeAnnotationsOnModuleElement(
diff --git a/java/dagger/internal/codegen/writing/BUILD b/java/dagger/internal/codegen/writing/BUILD
index d8177a1db..503e28782 100644
--- a/java/dagger/internal/codegen/writing/BUILD
+++ b/java/dagger/internal/codegen/writing/BUILD
@@ -29,6 +29,7 @@ java_library(
         "//java/dagger/internal/codegen/compileroption",
         "//java/dagger/internal/codegen/extension",
         "//java/dagger/internal/codegen/javapoet",
+        "//java/dagger/internal/codegen/kotlin",
         "//java/dagger/internal/codegen/langmodel",
         "//java/dagger/internal/codegen/statistics",
         "//java/dagger/model",
diff --git a/java/dagger/internal/codegen/writing/ComponentBindingExpressions.java b/java/dagger/internal/codegen/writing/ComponentBindingExpressions.java
index 8cd4f233d..fe1a92198 100644
--- a/java/dagger/internal/codegen/writing/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/writing/ComponentBindingExpressions.java
@@ -50,6 +50,7 @@
 import dagger.internal.codegen.binding.ResolvedBindings;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.javapoet.Expression;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.internal.codegen.writing.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
@@ -84,6 +85,7 @@
   private final MembersInjectionMethods membersInjectionMethods;
   private final InnerSwitchingProviders innerSwitchingProviders;
   private final Map<BindingRequest, BindingExpression> expressions = new HashMap<>();
+  private final KotlinMetadataUtil metadataUtil;
 
   @Inject
   ComponentBindingExpressions(
@@ -95,7 +97,8 @@
       DaggerTypes types,
       DaggerElements elements,
       SourceVersion sourceVersion,
-      CompilerOptions compilerOptions) {
+      CompilerOptions compilerOptions,
+      KotlinMetadataUtil metadataUtil) {
     this.parent = parent;
     this.graph = graph;
     this.componentImplementation = componentImplementation;
@@ -106,9 +109,11 @@
     this.sourceVersion = checkNotNull(sourceVersion);
     this.compilerOptions = checkNotNull(compilerOptions);
     this.membersInjectionMethods =
-        new MembersInjectionMethods(componentImplementation, this, graph, elements, types);
+        new MembersInjectionMethods(
+            componentImplementation, this, graph, elements, types, metadataUtil);
     this.innerSwitchingProviders =
         new InnerSwitchingProviders(componentImplementation, this, types);
+    this.metadataUtil = metadataUtil;
   }
 
   /**
@@ -552,7 +557,8 @@ private BindingExpression instanceBindingExpression(ContributionBinding binding)
                 componentRequirementExpressions,
                 types,
                 elements,
-                sourceVersion));
+                sourceVersion,
+                metadataUtil));
 
       case MEMBERS_INJECTOR:
         return Optional.empty();
diff --git a/java/dagger/internal/codegen/writing/FactoryGenerator.java b/java/dagger/internal/codegen/writing/FactoryGenerator.java
index 98cc208cf..b836313a3 100644
--- a/java/dagger/internal/codegen/writing/FactoryGenerator.java
+++ b/java/dagger/internal/codegen/writing/FactoryGenerator.java
@@ -59,6 +59,7 @@
 import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.javapoet.CodeBlocks;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.internal.codegen.statistics.DaggerStatisticsCollector;
@@ -81,6 +82,7 @@
   private final DaggerElements elements;
   private final CompilerOptions compilerOptions;
   private final DaggerStatisticsCollector statisticsCollector;
+  private final KotlinMetadataUtil metadataUtil;
 
   @Inject
   FactoryGenerator(
@@ -89,12 +91,14 @@
       DaggerTypes types,
       DaggerElements elements,
       CompilerOptions compilerOptions,
-      DaggerStatisticsCollector statisticsCollector) {
+      DaggerStatisticsCollector statisticsCollector,
+      KotlinMetadataUtil metadataUtil) {
     super(filer, elements, sourceVersion);
     this.types = types;
     this.elements = elements;
     this.compilerOptions = compilerOptions;
     this.statisticsCollector = statisticsCollector;
+    this.metadataUtil = metadataUtil;
   }
 
   @Override
@@ -137,7 +141,7 @@ public Element originatingElement(ProvisionBinding binding) {
     addCreateMethod(binding, factoryBuilder);
 
     factoryBuilder.addMethod(
-        ProvisionMethod.create(binding, compilerOptions, elements).toMethodSpec());
+        ProvisionMethod.create(binding, compilerOptions, elements, metadataUtil).toMethodSpec());
     gwtIncompatibleAnnotation(binding).ifPresent(factoryBuilder::addAnnotation);
 
     return factoryBuilder;
@@ -257,7 +261,8 @@ private MethodSpec getMethod(ProvisionBinding binding) {
                   ? Optional.of(CodeBlock.of("module"))
                   : Optional.empty(),
               compilerOptions,
-              elements));
+              elements,
+              metadataUtil));
     } else if (!binding.injectionSites().isEmpty()) {
       CodeBlock instance = CodeBlock.of("instance");
       getMethod
@@ -270,7 +275,8 @@ private MethodSpec getMethod(ProvisionBinding binding) {
                   binding.key().type(),
                   types,
                   frameworkFieldUsages(binding.dependencies(), frameworkFields)::get,
-                  elements))
+                  elements,
+                  metadataUtil))
           .addStatement("return $L", instance);
     } else {
       getMethod.addStatement(
diff --git a/java/dagger/internal/codegen/writing/InjectionMethods.java b/java/dagger/internal/codegen/writing/InjectionMethods.java
index 7f13404e1..5b1d8edb3 100644
--- a/java/dagger/internal/codegen/writing/InjectionMethods.java
+++ b/java/dagger/internal/codegen/writing/InjectionMethods.java
@@ -46,6 +46,7 @@
 import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.javapoet.Expression;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.DependencyRequest;
@@ -108,7 +109,10 @@
      * constructor} and injects the instance's members.
      */
     static InjectionMethod create(
-        ProvisionBinding binding, CompilerOptions compilerOptions, DaggerElements elements) {
+        ProvisionBinding binding,
+        CompilerOptions compilerOptions,
+        DaggerElements elements,
+        KotlinMetadataUtil metadataUtil) {
       ClassName proxyEnclosingClass = generatedClassNameForBinding(binding);
       ExecutableElement element = MoreElements.asExecutable(binding.bindingElement().get());
       switch (element.getKind()) {
@@ -121,7 +125,8 @@ static InjectionMethod create(
               methodName(element),
               ReceiverAccessibility.IGNORE,
               CheckNotNullPolicy.get(binding, compilerOptions),
-              elements);
+              elements,
+              metadataUtil);
         default:
           throw new AssertionError(element);
       }
@@ -139,14 +144,16 @@ static CodeBlock invoke(
         ClassName requestingClass,
         Optional<CodeBlock> moduleReference,
         CompilerOptions compilerOptions,
-        DaggerElements elements) {
+        DaggerElements elements,
+        KotlinMetadataUtil metadataUtil) {
       ImmutableList.Builder<CodeBlock> arguments = ImmutableList.builder();
       moduleReference.ifPresent(arguments::add);
       arguments.addAll(
           injectionMethodArguments(
               binding.provisionDependencies(), dependencyUsage, requestingClass));
       // TODO(ronshapiro): make InjectionMethods @Injectable
-      return create(binding, compilerOptions, elements).invoke(arguments.build(), requestingClass);
+      return create(binding, compilerOptions, elements, metadataUtil)
+          .invoke(arguments.build(), requestingClass);
     }
 
     private static InjectionMethod constructorProxy(
@@ -247,7 +254,8 @@ private static String methodName(ExecutableElement method) {
      * receives its own method, as the subclass may need to inject them in a different order from
      * the parent class.
      */
-    static InjectionMethod create(InjectionSite injectionSite, DaggerElements elements) {
+    static InjectionMethod create(
+        InjectionSite injectionSite, DaggerElements elements, KotlinMetadataUtil metadataUtil) {
       String methodName = methodName(injectionSite);
       ClassName proxyEnclosingClass = membersInjectorNameForType(
           MoreElements.asType(injectionSite.element().getEnclosingElement()));
@@ -259,7 +267,8 @@ static InjectionMethod create(InjectionSite injectionSite, DaggerElements elemen
               methodName,
               ReceiverAccessibility.CAST_IF_NOT_PUBLIC,
               CheckNotNullPolicy.IGNORE,
-              elements);
+              elements,
+              metadataUtil);
         case FIELD:
           return fieldProxy(
               proxyEnclosingClass,
@@ -283,9 +292,9 @@ static CodeBlock invokeAll(
         TypeMirror instanceType,
         DaggerTypes types,
         Function<DependencyRequest, CodeBlock> dependencyUsage,
-        DaggerElements elements) {
-      return injectionSites
-          .stream()
+        DaggerElements elements,
+        KotlinMetadataUtil metadataUtil) {
+      return injectionSites.stream()
           .map(
               injectionSite -> {
                 TypeMirror injectSiteType =
@@ -308,7 +317,8 @@ static CodeBlock invokeAll(
                         generatedTypeName,
                         maybeCastedInstance,
                         dependencyUsage,
-                        elements));
+                        elements,
+                        metadataUtil));
               })
           .collect(toConcatenatedCodeBlock());
     }
@@ -322,7 +332,8 @@ private static CodeBlock invoke(
         ClassName generatedTypeName,
         CodeBlock instanceCodeBlock,
         Function<DependencyRequest, CodeBlock> dependencyUsage,
-        DaggerElements elements) {
+        DaggerElements elements,
+        KotlinMetadataUtil metadataUtil) {
       List<CodeBlock> arguments = new ArrayList<>();
       arguments.add(instanceCodeBlock);
       if (!injectionSite.dependencies().isEmpty()) {
@@ -333,7 +344,7 @@ private static CodeBlock invoke(
                 .map(dependencyUsage)
                 .collect(toList()));
       }
-      return create(injectionSite, elements).invoke(arguments, generatedTypeName);
+      return create(injectionSite, elements, metadataUtil).invoke(arguments, generatedTypeName);
     }
 
     /*
@@ -481,12 +492,14 @@ private static InjectionMethod methodProxy(
       String methodName,
       ReceiverAccessibility receiverAccessibility,
       CheckNotNullPolicy checkNotNullPolicy,
-      DaggerElements elements) {
+      DaggerElements elements,
+      KotlinMetadataUtil metadataUtil) {
     TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
+    boolean isMethodInKotlinObject = metadataUtil.isObjectClass(enclosingType);
     InjectionMethod.Builder injectionMethod =
         InjectionMethod.builder(elements).name(methodName).enclosingClass(proxyEnclosingClass);
     ParameterSpec instance = null;
-    if (!method.getModifiers().contains(STATIC)) {
+    if (!isMethodInKotlinObject && !method.getModifiers().contains(STATIC)) {
       instance =
           injectionMethod.addParameter(
               "instance", receiverAccessibility.parameterType(enclosingType.asType(), elements));
@@ -500,7 +513,11 @@ private static InjectionMethod methodProxy(
       injectionMethod.methodBodyBuilder().add("return ");
     }
     CodeBlock.Builder proxyInvocation = CodeBlock.builder();
-    if (method.getModifiers().contains(STATIC)) {
+    if (isMethodInKotlinObject) {
+      // Call through the singleton instance.
+      // See: https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#static-methods
+      proxyInvocation.add("$T.INSTANCE", rawTypeName(TypeName.get(enclosingType.asType())));
+    } else if (method.getModifiers().contains(STATIC)) {
       proxyInvocation.add("$T", rawTypeName(TypeName.get(enclosingType.asType())));
     } else {
       injectionMethod.copyTypeParameters(enclosingType);
diff --git a/java/dagger/internal/codegen/writing/MembersInjectionMethods.java b/java/dagger/internal/codegen/writing/MembersInjectionMethods.java
index 137674b02..4cea71414 100644
--- a/java/dagger/internal/codegen/writing/MembersInjectionMethods.java
+++ b/java/dagger/internal/codegen/writing/MembersInjectionMethods.java
@@ -35,6 +35,7 @@
 import dagger.internal.codegen.binding.MembersInjectionBinding.InjectionSite;
 import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.binding.ResolvedBindings;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.internal.codegen.writing.InjectionMethods.InjectionSiteMethod;
@@ -53,18 +54,21 @@
   private final BindingGraph graph;
   private final DaggerElements elements;
   private final DaggerTypes types;
+  private final KotlinMetadataUtil metadataUtil;
 
   MembersInjectionMethods(
       ComponentImplementation componentImplementation,
       ComponentBindingExpressions bindingExpressions,
       BindingGraph graph,
       DaggerElements elements,
-      DaggerTypes types) {
+      DaggerTypes types,
+      KotlinMetadataUtil metadataUtil) {
     this.componentImplementation = checkNotNull(componentImplementation);
     this.bindingExpressions = checkNotNull(bindingExpressions);
     this.graph = checkNotNull(graph);
     this.elements = checkNotNull(elements);
     this.types = checkNotNull(types);
+    this.metadataUtil = metadataUtil;
   }
 
   /**
@@ -112,7 +116,8 @@ private MethodSpec membersInjectionMethod(Key key) {
                 bindingExpressions
                     .getDependencyArgumentExpression(request, componentImplementation.name())
                     .codeBlock(),
-            elements));
+            elements,
+            metadataUtil));
     methodBuilder.addStatement("return $L", instance);
 
     MethodSpec method = methodBuilder.build();
diff --git a/java/dagger/internal/codegen/writing/MembersInjectorGenerator.java b/java/dagger/internal/codegen/writing/MembersInjectorGenerator.java
index e9dcc342b..01dca35a6 100644
--- a/java/dagger/internal/codegen/writing/MembersInjectorGenerator.java
+++ b/java/dagger/internal/codegen/writing/MembersInjectorGenerator.java
@@ -53,6 +53,7 @@
 import dagger.internal.codegen.binding.FrameworkField;
 import dagger.internal.codegen.binding.MembersInjectionBinding;
 import dagger.internal.codegen.binding.MembersInjectionBinding.InjectionSite;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.internal.codegen.statistics.DaggerStatisticsCollector;
@@ -72,6 +73,7 @@
   private final DaggerTypes types;
   private final DaggerElements elements;
   private final DaggerStatisticsCollector statisticsCollector;
+  private final KotlinMetadataUtil metadataUtil;
 
   @Inject
   MembersInjectorGenerator(
@@ -79,11 +81,13 @@
       DaggerElements elements,
       DaggerTypes types,
       SourceVersion sourceVersion,
-      DaggerStatisticsCollector statisticsCollector) {
+      DaggerStatisticsCollector statisticsCollector,
+      KotlinMetadataUtil metadataUtil) {
     super(filer, elements, sourceVersion);
     this.types = types;
     this.elements = elements;
     this.statisticsCollector = statisticsCollector;
+    this.metadataUtil = metadataUtil;
   }
 
   @Override
@@ -200,7 +204,8 @@ public Element originatingElement(MembersInjectionBinding binding) {
             binding.key().type(),
             types,
             frameworkFieldUsages(binding.dependencies(), dependencyFields)::get,
-            elements));
+            elements,
+            metadataUtil));
 
     if (usesRawFrameworkTypes) {
       injectMembersBuilder.addAnnotation(suppressWarnings(UNCHECKED));
@@ -210,7 +215,7 @@ public Element originatingElement(MembersInjectionBinding binding) {
     for (InjectionSite injectionSite : binding.injectionSites()) {
       if (injectionSite.element().getEnclosingElement().equals(binding.membersInjectedType())) {
         injectorTypeBuilder.addMethod(
-            InjectionSiteMethod.create(injectionSite, elements).toMethodSpec());
+            InjectionSiteMethod.create(injectionSite, elements, metadataUtil).toMethodSpec());
       }
     }
 
diff --git a/java/dagger/internal/codegen/writing/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/writing/SimpleMethodBindingExpression.java
index 062ec8658..c1a1a2587 100644
--- a/java/dagger/internal/codegen/writing/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/writing/SimpleMethodBindingExpression.java
@@ -34,6 +34,7 @@
 import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.javapoet.Expression;
+import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.internal.codegen.writing.InjectionMethods.ProvisionMethod;
@@ -59,6 +60,7 @@
   private final DaggerTypes types;
   private final DaggerElements elements;
   private final SourceVersion sourceVersion;
+  private final KotlinMetadataUtil metadataUtil;
 
   SimpleMethodBindingExpression(
       ProvisionBinding binding,
@@ -68,10 +70,12 @@
       ComponentRequirementExpressions componentRequirementExpressions,
       DaggerTypes types,
       DaggerElements elements,
-      SourceVersion sourceVersion) {
+      SourceVersion sourceVersion,
+      KotlinMetadataUtil metadataUtil) {
     super(binding);
     this.compilerOptions = compilerOptions;
     this.provisionBinding = binding;
+    this.metadataUtil = metadataUtil;
     checkArgument(
         provisionBinding.implicitDependencies().isEmpty(),
         "framework deps are not currently supported");
@@ -150,7 +154,8 @@ private Expression invokeInjectionMethod(
             requestingClass,
             moduleReference(requestingClass),
             compilerOptions,
-            elements));
+            elements,
+            metadataUtil));
   }
 
   private Expression dependencyArgument(DependencyRequest dependency, ClassName requestingClass) {
