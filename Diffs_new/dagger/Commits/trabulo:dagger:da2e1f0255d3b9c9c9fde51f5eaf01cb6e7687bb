diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 881c7f292..4a5a6fcc7 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -176,6 +176,7 @@ java_library(
         "ComponentHierarchyValidator.java",
         "ComponentValidator.java",
         "DependencyRequestFormatter.java",
+        "DependencyRequestValidator.java",
         "ForReleasableReferencesValidator.java",
         "InjectValidator.java",
         "MapKeyValidator.java",
diff --git a/java/dagger/internal/codegen/BindingMethodValidator.java b/java/dagger/internal/codegen/BindingMethodValidator.java
index 8854f13e5..32bc9f0fc 100644
--- a/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -46,6 +46,7 @@
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
@@ -55,6 +56,7 @@
 
   private final DaggerElements elements;
   private final Types types;
+  private final DependencyRequestValidator dependencyRequestValidator;
   private final Class<? extends Annotation> methodAnnotation;
   private final ImmutableSet<? extends Class<? extends Annotation>> enclosingElementAnnotations;
   private final Abstractness abstractness;
@@ -72,6 +74,7 @@
   protected BindingMethodValidator(
       DaggerElements elements,
       Types types,
+      DependencyRequestValidator dependencyRequestValidator,
       Class<? extends Annotation> methodAnnotation,
       Class<? extends Annotation> enclosingElementAnnotation,
       Abstractness abstractness,
@@ -82,6 +85,7 @@ protected BindingMethodValidator(
         types,
         methodAnnotation,
         ImmutableSet.of(enclosingElementAnnotation),
+        dependencyRequestValidator,
         abstractness,
         exceptionSuperclass,
         allowsMultibindings);
@@ -99,6 +103,7 @@ protected BindingMethodValidator(
       Types types,
       Class<? extends Annotation> methodAnnotation,
       Iterable<? extends Class<? extends Annotation>> enclosingElementAnnotations,
+      DependencyRequestValidator dependencyRequestValidator,
       Abstractness abstractness,
       ExceptionSuperclass exceptionSuperclass,
       AllowsMultibindings allowsMultibindings) {
@@ -106,6 +111,7 @@ protected BindingMethodValidator(
     this.types = types;
     this.methodAnnotation = methodAnnotation;
     this.enclosingElementAnnotations = ImmutableSet.copyOf(enclosingElementAnnotations);
+    this.dependencyRequestValidator = dependencyRequestValidator;
     this.abstractness = abstractness;
     this.exceptionSuperclass = exceptionSuperclass;
     this.allowsMultibindings = allowsMultibindings;
@@ -153,6 +159,7 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkMapKeys(builder);
     checkMultibindings(builder);
     checkScopes(builder);
+    checkParameters(builder);
   }
 
   /**
@@ -300,7 +307,10 @@ protected void checkQualifiers(ValidationReport.Builder<ExecutableElement> build
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(builder.getSubject());
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError("Cannot use more than one @Qualifier", builder.getSubject(), qualifier);
+        builder.addError(
+            bindingMethods("may not use more than one @Qualifier"),
+            builder.getSubject(),
+            qualifier);
       }
     }
   }
@@ -374,6 +384,22 @@ protected void checkScopes(ValidationReport.Builder<ExecutableElement> builder)
     }
   }
 
+  /** Adds errors for the method parameters. */
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+    for (VariableElement parameter : builder.getSubject().getParameters()) {
+      checkParameter(builder, parameter);
+    }
+  }
+
+  /**
+   * Adds errors for a method parameter. This implementation reports an error if the parameter has
+   * more than one qualifier.
+   */
+  protected void checkParameter(
+      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
+    dependencyRequestValidator.validateDependencyRequest(builder, parameter, parameter.asType());
+  }
+
   /** Adds an error if the method returns a {@linkplain FrameworkTypes framework type}. */
   protected void checkFrameworkType(ValidationReport.Builder<ExecutableElement> builder) {
     if (FrameworkTypes.isFrameworkType(builder.getSubject().getReturnType())) {
diff --git a/java/dagger/internal/codegen/BindsMethodValidator.java b/java/dagger/internal/codegen/BindsMethodValidator.java
index 78909e84e..a9b15d135 100644
--- a/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
@@ -26,7 +25,6 @@
 import dagger.Binds;
 import dagger.Module;
 import dagger.producers.ProducerModule;
-import java.util.List;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
@@ -41,12 +39,14 @@
   private final BindsTypeChecker bindsTypeChecker;
 
   @Inject
-  BindsMethodValidator(DaggerElements elements, Types types) {
+  BindsMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         Binds.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         RUNTIME_EXCEPTION,
         ALLOWS_MULTIBINDINGS);
@@ -60,29 +60,36 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkParameters(builder);
   }
 
-  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     ExecutableElement method = builder.getSubject();
-    List<? extends VariableElement> parameters = method.getParameters();
-    if (parameters.size() == 1) {
-      VariableElement parameter = getOnlyElement(parameters);
-      TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
-      TypeMirror rightHandSide = parameter.asType();
-      ContributionType contributionType = ContributionType.fromBindingMethod(method);
-      if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
-        builder.addError(
-            "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter");
-      }
-
-      if (!bindsTypeChecker.isAssignable(rightHandSide, leftHandSide, contributionType)) {
-        // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
-        // right-hand-side might not be assignable to the left-hand-side, but still compatible with
-        // Set.addAll(Collection<? extends E>)
-        builder.addError("@Binds methods' parameter type must be assignable to the return type");
-      }
+    if (method.getParameters().size() != 1) {
+      builder.addError(
+          bindingMethods(
+              "must have exactly one parameter, whose type is assignable to the return type"));
     } else {
+      super.checkParameters(builder);
+    }
+  }
+
+  @Override
+  protected void checkParameter(
+      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
+    super.checkParameter(builder, parameter);
+    ExecutableElement method = builder.getSubject();
+    TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
+    TypeMirror rightHandSide = parameter.asType();
+    ContributionType contributionType = ContributionType.fromBindingMethod(method);
+    if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
       builder.addError(
-          "@Binds methods must have exactly one parameter, "
-              + "whose type is assignable to the return type");
+          "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter");
+    }
+
+    if (!bindsTypeChecker.isAssignable(rightHandSide, leftHandSide, contributionType)) {
+      // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
+      // right-hand-side might not be assignable to the left-hand-side, but still compatible with
+      // Set.addAll(Collection<? extends E>)
+      builder.addError("@Binds methods' parameter type must be assignable to the return type");
     }
   }
 
diff --git a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
index dfb84ab69..c12dd78d7 100644
--- a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -42,12 +42,14 @@
   private final Types types;
 
   @Inject
-  BindsOptionalOfMethodValidator(DaggerElements elements, Types types) {
+  BindsOptionalOfMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         BindsOptionalOf.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         NO_EXCEPTIONS,
         NO_MULTIBINDINGS);
@@ -74,7 +76,8 @@ protected void checkKeyType(
     }
   }
 
-  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getParameters().isEmpty()) {
       builder.addError("@BindsOptionalOf methods cannot have parameters");
     }
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index 671f0857a..3ed0ae801 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -82,6 +82,7 @@
   private final Types types;
   private final ModuleValidator moduleValidator;
   private final BuilderValidator builderValidator;
+  private final DependencyRequestValidator dependencyRequestValidator;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFactory dependencyRequestFactory;
 
@@ -91,12 +92,14 @@
       Types types,
       ModuleValidator moduleValidator,
       BuilderValidator builderValidator,
+      DependencyRequestValidator dependencyRequestValidator,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFactory dependencyRequestFactory) {
     this.elements = elements;
     this.types = types;
     this.moduleValidator = moduleValidator;
     this.builderValidator = builderValidator;
+    this.dependencyRequestValidator = dependencyRequestValidator;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFactory = dependencyRequestFactory;
   }
@@ -199,7 +202,8 @@ public ComponentValidationReport validate(
                 switch (parameters.size()) {
                   case 0:
                     // no parameters means that it is a provision method
-                    // basically, there are no restrictions here.  \o/
+                    dependencyRequestValidator.validateDependencyRequest(
+                        report, method, returnType);
                     break;
                   case 1:
                     // one parameter means that it's a members injection method
diff --git a/java/dagger/internal/codegen/DependencyRequestValidator.java b/java/dagger/internal/codegen/DependencyRequestValidator.java
new file mode 100644
index 000000000..eb9642215
--- /dev/null
+++ b/java/dagger/internal/codegen/DependencyRequestValidator.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.RequestKinds.extractKeyType;
+import static dagger.internal.codegen.RequestKinds.getRequestKind;
+import static javax.lang.model.type.TypeKind.WILDCARD;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+/** Validation for dependency requests. */
+final class DependencyRequestValidator {
+  @Inject
+  DependencyRequestValidator() {}
+
+  /**
+   * Adds an error if the given dependency request has more than one qualifier annotation or is a
+   * non-instance request with a wildcard type.
+   */
+  void validateDependencyRequest(
+      ValidationReport.Builder<?> report, Element requestElement, TypeMirror requestType) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(requestElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        report.addError(
+            "A single dependency request may not use more than one @Qualifier",
+            requestElement,
+            qualifier);
+      }
+    }
+
+    TypeMirror keyType = extractKeyType(getRequestKind(requestType), requestType);
+    if (keyType.getKind().equals(WILDCARD)) {
+      // TODO(ronshapiro): Explore creating this message using RequestKinds.
+      report.addError(
+          "Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, "
+              + "or Produced<T> when T is a wildcard type such as "
+              + keyType,
+          requestElement);
+    }
+  }
+
+  /**
+   * Adds an error if the given dependency request is for a {@link dagger.producers.Producer} or
+   * {@link dagger.producers.Produced}.
+   *
+   * <p>Only call this when processing a provision binding.
+   */
+  // TODO(dpb): Should we disallow Producer entry points in non-production components?
+  void checkNotProducer(ValidationReport.Builder<?> report, VariableElement requestElement) {
+    TypeMirror requestType = requestElement.asType();
+    if (FrameworkTypes.isProducerType(requestType)) {
+      report.addError(
+          String.format(
+              "%s may only be injected in @Produces methods",
+              MoreTypes.asTypeElement(requestType).getSimpleName()),
+          requestElement);
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 95d66951b..909b4f5ab 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
@@ -28,12 +27,6 @@
  */
 final class ErrorMessages {
 
-  static String provisionMayNotDependOnProducerType(TypeMirror type) {
-    return String.format(
-        "%s may only be injected in @Produces methods",
-        MoreTypes.asTypeElement(type).getSimpleName());
-  }
-
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
       case COMPONENT:
diff --git a/java/dagger/internal/codegen/InjectValidator.java b/java/dagger/internal/codegen/InjectValidator.java
index 4d6c89b03..b912fcbcd 100644
--- a/java/dagger/internal/codegen/InjectValidator.java
+++ b/java/dagger/internal/codegen/InjectValidator.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.Scopes.scopesOf;
@@ -46,6 +45,7 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
+import javax.tools.Diagnostic.Kind;
 
 /**
  * A {@linkplain ValidationReport validator} for {@link Inject}-annotated elements and the types
@@ -55,21 +55,28 @@
   private final Types types;
   private final DaggerElements elements;
   private final CompilerOptions compilerOptions;
+  private final DependencyRequestValidator dependencyRequestValidator;
   private final Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind;
 
   @Inject
-  InjectValidator(Types types, DaggerElements elements, CompilerOptions compilerOptions) {
-    this(types, elements, compilerOptions, Optional.empty());
+  InjectValidator(
+      Types types,
+      DaggerElements elements,
+      DependencyRequestValidator dependencyRequestValidator,
+      CompilerOptions compilerOptions) {
+    this(types, elements, compilerOptions, dependencyRequestValidator, Optional.empty());
   }
 
   private InjectValidator(
       Types types,
       DaggerElements elements,
       CompilerOptions compilerOptions,
-      Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind) {
+      DependencyRequestValidator dependencyRequestValidator,
+      Optional<Kind> privateAndStaticInjectionDiagnosticKind) {
     this.types = types;
     this.elements = elements;
     this.compilerOptions = compilerOptions;
+    this.dependencyRequestValidator = dependencyRequestValidator;
     this.privateAndStaticInjectionDiagnosticKind = privateAndStaticInjectionDiagnosticKind;
   }
 
@@ -79,7 +86,12 @@ private InjectValidator(
    */
   InjectValidator whenGeneratingCode() {
     return compilerOptions.ignorePrivateAndStaticInjectionForComponent()
-        ? new InjectValidator(types, elements, compilerOptions, Optional.of(Diagnostic.Kind.ERROR))
+        ? new InjectValidator(
+            types,
+            elements,
+            compilerOptions,
+            dependencyRequestValidator,
+            Optional.of(Diagnostic.Kind.ERROR))
         : this;
   }
 
@@ -106,10 +118,7 @@ InjectValidator whenGeneratingCode() {
     }
 
     for (VariableElement parameter : constructorElement.getParameters()) {
-      checkMultipleQualifiers(constructorElement, parameter, builder);
-      if (FrameworkTypes.isProducerType(parameter.asType())) {
-        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
-      }
+      validateDependencyRequest(builder, parameter);
     }
 
     if (throwsCheckedExceptions(constructorElement)) {
@@ -182,11 +191,7 @@ InjectValidator whenGeneratingCode() {
           fieldElement);
     }
 
-    checkMultipleQualifiers(fieldElement, fieldElement, builder);
-
-    if (FrameworkTypes.isProducerType(fieldElement.asType())) {
-      builder.addError(provisionMayNotDependOnProducerType(fieldElement.asType()), fieldElement);
-    }
+    validateDependencyRequest(builder, fieldElement);
 
     return builder.build();
   }
@@ -219,15 +224,18 @@ InjectValidator whenGeneratingCode() {
     }
 
     for (VariableElement parameter : methodElement.getParameters()) {
-      checkMultipleQualifiers(methodElement, parameter, builder);
-      if (FrameworkTypes.isProducerType(parameter.asType())) {
-        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
-      }
+      validateDependencyRequest(builder, parameter);
     }
 
     return builder.build();
   }
 
+  private void validateDependencyRequest(
+      ValidationReport.Builder<?> builder, VariableElement parameter) {
+    dependencyRequestValidator.validateDependencyRequest(builder, parameter, parameter.asType());
+    dependencyRequestValidator.checkNotProducer(builder, parameter);
+  }
+
   ValidationReport<TypeElement> validateMembersInjectionType(TypeElement typeElement) {
     // TODO(beder): This element might not be currently compiled, so this error message could be
     // left in limbo. Find an appropriate way to display the error message in that case.
@@ -304,22 +312,6 @@ private boolean throwsCheckedExceptions(ExecutableElement methodElement) {
     return false;
   }
 
-  // TODO(dpb,ronshapiro): Use this on AnyBindingMethodValidator, or a DependencyRequestValidator.
-  // Currently, @Provides and @Produces methods with multiple qualifiers on a dependency will crash
-  // the compiler.
-  private void checkMultipleQualifiers(
-      Element errorElement, Element qualifiedElement, ValidationReport.Builder<?> builder) {
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(qualifiedElement);
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(
-            "A single injection site may not use more than one @Qualifier",
-            errorElement,
-            qualifier);
-      }
-    }
-  }
-
   private void checkInjectIntoPrivateClass(Element element, Builder<TypeElement> builder) {
     if (!Accessibility.isElementAccessibleFromOwnPackage(
         DaggerElements.closestEnclosingTypeElement(element))) {
diff --git a/java/dagger/internal/codegen/KytheBindingGraphFactory.java b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
index 1af20601c..28b724fbe 100644
--- a/java/dagger/internal/codegen/KytheBindingGraphFactory.java
+++ b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
@@ -111,21 +111,17 @@ static CompilerOptions createCompilerOptions() {
   private static BindingGraphFactory createBindingGraphFactory(
       DaggerTypes types, DaggerElements elements, CompilerOptions compilerOptions) {
     KeyFactory keyFactory = new KeyFactory(types, elements);
-    DependencyRequestFactory dependencyRequestFactory =
-        new DependencyRequestFactory(keyFactory, types);
-    Messager messager = new NullMessager();
 
     BindingFactory bindingFactory =
-        new BindingFactory(types, elements, keyFactory, dependencyRequestFactory);
-
-    InjectValidator injectMethodValidator = new InjectValidator(types, elements, compilerOptions);
+        new BindingFactory(
+            types, elements, keyFactory, new DependencyRequestFactory(keyFactory, types));
 
     InjectBindingRegistry injectBindingRegistry =
         new InjectBindingRegistryImpl(
             elements,
             types,
-            messager,
-            injectMethodValidator,
+            new NullMessager(),
+            new InjectValidator(types, elements, new DependencyRequestValidator(), compilerOptions),
             keyFactory,
             bindingFactory,
             compilerOptions);
diff --git a/java/dagger/internal/codegen/MissingBindingValidation.java b/java/dagger/internal/codegen/MissingBindingValidation.java
index 811c5624a..b3c597cbd 100644
--- a/java/dagger/internal/codegen/MissingBindingValidation.java
+++ b/java/dagger/internal/codegen/MissingBindingValidation.java
@@ -20,6 +20,7 @@
 import static com.google.auto.common.MoreTypes.asTypeElement;
 import static com.google.auto.common.MoreTypes.isType;
 import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
@@ -97,25 +98,19 @@ private void reportMissingBinding(
   private String missingBindingErrorMessage(DependencyEdge edge, BindingGraph graph) {
     Key key = edge.dependencyRequest().key();
     StringBuilder errorMessage = new StringBuilder();
-    // TODO(dpb): Check for wildcard injection somewhere else first?
-    if (key.type().getKind().equals(TypeKind.WILDCARD)) {
-      // TODO(ronshapiro): Explore creating this message using RequestKinds.
-      errorMessage
-          .append("Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, ")
-          .append("or Produced<T> when T is a wildcard type such as ")
-          .append(key);
-    } else {
-      // TODO(ronshapiro): replace "provided" with "satisfied"?
-      errorMessage.append(key).append(" cannot be provided without ");
-      if (isValidImplicitProvisionKey(key, types)) {
-        errorMessage.append("an @Inject constructor or ");
-      }
-      errorMessage.append("an @Provides-"); // TODO(dpb): s/an/a
-      if (dependencyCanBeProduction(edge, graph)) {
-        errorMessage.append(" or @Produces-");
-      }
-      errorMessage.append("annotated method.");
+    // Wildcards should have already been checked by DependencyRequestValidator.
+    verify(
+        !key.type().getKind().equals(TypeKind.WILDCARD), "unexpected wildcard request: %s", edge);
+    // TODO(ronshapiro): replace "provided" with "satisfied"?
+    errorMessage.append(key).append(" cannot be provided without ");
+    if (isValidImplicitProvisionKey(key, types)) {
+      errorMessage.append("an @Inject constructor or ");
+    }
+    errorMessage.append("an @Provides-"); // TODO(dpb): s/an/a
+    if (dependencyCanBeProduction(edge, graph)) {
+      errorMessage.append(" or @Produces-");
     }
+    errorMessage.append("annotated method.");
     if (isValidMembersInjectionKey(key) && typeHasInjectionSites(key)) {
       errorMessage.append(
           " This type supports members injection but cannot be implicitly provided.");
diff --git a/java/dagger/internal/codegen/MultibindsMethodValidator.java b/java/dagger/internal/codegen/MultibindsMethodValidator.java
index bfac2839a..8e8765d08 100644
--- a/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -36,12 +36,14 @@
 
   /** Creates a validator for {@link Multibinds @Multibinds} methods. */
   @Inject
-  MultibindsMethodValidator(DaggerElements elements, Types types) {
+  MultibindsMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         Multibinds.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         NO_EXCEPTIONS,
         NO_MULTIBINDINGS);
@@ -54,7 +56,8 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkParameters(builder);
   }
 
-  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getParameters().isEmpty()) {
       builder.addError(bindingMethods("cannot have parameters"));
     }
diff --git a/java/dagger/internal/codegen/ProducesMethodValidator.java b/java/dagger/internal/codegen/ProducesMethodValidator.java
index 52ffd672e..5a043da4c 100644
--- a/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -41,10 +41,12 @@
 final class ProducesMethodValidator extends BindingMethodValidator {
 
   @Inject
-  ProducesMethodValidator(DaggerElements elements, Types types) {
+  ProducesMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
+        dependencyRequestValidator,
         Produces.class,
         ProducerModule.class,
         MUST_BE_CONCRETE,
diff --git a/java/dagger/internal/codegen/ProvidesMethodValidator.java b/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 8f7cf1a17..c4d409f14 100644
--- a/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -19,7 +19,6 @@
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
-import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
@@ -35,30 +34,33 @@
  */
 final class ProvidesMethodValidator extends BindingMethodValidator {
 
+  private final DependencyRequestValidator dependencyRequestValidator;
+
   @Inject
-  ProvidesMethodValidator(DaggerElements elements, Types types) {
+  ProvidesMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         Provides.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_CONCRETE,
         RUNTIME_EXCEPTION,
         ALLOWS_MULTIBINDINGS);
+    this.dependencyRequestValidator = dependencyRequestValidator;
   }
 
   @Override
   protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
     super.checkMethod(builder);
-    checkDependsOnProducers(builder);
   }
 
   /** Adds an error if a {@link Provides @Provides} method depends on a producer type. */
-  private void checkDependsOnProducers(ValidationReport.Builder<ExecutableElement> builder) {
-    for (VariableElement parameter : builder.getSubject().getParameters()) {
-      if (FrameworkTypes.isProducerType(parameter.asType())) {
-        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
-      }
-    }
+  @Override
+  protected void checkParameter(
+      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
+    super.checkParameter(builder, parameter);
+    dependencyRequestValidator.checkNotProducer(builder, parameter);
   }
 }
diff --git a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java b/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
index 07c07859e..479e8031c 100644
--- a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
+++ b/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
@@ -92,13 +92,21 @@ public void returnsVoid() {
   }
 
   @Test
-  public void tooManyQualifiers() {
+  public void tooManyQualifiersOnMethod() {
     assertThatMethod(
             "@Binds @Qualifier1 @Qualifier2 abstract String tooManyQualifiers(String impl);")
         .importing(Qualifier1.class, Qualifier2.class)
         .hasError("more than one @Qualifier");
   }
 
+  @Test
+  public void tooManyQualifiersOnParameter() {
+    assertThatMethod(
+            "@Binds abstract String tooManyQualifiers(@Qualifier1 @Qualifier2 String impl);")
+        .importing(Qualifier1.class, Qualifier2.class)
+        .hasError("more than one @Qualifier");
+  }
+
   @Test
   public void noParameters() {
     assertThatMethod("@Binds abstract Object noParameters();").hasError("one parameter");
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index 7b0d7f6e5..f9821b3c6 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -983,6 +983,37 @@ public void missingBindingWithSameKeyAsMembersInjectionMethod() {
         .onLineContaining("void inject(Self target);");
   }
 
+  @Test
+  public void genericInjectClassWithWildcardDependencies() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Foo<? extends Number> foo();",
+            "}");
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Foo<T> {",
+            "  @Inject Foo(T t) {}",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component, foo);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.Foo<? extends java.lang.Number> cannot be provided "
+                + "without an @Provides-annotated method");
+  }
+
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
diff --git a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 21de94a06..a852752e2 100644
--- a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -564,7 +564,7 @@
     assertThat(compilation).failed();
     // for whatever reason, javac only reports the error once on the constructor
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6);
   }
@@ -824,12 +824,12 @@
     Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6)
         .atColumn(11);
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6)
         .atColumn(23);
@@ -943,7 +943,7 @@
     Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6);
   }
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index c10e2a266..ca9cc9550 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -1300,14 +1300,13 @@ public void genericSubclassedModule() {
           "",
           "@Qualifier @interface QualifierB {}");
 
-  @Test public void providesMethodMultipleQualifiers() {
+  @Test
+  public void providesMethodMultipleQualifiersOnMethod() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
         "import dagger.Module;",
         "import dagger.Provides;",
-        "import javax.annotation.Nullable;",
-        "import javax.inject.Singleton;",
         "",
         "@Module",
         "final class TestModule {",
@@ -1317,7 +1316,53 @@ public void genericSubclassedModule() {
         "}");
     Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("Cannot use more than one @Qualifier");
+    assertThat(compilation).hadErrorContaining("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void providesMethodMultipleQualifiersOnParameter() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides static String provideString(@QualifierA @QualifierB Object object) {",
+            "    return \"foo\";",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void providesMethodWildcardDependency() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides static String provideString(Provider<? extends Number> numberProvider) {",
+            "    return \"foo\";",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, or Produced<T> "
+                + "when T is a wildcard type such as ? extends java.lang.Number");
   }
 
   private static final JavaFileObject SCOPE_A =
diff --git a/javatests/dagger/internal/codegen/MultibindsValidatorTest.java b/javatests/dagger/internal/codegen/MultibindsValidatorTest.java
index 6f642f603..cdd74df0d 100644
--- a/javatests/dagger/internal/codegen/MultibindsValidatorTest.java
+++ b/javatests/dagger/internal/codegen/MultibindsValidatorTest.java
@@ -141,7 +141,7 @@ public void overqualifiedSet() {
                 + "abstract Set<Object> tooManyQualifiersSet();")
         .withDeclaration(moduleDeclaration)
         .importing(SomeQualifier.class, OtherQualifier.class)
-        .hasError("Cannot use more than one @Qualifier");
+        .hasError("may not use more than one @Qualifier");
   }
 
   @Test
@@ -151,7 +151,7 @@ public void overqualifiedMap() {
                 + "abstract Map<String, Object> tooManyQualifiersMap();")
         .withDeclaration(moduleDeclaration)
         .importing(SomeQualifier.class, OtherQualifier.class)
-        .hasError("Cannot use more than one @Qualifier");
+        .hasError("may not use more than one @Qualifier");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 5169ced35..cd9a97779 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -466,11 +466,32 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
         .generatesSources(factoryFile);
   }
 
-  @Test public void producesMethodMultipleQualifiers() {
+  @Test
+  public void producesMethodMultipleQualifiersOnMethod() {
+    assertThatProductionModuleMethod(
+            "@Produces @QualifierA @QualifierB static String produceString() { return null; }")
+        .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
+        .hasError("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void producesMethodMultipleQualifiersOnParameter() {
     assertThatProductionModuleMethod(
-            "@Produces @QualifierA @QualifierB abstract String produceString() { return null; }")
+            "@Produces static String produceString(@QualifierA @QualifierB Object input) "
+                + "{ return null; }")
         .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
-        .hasError("Cannot use more than one @Qualifier");
+        .hasError("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void producesMethodWildcardDependency() {
+    assertThatProductionModuleMethod(
+            "@Produces static String produceString(Provider<? extends Number> numberProvider) "
+                + "{ return null; }")
+        .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
+        .hasError(
+            "Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, or Produced<T> "
+                + "when T is a wildcard type such as ? extends java.lang.Number");
   }
 
   @Qualifier
