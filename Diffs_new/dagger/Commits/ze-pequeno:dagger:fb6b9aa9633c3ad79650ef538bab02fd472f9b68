diff --git a/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index a921825d7..770b2fc83 100644
--- a/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -71,22 +71,16 @@ private void validateSubcomponentMethods(
         componentDescriptor.subcomponentsByFactoryMethod().entrySet()) {
       ComponentMethodDescriptor subcomponentMethodDescriptor = subcomponentEntry.getKey();
       ComponentDescriptor subcomponentDescriptor = subcomponentEntry.getValue();
-      // validate the way that we create subcomponents
-      for (VariableElement factoryMethodParameter :
-          subcomponentMethodDescriptor.methodElement().getParameters()) {
-        TypeElement moduleType = MoreTypes.asTypeElement(factoryMethodParameter.asType());
-        TypeElement originatingComponent = existingModuleToOwners.get(moduleType);
-        if (originatingComponent != null) {
-          /* Factory method tries to pass a module that is already present in the parent.
-           * This is an error. */
-          report.addError(
-              String.format(
-                  "%s is present in %s. A subcomponent cannot use an instance of a "
-                      + "module that differs from its parent.",
-                  moduleType.getSimpleName(), originatingComponent.getQualifiedName()),
-              factoryMethodParameter);
-        }
+
+      if (subcomponentDescriptor.hasBuilder()) {
+        report.addError(
+            "Components may not have factory methods for subcomponents that define a builder.",
+            subcomponentMethodDescriptor.methodElement());
+      } else {
+        validateFactoryMethodParameters(
+            report, subcomponentMethodDescriptor, existingModuleToOwners);
       }
+
       validateSubcomponentMethods(
           report,
           subcomponentDescriptor,
@@ -102,6 +96,27 @@ private void validateSubcomponentMethods(
     }
   }
 
+  private void validateFactoryMethodParameters(
+      ValidationReport.Builder<?> report,
+      ComponentMethodDescriptor subcomponentMethodDescriptor,
+      ImmutableMap<TypeElement, TypeElement> existingModuleToOwners) {
+    for (VariableElement factoryMethodParameter :
+        subcomponentMethodDescriptor.methodElement().getParameters()) {
+      TypeElement moduleType = MoreTypes.asTypeElement(factoryMethodParameter.asType());
+      TypeElement originatingComponent = existingModuleToOwners.get(moduleType);
+      if (originatingComponent != null) {
+        /* Factory method tries to pass a module that is already present in the parent.
+         * This is an error. */
+        report.addError(
+            String.format(
+                "%s is present in %s. A subcomponent cannot use an instance of a "
+                    + "module that differs from its parent.",
+                moduleType.getSimpleName(), originatingComponent.getQualifiedName()),
+            factoryMethodParameter);
+      }
+    }
+  }
+
   /**
    * Checks that components do not have any scopes that are also applied on any of their ancestors.
    */
diff --git a/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java b/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
index 757d5d7cc..d8c784ba2 100644
--- a/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
+++ b/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
@@ -123,4 +123,52 @@ public void productionComponents_productionScopeImplicitOnBoth() {
         daggerCompiler().compile(component, subcomponent, parentModule, childModule);
     assertThat(compilation).succeeded();
   }
+
+  @Test
+  public void factoryMethodForSubcomponentWithBuilder_isNotAllowed() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module(subcomponents = Sub.class)",
+            "class TestModule {",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Sub {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Sub build();",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface C {",
+            "  Sub newSub();",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(module, component, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "Components may not have factory methods for subcomponents that define a builder.");
+  }
 }
diff --git a/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java b/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
index 67d6b304e..7ac72f2b9 100644
--- a/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
+++ b/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
@@ -413,7 +413,7 @@ public void cyclicDependencyInSubcomponentsWithChildren() {
             "interface Child {",
             "  String entry();",
             "",
-            "  Grandchild grandchild();",
+            "  Grandchild.Builder grandchild();",
             "",
             "  @Subcomponent.Builder",
             "  interface Builder {",
