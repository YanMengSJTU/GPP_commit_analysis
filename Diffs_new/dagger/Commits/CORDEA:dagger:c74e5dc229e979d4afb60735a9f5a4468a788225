diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 7e1c1fe7e..e1e25ad8f 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -18,7 +18,6 @@
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.DaggerStreams.presentValues;
-import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
@@ -35,6 +34,7 @@
 import java.util.Collection;
 import java.util.Map;
 import java.util.Optional;
+import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -102,6 +102,7 @@ TypeElement componentTypeElement() {
    */
   abstract ImmutableSet<ModuleDescriptor> ownedModules();
 
+  @Memoized
   ImmutableSet<TypeElement> ownedModuleTypes() {
     return FluentIterable.from(ownedModules()).transform(ModuleDescriptor::moduleElement).toSet();
   }
@@ -157,8 +158,7 @@ TypeElement componentTypeElement() {
     return componentRequirements(
         StreamSupport.stream(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this).spliterator(), false)
             .flatMap(graph -> graph.contributionBindings().values().stream())
-            .flatMap(bindings -> bindings.contributionBindings().stream())
-        .collect(toImmutableSet()));
+            .flatMap(bindings -> bindings.contributionBindings().stream()));
   }
 
   /**
@@ -178,8 +178,7 @@ TypeElement componentTypeElement() {
     return componentRequirements(
         StreamSupport.stream(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this).spliterator(), false)
             .flatMap(graph -> graph.ownedModules().stream())
-            .flatMap(module -> module.bindings().stream())
-            .collect(toImmutableSet()));
+            .flatMap(module -> module.bindings().stream()));
   }
 
   /**
@@ -192,11 +191,15 @@ TypeElement componentTypeElement() {
    * </ul>
    */
   private ImmutableSet<ComponentRequirement> componentRequirements(
-      ImmutableSet<ContributionBinding> bindings) {
+      // accept Stream instead of ImmutableSet so the binding instances don't need to be
+      // materialized in a large set + hashed. Even though this is in support of implementing
+      // methods that are themselves memoized, they still have a measurable impact on performance
+      Stream<ContributionBinding> bindings) {
     ImmutableSet.Builder<ComponentRequirement> requirements = ImmutableSet.builder();
-    bindings.stream()
+    bindings
         .filter(ContributionBinding::requiresModuleInstance)
         .map(ContributionBinding::contributingModule)
+        .distinct()
         .flatMap(presentValues())
         .filter(module -> ownedModuleTypes().contains(module))
         .map(module -> ComponentRequirement.forModule(module.asType()))
diff --git a/java/dagger/internal/codegen/MembersInjectionBinding.java b/java/dagger/internal/codegen/MembersInjectionBinding.java
index ac9f6811d..75912a553 100644
--- a/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -80,6 +80,11 @@ boolean hasLocalInjectionSites() {
                 injectionSite.element().getEnclosingElement().equals(membersInjectedType()));
   }
 
+  @Override
+  boolean requiresModuleInstance() {
+    return false;
+  }
+
   @AutoValue
   abstract static class InjectionSite {
     enum Kind {
diff --git a/java/dagger/internal/codegen/ProductionBinding.java b/java/dagger/internal/codegen/ProductionBinding.java
index 12a6c3ecf..ebea14b24 100644
--- a/java/dagger/internal/codegen/ProductionBinding.java
+++ b/java/dagger/internal/codegen/ProductionBinding.java
@@ -20,6 +20,7 @@
 import static dagger.internal.codegen.DaggerTypes.isFutureType;
 
 import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -98,6 +99,14 @@ static ProductionKind fromProducesMethod(ExecutableElement producesMethod) {
    */
   abstract Optional<DependencyRequest> monitorRequest();
 
+  // Profiling determined that this method is called enough times that memoizing it had a measurable
+  // performance improvement for large components.
+  @Memoized
+  @Override
+  boolean requiresModuleInstance() {
+    return super.requiresModuleInstance();
+  }
+
   static Builder builder() {
     return new AutoValue_ProductionBinding.Builder()
         .explicitDependencies(ImmutableList.<DependencyRequest>of())
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index 492cefc24..70c9aa084 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -97,6 +97,14 @@ boolean shouldCheckForNull(CompilerOptions compilerOptions) {
         && compilerOptions.doCheckForNulls();
   }
 
+  // Profiling determined that this method is called enough times that memoizing it had a measurable
+  // performance improvement for large components.
+  @Memoized
+  @Override
+  boolean requiresModuleInstance() {
+    return super.requiresModuleInstance();
+  }
+
   @AutoValue.Builder
   @CanIgnoreReturnValue
   abstract static class Builder extends ContributionBinding.Builder<ProvisionBinding, Builder> {
diff --git a/java/dagger/internal/codegen/ResolvedBindings.java b/java/dagger/internal/codegen/ResolvedBindings.java
index f88cbaf06..5d1334eff 100644
--- a/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/java/dagger/internal/codegen/ResolvedBindings.java
@@ -131,7 +131,8 @@ final boolean isEmpty() {
    * All contribution bindings, regardless of owning component. Empty if this is a members-injection
    * binding.
    */
-  final ImmutableSet<ContributionBinding> contributionBindings() {
+  @Memoized
+  ImmutableSet<ContributionBinding> contributionBindings() {
     return ImmutableSet.copyOf(allContributionBindings().values());
   }
 
