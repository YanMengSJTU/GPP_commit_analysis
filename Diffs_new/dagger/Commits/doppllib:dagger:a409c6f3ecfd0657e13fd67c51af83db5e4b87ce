diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 529062f2c..26ebfdfbf 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -69,13 +69,12 @@
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /** Creates the implementation class for a component or subcomponent. */
 abstract class AbstractComponentWriter implements GeneratedComponentModel {
   // TODO(dpb): Make all these fields private after refactoring is complete.
   protected final Elements elements;
-  protected final Types types;
+  protected final DaggerTypes types;
   protected final Key.Factory keyFactory;
   protected final CompilerOptions compilerOptions;
   protected final ClassName name;
@@ -110,7 +109,7 @@
   private ImmutableMap<Scope, MemberSelect> referenceReleasingProviderManagerFields;
 
   AbstractComponentWriter(
-      Types types,
+      DaggerTypes types,
       Elements elements,
       Key.Factory keyFactory,
       CompilerOptions compilerOptions,
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 7518ef3bd..caf649b0a 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -26,7 +26,6 @@
 import com.squareup.javapoet.FieldSpec;
 import java.util.Optional;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /** A factory of code expressions used to access a single binding in a component. */
 abstract class BindingExpression {
@@ -60,7 +59,7 @@ abstract Expression getDependencyExpression(
     private final GeneratedComponentModel generatedComponentModel;
     private final ImmutableMap<BindingKey, String> subcomponentNames;
     private final BindingGraph graph;
-    private final Types types;
+    private final DaggerTypes types;
     private final Elements elements;
     private final OptionalFactories optionalFactories;
 
@@ -73,7 +72,7 @@ abstract Expression getDependencyExpression(
         GeneratedComponentModel generatedComponentModel,
         ImmutableMap<BindingKey, String> subcomponentNames,
         BindingGraph graph,
-        Types types,
+        DaggerTypes types,
         Elements elements,
         OptionalFactories optionalFactories) {
       this.compilerOptions = checkNotNull(compilerOptions);
@@ -171,15 +170,14 @@ private BindingExpression create(
       switch (provisionBinding.bindingKind()) {
         case COMPONENT:
           return new ComponentInstanceBindingExpression(
-              bindingExpression, provisionBinding, componentName, types, elements);
+              bindingExpression, provisionBinding, componentName, types);
 
         case COMPONENT_DEPENDENCY:
           return new BoundInstanceBindingExpression(
               bindingExpression,
               ComponentRequirement.forDependency(provisionBinding.key().type()),
               componentRequirementFields,
-              types,
-              elements);
+              types);
 
         case COMPONENT_PROVISION:
           return new ComponentProvisionBindingExpression(
@@ -188,16 +186,14 @@ private BindingExpression create(
               graph,
               componentRequirementFields,
               compilerOptions,
-              types,
-              elements);
+              types);
 
         case SUBCOMPONENT_BUILDER:
           return new SubcomponentBuilderBindingExpression(
               bindingExpression,
               provisionBinding,
               subcomponentNames.get(resolvedBindings.bindingKey()),
-              types,
-              elements);
+              types);
 
         case SYNTHETIC_MULTIBOUND_SET:
           return new SetBindingExpression(
@@ -219,15 +215,14 @@ private BindingExpression create(
 
         case SYNTHETIC_OPTIONAL_BINDING:
           return new OptionalBindingExpression(
-              provisionBinding, bindingExpression, componentBindingExpressions, types, elements);
+              provisionBinding, bindingExpression, componentBindingExpressions, types);
 
         case BUILDER_BINDING:
           return new BoundInstanceBindingExpression(
               bindingExpression,
               ComponentRequirement.forBinding(provisionBinding),
               componentRequirementFields,
-              types,
-              elements);
+              types);
 
         case INJECTION:
         case PROVISION:
diff --git a/java/dagger/internal/codegen/BoundInstanceBindingExpression.java b/java/dagger/internal/codegen/BoundInstanceBindingExpression.java
index 8b790c76c..b6cc12ba0 100644
--- a/java/dagger/internal/codegen/BoundInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/BoundInstanceBindingExpression.java
@@ -18,8 +18,6 @@
 
 import com.squareup.javapoet.ClassName;
 import dagger.Component;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * A binding expression for instances bound with {@link dagger.BindsInstance} and instances of
@@ -33,9 +31,8 @@
       BindingExpression delegate,
       ComponentRequirement componentRequirement,
       ComponentRequirementFields componentRequirementFields,
-      Types types,
-      Elements elements) {
-    super(delegate, types, elements);
+      DaggerTypes types) {
+    super(delegate, types);
     this.componentRequirement = componentRequirement;
     this.componentRequirementFields = componentRequirementFields;
   }
diff --git a/java/dagger/internal/codegen/BuilderValidator.java b/java/dagger/internal/codegen/BuilderValidator.java
index 72df34e5c..b1181f25b 100644
--- a/java/dagger/internal/codegen/BuilderValidator.java
+++ b/java/dagger/internal/codegen/BuilderValidator.java
@@ -19,7 +19,6 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.DaggerElements.getUnimplementedMethods;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -42,7 +41,6 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 /**
@@ -52,10 +50,10 @@
  */
 class BuilderValidator {
 
-  private final Elements elements;
+  private final DaggerElements elements;
   private final Types types;
 
-  BuilderValidator(Elements elements, Types types) {
+  BuilderValidator(DaggerElements elements, Types types) {
     this.elements = elements;
     this.types = types;
   }
@@ -109,7 +107,7 @@
     }
 
     ExecutableElement buildMethod = null;
-    for (ExecutableElement method : getUnimplementedMethods(subject, types, elements)) {
+    for (ExecutableElement method : elements.getUnimplementedMethods(subject)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
       TypeMirror returnType = resolvedMethodType.getReturnType();
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 0006c072b..aa9310f5b 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -25,9 +25,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
-import static dagger.internal.codegen.DaggerElements.checkTypePresent;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static dagger.internal.codegen.DaggerElements.getUnimplementedMethods;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static javax.lang.model.type.TypeKind.DECLARED;
@@ -445,13 +443,13 @@ Kind componentKind() {
   }
 
   static final class Factory {
-    private final Elements elements;
+    private final DaggerElements elements;
     private final Types types;
     private final DependencyRequest.Factory dependencyRequestFactory;
     private final ModuleDescriptor.Factory moduleDescriptorFactory;
 
     Factory(
-        Elements elements,
+        DaggerElements elements,
         Types types,
         DependencyRequest.Factory dependencyRequestFactory,
         ModuleDescriptor.Factory moduleDescriptorFactory) {
@@ -522,7 +520,7 @@ private ComponentDescriptor create(
         }
       }
       ImmutableSet<ExecutableElement> unimplementedMethods =
-          getUnimplementedMethods(componentDefinitionType, types, elements);
+          elements.getUnimplementedMethods(componentDefinitionType);
 
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
@@ -668,7 +666,7 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
         return Optional.empty();
       }
       TypeElement element = MoreTypes.asTypeElement(builderType.get());
-      ImmutableSet<ExecutableElement> methods = getUnimplementedMethods(element, types, elements);
+      ImmutableSet<ExecutableElement> methods = elements.getUnimplementedMethods(element);
       ImmutableSet.Builder<BuilderRequirementMethod> requirementMethods = ImmutableSet.builder();
       ExecutableElement buildMethod = null;
       for (ExecutableElement method : methods) {
@@ -719,7 +717,7 @@ private ComponentRequirement requirementForBuilderMethod(
     private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefinitionType) {
       ClassName monitoringModuleName =
           SourceFiles.generatedMonitoringModuleName(componentDefinitionType);
-      TypeElement monitoringModule = checkTypePresent(monitoringModuleName.toString(), elements);
+      TypeElement monitoringModule = elements.checkTypePresent(monitoringModuleName.toString());
       return moduleDescriptorFactory.create(monitoringModule);
     }
 
@@ -736,7 +734,7 @@ private ModuleDescriptor descriptorForProductionExecutorModule(
       ClassName productionExecutorModuleName =
           SourceFiles.generatedProductionExecutorModuleName(componentDefinitionType);
       TypeElement productionExecutorModule =
-          checkTypePresent(productionExecutorModuleName.toString(), elements);
+          elements.checkTypePresent(productionExecutorModuleName.toString());
       return moduleDescriptorFactory.create(productionExecutorModule);
     }
   }
diff --git a/java/dagger/internal/codegen/ComponentGenerator.java b/java/dagger/internal/codegen/ComponentGenerator.java
index dadb44639..bca63f0c1 100644
--- a/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/java/dagger/internal/codegen/ComponentGenerator.java
@@ -24,7 +24,6 @@
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * Generates the implementation of the abstract types annotated with {@link Component}.
@@ -33,7 +32,7 @@
  * @since 2.0
  */
 final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
-  private final Types types;
+  private final DaggerTypes types;
   private final Elements elements;
   private final Key.Factory keyFactory;
   private final CompilerOptions compilerOptions;
@@ -41,7 +40,7 @@
   ComponentGenerator(
       Filer filer,
       Elements elements,
-      Types types,
+      DaggerTypes types,
       Key.Factory keyFactory,
       CompilerOptions compilerOptions) {
     super(filer, elements);
diff --git a/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
index 0c8635e95..6e04039ac 100644
--- a/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
@@ -18,8 +18,6 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /** A binding expression for the instance of the component itself, i.e. {@code this}. */
 final class ComponentInstanceBindingExpression extends SimpleInvocationBindingExpression {
@@ -30,9 +28,8 @@
       BindingExpression delegate,
       ContributionBinding binding,
       ClassName componentName,
-      Types types,
-      Elements elements) {
-    super(delegate, types, elements);
+      DaggerTypes types) {
+    super(delegate, types);
     this.componentName = componentName;
     this.binding = binding;
   }
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index cc13efa02..d35e30b9d 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -29,8 +29,6 @@
 import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.SourceVersion;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
@@ -60,8 +58,8 @@ public SourceVersion getSupportedSourceVersion() {
   @Override
   protected Iterable<? extends ProcessingStep> initSteps() {
     Messager messager = processingEnv.getMessager();
-    Types types = processingEnv.getTypeUtils();
-    Elements elements = processingEnv.getElementUtils();
+    DaggerTypes types = new DaggerTypes(processingEnv);
+    DaggerElements elements = new DaggerElements(processingEnv);
     CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
     Filer filer =  new FormattingFiler(processingEnv.getFiler());
 
diff --git a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
index af8b1f9c8..afdaf381e 100644
--- a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
@@ -24,8 +24,6 @@
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.Preconditions;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /** A binding expression for component provision methods. */
 final class ComponentProvisionBindingExpression extends SimpleInvocationBindingExpression {
@@ -40,9 +38,8 @@
       BindingGraph bindingGraph,
       ComponentRequirementFields componentRequirementFields,
       CompilerOptions compilerOptions,
-      Types types,
-      Elements elements) {
-    super(providerBindingExpression, types, elements);
+      DaggerTypes types) {
+    super(providerBindingExpression, types);
     this.binding = checkNotNull(binding);
     this.bindingGraph = checkNotNull(bindingGraph);
     this.componentRequirementFields = checkNotNull(componentRequirementFields);
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index 1bd1820c2..e0f8764a3 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -42,7 +42,6 @@
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * Creates the implementation class for a component.
@@ -50,7 +49,7 @@
 final class ComponentWriter extends AbstractComponentWriter {
 
   ComponentWriter(
-      Types types,
+      DaggerTypes types,
       Elements elements,
       Key.Factory keyFactory,
       CompilerOptions compilerOptions,
diff --git a/java/dagger/internal/codegen/DaggerElements.java b/java/dagger/internal/codegen/DaggerElements.java
index fe19903b9..afbb6b541 100644
--- a/java/dagger/internal/codegen/DaggerElements.java
+++ b/java/dagger/internal/codegen/DaggerElements.java
@@ -18,6 +18,7 @@
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.hasModifiers;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Lists.asList;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.stream.Collectors.toSet;
@@ -27,29 +28,44 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import java.io.Writer;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
+import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import java.util.function.Predicate;
+import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.Types;
 
-/**
- * Utilities for working with {@link Element} objects. Each is a candidate to move to {@link
- * MoreElements}.
- */
-final class DaggerElements {
+/** Extension of {@link Elements} that adds Dagger-specific methods. */
+final class DaggerElements implements Elements {
+
+  private final Elements elements;
+  private final Types types;
 
-  static ImmutableSet<ExecutableElement> getUnimplementedMethods(
-      TypeElement type, Types types, Elements elements) {
+  DaggerElements(Elements elements, Types types) {
+    this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
+  }
+
+  DaggerElements(ProcessingEnvironment processingEnv) {
+    this(processingEnv.getElementUtils(), processingEnv.getTypeUtils());
+  }
+
+  ImmutableSet<ExecutableElement> getUnimplementedMethods(TypeElement type) {
     return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
         .filter(hasModifiers(ABSTRACT))
         .toSet();
@@ -174,11 +190,88 @@ static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
    * Invokes {@link Elements#getTypeElement(CharSequence)}, throwing {@link TypeNotPresentException}
    * if it is not accessible in the current compilation.
    */
-  static TypeElement checkTypePresent(String typeName, Elements elements) {
+  TypeElement checkTypePresent(String typeName) {
     TypeElement type = elements.getTypeElement(typeName);
     if (type == null) {
       throw new TypeNotPresentException(typeName, null);
     }
     return type;
   }
+
+  @Override
+  public PackageElement getPackageElement(CharSequence name) {
+    return elements.getPackageElement(name);
+  }
+
+  @Override
+  public TypeElement getTypeElement(CharSequence name) {
+    return elements.getTypeElement(name);
+  }
+
+  @Override
+  public Map<? extends ExecutableElement, ? extends AnnotationValue> getElementValuesWithDefaults(
+      AnnotationMirror a) {
+    return elements.getElementValuesWithDefaults(a);
+  }
+
+  @Override
+  public String getDocComment(Element e) {
+    return elements.getDocComment(e);
+  }
+
+  @Override
+  public boolean isDeprecated(Element e) {
+    return elements.isDeprecated(e);
+  }
+
+  @Override
+  public Name getBinaryName(TypeElement type) {
+    return elements.getBinaryName(type);
+  }
+
+  @Override
+  public PackageElement getPackageOf(Element type) {
+    return elements.getPackageOf(type);
+  }
+
+  @Override
+  public List<? extends Element> getAllMembers(TypeElement type) {
+    return elements.getAllMembers(type);
+  }
+
+  @Override
+  public List<? extends AnnotationMirror> getAllAnnotationMirrors(Element e) {
+    return elements.getAllAnnotationMirrors(e);
+  }
+
+  @Override
+  public boolean hides(Element hider, Element hidden) {
+    return elements.hides(hider, hidden);
+  }
+
+  @Override
+  public boolean overrides(
+      ExecutableElement overrider, ExecutableElement overridden, TypeElement type) {
+    return elements.overrides(overrider, overridden, type);
+  }
+
+  @Override
+  public String getConstantExpression(Object value) {
+    return elements.getConstantExpression(value);
+  }
+
+  @Override
+  public void printElements(Writer w, Element... elements) {
+    this.elements.printElements(w, elements);
+  }
+
+  @Override
+  public Name getName(CharSequence cs) {
+    return elements.getName(cs);
+  }
+
+  @Override
+  public boolean isFunctionalInterface(TypeElement type) {
+    return elements.isFunctionalInterface(type);
+  }
 }
diff --git a/java/dagger/internal/codegen/DaggerTypes.java b/java/dagger/internal/codegen/DaggerTypes.java
index 31967472d..0e8e95fea 100644
--- a/java/dagger/internal/codegen/DaggerTypes.java
+++ b/java/dagger/internal/codegen/DaggerTypes.java
@@ -17,30 +17,48 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import java.util.List;
 import java.util.Optional;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.NoType;
+import javax.lang.model.type.NullType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-/**
- * Utilities for working with {@link TypeMirror} objects. Each is a candidate to move to {@link
- * MoreTypes}.
- */
-// TODO(dpb): Change this to an object that contains a Types.
-final class DaggerTypes {
+/** Extension of {@link Types} that adds Dagger-specific methods. */
+final class DaggerTypes implements Types {
+
+  private final Types types;
+  private final Elements elements;
+
+  DaggerTypes(Types types, Elements elements) {
+    this.types = checkNotNull(types);
+    this.elements = checkNotNull(elements);
+  }
+
+  DaggerTypes(ProcessingEnvironment processingEnv) {
+    this(processingEnv.getTypeUtils(), processingEnv.getElementUtils());
+  }
+
   /**
    * Returns the non-{@link Object} superclass of the type with the proper type parameters. An empty
    * {@link Optional} is returned if there is no non-{@link Object} superclass.
    */
-  static Optional<DeclaredType> nonObjectSuperclass(
-      Types types, Elements elements, DeclaredType type) {
+  Optional<DeclaredType> nonObjectSuperclass(DeclaredType type) {
     return Optional.ofNullable(MoreTypes.nonObjectSuperclass(types, elements, type).orNull());
   }
 
@@ -52,7 +70,7 @@
    * @throws IllegalArgumentException if {@code type} is not a declared type or has more than one
    *     type argument.
    */
-  static TypeMirror unwrapTypeOrObject(TypeMirror type, Elements elements) {
+  TypeMirror unwrapTypeOrObject(TypeMirror type) {
     DeclaredType declaredType = MoreTypes.asDeclared(type);
     TypeElement typeElement = MoreElements.asType(declaredType.asElement());
     checkArgument(
@@ -70,8 +88,7 @@ static TypeMirror unwrapTypeOrObject(TypeMirror type, Elements elements) {
    * <p>For example, if {@code type} is {@code List<Number>} and {@code wrappingClass} is {@code
    * Set.class}, this will return {@code Set<List<Number>>}.
    */
-  static TypeMirror wrapType(
-      TypeMirror type, Class<?> wrappingClass, Types types, Elements elements) {
+  TypeMirror wrapType(TypeMirror type, Class<?> wrappingClass) {
     return types.getDeclaredType(elements.getTypeElement(wrappingClass.getCanonicalName()), type);
   }
 
@@ -86,8 +103,7 @@ static TypeMirror wrapType(
    *
    * @throws IllegalArgumentException if {@code} has more than one type argument.
    */
-  static DeclaredType rewrapType(
-      TypeMirror type, Class<?> wrappingClass, Types types, Elements elements) {
+  DeclaredType rewrapType(TypeMirror type, Class<?> wrappingClass) {
     List<? extends TypeMirror> typeArguments = MoreTypes.asDeclared(type).getTypeArguments();
     TypeElement wrappingType = elements.getTypeElement(wrappingClass.getCanonicalName());
     switch (typeArguments.size()) {
@@ -99,4 +115,100 @@ static DeclaredType rewrapType(
         throw new IllegalArgumentException(type + " has more than 1 type argument");
     }
   }
+
+  @Override
+  public Element asElement(TypeMirror t) {
+    return types.asElement(t);
+  }
+
+  @Override
+  public boolean isSameType(TypeMirror t1, TypeMirror t2) {
+    return types.isSameType(t1, t2);
+  }
+
+  @Override
+  public boolean isSubtype(TypeMirror t1, TypeMirror t2) {
+    return types.isSubtype(t1, t2);
+  }
+
+  @Override
+  public boolean isAssignable(TypeMirror t1, TypeMirror t2) {
+    return types.isAssignable(t1, t2);
+  }
+
+  @Override
+  public boolean contains(TypeMirror t1, TypeMirror t2) {
+    return types.contains(t1, t2);
+  }
+
+  @Override
+  public boolean isSubsignature(ExecutableType m1, ExecutableType m2) {
+    return types.isSubsignature(m1, m2);
+  }
+
+  @Override
+  public List<? extends TypeMirror> directSupertypes(TypeMirror t) {
+    return types.directSupertypes(t);
+  }
+
+  @Override
+  public TypeMirror erasure(TypeMirror t) {
+    return types.erasure(t);
+  }
+
+  @Override
+  public TypeElement boxedClass(PrimitiveType p) {
+    return types.boxedClass(p);
+  }
+
+  @Override
+  public PrimitiveType unboxedType(TypeMirror t) {
+    return types.unboxedType(t);
+  }
+
+  @Override
+  public TypeMirror capture(TypeMirror t) {
+    return types.capture(t);
+  }
+
+  @Override
+  public PrimitiveType getPrimitiveType(TypeKind kind) {
+    return types.getPrimitiveType(kind);
+  }
+
+  @Override
+  public NullType getNullType() {
+    return types.getNullType();
+  }
+
+  @Override
+  public NoType getNoType(TypeKind kind) {
+    return types.getNoType(kind);
+  }
+
+  @Override
+  public ArrayType getArrayType(TypeMirror componentType) {
+    return types.getArrayType(componentType);
+  }
+
+  @Override
+  public WildcardType getWildcardType(TypeMirror extendsBound, TypeMirror superBound) {
+    return types.getWildcardType(extendsBound, superBound);
+  }
+
+  @Override
+  public DeclaredType getDeclaredType(TypeElement typeElem, TypeMirror... typeArgs) {
+    return types.getDeclaredType(typeElem, typeArgs);
+  }
+
+  @Override
+  public DeclaredType getDeclaredType(
+      DeclaredType containing, TypeElement typeElem, TypeMirror... typeArgs) {
+    return types.getDeclaredType(containing, typeElem, typeArgs);
+  }
+
+  @Override
+  public TypeMirror asMemberOf(DeclaredType containing, Element element) {
+    return types.asMemberOf(containing, element);
+  }
 }
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 1e2606cac..ac8f3e15f 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -20,7 +20,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.DaggerTypes.wrapType;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 
 import com.squareup.javapoet.ClassName;
@@ -31,7 +30,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /** A binding expression that uses an instance of a {@link FrameworkType}. */
 final class FrameworkInstanceBindingExpression extends BindingExpression {
@@ -40,7 +38,7 @@
   private final MemberSelect memberSelect;
   private final FrameworkType frameworkType;
   private final FrameworkFieldInitializer fieldInitializer;
-  private final Types types;
+  private final DaggerTypes types;
   private final Elements elements;
   private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
@@ -51,7 +49,7 @@ static FrameworkInstanceBindingExpression create(
       GeneratedComponentModel generatedComponentModel,
       MemberSelect memberSelect,
       FrameworkFieldInitializer frameworkFieldInitializer,
-      Types types,
+      DaggerTypes types,
       Elements elements) {
     return new FrameworkInstanceBindingExpression(
         resolvedBindings,
@@ -71,7 +69,7 @@ private FrameworkInstanceBindingExpression(
       MemberSelect memberSelect,
       FrameworkType frameworkType,
       FrameworkFieldInitializer fieldInitializer,
-      Types types,
+      DaggerTypes types,
       Elements elements) {
     super(resolvedBindings);
     this.generatedComponentModel = generatedComponentModel;
@@ -109,14 +107,13 @@ Expression getDependencyExpression(
     maybeInitializeField();
     TypeMirror expressionType =
         isTypeAccessibleFrom(instanceType(), requestingClass.packageName())
-            ? wrapType(instanceType(), resolvedBindings().frameworkClass(), types, elements)
+            ? types.wrapType(instanceType(), resolvedBindings().frameworkClass())
             : rawFrameworkType();
 
     return frameworkType.to(
         requestKind,
         Expression.create(expressionType, memberSelect.getExpressionFor(requestingClass)),
-        types,
-        elements);
+        types);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/FrameworkType.java b/java/dagger/internal/codegen/FrameworkType.java
index 01ff94525..31baa1251 100644
--- a/java/dagger/internal/codegen/FrameworkType.java
+++ b/java/dagger/internal/codegen/FrameworkType.java
@@ -18,9 +18,6 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
-import static dagger.internal.codegen.DaggerTypes.rewrapType;
-import static dagger.internal.codegen.DaggerTypes.unwrapTypeOrObject;
-import static dagger.internal.codegen.DaggerTypes.wrapType;
 import static dagger.internal.codegen.DependencyRequest.Kind.INSTANCE;
 
 import com.google.common.util.concurrent.Futures;
@@ -35,8 +32,6 @@
 import dagger.producers.internal.Producers;
 import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /** One of the core types initialized as fields in a generated component. */
 enum FrameworkType {
@@ -73,28 +68,26 @@ CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
     }
 
     @Override
-    Expression to(
-        DependencyRequest.Kind requestKind, Expression from, Types types, Elements elements) {
+    Expression to(DependencyRequest.Kind requestKind, Expression from, DaggerTypes types) {
       CodeBlock codeBlock = to(requestKind, from.codeBlock());
       switch (requestKind) {
         case INSTANCE:
-          return Expression.create(unwrapTypeOrObject(from.type(), elements), codeBlock);
+          return Expression.create(types.unwrapTypeOrObject(from.type()), codeBlock);
 
         case PROVIDER:
           return from;
 
         case PROVIDER_OF_LAZY:
-          TypeMirror lazyType = rewrapType(from.type(), Lazy.class, types, elements);
-          return Expression.create(wrapType(lazyType, Provider.class, types, elements), codeBlock);
+          TypeMirror lazyType = types.rewrapType(from.type(), Lazy.class);
+          return Expression.create(types.wrapType(lazyType, Provider.class), codeBlock);
 
         case FUTURE:
           return Expression.create(
-              rewrapType(from.type(), ListenableFuture.class, types, elements), codeBlock);
+              types.rewrapType(from.type(), ListenableFuture.class), codeBlock);
 
         default:
           return Expression.create(
-              rewrapType(from.type(), requestKind.frameworkClass.get(), types, elements),
-              codeBlock);
+              types.rewrapType(from.type(), requestKind.frameworkClass.get()), codeBlock);
       }
     }
   },
@@ -117,12 +110,11 @@ CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
     }
 
     @Override
-    Expression to(
-        DependencyRequest.Kind requestKind, Expression from, Types types, Elements elements) {
+    Expression to(DependencyRequest.Kind requestKind, Expression from, DaggerTypes types) {
       switch (requestKind) {
         case FUTURE:
           return Expression.create(
-              rewrapType(from.type(), ListenableFuture.class, types, elements),
+              types.rewrapType(from.type(), ListenableFuture.class),
               to(requestKind, from.codeBlock()));
 
         case PRODUCER:
@@ -150,8 +142,7 @@ CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
     }
 
     @Override
-    Expression to(
-        DependencyRequest.Kind requestKind, Expression from, Types types, Elements elements) {
+    Expression to(DependencyRequest.Kind requestKind, Expression from, DaggerTypes types) {
       switch (requestKind) {
         case MEMBERS_INJECTOR:
           return from;
@@ -186,8 +177,7 @@ Expression to(
    * @throws IllegalArgumentException if a valid expression cannot be generated for {@code
    *     requestKind}
    */
-  abstract Expression to(
-      DependencyRequest.Kind requestKind, Expression from, Types types, Elements elements);
+  abstract Expression to(DependencyRequest.Kind requestKind, Expression from, DaggerTypes types);
 
   @Override
   public String toString() {
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index 165d695ae..2b422709b 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -32,7 +32,6 @@
 import java.util.Map;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /** A {@link BindingExpression} for multibound maps. */
 final class MapBindingExpression extends SimpleInvocationBindingExpression {
@@ -49,9 +48,9 @@
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       BindingExpression delegate,
-      Types types,
+      DaggerTypes types,
       Elements elements) {
-    super(delegate, types, elements);
+    super(delegate, types);
     ContributionBinding.Kind bindingKind = binding.bindingKind();
     checkArgument(bindingKind.equals(SYNTHETIC_MULTIBOUND_MAP), bindingKind);
     this.binding = binding;
diff --git a/java/dagger/internal/codegen/MembersInjectionBinding.java b/java/dagger/internal/codegen/MembersInjectionBinding.java
index 384cd5c30..af5258037 100644
--- a/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -20,7 +20,6 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.DaggerTypes.nonObjectSuperclass;
 import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -141,11 +140,14 @@ int indexAmongAtInjectMembersWithSameSimpleName() {
 
   static final class Factory {
     private final Elements elements;
-    private final Types types;
+    private final DaggerTypes types;
     private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Elements elements, Types types, Key.Factory keyFactory,
+    Factory(
+        Elements elements,
+        DaggerTypes types,
+        Key.Factory keyFactory,
         DependencyRequest.Factory dependencyRequestFactory) {
       this.elements = checkNotNull(elements);
       this.types = checkNotNull(types);
@@ -209,8 +211,7 @@ MembersInjectionBinding forInjectedType(
               .toSet();
 
       Optional<Key> parentKey =
-          nonObjectSuperclass(types, elements, declaredType)
-              .map(keyFactory::forMembersInjectedType);
+          types.nonObjectSuperclass(declaredType).map(keyFactory::forMembersInjectedType);
 
       Key key = keyFactory.forMembersInjectedType(declaredType);
       TypeElement typeElement = MoreElements.asType(declaredType.asElement());
@@ -232,7 +233,7 @@ MembersInjectionBinding forInjectedType(
       SetMultimap<String, ExecutableElement> overriddenMethodMap = LinkedHashMultimap.create();
       for (Optional<DeclaredType> currentType = Optional.of(declaredType);
           currentType.isPresent();
-          currentType = nonObjectSuperclass(types, elements, currentType.get())) {
+          currentType = types.nonObjectSuperclass(currentType.get())) {
         final DeclaredType type = currentType.get();
         ancestors.add(MoreElements.asType(type.asElement()));
         for (Element enclosedElement : type.asElement().getEnclosedElements()) {
diff --git a/java/dagger/internal/codegen/ModuleDescriptor.java b/java/dagger/internal/codegen/ModuleDescriptor.java
index ed1f98731..49f4d66ea 100644
--- a/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -24,7 +24,6 @@
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
-import static dagger.internal.codegen.DaggerElements.checkTypePresent;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.SourceFiles.classFileName;
@@ -55,7 +54,6 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 
 @AutoValue
 abstract class ModuleDescriptor {
@@ -138,7 +136,7 @@
   }
 
   static final class Factory {
-    private final Elements elements;
+    private final DaggerElements elements;
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
     private final MultibindingDeclaration.Factory multibindingDeclarationFactory;
@@ -147,7 +145,7 @@
     private final OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory;
 
     Factory(
-        Elements elements,
+        DaggerElements elements,
         ProvisionBinding.Factory provisionBindingFactory,
         ProductionBinding.Factory productionBindingFactory,
         MultibindingDeclaration.Factory multibindingDeclarationFactory,
@@ -238,7 +236,7 @@ private void collectImplicitlyIncludedModules(
       for (ExecutableElement method : methodsIn(moduleElement.getEnclosedElements())) {
         if (isAnnotationPresent(method, contributesAndroidInjector.asType())) {
           includedModules.add(
-              create(checkTypePresent(implicitlyIncludedModuleName(method), elements)));
+              create(elements.checkTypePresent(implicitlyIncludedModuleName(method))));
         }
       }
     }
diff --git a/java/dagger/internal/codegen/OptionalBindingExpression.java b/java/dagger/internal/codegen/OptionalBindingExpression.java
index 7c565f1ab..ceb0c905d 100644
--- a/java/dagger/internal/codegen/OptionalBindingExpression.java
+++ b/java/dagger/internal/codegen/OptionalBindingExpression.java
@@ -22,7 +22,6 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.OptionalType.OptionalKind;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 /** A binding expression for optional bindings. */
@@ -35,9 +34,8 @@
       ProvisionBinding binding,
       BindingExpression delegate,
       ComponentBindingExpressions componentBindingExpressions,
-      Types types,
-      Elements elements) {
-    super(delegate, types, elements);
+      DaggerTypes types) {
+    super(delegate, types);
     this.binding = binding;
     this.componentBindingExpressions = componentBindingExpressions;
     this.types = types;
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
index 1c5650949..d97ced043 100644
--- a/java/dagger/internal/codegen/SetBindingExpression.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -28,7 +28,6 @@
 import java.util.Set;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /** A binding expression for multibound sets. */
 final class SetBindingExpression extends SimpleInvocationBindingExpression {
@@ -42,9 +41,9 @@
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       BindingExpression delegate,
-      Types types,
+      DaggerTypes types,
       Elements elements) {
-    super(delegate, types, elements);
+    super(delegate, types);
     this.binding = binding;
     this.graph = graph;
     this.componentBindingExpressions = componentBindingExpressions;
diff --git a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
index 1582d492d..3b4d81756 100644
--- a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
@@ -16,14 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.DaggerTypes.wrapType;
-
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * A binding expression that can use a simple expression for instance requests, and delegates to
@@ -31,14 +27,12 @@
  */
 abstract class SimpleInvocationBindingExpression extends BindingExpression {
   private final BindingExpression delegate;
-  private final Types types;
-  private final Elements elements;
+  private final DaggerTypes types;
 
-  SimpleInvocationBindingExpression(BindingExpression delegate, Types types, Elements elements) {
+  SimpleInvocationBindingExpression(BindingExpression delegate, DaggerTypes types) {
     super(delegate.resolvedBindings());
     this.delegate = delegate;
     this.types = types;
-    this.elements = elements;
   }
 
   /**
@@ -69,7 +63,7 @@ final Expression getDependencyExpression(
       case FUTURE:
         Expression expression = getInstanceDependencyExpression(requestKind, requestingClass);
         return Expression.create(
-            wrapType(expression.type(), ListenableFuture.class, types, elements),
+            types.wrapType(expression.type(), ListenableFuture.class),
             CodeBlock.builder()
                 .add("$T.", Futures.class)
                 .add(explicitTypeParameter(requestingClass))
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index 6c3ccec27..993c8c537 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -37,7 +37,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * A binding expression that invokes methods or constructors directly for a provision binding when
@@ -58,9 +57,9 @@
       ComponentBindingExpressions componentBindingExpressions,
       GeneratedComponentModel generatedComponentModel,
       ComponentRequirementFields componentRequirementFields,
-      Types types,
+      DaggerTypes types,
       Elements elements) {
-    super(delegate, types, elements);
+    super(delegate, types);
     checkArgument(
         provisionBinding.implicitDependencies().isEmpty(),
         "framework deps are not currently supported");
diff --git a/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java b/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
index 02b99d594..5215bced9 100644
--- a/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
+++ b/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
@@ -18,8 +18,6 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /** A binding expression for a subcomponent builder that just invokes the constructor. */
 final class SubcomponentBuilderBindingExpression extends SimpleInvocationBindingExpression {
@@ -30,9 +28,8 @@
       BindingExpression delegate,
       ContributionBinding binding,
       String subcomponentBuilderName,
-      Types types,
-      Elements elements) {
-    super(delegate, types, elements);
+      DaggerTypes types) {
+    super(delegate, types);
     this.subcomponentBuilderName = subcomponentBuilderName;
     this.binding = binding;
   }
