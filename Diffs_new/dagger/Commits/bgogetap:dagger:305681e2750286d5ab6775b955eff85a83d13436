diff --git a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
index 0e8c0cca7..23b90c92e 100644
--- a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
+++ b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
@@ -32,8 +32,8 @@
 import dagger.MapKey;
 import dagger.android.AndroidInjector;
 import dagger.android.DispatchingAndroidInjector;
+import dagger.model.Binding;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingKind;
 import dagger.model.Key;
 import dagger.spi.BindingGraphPlugin;
@@ -58,31 +58,30 @@
 public final class DuplicateAndroidInjectorsChecker implements BindingGraphPlugin {
   @Override
   public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
-    for (BindingNode node : graph.bindingNodes()) {
-      if (isDispatchingAndroidInjector(node)) {
-        validateMapKeyUniqueness(node, graph, diagnosticReporter);
+    for (Binding binding : graph.bindings()) {
+      if (isDispatchingAndroidInjector(binding)) {
+        validateMapKeyUniqueness(binding, graph, diagnosticReporter);
       }
     }
   }
 
-  private boolean isDispatchingAndroidInjector(BindingNode node) {
-    Key key = node.key();
+  private boolean isDispatchingAndroidInjector(Binding binding) {
+    Key key = binding.key();
     return MoreTypes.isTypeOf(DispatchingAndroidInjector.class, key.type())
         && !key.qualifier().isPresent();
   }
 
   private void validateMapKeyUniqueness(
-      BindingNode dispatchingAndroidInjectorNode,
+      Binding dispatchingAndroidInjector,
       BindingGraph graph,
       DiagnosticReporter diagnosticReporter) {
-    ImmutableSet<BindingNode> injectorFactories =
-        injectorMapDependencies(dispatchingAndroidInjectorNode, graph)
+    ImmutableSet<Binding> injectorFactories =
+        injectorMapDependencies(dispatchingAndroidInjector, graph)
             .flatMap(injectorFactoryMap -> dependencies(injectorFactoryMap, graph))
             .collect(collectingAndThen(toList(), ImmutableSet::copyOf));
 
-    ImmutableListMultimap.Builder<String, BindingNode> mapKeyIndex =
-        ImmutableListMultimap.builder();
-    for (BindingNode injectorFactory : injectorFactories) {
+    ImmutableListMultimap.Builder<String, Binding> mapKeyIndex = ImmutableListMultimap.builder();
+    for (Binding injectorFactory : injectorFactories) {
       AnnotationMirror mapKey = mapKey(injectorFactory).get();
       Optional<String> injectedType = injectedTypeFromMapKey(mapKey);
       if (injectedType.isPresent()) {
@@ -93,9 +92,8 @@ private void validateMapKeyUniqueness(
       }
     }
 
-    Map<String, List<BindingNode>> duplicates =
-        Maps.filterValues(
-            Multimaps.asMap(mapKeyIndex.build()), bindingNodes -> bindingNodes.size() > 1);
+    Map<String, List<Binding>> duplicates =
+        Maps.filterValues(Multimaps.asMap(mapKeyIndex.build()), bindings -> bindings.size() > 1);
     if (!duplicates.isEmpty()) {
       StringBuilder errorMessage =
           new StringBuilder("Multiple injector factories bound for the same type:\n");
@@ -105,29 +103,28 @@ private void validateMapKeyUniqueness(
             formatter.format("  %s:\n", injectedType);
             duplicateFactories.forEach(duplicate -> formatter.format("    %s\n", duplicate));
           });
-      diagnosticReporter.reportBinding(
-          ERROR, dispatchingAndroidInjectorNode, errorMessage.toString());
+      diagnosticReporter.reportBinding(ERROR, dispatchingAndroidInjector, errorMessage.toString());
     }
   }
 
-  private Stream<BindingNode> dependencies(BindingNode bindingNode, BindingGraph graph) {
-    return graph.network().successors(bindingNode).stream()
+  private Stream<Binding> dependencies(Binding binding, BindingGraph graph) {
+    return graph.network().successors(binding).stream()
         // TODO(ronshapiro): reuse DaggerStreams.instancesOf()?
-        .filter(BindingNode.class::isInstance)
-        .map(BindingNode.class::cast);
+        .filter(Binding.class::isInstance)
+        .map(Binding.class::cast);
   }
 
   /**
-   * Returns a stream of the dependencies of {@code bindingNode} that have a key type of {@code
-   * Map<K, Provider<AndroidInjector.Factory<?>>}.
+   * Returns a stream of the dependencies of {@code binding} that have a key type of {@code Map<K,
+   * Provider<AndroidInjector.Factory<?>>}.
    */
-  private Stream<BindingNode> injectorMapDependencies(BindingNode bindingNode, BindingGraph graph) {
-    return dependencies(bindingNode, graph)
-        .filter(node -> node.binding().kind().equals(BindingKind.MULTIBOUND_MAP))
+  private Stream<Binding> injectorMapDependencies(Binding binding, BindingGraph graph) {
+    return dependencies(binding, graph)
+        .filter(requestedBinding -> requestedBinding.kind().equals(BindingKind.MULTIBOUND_MAP))
         .filter(
-            node -> {
+            requestedBinding -> {
               TypeMirror valueType =
-                  MoreTypes.asDeclared(node.key().type()).getTypeArguments().get(1);
+                  MoreTypes.asDeclared(requestedBinding.key().type()).getTypeArguments().get(1);
               if (!MoreTypes.isTypeOf(Provider.class, valueType)
                   || !valueType.getKind().equals(TypeKind.DECLARED)) {
                 return false;
@@ -137,9 +134,8 @@ private void validateMapKeyUniqueness(
             });
   }
 
-  private Optional<AnnotationMirror> mapKey(BindingNode bindingNode) {
-    return bindingNode
-        .binding()
+  private Optional<AnnotationMirror> mapKey(Binding binding) {
+    return binding
         .bindingElement()
         .map(bindingElement -> getAnnotatedAnnotations(bindingElement, MapKey.class))
         .flatMap(
diff --git a/java/dagger/example/spi/BindingGraphVisualizer.java b/java/dagger/example/spi/BindingGraphVisualizer.java
index 379e9733f..8865c8de8 100644
--- a/java/dagger/example/spi/BindingGraphVisualizer.java
+++ b/java/dagger/example/spi/BindingGraphVisualizer.java
@@ -28,13 +28,13 @@
 import com.google.common.graph.EndpointPair;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
+import dagger.model.Binding;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ChildFactoryMethodEdge;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
-import dagger.model.BindingGraph.MaybeBindingNode;
-import dagger.model.BindingGraph.MissingBindingNode;
+import dagger.model.BindingGraph.MaybeBinding;
+import dagger.model.BindingGraph.MissingBinding;
 import dagger.model.BindingGraph.Node;
 import dagger.model.BindingGraph.SubcomponentBuilderBindingEdge;
 import dagger.model.BindingKind;
@@ -278,17 +278,17 @@ UUID nodeId(Node node) {
 
     DotNode dotNode(Node node) {
       DotNode dotNode = new DotNode(nodeId(node));
-      if (node instanceof MaybeBindingNode) {
+      if (node instanceof MaybeBinding) {
         dotNode.addAttribute("tooltip", "");
-        if (bindingGraph.entryPointBindingNodes().contains(node)) {
+        if (bindingGraph.entryPointBindings().contains(node)) {
           dotNode.addAttribute("penwidth", 3);
         }
-        if (node instanceof BindingNode) {
-          dotNode.addAttribute("label", label((BindingNode) node));
+        if (node instanceof Binding) {
+          dotNode.addAttribute("label", label((Binding) node));
         }
-        if (node instanceof MissingBindingNode) {
+        if (node instanceof MissingBinding) {
           dotNode.addAttributeFormat(
-              "label", "missing binding for %s", ((MissingBindingNode) node).key());
+              "label", "missing binding for %s", ((MissingBinding) node).key());
         }
       } else {
         dotNode.addAttribute("style", "invis").addAttribute("shape", "point");
@@ -296,13 +296,13 @@ DotNode dotNode(Node node) {
       return dotNode;
     }
 
-    private String label(BindingNode bindingNode) {
-      if (bindingNode.binding().kind().equals(BindingKind.MEMBERS_INJECTION)) {
-        return String.format("inject(%s)", bindingNode.key());
-      } else if (bindingNode.binding().isProduction()) {
-        return String.format("@Produces %s", bindingNode.key());
+    private String label(Binding binding) {
+      if (binding.kind().equals(BindingKind.MEMBERS_INJECTION)) {
+        return String.format("inject(%s)", binding.key());
+      } else if (binding.isProduction()) {
+        return String.format("@Produces %s", binding.key());
       } else {
-        return bindingNode.key().toString();
+        return binding.key().toString();
       }
     }
 
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 4d00320ed..9a8fa7a05 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -124,7 +124,7 @@ java_library(
         "BindingDeclaration.java",
         "BindingFactory.java",
         "BindingGraph.java",
-        "BindingNodeImpl.java",
+        "BindingNode.java",
         "BindingRequest.java",
         "BindingType.java",
         "BindingVariableNamer.java",  # needed by FrameworkField
diff --git a/java/dagger/internal/codegen/Binding.java b/java/dagger/internal/codegen/Binding.java
index f3fd84a4a..386e29a78 100644
--- a/java/dagger/internal/codegen/Binding.java
+++ b/java/dagger/internal/codegen/Binding.java
@@ -20,6 +20,8 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 import static java.util.stream.Collectors.toSet;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Supplier;
@@ -30,6 +32,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
+import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.Scope;
@@ -39,6 +42,7 @@
 import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.DeclaredType;
@@ -47,12 +51,34 @@
 import javax.lang.model.util.Types;
 
 /**
- * An abstract type for classes representing a Dagger binding.  Particularly, contains the
- * {@link Element} that generated the binding and the {@link DependencyRequest} instances that are
- * required to satisfy the binding, but leaves the specifics of the <i>mechanism</i> of the binding
- * to the subtypes.
+ * An abstract type for classes representing a Dagger binding. Particularly, contains the {@link
+ * Element} that generated the binding and the {@link DependencyRequest} instances that are required
+ * to satisfy the binding, but leaves the specifics of the <i>mechanism</i> of the binding to the
+ * subtypes.
  */
-abstract class Binding extends BindingDeclaration implements dagger.model.Binding {
+abstract class Binding extends BindingDeclaration {
+
+  /**
+   * Returns {@code true} if using this binding requires an instance of the {@link
+   * #contributingModule()}.
+   */
+  boolean requiresModuleInstance() {
+    if (!bindingElement().isPresent() || !contributingModule().isPresent()) {
+      return false;
+    }
+    Set<Modifier> modifiers = bindingElement().get().getModifiers();
+    return !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC);
+  }
+
+  /**
+   * Returns {@code true} if this binding may provide {@code null} instead of an instance of {@link
+   * #key()}. Nullable bindings cannot be requested from {@linkplain DependencyRequest#isNullable()
+   * non-nullable dependency requests}.
+   */
+  abstract boolean isNullable();
+
+  /** The kind of binding this instance represents. */
+  abstract BindingKind kind();
 
   /** The {@link BindingType} of this binding. */
   abstract BindingType bindingType();
@@ -87,8 +113,7 @@
    * union of {@link #explicitDependencies()} and {@link #implicitDependencies()}. This returns an
    * unmodifiable set.
    */
-  @Override
-  public ImmutableSet<DependencyRequest> dependencies() {
+  ImmutableSet<DependencyRequest> dependencies() {
     return dependencies.get();
   }
 
@@ -236,8 +261,7 @@ static DependencyAssociation create(
    */
   abstract Optional<? extends Binding> unresolved();
 
-  @Override
-  public Optional<Scope> scope() {
+  Optional<Scope> scope() {
     return Optional.empty();
   }
 
diff --git a/java/dagger/internal/codegen/BindingDeclaration.java b/java/dagger/internal/codegen/BindingDeclaration.java
index f85cd2194..d7aa1fb13 100644
--- a/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/java/dagger/internal/codegen/BindingDeclaration.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import dagger.model.BindingKind;
 import dagger.model.Key;
 import java.util.Optional;
 import javax.lang.model.element.Element;
@@ -28,9 +29,19 @@
   abstract Key key();
 
   /**
-   * The {@link Element} that declares the binding. Absent for bindings without identifying
-   * declarations.
+   * The {@link Element} that declares this binding. Absent for {@linkplain BindingKind binding
+   * kinds} that are not always declared by exactly one element.
+   *
+   * <p>For example, consider {@link BindingKind#MULTIBOUND_SET}. A component with many
+   * {@code @IntoSet} bindings for the same key will have a synthetic binding that depends on all
+   * contributions, but with no identifiying binding element. A {@code @Multibinds} method will also
+   * contribute a synthetic binding, but since multiple {@code @Multibinds} methods can coexist in
+   * the same component (and contribute to one single binding), it has no binding element.
    */
+  // TODO(ronshapiro): examine whether this wildcard+bound have any benefit.
+  // We never actually refer to the overridden bindingElement methods directly in a way which needs
+  // anything more than an Element. Removing the wildcard would allow for simpler user-written code
+  // when the binding element is passed to a method.
   abstract Optional<Element> bindingElement();
 
   /**
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index ed2e0abe7..a892c45b1 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -29,11 +29,10 @@
 import com.google.common.graph.MutableNetwork;
 import com.google.common.graph.Network;
 import com.google.common.graph.NetworkBuilder;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
-import dagger.model.BindingGraph.MissingBindingNode;
+import dagger.model.BindingGraph.MissingBinding;
 import dagger.model.BindingGraph.Node;
 import dagger.model.BindingGraphProxies;
 import dagger.model.DependencyRequest;
@@ -105,13 +104,13 @@ protected void visitComponent(BindingGraph graph) {
       network.addNode(currentComponent);
 
       for (ResolvedBindings resolvedBindings : graph.resolvedBindings()) {
-        for (BindingNode node : bindingNodes(resolvedBindings)) {
-          addBindingNode(node);
-          if (node.binding().kind().equals(SUBCOMPONENT_BUILDER)
-              && node.componentPath().equals(currentComponent.componentPath())) {
+        for (BindingNode binding : bindingNodes(resolvedBindings)) {
+          addBinding(binding);
+          if (binding.kind().equals(SUBCOMPONENT_BUILDER)
+              && binding.componentPath().equals(currentComponent.componentPath())) {
             network.addEdge(
-                node,
-                subcomponentNode(node.key().type(), graph),
+                binding,
+                subcomponentNode(binding.key().type(), graph),
                 new SubcomponentBuilderBindingEdgeImpl(
                     subcomponentDeclaringModules(resolvedBindings)));
           }
@@ -181,11 +180,11 @@ private ResolvedBindings resolvedDependencies(
           .resolvedBindings(bindingRequest(dependencyRequest));
     }
 
-    /** Adds a binding node and edges for all its dependencies. */
-    private void addBindingNode(BindingNode node) {
-      network.addNode(node);
-      for (DependencyRequest dependencyRequest : node.binding().dependencies()) {
-        addDependencyEdges(node, dependencyRequest);
+    /** Adds a binding and all its dependencies. */
+    private void addBinding(BindingNode binding) {
+      network.addNode(binding);
+      for (DependencyRequest dependencyRequest : binding.dependencies()) {
+        addDependencyEdges(binding, dependencyRequest);
       }
     }
 
@@ -205,7 +204,7 @@ private void addBindingNode(BindingNode node) {
 
     private BindingNode bindingNode(
         ResolvedBindings resolvedBindings, Binding binding, ComponentDescriptor owningComponent) {
-      return BindingNodeImpl.create(
+      return BindingNode.create(
           componentTreePath()
               .pathFromRootToAncestor(owningComponent.componentDefinitionType())
               .toComponentPath(),
@@ -222,7 +221,7 @@ private BindingNode bindingNode(
           resolvedBindings.subcomponentDeclarations());
     }
 
-    private MissingBindingNode missingBindingNode(ResolvedBindings dependencies) {
+    private MissingBinding missingBindingNode(ResolvedBindings dependencies) {
       return BindingGraphProxies.missingBindingNode(
           componentTreePath()
               .pathFromRootToAncestor(dependencies.owningComponent().componentDefinitionType())
diff --git a/java/dagger/internal/codegen/BindingNode.java b/java/dagger/internal/codegen/BindingNode.java
new file mode 100644
index 000000000..fb9b5e3a3
--- /dev/null
+++ b/java/dagger/internal/codegen/BindingNode.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.BindingType.PRODUCTION;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import dagger.BindsOptionalOf;
+import dagger.Module;
+import dagger.model.BindingKind;
+import dagger.model.ComponentPath;
+import dagger.model.DependencyRequest;
+import dagger.model.Key;
+import dagger.model.Scope;
+import dagger.multibindings.Multibinds;
+import java.util.Optional;
+import java.util.function.Supplier;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * An implementation of {@link dagger.model.Binding} that also exposes {@link BindingDeclaration}s
+ * associated with the binding.
+ */
+// TODO(dpb): Consider a supertype of dagger.model.Binding that dagger.internal.codegen.Binding
+// could also implement.
+@AutoValue
+abstract class BindingNode implements dagger.model.Binding {
+  static BindingNode create(
+      ComponentPath component,
+      Binding delegate,
+      Iterable<BindingDeclaration> associatedDeclarations,
+      Supplier<String> toStringFunction) {
+    BindingNode node =
+        new AutoValue_BindingNode(component, delegate, ImmutableSet.copyOf(associatedDeclarations));
+    node.toStringFunction = checkNotNull(toStringFunction);
+    return node;
+  }
+
+  private Supplier<String> toStringFunction;
+
+  abstract Binding delegate();
+
+  /**
+   * The {@link Element}s (other than the binding's {@link #bindingElement()}) that are associated
+   * with the binding.
+   *
+   * <ul>
+   *   <li>{@linkplain BindsOptionalOf optional binding} declarations
+   *   <li>{@linkplain Module#subcomponents() module subcomponent} declarations
+   *   <li>{@linkplain Multibinds multibinding} declarations
+   * </ul>
+   */
+  abstract ImmutableSet<BindingDeclaration> associatedDeclarations();
+
+  @Override
+  public Key key() {
+    return delegate().key();
+  }
+
+  @Override
+  public ImmutableSet<DependencyRequest> dependencies() {
+    return delegate().dependencies();
+  }
+
+  @Override
+  public Optional<Element> bindingElement() {
+    return delegate().bindingElement();
+  }
+
+  @Override
+  public Optional<TypeElement> contributingModule() {
+    return delegate().contributingModule();
+  }
+
+  @Override
+  public boolean requiresModuleInstance() {
+    return delegate().requiresModuleInstance();
+  }
+
+  @Override
+  public Optional<Scope> scope() {
+    return delegate().scope();
+  }
+
+  @Override
+  public boolean isNullable() {
+    return delegate().isNullable();
+  }
+
+  @Override
+  public boolean isProduction() {
+    return delegate().bindingType().equals(PRODUCTION);
+  }
+
+  @Override
+  public BindingKind kind() {
+    return delegate().kind();
+  }
+
+  @Override
+  public final String toString() {
+    return toStringFunction.get();
+  }
+}
diff --git a/java/dagger/internal/codegen/BindingNodeImpl.java b/java/dagger/internal/codegen/BindingNodeImpl.java
deleted file mode 100644
index 3c2b32859..000000000
--- a/java/dagger/internal/codegen/BindingNodeImpl.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import com.google.auto.value.AutoValue;
-import com.google.common.collect.ImmutableSet;
-import dagger.BindsOptionalOf;
-import dagger.Module;
-import dagger.model.BindingGraph.BindingNode;
-import dagger.model.ComponentPath;
-import dagger.multibindings.Multibinds;
-import java.util.function.Supplier;
-import javax.lang.model.element.Element;
-
-/**
- * An implementation of {@link BindingNode} that also exposes {@link BindingDeclaration}s associated
- * with the binding.
- */
-@AutoValue
-abstract class BindingNodeImpl implements BindingNode {
-  static BindingNode create(
-      ComponentPath component,
-      dagger.model.Binding binding,
-      Iterable<BindingDeclaration> associatedDeclarations,
-      Supplier<String> toStringFunction) {
-    BindingNodeImpl node =
-        new AutoValue_BindingNodeImpl(
-            component, binding, ImmutableSet.copyOf(associatedDeclarations));
-    node.toStringFunction = checkNotNull(toStringFunction);
-    return node;
-  }
-
-  private Supplier<String> toStringFunction;
-
-  /**
-   * The {@link Element}s (other than the binding's {@link dagger.model.Binding#bindingElement()})
-   * that are associated with the binding.
-   *
-   * <ul>
-   *   <li>{@linkplain BindsOptionalOf optional binding} declarations
-   *   <li>{@linkplain Module#subcomponents() module subcomponent} declarations
-   *   <li>{@linkplain Multibinds multibinding} declarations
-   * </ul>
-   */
-  abstract ImmutableSet<BindingDeclaration> associatedDeclarations();
-
-  @Override
-  public final String toString() {
-    return toStringFunction.get();
-  }
-}
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index 9d206eff5..7de7372f1 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -23,8 +23,6 @@
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 import static java.util.Arrays.asList;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Equivalence;
@@ -35,12 +33,10 @@
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import java.util.Optional;
-import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -71,18 +67,6 @@ final Object mapKey() {
     return unwrapValue(mapKeyAnnotation).map(AnnotationValue::getValue).orElse(mapKeyAnnotation);
   }
 
-  /**
-   * {@code true} if {@link #contributingModule()} is present and this is a nonabstract instance
-   * method.
-   */
-  boolean requiresModuleInstance() {
-    if (!bindingElement().isPresent() || !contributingModule().isPresent()) {
-      return false;
-    }
-    Set<Modifier> modifiers = bindingElement().get().getModifiers();
-    return !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC);
-  }
-
   /** If {@link #bindingElement()} is a method that returns a primitive type, returns that type. */
   Optional<TypeMirror> contributedPrimitiveType() {
     return bindingElement()
diff --git a/java/dagger/internal/codegen/DependencyCycleValidator.java b/java/dagger/internal/codegen/DependencyCycleValidator.java
index b5e3b562d..2007ce8cd 100644
--- a/java/dagger/internal/codegen/DependencyCycleValidator.java
+++ b/java/dagger/internal/codegen/DependencyCycleValidator.java
@@ -38,7 +38,6 @@
 import com.google.common.graph.MutableNetwork;
 import com.google.common.graph.NetworkBuilder;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Node;
@@ -186,8 +185,8 @@ private boolean breaksCycle(DependencyEdge edge, BindingGraph graph) {
       return true;
     }
     Node target = graph.network().incidentNodes(edge).target();
-    if (target instanceof BindingNode
-        && ((BindingNode) target).binding().kind().equals(BindingKind.OPTIONAL)) {
+    if (target instanceof dagger.model.Binding
+        && ((dagger.model.Binding) target).kind().equals(BindingKind.OPTIONAL)) {
       /* For @BindsOptionalOf bindings, unwrap the type inside the Optional. If the unwrapped type
        * breaks the cycle, so does the optional binding. */
       TypeMirror optionalValueType = OptionalType.from(edge.dependencyRequest().key()).valueType();
diff --git a/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
index 965be6dd8..b4f4eb5f5 100644
--- a/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
+++ b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
@@ -20,7 +20,6 @@
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.Key;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
@@ -54,17 +53,17 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
     Key productionImplementationExecutorKey = keyFactory.forProductionImplementationExecutor();
     Key productionExecutorKey = keyFactory.forProductionExecutor();
 
-    bindingGraph.bindingNodes(productionExecutorKey).stream()
+    bindingGraph.bindings(productionExecutorKey).stream()
         .flatMap(
             productionExecutorBinding ->
                 bindingGraph.network().predecessors(productionExecutorBinding).stream())
-        .flatMap(instancesOf(BindingNode.class))
+        .flatMap(instancesOf(dagger.model.Binding.class))
         .filter(binding -> !binding.key().equals(productionImplementationExecutorKey))
         .forEach(binding -> reportError(diagnosticReporter, binding));
   }
 
-  private void reportError(DiagnosticReporter diagnosticReporter, BindingNode bindingNode) {
+  private void reportError(DiagnosticReporter diagnosticReporter, dagger.model.Binding binding) {
     diagnosticReporter.reportBinding(
-        ERROR, bindingNode, "%s may not depend on the production executor", bindingNode.key());
+        ERROR, binding, "%s may not depend on the production executor", binding.key());
   }
 }
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index 83e09870c..bef41faa3 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -46,12 +46,11 @@
 import com.google.common.collect.Table;
 import com.google.errorprone.annotations.FormatMethod;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ChildFactoryMethodEdge;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
-import dagger.model.BindingGraph.MaybeBindingNode;
+import dagger.model.BindingGraph.MaybeBinding;
 import dagger.model.BindingGraph.Node;
 import dagger.model.ComponentPath;
 import dagger.spi.BindingGraphPlugin;
@@ -119,7 +118,7 @@ DiagnosticReporterImpl reporter(BindingGraph graph, BindingGraphPlugin plugin) {
                 transform(types.supertypes(component.asType()), type -> asTypeElement(type)));
 
     /** The shortest path (value) from an entry point (column) to a binding (row). */
-    private final Table<MaybeBindingNode, DependencyEdge, ImmutableList<Node>> shortestPaths =
+    private final Table<MaybeBinding, DependencyEdge, ImmutableList<Node>> shortestPaths =
         HashBasedTable.create();
 
     private final BindingGraph graph;
@@ -162,18 +161,18 @@ public void reportComponent(
     // TODO(ronshapiro): should this also include the binding element?
     @Override
     public void reportBinding(
-        Diagnostic.Kind diagnosticKind, MaybeBindingNode bindingNode, String message) {
-      printMessage(diagnosticKind, message + new DiagnosticInfo(bindingNode), rootComponent);
+        Diagnostic.Kind diagnosticKind, MaybeBinding binding, String message) {
+      printMessage(diagnosticKind, message + new DiagnosticInfo(binding), rootComponent);
     }
 
     @Override
     public void reportBinding(
         Diagnostic.Kind diagnosticKind,
-        MaybeBindingNode bindingNode,
+        MaybeBinding binding,
         String messageFormat,
         Object firstArg,
         Object... moreArgs) {
-      reportBinding(diagnosticKind, bindingNode, formatMessage(messageFormat, firstArg, moreArgs));
+      reportBinding(diagnosticKind, binding, formatMessage(messageFormat, firstArg, moreArgs));
     }
 
     @Override
@@ -250,10 +249,10 @@ private void appendBracketPrefix(StringBuilder message, String prefix) {
       final ImmutableSet<DependencyEdge> requests;
       final ImmutableSet<DependencyEdge> entryPoints;
 
-      DiagnosticInfo(MaybeBindingNode bindingNode) {
-        entryPoints = graph.entryPointEdgesDependingOnBindingNode(bindingNode);
-        requests = requests(bindingNode);
-        dependencyTrace = dependencyTrace(bindingNode, entryPoints);
+      DiagnosticInfo(MaybeBinding binding) {
+        entryPoints = graph.entryPointEdgesDependingOnBindingNode(binding);
+        requests = requests(binding);
+        dependencyTrace = dependencyTrace(binding, entryPoints);
       }
 
       DiagnosticInfo(DependencyEdge dependencyEdge) {
@@ -265,9 +264,9 @@ private void appendBracketPrefix(StringBuilder message, String prefix) {
           entryPoints = ImmutableSet.of(dependencyEdge);
         } else {
           // It's not an entry point, so it's part of a binding
-          BindingNode bindingNode = (BindingNode) source(dependencyEdge);
-          entryPoints = graph.entryPointEdgesDependingOnBindingNode(bindingNode);
-          dependencyTraceBuilder.addAll(dependencyTrace(bindingNode, entryPoints));
+          dagger.model.Binding binding = (dagger.model.Binding) source(dependencyEdge);
+          entryPoints = graph.entryPointEdgesDependingOnBindingNode(binding);
+          dependencyTraceBuilder.addAll(dependencyTrace(binding, entryPoints));
         }
         dependencyTrace = dependencyTraceBuilder.build();
       }
@@ -330,13 +329,13 @@ public String toString() {
       }
 
       /**
-       * Returns the dependency trace from one of the {@code entryPoints} to {@code bindingNode} to
+       * Returns the dependency trace from one of the {@code entryPoints} to {@code binding} to
        * {@code message} as a list <i>ending with</i> the entry point.
        */
       // TODO(ronshapiro): Adding a DependencyPath type to dagger.model could be useful, i.e.
       // bindingGraph.shortestPathFromEntryPoint(DependencyEdge, MaybeBindingNode)
       ImmutableList<DependencyEdge> dependencyTrace(
-          MaybeBindingNode bindingNode, ImmutableSet<DependencyEdge> entryPoints) {
+          MaybeBinding binding, ImmutableSet<DependencyEdge> entryPoints) {
         // Show the full dependency trace for one entry point.
         DependencyEdge entryPointForTrace =
             min(
@@ -344,7 +343,7 @@ public String toString() {
                 // prefer entry points in components closest to the root
                 rootComponentFirst()
                     // then prefer entry points with a short dependency path to the error
-                    .thenComparing(shortestDependencyPathFirst(bindingNode))
+                    .thenComparing(shortestDependencyPathFirst(binding))
                     // then prefer entry points declared in the component to those declared in a
                     // supertype
                     .thenComparing(nearestComponentSupertypeFirst())
@@ -352,12 +351,12 @@ public String toString() {
                     .thenComparing(requestElementDeclarationOrder()));
 
         ImmutableList<Node> shortestBindingPath =
-            shortestPathFromEntryPoint(entryPointForTrace, bindingNode);
+            shortestPathFromEntryPoint(entryPointForTrace, binding);
         verify(
             !shortestBindingPath.isEmpty(),
             "no dependency path from %s to %s in %s",
             entryPointForTrace,
-            bindingNode,
+            binding,
             graph);
 
         ImmutableList.Builder<DependencyEdge> dependencyTrace = ImmutableList.builder();
@@ -374,9 +373,9 @@ public String toString() {
         return dependencyTrace.build().reverse();
       }
 
-      /** Returns all the nonsynthetic dependency requests for a binding node. */
-      ImmutableSet<DependencyEdge> requests(MaybeBindingNode bindingNode) {
-        return graph.network().inEdges(bindingNode).stream()
+      /** Returns all the nonsynthetic dependency requests for a binding. */
+      ImmutableSet<DependencyEdge> requests(MaybeBinding binding) {
+        return graph.network().inEdges(binding).stream()
             .flatMap(instancesOf(DependencyEdge.class))
             .filter(edge -> edge.dependencyRequest().requestElement().isPresent())
             .sorted(requestEnclosingTypeName().thenComparing(requestElementDeclarationOrder()))
@@ -393,26 +392,25 @@ public String toString() {
 
       /**
        * Returns a comparator that puts entry points whose shortest dependency path to {@code
-       * bindingNode} is shortest first.
+       * binding} is shortest first.
        */
-      Comparator<DependencyEdge> shortestDependencyPathFirst(MaybeBindingNode bindingNode) {
-        return comparing(entryPoint -> shortestPathFromEntryPoint(entryPoint, bindingNode).size());
+      Comparator<DependencyEdge> shortestDependencyPathFirst(MaybeBinding binding) {
+        return comparing(entryPoint -> shortestPathFromEntryPoint(entryPoint, binding).size());
       }
 
       ImmutableList<Node> shortestPathFromEntryPoint(
-          DependencyEdge entryPoint, MaybeBindingNode bindingNode) {
+          DependencyEdge entryPoint, MaybeBinding binding) {
         return shortestPaths
-            .row(bindingNode)
+            .row(binding)
             .computeIfAbsent(
                 entryPoint,
                 ep ->
                     shortestPath(
                         node ->
                             filter(
-                                graph.network().successors(node),
-                                MaybeBindingNode.class::isInstance),
+                                graph.network().successors(node), MaybeBinding.class::isInstance),
                         graph.network().incidentNodes(ep).target(),
-                        bindingNode));
+                        binding));
       }
 
       /**
diff --git a/java/dagger/internal/codegen/DuplicateBindingsValidator.java b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
index 927dbf4b2..3303e1f5b 100644
--- a/java/dagger/internal/codegen/DuplicateBindingsValidator.java
+++ b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
@@ -35,7 +35,6 @@
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Node;
 import dagger.model.DependencyRequest;
@@ -95,22 +94,22 @@ private void reportDuplicateBindings(
       Set<DependencyEdge> duplicateDependencies,
       BindingGraph bindingGraph,
       DiagnosticReporter diagnosticReporter) {
-    ImmutableSet<BindingNode> duplicateBindings =
+    ImmutableSet<dagger.model.Binding> duplicateBindings =
         duplicateDependencies.stream()
             .map(edge -> bindingGraph.network().incidentNodes(edge).target())
-            .flatMap(instancesOf(BindingNode.class))
+            .flatMap(instancesOf(dagger.model.Binding.class))
             .collect(toImmutableSet());
     diagnosticReporter.reportDependency(
         ERROR,
         Iterables.get(duplicateDependencies, 0),
-        Iterables.any(duplicateBindings, node -> node.binding().kind().isMultibinding())
+        Iterables.any(duplicateBindings, binding -> binding.kind().isMultibinding())
             ? incompatibleBindingsMessage(dependencyRequest, duplicateBindings, bindingGraph)
             : duplicateBindingMessage(dependencyRequest, duplicateBindings, bindingGraph));
   }
 
   private String duplicateBindingMessage(
       DependencyRequest dependencyRequest,
-      ImmutableSet<BindingNode> duplicateBindings,
+      ImmutableSet<dagger.model.Binding> duplicateBindings,
       BindingGraph graph) {
     StringBuilder message =
         new StringBuilder().append(dependencyRequest.key()).append(" is bound multiple times:");
@@ -120,11 +119,11 @@ private String duplicateBindingMessage(
 
   private String incompatibleBindingsMessage(
       DependencyRequest dependencyRequest,
-      ImmutableSet<BindingNode> duplicateBindings,
+      ImmutableSet<dagger.model.Binding> duplicateBindings,
       BindingGraph graph) {
-    ImmutableSet<BindingNode> multibindings =
+    ImmutableSet<dagger.model.Binding> multibindings =
         duplicateBindings.stream()
-            .filter(node -> node.binding().kind().isMultibinding())
+            .filter(binding -> binding.kind().isMultibinding())
             .collect(toImmutableSet());
     verify(
         multibindings.size() == 1,
@@ -136,11 +135,11 @@ private String incompatibleBindingsMessage(
     messageFormatter.format(
         "%s has incompatible bindings or declarations:\n", dependencyRequest.key());
     message.append(INDENT);
-    BindingNode multibinding = getOnlyElement(multibindings);
+    dagger.model.Binding multibinding = getOnlyElement(multibindings);
     messageFormatter.format("%s bindings and declarations:", multibindingTypeString(multibinding));
     formatDeclarations(message, 2, declarations(graph, multibindings));
 
-    Set<BindingNode> uniqueBindings =
+    Set<dagger.model.Binding> uniqueBindings =
         Sets.filter(duplicateBindings, binding -> !binding.equals(multibinding));
     message.append('\n').append(INDENT).append("Unique bindings and declarations:");
     formatDeclarations(
@@ -161,33 +160,32 @@ private void formatDeclarations(
   }
 
   private ImmutableSet<BindingDeclaration> declarations(
-      BindingGraph graph, Set<BindingNode> bindings) {
+      BindingGraph graph, Set<dagger.model.Binding> bindings) {
     return bindings.stream()
-        .flatMap(node -> declarations(graph, node).stream())
+        .flatMap(binding -> declarations(graph, binding).stream())
         .distinct()
         .sorted(BINDING_DECLARATION_COMPARATOR)
         .collect(toImmutableSet());
   }
 
-  private ImmutableSet<BindingDeclaration> declarations(BindingGraph graph, BindingNode node) {
+  private ImmutableSet<BindingDeclaration> declarations(
+      BindingGraph graph, dagger.model.Binding binding) {
     ImmutableSet.Builder<BindingDeclaration> declarations = ImmutableSet.builder();
-    ((BindingNodeImpl) node).associatedDeclarations().forEach(declarations::add);
-    if (node.binding() instanceof BindingDeclaration) {
-      BindingDeclaration declaration = ((BindingDeclaration) node.binding());
-      if (bindingDeclarationFormatter.canFormat(declaration)) {
-        declarations.add(declaration);
-      } else {
-        graph.network().successors(node).stream()
-            .flatMap(instancesOf(BindingNode.class))
-            .flatMap(dependency -> declarations(graph, dependency).stream())
-            .forEach(declarations::add);
-      }
+    BindingNode bindingNode = (BindingNode) binding;
+    bindingNode.associatedDeclarations().forEach(declarations::add);
+    if (bindingDeclarationFormatter.canFormat(bindingNode.delegate())) {
+      declarations.add(bindingNode.delegate());
+    } else {
+      graph.network().successors(binding).stream()
+          .flatMap(instancesOf(dagger.model.Binding.class))
+          .flatMap(dependency -> declarations(graph, dependency).stream())
+          .forEach(declarations::add);
     }
     return declarations.build();
   }
 
-  private String multibindingTypeString(BindingNode multibinding) {
-    switch (multibinding.binding().kind()) {
+  private String multibindingTypeString(dagger.model.Binding multibinding) {
+    switch (multibinding.kind()) {
       case MULTIBOUND_MAP:
         return "Map";
       case MULTIBOUND_SET:
diff --git a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
index 17b8c7eb2..4dfb49ec9 100644
--- a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
+++ b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
@@ -25,9 +25,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
-import dagger.model.Binding;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
@@ -54,11 +52,10 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    ImmutableSetMultimap.Builder<ComponentNode, BindingNode> incompatibleBindingNodes =
+    ImmutableSetMultimap.Builder<ComponentNode, dagger.model.Binding> incompatibleBindings =
         ImmutableSetMultimap.builder();
-    for (BindingNode bindingNode : bindingGraph.bindingNodes()) {
-      bindingNode
-          .binding()
+    for (dagger.model.Binding binding : bindingGraph.bindings()) {
+      binding
           .scope()
           .ifPresent(
               scope -> {
@@ -66,23 +63,21 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
                   return;
                 }
                 ComponentNode componentNode =
-                    bindingGraph.componentNode(bindingNode.componentPath()).get();
+                    bindingGraph.componentNode(binding.componentPath()).get();
                 if (!componentNode.scopes().contains(scope)) {
-                  incompatibleBindingNodes.put(componentNode, bindingNode);
+                  incompatibleBindings.put(componentNode, binding);
                 }
               });
     }
-    Multimaps.asMap(incompatibleBindingNodes.build())
+    Multimaps.asMap(incompatibleBindings.build())
         .forEach(
-            (componentNode, bindingNodes) ->
+            (componentNode, bindings) ->
                 diagnosticReporter.reportComponent(
-                    ERROR,
-                    componentNode,
-                    incompatibleBindingScopesError(componentNode, bindingNodes)));
+                    ERROR, componentNode, incompatibleBindingScopesError(componentNode, bindings)));
   }
 
   private String incompatibleBindingScopesError(
-      ComponentNode componentNode, Set<BindingNode> bindingNodes) {
+      ComponentNode componentNode, Set<dagger.model.Binding> bindings) {
     StringBuilder message =
         new StringBuilder(componentNode.componentPath().currentComponent().getQualifiedName());
     if (!componentNode.scopes().isEmpty()) {
@@ -95,10 +90,9 @@ private String incompatibleBindingScopesError(
       message.append(" (unscoped) may not reference scoped bindings:\n");
     }
     // TODO(ronshapiro): Should we group by scope?
-    for (BindingNode bindingNode : bindingNodes) {
+    for (dagger.model.Binding binding : bindings) {
       message.append(INDENT);
 
-      Binding binding = bindingNode.binding();
       switch (binding.kind()) {
         case DELEGATE:
         case PROVISION:
@@ -116,7 +110,7 @@ private String incompatibleBindingScopesError(
           break;
 
         default:
-          throw new AssertionError(bindingNode);
+          throw new AssertionError(binding);
       }
 
       message.append("\n");
diff --git a/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java b/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
index 67d72d0ab..3da907b2a 100644
--- a/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
+++ b/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
@@ -31,7 +31,6 @@
 import com.google.common.graph.NetworkBuilder;
 import dagger.Binds;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
 import dagger.model.BindingGraph.Node;
@@ -69,27 +68,23 @@ public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter
         incorrectlyInstalledBindingsCache.entries()) {
       ComponentPath idealComponentPath = entry.getKey();
       ContributionBinding incorrectlyInstalledBinding = entry.getValue();
-      graph
-          .bindingNodes(incorrectlyInstalledBinding.key())
-          .stream()
-          .filter(bindingNode -> bindingNode.binding().equals(incorrectlyInstalledBinding))
-          .forEach(
-              bindingNode -> report(bindingNode, idealComponentPath, graph, diagnosticReporter));
+      graph.bindings(incorrectlyInstalledBinding.key()).stream()
+          .filter(binding -> ((BindingNode) binding).delegate().equals(incorrectlyInstalledBinding))
+          .forEach(binding -> report(binding, idealComponentPath, graph, diagnosticReporter));
     }
   }
 
   private void report(
-      BindingNode incompatiblyInstalledBinding,
+      dagger.model.Binding incompatiblyInstalledBinding,
       ComponentPath idealComponentPath,
       BindingGraph graph,
       DiagnosticReporter diagnosticReporter) {
     // TODO(dpb): consider creating this once per visitGraph()
     ImmutableGraph<Node> dependencyGraph = dependencyGraph(graph).asGraph();
     Set<Node> culpableDependencies =
-        Graphs.reachableNodes(dependencyGraph, incompatiblyInstalledBinding)
-            .stream()
-            .filter(node -> isChild(idealComponentPath, node.componentPath()))
-            .filter(node -> !node.equals(incompatiblyInstalledBinding))
+        Graphs.reachableNodes(dependencyGraph, incompatiblyInstalledBinding).stream()
+            .filter(binding -> isChild(idealComponentPath, binding.componentPath()))
+            .filter(binding -> !binding.equals(incompatiblyInstalledBinding))
             .collect(toCollection(LinkedHashSet::new));
     if (culpableDependencies.isEmpty()) {
       return;
@@ -105,7 +100,8 @@ private void report(
             .append("\n  This is because it depends transitively on:");
 
     while (!culpableDependencies.isEmpty()) {
-      BindingNode culpableDependency = (BindingNode) Iterables.get(culpableDependencies, 0);
+      dagger.model.Binding culpableDependency =
+          (dagger.model.Binding) Iterables.get(culpableDependencies, 0);
       warning
           .append("\n      ")
           .append(culpableDependency)
diff --git a/java/dagger/internal/codegen/InjectBindingValidator.java b/java/dagger/internal/codegen/InjectBindingValidator.java
index a275bcbe4..183d16200 100644
--- a/java/dagger/internal/codegen/InjectBindingValidator.java
+++ b/java/dagger/internal/codegen/InjectBindingValidator.java
@@ -21,7 +21,6 @@
 import com.google.auto.common.MoreTypes;
 import dagger.internal.codegen.ValidationReport.Item;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
 import javax.inject.Inject;
@@ -44,12 +43,13 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    bindingGraph.bindingNodes().stream()
-        .filter(node -> node.binding().kind().equals(INJECTION)) // TODO(dpb): Move to BindingGraph
-        .forEach(node -> validateInjectionBinding(node, diagnosticReporter));
+    bindingGraph.bindings().stream()
+        .filter(binding -> binding.kind().equals(INJECTION)) // TODO(dpb): Move to BindingGraph
+        .forEach(binding -> validateInjectionBinding(binding, diagnosticReporter));
   }
 
-  private void validateInjectionBinding(BindingNode node, DiagnosticReporter diagnosticReporter) {
+  private void validateInjectionBinding(
+      dagger.model.Binding node, DiagnosticReporter diagnosticReporter) {
     ValidationReport<TypeElement> typeReport =
         injectValidator.validateType(MoreTypes.asTypeElement(node.key().type()));
     for (Item item : typeReport.allItems()) {
diff --git a/java/dagger/internal/codegen/MapMultibindingValidator.java b/java/dagger/internal/codegen/MapMultibindingValidator.java
index ea47679c7..53aa40fcd 100644
--- a/java/dagger/internal/codegen/MapMultibindingValidator.java
+++ b/java/dagger/internal/codegen/MapMultibindingValidator.java
@@ -32,7 +32,6 @@
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.Key;
 import dagger.producers.Producer;
 import dagger.spi.BindingGraphPlugin;
@@ -86,18 +85,18 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
    *   <li>{@code Map<K, Producer<V>>}
    * </ol>
    */
-  private ImmutableSet<BindingNode> mapMultibindings(BindingGraph bindingGraph) {
-    ImmutableSetMultimap<Key, BindingNode> mapMultibindings =
-        bindingGraph.bindingNodes().stream()
-            .filter(node -> node.binding().kind().equals(MULTIBOUND_MAP))
-            .collect(toImmutableSetMultimap(BindingNode::key, node -> node));
+  private ImmutableSet<dagger.model.Binding> mapMultibindings(BindingGraph bindingGraph) {
+    ImmutableSetMultimap<Key, dagger.model.Binding> mapMultibindings =
+        bindingGraph.bindings().stream()
+            .filter(node -> node.kind().equals(MULTIBOUND_MAP))
+            .collect(toImmutableSetMultimap(dagger.model.Binding::key, node -> node));
 
     // Mutlbindings for Map<K, V>
-    SetMultimap<Key, BindingNode> plainValueMapMultibindings =
+    SetMultimap<Key, dagger.model.Binding> plainValueMapMultibindings =
         filterKeys(mapMultibindings, key -> !MapType.from(key).valuesAreFrameworkType());
 
     // Multibindings for Map<K, Provider<V>> where Map<K, V> isn't in plainValueMapMultibindings
-    SetMultimap<Key, BindingNode> providerValueMapMultibindings =
+    SetMultimap<Key, dagger.model.Binding> providerValueMapMultibindings =
         filterKeys(
             mapMultibindings,
             key ->
@@ -106,7 +105,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
     // Multibindings for Map<K, Producer<V>> where Map<K, V> isn't in plainValueMapMultibindings and
     // Map<K, Provider<V>> isn't in providerValueMapMultibindings
-    SetMultimap<Key, BindingNode> producerValueMapMultibindings =
+    SetMultimap<Key, dagger.model.Binding> producerValueMapMultibindings =
         filterKeys(
             mapMultibindings,
             key ->
@@ -115,7 +114,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
                     && !providerValueMapMultibindings.containsKey(
                         keyFactory.rewrapMapKey(key, Producer.class, Provider.class).get()));
 
-    return new ImmutableSet.Builder<BindingNode>()
+    return new ImmutableSet.Builder<dagger.model.Binding>()
         .addAll(plainValueMapMultibindings.values())
         .addAll(providerValueMapMultibindings.values())
         .addAll(producerValueMapMultibindings.values())
@@ -123,16 +122,16 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
   }
 
   private ImmutableSet<ContributionBinding> mapBindingContributions(
-      BindingNode bindingNode, BindingGraph bindingGraph) {
-    checkArgument(bindingNode.binding().kind().equals(MULTIBOUND_MAP));
-    return bindingGraph.network().successors(bindingNode).stream()
+      dagger.model.Binding binding, BindingGraph bindingGraph) {
+    checkArgument(binding.kind().equals(MULTIBOUND_MAP));
+    return bindingGraph.network().successors(binding).stream()
         .flatMap(instancesOf(BindingNode.class))
-        .map(node -> (ContributionBinding) node.binding())
+        .map(b -> (ContributionBinding) b.delegate())
         .collect(toImmutableSet());
   }
 
   private void checkForDuplicateMapKeys(
-      BindingNode multiboundMapBindingNode,
+      dagger.model.Binding multiboundMapBinding,
       ImmutableSet<ContributionBinding> contributions,
       DiagnosticReporter diagnosticReporter) {
     ImmutableSetMultimap<Object, ContributionBinding> contributionsByMapKey =
@@ -143,14 +142,14 @@ private void checkForDuplicateMapKeys(
       if (contributionsForOneMapKey.size() > 1) {
         diagnosticReporter.reportBinding(
             ERROR,
-            multiboundMapBindingNode,
-            duplicateMapKeyErrorMessage(contributionsForOneMapKey, multiboundMapBindingNode.key()));
+            multiboundMapBinding,
+            duplicateMapKeyErrorMessage(contributionsForOneMapKey, multiboundMapBinding.key()));
       }
     }
   }
 
   private void checkForInconsistentMapKeyAnnotationTypes(
-      BindingNode multiboundMapBindingNode,
+      dagger.model.Binding multiboundMapBinding,
       ImmutableSet<ContributionBinding> contributions,
       DiagnosticReporter diagnosticReporter) {
     ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
@@ -159,9 +158,9 @@ private void checkForInconsistentMapKeyAnnotationTypes(
     if (contributionsByMapKeyAnnotationType.keySet().size() > 1) {
       diagnosticReporter.reportBinding(
           ERROR,
-          multiboundMapBindingNode,
+          multiboundMapBinding,
           inconsistentMapKeyAnnotationTypesErrorMessage(
-              contributionsByMapKeyAnnotationType, multiboundMapBindingNode.key()));
+              contributionsByMapKeyAnnotationType, multiboundMapBinding.key()));
     }
   }
 
diff --git a/java/dagger/internal/codegen/MembersInjectionBinding.java b/java/dagger/internal/codegen/MembersInjectionBinding.java
index b3e21edaf..ac9f6811d 100644
--- a/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -80,11 +80,6 @@ boolean hasLocalInjectionSites() {
                 injectionSite.element().getEnclosingElement().equals(membersInjectedType()));
   }
 
-  @Override
-  public final boolean isProduction() {
-    return false;
-  }
-
   @AutoValue
   abstract static class InjectionSite {
     enum Kind {
diff --git a/java/dagger/internal/codegen/MissingBindingValidator.java b/java/dagger/internal/codegen/MissingBindingValidator.java
index 74097d5e6..727b90885 100644
--- a/java/dagger/internal/codegen/MissingBindingValidator.java
+++ b/java/dagger/internal/codegen/MissingBindingValidator.java
@@ -24,10 +24,9 @@
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
-import dagger.model.BindingGraph.MissingBindingNode;
+import dagger.model.BindingGraph.MissingBinding;
 import dagger.model.BindingGraph.Node;
 import dagger.model.Key;
 import dagger.spi.BindingGraphPlugin;
@@ -56,21 +55,18 @@ public String pluginName() {
   @Override
   public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
     graph
-        .missingBindingNodes()
-        .forEach(node -> reportMissingBinding(node, graph, diagnosticReporter));
+        .missingBindings()
+        .forEach(missingBinding -> reportMissingBinding(missingBinding, graph, diagnosticReporter));
   }
 
   private void reportMissingBinding(
-      MissingBindingNode missingBindingNode,
-      BindingGraph graph,
-      DiagnosticReporter diagnosticReporter) {
+      MissingBinding missingBinding, BindingGraph graph, DiagnosticReporter diagnosticReporter) {
     diagnosticReporter.reportBinding(
-        ERROR, missingBindingNode, missingBindingErrorMessage(missingBindingNode, graph));
+        ERROR, missingBinding, missingBindingErrorMessage(missingBinding, graph));
   }
 
-  private String missingBindingErrorMessage(
-      MissingBindingNode missingBindingNode, BindingGraph graph) {
-    Key key = missingBindingNode.key();
+  private String missingBindingErrorMessage(MissingBinding missingBinding, BindingGraph graph) {
+    Key key = missingBinding.key();
     StringBuilder errorMessage = new StringBuilder();
     // Wildcards should have already been checked by DependencyRequestValidator.
     verify(!key.type().getKind().equals(TypeKind.WILDCARD), "unexpected wildcard request: %s", key);
@@ -80,7 +76,7 @@ private String missingBindingErrorMessage(
       errorMessage.append("an @Inject constructor or ");
     }
     errorMessage.append("an @Provides-"); // TODO(dpb): s/an/a
-    if (allIncomingDependenciesCanUseProduction(missingBindingNode, graph)) {
+    if (allIncomingDependenciesCanUseProduction(missingBinding, graph)) {
       errorMessage.append(" or @Produces-");
     }
     errorMessage.append("annotated method.");
@@ -88,8 +84,8 @@ private String missingBindingErrorMessage(
       errorMessage.append(
           " This type supports members injection but cannot be implicitly provided.");
     }
-    graph.bindingNodes(key).stream()
-        .map(bindingNode -> bindingNode.componentPath().currentComponent())
+    graph.bindings(key).stream()
+        .map(binding -> binding.componentPath().currentComponent())
         .distinct()
         .forEach(
             component ->
@@ -100,8 +96,8 @@ private String missingBindingErrorMessage(
   }
 
   private boolean allIncomingDependenciesCanUseProduction(
-      MissingBindingNode missingBindingNode, BindingGraph graph) {
-    return graph.network().inEdges(missingBindingNode).stream()
+      MissingBinding missingBinding, BindingGraph graph) {
+    return graph.network().inEdges(missingBinding).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .allMatch(edge -> dependencyCanBeProduction(edge, graph));
   }
@@ -111,10 +107,11 @@ private boolean dependencyCanBeProduction(DependencyEdge edge, BindingGraph grap
     if (source instanceof ComponentNode) {
       return entryPointCanUseProduction(edge.dependencyRequest().kind());
     }
-    if (source instanceof BindingNode) {
-      return ((BindingNode) source).binding().isProduction();
+    if (source instanceof dagger.model.Binding) {
+      return ((dagger.model.Binding) source).isProduction();
     }
-    throw new IllegalArgumentException("expected a BindingNode or ComponentNode: " + source);
+    throw new IllegalArgumentException(
+        "expected a dagger.model.Binding or ComponentNode: " + source);
   }
 
   private boolean typeHasInjectionSites(Key key) {
diff --git a/java/dagger/internal/codegen/NullableBindingValidator.java b/java/dagger/internal/codegen/NullableBindingValidator.java
index 553192eb9..1452c3ff8 100644
--- a/java/dagger/internal/codegen/NullableBindingValidator.java
+++ b/java/dagger/internal/codegen/NullableBindingValidator.java
@@ -24,7 +24,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
@@ -45,14 +44,14 @@
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    for (BindingNode bindingNode : nullableBindings(bindingGraph)) {
-      for (DependencyEdge dependencyEdge : nonNullableDependencies(bindingGraph, bindingNode)) {
+    for (dagger.model.Binding binding : nullableBindings(bindingGraph)) {
+      for (DependencyEdge dependencyEdge : nonNullableDependencies(bindingGraph, binding)) {
         diagnosticReporter.reportDependency(
             compilerOptions.nullableValidationKind(),
             dependencyEdge,
             nullableToNonNullable(
-                bindingNode.key().toString(),
-                bindingNode.toString())); // will include the @Nullable
+                binding.key().toString(),
+                binding.toString())); // binding.toString() will include the @Nullable
       }
     }
   }
@@ -62,15 +61,15 @@ public String pluginName() {
     return "Dagger/Nullable";
   }
 
-  private ImmutableList<BindingNode> nullableBindings(BindingGraph bindingGraph) {
-    return bindingGraph.bindingNodes().stream()
-        .filter(bindingNode -> bindingNode.binding().isNullable())
+  private ImmutableList<dagger.model.Binding> nullableBindings(BindingGraph bindingGraph) {
+    return bindingGraph.bindings().stream()
+        .filter(binding -> binding.isNullable())
         .collect(toImmutableList());
   }
 
   private ImmutableSet<DependencyEdge> nonNullableDependencies(
-      BindingGraph bindingGraph, BindingNode bindingNode) {
-    return bindingGraph.network().inEdges(bindingNode).stream()
+      BindingGraph bindingGraph, dagger.model.Binding binding) {
+    return bindingGraph.network().inEdges(binding).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .filter(edge -> !edge.dependencyRequest().isNullable())
         .collect(toImmutableSet());
diff --git a/java/dagger/internal/codegen/ProductionBinding.java b/java/dagger/internal/codegen/ProductionBinding.java
index 15deac730..12a6c3ecf 100644
--- a/java/dagger/internal/codegen/ProductionBinding.java
+++ b/java/dagger/internal/codegen/ProductionBinding.java
@@ -104,11 +104,6 @@ static Builder builder() {
         .thrownTypes(ImmutableList.<TypeMirror>of());
   }
 
-  @Override
-  public final boolean isProduction() {
-    return true;
-  }
-
   @AutoValue.Builder
   @CanIgnoreReturnValue
   abstract static class Builder extends ContributionBinding.Builder<ProductionBinding, Builder> {
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index 09d29e18e..492cefc24 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -97,11 +97,6 @@ boolean shouldCheckForNull(CompilerOptions compilerOptions) {
         && compilerOptions.doCheckForNulls();
   }
 
-  @Override
-  public final boolean isProduction() {
-    return false;
-  }
-
   @AutoValue.Builder
   @CanIgnoreReturnValue
   abstract static class Builder extends ContributionBinding.Builder<ProvisionBinding, Builder> {
diff --git a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
index 272bf8889..ce918624f 100644
--- a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
+++ b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
@@ -23,7 +23,6 @@
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Node;
 import dagger.spi.BindingGraphPlugin;
@@ -61,8 +60,8 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
   private Stream<DependencyEdge> provisionDependenciesOnProductionBindings(
       BindingGraph bindingGraph) {
-    return bindingGraph.bindingNodes().stream()
-        .filter(bindingNode -> bindingNode.binding().isProduction())
+    return bindingGraph.bindings().stream()
+        .filter(binding -> binding.isProduction())
         .flatMap(binding -> incomingDependencies(binding, bindingGraph))
         .filter(edge -> !dependencyCanUseProduction(edge, bindingGraph));
   }
@@ -70,7 +69,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
   /** Returns the dependencies on {@code binding}. */
   // TODO(dpb): Move to BindingGraph.
   private Stream<DependencyEdge> incomingDependencies(
-      BindingNode binding, BindingGraph bindingGraph) {
+      dagger.model.Binding binding, BindingGraph bindingGraph) {
     return bindingGraph.network().inEdges(binding).stream()
         .flatMap(instancesOf(DependencyEdge.class));
   }
@@ -78,7 +77,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
   private boolean dependencyCanUseProduction(DependencyEdge edge, BindingGraph bindingGraph) {
     return edge.isEntryPoint()
         ? entryPointCanUseProduction(edge.dependencyRequest().kind())
-        : bindingRequestingDependency(edge, bindingGraph).binding().isProduction();
+        : bindingRequestingDependency(edge, bindingGraph).isProduction();
   }
 
   /**
@@ -88,16 +87,16 @@ private boolean dependencyCanUseProduction(DependencyEdge edge, BindingGraph bin
    *     DependencyEdge#isEntryPoint() entry point}.
    */
   // TODO(dpb): Move to BindingGraph.
-  private BindingNode bindingRequestingDependency(
+  private dagger.model.Binding bindingRequestingDependency(
       DependencyEdge dependency, BindingGraph bindingGraph) {
     checkArgument(!dependency.isEntryPoint());
     Node source = bindingGraph.network().incidentNodes(dependency).source();
     verify(
-        source instanceof BindingNode,
-        "expected source of %s to be a binding node, but was: %s",
+        source instanceof dagger.model.Binding,
+        "expected source of %s to be a binding, but was: %s",
         dependency,
         source);
-    return (BindingNode) source;
+    return (dagger.model.Binding) source;
   }
 
   private String entryPointErrorMessage(DependencyEdge entryPoint) {
diff --git a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
index 5e9b1e8a8..7c05bc159 100644
--- a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
+++ b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
@@ -79,15 +79,12 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
         subgraphFactoryMethodParameters(edge, graph);
     ComponentNode child = (ComponentNode) graph.network().incidentNodes(edge).target();
     SetView<TypeElement> modulesOwnedByChild = ownedModules(child, graph);
-    return graph.bindingNodes().stream()
+    return graph.bindings().stream()
         // bindings owned by child
-        .filter(node -> node.componentPath().equals(child.componentPath()))
+        .filter(binding -> binding.componentPath().equals(child.componentPath()))
         // that require a module instance
-        .filter(
-            node ->
-                node.binding() instanceof ContributionBinding
-                    && ((ContributionBinding) node.binding()).requiresModuleInstance())
-        .map(node -> node.binding().contributingModule().get())
+        .filter(binding -> binding.requiresModuleInstance())
+        .map(binding -> binding.contributingModule().get())
         .distinct()
         // module owned by child
         .filter(module -> modulesOwnedByChild.contains(module))
diff --git a/java/dagger/model/Binding.java b/java/dagger/model/Binding.java
index 0b0eed1be..5e113bf2c 100644
--- a/java/dagger/model/Binding.java
+++ b/java/dagger/model/Binding.java
@@ -17,6 +17,7 @@
 package dagger.model;
 
 import com.google.common.collect.ImmutableSet;
+import dagger.model.BindingGraph.MaybeBinding;
 import java.util.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -25,11 +26,20 @@
  * The association between a {@link Key} and the way in which instances of the key are provided.
  * Includes any {@linkplain DependencyRequest dependencies} that are needed in order to provide the
  * instances.
+ *
+ * <p>If a binding is owned by more than one component, there is one {@code Binding} for every
+ * owning component.
  */
-public interface Binding {
-  /** The binding's key. */
-  Key key();
+public interface Binding extends MaybeBinding {
+  @Override
+  ComponentPath componentPath();
 
+  /** @deprecated This always returns {@code Optional.of(this)}. */
+  @Override
+  @Deprecated
+  default Optional<Binding> binding() {
+    return Optional.of(this);
+  }
   /**
    * The dependencies of this binding. The order of the dependencies corresponds to the order in
    * which they will be injected when the binding is requested.
@@ -54,6 +64,12 @@
    */
   Optional<TypeElement> contributingModule();
 
+  /**
+   * Returns {@code true} if using this binding requires an instance of the {@link
+   * #contributingModule()}.
+   */
+  boolean requiresModuleInstance();
+
   /** The scope of this binding if it has one. */
   Optional<Scope> scope();
 
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 581a94584..0971fd602 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -44,9 +44,9 @@
  *
  * <h3>Nodes</h3>
  *
- * <p>There is a <b>{@linkplain BindingNode binding node}</b> for each owned binding in the graph.
- * If a binding is owned by more than one component, there is one binding node for that binding for
- * every owning component.
+ * <p>There is a <b>{@link Binding}</b> for each owned binding in the graph. If a binding is owned
+ * by more than one component, there is one binding object for that binding for every owning
+ * component.
  *
  * <p>There is a <b>{@linkplain ComponentNode component node}</b> (without a binding) for each
  * component in the graph.
@@ -54,16 +54,16 @@
  * <h3>Edges</h3>
  *
  * <p>There is a <b>{@linkplain DependencyEdge dependency edge}</b> for each dependency request in
- * the graph. Its target node is the binding node for the binding that satisfies the request. For
- * entry point dependency requests, the source node is the component node for the component for
- * which it is an entry point. For other dependency requests, the source node is the binding node
- * for the binding that contains the request.
+ * the graph. Its target node is the binding for the binding that satisfies the request. For entry
+ * point dependency requests, the source node is the component node for the component for which it
+ * is an entry point. For other dependency requests, the source node is the binding for the binding
+ * that contains the request.
  *
  * <p>There is a <b>subcomponent edge</b> for each parent-child component relationship in the graph.
  * The target node is the component node for the child component. For subcomponents defined by a
  * {@linkplain SubcomponentBuilderBindingEdge subcomponent builder binding} (either a method on the
  * component or a set of {@code @Module.subcomponents} annotation values), the source node is the
- * binding node for the {@code @Subcomponent.Builder} type. For subcomponents defined by {@linkplain
+ * binding for the {@code @Subcomponent.Builder} type. For subcomponents defined by {@linkplain
  * ChildFactoryMethodEdge subcomponent factory methods}, the source node is the component node for
  * the parent.
  *
@@ -102,21 +102,21 @@ public String toString() {
     return network.toString();
   }
 
-  /** Returns the binding nodes. */
-  public ImmutableSet<BindingNode> bindingNodes() {
-    return nodes(BindingNode.class);
+  /** Returns the bindings. */
+  public ImmutableSet<Binding> bindings() {
+    return nodes(Binding.class);
   }
 
-  /** Returns the binding nodes for a key. */
-  public ImmutableSet<BindingNode> bindingNodes(Key key) {
-    return nodeStream(BindingNode.class)
-        .filter(node -> node.key().equals(key))
+  /** Returns the bindings for a key. */
+  public ImmutableSet<Binding> bindings(Key key) {
+    return nodeStream(Binding.class)
+        .filter(binding -> binding.key().equals(key))
         .collect(toImmutableSet());
   }
 
   /** Returns the nodes that represent missing bindings. */
-  public ImmutableSet<MissingBindingNode> missingBindingNodes() {
-    return nodes(MissingBindingNode.class);
+  public ImmutableSet<MissingBinding> missingBindings() {
+    return nodes(MissingBinding.class);
   }
 
   /** Returns the component nodes. */
@@ -156,11 +156,10 @@ public ComponentNode rootComponentNode() {
    * DependencyRequest} will map to a single {@link DependencyEdge}. When conflicting bindings exist
    * for a key, the multimap will have several edges for that {@link DependencyRequest}. Graphs that
    * have no binding for a key will have an edge whose {@linkplain EndpointPair#target() target
-   * node} is a {@link MissingBindingNode}.
+   * node} is a {@link MissingBinding}.
    */
-  public ImmutableSetMultimap<DependencyRequest, DependencyEdge> dependencyEdges(
-      BindingNode bindingNode) {
-    return dependencyEdgeStream(bindingNode)
+  public ImmutableSetMultimap<DependencyRequest, DependencyEdge> dependencyEdges(Binding binding) {
+    return dependencyEdgeStream(binding)
         .collect(toImmutableSetMultimap(DependencyEdge::dependencyRequest, edge -> edge));
   }
 
@@ -191,10 +190,10 @@ public ComponentNode rootComponentNode() {
     return entryPointEdgeStream().collect(toImmutableSet());
   }
 
-  /** Returns the binding nodes or missing binding nodes that directly satisfy entry points. */
-  public ImmutableSet<MaybeBindingNode> entryPointBindingNodes() {
+  /** Returns the binding or missing binding nodes that directly satisfy entry points. */
+  public ImmutableSet<MaybeBinding> entryPointBindings() {
     return entryPointEdgeStream()
-        .map(edge -> (MaybeBindingNode) network.incidentNodes(edge).target())
+        .map(edge -> (MaybeBinding) network.incidentNodes(edge).target())
         .collect(toImmutableSet());
   }
 
@@ -202,15 +201,14 @@ public ComponentNode rootComponentNode() {
    * Returns the edges for entry points that transitively depend on a binding or missing binding for
    * a key. Never returns an empty set.
    */
-  public ImmutableSet<DependencyEdge> entryPointEdgesDependingOnBindingNode(
-      MaybeBindingNode bindingNode) {
+  public ImmutableSet<DependencyEdge> entryPointEdgesDependingOnBindingNode(MaybeBinding binding) {
     ImmutableNetwork<Node, DependencyEdge> dependencyGraph = dependencyGraph();
     Network<Node, DependencyEdge> subgraphDependingOnBindingNode =
         inducedSubgraph(
-            dependencyGraph, reachableNodes(transpose(dependencyGraph).asGraph(), bindingNode));
+            dependencyGraph, reachableNodes(transpose(dependencyGraph).asGraph(), binding));
     ImmutableSet<DependencyEdge> entryPointEdges =
         intersection(entryPointEdges(), subgraphDependingOnBindingNode.edges()).immutableCopy();
-    verify(!entryPointEdges.isEmpty(), "No entry points depend on binding %s", bindingNode);
+    verify(!entryPointEdges.isEmpty(), "No entry points depend on binding %s", binding);
     return entryPointEdges;
   }
 
@@ -260,10 +258,10 @@ public ComponentNode rootComponentNode() {
    * element), this class does not override {@link #equals(Object)} to use value semantics.
    *
    * <p>For entry points, the source node is the {@link ComponentNode} that contains the entry
-   * point. Otherwise the source node is a {@link BindingNode}.
+   * point. Otherwise the source node is a {@link Binding}.
    *
-   * <p>For dependencies on missing bindings, the target node is a {@link MissingBindingNode}.
-   * Otherwise the target node is a {@link BindingNode}.
+   * <p>For dependencies on missing bindings, the target node is a {@link MissingBinding}. Otherwise
+   * the target node is a {@link Binding}.
    */
   public interface DependencyEdge extends Edge {
     /** The dependency request. */
@@ -285,8 +283,8 @@ public ComponentNode rootComponentNode() {
   /**
    * An edge that represents the link between a parent component and a child subcomponent implied by
    * a subcomponent builder binding. The {@linkplain com.google.common.graph.EndpointPair#source()
-   * source node} of this edge is a {@link BindingNode} for the subcomponent builder {@link Key} and
-   * the {@linkplain com.google.common.graph.EndpointPair#target() target node} is a {@link
+   * source node} of this edge is a {@link Binding} for the subcomponent builder {@link Key} and the
+   * {@linkplain com.google.common.graph.EndpointPair#target() target node} is a {@link
    * ComponentNode} for the child subcomponent.
    */
   public interface SubcomponentBuilderBindingEdge extends Edge {
@@ -298,17 +296,15 @@ public ComponentNode rootComponentNode() {
     ImmutableSet<TypeElement> declaringModules();
   }
 
-  /** A node in the binding graph. Either a {@link BindingNode} or a {@link ComponentNode}. */
+  /** A node in the binding graph. Either a {@link Binding} or a {@link ComponentNode}. */
+  // TODO(dpb): Make all the node/edge types top-level.
   public interface Node {
     /** The component this node belongs to. */
     ComponentPath componentPath();
   }
 
-  /**
-   * A node in the binding graph that is either a {@link BindingNode} or a {@link
-   * MissingBindingNode}.
-   */
-  public interface MaybeBindingNode extends Node {
+  /** A node in the binding graph that is either a {@link Binding} or a {@link MissingBinding}. */
+  public interface MaybeBinding extends Node {
 
     /** The component that owns the binding, or in which the binding is missing. */
     @Override
@@ -318,38 +314,14 @@ public ComponentNode rootComponentNode() {
     Key key();
 
     /** The binding, or empty if missing. */
-    Optional<Binding> maybeBinding();
-  }
-
-  /**
-   * A <b>binding node</b> in the binding graph. If a binding is owned by more than one component,
-   * there is one binding node for that binding for every owning component.
-   */
-  public interface BindingNode extends MaybeBindingNode {
-
-    /** The component that owns the {@link #binding()}. */
-    @Override
-    ComponentPath componentPath();
-
-    /** The binding. */
-    Binding binding();
-
-    @Override
-    default Key key() {
-      return binding().key();
-    }
-
-    @Override
-    default Optional<Binding> maybeBinding() {
-      return Optional.of(binding());
-    }
+    Optional<Binding> binding();
   }
 
   /** A node in the binding graph that represents a missing binding for a key in a component. */
   @AutoValue
-  public abstract static class MissingBindingNode implements MaybeBindingNode {
-    static MissingBindingNode create(ComponentPath component, Key key) {
-      return new AutoValue_BindingGraph_MissingBindingNode(component, key);
+  public abstract static class MissingBinding implements MaybeBinding {
+    static MissingBinding create(ComponentPath component, Key key) {
+      return new AutoValue_BindingGraph_MissingBinding(component, key);
     }
 
     /** The component in which the binding is missing. */
@@ -359,8 +331,10 @@ static MissingBindingNode create(ComponentPath component, Key key) {
     /** The key for which there is no binding. */
     public abstract Key key();
 
+    /** @deprecated This always returns {@code Optional.empty()}. */
     @Override
-    public final Optional<Binding> maybeBinding() {
+    @Deprecated
+    public final Optional<Binding> binding() {
       return Optional.empty();
     }
 
diff --git a/java/dagger/model/BindingGraphProxies.java b/java/dagger/model/BindingGraphProxies.java
index 1e3ec5637..2eab0b9fa 100644
--- a/java/dagger/model/BindingGraphProxies.java
+++ b/java/dagger/model/BindingGraphProxies.java
@@ -18,7 +18,7 @@
 
 import com.google.common.graph.Network;
 import dagger.model.BindingGraph.Edge;
-import dagger.model.BindingGraph.MissingBindingNode;
+import dagger.model.BindingGraph.MissingBinding;
 import dagger.model.BindingGraph.Node;
 
 /**
@@ -32,9 +32,9 @@ public static BindingGraph bindingGraph(Network<Node, Edge> network) {
     return new BindingGraph(network);
   }
 
-  /** Creates a new {@link MissingBindingNode}. */
-  public static MissingBindingNode missingBindingNode(ComponentPath component, Key key) {
-    return MissingBindingNode.create(component, key);
+  /** Creates a new {@link MissingBinding}. */
+  public static MissingBinding missingBindingNode(ComponentPath component, Key key) {
+    return MissingBinding.create(component, key);
   }
 
   private BindingGraphProxies() {}
diff --git a/java/dagger/model/testing/BindingGraphSubject.java b/java/dagger/model/testing/BindingGraphSubject.java
index cd4e65ce1..a10e3a32c 100644
--- a/java/dagger/model/testing/BindingGraphSubject.java
+++ b/java/dagger/model/testing/BindingGraphSubject.java
@@ -23,8 +23,8 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.truth.FailureMetadata;
 import com.google.common.truth.Subject;
+import dagger.model.Binding;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import javax.lang.model.type.TypeMirror;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
@@ -65,7 +65,7 @@ public void hasBindingWithKey(String qualifier, String type) {
    *
    * @param type the canonical name of the type, as returned by {@link TypeMirror#toString()}
    */
-  public BindingNodeSubject bindingWithKey(String type) {
+  public BindingSubject bindingWithKey(String type) {
     return bindingWithKeyString(keyString(type));
   }
 
@@ -76,28 +76,28 @@ public BindingNodeSubject bindingWithKey(String type) {
    *     javax.lang.model.element.AnnotationMirror AnnotationMirror.toString()}
    * @param type the canonical name of the type, as returned by {@link TypeMirror#toString()}
    */
-  public BindingNodeSubject bindingWithKey(String qualifier, String type) {
+  public BindingSubject bindingWithKey(String qualifier, String type) {
     return bindingWithKeyString(keyString(qualifier, type));
   }
 
-  private BindingNodeSubject bindingWithKeyString(String keyString) {
-    ImmutableSet<BindingNode> bindingNodes = getBindingNodes(keyString);
-    if (bindingNodes.isEmpty()) {
+  private BindingSubject bindingWithKeyString(String keyString) {
+    ImmutableSet<Binding> bindings = getBindingNodes(keyString);
+    if (bindings.isEmpty()) {
       fail("has binding with key", keyString);
     }
     // TODO(dpb): Handle multiple bindings for the same key.
-    if (bindingNodes.size() > 1) {
+    if (bindings.size() > 1) {
       failWithBadResults(
-          "has only one binding with key", keyString, "has the following bindings:", bindingNodes);
+          "has only one binding with key", keyString, "has the following bindings:", bindings);
     }
     return check("bindingWithKey(%s)", keyString)
-        .about(BindingNodeSubject::new)
-        .that(getOnlyElement(bindingNodes));
+        .about(BindingSubject::new)
+        .that(getOnlyElement(bindings));
   }
 
-  private ImmutableSet<BindingNode> getBindingNodes(String keyString) {
-    return actual().bindingNodes().stream()
-        .filter(node -> node.key().toString().equals(keyString))
+  private ImmutableSet<Binding> getBindingNodes(String keyString) {
+    return actual().bindings().stream()
+        .filter(binding -> binding.key().toString().equals(keyString))
         .collect(toImmutableSet());
   }
 
@@ -109,15 +109,15 @@ private static String keyString(String qualifier, String type) {
     return String.format("%s %s", qualifier, type);
   }
 
-  /** A Truth subject for a {@link BindingNode}. */
-  public final class BindingNodeSubject extends Subject<BindingNodeSubject, BindingNode> {
+  /** A Truth subject for a {@link Binding}. */
+  public final class BindingSubject extends Subject<BindingSubject, Binding> {
 
-    BindingNodeSubject(FailureMetadata metadata, @NullableDecl BindingNode actual) {
+    BindingSubject(FailureMetadata metadata, @NullableDecl Binding actual) {
       super(metadata, actual);
     }
 
     /**
-     * Asserts that the binding node depends on a binding with an unqualified key.
+     * Asserts that the binding depends on a binding with an unqualified key.
      *
      * @param type the canonical name of the type, as returned by {@link TypeMirror#toString()}
      */
@@ -126,7 +126,7 @@ public void dependsOnBindingWithKey(String type) {
     }
 
     /**
-     * Asserts that the binding node depends on a binding with a qualified key.
+     * Asserts that the binding depends on a binding with a qualified key.
      *
      * @param qualifier the canonical string form of the qualifier, as returned by {@link
      *     javax.lang.model.element.AnnotationMirror AnnotationMirror.toString()}
@@ -138,10 +138,10 @@ public void dependsOnBindingWithKey(String qualifier, String type) {
 
     private void dependsOnBindingWithKeyString(String keyString) {
       if (actualBindingGraph().network().successors(actual()).stream()
-          .filter(node -> node instanceof BindingNode)
-          .map(node -> (BindingNode) node)
-          .noneMatch(node -> node.key().toString().equals(keyString))) {
-        fail("has successor with key", keyString);
+          .filter(node -> node instanceof Binding)
+          .map(node -> (Binding) node)
+          .noneMatch(binding -> binding.key().toString().equals(keyString))) {
+        fail("depends on binding with key", keyString);
       }
     }
 
diff --git a/java/dagger/spi/DiagnosticReporter.java b/java/dagger/spi/DiagnosticReporter.java
index 8c15149d6..f9ec41e06 100644
--- a/java/dagger/spi/DiagnosticReporter.java
+++ b/java/dagger/spi/DiagnosticReporter.java
@@ -21,7 +21,7 @@
 import dagger.model.BindingGraph.ChildFactoryMethodEdge;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
-import dagger.model.BindingGraph.MaybeBindingNode;
+import dagger.model.BindingGraph.MaybeBinding;
 import javax.tools.Diagnostic;
 
 /**
@@ -53,7 +53,7 @@ void reportComponent(
    * Reports a diagnostic for a binding or missing binding. Includes information about how the
    * binding is reachable from entry points.
    */
-  void reportBinding(Diagnostic.Kind diagnosticKind, MaybeBindingNode bindingNode, String message);
+  void reportBinding(Diagnostic.Kind diagnosticKind, MaybeBinding binding, String message);
 
   /**
    * Reports a diagnostic for a binding or missing binding. Includes information about how the
@@ -62,7 +62,7 @@ void reportComponent(
   @FormatMethod
   void reportBinding(
       Diagnostic.Kind diagnosticKind,
-      MaybeBindingNode bindingNode,
+      MaybeBinding binding,
       String messageFormat,
       Object firstArg,
       Object... moreArgs);
diff --git a/javatests/dagger/spi/FailingPlugin.java b/javatests/dagger/spi/FailingPlugin.java
index 71c1ed793..39623355b 100644
--- a/javatests/dagger/spi/FailingPlugin.java
+++ b/javatests/dagger/spi/FailingPlugin.java
@@ -43,9 +43,11 @@ public void initOptions(Map<String, String> options) {
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
     if (options.containsKey("error_on_binding")) {
       String key = options.get("error_on_binding");
-      bindingGraph.bindingNodes().stream()
-          .filter(node -> node.key().toString().equals(key))
-          .forEach(node -> diagnosticReporter.reportBinding(ERROR, node, "Bad Binding: %s", node));
+      bindingGraph.bindings().stream()
+          .filter(binding -> binding.key().toString().equals(key))
+          .forEach(
+              binding ->
+                  diagnosticReporter.reportBinding(ERROR, binding, "Bad Binding: %s", binding));
     }
 
     if (options.containsKey("error_on_component")) {
@@ -58,10 +60,11 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
     if (options.containsKey("error_on_subcomponents")) {
       bindingGraph.componentNodes().stream()
-          .filter(node -> !node.componentPath().atRoot())
+          .filter(componentNode -> !componentNode.componentPath().atRoot())
           .forEach(
-              node ->
-                  diagnosticReporter.reportComponent(ERROR, node, "Bad Subcomponent: %s", node));
+              componentNode ->
+                  diagnosticReporter.reportComponent(
+                      ERROR, componentNode, "Bad Subcomponent: %s", componentNode));
     }
 
     if (options.containsKey("error_on_dependency")) {
