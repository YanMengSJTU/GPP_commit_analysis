diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 174979596..69dac084b 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -174,7 +174,7 @@ TypeElement componentTypeElement() {
    */
   @Memoized
   ImmutableSet<ComponentRequirement> possiblyNecessaryRequirements() {
-    checkState(!componentDescriptor().kind().isTopLevel());
+    checkState(!componentDescriptor().kind().isRoot());
     return componentRequirements(
         StreamSupport.stream(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this).spliterator(), false)
             .flatMap(graph -> graph.ownedModules().stream())
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index aec497e82..ee82f2a26 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -55,11 +55,11 @@
   }
 
   /**
-   * Creates the external {@link dagger.model.BindingGraph} representing the given internal root
-   * {@link dagger.internal.codegen.BindingGraph}.
+   * Creates the external {@link dagger.model.BindingGraph} representing the given internal {@link
+   * dagger.internal.codegen.BindingGraph}.
    */
-  dagger.model.BindingGraph convert(BindingGraph rootGraph) {
-    Traverser traverser = new Traverser(rootGraph);
+  dagger.model.BindingGraph convert(BindingGraph bindingGraph) {
+    Traverser traverser = new Traverser(bindingGraph);
     traverser.traverseComponents();
 
     // When bindings are copied down into child graphs because they transitively depend on local
@@ -70,11 +70,9 @@
     unreachableNodes(traverser.network.asGraph(), rootComponentNode(traverser.network))
         .forEach(traverser.network::removeNode);
 
-    ComponentKind rootComponentKind = rootGraph.componentDescriptor().kind();
+    ComponentKind componentKind = bindingGraph.componentDescriptor().kind();
     return BindingGraphProxies.bindingGraph(
-        traverser.network,
-        rootComponentKind.isForModuleValidation(),
-        !rootComponentKind.isTopLevel());
+        traverser.network, componentKind.isForModuleValidation(), !componentKind.isRoot());
   }
 
   // TODO(dpb): Example of BindingGraph logic applied to derived networks.
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 748fd1bbb..9a3560c86 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -98,7 +98,7 @@
   /** Creates a binding graph for a root component. */
   BindingGraph create(ComponentDescriptor componentDescriptor) {
     checkArgument(
-        componentDescriptor.kind().isTopLevel() || compilerOptions.aheadOfTimeSubcomponents());
+        componentDescriptor.kind().isRoot() || compilerOptions.aheadOfTimeSubcomponents());
     return create(Optional.empty(), componentDescriptor);
   }
 
@@ -236,7 +236,7 @@ private boolean shouldIncludeImplicitProductionModules(
       ComponentDescriptor componentDescriptor, Optional<Resolver> parentResolver) {
     ComponentKind kind = componentDescriptor.kind();
     return kind.isProducer()
-        && ((kind.isTopLevel() && !kind.isForModuleValidation())
+        && ((kind.isRoot() && !kind.isForModuleValidation())
             || (parentResolver.isPresent()
                 && !parentResolver.get().componentDescriptor.kind().isProducer()));
   }
@@ -396,7 +396,7 @@ private boolean isIncorrectlyScopedInPartialGraph(ProvisionBinding binding) {
       checkArgument(binding.kind().equals(INJECTION));
       Resolver owningResolver = getOwningResolver(binding).orElse(this);
       ComponentDescriptor owningComponent = owningResolver.componentDescriptor;
-      return !rootComponent().kind().isTopLevel()
+      return !rootComponent().kind().isRoot()
           && binding.scope().isPresent()
           && !owningComponent.scopes().contains(binding.scope().get());
     }
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 9d405e377..2ae713151 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -274,7 +274,7 @@ private static boolean doesComponentMethodMatch(
    * builder.
    */
   final boolean hasCreator() {
-    return kind().isTopLevel() || creatorDescriptor().isPresent();
+    return kind().isRoot() || creatorDescriptor().isPresent();
   }
 
   /**
@@ -404,7 +404,7 @@ ComponentDescriptor forTypeElement(TypeElement typeElement) {
           "%s must have a component or subcomponent or module annotation",
           typeElement);
       if (!compilerOptions.aheadOfTimeSubcomponents()) {
-        checkArgument(kind.get().isTopLevel(), "%s must be a top-level component.", typeElement);
+        checkArgument(kind.get().isRoot(), "%s must be a top-level component.", typeElement);
       }
       return create(typeElement, kind.get());
     }
@@ -414,7 +414,7 @@ private ComponentDescriptor create(TypeElement typeElement, ComponentKind kind)
           getAnnotationMirror(typeElement, kind.annotation()).get();
       DeclaredType declaredComponentType = MoreTypes.asDeclared(typeElement.asType());
       ImmutableSet<ComponentRequirement> componentDependencies =
-          kind.isTopLevel() && !kind.isForModuleValidation()
+          kind.isRoot() && !kind.isForModuleValidation()
               ? getComponentDependencies(componentAnnotation).stream()
                   .map(ComponentRequirement::forDependency)
                   .collect(toImmutableSet())
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index 6fdcc77a4..5ff1bbadb 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -23,7 +23,7 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static dagger.internal.codegen.ComponentGenerator.componentName;
 import static dagger.internal.codegen.ComponentKind.annotationsFor;
-import static dagger.internal.codegen.ComponentKind.topLevelComponentKinds;
+import static dagger.internal.codegen.ComponentKind.rootComponentKinds;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -102,7 +102,7 @@
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return annotationsFor(topLevelComponentKinds());
+    return annotationsFor(rootComponentKinds());
   }
 
   @Override
@@ -213,7 +213,7 @@ private MethodSpec privateConstructor() {
    * ComponentDescriptor#creatorDescriptor()}.
    */
   private Stream<ComponentRequirement> componentRequirements(ComponentDescriptor component) {
-    checkArgument(component.kind().isTopLevel());
+    checkArgument(component.kind().isRoot());
     return Stream.concat(
         component.dependencies().stream(),
         component.modules().stream()
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
index 972a0cded..1f1909ca2 100644
--- a/java/dagger/internal/codegen/ComponentImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -137,7 +137,7 @@ ComponentImplementation topLevelImplementation(ClassName name, BindingGraph grap
         Optional.empty(), // superclassImplementation
         new SubcomponentNames(graph, keyFactory),
         PUBLIC,
-        graph.componentDescriptor().kind().isTopLevel() ? FINAL : ABSTRACT);
+        graph.componentDescriptor().kind().isRoot() ? FINAL : ABSTRACT);
   }
 
   abstract static class ComponentImplementationBuilder {
diff --git a/java/dagger/internal/codegen/ComponentKind.java b/java/dagger/internal/codegen/ComponentKind.java
index 74d94f731..73af19a7b 100644
--- a/java/dagger/internal/codegen/ComponentKind.java
+++ b/java/dagger/internal/codegen/ComponentKind.java
@@ -67,21 +67,21 @@
   PRODUCER_MODULE(ProducerModule.class, Optional.empty(), true, true),
   ;
 
-  private static final ImmutableSet<ComponentKind> TOP_LEVEL_COMPONENT_KINDS =
+  private static final ImmutableSet<ComponentKind> ROOT_COMPONENT_KINDS =
       stream(values())
           .filter(kind -> !kind.isForModuleValidation())
-          .filter(kind -> kind.isTopLevel())
+          .filter(kind -> kind.isRoot())
           .collect(toImmutableSet());
 
   private static final ImmutableSet<ComponentKind> SUBCOMPONENT_KINDS =
       stream(values())
           .filter(kind -> !kind.isForModuleValidation())
-          .filter(kind -> !kind.isTopLevel())
+          .filter(kind -> !kind.isRoot())
           .collect(toImmutableSet());
 
-  /** Returns the set of kinds for top-level components. */
-  static ImmutableSet<ComponentKind> topLevelComponentKinds() {
-    return TOP_LEVEL_COMPONENT_KINDS;
+  /** Returns the set of kinds for root components. */
+  static ImmutableSet<ComponentKind> rootComponentKinds() {
+    return ROOT_COMPONENT_KINDS;
   }
 
   /** Returns the set of kinds for subcomponents. */
@@ -162,17 +162,17 @@
 
   private final Class<? extends Annotation> annotation;
   private final Optional<Class<? extends Annotation>> builderAnnotation;
-  private final boolean topLevel;
+  private final boolean isRoot;
   private final boolean production;
 
   ComponentKind(
       Class<? extends Annotation> annotation,
       Optional<Class<? extends Annotation>> builderAnnotation,
-      boolean topLevel,
+      boolean isRoot,
       boolean production) {
     this.annotation = annotation;
     this.builderAnnotation = builderAnnotation;
-    this.topLevel = topLevel;
+    this.isRoot = isRoot;
     this.production = production;
   }
 
@@ -205,11 +205,11 @@
   }
 
   /**
-   * Returns {@code true} if the descriptor is for a top-level (not a child) component or is for
+   * Returns {@code true} if the descriptor is for a root component (not a subcomponent) or is for
    * {@linkplain #isForModuleValidation() module-validation}.
    */
-  boolean isTopLevel() {
-    return topLevel;
+  boolean isRoot() {
+    return isRoot;
   }
 
   /** Returns true if this is a production component. */
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 2a6397241..0f1cfaac3 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -19,8 +19,8 @@
 import static dagger.internal.codegen.ComponentKind.allComponentAndBuilderAnnotations;
 import static dagger.internal.codegen.ComponentKind.annotationsFor;
 import static dagger.internal.codegen.ComponentKind.builderAnnotationsFor;
+import static dagger.internal.codegen.ComponentKind.rootComponentKinds;
 import static dagger.internal.codegen.ComponentKind.subcomponentKinds;
-import static dagger.internal.codegen.ComponentKind.topLevelComponentKinds;
 import static java.util.Collections.disjoint;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
@@ -108,7 +108,7 @@
     builderReportsByComponent =
         processBuilders(
             getElementsFromAnnotations(
-                elementsByAnnotation, builderAnnotationsFor(topLevelComponentKinds())),
+                elementsByAnnotation, builderAnnotationsFor(rootComponentKinds())),
             rejectedElements);
     builderReportsBySubcomponent = processBuilders(subcomponentBuilderElements, rejectedElements);
     reportsBySubcomponent =
@@ -120,7 +120,7 @@
   @Override
   protected void process(
       TypeElement element, ImmutableSet<Class<? extends Annotation>> annotations) {
-    if (!disjoint(annotations, annotationsFor(topLevelComponentKinds()))) {
+    if (!disjoint(annotations, annotationsFor(rootComponentKinds()))) {
       ComponentValidationReport validationReport =
           componentValidator.validate(element, subcomponentElements, subcomponentBuilderElements);
       validationReport.report().printMessagesTo(messager);
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/ComponentTreeTraverser.java
index 72135f401..5086062e8 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -76,9 +76,9 @@
   /** Constructs a traverser for a root (component, not subcomponent) binding graph. */
   public ComponentTreeTraverser(BindingGraph rootGraph, CompilerOptions compilerOptions) {
     checkArgument(
-        rootGraph.componentDescriptor().kind().isTopLevel()
+        rootGraph.componentDescriptor().kind().isRoot()
             || compilerOptions.aheadOfTimeSubcomponents(),
-        "only top-level graphs can be traversed, not %s",
+        "only root graphs can be traversed, not %s",
         rootGraph.componentTypeElement().getQualifiedName());
     bindingGraphPath.add(rootGraph);
   }
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index 88799dfea..70cdd46cc 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -253,7 +253,7 @@ public ComponentValidationReport validate(
 
     AnnotationMirror componentMirror =
         getAnnotationMirror(subject, componentKind.annotation()).get();
-    if (componentKind.isTopLevel()) {
+    if (componentKind.isRoot()) {
       validateComponentDependencies(report, getComponentDependencies(componentMirror));
     }
     report.addSubreport(
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index c6a699431..7e6e276d6 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -283,7 +283,7 @@ ModifiableBindingType getModifiableBindingType(BindingRequest request) {
 
     // When generating a component the binding is not considered modifiable. Bindings are modifiable
     // only across subcomponent implementations.
-    if (componentImplementation.componentDescriptor().kind().isTopLevel()) {
+    if (componentImplementation.componentDescriptor().kind().isRoot()) {
       return ModifiableBindingType.NONE;
     }
 
