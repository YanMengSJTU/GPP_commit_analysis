diff --git a/.travis.yml b/.travis.yml
index ca2710015..67516b2ff 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -6,14 +6,10 @@ sudo: required
 addons:
   apt:
     sources:
-      # https://github.com/bazelbuild/bazel/issues/1821#issuecomment-262870638
-      - sourceline: "deb [arch=amd64] http://storage.googleapis.com/bazel-apt stable jdk1.8"
-        key_url: "https://storage.googleapis.com/bazel-apt/doc/apt-key.pub.gpg"
       - ubuntu-toolchain-r-test
     packages:
       - oracle-java8-installer
       - libstdc++-4.9-dev # https://github.com/nodegit/nodegit/issues/853
-      - bazel=0.4.5
       - gcc-4.8
       - g++-4.8
 
@@ -30,6 +26,8 @@ android:
     - extra-android-m2repository
 
 before_install:
+  - wget https://github.com/bazelbuild/bazel/releases/download/"${BAZEL_VERSION}"/bazel_"${BAZEL_VERSION}"-linux-x86_64.deb
+  - sudo dpkg -i bazel_"${BAZEL_VERSION}"-linux-x86_64.deb
   - sudo rm -f /etc/mavenrc
   - wget http://www.us.apache.org/dist/maven/maven-3/3.1.1/binaries/apache-maven-3.1.1-bin.tar.gz
   - tar -zxf apache-maven-3.1.1-bin.tar.gz
@@ -47,6 +45,7 @@ env:
     - secure: LTzrlqcSNeZTOV52D3ibY9RBdxY4Yu8dUOYhAonrWLE+eDTzuoyCzcPw8pEcYVNUi1rG6Q7v3QBDTnBztsPoCbcN5tEGjw5cQEbfEzSTkWaNCFjncWn36cLwx9lgbF+5Db/L0mYJ36unDKUpKVC8AgOtxQibfv/ffugfxxj8ohY=
     - secure: PEdRiHTy+xVFPnlBwOhr7RVW/QIFSgd4hO0LESRBeF7KGIjxTZWtKPjnYrysZFm6tozMk6WBVJO6avOss0v7L64nemwpCnSspNYBa6pRGPgQ3rv/wgdPSzqDDmABmpPC18EHbUtF94KVdRX3Cr4kmwKQyD+YUKNRCY11Txt+xfo=
     - JDK_FOR_PUBLISHING: *jdk_for_publishing
+    - BAZEL_VERSION="0.5.1"
 
 after_success:
   - util/generate-latest-docs.sh
diff --git a/README.md b/README.md
index 92b28ecdc..232dc133f 100644
--- a/README.md
+++ b/README.md
@@ -77,6 +77,7 @@ of your `pom.xml` and the `dagger-compiler` artifact as an
 
 If you are using a version of the `maven-compiler-plugin` lower than `3.5`, add
 the `dagger-compiler` artifact with the `provided` scope:
+
 ```xml
 <dependencies>
   <dependency>
@@ -143,7 +144,8 @@ https://bitbucket.org/hvisser/android-apt.
 If you're using the [Android Databinding library][databinding], you may want to
 increase the number of errors that `javac` will print. When Dagger prints an
 error, databinding compilation will halt and sometimes print more than 100
-errors, which is the default amount for `javac`. For more information, see #306.
+errors, which is the default amount for `javac`. For more information, see
+[Issue 306](https://github.com/google/dagger/issues/306).
 
 ```groovy
 gradle.projectsEvaluated {
diff --git a/WORKSPACE b/WORKSPACE
index 729e0290f..aad861295 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -61,14 +61,14 @@ maven_jar(
 
 maven_jar(
     name = "com_google_errorprone_javac",
-    artifact = "com.google.errorprone:javac:9-dev-r3297-1-shaded",
-    sha1 = "0f6d4998965282068a3feecddc21578d23f17275",
+    artifact = "com.google.errorprone:javac-shaded:9-dev-r4023-3",
+    sha1 = "72b688efd290280a0afde5f9892b0fde6f362d1d",
 )
 
 maven_jar(
     name = "com_google_googlejavaformat_google_java_format",
-    artifact = "com.google.googlejavaformat:google-java-format:1.3",
-    sha1 = "949e85e75b3160ce1446aa99d806d5b509631b02",
+    artifact = "com.google.googlejavaformat:google-java-format:1.4",
+    sha1 = "c2f8925850e17caa6da0ed1891a9e9de9414c062",
 )
 
 maven_jar(
@@ -115,8 +115,8 @@ maven_jar(
 
 maven_jar(
     name = "com_google_testing_compile_compile_testing",
-    artifact = "com.google.testing.compile:compile-testing:0.10",
-    sha1 = "51e6189be9d2861d1eb22b4009c8f3430319490c",
+    artifact = "com.google.testing.compile:compile-testing:0.11",
+    sha1 = "bff5d5aa61e6384b9dd4f5f7bb97a921081f4e1c",
 )
 
 maven_jar(
@@ -151,8 +151,8 @@ maven_jar(
 
 maven_jar(
     name = "com_squareup_javapoet",
-    artifact = "com.squareup:javapoet:1.7.0",
-    sha1 = "4fdcf1fc27c1a8f55d1109df986c923152f07759",
+    artifact = "com.squareup:javapoet:1.8.0",
+    sha1 = "e858dc62ef484048540d27d36f3ec2177a3fa9b1",
 )
 
 maven_jar(
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index b0a93ec3c..7a2b9a6c3 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -6,12 +6,12 @@
 public class CoffeeApp {
   @Singleton
   @Component(modules = { DripCoffeeModule.class })
-  public interface Coffee {
+  public interface CoffeeShop {
     CoffeeMaker maker();
   }
 
   public static void main(String[] args) {
-    Coffee coffee = DaggerCoffeeApp_Coffee.builder().build();
-    coffee.maker().brew();
+    CoffeeShop coffeeShop = DaggerCoffeeApp_CoffeeShop.builder().build();
+    coffeeShop.maker().brew();
   }
 }
diff --git a/java/dagger/BindsOptionalOf.java b/java/dagger/BindsOptionalOf.java
index 887d9ae8f..9a356ffeb 100644
--- a/java/dagger/BindsOptionalOf.java
+++ b/java/dagger/BindsOptionalOf.java
@@ -17,9 +17,11 @@
 package dagger;
 
 import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
@@ -41,38 +43,46 @@
  * <p>A {@code @BindsOptionalOf} method:
  *
  * <ul>
- * <li>must be {@code abstract}
- * <li>may have a {@linkplain Qualifier qualifier} annotation
- * <li>must not return {@code void}
- * <li>must not have parameters
- * <li>must not throw exceptions
- * <li>must not return an unqualified type with an {@link Inject @Inject}-annotated constructor,
- *     since such a type is always present
+ *   <li>must be {@code abstract}
+ *   <li>may have a {@linkplain Qualifier qualifier} annotation
+ *   <li>must not return {@code void}
+ *   <li>must not have parameters
+ *   <li>must not throw exceptions
+ *   <li>must not return an unqualified type with an {@link Inject @Inject}-annotated constructor,
+ *       since such a type is always present
  * </ul>
  *
  * <p>Other bindings may inject any of:
  *
  * <ul>
- * <li>{@code Optional<Foo>}
- * <li>{@code Optional<Provider<Foo>>}
- * <li>{@code Optional<Lazy<Foo>>}
- * <li>{@code Optional<Provider<Lazy<Foo>>>}
+ *   <li>{@code Optional<Foo>} (unless there is a {@code @Nullable} binding for {@code Foo}; see
+ *       below)
+ *   <li>{@code Optional<Provider<Foo>>}
+ *   <li>{@code Optional<Lazy<Foo>>}
+ *   <li>{@code Optional<Provider<Lazy<Foo>>>}
  * </ul>
  *
+ * <p>If there is a binding for {@code Foo}, and that binding is {@code @Nullable}, then it is a
+ * compile-time error to inject {@code Optional<Foo>}, because {@code Optional} cannot contain
+ * {@code null}. You can always inject the other forms, because {@link Provider} and {@link Lazy}
+ * can always return {@code null} from their {@code get()} methods.
+ *
  * <p>Explicit bindings for any of the above will conflict with a {@code @BindsOptionalOf} binding.
  *
  * <p>If the binding for {@code Foo} is a {@code @Produces} binding, then another {@code @Produces}
  * binding can depend on any of:
  *
  * <ul>
- * <li>{@code Optional<Foo>}
- * <li>{@code Optional<Producer<Foo>>}
- * <li>{@code Optional<Produced<Foo>>}
+ *   <li>{@code Optional<Foo>}
+ *       <!-- TODO(dpb): Update this once producers support nullability checks -->
+ *   <li>{@code Optional<Producer<Foo>>}
+ *   <li>{@code Optional<Produced<Foo>>}
  * </ul>
  *
  * <p>You can inject either {@code com.google.common.base.Optional} or {@code java.util.Optional}.
  */
 @Documented
 @Beta
+@Retention(RUNTIME)
 @Target(METHOD)
 public @interface BindsOptionalOf {}
diff --git a/java/dagger/android/DaggerActivity.java b/java/dagger/android/DaggerActivity.java
index ff18ed174..1fd9b9d12 100644
--- a/java/dagger/android/DaggerActivity.java
+++ b/java/dagger/android/DaggerActivity.java
@@ -19,6 +19,7 @@
 import android.app.Activity;
 import android.app.Fragment;
 import android.os.Bundle;
+import android.support.annotation.Nullable;
 import dagger.internal.Beta;
 import javax.inject.Inject;
 
@@ -32,7 +33,7 @@
   @Inject DispatchingAndroidInjector<Fragment> fragmentInjector;
 
   @Override
-  protected void onCreate(Bundle savedInstanceState) {
+  protected void onCreate(@Nullable Bundle savedInstanceState) {
     AndroidInjection.inject(this);
     super.onCreate(savedInstanceState);
   }
diff --git a/java/dagger/android/DaggerDialogFragment.java b/java/dagger/android/DaggerDialogFragment.java
new file mode 100644
index 000000000..3aec6545f
--- /dev/null
+++ b/java/dagger/android/DaggerDialogFragment.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.DialogFragment;
+import android.app.Fragment;
+import android.content.Context;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * A {@link DialogFragment} that injects its members in {@link #onAttach(Context)} and can be used
+ * to inject child {@link Fragment}s attached to it. Note that when this fragment gets reattached,
+ * its members will be injected again.
+ */
+@Beta
+public abstract class DaggerDialogFragment extends DialogFragment implements HasFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> childFragmentInjector;
+
+  @Override
+  public void onAttach(Context context) {
+    AndroidInjection.inject(this);
+    super.onAttach(context);
+  }
+
+  @Override
+  public AndroidInjector<Fragment> fragmentInjector() {
+    return childFragmentInjector;
+  }
+}
diff --git a/java/dagger/android/support/DaggerAppCompatActivity.java b/java/dagger/android/support/DaggerAppCompatActivity.java
index adfe4db85..4621e9a6d 100644
--- a/java/dagger/android/support/DaggerAppCompatActivity.java
+++ b/java/dagger/android/support/DaggerAppCompatActivity.java
@@ -17,6 +17,7 @@
 package dagger.android.support;
 
 import android.os.Bundle;
+import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
 import android.support.v7.app.AppCompatActivity;
 import dagger.android.AndroidInjection;
@@ -38,7 +39,7 @@
   @Inject DispatchingAndroidInjector<android.app.Fragment> frameworkFragmentInjector;
 
   @Override
-  protected void onCreate(Bundle savedInstanceState) {
+  protected void onCreate(@Nullable Bundle savedInstanceState) {
     AndroidInjection.inject(this);
     super.onCreate(savedInstanceState);
   }
diff --git a/java/dagger/android/support/DaggerAppCompatDialogFragment.java b/java/dagger/android/support/DaggerAppCompatDialogFragment.java
new file mode 100644
index 000000000..6592c2387
--- /dev/null
+++ b/java/dagger/android/support/DaggerAppCompatDialogFragment.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.content.Context;
+import android.support.v4.app.Fragment;
+import android.support.v7.app.AppCompatDialogFragment;
+import dagger.android.AndroidInjector;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * An {@link AppCompatDialogFragment} that injects its members in {@link #onAttach(Context)} and can
+ * be used to inject child {@link Fragment}s attached to it. Note that when this fragment gets
+ * reattached, its members will be injected again.
+ */
+@Beta
+public abstract class DaggerAppCompatDialogFragment extends AppCompatDialogFragment
+    implements HasSupportFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> childFragmentInjector;
+
+  @Override
+  public void onAttach(Context context) {
+    AndroidSupportInjection.inject(this);
+    super.onAttach(context);
+  }
+
+  @Override
+  public AndroidInjector<Fragment> supportFragmentInjector() {
+    return childFragmentInjector;
+  }
+}
diff --git a/java/dagger/grpc/server/processor/BUILD b/java/dagger/grpc/server/processor/BUILD
index 7220f851a..5e89d3e2e 100644
--- a/java/dagger/grpc/server/processor/BUILD
+++ b/java/dagger/grpc/server/processor/BUILD
@@ -14,6 +14,7 @@ java_library(
         "//third_party:google_java_format",
         "//third_party:guava",
         "//third_party:javapoet",
+        "//third_party:jsr250_annotations",
     ],
 )
 
diff --git a/java/dagger/internal/MapBuilder.java b/java/dagger/internal/MapBuilder.java
new file mode 100644
index 000000000..1560491b1
--- /dev/null
+++ b/java/dagger/internal/MapBuilder.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+
+import java.util.Collections;
+import java.util.Map;
+
+/**
+ * A fluent builder class that returns a {@link Map}. Used in component implementations where a map
+ * must be created in one fluent statement for inlined request fulfillments.
+ */
+public final class MapBuilder<K, V> {
+  private final Map<K, V> contributions;
+
+  private MapBuilder(int size) {
+    contributions = newLinkedHashMapWithExpectedSize(size);
+  }
+
+  /**
+   * Creates a new {@link MapBuilder} with {@code size} elements.
+   */
+  public static <K, V> MapBuilder<K, V> newMapBuilder(int size) {
+    return new MapBuilder<>(size);
+  }
+
+  public MapBuilder<K, V> put(K key, V value) {
+    contributions.put(key, value);
+    return this;
+  }
+
+  public Map<K, V> build() {
+    switch (contributions.size()) {
+      case 0:
+        return Collections.emptyMap();
+      default:
+        return Collections.unmodifiableMap(contributions);
+    }
+  }
+}
diff --git a/java/dagger/internal/MapFactory.java b/java/dagger/internal/MapFactory.java
index d4b918924..b6f925a98 100644
--- a/java/dagger/internal/MapFactory.java
+++ b/java/dagger/internal/MapFactory.java
@@ -17,8 +17,11 @@
 package dagger.internal;
 
 import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.Preconditions.checkNotNull;
 import static java.util.Collections.unmodifiableMap;
 
+import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.inject.Provider;
@@ -32,18 +35,28 @@
  *
  */
 public final class MapFactory<K, V> implements Factory<Map<K, V>> {
+  private static final Provider<Map<Object, Object>> EMPTY =
+      InstanceFactory.create(Collections.emptyMap());
+
   private final Map<K, Provider<V>> contributingMap;
 
-  private MapFactory(Map<K, Provider<V>> map) {
-    this.contributingMap = unmodifiableMap(map);
+  /**
+   * Returns a new {@link Builder}
+   */
+  public static <K, V> Builder<K, V> builder(int size) {
+    return new Builder<>(size);
   }
 
   /**
-   * Returns a new MapFactory.
+   * Returns a factory of an empty map.
    */
-  public static <K, V> MapFactory<K, V> create(Provider<Map<K, Provider<V>>> mapProviderFactory) {
-    Map<K, Provider<V>> map = mapProviderFactory.get();
-    return new MapFactory<K, V>(map);
+  @SuppressWarnings("unchecked") // safe contravariant cast
+  public static <K, V> Provider<Map<K, V>> emptyMapProvider() {
+    return (Provider<Map<K, V>>) (Provider) EMPTY;
+  }
+
+  private MapFactory(Map<K, Provider<V>> map) {
+    this.contributingMap = unmodifiableMap(map);
   }
 
   /**
@@ -58,4 +71,25 @@ private MapFactory(Map<K, Provider<V>> map) {
     }
     return unmodifiableMap(result);
   }
+
+  // TODO(ronshapiro): can we merge the builders? Or maybe just use a (Immutable)MapBuilder?
+  /** A builder for {@link MapFactory}. */
+  public static final class Builder<K, V> {
+    private final LinkedHashMap<K, Provider<V>> map;
+
+    private Builder(int size) {
+      this.map = newLinkedHashMapWithExpectedSize(size);
+    }
+
+    /** Associates {@code key} with {@code providerOfValue}. */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      map.put(checkNotNull(key, "key"), checkNotNull(providerOfValue, "provider"));
+      return this;
+    }
+
+    /** Returns a new {@link MapProviderFactory}. */
+    public MapFactory<K, V> build() {
+      return new MapFactory<>(map);
+    }
+  }
 }
diff --git a/java/dagger/internal/MapProviderFactory.java b/java/dagger/internal/MapProviderFactory.java
index c27beb222..2458a3c05 100644
--- a/java/dagger/internal/MapProviderFactory.java
+++ b/java/dagger/internal/MapProviderFactory.java
@@ -17,10 +17,10 @@
 package dagger.internal;
 
 import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.Preconditions.checkNotNull;
 import static java.util.Collections.unmodifiableMap;
 
 import dagger.Lazy;
-import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import javax.inject.Provider;
@@ -34,24 +34,13 @@
  */
 public final class MapProviderFactory<K, V>
     implements Factory<Map<K, Provider<V>>>, Lazy<Map<K, Provider<V>>> {
-  private static final MapProviderFactory<Object, Object> EMPTY =
-      new MapProviderFactory<Object, Object>(Collections.<Object, Provider<Object>>emptyMap());
-
   private final Map<K, Provider<V>> contributingMap;
 
   /**
    * Returns a new {@link Builder}
    */
   public static <K, V> Builder<K, V> builder(int size) {
-    return new Builder<K, V>(size);
-  }
-
-  /**
-   * Returns a factory of an empty map.
-   */
-  @SuppressWarnings("unchecked") // safe contravariant cast
-  public static <K, V> MapProviderFactory<K, V> empty() {
-    return (MapProviderFactory<K, V>) EMPTY;
+    return new Builder<>(size);
   }
 
   private MapProviderFactory(Map<K, Provider<V>> contributingMap) {
@@ -68,37 +57,23 @@ private MapProviderFactory(Map<K, Provider<V>> contributingMap) {
     return this.contributingMap;
   }
 
-  /**
-   * A builder to help build the {@link MapProviderFactory}
-   */
+  /** A builder for {@link MapProviderFactory}. */
   public static final class Builder<K, V> {
-    private final LinkedHashMap<K, Provider<V>> mapBuilder;
+    private final LinkedHashMap<K, Provider<V>> map;
 
     private Builder(int size) {
-      // TODO(user): consider which way to initialize mapBuilder is better
-      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
+      this.map = newLinkedHashMapWithExpectedSize(size);
     }
 
-    /**
-     * Returns a new {@link MapProviderFactory}
-     */
-    public MapProviderFactory<K, V> build() {
-      return new MapProviderFactory<K, V>(this.mapBuilder);
-    }
-
-    /**
-     * Associate k with providerOfValue in {@code Builder}
-     */
+    /** Associates {@code key} with {@code providerOfValue}. */
     public Builder<K, V> put(K key, Provider<V> providerOfValue) {
-      if (key == null) {
-        throw new NullPointerException("The key is null");
-      }
-      if (providerOfValue == null) {
-        throw new NullPointerException("The provider of the value is null");
-      }
-
-      this.mapBuilder.put(key, providerOfValue);
+      map.put(checkNotNull(key, "key"), checkNotNull(providerOfValue, "provider"));
       return this;
     }
+
+    /** Returns a new {@link MapProviderFactory}. */
+    public MapProviderFactory<K, V> build() {
+      return new MapProviderFactory<>(map);
+    }
   }
 }
diff --git a/java/dagger/internal/MembersInjectors.java b/java/dagger/internal/MembersInjectors.java
index 44d37af12..c90e2ab22 100644
--- a/java/dagger/internal/MembersInjectors.java
+++ b/java/dagger/internal/MembersInjectors.java
@@ -53,21 +53,12 @@
     INSTANCE;
 
     @Override public void injectMembers(Object instance) {
-      checkNotNull(instance);
+      checkInstanceNotNull(instance);
     }
   }
 
-  /**
-   * Returns a {@link MembersInjector} that delegates to the {@link MembersInjector} of its
-   * supertype.  This is useful for cases where a type is known not to have its own {@link Inject}
-   * members, but must still inject members on its supertype(s).
-   *
-   * <p>Note that there is no verification that the type being injected does not have {@link Inject}
-   * members, so care should be taken to ensure appropriate use.
-   */
-  @SuppressWarnings("unchecked")
-  public static <T> MembersInjector<T> delegatingTo(MembersInjector<? super T> delegate) {
-    return (MembersInjector<T>) checkNotNull(delegate);
+  public static void checkInstanceNotNull(Object instance) {
+    checkNotNull(instance, "Cannot inject members into a null reference");
   }
 
   private MembersInjectors() {}
diff --git a/java/dagger/internal/SetBuilder.java b/java/dagger/internal/SetBuilder.java
new file mode 100644
index 000000000..41a2fc721
--- /dev/null
+++ b/java/dagger/internal/SetBuilder.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * A fluent builder class that returns a {@link Set}. Used in component implementations where a set
+ * must be created in one fluent statement for inlined request fulfillments.
+ */
+public final class SetBuilder<T> {
+  private static final String SET_CONTRIBUTIONS_CANNOT_BE_NULL =
+      "Set contributions cannot be null";
+  private final List<T> contributions;
+
+  private SetBuilder(int estimatedSize) {
+    contributions = new ArrayList<>(estimatedSize);
+  }
+
+  /**
+   * {@code estimatedSize} is the number of bindings which contribute to the set. They may each
+   * provide {@code [0..n)} instances to the set. Because the final size is unknown, {@code
+   * contributions} are collected in a list and only hashed in {@link #build()}.
+   */
+  public static <T> SetBuilder<T> newSetBuilder(int estimatedSize) {
+    return new SetBuilder<T>(estimatedSize);
+  }
+
+  public SetBuilder<T> add(T t) {
+    contributions.add(checkNotNull(t, SET_CONTRIBUTIONS_CANNOT_BE_NULL));
+    return this;
+  }
+
+  public SetBuilder<T> addAll(Collection<? extends T> collection) {
+    for (T item : collection) {
+      checkNotNull(item, SET_CONTRIBUTIONS_CANNOT_BE_NULL);
+    }
+    contributions.addAll(collection);
+    return this;
+  }
+
+  public Set<T> build() {
+    switch (contributions.size()) {
+      case 0:
+        return Collections.emptySet();
+      case 1:
+        return Collections.singleton(contributions.get(0));
+      default:
+        return Collections.unmodifiableSet(new HashSet<>(contributions));
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 97b89c9e1..26ebfdfbf 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -16,168 +16,91 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
-import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
-import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
-import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
-import static dagger.internal.codegen.BindingKey.contribution;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
-import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
-import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
-import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
-import static dagger.internal.codegen.MemberSelect.emptySetProvider;
 import static dagger.internal.codegen.MemberSelect.localField;
-import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
-import static dagger.internal.codegen.MemberSelect.staticMethod;
-import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.Scope.reusableScope;
-import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
-import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
-import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
-import static dagger.internal.codegen.TypeNames.LISTENABLE_FUTURE;
-import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
-import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCED_PRODUCER;
-import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
-import static dagger.internal.codegen.TypeNames.MAP_PRODUCER;
-import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
-import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
-import static dagger.internal.codegen.TypeNames.PRODUCER;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER_MANAGER;
-import static dagger.internal.codegen.TypeNames.SET_FACTORY;
-import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
-import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
-import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
-import static dagger.internal.codegen.TypeNames.providerOf;
-import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static javax.lang.model.element.Modifier.ABSTRACT;
+import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Joiner;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
+import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
-import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
-import com.squareup.javapoet.TypeVariableName;
-import dagger.internal.DelegateFactory;
-import dagger.internal.InstanceFactory;
-import dagger.internal.MapFactory;
-import dagger.internal.MapProviderFactory;
-import dagger.internal.Preconditions;
-import dagger.internal.SetFactory;
-import dagger.internal.TypedReleasableReferenceManagerDecorator;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
-import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.producers.Produced;
-import dagger.producers.Producer;
-import dagger.producers.internal.MapOfProducerProducer;
-import dagger.producers.internal.MapProducer;
-import dagger.producers.internal.SetOfProducedProducer;
-import dagger.producers.internal.SetProducer;
+import dagger.internal.codegen.InjectionMethods.InjectionSiteMethod;
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.util.Arrays;
-import java.util.EnumSet;
-import java.util.HashMap;
-import java.util.HashSet;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
-import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
 
 /** Creates the implementation class for a component or subcomponent. */
-abstract class AbstractComponentWriter implements HasBindingMembers {
-  private static final String NOOP_BUILDER_METHOD_JAVADOC =
-      "This module is declared, but an instance is not used in the component. This method is a "
-          + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
-
+abstract class AbstractComponentWriter implements GeneratedComponentModel {
   // TODO(dpb): Make all these fields private after refactoring is complete.
   protected final Elements elements;
-  protected final Types types;
+  protected final DaggerTypes types;
   protected final Key.Factory keyFactory;
   protected final CompilerOptions compilerOptions;
   protected final ClassName name;
   protected final BindingGraph graph;
   protected final ImmutableMap<ComponentDescriptor, String> subcomponentNames;
-  private final Map<BindingKey, InitializationState> initializationStates = new HashMap<>();
   protected final TypeSpec.Builder component;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
-  private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
-  private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
-  private final RequestFulfillmentRegistry requestFulfillmentRegistry;
+  private final UniqueNameSet componentMethodNames = new UniqueNameSet();
+  private final ComponentBindingExpressions bindingExpressions;
+  protected final ComponentRequirementFields componentRequirementFields;
+  private final List<CodeBlock> initializations = new ArrayList<>();
+  protected final List<MethodSpec> interfaceMethods = new ArrayList<>();
+  private final BindingExpression.Factory bindingExpressionFactory;
+  private final ComponentRequirementField.Factory componentRequirementFieldFactory;
+
+  private final Map<Key, MethodSpec> membersInjectionMethods = new LinkedHashMap<>();
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
-  protected Optional<ClassName> builderName = Optional.empty();
   private final OptionalFactories optionalFactories;
+  private ComponentBuilder builder;
   private boolean done;
 
   /**
    * For each component requirement, the builder field. This map is empty for subcomponents that do
    * not use a builder.
    */
-  private ImmutableMap<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.of();
-
-  /**
-   * For each component requirement, the member select for the component field that holds it.
-   *
-   * <p>Fields are written for all requirements for subcomponents that do not use a builder, and for
-   * any requirement that is reused from a subcomponent of this component.
-   */
-  protected final Map<ComponentRequirement, MemberSelect> componentContributionFields =
-      Maps.newHashMap();
+  private final ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
 
   /**
    * The member-selects for {@link dagger.internal.ReferenceReleasingProviderManager} fields,
@@ -186,14 +109,16 @@
   private ImmutableMap<Scope, MemberSelect> referenceReleasingProviderManagerFields;
 
   AbstractComponentWriter(
-      Types types,
+      DaggerTypes types,
       Elements elements,
       Key.Factory keyFactory,
       CompilerOptions compilerOptions,
       ClassName name,
       BindingGraph graph,
       ImmutableMap<ComponentDescriptor, String> subcomponentNames,
-      OptionalFactories optionalFactories) {
+      OptionalFactories optionalFactories,
+      ComponentBindingExpressions bindingExpressions,
+      ComponentRequirementFields componentRequirementFields) {
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
@@ -203,8 +128,44 @@
     this.graph = graph;
     this.subcomponentNames = subcomponentNames;
     this.optionalFactories = optionalFactories;
-    this.requestFulfillmentRegistry =
-        new RequestFulfillmentRegistry(graph.resolvedBindings(), this);
+    this.bindingExpressions = bindingExpressions;
+    // TODO(dpb): Allow ComponentBuilder.create to return a no-op object
+    if (hasBuilder(graph)) {
+      builder = ComponentBuilder.create(name, graph, subcomponentNames, elements, types);
+      builderFields = builder.builderFields();
+    } else {
+      builderFields = ImmutableMap.of();
+    }
+    this.componentRequirementFields = componentRequirementFields;
+    this.bindingExpressionFactory =
+        new BindingExpression.Factory(
+            compilerOptions,
+            name,
+            componentFieldNames,
+            bindingExpressions,
+            componentRequirementFields,
+            this,
+            childComponentNames(keyFactory, subcomponentNames),
+            graph,
+            types,
+            elements,
+            optionalFactories);
+    this.componentRequirementFieldFactory =
+        new ComponentRequirementField.Factory(this, componentFieldNames, name, builderFields);
+  }
+
+  private static ImmutableMap<BindingKey, String> childComponentNames(
+      Key.Factory keyFactory, ImmutableMap<ComponentDescriptor, String> subcomponentNames) {
+    ImmutableMap.Builder<BindingKey, String> builder = ImmutableMap.builder();
+    subcomponentNames.forEach(
+        (component, name) -> {
+          if (component.builderSpec().isPresent()) {
+            TypeMirror builderType = component.builderSpec().get().builderDefinitionType().asType();
+            builder.put(
+                BindingKey.contribution(keyFactory.forSubcomponentBuilder(builderType)), name);
+          }
+        });
+    return builder.build();
   }
 
   protected AbstractComponentWriter(
@@ -217,89 +178,50 @@ protected AbstractComponentWriter(
         name,
         graph,
         parent.subcomponentNames,
-        parent.optionalFactories);
-  }
-
-  protected final ClassName componentDefinitionTypeName() {
-    return ClassName.get(graph.componentType());
+        parent.optionalFactories,
+        parent.bindingExpressions.forChildComponent(),
+        parent.componentRequirementFields.forChildComponent());
   }
 
   /**
-   * Returns an expression that evaluates to an instance of the requirement, looking for either a
-   * builder field or a component field.
+   * Creates a {@link FieldSpec.Builder} with a unique name based off of {@code name}.
    */
-  private CodeBlock getComponentContributionExpression(ComponentRequirement componentRequirement) {
-    if (builderFields.containsKey(componentRequirement)) {
-      return CodeBlock.of("builder.$N", builderFields.get(componentRequirement));
-    } else {
-      Optional<CodeBlock> codeBlock =
-          getOrCreateComponentRequirementFieldExpression(componentRequirement);
-      checkState(
-          codeBlock.isPresent(), "no builder or component field for %s", componentRequirement);
-      return codeBlock.get();
-    }
+  protected final FieldSpec.Builder componentField(TypeName type, String name) {
+    return FieldSpec.builder(type, componentFieldNames.getUniqueName(name));
   }
 
-  /**
-   * Returns an expression for a component requirement field. Adds a field the first time one is
-   * requested for a requirement if this component's builder has a field for it.
-   */
-  protected Optional<CodeBlock> getOrCreateComponentRequirementFieldExpression(
-      ComponentRequirement componentRequirement) {
-    MemberSelect fieldSelect = componentContributionFields.get(componentRequirement);
-    if (fieldSelect == null) {
-      if (!builderFields.containsKey(componentRequirement)) {
-        return Optional.empty();
-      }
-      FieldSpec componentField =
-          componentField(
-                  TypeName.get(componentRequirement.type()),
-                  simpleVariableName(componentRequirement.typeElement()))
-              .addModifiers(PRIVATE, FINAL)
-              .build();
-      component.addField(componentField);
-      constructor.addCode(
-          "this.$N = builder.$N;", componentField, builderFields.get(componentRequirement));
-      fieldSelect = localField(name, componentField.name);
-      componentContributionFields.put(componentRequirement, fieldSelect);
-    }
-    return Optional.of(fieldSelect.getExpressionFor(name));
+  @Override
+  public void addInitialization(CodeBlock codeBlock) {
+    initializations.add(codeBlock);
   }
 
-  /**
-   * Creates a {@link FieldSpec.Builder} with a unique name based off of {@code name}.
-   */
-  protected final FieldSpec.Builder componentField(TypeName type, String name) {
-    return FieldSpec.builder(type, componentFieldNames.getUniqueName(name));
+  @Override
+  public void addField(FieldSpec fieldSpec) {
+    component.addField(fieldSpec);
   }
 
-  private CodeBlock getMemberSelectExpression(BindingKey key) {
-    return getMemberSelect(key).getExpressionFor(name);
+  @Override
+  public void addMethod(MethodSpec methodSpec) {
+    component.addMethod(methodSpec);
   }
 
   @Override
-  public MemberSelect getMemberSelect(BindingKey key) {
-    return memberSelects.get(key);
+  public String getUniqueMethodName(String name) {
+    return componentMethodNames.getUniqueName(name);
   }
 
-  /**
-   * Returns the initialization state of the factory field for a binding key in this component.
-   */
-  protected InitializationState getInitializationState(BindingKey bindingKey) {
-    return initializationStates.containsKey(bindingKey)
-        ? initializationStates.get(bindingKey)
-        : UNINITIALIZED;
+  @Override
+  public void addType(TypeSpec typeSpec) {
+    component.addType(typeSpec);
   }
 
-  private void setInitializationState(BindingKey bindingKey, InitializationState state) {
-    initializationStates.put(bindingKey, state);
+  @Override
+  public String getSubcomponentName(ComponentDescriptor subcomponentDescriptor) {
+    return checkNotNull(subcomponentNames.get(subcomponentDescriptor));
   }
 
-  /**
-   * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
-   * object for a scope.
-   */
-  protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
+  @Override
+  public CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
     return referenceReleasingProviderManagerFields.get(scope).getExpressionFor(name);
   }
 
@@ -311,13 +233,22 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
   final TypeSpec.Builder write() {
     checkState(!done, "ComponentWriter has already been generated.");
     decorateComponent();
-    addBuilder();
+    if (hasBuilder(graph)) {
+      addBuilder();
+    }
+
+    getLocalAndInheritedMethods(
+            graph.componentDescriptor().componentDefinitionType(), types, elements)
+        .forEach(method -> componentMethodNames.claim(method.getSimpleName()));
+
     addFactoryMethods();
     addReferenceReleasingProviderManagerFields();
-    addFrameworkFields();
-    initializeFrameworkTypes();
+    createBindingExpressions();
+    createComponentRequirementFields();
     implementInterfaceMethods();
     addSubcomponents();
+    writeInitializeAndInterfaceMethods();
+    writeMembersInjectionMethods();
     component.addMethod(constructor.build());
     if (graph.componentDescriptor().kind().isTopLevel()) {
       optionalFactories.addMembers(component);
@@ -332,31 +263,18 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
    */
   protected abstract void decorateComponent();
 
+  private static boolean hasBuilder(BindingGraph graph) {
+    ComponentDescriptor component = graph.componentDescriptor();
+    return component.kind().isTopLevel() || component.builderSpec().isPresent();
+  }
+
   /**
    * Adds a builder type.
    */
-  protected void addBuilder() {
-    builderName = Optional.of(builderName());
-    TypeSpec.Builder componentBuilder =
-        createBuilder(builderName.get().simpleName()).addModifiers(FINAL);
-
-    Optional<BuilderSpec> builderSpec = graph.componentDescriptor().builderSpec();
-    if (builderSpec.isPresent()) {
-      componentBuilder.addModifiers(PRIVATE);
-      addSupertype(componentBuilder, builderSpec.get().builderDefinitionType());
-    } else {
-      componentBuilder
-          .addModifiers(PUBLIC)
-          .addMethod(constructorBuilder().addModifiers(PRIVATE).build());
-    }
+  private void addBuilder() {
+    addBuilderClass(builder.typeSpec());
 
-    builderFields = addBuilderFields(componentBuilder);
-    addBuildMethod(componentBuilder, builderSpec);
-    addBuilderMethods(componentBuilder, builderSpec);
-    addBuilderClass(componentBuilder.build());
-
-    constructor.addParameter(builderName.get(), "builder");
-    constructor.addStatement("assert builder != null");
+    constructor.addParameter(builderName(), "builder");
   }
 
   /**
@@ -365,233 +283,34 @@ protected void addBuilder() {
    */
   protected abstract void addBuilderClass(TypeSpec builder);
 
-  /**
-   * Adds fields for each of the {@linkplain BindingGraph#componentRequirements component
-   * requirements}. Regardless of builder spec, there is always one field per requirement.
-   */
-  private ImmutableMap<ComponentRequirement, FieldSpec> addBuilderFields(
-      TypeSpec.Builder componentBuilder) {
-    UniqueNameSet builderFieldNames = new UniqueNameSet();
-    ImmutableMap.Builder<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.builder();
-    for (ComponentRequirement componentRequirement : graph.componentRequirements()) {
-      String contributionName =
-          builderFieldNames.getUniqueName(componentRequirement.variableName());
-      FieldSpec builderField =
-          FieldSpec.builder(TypeName.get(componentRequirement.type()), contributionName, PRIVATE)
-              .build();
-      componentBuilder.addField(builderField);
-      builderFields.put(componentRequirement, builderField);
-    }
-    return builderFields.build();
-  }
-
-  /** Adds the build method to the builder. */
-  private void addBuildMethod(
-      TypeSpec.Builder componentBuilder, Optional<BuilderSpec> builderSpec) {
-    MethodSpec.Builder buildMethod;
-    if (builderSpec.isPresent()) {
-      ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
-      // Note: we don't use the specBuildMethod.getReturnType() as the return type
-      // because it might be a type variable.  We make use of covariant returns to allow
-      // us to return the component type, which will always be valid.
-      buildMethod =
-          methodBuilder(specBuildMethod.getSimpleName().toString()).addAnnotation(Override.class);
-    } else {
-      buildMethod = methodBuilder("build");
-    }
-    buildMethod.returns(componentDefinitionTypeName()).addModifiers(PUBLIC);
-
-    for (Map.Entry<ComponentRequirement, FieldSpec> builderFieldEntry : builderFields.entrySet()) {
-      FieldSpec builderField = builderFieldEntry.getValue();
-      switch (builderFieldEntry.getKey().nullPolicy(elements, types)) {
-        case NEW:
-          buildMethod.addCode(
-              "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
-          break;
-        case THROW:
-          buildMethod.addCode(
-              "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
-              builderField,
-              IllegalStateException.class,
-              TypeNames.rawTypeName(builderField.type),
-              " must be set");
-          break;
-        case ALLOW:
-          break;
-        default:
-          throw new AssertionError(builderFieldEntry.getKey());
-      }
-    }
-    buildMethod.addStatement("return new $T(this)", name);
-    componentBuilder.addMethod(buildMethod.build());
-  }
-
-  /**
-   * Adds the methods that set each of parameters on the builder. If the {@link BuilderSpec} is
-   * present, it will tailor the methods to match the spec.
-   */
-  private void addBuilderMethods(
-      TypeSpec.Builder componentBuilder, Optional<BuilderSpec> builderSpec) {
-    ImmutableSet<ComponentRequirement> componentRequirements = graph.componentRequirements();
-    if (builderSpec.isPresent()) {
-      UniqueNameSet parameterNames = new UniqueNameSet();
-      for (BuilderRequirementMethod requirementMethod : builderSpec.get().requirementMethods()) {
-        ComponentRequirement builderRequirement = requirementMethod.requirement();
-        ExecutableElement specMethod = requirementMethod.method();
-        MethodSpec.Builder builderMethod = addBuilderMethodFromSpec(specMethod);
-        VariableElement parameterElement = Iterables.getOnlyElement(specMethod.getParameters());
-        String parameterName = parameterNames.getUniqueName(parameterElement.getSimpleName());
-
-        TypeName argType =
-            parameterElement.asType().getKind().isPrimitive()
-                // Primitives need to use the original (unresolved) type to avoid boxing.
-                ? TypeName.get(parameterElement.asType())
-                // Otherwise we use the full resolved type.
-                : TypeName.get(builderRequirement.type());
-
-        builderMethod.addParameter(argType, parameterName);
-        if (componentRequirements.contains(builderRequirement)) {
-          // required type
-          builderMethod.addStatement(
-              "this.$N = $L",
-              builderFields.get(builderRequirement),
-              builderRequirement
-                      .nullPolicy(elements, types)
-                      .equals(ComponentRequirement.NullPolicy.ALLOW)
-                  ? parameterName
-                  : CodeBlock.of("$T.checkNotNull($L)", Preconditions.class, parameterName));
-          addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
-        } else if (graph.ownedModuleTypes().contains(builderRequirement.typeElement())) {
-          // owned, but not required
-          builderMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);
-          addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
-        } else {
-          // neither owned nor required, so it must be an inherited module
-          builderMethod.addStatement(
-              "throw new $T($T.format($S, $T.class.getCanonicalName()))",
-              UnsupportedOperationException.class,
-              String.class,
-              "%s cannot be set because it is inherited from the enclosing component",
-              TypeNames.rawTypeName(TypeName.get(builderRequirement.type())));
-        }
-        componentBuilder.addMethod(builderMethod.build());
-      }
-    } else {
-      for (ComponentRequirement componentRequirement : graph.availableDependencies()) {
-        String componentRequirementName = simpleVariableName(componentRequirement.typeElement());
-        MethodSpec.Builder builderMethod =
-            methodBuilder(componentRequirementName)
-                .returns(builderName.get())
-                .addModifiers(PUBLIC)
-                .addParameter(ClassName.get(componentRequirement.type()), componentRequirementName);
-        if (componentRequirements.contains(componentRequirement)) {
-          builderMethod.addStatement(
-              "this.$N = $T.checkNotNull($L)",
-              builderFields.get(componentRequirement),
-              Preconditions.class,
-              componentRequirementName);
-        } else {
-          builderMethod.addStatement("$T.checkNotNull($L)",
-              Preconditions.class,
-              componentRequirementName);
-          builderMethod.addJavadoc("@deprecated " + NOOP_BUILDER_METHOD_JAVADOC);
-          builderMethod.addAnnotation(Deprecated.class);
-        }
-        builderMethod.addStatement("return this");
-        componentBuilder.addMethod(builderMethod.build());
-      }
-    }
-  }
-
-  private void addBuilderMethodReturnStatementForSpec(
-      ExecutableElement specMethod, MethodSpec.Builder builderMethod) {
-    if (!specMethod.getReturnType().getKind().equals(VOID)) {
-      builderMethod.addStatement("return this");
-    }
-  }
-
-  private MethodSpec.Builder addBuilderMethodFromSpec(ExecutableElement method) {
-    TypeMirror returnType = method.getReturnType();
-    MethodSpec.Builder builderMethod =
-        methodBuilder(method.getSimpleName().toString())
-            .addAnnotation(Override.class)
-            .addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
-    // If the return type is void, we add a method with the void return type.
-    // Otherwise we use the generated builder name and take advantage of covariant returns
-    // (so that we don't have to worry about setter methods that return type variables).
-    if (!returnType.getKind().equals(TypeKind.VOID)) {
-      builderMethod.returns(builderName.get());
-    }
-    return builderMethod;
+  protected final ClassName builderName() {
+    return builder.name();
   }
 
-  /**
-   * Creates the builder class.
-   */
-  protected abstract TypeSpec.Builder createBuilder(String builderName);
-
-  protected abstract ClassName builderName();
-
   /**
    * Adds component factory methods.
    */
   protected abstract void addFactoryMethods();
 
   /**
-   * Adds a {@link dagger.internal.ReferenceReleasingProviderManager} field for every {@link
-   * CanReleaseReferences @ReleasableReferences} scope for which {@linkplain
-   * #requiresReleasableReferences(Scope) one is required}.
+   * Adds a {@link dagger.internal.ReferenceReleasingProviderManager} field for every scope for
+   * which {@linkplain BindingGraph#scopesRequiringReleasableReferenceManagers() one is required}.
    */
   private void addReferenceReleasingProviderManagerFields() {
     ImmutableMap.Builder<Scope, MemberSelect> fields = ImmutableMap.builder();
-    for (Scope scope : graph.componentDescriptor().releasableReferencesScopes()) {
-      if (requiresReleasableReferences(scope)) {
-        FieldSpec field = referenceReleasingProxyManagerField(scope);
-        component.addField(field);
-        fields.put(scope, localField(name, field.name));
-      }
+    for (Scope scope : graph.scopesRequiringReleasableReferenceManagers()) {
+      FieldSpec field = referenceReleasingProxyManagerField(scope);
+      component.addField(field);
+      fields.put(scope, localField(name, field.name));
     }
     referenceReleasingProviderManagerFields = fields.build();
   }
 
   /**
-   * Returns {@code true} if {@code scope} {@linkplain CanReleaseReferences can release its
-   * references} and there is a dependency request in the component for any of
-   *
-   * <ul>
-   * <li>{@code @ForReleasableReferences(scope)} {@link ReleasableReferenceManager}
-   * <li>{@code @ForReleasableReferences(scope)} {@code TypedReleasableReferenceManager<M>}, where
-   *     {@code M} is the releasable-references metatadata type for {@code scope}
-   * <li>{@code Set<ReleasableReferenceManager>}
-   * <li>{@code Set<TypedReleasableReferenceManager<M>>}, where {@code M} is the metadata type for
-   *     the scope
-   * </ul>
+   * Returns {@code true} if {@code scope} is in {@link
+   * BindingGraph#scopesRequiringReleasableReferenceManagers()} for the root graph.
    */
-  private boolean requiresReleasableReferences(Scope scope) {
-    if (!scope.canReleaseReferences()) {
-      return false;
-    }
-
-    if (graphHasContributionBinding(keyFactory.forReleasableReferenceManager(scope))
-        || graphHasContributionBinding(keyFactory.forSetOfReleasableReferenceManagers())) {
-      return true;
-    }
-
-    for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
-      if (graphHasContributionBinding(
-              keyFactory.forTypedReleasableReferenceManager(scope, metadata.getAnnotationType()))
-          || graphHasContributionBinding(
-              keyFactory.forSetOfTypedReleasableReferenceManagers(metadata.getAnnotationType()))) {
-        return true;
-      }
-    }
-
-    return false;
-  }
-
-  private boolean graphHasContributionBinding(Key key) {
-    return graph.resolvedBindings().containsKey(contribution(key));
-  }
+  protected abstract boolean requiresReleasableReferences(Scope scope);
 
   private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
     return componentField(
@@ -609,18 +328,18 @@ private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
         .build();
   }
 
-  private void addFrameworkFields() {
-    graph.resolvedBindings().values().forEach(this::addField);
+  private void createBindingExpressions() {
+    graph.resolvedBindings().values().forEach(this::createBindingExpression);
   }
 
-  private void addField(ResolvedBindings resolvedBindings) {
-    BindingKey bindingKey = resolvedBindings.bindingKey();
-
+  private void createBindingExpression(ResolvedBindings resolvedBindings) {
     // If the binding can be satisfied with a static method call without dependencies or state,
     // no field is necessary.
-    Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
-    if (staticMemberSelect.isPresent()) {
-      memberSelects.put(bindingKey, staticMemberSelect.get());
+    // TODO(ronshapiro): can these be merged into bindingExpressionFactory.forResolvedBindings()?
+    Optional<BindingExpression> staticBindingExpression =
+        bindingExpressionFactory.forStaticMethod(resolvedBindings);
+    if (staticBindingExpression.isPresent()) {
+      bindingExpressions.addBindingExpression(staticBindingExpression.get());
       return;
     }
 
@@ -630,254 +349,65 @@ private void addField(ResolvedBindings resolvedBindings) {
     }
 
     // TODO(gak): get rid of the field for unscoped delegated bindings
-
-    FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.empty());
-    memberSelects.put(bindingKey, localField(name, frameworkField.name));
-  }
-
-  /**
-   * Adds a field representing the resolved bindings, optionally forcing it to use a particular
-   * framework class (instead of the class the resolved bindings would typically use).
-   */
-  private FieldSpec addFrameworkField(
-      ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
-    boolean useRawType = useRawType(resolvedBindings);
-
-    FrameworkField contributionBindingField =
-        FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);
-    FieldSpec.Builder contributionField =
-        componentField(
-            useRawType
-                ? contributionBindingField.type().rawType
-                : contributionBindingField.type(),
-            contributionBindingField.name());
-    contributionField.addModifiers(PRIVATE);
-    if (useRawType) {
-      contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
-    }
-
-    FieldSpec field = contributionField.build();
-    component.addField(field);
-    return field;
-  }
-
-  private boolean useRawType(ResolvedBindings resolvedBindings) {
-    return useRawType(resolvedBindings.bindingPackage());
-  }
-
-  private boolean useRawType(Binding binding) {
-    return useRawType(binding.bindingPackage());
-  }
-
-  private boolean useRawType(Optional<String> bindingPackage) {
-    return bindingPackage.isPresent() && !bindingPackage.get().equals(name.packageName());
-  }
-
-  /**
-   * If {@code resolvedBindings} is an unscoped provision binding with no factory arguments or a
-   * no-op members injection binding, then we don't need a field to hold its factory. In that case,
-   * this method returns the static member select that returns the factory or no-op members
-   * injector.
-   */
-  private static Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
-    BindingKey bindingKey = resolvedBindings.bindingKey();
-    switch (bindingKey.kind()) {
-      case CONTRIBUTION:
-        ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
-        if (contributionBinding.factoryCreationStrategy().equals(SINGLETON_INSTANCE)
-            && !contributionBinding.scope().isPresent()) {
-          switch (contributionBinding.bindingKind()) {
-            case SYNTHETIC_MULTIBOUND_MAP:
-              BindingType bindingType = contributionBinding.bindingType();
-              MapType mapType = MapType.from(contributionBinding.key());
-              return Optional.of(
-                  emptyFrameworkMapFactory(
-                      bindingType,
-                      mapType.keyType(),
-                      mapType.unwrappedValueType(bindingType.frameworkClass())));
-
-            case SYNTHETIC_MULTIBOUND_SET:
-              return Optional.of(
-                  emptySetFactoryStaticMemberSelect(
-                      contributionBinding.bindingType(), contributionBinding.key()));
-
-            case INJECTION:
-            case PROVISION:
-              if (bindingKey.key().type().getKind().equals(DECLARED)) {
-                ImmutableList<TypeVariableName> typeVariables =
-                    bindingTypeElementTypeVariableNames(contributionBinding);
-                if (!typeVariables.isEmpty()) {
-                  List<? extends TypeMirror> typeArguments =
-                      ((DeclaredType) bindingKey.key().type()).getTypeArguments();
-                  return Optional.of(MemberSelect.parameterizedFactoryCreateMethod(
-                      generatedClassNameForBinding(contributionBinding), typeArguments));
-                }
-              }
-              // fall through
-
-            default:
-              return Optional.of(
-                  staticMethod(
-                      generatedClassNameForBinding(contributionBinding), CodeBlock.of("create()")));
-          }
-        }
-        break;
-
-      case MEMBERS_INJECTION:
-        Optional<MembersInjectionBinding> membersInjectionBinding =
-            resolvedBindings.membersInjectionBinding();
-        if (membersInjectionBinding.isPresent()
-            && membersInjectionBinding.get().injectionSites().isEmpty()) {
-          return Optional.of(noOpMembersInjector(membersInjectionBinding.get().key().type()));
-        }
-        break;
-
-      default:
-        throw new AssertionError();
-    }
-    return Optional.empty();
-  }
-
-  /**
-   * A static member select for an empty set factory. Calls {@link SetFactory#empty()}, {@link
-   * SetProducer#empty()}, or {@link SetOfProducedProducer#empty()}, depending on the set
-   * bindings.
-   */
-  private static MemberSelect emptySetFactoryStaticMemberSelect(BindingType bindingType, Key key) {
-    return emptySetProvider(setFactoryClassName(bindingType, key), SetType.from(key));
-  }
-
-  /**
-   * The {@link Set} factory class name appropriate for set bindings.
-   *
-   * <ul>
-   * <li>{@link SetFactory} for provision bindings.
-   * <li>{@link SetProducer} for production bindings for {@code Set<T>}.
-   * <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
-   * </ul>
-   */
-  private static ClassName setFactoryClassName(BindingType bindingType, Key key) {
-    if (bindingType.equals(BindingType.PROVISION)) {
-      return SET_FACTORY;
-    } else {
-      SetType setType = SetType.from(key);
-      return setType.elementsAreTypeOf(Produced.class) ? SET_OF_PRODUCED_PRODUCER : SET_PRODUCER;
-    }
+    bindingExpressions.addBindingExpression(bindingExpressionFactory.forField(resolvedBindings));
   }
 
-  /**
-   * The {@link Map}-of-value factory class name appropriate for map bindings.
-   *
-   * <ul>
-   * <li>{@link MapFactory} for provision bindings.
-   * <li>{@link MapProducer} for production bindings.
-   * </ul>
-   */
-  private static ClassName mapFactoryClassName(ContributionBinding binding) {
-    switch (binding.bindingType()) {
-      case PRODUCTION:
-        return MapType.from(binding.key()).valuesAreTypeOf(Produced.class)
-            ? MAP_OF_PRODUCED_PRODUCER : MAP_PRODUCER;
-
-      case PROVISION:
-      case MEMBERS_INJECTION:
-        return MAP_FACTORY;
-
-      default:
-        throw new AssertionError(binding.toString());
-    }
-  }
-
-  /**
-   * The {@link Map}-of-framework factory class name appropriate for map bindings.
-   *
-   * <ul>
-   * <li>{@link MapProviderFactory} for provision bindings.
-   * <li>{@link MapOfProducerProducer} for production bindings.
-   * </ul>
-   */
-  private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
-    return bindingType.equals(BindingType.PRODUCTION)
-        ? MAP_OF_PRODUCER_PRODUCER : MAP_PROVIDER_FACTORY;
+  private void createComponentRequirementFields() {
+    builderFields
+        .keySet()
+        .stream()
+        .map(componentRequirementFieldFactory::forBuilderField)
+        .forEach(componentRequirementFields::add);
   }
 
   private void implementInterfaceMethods() {
-    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
+    Set<MethodSignature> interfaceMethodSignatures = Sets.newHashSet();
+    DeclaredType componentType = MoreTypes.asDeclared(graph.componentType().asType());
     for (ComponentMethodDescriptor componentMethod :
         graph.componentDescriptor().componentMethods()) {
       if (componentMethod.dependencyRequest().isPresent()) {
         DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
-        ExecutableElement methodElement =
-            MoreElements.asExecutable(componentMethod.methodElement());
+        ExecutableElement methodElement = componentMethod.methodElement();
         ExecutableType requestType =
-            MoreTypes.asExecutable(
-                types.asMemberOf(
-                    MoreTypes.asDeclared(graph.componentType().asType()), methodElement));
+            MoreTypes.asExecutable(types.asMemberOf(componentType, methodElement));
         MethodSignature signature =
             MethodSignature.fromExecutableType(
                 methodElement.getSimpleName().toString(), requestType);
-        if (!interfaceMethods.contains(signature)) {
-          interfaceMethods.add(signature);
+        if (interfaceMethodSignatures.add(signature)) {
           MethodSpec.Builder interfaceMethod =
-              methodSpecForComponentMethod(methodElement, requestType);
-          RequestFulfillment fulfillment =
-              requestFulfillmentRegistry.getRequestFulfillment(interfaceRequest.bindingKey());
-          CodeBlock codeBlock = fulfillment.getSnippetForDependencyRequest(interfaceRequest, name);
-          switch (interfaceRequest.kind()) {
-            case MEMBERS_INJECTOR:
-              List<? extends VariableElement> parameters = methodElement.getParameters();
-              if (!parameters.isEmpty()) {
-                Name parameterName =
-                    Iterables.getOnlyElement(methodElement.getParameters()).getSimpleName();
-                interfaceMethod.addStatement("$L.injectMembers($L)", codeBlock, parameterName);
-                if (!requestType.getReturnType().getKind().equals(VOID)) {
-                  interfaceMethod.addStatement("return $L", parameterName);
-                }
-                break;
+              MethodSpec.overriding(methodElement, componentType, types);
+          List<? extends VariableElement> parameters = methodElement.getParameters();
+          if (interfaceRequest.kind().equals(DependencyRequest.Kind.MEMBERS_INJECTOR)
+              && !parameters.isEmpty() /* i.e. it's not a request for a MembersInjector<T> */) {
+            ParameterSpec parameter = ParameterSpec.get(getOnlyElement(parameters));
+            MembersInjectionBinding binding =
+                graph
+                    .resolvedBindings()
+                    .get(interfaceRequest.bindingKey())
+                    .membersInjectionBinding()
+                    .get();
+            if (requestType.getReturnType().getKind().equals(VOID)) {
+              if (!binding.injectionSites().isEmpty()) {
+                interfaceMethod.addStatement(
+                    "$N($N)", getMembersInjectionMethod(binding.key()), parameter);
               }
-              // fall through
-            default:
-              interfaceMethod.addStatement("return $L", codeBlock);
-              break;
+            } else if (binding.injectionSites().isEmpty()) {
+              interfaceMethod.addStatement("return $N", parameter);
+            } else {
+              interfaceMethod.addStatement(
+                  "return $N($N)", getMembersInjectionMethod(binding.key()), parameter);
+            }
+          } else {
+            interfaceMethod.addStatement(
+                "return $L",
+                bindingExpressions.getDependencyExpression(interfaceRequest, name).codeBlock());
           }
-          component.addMethod(interfaceMethod.build());
+          interfaceMethods.add(interfaceMethod.build());
         }
       }
     }
   }
 
-  private MethodSpec.Builder methodSpecForComponentMethod(
-      ExecutableElement method, ExecutableType methodType) {
-    String methodName = method.getSimpleName().toString();
-    MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName);
-
-    methodBuilder.addAnnotation(Override.class);
-
-    Set<Modifier> modifiers = EnumSet.copyOf(method.getModifiers());
-    modifiers.remove(Modifier.ABSTRACT);
-    methodBuilder.addModifiers(modifiers);
-
-    methodBuilder.returns(TypeName.get(methodType.getReturnType()));
-
-    List<? extends VariableElement> parameters = method.getParameters();
-    List<? extends TypeMirror> resolvedParameterTypes = methodType.getParameterTypes();
-    verify(parameters.size() == resolvedParameterTypes.size());
-    for (int i = 0; i < parameters.size(); i++) {
-      VariableElement parameter = parameters.get(i);
-      TypeName type = TypeName.get(resolvedParameterTypes.get(i));
-      String name = parameter.getSimpleName().toString();
-      Set<Modifier> parameterModifiers = parameter.getModifiers();
-      ParameterSpec.Builder parameterBuilder =
-          ParameterSpec.builder(type, name)
-              .addModifiers(parameterModifiers.toArray(new Modifier[0]));
-      methodBuilder.addParameter(parameterBuilder.build());
-    }
-    for (TypeMirror thrownType : method.getThrownTypes()) {
-      methodBuilder.addException(TypeName.get(thrownType));
-    }
-    return methodBuilder;
-  }
-
   private void addSubcomponents() {
     for (BindingGraph subgraph : graph.subgraphs()) {
       ComponentMethodDescriptor componentMethodDescriptor =
@@ -893,13 +423,9 @@ private void addSubcomponents() {
 
   private static final int INITIALIZATIONS_PER_INITIALIZE_METHOD = 100;
 
-  private void initializeFrameworkTypes() {
-    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
-      initializeFrameworkType(bindingKey).ifPresent(codeBlocks::add);
-    }
+  private void writeInitializeAndInterfaceMethods() {
     List<List<CodeBlock>> partitions =
-        Lists.partition(codeBlocks.build(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
+        Lists.partition(initializations, INITIALIZATIONS_PER_INITIALIZE_METHOD);
 
     UniqueNameSet methodNames = new UniqueNameSet();
     for (List<CodeBlock> partition : partitions) {
@@ -913,377 +439,82 @@ private void initializeFrameworkTypes() {
                * separate fields and initilization as we do now. */
               .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
               .addCode(CodeBlocks.concat(partition));
-      if (builderName.isPresent()) {
-        initializeMethod.addParameter(builderName.get(), "builder", FINAL);
+      if (hasBuilder(graph)) {
+        initializeMethod.addParameter(builderName(), "builder", FINAL);
         constructor.addStatement("$L(builder)", methodName);
       } else {
         constructor.addStatement("$L()", methodName);
       }
       component.addMethod(initializeMethod.build());
     }
-  }
-
-  /**
-   * Returns a single code block representing the initialization of the framework type.
-   *
-   * <p>Note that this must be a single code block because initialization code blocks can be invoked
-   * from any place in any order.  By requiring a single code block (often of concatenated code
-   * blocks) we ensure that things like local variables always behave as expected by the
-   * initialization logic.
-   */
-  private Optional<CodeBlock> initializeFrameworkType(BindingKey bindingKey) {
-    // If the field is inherited or the member select is static, don't initialize.
-    MemberSelect memberSelect = getMemberSelect(bindingKey);
-    if (memberSelect.staticMember() || !memberSelect.owningClass().equals(name)) {
-      return Optional.empty();
-    }
 
-    switch (bindingKey.kind()) {
-      case CONTRIBUTION:
-        return initializeContributionBinding(bindingKey);
-
-      case MEMBERS_INJECTION:
-        return initializeMembersInjectionBinding(bindingKey);
-
-      default:
-        throw new AssertionError();
-    }
+    component.addMethods(interfaceMethods);
   }
 
-  private Optional<CodeBlock> initializeContributionBinding(BindingKey bindingKey) {
-    ContributionBinding binding = graph.resolvedBindings().get(bindingKey).contributionBinding();
-    /* We have some duplication in the branches below b/c initializeDeferredDependencies must be
-     * called before we get the code block that initializes the member. */
-    switch (binding.factoryCreationStrategy()) {
-      case DELEGATE:
-        CodeBlock delegatingCodeBlock =
-            CodeBlock.of(
-                "($T) $L",
-                binding.bindingType().frameworkClass(),
-                getMemberSelect(
-                        Iterables.getOnlyElement(binding.explicitDependencies()).bindingKey())
-                    .getExpressionFor(name));
-        return Optional.of(
-            CodeBlocks.concat(
-                ImmutableList.of(
-                    initializeDeferredDependencies(binding),
-                    initializeMember(
-                        bindingKey, decorateForScope(delegatingCodeBlock, binding.scope())))));
-      case SINGLETON_INSTANCE:
-        if (!binding.scope().isPresent()) {
-          return Optional.empty();
-        }
-        // fall through
-      case CLASS_CONSTRUCTOR:
-        return Optional.of(
-            CodeBlocks.concat(
-                ImmutableList.of(
-                    initializeDeferredDependencies(binding),
-                    initializeMember(
-                        bindingKey, initializeFactoryForContributionBinding(binding)))));
-      default:
-        throw new AssertionError();
-    }
+  private void writeMembersInjectionMethods() {
+    component.addMethods(membersInjectionMethods.values());
   }
 
-  private Optional<CodeBlock> initializeMembersInjectionBinding(BindingKey bindingKey) {
-    MembersInjectionBinding binding =
-        graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();
-
-    if (binding.injectionSites().isEmpty()) {
-      return Optional.empty();
-    }
-
-    return Optional.of(
-        CodeBlocks.concat(
-            ImmutableList.of(
-                initializeDeferredDependencies(binding),
-                initializeMember(bindingKey, initializeMembersInjectorForBinding(binding)))));
-  }
-
-  /**
-   * Initializes any dependencies of the given binding that need to be instantiated, i.e., as we get
-   * to them during normal initialization.
-   */
-  private CodeBlock initializeDeferredDependencies(Binding binding) {
-    return CodeBlocks.concat(
-        ImmutableList.of(
-            initializeDelegateFactoriesForUninitializedDependencies(binding),
-            initializeProducersFromProviderDependencies(binding)));
-  }
-
-  /**
-   * Initializes delegate factories for any dependencies of {@code binding} that are uninitialized
-   * because of a dependency cycle.
-   */
-  private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {
-    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
-
-    for (BindingKey dependencyKey :
-        FluentIterable.from(binding.dependencies())
-            .transform(DependencyRequest::bindingKey)
-            .toSet()) {
-      if (!getMemberSelect(dependencyKey).staticMember()
-          && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
-        initializations.add(
-            CodeBlock.of(
-                "this.$L = new $T();", getMemberSelectExpression(dependencyKey), DELEGATE_FACTORY));
-        setInitializationState(dependencyKey, DELEGATED);
-      }
-    }
-
-    return CodeBlocks.concat(initializations.build());
-  }
-
-  private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {
-    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
-    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
-      ResolvedBindings resolvedBindings =
-          graph.resolvedBindings().get(frameworkDependency.bindingKey());
-      if (resolvedBindings.frameworkClass().equals(Provider.class)
-          && frameworkDependency.frameworkClass().equals(Producer.class)) {
-        MemberSelect memberSelect =
-            producerFromProviderMemberSelects.get(frameworkDependency.bindingKey());
-        if (memberSelect != null) {
-          continue;
-        }
-        FieldSpec frameworkField =
-            addFrameworkField(resolvedBindings, Optional.of(PRODUCER));
-        memberSelect = localField(name, frameworkField.name);
-        producerFromProviderMemberSelects.put(frameworkDependency.bindingKey(), memberSelect);
-        initializations.add(
-            CodeBlock.of(
-                "this.$L = $L;",
-                memberSelect.getExpressionFor(name),
-                requestFulfillmentRegistry
-                    .getRequestFulfillment(frameworkDependency.bindingKey())
-                    .getSnippetForFrameworkDependency(frameworkDependency, name)));
-      }
-    }
-    return CodeBlocks.concat(initializations.build());
-  }
-
-  private CodeBlock initializeMember(BindingKey bindingKey, CodeBlock initializationCodeBlock) {
-    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
-
-    CodeBlock memberSelect = getMemberSelectExpression(bindingKey);
-    CodeBlock delegateFactoryVariable = delegateFactoryVariableExpression(bindingKey);
-    if (getInitializationState(bindingKey).equals(DELEGATED)) {
-      initializations.add(
-          CodeBlock.of(
-              "$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, memberSelect));
-    }
-    initializations.add(
-        CodeBlock.of("this.$L = $L;", memberSelect, initializationCodeBlock));
-    if (getInitializationState(bindingKey).equals(DELEGATED)) {
-      initializations.add(
-          CodeBlock.of("$L.setDelegatedProvider($L);", delegateFactoryVariable, memberSelect));
-    }
-    setInitializationState(bindingKey, INITIALIZED);
-
-    return CodeBlocks.concat(initializations.build());
-  }
-
-  private CodeBlock delegateFactoryVariableExpression(BindingKey key) {
-    return CodeBlock.of("$LDelegate", getMemberSelectExpression(key).toString().replace('.', '_'));
-  }
-
-  private CodeBlock initializeFactoryForContributionBinding(ContributionBinding binding) {
-    TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
-    switch (binding.bindingKind()) {
-      case COMPONENT:
-        return CodeBlock.of(
-            "$T.<$T>create($L)",
-            INSTANCE_FACTORY,
-            bindingKeyTypeName,
-            bindingKeyTypeName.equals(componentDefinitionTypeName())
-                ? "this"
-                : getComponentContributionExpression(
-                    ComponentRequirement.forDependency(binding.key().type())));
-
-      case COMPONENT_PROVISION:
-        {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
-          String dependencyVariable = simpleVariableName(dependencyType);
-          String componentMethod = binding.bindingElement().get().getSimpleName().toString();
-          CodeBlock callFactoryMethod =
-              CodeBlock.of("$L.$L()", dependencyVariable, componentMethod);
-          // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
-          // help to figure out what the method or return type is.  If we include a string
-          // of the return type or method name in the error message, that can defeat obfuscation.
-          // We can easily include the raw type (no generics) + annotation type (no values),
-          // using .class & String.format -- but that wouldn't be the whole story.
-          // What should we do?
-          CodeBlock getMethodBody =
-              binding.nullableType().isPresent()
-                      || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
-                  ? CodeBlock.of("return $L;", callFactoryMethod)
-                  : CodeBlock.of(
-                      "return $T.checkNotNull($L, $S);",
-                      Preconditions.class,
-                      callFactoryMethod,
-                      CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-          ClassName dependencyClassName = ClassName.get(dependencyType);
-          String factoryName =
-              dependencyClassName.toString().replace('.', '_') + "_" + componentMethod;
-          MethodSpec.Builder getMethod =
-              methodBuilder("get")
-                  .addAnnotation(Override.class)
-                  .addModifiers(PUBLIC)
-                  .returns(bindingKeyTypeName)
-                  .addCode(getMethodBody);
-          if (binding.nullableType().isPresent()) {
-            getMethod.addAnnotation(
-                ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
-          }
-          component.addType(
-              TypeSpec.classBuilder(factoryName)
-                  .addSuperinterface(providerOf(bindingKeyTypeName))
-                  .addModifiers(PRIVATE, STATIC)
-                  .addField(dependencyClassName, dependencyVariable, PRIVATE, FINAL)
-                  .addMethod(
-                      constructorBuilder()
-                          .addParameter(dependencyClassName, dependencyVariable)
-                          .addStatement("this.$1L = $1L", dependencyVariable)
-                          .build())
-                  .addMethod(getMethod.build())
-                  .build());
-          return CodeBlock.of(
-              "new $L($L)",
-              factoryName,
-              getComponentContributionExpression(
-                  ComponentRequirement.forDependency(dependencyType.asType())));
-        }
-
-      case SUBCOMPONENT_BUILDER:
-        String subcomponentName =
-            subcomponentNames.get(
-                graph.componentDescriptor()
-                    .subcomponentsByBuilderType()
-                    .get(MoreTypes.asTypeElement(binding.key().type())));
-        return CodeBlock.of(
-            Joiner.on('\n')
-                .join(
-                    "new $1L<$2T>() {",
-                    "  @Override public $2T get() {",
-                    "    return new $3LBuilder();",
-                    "  }",
-                    "}"),
-            // TODO(ronshapiro): Until we remove Factory, fully qualify the import so it doesn't
-            // conflict with dagger.android.ActivityInjector.Factory
-            /* 1 */ "dagger.internal.Factory",
-            /* 2 */ bindingKeyTypeName,
-            /* 3 */ subcomponentName);
-
-      case BUILDER_BINDING:
-        return CodeBlock.of(
-            "$T.$L($L)",
-            InstanceFactory.class,
-            binding.nullableType().isPresent() ? "createNullable" : "create",
-            getComponentContributionExpression(ComponentRequirement.forBinding(binding)));
-
-      case INJECTION:
-      case PROVISION:
-        {
-          List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
-          if (binding.requiresModuleInstance()) {
-            arguments.add(
-                getComponentContributionExpression(
-                    ComponentRequirement.forModule(binding.contributingModule().get().asType())));
-          }
-          arguments.addAll(getDependencyArguments(binding));
-
-          CodeBlock factoryCreate =
-              CodeBlock.of(
-                  "$T.create($L)",
-                  generatedClassNameForBinding(binding),
-                  makeParametersCodeBlock(arguments));
-
-          // If scoping a parameterized factory for an @Inject class, Java 7 cannot always infer the
-          // type properly, so cast to a raw framework type before scoping.
-          if (binding.bindingKind().equals(INJECTION)
-              && binding.unresolved().isPresent()
-              && binding.scope().isPresent()) {
-            factoryCreate =
-                CodeBlock.of("($T) $L", binding.bindingType().frameworkClass(), factoryCreate);
-          }
-          return decorateForScope(factoryCreate, binding.scope());
-        }
-
-      case COMPONENT_PRODUCTION:
-        {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
-          return CodeBlock.of(
-              Joiner.on('\n')
-                  .join(
-                      "new $1T<$2T>() {",
-                      "  private final $6T $7L = $4L;",
-                      "  @Override public $3T<$2T> get() {",
-                      "    return $7L.$5L();",
-                      "  }",
-                      "}"),
-              /* 1 */ PRODUCER,
-              /* 2 */ TypeName.get(binding.key().type()),
-              /* 3 */ LISTENABLE_FUTURE,
-              /* 4 */ getComponentContributionExpression(
-                  ComponentRequirement.forDependency(dependencyType.asType())),
-              /* 5 */ binding.bindingElement().get().getSimpleName(),
-              /* 6 */ TypeName.get(dependencyType.asType()),
-              /* 7 */ simpleVariableName(dependencyType));
-        }
-
-      case PRODUCTION:
-        {
-          List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
-          if (binding.requiresModuleInstance()) {
-            arguments.add(
-                getComponentContributionExpression(
-                    ComponentRequirement.forModule(binding.contributingModule().get().asType())));
-          }
-          arguments.addAll(getDependencyArguments(binding));
-
-          return CodeBlock.of(
-              "new $T($L)",
-              generatedClassNameForBinding(binding),
-              makeParametersCodeBlock(arguments));
-        }
-
-      case SYNTHETIC_MAP:
-        FrameworkDependency frameworkDependency = getOnlyElement(binding.frameworkDependencies());
-        return CodeBlock.of(
-            "$T.create($L)",
-            mapFactoryClassName(binding),
-            requestFulfillmentRegistry
-                .getRequestFulfillment(frameworkDependency.bindingKey())
-                .getSnippetForFrameworkDependency(frameworkDependency, name));
-
-      case SYNTHETIC_MULTIBOUND_SET:
-        return initializeFactoryForSetMultibinding(binding);
-
-      case SYNTHETIC_MULTIBOUND_MAP:
-        return initializeFactoryForMapMultibinding(binding);
-
-      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
-        return initializeFactoryForSyntheticReleasableReferenceManagerBinding(binding);
-
-      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
-        return initializeFactoryForSyntheticSetOfReleasableReferenceManagers(binding);
-
-      case SYNTHETIC_OPTIONAL_BINDING:
-        return initializeFactoryForSyntheticOptionalBinding(binding);
-
-      default:
-        throw new AssertionError(binding);
-    }
-  }
-
-  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
-    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
-  }
-
-  private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope) {
+  @Override
+  public MethodSpec getMembersInjectionMethod(Key key) {
+    return reentrantComputeIfAbsent(
+        membersInjectionMethods, key, this::membersInjectionMethod);
+  }
+
+  private MethodSpec membersInjectionMethod(Key key) {
+    Binding binding =
+        MoreObjects.firstNonNull(
+                graph.resolvedBindings().get(BindingKey.membersInjection(key)),
+                graph.resolvedBindings().get(BindingKey.contribution(key)))
+            .binding();
+    TypeMirror keyType = binding.key().type();
+    TypeMirror membersInjectedType =
+        isTypeAccessibleFrom(keyType, name.packageName())
+            ? keyType
+            : elements.getTypeElement("java.lang.Object").asType();
+    TypeName membersInjectedTypeName = TypeName.get(membersInjectedType);
+    Name bindingTypeName = binding.bindingTypeElement().get().getSimpleName();
+    // TODO(ronshapiro): include type parameters in this name e.g. injectFooOfT, and outer class
+    // simple names Foo.Builder -> injectFooBuilder
+    String methodName = componentMethodNames.getUniqueName("inject" + bindingTypeName);
+    ParameterSpec parameter = ParameterSpec.builder(membersInjectedTypeName, "instance").build();
+    MethodSpec.Builder method =
+        methodBuilder(methodName)
+            .addModifiers(PRIVATE)
+            .returns(membersInjectedTypeName)
+            .addParameter(parameter);
+    TypeElement canIgnoreReturnValue =
+        elements.getTypeElement("com.google.errorprone.annotations.CanIgnoreReturnValue");
+    if (canIgnoreReturnValue != null) {
+      method.addAnnotation(ClassName.get(canIgnoreReturnValue));
+    }
+    CodeBlock instance = CodeBlock.of("$N", parameter);
+    method.addCode(
+        InjectionSiteMethod.invokeAll(
+            injectionSites(binding),
+            name,
+            instance,
+            membersInjectedType,
+            types,
+            request ->
+                bindingExpressions.getDependencyArgumentExpression(request, name).codeBlock()));
+    method.addStatement("return $L", instance);
+
+    return method.build();
+  }
+
+  static ImmutableSet<InjectionSite> injectionSites(Binding binding) {
+    if (binding instanceof ProvisionBinding) {
+      return ((ProvisionBinding) binding).injectionSites();
+    } else if (binding instanceof MembersInjectionBinding) {
+      return ((MembersInjectionBinding) binding).injectionSites();
+    }
+    throw new IllegalArgumentException(binding.key().toString());
+  }
+
+  // TODO(user): Pull this out into a separate Scoper object or move to field initializer?
+  @Override
+  public CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope) {
     if (!maybeScope.isPresent()) {
       return factoryCreate;
     }
@@ -1301,271 +532,4 @@ private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> mayb
           factoryCreate);
     }
   }
-
-  private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
-    return binding.injectionSites().isEmpty()
-        ? CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS)
-        : CodeBlock.of(
-            "$T.create($L)",
-            membersInjectorNameForType(binding.membersInjectedType()),
-            makeParametersCodeBlock(getDependencyArguments(binding)));
-  }
-
-  /**
-   * The expressions that represent factory arguments for the dependencies of a binding.
-   */
-  private ImmutableList<CodeBlock> getDependencyArguments(Binding binding) {
-    ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
-    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
-      parameters.add(getDependencyArgument(frameworkDependency));
-    }
-    return parameters.build();
-  }
-
-  /** Returns the expression to use as an argument for a dependency. */
-  private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency) {
-    BindingKey requestedKey = frameworkDependency.bindingKey();
-    ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
-    if (resolvedBindings.frameworkClass().equals(Provider.class)
-        && frameworkDependency.frameworkClass().equals(Producer.class)) {
-      return producerFromProviderMemberSelects.get(requestedKey).getExpressionFor(name);
-    } else {
-      RequestFulfillment requestFulfillment =
-          requestFulfillmentRegistry.getRequestFulfillment(requestedKey);
-      return requestFulfillment.getSnippetForFrameworkDependency(frameworkDependency, name);
-    }
-  }
-
-  private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding binding) {
-    CodeBlock.Builder builder =
-        CodeBlock.builder().add("$T.", setFactoryClassName(binding.bindingType(), binding.key()));
-    boolean useRawTypes = useRawType(binding);
-    if (!useRawTypes) {
-      SetType setType = SetType.from(binding.key());
-      builder.add(
-          "<$T>",
-          setType.elementsAreTypeOf(Produced.class)
-              ? setType.unwrappedElementType(Produced.class)
-              : setType.elementType());
-    }
-    int individualProviders = 0;
-    int setProviders = 0;
-    CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
-    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
-      ContributionType contributionType =
-          graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
-      String methodName;
-      String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
-      switch (contributionType) {
-        case SET:
-          individualProviders++;
-          methodName = "add" + methodNameSuffix;
-          break;
-        case SET_VALUES:
-          setProviders++;
-          methodName = "addCollection" + methodNameSuffix;
-          break;
-        default:
-          throw new AssertionError(frameworkDependency + " is not a set multibinding");
-      }
-
-      builderMethodCalls.add(
-          ".$L($L)",
-          methodName,
-          potentiallyCast(
-              useRawTypes,
-              frameworkDependency.frameworkClass(),
-              getDependencyArgument(frameworkDependency)));
-    }
-    builder.add("builder($L, $L)", individualProviders, setProviders);
-    builder.add(builderMethodCalls.build());
-    return builder.add(".build()").build();
-  }
-
-  private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding binding) {
-    ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
-
-    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    MapType mapType = MapType.from(binding.key().type());
-    CodeBlock.Builder builderCall =
-        CodeBlock.builder().add("$T.", frameworkMapFactoryClassName(binding.bindingType()));
-    boolean useRawTypes = useRawType(binding);
-    if (!useRawTypes) {
-      builderCall.add("<$T, $T>", TypeName.get(mapType.keyType()),
-          TypeName.get(mapType.unwrappedValueType(binding.bindingType().frameworkClass())));
-    }
-    builderCall.add("builder($L)", frameworkDependencies.size());
-    codeBlocks.add(builderCall.build());
-
-    for (FrameworkDependency frameworkDependency : frameworkDependencies) {
-      BindingKey bindingKey = frameworkDependency.bindingKey();
-      ContributionBinding contributionBinding =
-          graph.resolvedBindings().get(bindingKey).contributionBinding();
-      CodeBlock value =
-          potentiallyCast(
-              useRawTypes,
-              frameworkDependency.frameworkClass(),
-              getDependencyArgument(frameworkDependency));
-      codeBlocks.add(
-          CodeBlock.of(
-              ".put($L, $L)", getMapKeyExpression(contributionBinding.mapKey().get()), value));
-    }
-    codeBlocks.add(CodeBlock.of(".build()"));
-
-    return CodeBlocks.concat(codeBlocks.build());
-  }
-
-  private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, CodeBlock notCasted) {
-    if (!shouldCast) {
-      return notCasted;
-    }
-    return CodeBlock.of("($T) $L", classToCast, notCasted);
-  }
-
-  /**
-   * Initializes the factory for a {@link
-   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} binding.
-   *
-   * <p>The {@code get()} method just returns the component field with the {@link
-   * dagger.internal.ReferenceReleasingProviderManager} object.
-   */
-  private CodeBlock initializeFactoryForSyntheticReleasableReferenceManagerBinding(
-      ContributionBinding binding) {
-    // The scope is the value of the @ForReleasableReferences annotation.
-    Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
-
-    CodeBlock managerExpression;
-    if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
-      /* The key's type is TypedReleasableReferenceManager<M>, so return
-       * new TypedReleasableReferenceManager(field, metadata). */
-      TypeMirror metadataType =
-          MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
-      managerExpression =
-          typedReleasableReferenceManagerDecoratorExpression(
-              getReferenceReleasingProviderManagerExpression(scope),
-              scope.releasableReferencesMetadata(metadataType).get());
-    } else {
-      // The key's type is ReleasableReferenceManager, so return the field as is.
-      managerExpression = getReferenceReleasingProviderManagerExpression(scope);
-    }
-
-    TypeName keyType = TypeName.get(binding.key().type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyType))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyType)
-                    .addCode("return $L;", managerExpression)
-                    .build())
-            .build());
-  }
-
-  /**
-   * Initializes the factory for a {@link
-   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} binding.
-   *
-   * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
-   * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
-   * include managers for all reference-releasing scopes whose metadata type is {@code M}.
-   */
-  private CodeBlock initializeFactoryForSyntheticSetOfReleasableReferenceManagers(
-      ContributionBinding binding) {
-    Key key = binding.key();
-    SetType keyType = SetType.from(key);
-    ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
-    for (Map.Entry<Scope, MemberSelect> entry :
-        referenceReleasingProviderManagerFields.entrySet()) {
-      Scope scope = entry.getKey();
-      CodeBlock releasableReferenceManagerExpression = entry.getValue().getExpressionFor(name);
-
-      if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
-        managerExpressions.add(releasableReferenceManagerExpression);
-      } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
-        TypeMirror metadataType =
-            keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
-        Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
-        if (metadata.isPresent()) {
-          managerExpressions.add(
-              typedReleasableReferenceManagerDecoratorExpression(
-                  releasableReferenceManagerExpression, metadata.get()));
-        }
-      } else {
-        throw new IllegalArgumentException("inappropriate key: " + binding);
-      }
-    }
-    TypeName keyTypeName = TypeName.get(key.type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyTypeName))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyTypeName)
-                    .addCode(
-                        "return new $T($T.asList($L));",
-                        HashSet.class,
-                        Arrays.class,
-                        makeParametersCodeBlock(managerExpressions.build()))
-                    .build())
-            .build());
-  }
-
-  /**
-   * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
-   * decorates the {@code managerExpression} to supply {@code metadata}.
-   */
-  private CodeBlock typedReleasableReferenceManagerDecoratorExpression(
-      CodeBlock managerExpression, AnnotationMirror metadata) {
-    return CodeBlock.of(
-        "new $T($L, $L)",
-        ParameterizedTypeName.get(
-            TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
-            TypeName.get(metadata.getAnnotationType())),
-        managerExpression,
-        new AnnotationExpression(metadata).getAnnotationInstanceExpression());
-  }
-
-  private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
-    checkArgument(
-        MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
-    return Scope.scope(
-        MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
-  }
-
-  /**
-   * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
-   * binding.
-   */
-  private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBinding binding) {
-    if (binding.explicitDependencies().isEmpty()) {
-      verify(
-          binding.bindingType().equals(BindingType.PROVISION),
-          "Absent optional bindings should be provisions: %s",
-          binding);
-      return optionalFactories.absentOptionalProvider(binding);
-    } else {
-      return optionalFactories.presentOptionalFactory(
-          binding, getOnlyElement(getDependencyArguments(binding)));
-    }
-  }
-
-  /**
-   * Initialization state for a factory field.
-   */
-  enum InitializationState {
-    /** The field is {@code null}. */
-    UNINITIALIZED,
-
-    /** The field is set to a {@link DelegateFactory}. */
-    DELEGATED,
-
-    /** The field is set to an undelegated factory. */
-    INITIALIZED;
-  }
 }
diff --git a/java/dagger/internal/codegen/AnnotationExpression.java b/java/dagger/internal/codegen/AnnotationExpression.java
index 6d3692636..61b472a2b 100644
--- a/java/dagger/internal/codegen/AnnotationExpression.java
+++ b/java/dagger/internal/codegen/AnnotationExpression.java
@@ -91,7 +91,7 @@ CodeBlock getValueExpression(TypeMirror valueType, AnnotationValue value) {
 
   @Override
   public CodeBlock visitEnumConstant(VariableElement c, AnnotationValue p) {
-    return CodeBlock.of("$T.$L", TypeName.get(c.getEnclosingElement().asType()), c.getSimpleName());
+    return CodeBlock.of("$T.$L", c.getEnclosingElement(), c.getSimpleName());
   }
 
   @Override
@@ -101,7 +101,7 @@ public CodeBlock visitAnnotation(AnnotationMirror a, AnnotationValue p) {
 
   @Override
   public CodeBlock visitType(TypeMirror t, AnnotationValue p) {
-    return CodeBlock.of("$T.class", TypeName.get(t));
+    return CodeBlock.of("$T.class", t);
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/AnyBindingMethodValidator.java b/java/dagger/internal/codegen/AnyBindingMethodValidator.java
index a8a483e11..7b338ea1f 100644
--- a/java/dagger/internal/codegen/AnyBindingMethodValidator.java
+++ b/java/dagger/internal/codegen/AnyBindingMethodValidator.java
@@ -21,6 +21,7 @@
 import static com.google.common.collect.Maps.uniqueIndex;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.ErrorMessages.tooManyBindingMethodAnnotations;
+import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.Arrays.asList;
 
@@ -69,7 +70,7 @@ boolean isBindingMethod(ExecutableElement method) {
    *     #methodAnnotations() binding method annotation}
    */
   ValidationReport<ExecutableElement> validate(ExecutableElement method) {
-    return reports.computeIfAbsent(method, this::validateUncached);
+    return reentrantComputeIfAbsent(reports, method, this::validateUncached);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index aad953156..53e392635 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -35,6 +35,7 @@ CODEGEN_SHARED_DEPS = [
     "//third_party:google_java_format",
     "//third_party:javapoet",
     "@local_jdk//:lib/tools.jar",
+    "//third_party:jsr250_annotations",
     "//third_party:jsr305_annotations",
     "//third_party:jsr330_inject",
     "//java/dagger:core",
diff --git a/java/dagger/internal/codegen/Binding.java b/java/dagger/internal/codegen/Binding.java
index bb1e073ec..182069250 100644
--- a/java/dagger/internal/codegen/Binding.java
+++ b/java/dagger/internal/codegen/Binding.java
@@ -76,20 +76,27 @@
    * user-defined injection site. This returns an unmodifiable set.
    */
   // TODO(gak): this will eventually get changed to return a set of FrameworkDependency
-  Set<DependencyRequest> implicitDependencies() {
+  ImmutableSet<DependencyRequest> implicitDependencies() {
     return ImmutableSet.of();
   }
 
+  private final Supplier<ImmutableSet<DependencyRequest>> dependencies =
+      memoize(
+          () -> {
+            ImmutableSet<DependencyRequest> implicitDependencies = implicitDependencies();
+            return ImmutableSet.copyOf(
+                implicitDependencies.isEmpty()
+                    ? explicitDependencies()
+                    : Sets.union(implicitDependencies, explicitDependencies()));
+          });
+
   /**
    * The set of {@link DependencyRequest dependencies} required to satisfy this binding. This is the
    * union of {@link #explicitDependencies()} and {@link #implicitDependencies()}. This returns an
    * unmodifiable set.
    */
-  final Set<DependencyRequest> dependencies() {
-    Set<DependencyRequest> implicitDependencies = implicitDependencies();
-    return implicitDependencies.isEmpty()
-        ? explicitDependencies()
-        : Sets.union(implicitDependencies, explicitDependencies());
+  final ImmutableSet<DependencyRequest> dependencies() {
+    return dependencies.get();
   }
 
   private final Supplier<ImmutableList<FrameworkDependency>> frameworkDependencies =
diff --git a/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index 0652b4d3c..334298dad 100644
--- a/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -48,12 +48,9 @@
               SYNTHETIC_RELEASABLE_REFERENCE_MANAGER, SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS);
 
   private final MethodSignatureFormatter methodSignatureFormatter;
-  private final KeyFormatter keyFormatter;
 
-  BindingDeclarationFormatter(
-      MethodSignatureFormatter methodSignatureFormatter, KeyFormatter keyFormatter) {
+  BindingDeclarationFormatter(MethodSignatureFormatter methodSignatureFormatter) {
     this.methodSignatureFormatter = methodSignatureFormatter;
-    this.keyFormatter = keyFormatter;
   }
 
   /**
@@ -93,11 +90,11 @@ public String format(BindingDeclaration bindingDeclaration) {
         case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
           return String.format(
               "binding for %s from the scope declaration",
-              stripCommonTypePrefixes(keyFormatter.format(binding.key())));
+              stripCommonTypePrefixes(binding.key().toString()));
         case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
           return String.format(
               "Dagger-generated binding for %s",
-              stripCommonTypePrefixes(keyFormatter.format(binding.key())));
+              stripCommonTypePrefixes(binding.key().toString()));
         default:
           break;
       }
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
new file mode 100644
index 000000000..58506f405
--- /dev/null
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -0,0 +1,262 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.google.common.collect.ImmutableMap;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.FieldSpec;
+import java.util.Optional;
+import javax.lang.model.util.Elements;
+
+/** A factory of code expressions used to access a single binding in a component. */
+abstract class BindingExpression {
+  private final ResolvedBindings resolvedBindings;
+
+  BindingExpression(ResolvedBindings resolvedBindings) {
+    this.resolvedBindings = checkNotNull(resolvedBindings);
+  }
+
+  /** The binding this instance uses to fulfill requests. */
+  final ResolvedBindings resolvedBindings() {
+    return resolvedBindings;
+  }
+
+  /**
+   * Returns an expression that evaluates to the value of a request for a given kind of dependency
+   * on this binding.
+   *
+   * @param requestingClass the class that will contain the expression
+   */
+  abstract Expression getDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass);
+
+  /** Factory for building a {@link BindingExpression}. */
+  static final class Factory {
+    private final CompilerOptions compilerOptions;
+    private final ClassName componentName;
+    private final UniqueNameSet componentFieldNames;
+    private final ComponentBindingExpressions componentBindingExpressions;
+    private final ComponentRequirementFields componentRequirementFields;
+    private final GeneratedComponentModel generatedComponentModel;
+    private final ImmutableMap<BindingKey, String> subcomponentNames;
+    private final BindingGraph graph;
+    private final DaggerTypes types;
+    private final Elements elements;
+    private final OptionalFactories optionalFactories;
+
+    Factory(
+        CompilerOptions compilerOptions,
+        ClassName componentName,
+        UniqueNameSet componentFieldNames,
+        ComponentBindingExpressions componentBindingExpressions,
+        ComponentRequirementFields componentRequirementFields,
+        GeneratedComponentModel generatedComponentModel,
+        ImmutableMap<BindingKey, String> subcomponentNames,
+        BindingGraph graph,
+        DaggerTypes types,
+        Elements elements,
+        OptionalFactories optionalFactories) {
+      this.compilerOptions = checkNotNull(compilerOptions);
+      this.componentName = checkNotNull(componentName);
+      this.componentFieldNames = checkNotNull(componentFieldNames);
+      this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+      this.componentRequirementFields = checkNotNull(componentRequirementFields);
+      this.generatedComponentModel = checkNotNull(generatedComponentModel);
+      this.subcomponentNames = checkNotNull(subcomponentNames);
+      this.graph = checkNotNull(graph);
+      this.types = checkNotNull(types);
+      this.elements = checkNotNull(elements);
+      this.optionalFactories = checkNotNull(optionalFactories);
+    }
+
+    /** Creates a binding expression for a field. */
+    BindingExpression forField(ResolvedBindings resolvedBindings) {
+      FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.empty());
+      MemberSelect memberSelect = MemberSelect.localField(componentName, fieldSpec.name);
+      return create(resolvedBindings, Optional.of(fieldSpec), memberSelect);
+    }
+
+    /** Creates a binding expression for a static method call. */
+    Optional<BindingExpression> forStaticMethod(ResolvedBindings resolvedBindings) {
+      return staticMemberSelect(resolvedBindings)
+          .map(memberSelect -> create(resolvedBindings, Optional.empty(), memberSelect));
+    }
+
+    /**
+     * Adds a field representing the resolved bindings, optionally forcing it to use a particular
+     * binding type (instead of the type the resolved bindings would typically use).
+     */
+    private FieldSpec generateFrameworkField(
+        ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
+      boolean useRawType = useRawType(resolvedBindings);
+
+      FrameworkField contributionBindingField =
+          FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);
+      FieldSpec.Builder contributionField =
+          FieldSpec.builder(
+              useRawType
+                  ? contributionBindingField.type().rawType
+                  : contributionBindingField.type(),
+              componentFieldNames.getUniqueName(contributionBindingField.name()));
+      contributionField.addModifiers(PRIVATE);
+      if (useRawType) {
+        contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
+      }
+
+      return contributionField.build();
+    }
+
+    private boolean useRawType(ResolvedBindings resolvedBindings) {
+      Optional<String> bindingPackage = resolvedBindings.bindingPackage();
+      return bindingPackage.isPresent()
+          && !bindingPackage.get().equals(componentName.packageName());
+    }
+
+    private BindingExpression create(
+        ResolvedBindings resolvedBindings,
+        Optional<FieldSpec> fieldSpec,
+        MemberSelect memberSelect) {
+      FrameworkFieldInitializer frameworkFieldInitializer =
+          new FrameworkFieldInitializer(
+              generatedComponentModel,
+              componentBindingExpressions,
+              componentRequirementFields,
+              resolvedBindings,
+              compilerOptions,
+              graph,
+              optionalFactories,
+              componentName);
+      FrameworkInstanceBindingExpression frameworkInstanceBindingExpression =
+          FrameworkInstanceBindingExpression.create(
+              resolvedBindings,
+              fieldSpec,
+              generatedComponentModel,
+              memberSelect,
+              frameworkFieldInitializer,
+              types,
+              elements);
+
+      if (!resolvedBindings.bindingType().equals(BindingType.PROVISION)) {
+        return frameworkInstanceBindingExpression;
+      }
+
+      BindingExpression bindingExpression =
+          new ProviderOrProducerBindingExpression(
+              frameworkInstanceBindingExpression,
+              frameworkInstanceBindingExpression.producerFromProvider(
+                  generateFrameworkField(resolvedBindings, Optional.of(TypeNames.PRODUCER)),
+                  componentName));
+
+      ProvisionBinding provisionBinding = (ProvisionBinding) resolvedBindings.contributionBinding();
+      switch (provisionBinding.bindingKind()) {
+        case COMPONENT:
+          return new ComponentInstanceBindingExpression(
+              bindingExpression, provisionBinding, componentName, types);
+
+        case COMPONENT_DEPENDENCY:
+          return new BoundInstanceBindingExpression(
+              bindingExpression,
+              ComponentRequirement.forDependency(provisionBinding.key().type()),
+              componentRequirementFields,
+              types);
+
+        case COMPONENT_PROVISION:
+          return new ComponentProvisionBindingExpression(
+              bindingExpression,
+              provisionBinding,
+              graph,
+              componentRequirementFields,
+              compilerOptions,
+              types);
+
+        case SUBCOMPONENT_BUILDER:
+          return new SubcomponentBuilderBindingExpression(
+              bindingExpression,
+              provisionBinding,
+              subcomponentNames.get(resolvedBindings.bindingKey()),
+              types);
+
+        case SYNTHETIC_MULTIBOUND_SET:
+          return new SetBindingExpression(
+              provisionBinding,
+              graph,
+              componentBindingExpressions,
+              bindingExpression,
+              types,
+              elements);
+
+        case SYNTHETIC_MULTIBOUND_MAP:
+          return new MapBindingExpression(
+              provisionBinding,
+              graph,
+              componentBindingExpressions,
+              bindingExpression,
+              types,
+              elements);
+
+        case SYNTHETIC_OPTIONAL_BINDING:
+          return new OptionalBindingExpression(
+              provisionBinding, bindingExpression, componentBindingExpressions, types);
+
+        case SYNTHETIC_DELEGATE_BINDING:
+          return DelegateBindingExpression.create(
+              graph, bindingExpression, componentBindingExpressions, types, elements);
+
+        case BUILDER_BINDING:
+          return new BoundInstanceBindingExpression(
+              bindingExpression,
+              ComponentRequirement.forBinding(provisionBinding),
+              componentRequirementFields,
+              types);
+
+        case INJECTION:
+        case PROVISION:
+          if (!provisionBinding.scope().isPresent()
+              && provisionBinding.bindingElement().isPresent()) {
+            BindingExpression simpleMethodBindingExpression =
+                new SimpleMethodBindingExpression(
+                    compilerOptions,
+                    provisionBinding,
+                    bindingExpression,
+                    componentBindingExpressions,
+                    generatedComponentModel,
+                    componentRequirementFields,
+                    types,
+                    elements);
+            return compilerOptions.experimentalAndroidMode()
+                ? new PrivateMethodBindingExpression(
+                    resolvedBindings,
+                    componentName,
+                    generatedComponentModel,
+                    simpleMethodBindingExpression,
+                    types,
+                    elements)
+                : simpleMethodBindingExpression;
+          }
+          // fall through
+
+        default:
+          return bindingExpression;
+      }
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 8b695fda3..14b9c7d07 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -20,7 +20,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.isEmpty;
-import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
@@ -28,6 +27,7 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
 import static dagger.internal.codegen.Key.indexByKey;
 import static dagger.internal.codegen.Scope.reusableScope;
+import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.function.Predicate.isEqual;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -35,9 +35,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
-import com.google.common.base.VerifyException;
-import com.google.common.cache.Cache;
-import com.google.common.cache.CacheBuilder;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -56,9 +53,12 @@
 import dagger.internal.codegen.Key.HasKey;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.releasablereferences.CanReleaseReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -66,7 +66,6 @@
 import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
-import java.util.concurrent.ExecutionException;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 import javax.inject.Inject;
@@ -88,6 +87,23 @@
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableSet<BindingGraph> subgraphs();
 
+  /**
+   * The scopes in the graph that {@linkplain CanReleaseReferences can release their references} for
+   * which there is a dependency request for any of the following:
+   *
+   * <ul>
+   *   <li>{@code @ForReleasableReferences(scope)} {@link ReleasableReferenceManager}
+   *   <li>{@code @ForReleasableReferences(scope)} {@code TypedReleasableReferenceManager<M>}, where
+   *       {@code M} is the releasable-references metatadata type for {@code scope}
+   *   <li>{@code Set<ReleasableReferenceManager>}
+   *   <li>{@code Set<TypedReleasableReferenceManager<M>>}, where {@code M} is the metadata type for
+   *       the scope
+   * </ul>
+   *
+   * <p>This set is always empty for subcomponent graphs.
+   */
+  abstract ImmutableSet<Scope> scopesRequiringReleasableReferenceManagers();
+
   /** Returns the resolved bindings for the dependencies of {@code binding}. */
   ImmutableSet<ResolvedBindings> resolvedDependencies(ContributionBinding binding) {
     return binding
@@ -231,7 +247,8 @@ private BindingGraph create(
 
       // Collect Component dependencies.
       for (TypeElement componentDependency : componentDescriptor.dependencies()) {
-        explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
+        explicitBindingsBuilder.add(
+            provisionBindingFactory.forComponentDependency(componentDependency));
         List<ExecutableElement> dependencyMethods =
             ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
         for (ExecutableElement method : dependencyMethods) {
@@ -283,33 +300,9 @@ private BindingGraph create(
         optionalsBuilder.addAll(moduleDescriptor.optionalDeclarations());
       }
 
-      // TODO(dpb,gak): Do we need to bind an empty Set<ReleasableReferenceManager> if there are
-      // none?
-      for (Scope scope : componentDescriptor.releasableReferencesScopes()) {
-        // Add a binding for @ForReleasableReferences(scope) ReleasableReferenceManager.
-        explicitBindingsBuilder.add(
-            provisionBindingFactory.provideReleasableReferenceManager(scope));
-
-        /* Add a binding for Set<ReleasableReferenceManager>. Even if these are added more than
-         * once, each instance will be equal to the rest. Since they're being added to a set, there
-         * will be only one instance. */
-        explicitBindingsBuilder.add(
-            provisionBindingFactory.provideSetOfReleasableReferenceManagers());
-
-        for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
-          // Add a binding for @ForReleasableReferences(scope) TypedReleasableReferenceManager<M>.
-          explicitBindingsBuilder.add(
-              provisionBindingFactory.provideTypedReleasableReferenceManager(
-                  scope, metadata.getAnnotationType()));
-
-          /* Add a binding for Set<TypedReleasableReferenceManager<M>>. Even if these are added more
-           * than once, each instance will be equal to the rest. Since they're being added to a set,
-           * there will be only one instance. */
-          explicitBindingsBuilder.add(
-              provisionBindingFactory.provideSetOfTypedReleasableReferenceManagers(
-                  metadata.getAnnotationType()));
-        }
-      }
+      ImmutableSetMultimap<Scope, ProvisionBinding> releasableReferenceManagerBindings =
+          getReleasableReferenceManagerBindings(componentDescriptor);
+      explicitBindingsBuilder.addAll(releasableReferenceManagerBindings.values());
 
       final Resolver requestResolver =
           new Resolver(
@@ -341,7 +334,9 @@ private BindingGraph create(
         }
       }
 
-      for (ResolvedBindings resolvedBindings : requestResolver.getResolvedBindings().values()) {
+      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap =
+          requestResolver.getResolvedBindings();
+      for (ResolvedBindings resolvedBindings : resolvedBindingsMap.values()) {
         verify(
             resolvedBindings.owningComponent().equals(componentDescriptor),
             "%s is not owned by %s",
@@ -351,11 +346,77 @@ private BindingGraph create(
 
       return new AutoValue_BindingGraph(
           componentDescriptor,
-          requestResolver.getResolvedBindings(),
+          resolvedBindingsMap,
           subgraphs.build(),
+          getScopesRequiringReleasableReferenceManagers(
+              releasableReferenceManagerBindings, resolvedBindingsMap),
           requestResolver.getOwnedModules());
     }
 
+    /**
+     * Returns the bindings for {@link ReleasableReferenceManager}s for all {@link
+     * CanReleaseReferences @CanReleaseReferences} scopes.
+     */
+    private ImmutableSetMultimap<Scope, ProvisionBinding> getReleasableReferenceManagerBindings(
+        ComponentDescriptor componentDescriptor) {
+      ImmutableSetMultimap.Builder<Scope, ProvisionBinding> bindings =
+          ImmutableSetMultimap.builder();
+      // TODO(dpb,gak): Do we need to bind an empty Set<ReleasableReferenceManager> if there are
+      // none?
+      for (Scope scope : componentDescriptor.releasableReferencesScopes()) {
+        // Add a binding for @ForReleasableReferences(scope) ReleasableReferenceManager.
+        bindings.put(scope, provisionBindingFactory.provideReleasableReferenceManager(scope));
+
+        /* Add a binding for Set<ReleasableReferenceManager>. Even if these are added more than
+         * once, each instance will be equal to the rest. Since they're being added to a set, there
+         * will be only one instance. */
+        bindings.put(scope, provisionBindingFactory.provideSetOfReleasableReferenceManagers());
+
+        for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
+          // Add a binding for @ForReleasableReferences(scope) TypedReleasableReferenceManager<M>.
+          bindings.put(
+              scope,
+              provisionBindingFactory.provideTypedReleasableReferenceManager(
+                  scope, metadata.getAnnotationType()));
+
+          /* Add a binding for Set<TypedReleasableReferenceManager<M>>. Even if these are added more
+           * than once, each instance will be equal to the rest. Since they're being added to a set,
+           * there will be only one instance. */
+          bindings.put(
+              scope,
+              provisionBindingFactory.provideSetOfTypedReleasableReferenceManagers(
+                  metadata.getAnnotationType()));
+        }
+      }
+      return bindings.build();
+    }
+
+    /**
+     * Returns the set of scopes that will be returned by {@link
+     * BindingGraph#scopesRequiringReleasableReferenceManagers()}.
+     *
+     * @param releasableReferenceManagerBindings the {@link ReleasableReferenceManager} bindings for
+     *     each scope
+     * @param resolvedBindingsMap the resolved bindings for the component
+     */
+    private ImmutableSet<Scope> getScopesRequiringReleasableReferenceManagers(
+        ImmutableSetMultimap<Scope, ProvisionBinding> releasableReferenceManagerBindings,
+        ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap) {
+      ImmutableSet.Builder<Scope> scopes = ImmutableSet.builder();
+      releasableReferenceManagerBindings
+          .asMap()
+          .forEach(
+              (scope, bindings) -> {
+                for (Binding binding : bindings) {
+                  if (resolvedBindingsMap.containsKey(BindingKey.contribution(binding.key()))) {
+                    scopes.add(scope);
+                    return;
+                  }
+                }
+              });
+      return scopes.build();
+    }
+
     private final class Resolver {
       final Optional<Resolver> parentResolver;
       final ComponentDescriptor componentDescriptor;
@@ -369,10 +430,8 @@ private BindingGraph create(
       final ImmutableSetMultimap<Key, DelegateDeclaration> delegateMultibindingDeclarations;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
-      final Cache<BindingKey, Boolean> bindingKeyDependsOnLocalBindingsCache =
-          CacheBuilder.newBuilder().build();
-      final Cache<Binding, Boolean> bindingDependsOnLocalBindingsCache =
-          CacheBuilder.newBuilder().build();
+      final Map<BindingKey, Boolean> bindingKeyDependsOnLocalBindingsCache = new HashMap<>();
+      final Map<Binding, Boolean> bindingDependsOnLocalBindingsCache = new HashMap<>();
       final Queue<ComponentDescriptor> subcomponentsToResolve = new ArrayDeque<>();
 
       Resolver(
@@ -459,7 +518,6 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
 
             ImmutableSet.Builder<Optional<ContributionBinding>> maybeContributionBindings =
                 ImmutableSet.builder();
-            maybeContributionBindings.add(syntheticMapOfValuesBinding(requestKey));
             maybeContributionBindings.add(
                 syntheticMultibinding(
                     requestKey, multibindingContributions, multibindingDeclarations));
@@ -525,70 +583,16 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
             owningResolver.componentDescriptor.subcomponentsByBuilderType().get(builderType));
       }
 
-      private Iterable<Key> keysMatchingRequest(Key requestKey) {
+      private ImmutableSet<Key> keysMatchingRequest(Key requestKey) {
         ImmutableSet.Builder<Key> keys = ImmutableSet.builder();
         keys.add(requestKey);
         keyFactory.unwrapSetKey(requestKey, Produced.class).ifPresent(keys::add);
         keyFactory.rewrapMapKey(requestKey, Producer.class, Provider.class).ifPresent(keys::add);
         keyFactory.rewrapMapKey(requestKey, Provider.class, Producer.class).ifPresent(keys::add);
+        keys.addAll(keyFactory.implicitFrameworkMapKeys(requestKey));
         return keys.build();
       }
 
-      /**
-       * If {@code key} is a {@code Map<K, V>} or {@code Map<K, Produced<V>>}, and there are any
-       * multibinding contributions or declarations that apply to that map, returns a synthetic
-       * binding for the {@code key} that depends on an {@linkplain #syntheticMultibinding(Key,
-       * Iterable, Iterable) underlying synthetic multibinding}.
-       *
-       * <p>The returned binding has the same {@link BindingType} as the underlying synthetic
-       * multibinding.
-       */
-      private Optional<ContributionBinding> syntheticMapOfValuesBinding(final Key key) {
-        return syntheticMultibinding(
-                key,
-                multibindingContributionsForValueMap(key),
-                multibindingDeclarationsForValueMap(key))
-            .map(
-                syntheticMultibinding -> {
-                  switch (syntheticMultibinding.bindingType()) {
-                    case PROVISION:
-                      return provisionBindingFactory.syntheticMapOfValuesBinding(key);
-
-                    case PRODUCTION:
-                      return productionBindingFactory.syntheticMapOfValuesOrProducedBinding(key);
-
-                    default:
-                      throw new VerifyException(syntheticMultibinding.toString());
-                  }
-                });
-      }
-
-      /**
-       * If {@code key} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
-       * multibinding contributions whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
-       * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
-       */
-      private ImmutableSet<ContributionBinding> multibindingContributionsForValueMap(Key key) {
-        return keyFactory
-            .implicitFrameworkMapKeys(key)
-            .stream()
-            .flatMap(mapKey -> getExplicitMultibindings(mapKey).stream())
-            .collect(toImmutableSet());
-      }
-
-      /**
-       * If {@code key} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
-       * multibinding declarations whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
-       * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
-       */
-      private ImmutableSet<MultibindingDeclaration> multibindingDeclarationsForValueMap(Key key) {
-        return keyFactory
-            .implicitFrameworkMapKeys(key)
-            .stream()
-            .flatMap(mapKey -> getMultibindingDeclarations(mapKey).stream())
-            .collect(toImmutableSet());
-      }
-
       /**
        * Returns a synthetic binding that depends on individual multibinding contributions.
        *
@@ -658,14 +662,19 @@ private boolean multibindingsRequireProduction(
         if (optionalBindingDeclarations.isEmpty()) {
           return Optional.empty();
         }
+        DependencyRequest.Kind kind =
+            DependencyRequest.extractKindAndType(OptionalType.from(key).valueType()).kind();
         ResolvedBindings underlyingKeyBindings =
-            lookUpBindings(contribution(keyFactory.unwrapOptional(key).get()));
+            lookUpBindings(BindingKey.contribution(keyFactory.unwrapOptional(key).get()));
         if (underlyingKeyBindings.isEmpty()) {
           return Optional.of(provisionBindingFactory.syntheticAbsentBinding(key));
-        } else if (underlyingKeyBindings.bindingTypes().contains(BindingType.PRODUCTION)) {
-          return Optional.of(productionBindingFactory.syntheticPresentBinding(key));
+        } else if (underlyingKeyBindings.bindingTypes().contains(BindingType.PRODUCTION)
+            // handles producerFromProvider cases
+            || kind.equals(DependencyRequest.Kind.PRODUCER)
+            || kind.equals(DependencyRequest.Kind.PRODUCED)) {
+          return Optional.of(productionBindingFactory.syntheticPresentBinding(key, kind));
         } else {
-          return Optional.of(provisionBindingFactory.syntheticPresentBinding(key));
+          return Optional.of(provisionBindingFactory.syntheticPresentBinding(key, kind));
         }
       }
 
@@ -1027,37 +1036,36 @@ void resolve(BindingKey bindingKey) {
          *     empty
          */
         boolean dependsOnLocalBindings(BindingKey bindingKey) {
+          // Don't recur infinitely if there are valid cycles in the dependency graph.
+          // http://b/23032377
+          if (!cycleChecker.add(bindingKey)) {
+            return false;
+          }
+          return reentrantComputeIfAbsent(
+              bindingKeyDependsOnLocalBindingsCache,
+              bindingKey,
+              this::dependsOnLocalBindingsUncached);
+        }
+
+        private boolean dependsOnLocalBindingsUncached(BindingKey bindingKey) {
           checkArgument(
               getPreviouslyResolvedBindings(bindingKey).isPresent(),
               "no previously resolved bindings in %s for %s",
               Resolver.this,
               bindingKey);
-          // Don't recur infinitely if there are valid cycles in the dependency graph.
-          // http://b/23032377
-          if (!cycleChecker.add(bindingKey)) {
-            return false;
+          ResolvedBindings previouslyResolvedBindings =
+              getPreviouslyResolvedBindings(bindingKey).get();
+          if (hasLocalMultibindingContributions(previouslyResolvedBindings)
+              || hasLocallyPresentOptionalBinding(previouslyResolvedBindings)) {
+            return true;
           }
-          try {
-            return bindingKeyDependsOnLocalBindingsCache.get(
-                bindingKey,
-                () -> {
-                  ResolvedBindings previouslyResolvedBindings =
-                      getPreviouslyResolvedBindings(bindingKey).get();
-                  if (hasLocalMultibindingContributions(previouslyResolvedBindings)
-                      || hasLocallyPresentOptionalBinding(previouslyResolvedBindings)) {
-                    return true;
-                  }
 
-                  for (Binding binding : previouslyResolvedBindings.bindings()) {
-                    if (dependsOnLocalBindings(binding)) {
-                      return true;
-                    }
-                  }
-                  return false;
-                });
-          } catch (ExecutionException e) {
-            throw new AssertionError(e);
+          for (Binding binding : previouslyResolvedBindings.bindings()) {
+            if (dependsOnLocalBindings(binding)) {
+              return true;
+            }
           }
+          return false;
         }
 
         /**
@@ -1073,25 +1081,22 @@ boolean dependsOnLocalBindings(Binding binding) {
           if (!cycleChecker.add(binding)) {
             return false;
           }
-          try {
-            return bindingDependsOnLocalBindingsCache.get(
-                binding,
-                () -> {
-                  if ((!binding.scope().isPresent()
-                          || binding.scope().get().equals(reusableScope(elements)))
-                      // TODO(beder): Figure out what happens with production subcomponents.
-                      && !binding.bindingType().equals(BindingType.PRODUCTION)) {
-                    for (DependencyRequest dependency : binding.dependencies()) {
-                      if (dependsOnLocalBindings(dependency.bindingKey())) {
-                        return true;
-                      }
-                    }
-                  }
-                  return false;
-                });
-          } catch (ExecutionException e) {
-            throw new AssertionError(e);
+          return reentrantComputeIfAbsent(
+              bindingDependsOnLocalBindingsCache, binding, this::dependsOnLocalBindingsUncached);
+        }
+
+        private boolean dependsOnLocalBindingsUncached(Binding binding) {
+          if ((!binding.scope().isPresent()
+                  || binding.scope().get().equals(reusableScope(elements)))
+              // TODO(beder): Figure out what happens with production subcomponents.
+              && !binding.bindingType().equals(BindingType.PRODUCTION)) {
+            for (DependencyRequest dependency : binding.dependencies()) {
+              if (dependsOnLocalBindings(dependency.bindingKey())) {
+                return true;
+              }
+            }
           }
+          return false;
         }
 
         /**
@@ -1104,7 +1109,9 @@ private boolean hasLocalMultibindingContributions(ResolvedBindings resolvedBindi
                   .stream()
                   .map(ContributionBinding::bindingKind)
                   .anyMatch(SYNTHETIC_MULTIBOUND_KINDS::contains)
-              && !getLocalExplicitMultibindings(resolvedBindings.key()).isEmpty();
+              && keysMatchingRequest(resolvedBindings.key())
+                  .stream()
+                  .anyMatch(key -> !getLocalExplicitMultibindings(key).isEmpty());
         }
 
         /**
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index d68d86975..32143d089 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -30,7 +30,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
@@ -52,6 +51,7 @@
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.abstractModuleHasInstanceBindingMethods;
 import static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;
 import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
 import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
@@ -63,6 +63,7 @@
 import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.Scope.scopesOf;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.joining;
@@ -111,6 +112,7 @@
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
@@ -134,7 +136,6 @@
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
-  private final KeyFormatter keyFormatter;
   private final Key.Factory keyFactory;
 
   BindingGraphValidator(
@@ -146,7 +147,6 @@
       BindingDeclarationFormatter bindingDeclarationFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFormatter dependencyRequestFormatter,
-      KeyFormatter keyFormatter,
       Key.Factory keyFactory) {
     this.elements = elements;
     this.types = types;
@@ -156,7 +156,6 @@
     this.bindingDeclarationFormatter = bindingDeclarationFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
-    this.keyFormatter = keyFormatter;
     this.keyFactory = keyFactory;
   }
 
@@ -190,7 +189,8 @@ protected BindingGraphTraverser bindingGraphTraverser(
 
     /** Returns the report builder for a (sub)component. */
     private ValidationReport.Builder<TypeElement> report(BindingGraph graph) {
-      return reports.computeIfAbsent(
+      return reentrantComputeIfAbsent(
+          reports,
           graph.componentDescriptor(),
           descriptor -> ValidationReport.about(descriptor.componentDefinitionType()));
     }
@@ -199,6 +199,7 @@ protected BindingGraphTraverser bindingGraphTraverser(
     protected void visitComponent(BindingGraph graph) {
       validateDependencyScopes(graph);
       validateComponentDependencyHierarchy(graph);
+      validateModules(graph);
       validateBuilders(graph);
       super.visitComponent(graph);
       checkScopedBindings(graph);
@@ -345,6 +346,19 @@ private void validateDependencyScopes(BindingGraph graph) {
       }
     }
 
+    private void validateModules(BindingGraph graph) {
+      for (ModuleDescriptor module : graph.componentDescriptor().transitiveModules()) {
+        if (module.moduleElement().getModifiers().contains(Modifier.ABSTRACT)) {
+          for (ContributionBinding binding : module.bindings()) {
+            if (binding.requiresModuleInstance()) {
+              report(graph).addError(abstractModuleHasInstanceBindingMethods(module));
+              break;
+            }
+          }
+        }
+      }
+    }
+
     private void validateBuilders(BindingGraph graph) {
       ComponentDescriptor componentDesc = graph.componentDescriptor();
       if (!componentDesc.builderSpec().isPresent()) {
@@ -648,6 +662,10 @@ protected void visitMembersInjectionBinding(
        * ContributionBinding}s with present {@linkplain BindingDeclaration#bindingElement() binding
        * elements}.
        *
+       * <p>Includes {@link ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} or
+       * {@link ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} bindings, even
+       * though they have no binding elements, because they will be reported via the declared
+       * scopes.
        *
        * <p>For other bindings without binding elements, such as the {@link
        * ContributionBinding.Kind#SYNTHETIC_MULTIBOUND_KINDS}, includes the conflicting declarations
@@ -975,8 +993,7 @@ private void reportDuplicateBindings() {
             .stream()
             .map(ContributionBinding::bindingKind)
             // TODO(dpb): Kill with fire.
-            .anyMatch(
-                kind -> SYNTHETIC_MULTIBOUND_KINDS.contains(kind) || SYNTHETIC_MAP.equals(kind))) {
+            .anyMatch(SYNTHETIC_MULTIBOUND_KINDS::contains)) {
           reportMultipleContributionTypes();
           return;
         }
@@ -1165,7 +1182,7 @@ private boolean doesPathRequireProvisionOnly() {
       }
 
       private String formatCurrentDependencyRequestKey() {
-        return keyFormatter.format(dependencyRequest().key());
+        return dependencyRequest().key().toString();
       }
     }
   }
diff --git a/java/dagger/internal/codegen/BindingMethodValidator.java b/java/dagger/internal/codegen/BindingMethodValidator.java
index 0b5f96b09..29495b0c9 100644
--- a/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -39,6 +39,7 @@
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
+import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.type.TypeKind.ARRAY;
@@ -135,7 +136,7 @@ protected BindingMethodValidator(
 
   /** Returns a {@link ValidationReport} for {@code method}. */
   final ValidationReport<ExecutableElement> validate(ExecutableElement method) {
-    return cache.computeIfAbsent(method, this::validateUncached);
+    return reentrantComputeIfAbsent(cache, method, this::validateUncached);
   }
 
   private ValidationReport<ExecutableElement> validateUncached(ExecutableElement m) {
diff --git a/java/dagger/internal/codegen/BindingType.java b/java/dagger/internal/codegen/BindingType.java
index e654b04a4..60e4ad0ec 100644
--- a/java/dagger/internal/codegen/BindingType.java
+++ b/java/dagger/internal/codegen/BindingType.java
@@ -25,18 +25,17 @@
 import dagger.producers.Producer;
 import javax.inject.Provider;
 
-/**
- * Whether a binding or declaration is for provision, production, or a {@link MembersInjector}.
- */
+/** Whether a binding or declaration is for provision, production, or a {@link MembersInjector}. */
+// TODO(dpb): Merge with FrameworkType?
 enum BindingType {
   /** A binding with this type is a {@link ProvisionBinding}. */
-  PROVISION(Provider.class),
+  PROVISION(Provider.class, FrameworkType.PROVIDER),
 
   /** A binding with this type is a {@link MembersInjectionBinding}. */
-  MEMBERS_INJECTION(MembersInjector.class),
+  MEMBERS_INJECTION(MembersInjector.class, FrameworkType.MEMBERS_INJECTOR),
 
   /** A binding with this type is a {@link ProductionBinding}. */
-  PRODUCTION(Producer.class),
+  PRODUCTION(Producer.class, FrameworkType.PRODUCER),
   ;
 
   boolean isOfType(HasBindingType hasBindingType) {
@@ -48,14 +47,16 @@ boolean isOfType(HasBindingType hasBindingType) {
 
   /** An object that is associated with a {@link BindingType}. */
   interface HasBindingType {
+
     /** The binding type of this object. */
     BindingType bindingType();
   }
-
   private final Class<?> frameworkClass;
+  private final FrameworkType frameworkType;
 
-  BindingType(Class<?> frameworkClass) {
+  private BindingType(Class<?> frameworkClass, FrameworkType frameworkType) {
     this.frameworkClass = frameworkClass;
+    this.frameworkType = frameworkType;
   }
 
   /** The framework class associated with bindings of this type. */
@@ -63,6 +64,11 @@ boolean isOfType(HasBindingType hasBindingType) {
     return frameworkClass;
   }
 
+  /** The framework type used to represent bindings of this type. */
+  FrameworkType frameworkType() {
+    return frameworkType;
+  }
+
   /** Returns the {@link #frameworkClass()} parameterized with a type. */
   ParameterizedTypeName frameworkClassOf(TypeName valueType) {
     return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);
diff --git a/java/dagger/internal/codegen/BindingVariableNamer.java b/java/dagger/internal/codegen/BindingVariableNamer.java
index 36db21ab6..496ef8e08 100644
--- a/java/dagger/internal/codegen/BindingVariableNamer.java
+++ b/java/dagger/internal/codegen/BindingVariableNamer.java
@@ -22,8 +22,11 @@
 
 import java.util.Iterator;
 import javax.lang.model.element.Element;
+import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
 /**
@@ -34,6 +37,44 @@
  * @since 2.0
  */
 final class BindingVariableNamer {
+  private static final TypeVisitor<Void, StringBuilder> TYPE_NAMER =
+      new SimpleTypeVisitor6<Void, StringBuilder>() {
+        @Override
+        public Void visitDeclared(DeclaredType declaredType, StringBuilder builder) {
+          Element element = declaredType.asElement();
+          if (isSubcomponentBuilder(element)) {
+            // Most Subcomponent builders are named "Builder", so add their associated
+            // Subcomponent type so that they're not all "builderProvider{N}"
+            builder.append(element.getEnclosingElement().getSimpleName());
+          }
+          builder.append(element.getSimpleName());
+          Iterator<? extends TypeMirror> argumentIterator =
+              declaredType.getTypeArguments().iterator();
+          if (argumentIterator.hasNext()) {
+            builder.append("Of");
+            TypeMirror first = argumentIterator.next();
+            first.accept(this, builder);
+            while (argumentIterator.hasNext()) {
+              builder.append("And");
+              argumentIterator.next().accept(this, builder);
+            }
+          }
+          return null;
+        }
+
+        @Override
+        public Void visitPrimitive(PrimitiveType type, StringBuilder builder) {
+          builder.append(LOWER_CAMEL.to(UPPER_CAMEL, type.toString()));
+          return null;
+        }
+
+        @Override
+        public Void visitArray(ArrayType type, StringBuilder builder) {
+          type.getComponentType().accept(this, builder);
+          builder.append("Array");
+          return null;
+        }
+      };
 
   private BindingVariableNamer() {}
 
@@ -47,32 +88,7 @@ static String name(Binding binding) {
     }
 
     TypeMirror type = typeToName(binding);
-    type.accept(
-        new SimpleTypeVisitor6<Void, StringBuilder>() {
-          @Override
-          public Void visitDeclared(DeclaredType declaredType, StringBuilder builder) {
-            Element element = declaredType.asElement();
-            if (isSubcomponentBuilder(element)) {
-              // Most Subcomponent builders are named "Builder", so add their associated
-              // Subcomponent type so that they're not all "builderProvider{N}"
-              builder.append(element.getEnclosingElement().getSimpleName());
-            }
-            builder.append(element.getSimpleName());
-            Iterator<? extends TypeMirror> argumentIterator =
-                declaredType.getTypeArguments().iterator();
-            if (argumentIterator.hasNext()) {
-              builder.append("Of");
-              TypeMirror first = argumentIterator.next();
-              first.accept(this, builder);
-              while (argumentIterator.hasNext()) {
-                builder.append("And");
-                argumentIterator.next().accept(this, builder);
-              }
-            }
-            return null;
-          }
-        },
-        builder);
+    type.accept(TYPE_NAMER, builder);
 
     return UPPER_CAMEL.to(LOWER_CAMEL, builder.toString());
   }
diff --git a/java/dagger/internal/codegen/BindsMethodValidator.java b/java/dagger/internal/codegen/BindsMethodValidator.java
index 780963820..34e0df1ae 100644
--- a/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -23,22 +23,15 @@
 import static dagger.internal.codegen.ErrorMessages.BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.Module;
 import dagger.producers.ProducerModule;
 import java.util.List;
-import java.util.Map;
-import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -47,7 +40,7 @@
  */
 final class BindsMethodValidator extends BindingMethodValidator {
   private final Types types;
-  private final Elements elements;
+  private final BindsTypeChecker bindsTypeChecker;
 
   BindsMethodValidator(Elements elements, Types types) {
     super(
@@ -59,7 +52,7 @@
         RUNTIME_EXCEPTION,
         ALLOWS_MULTIBINDINGS);
     this.types = types;
-    this.elements = elements;
+    this.bindsTypeChecker = new BindsTypeChecker(types, elements);
   }
 
   @Override
@@ -76,83 +69,18 @@ private void checkParameters(ValidationReport.Builder<ExecutableElement> builder
       TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
       TypeMirror rightHandSide = parameter.asType();
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
-      switch (contributionType) {
-        case SET_VALUES:
-          if (!SetType.isSet(leftHandSide)) {
-            builder.addError(BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET);
-          } else {
-            validateTypesAreAssignable(
-                builder,
-                rightHandSide,
-                methodParameterType(MoreTypes.asDeclared(leftHandSide), "addAll"));
-          }
-          break;
-        case SET:
-          DeclaredType parameterizedSetType = types.getDeclaredType(setElement(), leftHandSide);
-          validateTypesAreAssignable(
-              builder,
-              rightHandSide,
-              methodParameterType(parameterizedSetType, "add"));
-          break;
-        case MAP:
-          DeclaredType parameterizedMapType =
-              types.getDeclaredType(mapElement(), unboundedWildcard(), leftHandSide);
-          validateTypesAreAssignable(
-              builder,
-              rightHandSide,
-              methodParameterTypes(parameterizedMapType, "put").get(1));
-          break;
-        case UNIQUE:
-          validateTypesAreAssignable(builder, rightHandSide, leftHandSide);
-          break;
-        default:
-          throw new AssertionError(
-              String.format(
-                  "Unknown contribution type (%s) for method: %s", contributionType, method));
+      if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
+        builder.addError(BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET);
       }
-    } else {
-      builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);
-    }
-  }
 
-  private ImmutableList<TypeMirror> methodParameterTypes(DeclaredType type, String methodName) {
-    ImmutableList.Builder<ExecutableElement> methodsForName = ImmutableList.builder();
-    for (ExecutableElement method :
-        ElementFilter.methodsIn(MoreElements.asType(type.asElement()).getEnclosedElements())) {
-      if (method.getSimpleName().contentEquals(methodName)) {
-        methodsForName.add(method);
+      if (!bindsTypeChecker.isAssignable(rightHandSide, leftHandSide, contributionType)) {
+        builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);
       }
-    }
-    ExecutableElement method = getOnlyElement(methodsForName.build());
-    return ImmutableList.<TypeMirror>copyOf(
-        MoreTypes.asExecutable(types.asMemberOf(type, method)).getParameterTypes());
-  }
-
-  private TypeMirror methodParameterType(DeclaredType type, String methodName) {
-    return getOnlyElement(methodParameterTypes(type, methodName));
-  }
-
-  private void validateTypesAreAssignable(
-      ValidationReport.Builder<ExecutableElement> builder,
-      TypeMirror rightHandSide,
-      TypeMirror leftHandSide) {
-    if (!types.isAssignable(rightHandSide, leftHandSide)) {
+    } else {
       builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);
     }
   }
 
-  private TypeElement setElement() {
-    return elements.getTypeElement(Set.class.getName());
-  }
-
-  private TypeElement mapElement() {
-    return elements.getTypeElement(Map.class.getName());
-  }
-
-  private TypeMirror unboundedWildcard() {
-    return types.getWildcardType(null, null);
-  }
-
   private TypeMirror boxIfNecessary(TypeMirror maybePrimitive) {
     if (maybePrimitive.getKind().isPrimitive()) {
       return types.boxedClass(MoreTypes.asPrimitiveType(maybePrimitive)).asType();
diff --git a/java/dagger/internal/codegen/BindsTypeChecker.java b/java/dagger/internal/codegen/BindsTypeChecker.java
new file mode 100644
index 000000000..16855344b
--- /dev/null
+++ b/java/dagger/internal/codegen/BindsTypeChecker.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * Checks the assignability of one type to another, given a {@link ContributionType} context. This
+ * is used by {@link BindsMethodValidator} to validate that the right-hand-side of a {@link
+ * dagger.Binds} method is valid, as well as in {@link DelegateBindingExpression} when the
+ * right-hand-side in generated code might be an erased type due to accessibility.
+ */
+final class BindsTypeChecker {
+  private final Types types;
+  private final Elements elements;
+
+  BindsTypeChecker(Types types, Elements elements) {
+    this.types = types;
+    this.elements = elements;
+  }
+
+  /**
+   * Checks the assignability of {@code rightHandSide} to {@code leftHandSide} given a {@link
+   * ContributionType} context.
+   */
+  boolean isAssignable(
+      TypeMirror rightHandSide, TypeMirror leftHandSide, ContributionType contributionType) {
+    return types.isAssignable(rightHandSide, desiredAssignableType(leftHandSide, contributionType));
+  }
+
+  private TypeMirror desiredAssignableType(
+      TypeMirror leftHandSide, ContributionType contributionType) {
+    switch (contributionType) {
+      case UNIQUE:
+        return leftHandSide;
+      case SET:
+        DeclaredType parameterizedSetType = types.getDeclaredType(setElement(), leftHandSide);
+        return methodParameterType(parameterizedSetType, "add");
+      case SET_VALUES:
+        return methodParameterType(MoreTypes.asDeclared(leftHandSide), "addAll");
+      case MAP:
+        DeclaredType parameterizedMapType =
+            types.getDeclaredType(mapElement(), unboundedWildcard(), leftHandSide);
+        return methodParameterTypes(parameterizedMapType, "put").get(1);
+      default:
+        throw new AssertionError("Unknown contribution type: " + contributionType);
+    }
+  }
+
+  private ImmutableList<TypeMirror> methodParameterTypes(DeclaredType type, String methodName) {
+    ImmutableList.Builder<ExecutableElement> methodsForName = ImmutableList.builder();
+    for (ExecutableElement method :
+        methodsIn(MoreElements.asType(type.asElement()).getEnclosedElements())) {
+      if (method.getSimpleName().contentEquals(methodName)) {
+        methodsForName.add(method);
+      }
+    }
+    ExecutableElement method = getOnlyElement(methodsForName.build());
+    return ImmutableList.copyOf(
+        MoreTypes.asExecutable(types.asMemberOf(type, method)).getParameterTypes());
+  }
+
+  private TypeMirror methodParameterType(DeclaredType type, String methodName) {
+    return getOnlyElement(methodParameterTypes(type, methodName));
+  }
+
+  private TypeElement setElement() {
+    return elements.getTypeElement(Set.class.getName());
+  }
+
+  private TypeElement mapElement() {
+    return elements.getTypeElement(Map.class.getName());
+  }
+
+  private TypeMirror unboundedWildcard() {
+    return types.getWildcardType(null, null);
+  }
+}
diff --git a/java/dagger/internal/codegen/BoundInstanceBindingExpression.java b/java/dagger/internal/codegen/BoundInstanceBindingExpression.java
new file mode 100644
index 000000000..b6cc12ba0
--- /dev/null
+++ b/java/dagger/internal/codegen/BoundInstanceBindingExpression.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import dagger.Component;
+
+/**
+ * A binding expression for instances bound with {@link dagger.BindsInstance} and instances of
+ * {@link Component#dependencies() component dependencies}.
+ */
+final class BoundInstanceBindingExpression extends SimpleInvocationBindingExpression {
+  private final ComponentRequirement componentRequirement;
+  private final ComponentRequirementFields componentRequirementFields;
+
+  BoundInstanceBindingExpression(
+      BindingExpression delegate,
+      ComponentRequirement componentRequirement,
+      ComponentRequirementFields componentRequirementFields,
+      DaggerTypes types) {
+    super(delegate, types);
+    this.componentRequirement = componentRequirement;
+    this.componentRequirementFields = componentRequirementFields;
+  }
+
+  @Override
+  Expression getInstanceDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    return Expression.create(
+        componentRequirement.type(),
+        componentRequirementFields.getExpression(componentRequirement, requestingClass));
+  }
+}
diff --git a/java/dagger/internal/codegen/BuilderValidator.java b/java/dagger/internal/codegen/BuilderValidator.java
index 72df34e5c..b1181f25b 100644
--- a/java/dagger/internal/codegen/BuilderValidator.java
+++ b/java/dagger/internal/codegen/BuilderValidator.java
@@ -19,7 +19,6 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.DaggerElements.getUnimplementedMethods;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -42,7 +41,6 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 /**
@@ -52,10 +50,10 @@
  */
 class BuilderValidator {
 
-  private final Elements elements;
+  private final DaggerElements elements;
   private final Types types;
 
-  BuilderValidator(Elements elements, Types types) {
+  BuilderValidator(DaggerElements elements, Types types) {
     this.elements = elements;
     this.types = types;
   }
@@ -109,7 +107,7 @@
     }
 
     ExecutableElement buildMethod = null;
-    for (ExecutableElement method : getUnimplementedMethods(subject, types, elements)) {
+    for (ExecutableElement method : elements.getUnimplementedMethods(subject)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
       TypeMirror returnType = resolvedMethodType.getReturnType();
diff --git a/java/dagger/internal/codegen/CodeBlocks.java b/java/dagger/internal/codegen/CodeBlocks.java
index c8f06405c..8b6b4a0d7 100644
--- a/java/dagger/internal/codegen/CodeBlocks.java
+++ b/java/dagger/internal/codegen/CodeBlocks.java
@@ -20,14 +20,17 @@
 import static java.util.stream.StreamSupport.stream;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.CodeBlock.Builder;
+import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import java.util.stream.Collector;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
 
 final class CodeBlocks {
   /**
@@ -76,6 +79,11 @@ static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
     return stream(codeBlocks.spliterator(), false).collect(toParametersCodeBlock());
   }
 
+  /** Adds an annotation to a method. */
+  static void addAnnotation(MethodSpec.Builder method, DeclaredType nullableType) {
+    method.addAnnotation(ClassName.get(MoreTypes.asTypeElement(nullableType)));
+  }
+
   private static final class CodeBlockJoiner {
     private final String delimiter;
     private final CodeBlock.Builder builder;
diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index b979128ac..44d926184 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -26,13 +26,35 @@
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
+import javax.tools.Diagnostic.Kind;
 
 /** A collection of options that dictate how the compiler will run. */
 @AutoValue
 abstract class CompilerOptions {
   abstract boolean usesProducers();
+
+  /**
+   * Returns true if the experimental Android mode is enabled.
+   *
+   * <p><b>Warning: Do Not use! This flag is for internal, experimental use only!</b>
+   *
+   * <p> Issues related to this flag will not be supported. This flag could break your build, cause
+   * memory leaks in your app, or cause other unknown issues at runtime.
+   *
+   * <p>If enabled, the generated code will attempt to more aggressively inline creation logic for
+   * bindings inside of the component rather than in a separate factory class. Enabling this flag
+   * should reduced the class loading and the number of eagerly initialized fields, at the cost of
+   * potential memory leaks and higher per-provision instantiation time. Due to very slow
+   * classloading on Android, these trade-offs are potentially advantageous.
+   */
+  abstract boolean experimentalAndroidMode();
   abstract boolean writeProducerNameInToken();
   abstract Diagnostic.Kind nullableValidationKind();
+
+  boolean doCheckForNulls() {
+    return nullableValidationKind().equals(Kind.ERROR);
+  }
+
   abstract Diagnostic.Kind privateMemberValidationKind();
   abstract Diagnostic.Kind staticMemberValidationKind();
   abstract boolean ignorePrivateAndStaticInjectionForComponent();
@@ -46,6 +68,8 @@ static Builder builder() {
   static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elements) {
     return builder()
         .usesProducers(elements.getTypeElement(Produces.class.getCanonicalName()) != null)
+        .experimentalAndroidMode(experimentalAndroidMode(processingEnv)
+            .equals(FeatureStatus.ENABLED))
         .writeProducerNameInToken(
             writeProducerNameInToken(processingEnv).equals(FeatureStatus.ENABLED))
         .nullableValidationKind(nullableValidationType(processingEnv).diagnosticKind().get())
@@ -65,6 +89,7 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elem
   @AutoValue.Builder
   interface Builder {
     Builder usesProducers(boolean usesProduces);
+    Builder experimentalAndroidMode(boolean experimentalAndroidMode);
     Builder writeProducerNameInToken(boolean writeProducerNameInToken);
     Builder nullableValidationKind(Diagnostic.Kind kind);
     Builder privateMemberValidationKind(Diagnostic.Kind kind);
@@ -77,6 +102,8 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
     CompilerOptions build();
   }
 
+  static final String EXPERIMENTAL_ANDROID_MODE = "dagger.experimentalAndroidMode";
+
   static final String WRITE_PRODUCER_NAME_IN_TOKEN_KEY = "dagger.writeProducerNameInToken";
 
   static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
@@ -101,14 +128,24 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
   static final String IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT =
       "dagger.ignorePrivateAndStaticInjectionForComponent";
 
-  static final ImmutableSet<String> SUPPORTED_OPTIONS = ImmutableSet.of(
-        WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
-        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
-        NULLABLE_VALIDATION_KEY,
-        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
-        STATIC_MEMBER_VALIDATION_TYPE_KEY,
-        WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
-        IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT);
+  static final ImmutableSet<String> SUPPORTED_OPTIONS =
+      ImmutableSet.of(
+          EXPERIMENTAL_ANDROID_MODE,
+          WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
+          DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
+          NULLABLE_VALIDATION_KEY,
+          PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
+          STATIC_MEMBER_VALIDATION_TYPE_KEY,
+          WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
+          IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT);
+
+  private static FeatureStatus experimentalAndroidMode(ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        EXPERIMENTAL_ANDROID_MODE,
+        FeatureStatus.DISABLED,
+        EnumSet.allOf(FeatureStatus.class));
+  }
 
   private static FeatureStatus writeProducerNameInToken(ProcessingEnvironment processingEnv) {
     return valueOf(
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
new file mode 100644
index 000000000..7bb9312f7
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ClassName;
+import java.util.HashMap;
+import java.util.Map;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+
+/** A central repository of code expressions used to access any binding available to a component. */
+final class ComponentBindingExpressions {
+
+  // TODO(dpb,ronshapiro): refactor this and ComponentRequirementFields into a
+  // HierarchicalComponentMap<K, V>, or perhaps this use a flattened ImmutableMap, built from its
+  // parents? If so, maybe make BindingExpression.Factory create it.
+
+  /**
+   * A list of binding expression maps. The first element contains the bindings owned by this
+   * component; the second contains the bindings owned by its parent; and so on.
+   */
+  private final ImmutableList<Map<BindingKey, BindingExpression>> bindingExpressionsMaps;
+  private final Types types;
+
+  private ComponentBindingExpressions(
+      ImmutableList<Map<BindingKey, BindingExpression>> bindingExpressionsMaps, Types types) {
+    this.bindingExpressionsMaps = bindingExpressionsMaps;
+    this.types = types;
+  }
+
+  ComponentBindingExpressions(Types types) {
+    this(ImmutableList.of(newBindingExpressionMap()), types);
+  }
+
+  /**
+   * Returns an expression that evaluates to the value of a dependency request for a binding owned
+   * by this component or an ancestor.
+   *
+   * @param requestingClass the class that will contain the expression
+   * @throws IllegalStateException if there is no binding expression that satisfies the dependency
+   *     request
+   */
+  Expression getDependencyExpression(
+      BindingKey bindingKey, DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    return getBindingExpression(bindingKey).getDependencyExpression(requestKind, requestingClass);
+  }
+
+  /**
+   * Returns an expression that evaluates to the value of a dependency request for a binding owned
+   * by this component or an ancestor.
+   *
+   * @param requestingClass the class that will contain the expression
+   * @throws IllegalStateException if there is no binding expression that satisfies the dependency
+   *     request
+   */
+  Expression getDependencyExpression(DependencyRequest request, ClassName requestingClass) {
+    return getDependencyExpression(request.bindingKey(), request.kind(), requestingClass);
+  }
+
+  /**
+   * Returns an expression that evaluates to the value of a framework dependency for a binding owned
+   * in this component or an ancestor.
+   *
+   * @param requestingClass the class that will contain the expression
+   * @throws IllegalStateException if there is no binding expression that satisfies the dependency
+   *     request
+   */
+  Expression getDependencyExpression(
+      FrameworkDependency frameworkDependency, ClassName requestingClass) {
+    return getDependencyExpression(
+        frameworkDependency.bindingKey(),
+        frameworkDependency.dependencyRequestKind(),
+        requestingClass);
+  }
+
+  /**
+   * Returns an expression that evaluates to the value of a dependency request, for passing to a
+   * binding method, an {@code @Inject}-annotated constructor or member, or a proxy for one.
+   *
+   * <p>If the method is a generated static {@link InjectionMethods injection method}, each
+   * parameter will be {@link Object} if the dependency's raw type is inaccessible. If that is the
+   * case for this dependency, the returned expression will use a cast to evaluate to the raw type.
+   *
+   * @param requestingClass the class that will contain the expression
+   */
+  // TODO(b/64024402) Merge with getDependencyExpression(DependencyRequest, ClassName) if possible.
+  Expression getDependencyArgumentExpression(
+      DependencyRequest dependencyRequest, ClassName requestingClass) {
+
+    TypeMirror dependencyType = dependencyRequest.key().type();
+    Expression dependencyExpression = getDependencyExpression(dependencyRequest, requestingClass);
+
+    if (!isTypeAccessibleFrom(dependencyType, requestingClass.packageName())
+        && isRawTypeAccessible(dependencyType, requestingClass.packageName())) {
+      return dependencyExpression.castTo(types.erasure(dependencyType));
+    }
+
+    return dependencyExpression;
+  }
+
+  private BindingExpression getBindingExpression(BindingKey bindingKey) {
+    for (Map<BindingKey, BindingExpression> bindingExpressionsMap : bindingExpressionsMaps) {
+      BindingExpression expression = bindingExpressionsMap.get(bindingKey);
+      if (expression != null) {
+        return expression;
+      }
+    }
+    throw new IllegalStateException("no binding expression found for " + bindingKey);
+  }
+
+  /** Adds a binding expression for a single binding owned by this component. */
+  void addBindingExpression(BindingExpression bindingExpression) {
+    bindingExpressionsMaps
+        .get(0)
+        .put(bindingExpression.resolvedBindings().bindingKey(), bindingExpression);
+  }
+
+  /**
+   * Returns a new object representing the bindings available from a child component of this one.
+   */
+  ComponentBindingExpressions forChildComponent() {
+    return new ComponentBindingExpressions(
+        FluentIterable.of(newBindingExpressionMap()).append(bindingExpressionsMaps).toList(),
+        types);
+  }
+
+  private static Map<BindingKey, BindingExpression> newBindingExpressionMap() {
+    return new HashMap<>();
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentBuilder.java b/java/dagger/internal/codegen/ComponentBuilder.java
new file mode 100644
index 000000000..5767d7634
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentBuilder.java
@@ -0,0 +1,300 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.TypeSpecs.addSupertype;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.VOID;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.internal.Preconditions;
+import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import java.util.Optional;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/** Models the generated code for a component builder. */
+final class ComponentBuilder {
+  private final TypeSpec typeSpec;
+  private final ClassName name;
+  private final ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
+
+  private ComponentBuilder(
+      TypeSpec typeSpec,
+      ClassName name,
+      ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
+    this.typeSpec = typeSpec;
+    this.name = name;
+    this.builderFields = builderFields;
+  }
+
+  TypeSpec typeSpec() {
+    return typeSpec;
+  }
+
+  ClassName name() {
+    return name;
+  }
+
+  ImmutableMap<ComponentRequirement, FieldSpec> builderFields() {
+    return builderFields;
+  }
+
+  static ComponentBuilder create(
+      ClassName componentName,
+      BindingGraph graph,
+      ImmutableMap<ComponentDescriptor, String> subcomponentNames,
+      Elements elements,
+      Types types) {
+    return new Creator(componentName, graph, subcomponentNames, elements, types).create();
+  }
+
+  private static final class Creator {
+    private static final String NOOP_BUILDER_METHOD_JAVADOC =
+        "This module is declared, but an instance is not used in the component. This method is a "
+            + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
+    private final BindingGraph graph;
+    private final TypeSpec.Builder builder;
+    private final ClassName componentName;
+    private final ClassName builderName;
+    private final Elements elements;
+    private final Types types;
+    private ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
+
+    Creator(
+        ClassName componentName,
+        BindingGraph graph,
+        ImmutableMap<ComponentDescriptor, String> subcomponentNames,
+        Elements elements,
+        Types types) {
+      this.componentName = componentName;
+      if (graph.componentDescriptor().kind().isTopLevel()) {
+        builderName = componentName.nestedClass("Builder");
+        builder = classBuilder(builderName).addModifiers(STATIC);
+      } else {
+        builderName =
+            componentName.peerClass(subcomponentNames.get(graph.componentDescriptor()) + "Builder");
+        builder = classBuilder(builderName);
+      }
+      this.graph = graph;
+      this.elements = elements;
+      this.types = types;
+    }
+
+    ComponentBuilder create() {
+      if (builderSpec().isPresent()) {
+        builder.addModifiers(PRIVATE);
+        addSupertype(builder, builderSpec().get().builderDefinitionType());
+      } else {
+        builder.addModifiers(PUBLIC).addMethod(constructorBuilder().addModifiers(PRIVATE).build());
+      }
+
+      builderFields = builderFields(graph);
+
+      builder
+          .addModifiers(FINAL)
+          .addFields(builderFields.values())
+          .addMethod(buildMethod())
+          // TODO(ronshapiro): this should be switched with buildMethod(), but that currently breaks
+          // compile-testing tests that rely on the order of the methods
+          .addMethods(builderMethods());
+
+      return new ComponentBuilder(builder.build(), builderName, builderFields);
+    }
+
+    /**
+     * Computes fields for each of the {@linkplain BindingGraph#componentRequirements component
+     * requirements}. Regardless of builder spec, there is always one field per requirement.
+     */
+    private static ImmutableMap<ComponentRequirement, FieldSpec> builderFields(BindingGraph graph) {
+      UniqueNameSet fieldNames = new UniqueNameSet();
+      ImmutableMap.Builder<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.builder();
+      for (ComponentRequirement componentRequirement : graph.componentRequirements()) {
+        String name = fieldNames.getUniqueName(componentRequirement.variableName());
+        builderFields.put(
+            componentRequirement,
+            FieldSpec.builder(TypeName.get(componentRequirement.type()), name, PRIVATE).build());
+      }
+      return builderFields.build();
+    }
+
+    private MethodSpec buildMethod() {
+      MethodSpec.Builder buildMethod;
+      if (builderSpec().isPresent()) {
+        ExecutableElement specBuildMethod = builderSpec().get().buildMethod();
+        // Note: we don't use the specBuildMethod.getReturnType() as the return type
+        // because it might be a type variable.  We make use of covariant returns to allow
+        // us to return the component type, which will always be valid.
+        buildMethod =
+            methodBuilder(specBuildMethod.getSimpleName().toString()).addAnnotation(Override.class);
+      } else {
+        buildMethod = methodBuilder("build");
+      }
+      buildMethod.returns(ClassName.get(graph.componentType())).addModifiers(PUBLIC);
+
+      builderFields.forEach(
+          (requirement, builderField) -> {
+            switch (requirement.nullPolicy(elements, types)) {
+              case NEW:
+                buildMethod.addCode(
+                    "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
+                break;
+              case THROW:
+                buildMethod.addCode(
+                    "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
+                    builderField,
+                    IllegalStateException.class,
+                    TypeNames.rawTypeName(builderField.type),
+                    " must be set");
+                break;
+              case ALLOW:
+                break;
+              default:
+                throw new AssertionError(requirement);
+            }
+          });
+      buildMethod.addStatement("return new $T(this)", componentName);
+      return buildMethod.build();
+    }
+
+    /**
+     * Computes the methods that set each of parameters on the builder. If the {@link BuilderSpec}
+     * is present, it will tailor the methods to match the spec.
+     */
+    private ImmutableSet<MethodSpec> builderMethods() {
+      ImmutableSet<ComponentRequirement> componentRequirements = graph.componentRequirements();
+      ImmutableSet.Builder<MethodSpec> methods = ImmutableSet.builder();
+      if (builderSpec().isPresent()) {
+        UniqueNameSet parameterNames = new UniqueNameSet();
+        for (BuilderRequirementMethod requirementMethod :
+            builderSpec().get().requirementMethods()) {
+          ComponentRequirement builderRequirement = requirementMethod.requirement();
+          ExecutableElement specMethod = requirementMethod.method();
+          MethodSpec.Builder builderMethod = addBuilderMethodFromSpec(specMethod);
+          VariableElement parameterElement = Iterables.getOnlyElement(specMethod.getParameters());
+          String parameterName = parameterNames.getUniqueName(parameterElement.getSimpleName());
+
+          TypeName argType =
+              parameterElement.asType().getKind().isPrimitive()
+                  // Primitives need to use the original (unresolved) type to avoid boxing.
+                  ? TypeName.get(parameterElement.asType())
+                  // Otherwise we use the full resolved type.
+                  : TypeName.get(builderRequirement.type());
+
+          builderMethod.addParameter(argType, parameterName);
+          if (componentRequirements.contains(builderRequirement)) {
+            // required type
+            builderMethod.addStatement(
+                "this.$N = $L",
+                builderFields.get(builderRequirement),
+                builderRequirement
+                        .nullPolicy(elements, types)
+                        .equals(ComponentRequirement.NullPolicy.ALLOW)
+                    ? parameterName
+                    : CodeBlock.of("$T.checkNotNull($L)", Preconditions.class, parameterName));
+            addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
+          } else if (graph.ownedModuleTypes().contains(builderRequirement.typeElement())) {
+            // owned, but not required
+            builderMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);
+            addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
+          } else {
+            // neither owned nor required, so it must be an inherited module
+            builderMethod.addStatement(
+                "throw new $T($T.format($S, $T.class.getCanonicalName()))",
+                UnsupportedOperationException.class,
+                String.class,
+                "%s cannot be set because it is inherited from the enclosing component",
+                TypeNames.rawTypeName(TypeName.get(builderRequirement.type())));
+          }
+          methods.add(builderMethod.build());
+        }
+      } else {
+        for (ComponentRequirement componentRequirement : graph.availableDependencies()) {
+          String componentRequirementName = simpleVariableName(componentRequirement.typeElement());
+          MethodSpec.Builder builderMethod =
+              methodBuilder(componentRequirementName)
+                  .returns(builderName)
+                  .addModifiers(PUBLIC)
+                  .addParameter(
+                      TypeName.get(componentRequirement.type()), componentRequirementName);
+          if (componentRequirements.contains(componentRequirement)) {
+            builderMethod.addStatement(
+                "this.$N = $T.checkNotNull($L)",
+                builderFields.get(componentRequirement),
+                Preconditions.class,
+                componentRequirementName);
+          } else {
+            builderMethod.addStatement(
+                "$T.checkNotNull($L)", Preconditions.class, componentRequirementName);
+            builderMethod.addJavadoc("@deprecated " + NOOP_BUILDER_METHOD_JAVADOC);
+            builderMethod.addAnnotation(Deprecated.class);
+          }
+          builderMethod.addStatement("return this");
+          methods.add(builderMethod.build());
+        }
+      }
+      return methods.build();
+    }
+
+    private MethodSpec.Builder addBuilderMethodFromSpec(ExecutableElement method) {
+      TypeMirror returnType = method.getReturnType();
+      MethodSpec.Builder builderMethod =
+          methodBuilder(method.getSimpleName().toString())
+              .addAnnotation(Override.class)
+              .addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
+      // If the return type is void, we add a method with the void return type.
+      // Otherwise we use the generated builder name and take advantage of covariant returns
+      // (so that we don't have to worry about setter methods that return type variables).
+      if (!returnType.getKind().equals(VOID)) {
+        builderMethod.returns(builderName);
+      }
+      return builderMethod;
+    }
+
+    private static void addBuilderMethodReturnStatementForSpec(
+        ExecutableElement specMethod, MethodSpec.Builder builderMethod) {
+      if (!specMethod.getReturnType().getKind().equals(VOID)) {
+        builderMethod.addStatement("return this");
+      }
+    }
+
+    private Optional<BuilderSpec> builderSpec() {
+      return graph.componentDescriptor().builderSpec();
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 0006c072b..aa9310f5b 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -25,9 +25,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
-import static dagger.internal.codegen.DaggerElements.checkTypePresent;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static dagger.internal.codegen.DaggerElements.getUnimplementedMethods;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static javax.lang.model.type.TypeKind.DECLARED;
@@ -445,13 +443,13 @@ Kind componentKind() {
   }
 
   static final class Factory {
-    private final Elements elements;
+    private final DaggerElements elements;
     private final Types types;
     private final DependencyRequest.Factory dependencyRequestFactory;
     private final ModuleDescriptor.Factory moduleDescriptorFactory;
 
     Factory(
-        Elements elements,
+        DaggerElements elements,
         Types types,
         DependencyRequest.Factory dependencyRequestFactory,
         ModuleDescriptor.Factory moduleDescriptorFactory) {
@@ -522,7 +520,7 @@ private ComponentDescriptor create(
         }
       }
       ImmutableSet<ExecutableElement> unimplementedMethods =
-          getUnimplementedMethods(componentDefinitionType, types, elements);
+          elements.getUnimplementedMethods(componentDefinitionType);
 
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
@@ -668,7 +666,7 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
         return Optional.empty();
       }
       TypeElement element = MoreTypes.asTypeElement(builderType.get());
-      ImmutableSet<ExecutableElement> methods = getUnimplementedMethods(element, types, elements);
+      ImmutableSet<ExecutableElement> methods = elements.getUnimplementedMethods(element);
       ImmutableSet.Builder<BuilderRequirementMethod> requirementMethods = ImmutableSet.builder();
       ExecutableElement buildMethod = null;
       for (ExecutableElement method : methods) {
@@ -719,7 +717,7 @@ private ComponentRequirement requirementForBuilderMethod(
     private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefinitionType) {
       ClassName monitoringModuleName =
           SourceFiles.generatedMonitoringModuleName(componentDefinitionType);
-      TypeElement monitoringModule = checkTypePresent(monitoringModuleName.toString(), elements);
+      TypeElement monitoringModule = elements.checkTypePresent(monitoringModuleName.toString());
       return moduleDescriptorFactory.create(monitoringModule);
     }
 
@@ -736,7 +734,7 @@ private ModuleDescriptor descriptorForProductionExecutorModule(
       ClassName productionExecutorModuleName =
           SourceFiles.generatedProductionExecutorModuleName(componentDefinitionType);
       TypeElement productionExecutorModule =
-          checkTypePresent(productionExecutorModuleName.toString(), elements);
+          elements.checkTypePresent(productionExecutorModuleName.toString());
       return moduleDescriptorFactory.create(productionExecutorModule);
     }
   }
diff --git a/java/dagger/internal/codegen/ComponentGenerator.java b/java/dagger/internal/codegen/ComponentGenerator.java
index dadb44639..bca63f0c1 100644
--- a/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/java/dagger/internal/codegen/ComponentGenerator.java
@@ -24,7 +24,6 @@
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * Generates the implementation of the abstract types annotated with {@link Component}.
@@ -33,7 +32,7 @@
  * @since 2.0
  */
 final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
-  private final Types types;
+  private final DaggerTypes types;
   private final Elements elements;
   private final Key.Factory keyFactory;
   private final CompilerOptions compilerOptions;
@@ -41,7 +40,7 @@
   ComponentGenerator(
       Filer filer,
       Elements elements,
-      Types types,
+      DaggerTypes types,
       Key.Factory keyFactory,
       CompilerOptions compilerOptions) {
     super(filer, elements);
diff --git a/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
new file mode 100644
index 000000000..6e04039ac
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+
+/** A binding expression for the instance of the component itself, i.e. {@code this}. */
+final class ComponentInstanceBindingExpression extends SimpleInvocationBindingExpression {
+  private final ClassName componentName;
+  private final ContributionBinding binding;
+
+  ComponentInstanceBindingExpression(
+      BindingExpression delegate,
+      ContributionBinding binding,
+      ClassName componentName,
+      DaggerTypes types) {
+    super(delegate, types);
+    this.componentName = componentName;
+    this.binding = binding;
+  }
+
+  @Override
+  Expression getInstanceDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    return Expression.create(
+        binding.key().type(),
+        componentName.equals(requestingClass)
+            ? CodeBlock.of("this")
+            : CodeBlock.of("$T.this", componentName));
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index b0a852702..d35e30b9d 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -29,8 +29,6 @@
 import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.SourceVersion;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
@@ -60,15 +58,14 @@ public SourceVersion getSupportedSourceVersion() {
   @Override
   protected Iterable<? extends ProcessingStep> initSteps() {
     Messager messager = processingEnv.getMessager();
-    Types types = processingEnv.getTypeUtils();
-    Elements elements = processingEnv.getElementUtils();
+    DaggerTypes types = new DaggerTypes(processingEnv);
+    DaggerElements elements = new DaggerElements(processingEnv);
     CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
     Filer filer =  new FormattingFiler(processingEnv.getFiler());
 
-    KeyFormatter keyFormatter = new KeyFormatter();
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     BindingDeclarationFormatter bindingDeclarationFormatter =
-        new BindingDeclarationFormatter(methodSignatureFormatter, keyFormatter);
+        new BindingDeclarationFormatter(methodSignatureFormatter);
     DependencyRequestFormatter dependencyRequestFormatter =
         new DependencyRequestFormatter(types, elements);
 
@@ -105,23 +102,13 @@ public SourceVersion getSupportedSourceVersion() {
             elements, types, moduleValidator, subcomponentValidator, builderValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator(elements);
 
-    this.factoryGenerator =
-        new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);
-    this.membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, elements, injectValidatorWhenGeneratingCode);
-    ComponentGenerator componentGenerator =
-        new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
-    ProducerFactoryGenerator producerFactoryGenerator =
-        new ProducerFactoryGenerator(filer, elements, compilerOptions);
-    MonitoringModuleGenerator monitoringModuleGenerator =
-        new MonitoringModuleGenerator(filer, elements);
-    ProductionExecutorModuleGenerator productionExecutorModuleGenerator =
-        new ProductionExecutorModuleGenerator(filer, elements);
-
     DependencyRequest.Factory dependencyRequestFactory =
         new DependencyRequest.Factory(keyFactory);
+    MembersInjectionBinding.Factory membersInjectionBindingFactory =
+        new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
     ProvisionBinding.Factory provisionBindingFactory =
-        new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
+        new ProvisionBinding.Factory(
+            types, keyFactory, dependencyRequestFactory, membersInjectionBindingFactory);
     ProductionBinding.Factory productionBindingFactory =
         new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);
     MultibindingDeclaration.Factory multibindingDeclarationFactory =
@@ -129,8 +116,19 @@ public SourceVersion getSupportedSourceVersion() {
     SubcomponentDeclaration.Factory subcomponentDeclarationFactory =
         new SubcomponentDeclaration.Factory(keyFactory);
 
-    MembersInjectionBinding.Factory membersInjectionBindingFactory =
-        new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
+    this.factoryGenerator =
+        new FactoryGenerator(
+            filer, elements, types, compilerOptions, injectValidatorWhenGeneratingCode);
+    this.membersInjectorGenerator =
+        new MembersInjectorGenerator(filer, elements, types, injectValidatorWhenGeneratingCode);
+    ComponentGenerator componentGenerator =
+        new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
+    ProducerFactoryGenerator producerFactoryGenerator =
+        new ProducerFactoryGenerator(filer, elements, types, compilerOptions);
+    MonitoringModuleGenerator monitoringModuleGenerator =
+        new MonitoringModuleGenerator(filer, elements);
+    ProductionExecutorModuleGenerator productionExecutorModuleGenerator =
+        new ProductionExecutorModuleGenerator(filer, elements);
 
     DelegateDeclaration.Factory bindingDelegateDeclarationFactory =
         new DelegateDeclaration.Factory(types, keyFactory, dependencyRequestFactory);
@@ -187,7 +185,6 @@ public SourceVersion getSupportedSourceVersion() {
             bindingDeclarationFormatter,
             methodSignatureFormatter,
             dependencyRequestFormatter,
-            keyFormatter,
             keyFactory);
 
     return ImmutableList.of(
diff --git a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
new file mode 100644
index 000000000..afdaf381e
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
+
+import com.google.auto.common.MoreElements;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.Preconditions;
+import javax.lang.model.element.TypeElement;
+
+/** A binding expression for component provision methods. */
+final class ComponentProvisionBindingExpression extends SimpleInvocationBindingExpression {
+  private final ProvisionBinding binding;
+  private final BindingGraph bindingGraph;
+  private final ComponentRequirementFields componentRequirementFields;
+  private final CompilerOptions compilerOptions;
+
+  ComponentProvisionBindingExpression(
+      BindingExpression providerBindingExpression,
+      ProvisionBinding binding,
+      BindingGraph bindingGraph,
+      ComponentRequirementFields componentRequirementFields,
+      CompilerOptions compilerOptions,
+      DaggerTypes types) {
+    super(providerBindingExpression, types);
+    this.binding = checkNotNull(binding);
+    this.bindingGraph = checkNotNull(bindingGraph);
+    this.componentRequirementFields = checkNotNull(componentRequirementFields);
+    this.compilerOptions = checkNotNull(compilerOptions);
+  }
+
+  @Override
+  Expression getInstanceDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    CodeBlock invocation =
+        CodeBlock.of(
+            "$L.$L()",
+            componentRequirementFields.getExpression(componentRequirement(), requestingClass),
+            binding.bindingElement().get().getSimpleName());
+    return Expression.create(
+        binding.key().type(), maybeCheckForNull(binding, compilerOptions, invocation));
+  }
+
+  private ComponentRequirement componentRequirement() {
+    TypeElement componentDependency =
+        bindingGraph
+            .componentDescriptor()
+            .dependencyMethodIndex()
+            .get(MoreElements.asExecutable(binding.bindingElement().get()));
+    return ComponentRequirement.forDependency(componentDependency.asType());
+  }
+
+  static CodeBlock maybeCheckForNull(
+      ProvisionBinding binding, CompilerOptions compilerOptions, CodeBlock invocation) {
+    return binding.shouldCheckForNull(compilerOptions)
+        ? CodeBlock.of(
+            "$T.checkNotNull($L, $S)",
+            Preconditions.class,
+            invocation,
+            CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD)
+        : invocation;
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentRequirementField.java b/java/dagger/internal/codegen/ComponentRequirementField.java
new file mode 100644
index 000000000..e8d721d47
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentRequirementField.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.google.common.collect.ImmutableMap;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.TypeName;
+
+/**
+ * A factory for expressions of {@link ComponentRequirement}s in the generated component. This is
+ * <em>not</em> a {@link BindingExpression}, since {@link ComponentRequirement}s do not have a
+ * {@link BindingKey}. See {@link BoundInstanceBindingExpression} for binding expressions that are
+ * themselves a binding.
+ */
+abstract class ComponentRequirementField {
+  private final ComponentRequirement componentRequirement;
+
+  private ComponentRequirementField(ComponentRequirement componentRequirement) {
+    this.componentRequirement = checkNotNull(componentRequirement);
+  }
+
+  final ComponentRequirement componentRequirement() {
+    return componentRequirement;
+  }
+
+  /**
+   * Returns an expression for the {@link ComponentRequirement} to be used when implementing a
+   * component method. This may add a field to the component in order to reference the component
+   * requirement outside of the {@code initialize()} methods.
+   */
+  abstract CodeBlock getExpression(ClassName requestingClass);
+
+  /**
+   * Returns an expression for the {@link ComponentRequirement} to be used only within {@code
+   * initialize()} methods, where the component builder is available.
+   *
+   * <p>When accessing this field from a subcomponent, this may cause a field to be initialized in
+   * the component that owns this {@link ComponentRequirement}.
+   */
+  abstract CodeBlock getExpressionDuringInitialization(ClassName requestingClass);
+
+  /**
+   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a corresponding
+   * field on the component builder.
+   */
+  private static final class BuilderField extends ComponentRequirementField {
+    private final GeneratedComponentModel generatedComponentModel;
+    private final UniqueNameSet componentFieldNames;
+    private final ClassName owningComponent;
+    private final FieldSpec builderField;
+    private MemberSelect field;
+
+    private BuilderField(
+        ComponentRequirement componentRequirement,
+        GeneratedComponentModel generatedComponentModel,
+        UniqueNameSet componentFieldNames,
+        ClassName owningComponent,
+        FieldSpec builderField) {
+      super(componentRequirement);
+      this.generatedComponentModel = checkNotNull(generatedComponentModel);
+      this.componentFieldNames = checkNotNull(componentFieldNames);
+      this.owningComponent = checkNotNull(owningComponent);
+      this.builderField = checkNotNull(builderField);
+    }
+
+    @Override
+    CodeBlock getExpression(ClassName requestingClass) {
+      return getField().getExpressionFor(requestingClass);
+    }
+
+    @Override
+    CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
+      if (owningComponent.equals(requestingClass)) {
+        return CodeBlock.of("builder.$N", builderField);
+      } else {
+        // requesting this component requirement during initialization of a child component requires
+        // the it to be access from a field and not the builder (since it is no longer available)
+        return getExpression(requestingClass);
+      }
+    }
+
+    private MemberSelect getField() {
+      if (field == null) {
+        // TODO(dpb,ronshapiro): think about whether GeneratedComponentModel.addField should make a
+        // unique name for the field.
+        String fieldName = componentFieldNames.getUniqueName(componentRequirement().variableName());
+        FieldSpec componentField =
+            FieldSpec.builder(TypeName.get(componentRequirement().type()), fieldName, PRIVATE)
+                .build();
+        generatedComponentModel.addField(componentField);
+        generatedComponentModel.addInitialization(
+            CodeBlock.of("this.$N = builder.$N;", componentField, builderField));
+        field = MemberSelect.localField(owningComponent, fieldName);
+      }
+      return field;
+    }
+  }
+
+  /**
+   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a corresponding
+   * field already added on the component.
+   */
+  private static final class ComponentField extends ComponentRequirementField {
+    private final MemberSelect memberSelect;
+
+    private ComponentField(
+        ComponentRequirement componentRequirement,
+        FieldSpec componentField,
+        ClassName owningComponent) {
+      super(componentRequirement);
+      this.memberSelect = MemberSelect.localField(owningComponent, componentField.name);
+    }
+
+    @Override
+    CodeBlock getExpression(ClassName requestingClass) {
+      return memberSelect.getExpressionFor(requestingClass);
+    }
+
+    @Override
+    CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
+      return getExpression(requestingClass);
+    }
+  }
+
+  static final class Factory {
+    private final GeneratedComponentModel generatedComponentModel;
+    private final UniqueNameSet componentFieldNames;
+    private final ClassName owningComponent;
+    private final ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
+
+    Factory(
+        GeneratedComponentModel generatedComponentModel,
+        UniqueNameSet componentFieldNames,
+        ClassName owningComponent,
+        ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
+      this.generatedComponentModel = checkNotNull(generatedComponentModel);
+      this.componentFieldNames = checkNotNull(componentFieldNames);
+      this.owningComponent = checkNotNull(owningComponent);
+      this.builderFields = checkNotNull(builderFields);
+    }
+
+    /**
+     * Returns a {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a
+     * corresponding field on the component builder.
+     */
+    ComponentRequirementField forBuilderField(ComponentRequirement componentRequirement) {
+      return new BuilderField(
+          componentRequirement,
+          generatedComponentModel,
+          componentFieldNames,
+          owningComponent,
+          builderFields.get(componentRequirement));
+    }
+  }
+
+  /**
+   * Returns a {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a
+   * corresponding field already added on the component.
+   */
+  static ComponentRequirementField componentField(
+      ComponentRequirement componentRequirement,
+      FieldSpec componentField,
+      ClassName owningComponent) {
+    return new ComponentField(componentRequirement, componentField, owningComponent);
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentRequirementFields.java b/java/dagger/internal/codegen/ComponentRequirementFields.java
new file mode 100644
index 000000000..afa33828d
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentRequirementFields.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A central repository of fields used to access any {@link ComponentRequirement} available to a
+ * component.
+ */
+final class ComponentRequirementFields {
+
+  // TODO(dpb,ronshapiro): refactor this and ComponentBindingExpressions into a
+  // HierarchicalComponentMap<K, V>, or perhaps this use a flattened ImmutableMap, built from its
+  // parents? If so, maybe make ComponentRequirementField.Factory create it.
+
+  /**
+   * A list of component requirement field maps. The first element contains the fields on this
+   * component; the second contains the fields owned by its parent; and so on.
+   */
+  private final ImmutableList<Map<ComponentRequirement, ComponentRequirementField>>
+      componentRequirementFieldsMaps;
+
+  private ComponentRequirementFields(
+      ImmutableList<Map<ComponentRequirement, ComponentRequirementField>>
+          componentRequirementFieldsMaps) {
+    this.componentRequirementFieldsMaps = componentRequirementFieldsMaps;
+  }
+
+  ComponentRequirementFields() {
+    this(ImmutableList.of(newComponentRequirementsMap()));
+  }
+
+  /**
+   * Returns an expression for the {@code componentRequirement} to be used when implementing a
+   * component method. This may add a field to the component in order to reference the component
+   * requirement outside of the {@code initialize()} methods.
+   */
+  CodeBlock getExpression(ComponentRequirement componentRequirement, ClassName requestingClass) {
+    return getField(componentRequirement).getExpression(requestingClass);
+  }
+
+  /**
+   * Returns an expression for the {@code componentRequirement} to be used only within {@code
+   * initialize()} methods, where the component builder is available.
+   *
+   * <p>When accessing this field from a subcomponent, this may cause a field to be initialized in
+   * the component that owns this {@link ComponentRequirement}.
+   */
+  CodeBlock getExpressionDuringInitialization(
+      ComponentRequirement componentRequirement, ClassName requestingClass) {
+    return getField(componentRequirement).getExpressionDuringInitialization(requestingClass);
+  }
+
+  private ComponentRequirementField getField(ComponentRequirement componentRequirement) {
+    for (Map<ComponentRequirement, ComponentRequirementField> componentRequirementFieldsMap :
+        componentRequirementFieldsMaps) {
+      ComponentRequirementField field = componentRequirementFieldsMap.get(componentRequirement);
+      if (field != null) {
+        return field;
+      }
+    }
+    throw new IllegalStateException(
+        "no component requirement field found for " + componentRequirement);
+  }
+
+  /**
+   * Adds a component requirement field for a single component requirement owned by this component.
+   */
+  void add(ComponentRequirementField field) {
+    componentRequirementFieldsMaps.get(0).put(field.componentRequirement(), field);
+  }
+
+  /**
+   * Returns {@code true} if the component that owns this {@link ComponentRequirementFields} has a
+   * registered {@link ComponentRequirementField} for {@code componentRequirement}.
+   */
+  boolean contains(ComponentRequirement componentRequirement) {
+    return componentRequirementFieldsMaps
+        .stream()
+        .anyMatch(map -> map.containsKey(componentRequirement));
+  }
+
+  private static Map<ComponentRequirement, ComponentRequirementField>
+      newComponentRequirementsMap() {
+    return new HashMap<>();
+  }
+
+  /**
+   * Returns a new object representing the fields available from a child component of this one.
+   */
+  ComponentRequirementFields forChildComponent() {
+    return new ComponentRequirementFields(
+        FluentIterable.of(newComponentRequirementsMap())
+            .append(componentRequirementFieldsMaps)
+            .toList());
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index f1c8b9b0f..e0f8764a3 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static java.lang.Character.isUpperCase;
 import static java.lang.String.format;
@@ -26,7 +25,6 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.common.base.CharMatcher;
-import com.google.common.base.Joiner;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableListMultimap;
@@ -44,7 +42,6 @@
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * Creates the implementation class for a component.
@@ -52,7 +49,7 @@
 final class ComponentWriter extends AbstractComponentWriter {
 
   ComponentWriter(
-      Types types,
+      DaggerTypes types,
       Elements elements,
       Key.Factory keyFactory,
       CompilerOptions compilerOptions,
@@ -66,7 +63,9 @@
         name,
         graph,
         new UniqueSubcomponentNamesGenerator(graph).generate(),
-        new OptionalFactories());
+        new OptionalFactories(),
+        new ComponentBindingExpressions(types),
+        new ComponentRequirementFields());
   }
 
   /**
@@ -76,7 +75,6 @@
   private static class UniqueSubcomponentNamesGenerator {
 
     private static final Splitter QUALIFIED_NAME_SPLITTER = Splitter.on('.');
-    private static final Joiner QUALIFIED_NAME_JOINER = Joiner.on('_');
 
     private final BindingGraph graph;
     private final ImmutableListMultimap<String, ComponentDescriptor>
@@ -186,15 +184,7 @@ protected void decorateComponent() {
     addSupertype(component, graph.componentType());
   }
 
-  @Override
-  protected ClassName builderName() {
-    return name.nestedClass("Builder");
-  }
-
-  @Override
-  protected TypeSpec.Builder createBuilder(String builderSimpleName) {
-    TypeSpec.Builder builder = classBuilder(builderSimpleName).addModifiers(STATIC);
-
+  private void addBuilderFactoryMethod() {
     // Only top-level components have the factory builder() method.
     // Mirror the user's builder API type if they had one.
     MethodSpec builderFactoryMethod =
@@ -203,12 +193,11 @@ protected ClassName builderName() {
             .returns(
                 graph.componentDescriptor().builderSpec().isPresent()
                     ? ClassName.get(
-                        graph.componentDescriptor().builderSpec().get().builderDefinitionType())
-                    : builderName.get())
-            .addStatement("return new $T()", builderName.get())
+                    graph.componentDescriptor().builderSpec().get().builderDefinitionType())
+                    : builderName())
+            .addStatement("return new $T()", builderName())
             .build();
     component.addMethod(builderFactoryMethod);
-    return builder;
   }
 
   @Override
@@ -218,6 +207,7 @@ protected void addBuilderClass(TypeSpec builder) {
 
   @Override
   protected void addFactoryMethods() {
+    addBuilderFactoryMethod();
     if (canInstantiateAllRequirements()) {
       CharSequence buildMethodName =
           graph.componentDescriptor().builderSpec().isPresent()
@@ -225,7 +215,7 @@ protected void addFactoryMethods() {
               : "build";
       component.addMethod(
           methodBuilder("create")
-              .returns(componentDefinitionTypeName())
+              .returns(ClassName.get(graph.componentType()))
               .addModifiers(PUBLIC, STATIC)
               .addStatement("return new Builder().$L()", buildMethodName)
               .build());
@@ -238,4 +228,9 @@ private boolean canInstantiateAllRequirements() {
         graph.componentRequirements(),
         dependency -> dependency.requiresAPassedInstance(elements, types));
   }
+
+  @Override
+  protected boolean requiresReleasableReferences(Scope scope) {
+    return graph.scopesRequiringReleasableReferenceManagers().contains(scope);
+  }
 }
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index b95f04a89..d8b94516b 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -25,6 +25,7 @@
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.STATIC;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Equivalence.Wrapper;
@@ -72,12 +73,6 @@
    * of contribution.
    */
   enum Kind {
-    /**
-     * The synthetic binding for {@code Map<K, V>} that depends on either
-     * {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}.
-     */
-    SYNTHETIC_MAP,
-
     /**
      * A synthetic binding for a multibound set that depends on the individual multibinding
      * {@link Provides @Provides} or {@link Produces @Produces} methods.
@@ -129,6 +124,9 @@
     /** A provision method on a component's {@linkplain Component#dependencies() dependency}. */
     COMPONENT_PROVISION,
 
+    /** An instance of a {@linkplain Component#dependencies() dependency}. */
+    COMPONENT_DEPENDENCY,
+
     /**
      * A subcomponent builder method on a component or subcomponent.
      */
@@ -185,6 +183,18 @@ boolean requiresModuleInstance() {
     return !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC);
   }
 
+  /**
+   * Returns {@code true} if {@link #bindingElement()} is present and is a method that returns a
+   * primitive type.
+   */
+  boolean contributesPrimitiveType() {
+    return bindingElement().isPresent()
+        && MoreElements.asExecutable(bindingElement().get())
+            .getReturnType()
+            .getKind()
+            .isPrimitive();
+  }
+
   /**
    * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
    */
@@ -285,10 +295,6 @@ final TypeMirror contributedType() {
 
     abstract B key(Key key);
 
-    abstract B explicitDependencies(Iterable<DependencyRequest> dependencies);
-
-    abstract B explicitDependencies(DependencyRequest... dependencies);
-
     abstract B nullableType(Optional<DeclaredType> nullableType);
 
     abstract B wrappedMapKey(Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey);
diff --git a/java/dagger/internal/codegen/DaggerElements.java b/java/dagger/internal/codegen/DaggerElements.java
index fe19903b9..afbb6b541 100644
--- a/java/dagger/internal/codegen/DaggerElements.java
+++ b/java/dagger/internal/codegen/DaggerElements.java
@@ -18,6 +18,7 @@
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.hasModifiers;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Lists.asList;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.stream.Collectors.toSet;
@@ -27,29 +28,44 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import java.io.Writer;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
+import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import java.util.function.Predicate;
+import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.Types;
 
-/**
- * Utilities for working with {@link Element} objects. Each is a candidate to move to {@link
- * MoreElements}.
- */
-final class DaggerElements {
+/** Extension of {@link Elements} that adds Dagger-specific methods. */
+final class DaggerElements implements Elements {
+
+  private final Elements elements;
+  private final Types types;
 
-  static ImmutableSet<ExecutableElement> getUnimplementedMethods(
-      TypeElement type, Types types, Elements elements) {
+  DaggerElements(Elements elements, Types types) {
+    this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
+  }
+
+  DaggerElements(ProcessingEnvironment processingEnv) {
+    this(processingEnv.getElementUtils(), processingEnv.getTypeUtils());
+  }
+
+  ImmutableSet<ExecutableElement> getUnimplementedMethods(TypeElement type) {
     return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
         .filter(hasModifiers(ABSTRACT))
         .toSet();
@@ -174,11 +190,88 @@ static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
    * Invokes {@link Elements#getTypeElement(CharSequence)}, throwing {@link TypeNotPresentException}
    * if it is not accessible in the current compilation.
    */
-  static TypeElement checkTypePresent(String typeName, Elements elements) {
+  TypeElement checkTypePresent(String typeName) {
     TypeElement type = elements.getTypeElement(typeName);
     if (type == null) {
       throw new TypeNotPresentException(typeName, null);
     }
     return type;
   }
+
+  @Override
+  public PackageElement getPackageElement(CharSequence name) {
+    return elements.getPackageElement(name);
+  }
+
+  @Override
+  public TypeElement getTypeElement(CharSequence name) {
+    return elements.getTypeElement(name);
+  }
+
+  @Override
+  public Map<? extends ExecutableElement, ? extends AnnotationValue> getElementValuesWithDefaults(
+      AnnotationMirror a) {
+    return elements.getElementValuesWithDefaults(a);
+  }
+
+  @Override
+  public String getDocComment(Element e) {
+    return elements.getDocComment(e);
+  }
+
+  @Override
+  public boolean isDeprecated(Element e) {
+    return elements.isDeprecated(e);
+  }
+
+  @Override
+  public Name getBinaryName(TypeElement type) {
+    return elements.getBinaryName(type);
+  }
+
+  @Override
+  public PackageElement getPackageOf(Element type) {
+    return elements.getPackageOf(type);
+  }
+
+  @Override
+  public List<? extends Element> getAllMembers(TypeElement type) {
+    return elements.getAllMembers(type);
+  }
+
+  @Override
+  public List<? extends AnnotationMirror> getAllAnnotationMirrors(Element e) {
+    return elements.getAllAnnotationMirrors(e);
+  }
+
+  @Override
+  public boolean hides(Element hider, Element hidden) {
+    return elements.hides(hider, hidden);
+  }
+
+  @Override
+  public boolean overrides(
+      ExecutableElement overrider, ExecutableElement overridden, TypeElement type) {
+    return elements.overrides(overrider, overridden, type);
+  }
+
+  @Override
+  public String getConstantExpression(Object value) {
+    return elements.getConstantExpression(value);
+  }
+
+  @Override
+  public void printElements(Writer w, Element... elements) {
+    this.elements.printElements(w, elements);
+  }
+
+  @Override
+  public Name getName(CharSequence cs) {
+    return elements.getName(cs);
+  }
+
+  @Override
+  public boolean isFunctionalInterface(TypeElement type) {
+    return elements.isFunctionalInterface(type);
+  }
 }
diff --git a/java/dagger/internal/codegen/DaggerTypes.java b/java/dagger/internal/codegen/DaggerTypes.java
index b000e1353..dc7b386ae 100644
--- a/java/dagger/internal/codegen/DaggerTypes.java
+++ b/java/dagger/internal/codegen/DaggerTypes.java
@@ -16,24 +16,224 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Iterables.getOnlyElement;
+
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import dagger.Lazy;
+import dagger.producers.Producer;
+import java.util.List;
 import java.util.Optional;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.inject.Provider;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.NoType;
+import javax.lang.model.type.NullType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-/**
- * Utilities for working with {@link TypeMirror} objects. Each is a candidate to move to {@link
- * MoreTypes}.
- */
-final class DaggerTypes {
+/** Extension of {@link Types} that adds Dagger-specific methods. */
+final class DaggerTypes implements Types {
+
+  private final Types types;
+  private final Elements elements;
+
+  DaggerTypes(Types types, Elements elements) {
+    this.types = checkNotNull(types);
+    this.elements = checkNotNull(elements);
+  }
+
+  DaggerTypes(ProcessingEnvironment processingEnv) {
+    this(processingEnv.getTypeUtils(), processingEnv.getElementUtils());
+  }
+
   /**
    * Returns the non-{@link Object} superclass of the type with the proper type parameters. An empty
    * {@link Optional} is returned if there is no non-{@link Object} superclass.
    */
-  static Optional<DeclaredType> nonObjectSuperclass(
-      Types types, Elements elements, DeclaredType type) {
+  Optional<DeclaredType> nonObjectSuperclass(DeclaredType type) {
     return Optional.ofNullable(MoreTypes.nonObjectSuperclass(types, elements, type).orNull());
   }
+
+  /**
+   * Returns {@code type}'s single type argument, if one exists, or {@link Object} if not.
+   *
+   * <p>For example, if {@code type} is {@code List<Number>} this will return {@code Number}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not a declared type or has more than one
+   *     type argument.
+   */
+  TypeMirror unwrapTypeOrObject(TypeMirror type) {
+    DeclaredType declaredType = MoreTypes.asDeclared(type);
+    TypeElement typeElement = MoreElements.asType(declaredType.asElement());
+    checkArgument(
+        !typeElement.getTypeParameters().isEmpty(),
+        "%s does not have a type parameter",
+        typeElement.getQualifiedName());
+    return getOnlyElement(
+        declaredType.getTypeArguments(),
+        elements.getTypeElement(Object.class.getCanonicalName()).asType());
+  }
+
+  /**
+   * Returns {@code type} wrapped in {@code wrappingClass}.
+   *
+   * <p>For example, if {@code type} is {@code List<Number>} and {@code wrappingClass} is {@code
+   * Set.class}, this will return {@code Set<List<Number>>}.
+   */
+  TypeMirror wrapType(TypeMirror type, Class<?> wrappingClass) {
+    return types.getDeclaredType(elements.getTypeElement(wrappingClass.getCanonicalName()), type);
+  }
+
+  /**
+   * Returns {@code type}'s single type argument wrapped in {@code wrappingClass}.
+   *
+   * <p>For example, if {@code type} is {@code List<Number>} and {@code wrappingClass} is {@code
+   * Set.class}, this will return {@code Set<Number>}.
+   *
+   * <p>If {@code type} has no type parameters, returns a {@link TypeMirror} for {@code
+   * wrappingClass} as a raw type.
+   *
+   * @throws IllegalArgumentException if {@code} has more than one type argument.
+   */
+  DeclaredType rewrapType(TypeMirror type, Class<?> wrappingClass) {
+    List<? extends TypeMirror> typeArguments = MoreTypes.asDeclared(type).getTypeArguments();
+    TypeElement wrappingType = elements.getTypeElement(wrappingClass.getCanonicalName());
+    switch (typeArguments.size()) {
+      case 0:
+        return types.getDeclaredType(wrappingType);
+      case 1:
+        return types.getDeclaredType(wrappingType, getOnlyElement(typeArguments));
+      default:
+        throw new IllegalArgumentException(type + " has more than 1 type argument");
+    }
+  }
+
+  /** Returns a type mirror for {@code Lazy<T>} given a type mirror for {@code T}. */
+  TypeMirror lazyOf(TypeMirror typeMirror) {
+    return wrapType(typeMirror, Lazy.class);
+  }
+
+  /** Returns a type mirror for {@code Provider<T>} given a type mirror for {@code T}. */
+  TypeMirror providerOf(TypeMirror typeMirror) {
+    return wrapType(typeMirror, Provider.class);
+  }
+
+  /** Returns a type mirror for {@code Producer<T>} given a type mirror for {@code T}. */
+  TypeMirror producerOf(TypeMirror typeMirror) {
+    return wrapType(typeMirror, Producer.class);
+  }
+
+  /** Returns a type mirror for {@code Provider<Lazy<T>>} given a type mirror for {@code T}. */
+  TypeMirror providerOfLazyOf(TypeMirror typeMirror) {
+    return providerOf(lazyOf(typeMirror));
+  }
+
+  // Implementation of Types methods, delegating to types.
+
+  @Override
+  public Element asElement(TypeMirror t) {
+    return types.asElement(t);
+  }
+
+  @Override
+  public boolean isSameType(TypeMirror t1, TypeMirror t2) {
+    return types.isSameType(t1, t2);
+  }
+
+  @Override
+  public boolean isSubtype(TypeMirror t1, TypeMirror t2) {
+    return types.isSubtype(t1, t2);
+  }
+
+  @Override
+  public boolean isAssignable(TypeMirror t1, TypeMirror t2) {
+    return types.isAssignable(t1, t2);
+  }
+
+  @Override
+  public boolean contains(TypeMirror t1, TypeMirror t2) {
+    return types.contains(t1, t2);
+  }
+
+  @Override
+  public boolean isSubsignature(ExecutableType m1, ExecutableType m2) {
+    return types.isSubsignature(m1, m2);
+  }
+
+  @Override
+  public List<? extends TypeMirror> directSupertypes(TypeMirror t) {
+    return types.directSupertypes(t);
+  }
+
+  @Override
+  public TypeMirror erasure(TypeMirror t) {
+    return types.erasure(t);
+  }
+
+  @Override
+  public TypeElement boxedClass(PrimitiveType p) {
+    return types.boxedClass(p);
+  }
+
+  @Override
+  public PrimitiveType unboxedType(TypeMirror t) {
+    return types.unboxedType(t);
+  }
+
+  @Override
+  public TypeMirror capture(TypeMirror t) {
+    return types.capture(t);
+  }
+
+  @Override
+  public PrimitiveType getPrimitiveType(TypeKind kind) {
+    return types.getPrimitiveType(kind);
+  }
+
+  @Override
+  public NullType getNullType() {
+    return types.getNullType();
+  }
+
+  @Override
+  public NoType getNoType(TypeKind kind) {
+    return types.getNoType(kind);
+  }
+
+  @Override
+  public ArrayType getArrayType(TypeMirror componentType) {
+    return types.getArrayType(componentType);
+  }
+
+  @Override
+  public WildcardType getWildcardType(TypeMirror extendsBound, TypeMirror superBound) {
+    return types.getWildcardType(extendsBound, superBound);
+  }
+
+  @Override
+  public DeclaredType getDeclaredType(TypeElement typeElem, TypeMirror... typeArgs) {
+    return types.getDeclaredType(typeElem, typeArgs);
+  }
+
+  @Override
+  public DeclaredType getDeclaredType(
+      DeclaredType containing, TypeElement typeElem, TypeMirror... typeArgs) {
+    return types.getDeclaredType(containing, typeElem, typeArgs);
+  }
+
+  @Override
+  public TypeMirror asMemberOf(DeclaredType containing, Element element) {
+    return types.asMemberOf(containing, element);
+  }
 }
diff --git a/java/dagger/internal/codegen/DelegateBindingExpression.java b/java/dagger/internal/codegen/DelegateBindingExpression.java
new file mode 100644
index 000000000..ad72e5a38
--- /dev/null
+++ b/java/dagger/internal/codegen/DelegateBindingExpression.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.Scope.reusableScope;
+
+import com.squareup.javapoet.ClassName;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/** A {@link BindingExpression} for {@code @Binds} methods. */
+final class DelegateBindingExpression extends BindingExpression {
+  private final ContributionBinding binding;
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final DaggerTypes types;
+  private final Elements elements;
+  private final BindsTypeChecker bindsTypeChecker;
+
+  private DelegateBindingExpression(
+      ResolvedBindings resolvedBindings,
+      ComponentBindingExpressions componentBindingExpressions,
+      DaggerTypes types,
+      Elements elements) {
+    super(resolvedBindings);
+    this.binding = checkNotNull(resolvedBindings.contributionBinding());
+    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+    this.types = checkNotNull(types);
+    this.elements = checkNotNull(elements);
+    this.bindsTypeChecker = new BindsTypeChecker(types, elements);
+  }
+
+  static BindingExpression create(
+      BindingGraph graph,
+      BindingExpression bindingExpression,
+      ComponentBindingExpressions componentBindingExpressions,
+      DaggerTypes types,
+      Elements elements) {
+    ResolvedBindings resolvedBindings = bindingExpression.resolvedBindings();
+    ContributionBinding binding = resolvedBindings.contributionBinding();
+    Binding delegateBinding =
+        graph
+            .resolvedBindings()
+            .get(getOnlyElement(binding.dependencies()).bindingKey())
+            .binding();
+    ScopeKind bindsScope = ScopeKind.get(binding, graph, elements);
+    ScopeKind delegateScope = ScopeKind.get(delegateBinding, graph, elements);
+    if (bindsScope.isSimilarOrWeakerScopeThan(delegateScope)) {
+      return new DelegateBindingExpression(
+          resolvedBindings, componentBindingExpressions, types, elements);
+    }
+    return bindingExpression;
+  }
+
+  @Override
+  Expression getDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    Expression delegateExpression =
+        componentBindingExpressions.getDependencyExpression(
+            getOnlyElement(binding.dependencies()).bindingKey(), requestKind, requestingClass);
+
+    TypeMirror contributedType = binding.contributedType();
+    switch (requestKind) {
+      case INSTANCE:
+        return instanceRequiresCast(delegateExpression, requestingClass)
+            ? delegateExpression.castTo(contributedType)
+            : delegateExpression;
+      default:
+        return castToRawTypeIfNecessary(
+            delegateExpression, requestKind.type(contributedType, types));
+    }
+  }
+
+  private boolean instanceRequiresCast(Expression delegateExpression, ClassName requestingClass) {
+    // delegateExpression.type() could be Object if expression is satisfied with a raw
+    // Provider's get() method.
+    return !bindsTypeChecker.isAssignable(
+        delegateExpression.type(), binding.contributedType(), binding.contributionType())
+        && isTypeAccessibleFrom(binding.contributedType(), requestingClass.packageName());
+  }
+
+  /**
+   * If {@code delegateExpression} can be assigned to {@code desiredType} safely, then {@code
+   * delegateExpression} is returned unchanged. If the {@code delegateExpression} is already a raw
+   * type, returns {@code delegateExpression} as well, as casting would have no effect. Otherwise,
+   * returns a {@link Expression#castTo(TypeMirror) casted} version of {@code delegateExpression}
+   * to the raw type of {@code desiredType}.
+   */
+  // TODO(ronshapiro): this probably can be generalized for usage in InjectionMethods
+  private Expression castToRawTypeIfNecessary(
+      Expression delegateExpression, TypeMirror desiredType) {
+    if (types.isAssignable(delegateExpression.type(), desiredType)) {
+      return delegateExpression;
+    }
+    return delegateExpression.castTo(types.erasure(desiredType));
+  }
+
+  private enum ScopeKind {
+    UNSCOPED,
+    RELEASABLE,
+    SINGLE_CHECK,
+    DOUBLE_CHECK,
+    ;
+
+    static ScopeKind get(Binding binding, BindingGraph graph, Elements elements) {
+      if (!binding.scope().isPresent()) {
+        return UNSCOPED;
+      }
+
+      Scope scope = binding.scope().get();
+      if (graph.scopesRequiringReleasableReferenceManagers().contains(scope)) {
+        return RELEASABLE;
+      }
+      return scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK;
+    }
+
+    boolean isSimilarOrWeakerScopeThan(ScopeKind other) {
+      return ordinal() <= other.ordinal();
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/DependencyRequest.java b/java/dagger/internal/codegen/DependencyRequest.java
index fb0420218..56b152b81 100644
--- a/java/dagger/internal/codegen/DependencyRequest.java
+++ b/java/dagger/internal/codegen/DependencyRequest.java
@@ -27,6 +27,7 @@
 import static dagger.internal.codegen.Optionals.firstPresent;
 import static dagger.internal.codegen.TypeNames.lazyOf;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
+import static dagger.internal.codegen.TypeNames.membersInjectorOf;
 import static dagger.internal.codegen.TypeNames.producedOf;
 import static dagger.internal.codegen.TypeNames.producerOf;
 import static dagger.internal.codegen.TypeNames.providerOf;
@@ -153,15 +154,35 @@ TypeName typeName(TypeName keyType) {
         case FUTURE:
           return listenableFutureOf(keyType);
 
+        case MEMBERS_INJECTOR:
+          return membersInjectorOf(keyType);
+
         default:
           throw new AssertionError(this);
       }
     }
+
+    /** Returns the type of a request of this kind for the given {@code type}. */
+    TypeMirror type(TypeMirror type, DaggerTypes types) {
+      switch (this) {
+        case INSTANCE:
+          return type;
+
+        case PROVIDER_OF_LAZY:
+          return types.wrapType(LAZY.type(type, types), Provider.class);
+
+        case FUTURE:
+          return types.wrapType(type, ListenableFuture.class);
+
+        default:
+          return types.wrapType(type, frameworkClass.get());
+      }
+    }
   }
 
   abstract Kind kind();
   abstract Key key();
-  
+
   BindingKey bindingKey() {
     switch (kind()) {
       case INSTANCE:
@@ -182,6 +203,17 @@ BindingKey bindingKey() {
   /** The element that declares this dependency request. Absent for synthetic requests. */
   abstract Optional<Element> requestElement();
 
+  /**
+   * Returns {@code true} if {@code requestElement}'s type is a primitive type.
+   *
+   * <p>Because the {@link #key()} of a {@link DependencyRequest} is {@linkplain
+   * Key.Factory#boxPrimitives(TypeMirror) boxed} to normalize it with other keys, this inspects the
+   * {@link #requestElement()} directly.
+   */
+  boolean requestsPrimitiveType() {
+    return requestElement().map(element -> element.asType().getKind().isPrimitive()).orElse(false);
+  }
+
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
 
@@ -325,27 +357,49 @@ DependencyRequest producerForImplicitMapBinding(Key mapOfFactoryKey) {
       return DependencyRequest.builder().kind(Kind.PRODUCER).key(mapOfFactoryKey).build();
     }
 
+    /**
+     * Creates synthetic dependency requests for each individual multibinding contribution in {@code
+     * multibindingContributions}.
+     */
+    ImmutableSet<DependencyRequest> forMultibindingContributions(
+        Key multibindingKey, Iterable<ContributionBinding> multibindingContributions) {
+      ImmutableSet.Builder<DependencyRequest> requests = ImmutableSet.builder();
+      for (ContributionBinding multibindingContribution : multibindingContributions) {
+        requests.add(forMultibindingContribution(multibindingKey, multibindingContribution));
+      }
+      return requests.build();
+    }
+
     /**
      * Creates a synthetic dependency request for one individual {@code multibindingContribution}.
      */
     private DependencyRequest forMultibindingContribution(
-        ContributionBinding multibindingContribution) {
+        Key multibindingKey, ContributionBinding multibindingContribution) {
       checkArgument(
           multibindingContribution.key().multibindingContributionIdentifier().isPresent(),
           "multibindingContribution's key must have a multibinding contribution identifier: %s",
           multibindingContribution);
       return DependencyRequest.builder()
-          .kind(multibindingContributionRequestKind(multibindingContribution))
+          .kind(multibindingContributionRequestKind(multibindingKey, multibindingContribution))
           .key(multibindingContribution.key())
           .build();
     }
 
-    private Kind multibindingContributionRequestKind(ContributionBinding multibindingContribution) {
+    // TODO(b/28555349): support PROVIDER_OF_LAZY here too
+    private static final ImmutableSet<Kind> WRAPPING_MAP_VALUE_FRAMEWORK_TYPES =
+        ImmutableSet.of(Kind.PROVIDER, Kind.PRODUCER);
+
+    private Kind multibindingContributionRequestKind(
+        Key multibindingKey, ContributionBinding multibindingContribution) {
       switch (multibindingContribution.contributionType()) {
         case MAP:
-          return multibindingContribution.bindingType().equals(BindingType.PRODUCTION)
-              ? Kind.PRODUCER
-              : Kind.PROVIDER;
+          MapType mapType = MapType.from(multibindingKey);
+          for (Kind kind : WRAPPING_MAP_VALUE_FRAMEWORK_TYPES) {
+            if (mapType.valuesAreTypeOf(kind.frameworkClass.get())) {
+              return kind;
+            }
+          }
+          // fall through
         case SET:
         case SET_VALUES:
           return Kind.INSTANCE;
@@ -357,19 +411,6 @@ private Kind multibindingContributionRequestKind(ContributionBinding multibindin
       }
     }
 
-    /**
-     * Creates synthetic dependency requests for each individual multibinding contribution in {@code
-     * multibindingContributions}.
-     */
-    ImmutableSet<DependencyRequest> forMultibindingContributions(
-        Iterable<ContributionBinding> multibindingContributions) {
-      ImmutableSet.Builder<DependencyRequest> requests = ImmutableSet.builder();
-      for (ContributionBinding multibindingContribution : multibindingContributions) {
-        requests.add(forMultibindingContribution(multibindingContribution));
-      }
-      return requests.build();
-    }
-
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
       return forRequiredVariable(variableElement, Optional.empty());
     }
diff --git a/java/dagger/internal/codegen/DependencyVariableNamer.java b/java/dagger/internal/codegen/DependencyVariableNamer.java
index b84d338db..161d5705f 100644
--- a/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -20,7 +20,6 @@
 
 import com.google.common.base.Ascii;
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Function;
 import dagger.Lazy;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -36,11 +35,10 @@
  * @since 2.0
  */
 //TODO(gak): develop the heuristics to get better names
-final class DependencyVariableNamer implements Function<DependencyRequest, String> {
+final class DependencyVariableNamer {
   private static final Pattern LAZY_PROVIDER_PATTERN = Pattern.compile("lazy(\\w+)Provider");
 
-  @Override
-  public String apply(DependencyRequest dependency) {
+  static String name(DependencyRequest dependency) {
     if (dependency.overriddenVariableName().isPresent()) {
       return dependency.overriddenVariableName().get();
     }
@@ -83,7 +81,7 @@ public String apply(DependencyRequest dependency) {
     }
   }
 
-  private String toLowerCamel(String name) {
+  private static String toLowerCamel(String name) {
     return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, name);
   }
 }
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 8749eded0..af084f6db 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -416,6 +416,24 @@ static String tooManyBindingMethodAnnotations(
         methodAnnotations.stream().map(Class::getCanonicalName).collect(joining(", ")));
   }
 
+  static String abstractModuleHasInstanceBindingMethods(ModuleDescriptor module) {
+    String methodAnnotations;
+    switch (module.kind()) {
+      case MODULE:
+        methodAnnotations = "@Provides";
+        break;
+      case PRODUCER_MODULE:
+        methodAnnotations = "@Provides or @Produces";
+        break;
+      default:
+        throw new AssertionError(module.kind());
+    }
+    return String.format(
+        "%s is abstract and has instance %s methods. Consider making the methods static or "
+            + "including a non-abstract subclass of the module instead.",
+        module.moduleElement(), methodAnnotations);
+  }
+
   static class ComponentBuilderMessages {
     static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
 
diff --git a/java/dagger/internal/codegen/Expression.java b/java/dagger/internal/codegen/Expression.java
new file mode 100644
index 000000000..0678cd7f4
--- /dev/null
+++ b/java/dagger/internal/codegen/Expression.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.CodeBlock;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Encapsulates a {@link CodeBlock} for an <a
+ * href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html">expression</a> and the
+ * {@link TypeMirror} that it represents from the perspective of the compiler. Consider the
+ * following example:
+ *
+ * <pre><code>
+ *   {@literal @SuppressWarnings("rawtypes")}
+ *   private Provider fooImplProvider = DoubleCheck.provider(FooImpl_Factory.create());
+ * </code></pre>
+ *
+ * <p>An {@code Expression} for {@code fooImplProvider.get()} would have a {@link #type()} of {@code
+ * java.lang.Object} and not {@code FooImpl}.
+ */
+final class Expression {
+  private final TypeMirror type;
+  private final CodeBlock codeBlock;
+
+  private Expression(TypeMirror type, CodeBlock codeBlock) {
+    this.type = type;
+    this.codeBlock = codeBlock;
+  }
+
+  /** Creates a new {@link Expression} with a {@link TypeMirror} and {@link CodeBlock}. */
+  static Expression create(TypeMirror type, CodeBlock expression) {
+    return new Expression(type, expression);
+  }
+
+  /** Returns a new expression that casts the current expression to {@code newType}. */
+  // TODO(ronshapiro): consider overloads that take a Types and Elements and only cast if necessary,
+  // or just embedding a Types/Elements instance in an Expression.
+  Expression castTo(TypeMirror newType) {
+    return Expression.create(newType, CodeBlock.of("($T) $L", newType, codeBlock));
+  }
+
+  /** The {@link TypeMirror type} to which the expression evaluates. */
+  TypeMirror type() {
+    return type;
+  }
+
+  /** The code of the expression. */
+  CodeBlock codeBlock() {
+    return codeBlock;
+  }
+
+  @Override
+  public String toString() {
+    return String.format("[%s] %s", type, codeBlock);
+  }
+}
diff --git a/java/dagger/internal/codegen/FactoryGenerator.java b/java/dagger/internal/codegen/FactoryGenerator.java
index da6784fda..8cfe3d889 100644
--- a/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/java/dagger/internal/codegen/FactoryGenerator.java
@@ -28,10 +28,9 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
-import static dagger.internal.codegen.Proxies.createProxy;
-import static dagger.internal.codegen.Proxies.shouldGenerateProxy;
+import static dagger.internal.codegen.MapKeys.mapKeyFactoryMethod;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
-import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.frameworkFieldUsages;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
@@ -41,7 +40,6 @@
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
-import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
@@ -56,17 +54,17 @@
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.Factory;
-import dagger.internal.MembersInjectors;
 import dagger.internal.Preconditions;
+import dagger.internal.codegen.InjectionMethods.InjectionSiteMethod;
+import dagger.internal.codegen.InjectionMethods.ProvisionMethod;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.util.Elements;
-import javax.tools.Diagnostic;
+import javax.lang.model.util.Types;
 
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
@@ -76,16 +74,18 @@
  * @since 2.0
  */
 final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
-
+  private final Types types;
   private final CompilerOptions compilerOptions;
   private final InjectValidator injectValidator;
 
   FactoryGenerator(
       Filer filer,
       Elements elements,
+      Types types,
       CompilerOptions compilerOptions,
       InjectValidator injectValidator) {
     super(filer, elements);
+    this.types = types;
     this.compilerOptions = compilerOptions;
     this.injectValidator = injectValidator;
   }
@@ -221,13 +221,9 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
       factoryBuilder.addMethod(constructorBuilder.get().build());
     }
 
-    List<CodeBlock> parameters = Lists.newArrayList();
-    for (DependencyRequest dependency : binding.explicitDependencies()) {
-      parameters.add(
-          frameworkTypeUsageStatement(
-              CodeBlock.of("$N", fields.get(dependency.bindingKey())), dependency.kind()));
-    }
-    CodeBlock parametersCodeBlock = makeParametersCodeBlock(parameters);
+    CodeBlock parametersCodeBlock =
+        makeParametersCodeBlock(
+            frameworkFieldUsages(binding.provisionDependencies(), fields).values());
 
     MethodSpec.Builder getMethodBuilder =
         methodBuilder("get")
@@ -236,36 +232,37 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             .addModifiers(PUBLIC);
 
     if (binding.bindingKind().equals(PROVISION)) {
-      CodeBlock.Builder providesMethodInvocationBuilder = CodeBlock.builder();
-      if (binding.requiresModuleInstance()) {
-        providesMethodInvocationBuilder.add("module");
-      } else {
-        providesMethodInvocationBuilder.add(
-            "$T", ClassName.get(binding.bindingTypeElement().get()));
-      }
-      providesMethodInvocationBuilder.add(
-          ".$L($L)", binding.bindingElement().get().getSimpleName(), parametersCodeBlock);
-      CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
-
-      if (binding.nullableType().isPresent()
-          || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)) {
-        if (binding.nullableType().isPresent()) {
-          getMethodBuilder.addAnnotation((ClassName) TypeName.get(binding.nullableType().get()));
-        }
-        getMethodBuilder.addStatement("return $L", providesMethodInvocation);
-      } else {
-        getMethodBuilder.addStatement("return $T.checkNotNull($L, $S)",
-            Preconditions.class,
-            providesMethodInvocation,
-            CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-      }
-    } else if (binding.membersInjectionRequest().isPresent()) {
+      // TODO(dpb): take advantage of the code in InjectionMethods so this doesn't have to be
+      // duplicated
+      binding
+          .nullableType()
+          .ifPresent(nullableType -> CodeBlocks.addAnnotation(getMethodBuilder, nullableType));
+      CodeBlock methodCall =
+          CodeBlock.of(
+              "$L.$L($L)",
+              binding.requiresModuleInstance()
+                  ? "module"
+                  : CodeBlock.of("$T", ClassName.get(binding.bindingTypeElement().get())),
+              binding.bindingElement().get().getSimpleName(),
+              parametersCodeBlock);
       getMethodBuilder.addStatement(
-          "return $T.injectMembers($N, new $T($L))",
-          MembersInjectors.class,
-          fields.get(binding.membersInjectionRequest().get().bindingKey()),
-          providedTypeName,
-          parametersCodeBlock);
+          "return $L",
+          binding.shouldCheckForNull(compilerOptions)
+              ? checkNotNullProvidesMethod(methodCall)
+              : methodCall);
+    } else if (!binding.injectionSites().isEmpty()) {
+      CodeBlock instance = CodeBlock.of("instance");
+      getMethodBuilder
+          .addStatement("$1T $2L = new $1T($3L)", providedTypeName, instance, parametersCodeBlock)
+          .addCode(
+              InjectionSiteMethod.invokeAll(
+                  binding.injectionSites(),
+                  generatedTypeName,
+                  instance,
+                  binding.key().type(),
+                  types,
+                  frameworkFieldUsages(binding.dependencies(), fields)::get))
+          .addStatement("return $L", instance);
     } else {
       getMethodBuilder.addStatement("return new $T($L)", providedTypeName, parametersCodeBlock);
     }
@@ -275,26 +272,23 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
       factoryBuilder.addMethod(createMethod.get());
     }
 
-    proxyMethodFor(binding).ifPresent(factoryBuilder::addMethod);
-
+    ProvisionMethod.create(binding).ifPresent(factoryBuilder::addMethod);
     gwtIncompatibleAnnotation(binding).ifPresent(factoryBuilder::addAnnotation);
+    mapKeyFactoryMethod(binding, types).ifPresent(factoryBuilder::addMethod);
 
     return Optional.of(factoryBuilder);
   }
 
   /**
-   * Returns a method to proxy access to the binding's {@link Binding#bindingElement()}, which
-   * behaves according to the description in {@link Proxies}. Use here is further restricted by
-   * whether or not members injection is required, since that is not yet implemented for proxy
-   * methods, but will be added.
+   * Returns {@code Preconditions.checkNotNull(providesMethodInvocation)} with a message suitable
+   * for {@code @Provides} methods.
    */
-  // TODO(gak): support accessibility proxies for types with injected members as well
-  private static Optional<MethodSpec> proxyMethodFor(ProvisionBinding binding) {
-    ExecutableElement executableElement = MoreElements.asExecutable(binding.bindingElement().get());
-    if (binding.membersInjectionRequest().isPresent() || !shouldGenerateProxy(executableElement)) {
-      return Optional.empty();
-    }
-    return Optional.of(createProxy(executableElement));
+  static CodeBlock checkNotNullProvidesMethod(CodeBlock providesMethodInvocation) {
+    return CodeBlock.of(
+        "$T.checkNotNull($L, $S)",
+        Preconditions.class,
+        providesMethodInvocation,
+        CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
   }
 
   @CanIgnoreReturnValue
@@ -307,7 +301,7 @@ private FieldSpec addConstructorParameterAndTypeField(
     factoryBuilder.addField(field);
     ParameterSpec parameter = ParameterSpec.builder(typeName, variableName).build();
     constructorBuilder.addParameter(parameter);
-    constructorBuilder.addCode("assert $1N != null; this.$2N = $1N;", parameter, field);
+    constructorBuilder.addCode("this.$N = $N;", field, parameter);
     return field;
   }
 }
diff --git a/java/dagger/internal/codegen/FrameworkDependency.java b/java/dagger/internal/codegen/FrameworkDependency.java
index 0cd593d6b..f5efe770e 100644
--- a/java/dagger/internal/codegen/FrameworkDependency.java
+++ b/java/dagger/internal/codegen/FrameworkDependency.java
@@ -51,6 +51,23 @@
   /** The binding type of the framework dependency. */
   abstract BindingType bindingType();
 
+  /** The dependency request kind that is equivalent to requesting the framework dependency. */
+  DependencyRequest.Kind dependencyRequestKind() {
+    switch (bindingType()) {
+      case PROVISION:
+        return DependencyRequest.Kind.PROVIDER;
+
+      case PRODUCTION:
+        return DependencyRequest.Kind.PRODUCER;
+
+      case MEMBERS_INJECTION:
+        return DependencyRequest.Kind.MEMBERS_INJECTOR;
+
+      default:
+        throw new AssertionError(bindingType());
+    }
+  }
+
   /** The framework class to use for these requests. */
   final Class<?> frameworkClass() {
     return bindingType().frameworkClass();
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
new file mode 100644
index 000000000..b78902e8b
--- /dev/null
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -0,0 +1,642 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
+import static dagger.internal.codegen.BindingType.PROVISION;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
+import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
+import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
+import static dagger.internal.codegen.TypeNames.producerOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static dagger.internal.codegen.Util.toImmutableList;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.internal.InstanceFactory;
+import dagger.internal.TypedReleasableReferenceManagerDecorator;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Optional;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * An object that can initialize a framework-type component field for a binding. An instance should
+ * be created for every field.
+ */
+final class FrameworkFieldInitializer {
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final ComponentRequirementFields componentRequirementFields;
+  // TODO(ronshapiro): add Binding.bindingKey() and use that instead of taking a ResolvedBindings
+  private final ResolvedBindings resolvedBindings;
+  private final CompilerOptions compilerOptions;
+  private final BindingGraph graph;
+  private final boolean isProducerFromProvider;
+  private final OptionalFactories optionalFactories;
+  private final ClassName componentName;
+
+  FrameworkFieldInitializer(
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions,
+      ComponentRequirementFields componentRequirementFields,
+      ResolvedBindings resolvedBindings,
+      CompilerOptions compilerOptions,
+      BindingGraph graph,
+      OptionalFactories optionalFactories,
+      ClassName componentName) {
+    this(
+        generatedComponentModel,
+        componentBindingExpressions,
+        componentRequirementFields,
+        resolvedBindings,
+        compilerOptions,
+        graph,
+        false,
+        optionalFactories,
+        componentName);
+  }
+
+  private FrameworkFieldInitializer(
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions,
+      ComponentRequirementFields componentRequirementFields,
+      ResolvedBindings resolvedBindings,
+      CompilerOptions compilerOptions,
+      BindingGraph graph,
+      boolean isProducerFromProvider,
+      OptionalFactories optionalFactories,
+      ClassName componentName) {
+    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+    this.componentRequirementFields = checkNotNull(componentRequirementFields);
+    this.resolvedBindings = checkNotNull(resolvedBindings);
+    this.compilerOptions = checkNotNull(compilerOptions);
+    this.graph = checkNotNull(graph);
+    this.optionalFactories = checkNotNull(optionalFactories);
+    this.componentName = checkNotNull(componentName);
+    this.isProducerFromProvider = isProducerFromProvider;
+  }
+
+  /** Returns the expression to use to initialize the field. */
+  CodeBlock getFieldInitialization() {
+    if (isProducerFromProvider) {
+      return FrameworkType.PROVIDER.to(
+          DependencyRequest.Kind.PRODUCER,
+          componentBindingExpressions
+              .getDependencyExpression(
+                  FrameworkDependency.create(resolvedBindings.bindingKey(), PROVISION),
+                  componentName)
+              .codeBlock());
+    }
+
+    switch (resolvedBindings.bindingKey().kind()) {
+      case CONTRIBUTION:
+        return contributionBindingInitialization();
+      case MEMBERS_INJECTION:
+        return membersInjectionBindingInitialization();
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private CodeBlock contributionBindingInitialization() {
+    ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
+    switch (contributionBinding.factoryCreationStrategy()) {
+      case DELEGATE:
+        CodeBlock delegatingCodeBlock =
+            CodeBlock.of(
+                "($T) $L",
+                contributionBinding.bindingType().frameworkClass(),
+                getDependencyExpression(
+                    getOnlyElement(contributionBinding.frameworkDependencies())));
+        return generatedComponentModel.decorateForScope(
+            delegatingCodeBlock, contributionBinding.scope());
+      case SINGLETON_INSTANCE:
+        checkState(contributionBinding.scope().isPresent());
+        // fall through
+      case CLASS_CONSTRUCTOR:
+        return factoryForContributionBindingInitialization(contributionBinding);
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private CodeBlock membersInjectionBindingInitialization() {
+    MembersInjectionBinding membersInjectionBinding =
+        resolvedBindings.membersInjectionBinding().get();
+    return CodeBlock.of(
+        "$T.create($L)",
+        membersInjectorNameForType(membersInjectionBinding.membersInjectedType()),
+        makeParametersCodeBlock(getBindingDependencyExpressions(membersInjectionBinding)));
+  }
+
+  private CodeBlock factoryForContributionBindingInitialization(ContributionBinding binding) {
+    TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
+    switch (binding.bindingKind()) {
+      case COMPONENT:
+        // This bindingKeyTypeName type parameter can be removed when we drop java 7 source support
+        return CodeBlock.of("$T.<$T>create(this)", INSTANCE_FACTORY, bindingKeyTypeName);
+
+      case COMPONENT_DEPENDENCY:
+        return CodeBlock.of(
+            "$T.create($L)",
+            INSTANCE_FACTORY,
+            componentRequirementFields.getExpressionDuringInitialization(
+                ComponentRequirement.forDependency(binding.key().type()), componentName));
+
+      case COMPONENT_PROVISION:
+        {
+          TypeElement dependencyType = dependencyTypeForBinding(binding);
+          String dependencyVariable = simpleVariableName(dependencyType);
+          String componentMethod = binding.bindingElement().get().getSimpleName().toString();
+          // TODO(sameb): The Provider.get() throws a very vague NPE.  The stack trace doesn't
+          // help to figure out what the method or return type is.  If we include a string
+          // of the return type or method name in the error message, that can defeat obfuscation.
+          // We can easily include the raw type (no generics) + annotation type (no values),
+          // using .class & String.format -- but that wouldn't be the whole story.
+          // What should we do?
+          CodeBlock invocation =
+              ComponentProvisionBindingExpression.maybeCheckForNull(
+                  (ProvisionBinding) binding,
+                  compilerOptions,
+                  CodeBlock.of("$L.$L()", dependencyVariable, componentMethod));
+          ClassName dependencyClassName = ClassName.get(dependencyType);
+          String factoryName =
+              dependencyClassName.toString().replace('.', '_') + "_" + componentMethod;
+          MethodSpec.Builder getMethod =
+              methodBuilder("get")
+                  .addAnnotation(Override.class)
+                  .addModifiers(PUBLIC)
+                  .returns(bindingKeyTypeName)
+                  .addStatement("return $L", invocation);
+          if (binding.nullableType().isPresent()) {
+            getMethod.addAnnotation(
+                ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
+          }
+          generatedComponentModel.addType(
+              TypeSpec.classBuilder(factoryName)
+                  .addSuperinterface(providerOf(bindingKeyTypeName))
+                  .addModifiers(PRIVATE, STATIC)
+                  .addField(dependencyClassName, dependencyVariable, PRIVATE, FINAL)
+                  .addMethod(
+                      constructorBuilder()
+                          .addParameter(dependencyClassName, dependencyVariable)
+                          .addStatement("this.$1L = $1L", dependencyVariable)
+                          .build())
+                  .addMethod(getMethod.build())
+                  .build());
+          return CodeBlock.of(
+              "new $L($L)",
+              factoryName,
+              componentRequirementFields.getExpressionDuringInitialization(
+                  ComponentRequirement.forDependency(dependencyType.asType()), componentName));
+        }
+
+      case SUBCOMPONENT_BUILDER:
+        String subcomponentName =
+            generatedComponentModel.getSubcomponentName(
+                graph
+                    .componentDescriptor()
+                    .subcomponentsByBuilderType()
+                    .get(MoreTypes.asTypeElement(binding.key().type())));
+        return CodeBlock.of(
+            "$L",
+            anonymousClassBuilder("")
+                .superclass(providerOf(bindingKeyTypeName))
+                .addMethod(
+                    methodBuilder("get")
+                        .addAnnotation(Override.class)
+                        .addModifiers(PUBLIC)
+                        .returns(bindingKeyTypeName)
+                        .addStatement("return new $LBuilder()", subcomponentName)
+                        .build())
+                .build());
+
+      case BUILDER_BINDING:
+        return CodeBlock.of(
+            "$T.$L($L)",
+            InstanceFactory.class,
+            binding.nullableType().isPresent() ? "createNullable" : "create",
+            componentRequirementFields.getExpressionDuringInitialization(
+                ComponentRequirement.forBinding(binding), componentName));
+
+      case INJECTION:
+      case PROVISION:
+        {
+          List<CodeBlock> arguments =
+              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
+          if (binding.requiresModuleInstance()) {
+            arguments.add(
+                componentRequirementFields.getExpressionDuringInitialization(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
+                    componentName));
+          }
+          arguments.addAll(getBindingDependencyExpressions(binding));
+
+          CodeBlock factoryCreate =
+              CodeBlock.of(
+                  "$T.create($L)",
+                  generatedClassNameForBinding(binding),
+                  makeParametersCodeBlock(arguments));
+
+          // If scoping a parameterized factory for an @Inject class, Java 7 cannot always infer the
+          // type properly, so cast to a raw framework type before scoping.
+          if (binding.bindingKind().equals(INJECTION)
+              && binding.unresolved().isPresent()
+              && binding.scope().isPresent()) {
+            factoryCreate =
+                CodeBlock.of("($T) $L", binding.bindingType().frameworkClass(), factoryCreate);
+          }
+          return generatedComponentModel.decorateForScope(factoryCreate, binding.scope());
+        }
+
+      case COMPONENT_PRODUCTION:
+        {
+          TypeElement dependencyType = dependencyTypeForBinding(binding);
+          FieldSpec dependencyField =
+              FieldSpec.builder(
+                      ClassName.get(dependencyType),
+                      simpleVariableName(dependencyType),
+                      PRIVATE,
+                      FINAL)
+                  .initializer(
+                      componentRequirementFields.getExpressionDuringInitialization(
+                          ComponentRequirement.forDependency(dependencyType.asType()),
+                          componentName))
+                  .build();
+          return CodeBlock.of(
+              "$L",
+              anonymousClassBuilder("")
+                  .superclass(producerOf(bindingKeyTypeName))
+                  .addField(dependencyField)
+                  .addMethod(
+                      methodBuilder("get")
+                          .addAnnotation(Override.class)
+                          .addModifiers(PUBLIC)
+                          .returns(listenableFutureOf(bindingKeyTypeName))
+                          .addStatement(
+                              "return $N.$L()",
+                              dependencyField,
+                              binding.bindingElement().get().getSimpleName())
+                          .build())
+                  .build());
+        }
+
+      case PRODUCTION:
+        {
+          List<CodeBlock> arguments =
+              Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
+          if (binding.requiresModuleInstance()) {
+            arguments.add(
+                componentRequirementFields.getExpressionDuringInitialization(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
+                    componentName));
+          }
+          arguments.addAll(getBindingDependencyExpressions(binding));
+
+          return CodeBlock.of(
+              "new $T($L)",
+              generatedClassNameForBinding(binding),
+              makeParametersCodeBlock(arguments));
+        }
+
+      case SYNTHETIC_MULTIBOUND_SET:
+        return factoryForSetMultibindingInitialization(binding);
+
+      case SYNTHETIC_MULTIBOUND_MAP:
+        return factoryForMapMultibindingInitialization(binding);
+
+      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
+        return factoryForSyntheticReleasableReferenceManagerBindingInitialization(binding);
+
+      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
+        return factoryForSyntheticSetOfReleasableReferenceManagersInitialization(binding);
+
+      case SYNTHETIC_OPTIONAL_BINDING:
+        return factoryForSyntheticOptionalBindingInitialization(binding);
+
+      default:
+        throw new AssertionError(binding);
+    }
+  }
+
+  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
+    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
+  }
+
+  private CodeBlock factoryForSetMultibindingInitialization(ContributionBinding binding) {
+    CodeBlock.Builder builder = CodeBlock.builder().add("$T.", setFactoryClassName(binding));
+    boolean useRawTypes = useRawType();
+    if (!useRawTypes) {
+      SetType setType = SetType.from(binding.key());
+      builder.add(
+          "<$T>",
+          setType.elementsAreTypeOf(Produced.class)
+              ? setType.unwrappedElementType(Produced.class)
+              : setType.elementType());
+    }
+    int individualProviders = 0;
+    int setProviders = 0;
+    CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
+    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
+      ContributionType contributionType =
+          graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
+      String methodName;
+      String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
+      switch (contributionType) {
+        case SET:
+          individualProviders++;
+          methodName = "add" + methodNameSuffix;
+          break;
+        case SET_VALUES:
+          setProviders++;
+          methodName = "addCollection" + methodNameSuffix;
+          break;
+        default:
+          throw new AssertionError(frameworkDependency + " is not a set multibinding");
+      }
+
+      builderMethodCalls.add(
+          ".$L($L)",
+          methodName,
+          potentiallyCast(
+              useRawTypes,
+              frameworkDependency.frameworkClass(),
+              getDependencyExpression(frameworkDependency)));
+    }
+    builder.add("builder($L, $L)", individualProviders, setProviders);
+    builder.add(builderMethodCalls.build());
+    return builder.add(".build()").build();
+  }
+
+  private CodeBlock factoryForMapMultibindingInitialization(ContributionBinding binding) {
+    ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
+
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+    MapType mapType = MapType.from(binding.key().type());
+    CodeBlock.Builder builderCall = CodeBlock.builder().add("$T.", mapFactoryClassName(binding));
+    boolean useRawTypes = useRawType();
+    if (!useRawTypes) {
+      // TODO(ronshapiro): either inline this into mapFactoryClassName, or add a
+      // mapType.unwrappedValueType() method that doesn't require a framework type
+      TypeMirror valueType = mapType.valueType();
+      for (Class<?> frameworkClass :
+          ImmutableSet.of(Provider.class, Producer.class, Produced.class)) {
+        if (mapType.valuesAreTypeOf(frameworkClass)) {
+          valueType = mapType.unwrappedValueType(frameworkClass);
+          break;
+        }
+      }
+      builderCall.add("<$T, $T>", mapType.keyType(), valueType);
+    }
+
+    if (binding.bindingType().equals(BindingType.PROVISION)) {
+      builderCall.add("builder($L)", frameworkDependencies.size());
+    } else {
+      builderCall.add("builder()");
+    }
+    codeBlocks.add(builderCall.build());
+
+    for (FrameworkDependency frameworkDependency : frameworkDependencies) {
+      BindingKey bindingKey = frameworkDependency.bindingKey();
+      ContributionBinding contributionBinding =
+          graph.resolvedBindings().get(bindingKey).contributionBinding();
+      CodeBlock value =
+          potentiallyCast(
+              useRawTypes,
+              frameworkDependency.frameworkClass(),
+              getDependencyExpression(frameworkDependency));
+      codeBlocks.add(
+          CodeBlock.of(
+              ".put($L, $L)", getMapKeyExpression(contributionBinding, componentName), value));
+    }
+    codeBlocks.add(CodeBlock.of(".build()"));
+
+    return CodeBlocks.concat(codeBlocks.build());
+  }
+
+  // TODO(ronshapiro): Use functionality from Expression
+  private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, CodeBlock notCasted) {
+    if (!shouldCast) {
+      return notCasted;
+    }
+    return CodeBlock.of("($T) $L", classToCast, notCasted);
+  }
+
+  private boolean useRawType() {
+    Optional<String> bindingPackage = resolvedBindings.binding().bindingPackage();
+    return bindingPackage.isPresent() && !bindingPackage.get().equals(componentName.packageName());
+  }
+
+  /**
+   * Initializes the factory for a {@link
+   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} binding.
+   *
+   * <p>The {@code get()} method just returns the component field with the {@link
+   * dagger.internal.ReferenceReleasingProviderManager} object.
+   */
+  private CodeBlock factoryForSyntheticReleasableReferenceManagerBindingInitialization(
+      ContributionBinding binding) {
+    // The scope is the value of the @ForReleasableReferences annotation.
+    Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
+
+    CodeBlock managerExpression;
+    if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
+      /* The key's type is TypedReleasableReferenceManager<M>, so return
+       * new TypedReleasableReferenceManager(field, metadata). */
+      TypeMirror metadataType =
+          MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
+      managerExpression =
+          typedReleasableReferenceManagerDecoratorExpression(
+              generatedComponentModel.getReferenceReleasingProviderManagerExpression(scope),
+              scope.releasableReferencesMetadata(metadataType).get());
+    } else {
+      // The key's type is ReleasableReferenceManager, so return the field as is.
+      managerExpression =
+          generatedComponentModel.getReferenceReleasingProviderManagerExpression(scope);
+    }
+
+    TypeName keyType = TypeName.get(binding.key().type());
+    return CodeBlock.of(
+        "$L",
+        anonymousClassBuilder("")
+            .addSuperinterface(providerOf(keyType))
+            .addMethod(
+                methodBuilder("get")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(keyType)
+                    .addCode("return $L;", managerExpression)
+                    .build())
+            .build());
+  }
+
+  /**
+   * Initializes the factory for a {@link
+   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} binding.
+   *
+   * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
+   * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
+   * include managers for all reference-releasing scopes whose metadata type is {@code M}.
+   */
+  private CodeBlock factoryForSyntheticSetOfReleasableReferenceManagersInitialization(
+      ContributionBinding binding) {
+    Key key = binding.key();
+    SetType keyType = SetType.from(key);
+    ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
+    for (Scope scope : graph.scopesRequiringReleasableReferenceManagers()) {
+      CodeBlock releasableReferenceManagerExpression =
+          generatedComponentModel.getReferenceReleasingProviderManagerExpression(scope);
+
+      if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
+        managerExpressions.add(releasableReferenceManagerExpression);
+      } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
+        TypeMirror metadataType =
+            keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
+        Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
+        if (metadata.isPresent()) {
+          managerExpressions.add(
+              typedReleasableReferenceManagerDecoratorExpression(
+                  releasableReferenceManagerExpression, metadata.get()));
+        }
+      } else {
+        throw new IllegalArgumentException("inappropriate key: " + binding);
+      }
+    }
+    TypeName keyTypeName = TypeName.get(key.type());
+    return CodeBlock.of(
+        "$L",
+        anonymousClassBuilder("")
+            .addSuperinterface(providerOf(keyTypeName))
+            .addMethod(
+                methodBuilder("get")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(keyTypeName)
+                    .addCode(
+                        "return new $T($T.asList($L));",
+                        HashSet.class,
+                        Arrays.class,
+                        makeParametersCodeBlock(managerExpressions.build()))
+                    .build())
+            .build());
+  }
+
+  /**
+   * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
+   * decorates the {@code managerExpression} to supply {@code metadata}.
+   */
+  private CodeBlock typedReleasableReferenceManagerDecoratorExpression(
+      CodeBlock managerExpression, AnnotationMirror metadata) {
+    return CodeBlock.of(
+        "new $T<$T>($L, $L)",
+        TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
+        metadata.getAnnotationType(),
+        managerExpression,
+        new AnnotationExpression(metadata).getAnnotationInstanceExpression());
+  }
+
+  private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
+    checkArgument(
+        MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
+    return Scope.scope(
+        MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
+  }
+
+  /**
+   * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
+   * binding.
+   */
+  private CodeBlock factoryForSyntheticOptionalBindingInitialization(ContributionBinding binding) {
+    if (binding.explicitDependencies().isEmpty()) {
+      verify(
+          binding.bindingType().equals(BindingType.PROVISION),
+          "Absent optional bindings should be provisions: %s",
+          binding);
+      return optionalFactories.absentOptionalProvider(binding);
+    } else {
+      return optionalFactories.presentOptionalFactory(
+          binding, getDependencyExpression(getOnlyElement(binding.frameworkDependencies())));
+    }
+  }
+
+  /** Returns a list of code blocks for referencing all of the given binding's dependencies. */
+  private ImmutableList<CodeBlock> getBindingDependencyExpressions(Binding binding) {
+    ImmutableList<FrameworkDependency> dependencies = binding.frameworkDependencies();
+    return dependencies.stream().map(this::getDependencyExpression).collect(toImmutableList());
+  }
+
+  /** Returns a code block referencing the given dependency. */
+  private CodeBlock getDependencyExpression(FrameworkDependency frameworkDependency) {
+    return componentBindingExpressions
+        .getDependencyExpression(frameworkDependency, componentName)
+        .codeBlock();
+  }
+
+  FrameworkFieldInitializer forProducerFromProvider() {
+    return new FrameworkFieldInitializer(
+        generatedComponentModel,
+        componentBindingExpressions,
+        componentRequirementFields,
+        resolvedBindings,
+        compilerOptions,
+        graph,
+        true,
+        optionalFactories,
+        componentName);
+  }
+}
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
new file mode 100644
index 000000000..faec0dc16
--- /dev/null
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -0,0 +1,249 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import dagger.internal.DelegateFactory;
+import java.util.Optional;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/** A binding expression that uses an instance of a {@link FrameworkType}. */
+final class FrameworkInstanceBindingExpression extends BindingExpression {
+  private final Optional<FieldSpec> fieldSpec;
+  private final GeneratedComponentModel generatedComponentModel;
+  private final MemberSelect memberSelect;
+  private final FrameworkType frameworkType;
+  private final FrameworkFieldInitializer fieldInitializer;
+  private final DaggerTypes types;
+  private final Elements elements;
+  private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
+
+  /** Returns a binding expression for a binding. */
+  static FrameworkInstanceBindingExpression create(
+      ResolvedBindings resolvedBindings,
+      Optional<FieldSpec> fieldSpec,
+      GeneratedComponentModel generatedComponentModel,
+      MemberSelect memberSelect,
+      FrameworkFieldInitializer frameworkFieldInitializer,
+      DaggerTypes types,
+      Elements elements) {
+    return new FrameworkInstanceBindingExpression(
+        resolvedBindings,
+        fieldSpec,
+        generatedComponentModel,
+        memberSelect,
+        resolvedBindings.bindingType().frameworkType(),
+        frameworkFieldInitializer,
+        types,
+        elements);
+  }
+
+  private FrameworkInstanceBindingExpression(
+      ResolvedBindings resolvedBindings,
+      Optional<FieldSpec> fieldSpec,
+      GeneratedComponentModel generatedComponentModel,
+      MemberSelect memberSelect,
+      FrameworkType frameworkType,
+      FrameworkFieldInitializer fieldInitializer,
+      DaggerTypes types,
+      Elements elements) {
+    super(resolvedBindings);
+    this.generatedComponentModel = generatedComponentModel;
+    this.memberSelect = memberSelect;
+    this.fieldSpec = fieldSpec;
+    this.frameworkType = frameworkType;
+    this.fieldInitializer = fieldInitializer;
+    this.types = types;
+    this.elements = elements;
+  }
+
+  FrameworkInstanceBindingExpression producerFromProvider(
+      FieldSpec fieldSpec, ClassName componentName) {
+    checkState(frameworkType.equals(FrameworkType.PROVIDER));
+    return new FrameworkInstanceBindingExpression(
+        resolvedBindings(),
+        Optional.of(fieldSpec),
+        generatedComponentModel,
+        MemberSelect.localField(componentName, fieldSpec.name),
+        FrameworkType.PRODUCER,
+        fieldInitializer.forProducerFromProvider(),
+        types,
+        elements);
+  }
+
+  /**
+   * The expression for the framework instance for this binding. If the instance comes from a
+   * component field, it will be {@link GeneratedComponentModel#addInitialization(CodeBlock)
+   * initialized} and {@link GeneratedComponentModel#addField(FieldSpec) added} to the component the
+   * first time this method is invoked.
+   */
+  @Override
+  Expression getDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    maybeInitializeField();
+    TypeMirror expressionType =
+        isTypeAccessibleFrom(instanceType(), requestingClass.packageName())
+                || isInlinedFactoryCreation()
+            ? types.wrapType(instanceType(), resolvedBindings().frameworkClass())
+            : rawFrameworkType();
+
+    return frameworkType.to(
+        requestKind,
+        Expression.create(expressionType, memberSelect.getExpressionFor(requestingClass)),
+        types);
+  }
+
+  /**
+   * The instance type {@code T} of this {@code FrameworkType<T>}. For {@link
+   * MembersInjectionBinding}s, this is the {@linkplain Key#type() key type}; for {@link
+   * ContributionBinding}s, this the {@link ContributionBinding#contributedType()}.
+   */
+  private TypeMirror instanceType() {
+    return resolvedBindings()
+        .membersInjectionBinding()
+        .map(binding -> binding.key().type())
+        .orElseGet(() -> resolvedBindings().contributionBinding().contributedType());
+  }
+
+  /**
+   * Returns {@code true} if a factory is created inline each time it is requested. For example, in
+   * the initialization {@code this.fooProvider = Foo_Factory.create(Bar_Factory.create());}, {@code
+   * Bar_Factory} is considered to be inline.
+   *
+   * <p>This is used in {@link #getDependencyExpression(Kind, ClassName)} when determining the type
+   * of a factory. Normally if the {@link #instanceType()} is not accessible from the component, the
+   * type of the expression will be a raw {@link javax.inject.Provider}. However, if the factory is
+   * created inline, even if contributed type is not accessible, javac will still be able to
+   * determine the type that is returned from the {@code Foo_Factory.create()} method.
+   */
+  private boolean isInlinedFactoryCreation() {
+    return memberSelect.staticMember();
+  }
+
+  private DeclaredType rawFrameworkType() {
+    return types.getDeclaredType(
+        elements.getTypeElement(resolvedBindings().frameworkClass().getCanonicalName()));
+  }
+
+  /**
+   * Returns the name of the binding's underlying field.
+   *
+   * @throws UnsupportedOperationException if no field exists
+   */
+  // TODO(ronshapiro): remove this in favor of $N in a CodeBlock
+  private String fieldName() {
+    checkHasField();
+    return fieldSpec.get().name;
+  }
+
+  /**
+   * Sets the initialization state for the binding's underlying field. Only valid for field types.
+   *
+   * @throws UnsupportedOperationException if no field exists
+   */
+  private void setFieldInitializationState(InitializationState fieldInitializationState) {
+    checkHasField();
+    checkArgument(this.fieldInitializationState.compareTo(fieldInitializationState) < 0);
+    this.fieldInitializationState = fieldInitializationState;
+  }
+
+  private void checkHasField() {
+    if (!fieldSpec.isPresent()) {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  // Adds our field and initialization of our field to the component.
+  // TODO(user): Move this to the field initializer class
+  private void maybeInitializeField() {
+    if (!fieldSpec.isPresent()) {
+      return;
+    }
+    switch (fieldInitializationState) {
+      case UNINITIALIZED:
+        // Change our state in case we are recursively invoked via initializeBindingExpression
+        setFieldInitializationState(InitializationState.INITIALIZING);
+        CodeBlock.Builder codeBuilder = CodeBlock.builder();
+        CodeBlock initCode =
+            CodeBlock.of(
+                "this.$L = $L;",
+                fieldName(),
+                checkNotNull(fieldInitializer.getFieldInitialization()));
+
+        if (fieldInitializationState == InitializationState.DELEGATED) {
+          // If we were recursively invoked, set the delegate factory as part of our initialization
+          String delegateFactoryVariable = fieldName() + "Delegate";
+          codeBuilder
+              .add("$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, fieldName())
+              .add(initCode)
+              .add("$L.setDelegatedProvider($L);", delegateFactoryVariable, fieldName())
+              .build();
+        } else {
+          codeBuilder.add(initCode);
+        }
+        generatedComponentModel.addInitialization(codeBuilder.build());
+        generatedComponentModel.addField(fieldSpec.get());
+
+        setFieldInitializationState(InitializationState.INITIALIZED);
+        break;
+
+      case INITIALIZING:
+        // We were recursively invoked, so create a delegate factory instead
+        generatedComponentModel.addInitialization(
+            CodeBlock.of("this.$L = new $T<>();", fieldName(), DELEGATE_FACTORY));
+        setFieldInitializationState(InitializationState.DELEGATED);
+        break;
+
+      case DELEGATED:
+      case INITIALIZED:
+        break;
+      default:
+        throw new AssertionError("Unhandled initialization state: " + fieldInitializationState);
+    }
+  }
+
+  /** Initialization state for a factory field. */
+  private enum InitializationState {
+    /** The field is {@code null}. */
+    UNINITIALIZED,
+
+    /**
+     * The field's dependencies are being set up. If the field is needed in this state, use a {@link
+     * DelegateFactory}.
+     */
+    INITIALIZING,
+
+    /**
+     * The field's dependencies are being set up, but the field can be used because it has already
+     * been set to a {@link DelegateFactory}.
+     */
+    DELEGATED,
+
+    /** The field is set to an undelegated factory. */
+    INITIALIZED;
+  }
+}
diff --git a/java/dagger/internal/codegen/FrameworkType.java b/java/dagger/internal/codegen/FrameworkType.java
index 15cb4fccf..31baa1251 100644
--- a/java/dagger/internal/codegen/FrameworkType.java
+++ b/java/dagger/internal/codegen/FrameworkType.java
@@ -21,7 +21,9 @@
 import static dagger.internal.codegen.DependencyRequest.Kind.INSTANCE;
 
 import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.CodeBlock;
+import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.internal.DoubleCheck;
 import dagger.internal.ProviderOfLazy;
@@ -29,6 +31,7 @@
 import dagger.producers.Producer;
 import dagger.producers.internal.Producers;
 import javax.inject.Provider;
+import javax.lang.model.type.TypeMirror;
 
 /** One of the core types initialized as fields in a generated component. */
 enum FrameworkType {
@@ -63,6 +66,30 @@ CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
               String.format("Cannot request a %s from a %s", requestKind, this));
       }
     }
+
+    @Override
+    Expression to(DependencyRequest.Kind requestKind, Expression from, DaggerTypes types) {
+      CodeBlock codeBlock = to(requestKind, from.codeBlock());
+      switch (requestKind) {
+        case INSTANCE:
+          return Expression.create(types.unwrapTypeOrObject(from.type()), codeBlock);
+
+        case PROVIDER:
+          return from;
+
+        case PROVIDER_OF_LAZY:
+          TypeMirror lazyType = types.rewrapType(from.type(), Lazy.class);
+          return Expression.create(types.wrapType(lazyType, Provider.class), codeBlock);
+
+        case FUTURE:
+          return Expression.create(
+              types.rewrapType(from.type(), ListenableFuture.class), codeBlock);
+
+        default:
+          return Expression.create(
+              types.rewrapType(from.type(), requestKind.frameworkClass.get()), codeBlock);
+      }
+    }
   },
 
   /** A {@link Producer}. */
@@ -81,6 +108,23 @@ CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
               String.format("Cannot request a %s from a %s", requestKind, this));
       }
     }
+
+    @Override
+    Expression to(DependencyRequest.Kind requestKind, Expression from, DaggerTypes types) {
+      switch (requestKind) {
+        case FUTURE:
+          return Expression.create(
+              types.rewrapType(from.type(), ListenableFuture.class),
+              to(requestKind, from.codeBlock()));
+
+        case PRODUCER:
+          return from;
+
+        default:
+          throw new IllegalArgumentException(
+              String.format("Cannot request a %s from a %s", requestKind, this));
+      }
+    }
   },
 
   /** A {@link MembersInjector}. */
@@ -96,21 +140,45 @@ CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
               String.format("Cannot request a %s from a %s", requestKind, this));
       }
     }
+
+    @Override
+    Expression to(DependencyRequest.Kind requestKind, Expression from, DaggerTypes types) {
+      switch (requestKind) {
+        case MEMBERS_INJECTOR:
+          return from;
+
+        default:
+          throw new IllegalArgumentException(
+              String.format("Cannot request a %s from a %s", requestKind, this));
+      }
+    }
   },
   ;
 
   /**
-   * Returns an expression that evaluates to a requested object given an expression that evaluates
-   * to an instance of this framework type.
+   * Returns a {@link CodeBlock} that evaluates to a requested object given an expression that
+   * evaluates to an instance of this framework type.
    *
    * @param requestKind the kind of {@link DependencyRequest} that the returned expression can
    *     satisfy
-   * @param from an expression that evaluates to an instance of this framework type
+   * @param from a {@link CodeBlock} that evaluates to an instance of this framework type
    * @throws IllegalArgumentException if a valid expression cannot be generated for {@code
    *     requestKind}
    */
   abstract CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from);
 
+  /**
+   * Returns an {@link Expression} that evaluates to a requested object given an expression that
+   * evaluates to an instance of this framework type.
+   *
+   * @param requestKind the kind of {@link DependencyRequest} that the returned expression can
+   *     satisfy
+   * @param from an expression that evaluates to an instance of this framework type
+   * @throws IllegalArgumentException if a valid expression cannot be generated for {@code
+   *     requestKind}
+   */
+  abstract Expression to(DependencyRequest.Kind requestKind, Expression from, DaggerTypes types);
+
   @Override
   public String toString() {
     return UPPER_UNDERSCORE.to(UPPER_CAMEL, super.toString());
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
new file mode 100644
index 000000000..54d95187f
--- /dev/null
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+import java.util.Optional;
+
+/** The model of the component being generated. */
+interface GeneratedComponentModel {
+
+  /** Adds the given field to the component. */
+  void addField(FieldSpec fieldSpec);
+
+  /** Adds the given method to the component. */
+  void addMethod(MethodSpec methodSpec);
+
+  /** Adds the given code block to the initialize methods of the component. */
+  void addInitialization(CodeBlock codeBlock);
+
+  /** Adds the given type to the component. */
+  void addType(TypeSpec typeSpec);
+
+  // TODO(user): add getUniqueFieldName(String name).
+
+  /** Returns a unique method name for the component based on the given name. */
+  String getUniqueMethodName(String name);
+
+  /** Returns the corresponding subcomponent name for the given subcomponent descriptor. */
+  String getSubcomponentName(ComponentDescriptor subcomponentDescriptor);
+
+  /**
+   * Returns the {@code private} members injection method that injects objects with the {@code key}.
+   */
+  MethodSpec getMembersInjectionMethod(Key key);
+
+  /**
+   * Maybe wraps the given creation code block in single/double check or reference releasing
+   * providers.
+   */
+  CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope);
+
+  /**
+   * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
+   * object for a scope.
+   */
+  CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope);
+}
diff --git a/java/dagger/internal/codegen/InjectionMethods.java b/java/dagger/internal/codegen/InjectionMethods.java
new file mode 100644
index 000000000..6eff4dd54
--- /dev/null
+++ b/java/dagger/internal/codegen/InjectionMethods.java
@@ -0,0 +1,517 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
+import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
+import static dagger.internal.codegen.Accessibility.isRawTypePubliclyAccessible;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toConcatenatedCodeBlock;
+import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.TypeNames.rawTypeName;
+import static dagger.internal.codegen.Util.toImmutableList;
+import static java.util.stream.Collectors.toList;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.VOID;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeVariableName;
+import dagger.internal.codegen.DependencyRequest.Kind;
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Function;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Parameterizable;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+
+/**
+ * Injection methods are static methods that implement provision and/or injection in one step:
+ *
+ * <ul>
+ *   <li>methods that invoke {@code @Inject} constructors and do members injection if necessary
+ *   <li>methods that call {@code @Provides} module methods
+ *   <li>methods that perform members injection
+ * </ul>
+ */
+// TODO(ronshapiro): add examples for each class of injection method
+final class InjectionMethods {
+  /**
+   * A static method that returns an object from a {@code @Provides} method or an {@code @Inject}ed
+   * constructor. Its parameters match the dependency requests for constructor and members
+   * injection.
+   *
+   * <p>For {@code @Provides} methods named "foo", the method name is "proxyFoo". If the
+   * {@code @Provides} method and its raw parameter types are publicly accessible, no method is
+   * necessary and this method returns {@link Optional#empty()}.
+   *
+   * <p>TODO(ronshapiro): At the moment non-static {@code @Provides} methods are not supported.
+   *
+   * <p>Example:
+   *
+   * <pre><code>
+   * abstract class FooModule {
+   *   {@literal @Provides} static Foo provideFoo(Bar bar, Baz baz) { … }
+   * }
+   *
+   * public static proxyProvideFoo(Bar bar, Baz baz) { … }
+   * </code></pre>
+   *
+   * <p>For {@code @Inject}ed constructors, the method name is "newFoo". If the constructor and its
+   * raw parameter types are publicly accessible, no method is necessary and this method returns
+   * {@code Optional#empty()}.
+   *
+   * <p>Example:
+   *
+   * <pre><code>
+   * class Foo {
+   *   {@literal @Inject} Foo(Bar bar) {}
+   * }
+   *
+   * public static Foo newFoo(Bar bar) { … }
+   * </code></pre>
+   */
+  static final class ProvisionMethod {
+
+    /**
+     * Returns a method that invokes the binding's {@linkplain ProvisionBinding#bindingElement()
+     * constructor} and injects the instance's members, if necessary. If {@link
+     * #shouldCreateInjectionMethod(ProvisionBinding) no method is necessary}, then {@link
+     * Optional#empty()} is returned.
+     */
+    static Optional<MethodSpec> create(ProvisionBinding binding) {
+      if (!shouldCreateInjectionMethod(binding)) {
+        return Optional.empty();
+      }
+      ExecutableElement element = MoreElements.asExecutable(binding.bindingElement().get());
+      switch (element.getKind()) {
+        case CONSTRUCTOR:
+          return Optional.of(constructorProxy(element));
+        case METHOD:
+          return Optional.of(
+              methodProxy(element, methodName(element), ReceiverAccessibility.IGNORE));
+        default:
+          throw new AssertionError(element);
+      }
+    }
+
+    /**
+     * Invokes the injection method for {@code binding}, with the dependencies transformed with the
+     * {@code dependencyUsage} function.
+     */
+    static CodeBlock invoke(
+        ProvisionBinding binding,
+        Function<DependencyRequest, CodeBlock> dependencyUsage,
+        ClassName requestingClass,
+        Optional<CodeBlock> moduleReference) {
+      ImmutableList.Builder<CodeBlock> arguments = ImmutableList.builder();
+      moduleReference.ifPresent(arguments::add);
+      arguments.addAll(
+          injectionMethodArguments(
+              binding.provisionDependencies(), dependencyUsage, requestingClass));
+      return callInjectionMethod(
+          create(binding).get().name,
+          arguments.build(),
+          generatedClassNameForBinding(binding),
+          requestingClass);
+    }
+
+    private static MethodSpec constructorProxy(ExecutableElement constructor) {
+      UniqueNameSet names = new UniqueNameSet();
+      TypeElement enclosingType = MoreElements.asType(constructor.getEnclosingElement());
+      MethodSpec.Builder method =
+          methodBuilder(methodName(constructor))
+              .returns(TypeName.get(enclosingType.asType()))
+              .addModifiers(PUBLIC, STATIC);
+
+      copyTypeParameters(enclosingType, method);
+      copyThrows(constructor, method);
+
+      return method
+          .addStatement(
+              "return new $T($L)", enclosingType, copyParameters(constructor, method, names))
+          .build();
+    }
+
+    /**
+     * Returns {@code true} if injecting an instance of {@code binding} from {@code callingPackage}
+     * requires the use of an injection method.
+     */
+    static boolean requiresInjectionMethod(ProvisionBinding binding, String callingPackage) {
+      ExecutableElement method = MoreElements.asExecutable(binding.bindingElement().get());
+      return !binding.injectionSites().isEmpty()
+          || !isElementAccessibleFrom(method, callingPackage)
+          || method
+              .getParameters()
+              .stream()
+              .map(VariableElement::asType)
+              .anyMatch(type -> !isRawTypeAccessible(type, callingPackage));
+    }
+
+    private static boolean shouldCreateInjectionMethod(ProvisionBinding binding) {
+      return requiresInjectionMethod(binding, "dagger.should.never.exist");
+    }
+
+    /**
+     * Returns the name of the {@code static} method that wraps {@code method}. For methods that are
+     * associated with {@code @Inject} constructors, the method will also inject all {@link
+     * InjectionSite}s.
+     */
+    private static String methodName(ExecutableElement method) {
+      switch (method.getKind()) {
+        case CONSTRUCTOR:
+          return "new" + method.getEnclosingElement().getSimpleName();
+        case METHOD:
+          return "proxy" + LOWER_CAMEL.to(UPPER_CAMEL, method.getSimpleName().toString());
+        default:
+          throw new AssertionError(method);
+      }
+    }
+  }
+
+  /**
+   * A static method that injects one member of an instance of a type. Its first parameter is an
+   * instance of the type to be injected. The remaining parameters match the dependency requests for
+   * the injection site.
+   *
+   * <p>Example:
+   *
+   * <pre><code>
+   * class Foo {
+   *   {@literal @Inject} Bar bar;
+   *   {@literal @Inject} void setThings(Baz baz, Qux qux) {}
+   * }
+   *
+   * public static injectBar(Foo instance, Bar bar) { … }
+   * public static injectSetThings(Foo instance, Baz baz, Qux qux) { … }
+   * </code></pre>
+   */
+  static final class InjectionSiteMethod {
+    /**
+     * When a type has an inaccessible member from a supertype (e.g. an @Inject field in a parent
+     * that's in a different package), a method in the supertype's package must be generated to give
+     * the subclass's members injector a way to inject it. Each potentially inaccessible member
+     * receives its own method, as the subclass may need to inject them in a different order from
+     * the parent class.
+     */
+    static MethodSpec create(InjectionSite injectionSite) {
+      String methodName = methodName(injectionSite);
+      switch (injectionSite.kind()) {
+        case METHOD:
+          return methodProxy(
+              MoreElements.asExecutable(injectionSite.element()),
+              methodName,
+              ReceiverAccessibility.CAST_IF_NOT_PUBLIC);
+        case FIELD:
+          return fieldProxy(MoreElements.asVariable(injectionSite.element()), methodName);
+        default:
+          throw new AssertionError(injectionSite);
+      }
+    }
+
+    /**
+     * Invokes each of the injection methods for {@code injectionSites}, with the dependencies
+     * transformed using the {@code dependencyUsage} function.
+     *
+     * @param instanceType the type of the {@code instance} parameter
+     */
+    static CodeBlock invokeAll(
+        ImmutableSet<InjectionSite> injectionSites,
+        ClassName generatedTypeName,
+        CodeBlock instanceCodeBlock,
+        TypeMirror instanceType,
+        Types types,
+        Function<DependencyRequest, CodeBlock> dependencyUsage) {
+      return injectionSites
+          .stream()
+          .map(
+              injectionSite -> {
+                TypeMirror injectSiteType =
+                    types.erasure(injectionSite.element().getEnclosingElement().asType());
+
+                // If instance has been declared as Object because it is not accessible from the
+                // component, but the injectionSite is in a supertype of instanceType that is
+                // publicly accessible, the InjectionSiteMethod will request the actual type and not
+                // Object as the first parameter. If so, cast to the supertype which is accessible
+                // from within generatedTypeName
+                CodeBlock maybeCastedInstance =
+                    !types.isSubtype(instanceType, injectSiteType)
+                            && isTypeAccessibleFrom(injectSiteType, generatedTypeName.packageName())
+                        ? CodeBlock.of("($T) $L", injectSiteType, instanceCodeBlock)
+                        : instanceCodeBlock;
+                return CodeBlock.of(
+                    "$L;",
+                    invoke(injectionSite, generatedTypeName, maybeCastedInstance, dependencyUsage));
+              })
+          .collect(toConcatenatedCodeBlock());
+    }
+
+    /**
+     * Invokes the injection method for {@code injectionSite}, with the dependencies transformed
+     * using the {@code dependencyUsage} function.
+     */
+    private static CodeBlock invoke(
+        InjectionSite injectionSite,
+        ClassName generatedTypeName,
+        CodeBlock instanceCodeBlock,
+        Function<DependencyRequest, CodeBlock> dependencyUsage) {
+      List<CodeBlock> arguments = new ArrayList<>();
+      arguments.add(instanceCodeBlock);
+      if (!injectionSite.dependencies().isEmpty()) {
+        arguments.addAll(
+            injectionSite
+                .dependencies()
+                .stream()
+                .map(dependencyUsage)
+                .collect(toList()));
+      }
+      return callInjectionMethod(
+          create(injectionSite).name,
+          arguments,
+          membersInjectorNameForType(
+              MoreElements.asType(injectionSite.element().getEnclosingElement())),
+          generatedTypeName);
+    }
+
+    /*
+     * TODO(ronshapiro): this isn't perfect, as collisions could still exist. Some examples:
+     *
+     *  - @Inject void members() {} will generate a method that conflicts with the instance
+     *    method `injectMembers(T)`
+     *  - Adding the index could conflict with another member:
+     *      @Inject void a(Object o) {}
+     *      @Inject void a(String s) {}
+     *      @Inject void a1(String s) {}
+     *
+     *    Here, Method a(String) will add the suffix "1", which will conflict with the method
+     *    generated for a1(String)
+     *  - Members named "members" or "methods" could also conflict with the {@code static} injection
+     *    method.
+     */
+    private static String methodName(InjectionSite injectionSite) {
+      int index = injectionSite.indexAmongAtInjectMembersWithSameSimpleName();
+      String indexString = index == 0 ? "" : String.valueOf(index + 1);
+      return "inject"
+          + LOWER_CAMEL.to(UPPER_CAMEL, injectionSite.element().getSimpleName().toString())
+          + indexString;
+    }
+  }
+
+  /**
+   * Returns an argument list suitable for calling an injection method. Down-casts any arguments
+   * that are {@code Object} (or {@code Provider<Object>}) at the caller but not the method.
+   *
+   * @param dependencies the dependencies used by the method
+   * @param dependencyUsage function to apply on each of {@code dependencies} before casting
+   * @param requestingClass the class calling the injection method
+   */
+  private static ImmutableList<CodeBlock> injectionMethodArguments(
+      ImmutableSet<DependencyRequest> dependencies,
+      Function<DependencyRequest, CodeBlock> dependencyUsage,
+      ClassName requestingClass) {
+    return dependencies.stream()
+        .map(dep -> injectionMethodArgument(dep, dependencyUsage.apply(dep), requestingClass))
+        .collect(toImmutableList());
+  }
+
+  private static CodeBlock injectionMethodArgument(
+      DependencyRequest dependency, CodeBlock argument, ClassName generatedTypeName) {
+    TypeMirror keyType = dependency.key().type();
+    CodeBlock.Builder codeBlock = CodeBlock.builder();
+    if (!isRawTypeAccessible(keyType, generatedTypeName.packageName())
+        && isTypeAccessibleFrom(keyType, generatedTypeName.packageName())) {
+      if (!dependency.kind().equals(Kind.INSTANCE)) {
+        TypeName usageTypeName = accessibleType(dependency);
+        codeBlock.add("($T) ($T)", usageTypeName, rawTypeName(usageTypeName));
+      } else if (dependency.requestElement().get().asType().getKind().equals(TypeKind.TYPEVAR)) {
+        codeBlock.add("($T)", keyType);
+      }
+    }
+    return codeBlock.add(argument).build();
+  }
+
+  /**
+   * Returns the parameter type for {@code dependency}. If the raw type is not accessible, returns
+   * {@link Object}.
+   */
+  private static TypeName accessibleType(DependencyRequest dependency) {
+    TypeName typeName = dependency.kind().typeName(accessibleType(dependency.key().type()));
+    return dependency.requestsPrimitiveType() ? typeName.unbox() : typeName;
+  }
+
+  /**
+   * Returns the accessible type for {@code type}. If the raw type is not accessible, returns {@link
+   * Object}.
+   */
+  private static TypeName accessibleType(TypeMirror type) {
+    return isRawTypePubliclyAccessible(type) ? TypeName.get(type) : TypeName.OBJECT;
+  }
+
+  private static CodeBlock callInjectionMethod(
+      String methodName,
+      List<CodeBlock> arguments,
+      ClassName enclosingClass,
+      ClassName requestingClass) {
+    CodeBlock.Builder invocation = CodeBlock.builder();
+    if (!enclosingClass.equals(requestingClass)) {
+      invocation.add("$T.", enclosingClass);
+    }
+    return invocation.add("$L($L)", methodName, makeParametersCodeBlock(arguments)).build();
+  }
+
+  private enum ReceiverAccessibility {
+    CAST_IF_NOT_PUBLIC {
+      @Override
+      TypeName parameterType(TypeMirror type) {
+        return accessibleType(type);
+      }
+
+      @Override
+      CodeBlock potentiallyCast(CodeBlock instance, TypeMirror instanceType) {
+        return instanceWithPotentialCast(instance, instanceType);
+      }
+    },
+    IGNORE {
+      @Override
+      TypeName parameterType(TypeMirror type) {
+        return TypeName.get(type);
+      }
+
+      @Override
+      CodeBlock potentiallyCast(CodeBlock instance, TypeMirror instanceType) {
+        return instance;
+      }
+    },
+    ;
+
+    abstract TypeName parameterType(TypeMirror type);
+    abstract CodeBlock potentiallyCast(CodeBlock instance, TypeMirror instanceType);
+  }
+
+  private static CodeBlock instanceWithPotentialCast(CodeBlock instance, TypeMirror instanceType) {
+    return isRawTypePubliclyAccessible(instanceType)
+        ? instance
+        : CodeBlock.of("(($T) $L)", instanceType, instance);
+  }
+
+  private static MethodSpec methodProxy(
+      ExecutableElement method, String methodName, ReceiverAccessibility receiverAccessibility) {
+    TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
+    MethodSpec.Builder methodBuilder = methodBuilder(methodName).addModifiers(PUBLIC, STATIC);
+
+    UniqueNameSet nameSet = new UniqueNameSet();
+    if (!method.getModifiers().contains(STATIC)) {
+      methodBuilder.addParameter(
+          receiverAccessibility.parameterType(enclosingType.asType()),
+          nameSet.getUniqueName("instance"));
+    }
+    CodeBlock arguments = copyParameters(method, methodBuilder, nameSet);
+    if (!method.getReturnType().getKind().equals(VOID)) {
+      methodBuilder.returns(TypeName.get(method.getReturnType()));
+      getNullableType(method)
+          .ifPresent(nullableType -> CodeBlocks.addAnnotation(methodBuilder, nullableType));
+      methodBuilder.addCode("return ");
+    }
+    if (method.getModifiers().contains(STATIC)) {
+      methodBuilder.addCode("$T", rawTypeName(TypeName.get(enclosingType.asType())));
+    } else {
+      copyTypeParameters(enclosingType, methodBuilder);
+      // "instance" is guaranteed b/c it was the first name into the UniqueNameSet
+      methodBuilder.addCode(
+          receiverAccessibility.potentiallyCast(CodeBlock.of("instance"), enclosingType.asType()));
+    }
+    copyTypeParameters(method, methodBuilder);
+    copyThrows(method, methodBuilder);
+
+    methodBuilder.addCode(".$N($L);", method.getSimpleName(), arguments);
+    return methodBuilder.build();
+  }
+
+  private static MethodSpec fieldProxy(VariableElement field, String methodName) {
+    TypeElement enclosingType = MoreElements.asType(field.getEnclosingElement());
+    MethodSpec.Builder methodBuilder = methodBuilder(methodName).addModifiers(PUBLIC, STATIC);
+    copyTypeParameters(enclosingType, methodBuilder);
+
+    UniqueNameSet nameSet = new UniqueNameSet();
+    String instanceName = nameSet.getUniqueName("instance");
+    methodBuilder.addParameter(accessibleType(enclosingType.asType()), instanceName);
+    return methodBuilder
+        .addCode(
+            "$L.$L = $L;",
+            instanceWithPotentialCast(CodeBlock.of(instanceName), enclosingType.asType()),
+            field.getSimpleName(),
+            copyParameter(field, methodBuilder, nameSet))
+        .build();
+  }
+
+  private static void copyThrows(ExecutableElement method, MethodSpec.Builder methodBuilder) {
+    for (TypeMirror thrownType : method.getThrownTypes()) {
+      methodBuilder.addException(TypeName.get(thrownType));
+    }
+  }
+
+  private static CodeBlock copyParameters(
+      ExecutableElement method, MethodSpec.Builder methodBuilder, UniqueNameSet nameSet) {
+    ImmutableList.Builder<CodeBlock> argumentsBuilder = ImmutableList.builder();
+    for (VariableElement parameter : method.getParameters()) {
+      argumentsBuilder.add(copyParameter(parameter, methodBuilder, nameSet));
+    }
+    methodBuilder.varargs(method.isVarArgs());
+    return makeParametersCodeBlock(argumentsBuilder.build());
+  }
+
+  private static CodeBlock copyParameter(
+      VariableElement element, MethodSpec.Builder methodBuilder, UniqueNameSet nameSet) {
+    TypeMirror elementType = element.asType();
+    boolean useObject = !isRawTypePubliclyAccessible(elementType);
+    TypeName typeName = useObject ? TypeName.OBJECT : TypeName.get(elementType);
+    String name = nameSet.getUniqueName(element.getSimpleName().toString());
+    ParameterSpec parameter =
+        ParameterSpec.builder(typeName, name).build();
+    methodBuilder.addParameter(parameter);
+    return useObject
+        ? CodeBlock.of("($T) $N", elementType, parameter)
+        : CodeBlock.of("$N", parameter);
+  }
+
+  private static void copyTypeParameters(
+      Parameterizable parameterizable, MethodSpec.Builder methodBuilder) {
+    for (TypeParameterElement typeParameterElement : parameterizable.getTypeParameters()) {
+      methodBuilder.addTypeVariable(TypeVariableName.get(typeParameterElement));
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/Key.java b/java/dagger/internal/codegen/Key.java
index 50d12bcc4..9deac5626 100644
--- a/java/dagger/internal/codegen/Key.java
+++ b/java/dagger/internal/codegen/Key.java
@@ -25,7 +25,7 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
-import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
+import static dagger.internal.codegen.MapKeys.mapKeyType;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
 import static dagger.internal.codegen.Optionals.firstPresent;
@@ -460,11 +460,10 @@ private TypeMirror bindingMethodKeyType(
         case SET:
           return setOf(returnType);
         case MAP:
-          if (frameworkType.isPresent()) {
-            return mapOfFrameworkType(mapKeyType(method), frameworkType.get(), returnType);
-          } else {
-            return mapOf(mapKeyType(method), returnType);
-          }
+          TypeMirror mapKeyType = mapKeyType(getMapKey(method).get(), types);
+          return frameworkType.isPresent()
+              ? mapOfFrameworkType(mapKeyType, frameworkType.get(), returnType)
+              : mapOf(mapKeyType, returnType);
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(SetType.isSet(returnType));
@@ -488,13 +487,6 @@ Key forDelegateBinding(
           : delegateDeclaration.key();
     }
 
-    private TypeMirror mapKeyType(ExecutableElement method) {
-      AnnotationMirror mapKeyAnnotation = getMapKey(method).get();
-      return MapKeys.unwrapValue(mapKeyAnnotation).isPresent()
-          ? getUnwrappedMapKeyType(mapKeyAnnotation.getAnnotationType(), types)
-          : mapKeyAnnotation.getAnnotationType();
-    }
-
     private Key forMethod(ExecutableElement method, TypeMirror keyType) {
       return forQualifiedType(getQualifier(method), keyType);
     }
@@ -503,7 +495,8 @@ Key forInjectConstructorWithResolvedType(TypeMirror type) {
       return builder(type).build();
     }
 
-    Key forComponent(TypeMirror type) {
+    // TODO(ronshapiro): Remove these conveniences which are simple wrappers around Key.Builder
+    Key forType(TypeMirror type) {
       return builder(type).build();
     }
 
@@ -545,12 +538,15 @@ Key forProductionComponentMonitor() {
     }
 
     /**
-     * Optionally extract a {@link Key} for the underlying provision binding(s) if such a
-     * valid key can be inferred from the given key.  Specifically, if the key represents a
-     * {@link Map}{@code <K, V>}, a key of {@code Map<K, Provider<V>>} will be returned.
+     * Optionally extract a {@link Key} for the underlying provision binding(s) if such a valid key
+     * can be inferred from the given key. Specifically, if the key represents a {@link Map}{@code
+     * <K, V>} or {@code Map<K, Producer<V>>}, a key of {@code Map<K, Provider<V>>} will be
+     * returned.
      */
     Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
-      return wrapMapKey(possibleMapKey, Provider.class);
+      return firstPresent(
+          rewrapMapKey(possibleMapKey, Produced.class, Provider.class),
+          wrapMapKey(possibleMapKey, Provider.class));
     }
 
     /**
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
new file mode 100644
index 000000000..2b422709b
--- /dev/null
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
+import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.MapBuilder;
+import java.util.Collections;
+import java.util.Map;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/** A {@link BindingExpression} for multibound maps. */
+final class MapBindingExpression extends SimpleInvocationBindingExpression {
+  /** Maximum number of key-value pairs that can be passed to ImmutableMap.of(K, V, K, V, ...). */
+  private static final int MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS = 5;
+
+  private final ProvisionBinding binding;
+  private final ImmutableMap<DependencyRequest, ContributionBinding> dependencies;
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final Elements elements;
+
+  MapBindingExpression(
+      ProvisionBinding binding,
+      BindingGraph graph,
+      ComponentBindingExpressions componentBindingExpressions,
+      BindingExpression delegate,
+      DaggerTypes types,
+      Elements elements) {
+    super(delegate, types);
+    ContributionBinding.Kind bindingKind = binding.bindingKind();
+    checkArgument(bindingKind.equals(SYNTHETIC_MULTIBOUND_MAP), bindingKind);
+    this.binding = binding;
+    this.componentBindingExpressions = componentBindingExpressions;
+    this.elements = elements;
+    this.dependencies =
+        Maps.toMap(
+            binding.dependencies(),
+            dep -> graph.resolvedBindings().get(dep.bindingKey()).contributionBinding());
+  }
+
+  @Override
+  Expression getInstanceDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    return Expression.create(binding.key().type(), mapExpression(requestingClass));
+  }
+
+  private CodeBlock mapExpression(ClassName requestingClass) {
+    // TODO(ronshapiro): We should also make an ImmutableMap version of MapFactory
+    boolean isImmutableMapAvailable = isImmutableMapAvailable();
+    // TODO(ronshapiro, gak): Use Maps.immutableEnumMap() if it's available?
+    if (isImmutableMapAvailable && dependencies.size() <= MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS) {
+      return CodeBlock.builder()
+          .add("$T.", ImmutableMap.class)
+          .add(maybeTypeParameters(requestingClass))
+          .add(
+              "of($L)",
+              dependencies
+                  .keySet()
+                  .stream()
+                  .map(dependency -> keyAndValueExpression(dependency, requestingClass))
+                  .collect(toParametersCodeBlock()))
+          .build();
+    }
+    switch (dependencies.size()) {
+      case 0:
+        return collectionsStaticFactoryInvocation(requestingClass, CodeBlock.of("emptyMap()"));
+      case 1:
+        return collectionsStaticFactoryInvocation(
+            requestingClass,
+            CodeBlock.of(
+                "singletonMap($L)",
+                keyAndValueExpression(getOnlyElement(dependencies.keySet()), requestingClass)));
+      default:
+        CodeBlock.Builder instantiation = CodeBlock.builder();
+        instantiation
+            .add("$T.", isImmutableMapAvailable ? ImmutableMap.class : MapBuilder.class)
+            .add(maybeTypeParameters(requestingClass));
+        if (isImmutableMapAvailable) {
+          // TODO(ronshapiro): builderWithExpectedSize
+          instantiation.add("builder()");
+        } else {
+          instantiation.add("newMapBuilder($L)", dependencies.size());
+        }
+        for (DependencyRequest dependency : dependencies.keySet()) {
+          instantiation.add(".put($L)", keyAndValueExpression(dependency, requestingClass));
+        }
+        return instantiation.add(".build()").build();
+    }
+  }
+
+  private CodeBlock keyAndValueExpression(DependencyRequest dependency, ClassName requestingClass) {
+    return CodeBlock.of(
+        "$L, $L",
+        getMapKeyExpression(dependencies.get(dependency), requestingClass),
+        componentBindingExpressions
+            .getDependencyExpression(dependency, requestingClass)
+            .codeBlock());
+  }
+
+  private CodeBlock collectionsStaticFactoryInvocation(
+      ClassName requestingClass, CodeBlock methodInvocation) {
+    return CodeBlock.builder()
+        .add("$T.", Collections.class)
+        .add(maybeTypeParameters(requestingClass))
+        .add(methodInvocation)
+        .build();
+  }
+
+  private CodeBlock maybeTypeParameters(ClassName requestingClass) {
+    TypeMirror bindingKeyType = binding.key().type();
+    MapType mapType = MapType.from(binding.key());
+    return isTypeAccessibleFrom(bindingKeyType, requestingClass.packageName())
+        ? CodeBlock.of("<$T, $T>", mapType.keyType(), mapType.valueType())
+        : CodeBlock.of("");
+  }
+
+  private boolean isImmutableMapAvailable() {
+    return elements.getTypeElement(ImmutableMap.class.getCanonicalName()) != null;
+  }
+
+  @Override
+  protected CodeBlock explicitTypeParameter(ClassName requestingClass) {
+    if (isImmutableMapAvailable()) {
+      TypeMirror keyType = binding.key().type();
+      return CodeBlock.of(
+          "<$T>",
+          isTypeAccessibleFrom(keyType, requestingClass.packageName()) ? keyType : Map.class);
+    }
+    return CodeBlock.of("");
+  }
+}
diff --git a/java/dagger/internal/codegen/MapKeyAccessibility.java b/java/dagger/internal/codegen/MapKeyAccessibility.java
new file mode 100644
index 000000000..fe52e3bb3
--- /dev/null
+++ b/java/dagger/internal/codegen/MapKeyAccessibility.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.function.Predicate;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleAnnotationValueVisitor8;
+
+final class MapKeyAccessibility extends SimpleAnnotationValueVisitor8<Boolean, Void> {
+  private final Predicate<TypeMirror> accessibilityChecker;
+
+  private MapKeyAccessibility(Predicate<TypeMirror> accessibilityChecker) {
+    this.accessibilityChecker = accessibilityChecker;
+  }
+
+  @Override
+  public Boolean visitAnnotation(AnnotationMirror annotation, Void aVoid) {
+    // The annotation type is not checked, as the generated code will refer to the @AutoAnnotation
+    // generated type which is always public
+    return visitValues(annotation.getElementValues().values());
+  }
+
+  @Override
+  public Boolean visitArray(List<? extends AnnotationValue> values, Void aVoid) {
+    return visitValues(values);
+  }
+
+  private boolean visitValues(Collection<? extends AnnotationValue> values) {
+    return values.stream().allMatch(value -> value.accept(this, null));
+  }
+
+  @Override
+  public Boolean visitEnumConstant(VariableElement enumConstant, Void aVoid) {
+    return accessibilityChecker.test(enumConstant.getEnclosingElement().asType());
+  }
+
+  @Override
+  public Boolean visitType(TypeMirror type, Void aVoid) {
+    return accessibilityChecker.test(type);
+  }
+
+  @Override
+  protected Boolean defaultAction(Object o, Void aVoid) {
+    return true;
+  }
+
+  static boolean isMapKeyAccessibleFrom(AnnotationMirror annotation, String accessingPackage) {
+    return new MapKeyAccessibility(type -> isTypeAccessibleFrom(type, accessingPackage))
+        .visitAnnotation(annotation, null);
+  }
+
+  static boolean isMapKeyPubliclyAccessible(AnnotationMirror annotation) {
+    return new MapKeyAccessibility(Accessibility::isTypePubliclyAccessible)
+        .visitAnnotation(annotation, null);
+  }
+}
diff --git a/java/dagger/internal/codegen/MapKeys.java b/java/dagger/internal/codegen/MapKeys.java
index 3db146551..ad7e5e62a 100644
--- a/java/dagger/internal/codegen/MapKeys.java
+++ b/java/dagger/internal/codegen/MapKeys.java
@@ -20,11 +20,19 @@
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static dagger.internal.codegen.MapKeyAccessibility.isMapKeyPubliclyAccessible;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
 import dagger.MapKey;
 import java.util.NoSuchElementException;
 import java.util.Optional;
@@ -81,6 +89,12 @@
         : Optional.empty();
   }
 
+  static TypeMirror mapKeyType(AnnotationMirror mapKeyAnnotation, Types types) {
+    return unwrapValue(mapKeyAnnotation).isPresent()
+        ? getUnwrappedMapKeyType(mapKeyAnnotation.getAnnotationType(), types)
+        : mapKeyAnnotation.getAnnotationType();
+  }
+
   /**
    * Returns the map key type for an unwrapped {@link MapKey} annotation type. If the single member
    * type is primitive, returns the boxed type.
@@ -89,7 +103,7 @@
    *     has more than one member, or if its single member is an array
    * @throws NoSuchElementException if the annotation has no members
    */
-  public static DeclaredType getUnwrappedMapKeyType(
+  static DeclaredType getUnwrappedMapKeyType(
       final DeclaredType mapKeyAnnotationType, final Types types) {
     checkArgument(
         MoreTypes.asTypeElement(mapKeyAnnotationType).getKind() == ElementKind.ANNOTATION_TYPE,
@@ -122,15 +136,35 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
   }
 
   /**
-   * Returns a code block for the map key specified by the {@link MapKey} annotation on
-   * {@code bindingElement}.
+   * Returns a code block for {@code binding}'s {@link ContributionBinding#mapKey() map key}. If for
+   * whatever reason the map key is not accessible from within {@code requestingClass} (i.e. it has
+   * a package-private {@code enum} from a different package), this will return an invocation of a
+   * proxy-method giving it access.
+   *
+   * @throws IllegalStateException if {@code binding} is not a {@link dagger.multibindings.IntoMap
+   *     map} contribution.
+   */
+  static CodeBlock getMapKeyExpression(ContributionBinding binding, ClassName requestingClass) {
+    AnnotationMirror mapKeyAnnotation = binding.mapKey().get();
+    return MapKeyAccessibility.isMapKeyAccessibleFrom(
+            mapKeyAnnotation, requestingClass.packageName())
+        ? directMapKeyExpression(mapKeyAnnotation)
+        : CodeBlock.of("$T.mapKey()", generatedClassNameForBinding(binding));
+  }
+
+  /**
+   * Returns a code block for the map key annotation {@code mapKey}.
+   *
+   * <p>This method assumes the map key will be accessible in the context that the returned {@link
+   * CodeBlock} is used. Use {@link #getMapKeyExpression(ContributionBinding, ClassName)} when that
+   * assumption is not guaranteed.
    *
    * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
    *     annotation
    * @throws IllegalStateException if {@code bindingElement} is not annotated with a {@code MapKey}
    *     annotation
    */
-  static CodeBlock getMapKeyExpression(AnnotationMirror mapKey) {
+  private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
     Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
     AnnotationExpression annotationExpression = new AnnotationExpression(mapKey);
     if (unwrappedValue.isPresent()) {
@@ -142,5 +176,22 @@ static CodeBlock getMapKeyExpression(AnnotationMirror mapKey) {
     }
   }
 
+  /**
+   * A {@code static mapKey()} method to be added to generated factories when the {@code @MapKey}
+   * annotation is not publicly accessible.
+   */
+  static Optional<MethodSpec> mapKeyFactoryMethod(ContributionBinding binding, Types types) {
+    return binding
+        .mapKey()
+        .filter(mapKey -> !isMapKeyPubliclyAccessible(mapKey))
+        .map(
+            mapKey ->
+                methodBuilder("mapKey")
+                    .addModifiers(PUBLIC, STATIC)
+                    .returns(TypeName.get(mapKeyType(mapKey, types)))
+                    .addStatement("return $L", directMapKeyExpression(mapKey))
+                    .build());
+  }
+
   private MapKeys() {}
 }
diff --git a/java/dagger/internal/codegen/MemberSelect.java b/java/dagger/internal/codegen/MemberSelect.java
index 97ee9845a..fc0217a39 100644
--- a/java/dagger/internal/codegen/MemberSelect.java
+++ b/java/dagger/internal/codegen/MemberSelect.java
@@ -19,19 +19,29 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.toTypeNamesCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
+import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
 import static dagger.internal.codegen.TypeNames.FACTORY;
-import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
-import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
+import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
+import static dagger.internal.codegen.TypeNames.PRODUCER;
+import static dagger.internal.codegen.TypeNames.PRODUCERS;
+import static dagger.internal.codegen.TypeNames.PROVIDER;
+import static javax.lang.model.type.TypeKind.DECLARED;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeVariableName;
 import dagger.MembersInjector;
 import java.util.List;
-import java.util.Set;
+import java.util.Optional;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /**
@@ -66,18 +76,68 @@ CodeBlock getExpressionFor(ClassName usingClass) {
   }
 
   /**
-   * Returns a {@link MemberSelect} for the invocation of a static method (given by
-   * {@code methodInvocationCodeBlock}) on the {@code owningClass}.
+   * If {@code resolvedBindings} is an unscoped provision binding with no factory arguments or a
+   * no-op members injection binding, then we don't need a field to hold its factory. In that case,
+   * this method returns the static member select that returns the factory or no-op members
+   * injector.
    */
-  static MemberSelect staticMethod(ClassName owningClass, CodeBlock methodInvocationCodeBlock) {
-    return new StaticMethod(owningClass, methodInvocationCodeBlock);
+  static Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
+    BindingKey bindingKey = resolvedBindings.bindingKey();
+    switch (bindingKey.kind()) {
+      case CONTRIBUTION:
+        ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
+        if (contributionBinding.factoryCreationStrategy().equals(SINGLETON_INSTANCE)
+            && !contributionBinding.scope().isPresent()) {
+          switch (contributionBinding.bindingKind()) {
+            case SYNTHETIC_MULTIBOUND_MAP:
+              return Optional.of(emptyMapFactory(contributionBinding));
+
+            case SYNTHETIC_MULTIBOUND_SET:
+              return Optional.of(emptySetFactory(contributionBinding));
+
+            case INJECTION:
+            case PROVISION:
+              if (bindingKey.key().type().getKind().equals(DECLARED)) {
+                ImmutableList<TypeVariableName> typeVariables =
+                    bindingTypeElementTypeVariableNames(contributionBinding);
+                if (!typeVariables.isEmpty()) {
+                  List<? extends TypeMirror> typeArguments =
+                      ((DeclaredType) bindingKey.key().type()).getTypeArguments();
+                  return Optional.of(
+                      MemberSelect.parameterizedFactoryCreateMethod(
+                          generatedClassNameForBinding(contributionBinding), typeArguments));
+                }
+              }
+              // fall through
+
+            default:
+              return Optional.of(
+                  new StaticMethod(
+                      generatedClassNameForBinding(contributionBinding), CodeBlock.of("create()")));
+          }
+        }
+        break;
+
+      case MEMBERS_INJECTION:
+        Optional<MembersInjectionBinding> membersInjectionBinding =
+            resolvedBindings.membersInjectionBinding();
+        if (membersInjectionBinding.isPresent()
+            && membersInjectionBinding.get().injectionSites().isEmpty()) {
+          return Optional.of(noOpMembersInjector(membersInjectionBinding.get().key().type()));
+        }
+        break;
+
+      default:
+        throw new AssertionError();
+    }
+    return Optional.empty();
   }
 
   /**
-   * Returns a {@link MemberSelect} for the instance of a {@code create()} method on a factory.
-   * This only applies for factories that do not have any dependencies.
+   * Returns a {@link MemberSelect} for the instance of a {@code create()} method on a factory. This
+   * only applies for factories that do not have any dependencies.
    */
-  static MemberSelect parameterizedFactoryCreateMethod(
+  private static MemberSelect parameterizedFactoryCreateMethod(
       ClassName owningClass, List<? extends TypeMirror> parameters) {
     return new ParameterizedStaticMethod(
         owningClass, ImmutableList.copyOf(parameters), CodeBlock.of("create()"), FACTORY);
@@ -99,10 +159,8 @@ CodeBlock getExpressionFor(ClassName usingClass) {
     }
   }
 
-  /**
-   * Returns the {@link MemberSelect} for a no-op {@link MembersInjector} for the given type.
-   */
-  static MemberSelect noOpMembersInjector(TypeMirror type) {
+  /** Returns the {@link MemberSelect} for a no-op {@link MembersInjector} for the given type. */
+  private static MemberSelect noOpMembersInjector(TypeMirror type) {
     return new ParameterizedStaticMethod(
         MEMBERS_INJECTORS,
         ImmutableList.of(type),
@@ -110,41 +168,32 @@ static MemberSelect noOpMembersInjector(TypeMirror type) {
         MEMBERS_INJECTOR);
   }
 
-   /**
-   * A {@link MemberSelect} for an empty map of framework types.
-   *
-   * @param bindingType the type of the binding of the empty map
-   */
-  static MemberSelect emptyFrameworkMapFactory(
-      BindingType bindingType, TypeMirror keyType, TypeMirror unwrappedValueType) {
-    final ClassName frameworkMapFactoryClass;
-    switch (bindingType) {
-      case PROVISION:
-        frameworkMapFactoryClass = MAP_PROVIDER_FACTORY;
-        break;
-      case PRODUCTION:
-        frameworkMapFactoryClass = MAP_OF_PRODUCER_PRODUCER;
-        break;
-      case MEMBERS_INJECTION:
-        throw new IllegalArgumentException();
-      default:
-        throw new AssertionError();
+  /** A {@link MemberSelect} for a factory of an empty map. */
+  private static MemberSelect emptyMapFactory(ContributionBinding contributionBinding) {
+    BindingType bindingType = contributionBinding.bindingType();
+    ImmutableList<TypeMirror> typeParameters =
+        ImmutableList.copyOf(
+            MoreTypes.asDeclared(contributionBinding.key().type()).getTypeArguments());
+    if (bindingType.equals(BindingType.PRODUCTION)) {
+      return new ParameterizedStaticMethod(
+          PRODUCERS, typeParameters, CodeBlock.of("emptyMapProducer()"), PRODUCER);
+    } else {
+      return new ParameterizedStaticMethod(
+          MAP_FACTORY, typeParameters, CodeBlock.of("emptyMapProvider()"), PROVIDER);
     }
-    return new ParameterizedStaticMethod(
-        frameworkMapFactoryClass,
-        ImmutableList.of(keyType, unwrappedValueType),
-        CodeBlock.of("empty()"),
-        ClassName.get(bindingType.frameworkClass()));
   }
 
   /**
-   * Returns the {@link MemberSelect} for an empty set provider.  Since there are several different
-   * implementations for a multibound {@link Set}, the caller is responsible for passing the
-   * correct factory.
+   * A static member select for an empty set factory. Calls {@link
+   * dagger.internal.SetFactory#empty()}, {@link dagger.producers.internal.SetProducer#empty()}, or
+   * {@link dagger.producers.internal.SetOfProducedProducer#empty()}, depending on the set bindings.
    */
-  static MemberSelect emptySetProvider(ClassName setFactoryType, SetType setType) {
+  private static MemberSelect emptySetFactory(ContributionBinding binding) {
     return new ParameterizedStaticMethod(
-        setFactoryType, ImmutableList.of(setType.elementType()), CodeBlock.of("empty()"), FACTORY);
+        setFactoryClassName(binding),
+        ImmutableList.of(SetType.from(binding.key()).elementType()),
+        CodeBlock.of("empty()"),
+        FACTORY);
   }
 
   private static final class ParameterizedStaticMethod extends MemberSelect {
diff --git a/java/dagger/internal/codegen/MembersInjectionBinding.java b/java/dagger/internal/codegen/MembersInjectionBinding.java
index 507519966..af5258037 100644
--- a/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -20,13 +20,14 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.DaggerTypes.nonObjectSuperclass;
+import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
@@ -43,6 +44,7 @@
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
@@ -112,23 +114,40 @@ boolean hasLocalInjectionSites() {
     abstract Element element();
 
     abstract ImmutableSet<DependencyRequest> dependencies();
-    
-    static int indexAmongSiblingMembers(InjectionSite injectionSite) {
-      return injectionSite
-          .element()
+
+    int indexAmongSiblingMembers() {
+      return element().getEnclosingElement().getEnclosedElements().indexOf(element());
+    }
+
+    /**
+     * Returns the index of {@link #element()} in its parents {@code @Inject} members that have the
+     * same simple name. This method filters out private elements so that the results will be
+     * consistent independent of whether the build system uses header jars or not.
+     */
+    @Memoized
+    int indexAmongAtInjectMembersWithSameSimpleName() {
+      return element()
           .getEnclosingElement()
           .getEnclosedElements()
-          .indexOf(injectionSite.element());
+          .stream()
+          .filter(element -> isAnnotationPresent(element, Inject.class))
+          .filter(element -> !element.getModifiers().contains(Modifier.PRIVATE))
+          .filter(element -> element.getSimpleName().equals(this.element().getSimpleName()))
+          .collect(toList())
+          .indexOf(element());
     }
   }
 
   static final class Factory {
     private final Elements elements;
-    private final Types types;
+    private final DaggerTypes types;
     private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Elements elements, Types types, Key.Factory keyFactory,
+    Factory(
+        Elements elements,
+        DaggerTypes types,
+        Key.Factory keyFactory,
         DependencyRequest.Factory dependencyRequestFactory) {
       this.elements = checkNotNull(elements);
       this.types = checkNotNull(types);
@@ -192,8 +211,7 @@ MembersInjectionBinding forInjectedType(
               .toSet();
 
       Optional<Key> parentKey =
-          nonObjectSuperclass(types, elements, declaredType)
-              .map(keyFactory::forMembersInjectedType);
+          types.nonObjectSuperclass(declaredType).map(keyFactory::forMembersInjectedType);
 
       Key key = keyFactory.forMembersInjectedType(declaredType);
       TypeElement typeElement = MoreElements.asType(declaredType.asElement());
@@ -215,7 +233,7 @@ MembersInjectionBinding forInjectedType(
       SetMultimap<String, ExecutableElement> overriddenMethodMap = LinkedHashMultimap.create();
       for (Optional<DeclaredType> currentType = Optional.of(declaredType);
           currentType.isPresent();
-          currentType = nonObjectSuperclass(types, elements, currentType.get())) {
+          currentType = types.nonObjectSuperclass(currentType.get())) {
         final DeclaredType type = currentType.get();
         ancestors.add(MoreElements.asType(type.asElement()));
         for (Element enclosedElement : type.asElement().getEnclosedElements()) {
diff --git a/java/dagger/internal/codegen/MembersInjectorGenerator.java b/java/dagger/internal/codegen/MembersInjectorGenerator.java
index eeca10431..81620a33b 100644
--- a/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -17,21 +17,17 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeName.VOID;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
-import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.frameworkFieldUsages;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
@@ -41,33 +37,25 @@
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
-import com.google.auto.common.MoreElements;
-import com.google.common.base.CaseFormat;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
-import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
 import dagger.MembersInjector;
+import dagger.internal.codegen.InjectionMethods.InjectionSiteMethod;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-import dagger.producers.Producer;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
 import java.util.Map.Entry;
 import java.util.Optional;
-import java.util.Set;
 import javax.annotation.processing.Filer;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
@@ -76,10 +64,13 @@
  * @since 2.0
  */
 final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
+  private final Types types;
   private final InjectValidator injectValidator;
 
-  MembersInjectorGenerator(Filer filer, Elements elements, InjectValidator injectValidator) {
+  MembersInjectorGenerator(
+      Filer filer, Elements elements, Types types, InjectValidator injectValidator) {
     super(filer, elements);
+    this.types = types;
     this.injectValidator = injectValidator;
   }
 
@@ -120,16 +111,9 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
     MethodSpec.Builder injectMembersBuilder =
         methodBuilder("injectMembers")
-            .returns(VOID)
             .addModifiers(PUBLIC)
             .addAnnotation(Override.class)
-            .addParameter(injectedTypeName, "instance")
-            .addCode("if (instance == null) {")
-            .addStatement(
-                "throw new $T($S)",
-                NullPointerException.class,
-                "Cannot inject members into a null reference")
-            .addCode("}");
+            .addParameter(injectedTypeName, "instance");
 
     ImmutableMap<BindingKey, FrameworkField> fields = generateBindingFieldsForDependencies(binding);
 
@@ -179,8 +163,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
       FieldSpec field = fieldBuilder.build();
       injectorTypeBuilder.addField(field);
-      constructorBuilder.addStatement("assert $N != null", field);
-      constructorBuilder.addStatement("this.$N = $N", field, field);
+      constructorBuilder.addStatement("this.$1N = $1N", field);
       dependencyFieldsBuilder.put(dependencyBindingKey, field);
       constructorInvocationParameters.add(CodeBlock.of("$N", field));
     }
@@ -192,179 +175,30 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     injectorTypeBuilder.addMethod(constructorBuilder.build());
     injectorTypeBuilder.addMethod(createMethodBuilder.build());
 
-    Set<String> delegateMethods = new HashSet<>();
     ImmutableMap<BindingKey, FieldSpec> dependencyFields = dependencyFieldsBuilder.build();
-    List<MethodSpec> injectMethodsForSubclasses = new ArrayList<>();
-    for (InjectionSite injectionSite : binding.injectionSites()) {
-      injectMembersBuilder.addCode(
-          isElementAccessibleFrom(injectionSite.element(), generatedTypeName.packageName())
-              ? directInjectMemberCodeBlock(binding, dependencyFields, injectionSite)
-              : delegateInjectMemberCodeBlock(dependencyFields, injectionSite));
-      if (!injectionSite.element().getModifiers().contains(PUBLIC)
-          && injectionSite.element().getEnclosingElement().equals(binding.membersInjectedType())
-          && delegateMethods.add(injectionSiteDelegateMethodName(injectionSite.element()))) {
-        injectMethodsForSubclasses.add(
-            injectorMethodForSubclasses(
-                dependencyFields,
-                typeParameters,
-                injectedTypeName,
-                injectionSite.element(),
-                injectionSite.dependencies()));
-      }
-    }
+
+    injectMembersBuilder.addCode(
+        InjectionSiteMethod.invokeAll(
+            binding.injectionSites(),
+            generatedTypeName,
+            CodeBlock.of("instance"),
+            binding.key().type(),
+            types,
+            frameworkFieldUsages(binding.dependencies(), dependencyFields)::get));
 
     if (usesRawFrameworkTypes) {
       injectMembersBuilder.addAnnotation(suppressWarnings(UNCHECKED));
     }
-
     injectorTypeBuilder.addMethod(injectMembersBuilder.build());
-    injectMethodsForSubclasses.forEach(injectorTypeBuilder::addMethod);
-
-    gwtIncompatibleAnnotation(binding).ifPresent(injectorTypeBuilder::addAnnotation);
-
-    return Optional.of(injectorTypeBuilder);
-  }
-
-  /** Returns a code block that directly injects the instance's field or method. */
-  private CodeBlock directInjectMemberCodeBlock(
-      MembersInjectionBinding binding,
-      ImmutableMap<BindingKey, FieldSpec> dependencyFields,
-      InjectionSite injectionSite) {
-    return CodeBlock.of(
-        injectionSite.element().getKind().isField() ? "$L.$L = $L;" : "$L.$L($L);",
-        getInstanceCodeBlockWithPotentialCast(
-            injectionSite.element().getEnclosingElement(), binding.membersInjectedType()),
-        injectionSite.element().getSimpleName(),
-        makeParametersCodeBlock(
-            parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), true)));
-  }
-
-  /**
-   * Returns a code block that injects the instance's field or method by calling a static method on
-   * the parent MembersInjector class.
-   */
-  private CodeBlock delegateInjectMemberCodeBlock(
-      ImmutableMap<BindingKey, FieldSpec> dependencyFields, InjectionSite injectionSite) {
-    return CodeBlock.of(
-        "$L.$L($L);",
-        membersInjectorNameForType(
-            MoreElements.asType(injectionSite.element().getEnclosingElement())),
-        injectionSiteDelegateMethodName(injectionSite.element()),
-        makeParametersCodeBlock(
-            new ImmutableList.Builder<CodeBlock>()
-                .add(CodeBlock.of("instance"))
-                .addAll(parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), false))
-                .build()));
-  }
-
-  /**
-   * Returns the parameters for injecting a member.
-   *
-   * @param passValue if {@code true}, each parameter code block will be the result of converting
-   *     the field from the framework type ({@link Provider}, {@link Producer}, etc.) to the real
-   *     value; if {@code false}, each parameter code block will be just the field
-   */
-  private ImmutableList<CodeBlock> parameterCodeBlocks(
-      ImmutableMap<BindingKey, FieldSpec> dependencyFields,
-      ImmutableSet<DependencyRequest> dependencies,
-      boolean passValue) {
-    ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
-    for (DependencyRequest dependency : dependencies) {
-      CodeBlock fieldCodeBlock =
-          CodeBlock.of("$L", dependencyFields.get(dependency.bindingKey()).name);
-      parameters.add(
-          passValue
-              ? frameworkTypeUsageStatement(fieldCodeBlock, dependency.kind())
-              : fieldCodeBlock);
-    }
-    return parameters.build();
-  }
 
-  private CodeBlock getInstanceCodeBlockWithPotentialCast(
-      Element injectionSiteElement, Element bindingElement) {
-    if (injectionSiteElement.equals(bindingElement)) {
-      return CodeBlock.of("instance");
-    }
-    TypeName injectionSiteName = TypeName.get(injectionSiteElement.asType());
-    if (injectionSiteName instanceof ParameterizedTypeName) {
-      injectionSiteName = ((ParameterizedTypeName) injectionSiteName).rawType;
-    }
-    return CodeBlock.of("(($T) instance)", injectionSiteName);
-  }
-
-  private static String injectionSiteDelegateMethodName(Element injectionSiteElement) {
-    return "inject"
-        + CaseFormat.LOWER_CAMEL.to(
-            CaseFormat.UPPER_CAMEL, injectionSiteElement.getSimpleName().toString());
-  }
-
-  private MethodSpec injectorMethodForSubclasses(
-      ImmutableMap<BindingKey, FieldSpec> dependencyFields,
-      List<TypeVariableName> typeParameters,
-      TypeName injectedTypeName,
-      Element injectionElement,
-      ImmutableSet<DependencyRequest> dependencies) {
-    MethodSpec.Builder methodBuilder =
-        methodBuilder(injectionSiteDelegateMethodName(injectionElement))
-            .addModifiers(PUBLIC, STATIC)
-            .addParameter(injectedTypeName, "instance")
-            .addTypeVariables(typeParameters);
-    ImmutableList.Builder<CodeBlock> providedParameters = ImmutableList.builder();
-    Set<String> parameterNames = new HashSet<>();
-    for (DependencyRequest dependency : dependencies) {
-      FieldSpec field = dependencyFields.get(dependency.bindingKey());
-      ParameterSpec parameter =
-          ParameterSpec.builder(
-                  field.type,
-                  staticInjectMethodDependencyParameterName(parameterNames, dependency, field))
-              .build();
-      methodBuilder.addParameter(parameter);
-      providedParameters.add(
-          frameworkTypeUsageStatement(CodeBlock.of("$N", parameter), dependency.kind()));
-    }
-    if (injectionElement.getKind().isField()) {
-      methodBuilder.addStatement(
-          "instance.$L = $L",
-          injectionElement.getSimpleName(),
-          getOnlyElement(providedParameters.build()));
-    } else {
-      methodBuilder.addStatement(
-          "instance.$L($L)",
-          injectionElement.getSimpleName(),
-          makeParametersCodeBlock(providedParameters.build()));
+    for (InjectionSite injectionSite : binding.injectionSites()) {
+      if (injectionSite.element().getEnclosingElement().equals(binding.membersInjectedType())) {
+        injectorTypeBuilder.addMethod(InjectionSiteMethod.create(injectionSite));
+      }
     }
-    return methodBuilder.build();
-  }
 
-  /**
-   * Returns the static inject method parameter name for a dependency.
-   *
-   * @param parameterNames the parameter names used so far
-   * @param dependency the dependency
-   * @param field the field used to hold the framework type for the dependency
-   */
-  private String staticInjectMethodDependencyParameterName(
-      Set<String> parameterNames, DependencyRequest dependency, FieldSpec field) {
-    StringBuilder parameterName =
-        new StringBuilder(dependency.requestElement().get().getSimpleName().toString());
-    switch (dependency.kind()) {
-      case LAZY:
-      case INSTANCE:
-      case FUTURE:
-        String suffix = ((ParameterizedTypeName) field.type).rawType.simpleName();
-        if (parameterName.length() <= suffix.length()
-            || !parameterName.substring(parameterName.length() - suffix.length()).equals(suffix)) {
-          parameterName.append(suffix);
-        }
-        break;
+    gwtIncompatibleAnnotation(binding).ifPresent(injectorTypeBuilder::addAnnotation);
 
-      default:
-        break;
-    }
-    int baseLength = parameterName.length();
-    for (int i = 2; !parameterNames.add(parameterName.toString()); i++) {
-      parameterName.replace(baseLength, parameterName.length(), String.valueOf(i));
-    }
-    return parameterName.toString();
+    return Optional.of(injectorTypeBuilder);
   }
 }
diff --git a/java/dagger/internal/codegen/MembersInjectorRequestFulfillment.java b/java/dagger/internal/codegen/MembersInjectorRequestFulfillment.java
deleted file mode 100644
index 4f9e9550c..000000000
--- a/java/dagger/internal/codegen/MembersInjectorRequestFulfillment.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.BindingKey.Kind.MEMBERS_INJECTION;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import dagger.internal.codegen.DependencyRequest.Kind;
-
-/** Fulfills requests for {@link MembersInjectionBinding} instances. */
-final class MembersInjectorRequestFulfillment extends RequestFulfillment {
-  private final MemberSelect membersInjectorFieldSelect;
-
-  MembersInjectorRequestFulfillment(
-      BindingKey bindingKey, MemberSelect membersInjectorFieldSelect) {
-    super(bindingKey);
-    checkArgument(bindingKey.kind().equals(MEMBERS_INJECTION));
-    this.membersInjectorFieldSelect = membersInjectorFieldSelect;
-  }
-
-  @Override
-  public CodeBlock getSnippetForDependencyRequest(
-      DependencyRequest request, ClassName requestingClass) {
-    checkArgument(request.kind().equals(Kind.MEMBERS_INJECTOR));
-    return membersInjectorFieldSelect.getExpressionFor(requestingClass);
-  }
-
-  @Override
-  CodeBlock getSnippetForFrameworkDependency(
-      FrameworkDependency frameworkDependency, ClassName requestingClass) {
-    checkArgument(frameworkDependency.bindingType().equals(BindingType.MEMBERS_INJECTION));
-    return membersInjectorFieldSelect.getExpressionFor(requestingClass);
-  }
-}
diff --git a/java/dagger/internal/codegen/ModuleDescriptor.java b/java/dagger/internal/codegen/ModuleDescriptor.java
index 52211589f..49f4d66ea 100644
--- a/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -24,7 +24,6 @@
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
-import static dagger.internal.codegen.DaggerElements.checkTypePresent;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.SourceFiles.classFileName;
@@ -55,7 +54,6 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 
 @AutoValue
 abstract class ModuleDescriptor {
@@ -78,6 +76,8 @@
   /** The {@link BindsOptionalOf} method declarations that define optional bindings. */
   abstract ImmutableSet<OptionalBindingDeclaration> optionalDeclarations();
 
+  abstract Kind kind();
+
   enum Kind {
     MODULE(Module.class, Provides.class),
     PRODUCER_MODULE(ProducerModule.class, Produces.class);
@@ -136,7 +136,7 @@
   }
 
   static final class Factory {
-    private final Elements elements;
+    private final DaggerElements elements;
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
     private final MultibindingDeclaration.Factory multibindingDeclarationFactory;
@@ -145,7 +145,7 @@
     private final OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory;
 
     Factory(
-        Elements elements,
+        DaggerElements elements,
         ProvisionBinding.Factory provisionBindingFactory,
         ProductionBinding.Factory productionBindingFactory,
         MultibindingDeclaration.Factory multibindingDeclarationFactory,
@@ -196,7 +196,8 @@ ModuleDescriptor create(TypeElement moduleElement) {
           multibindingDeclarations.build(),
           subcomponentDeclarationFactory.forModule(moduleElement),
           delegates.build(),
-          optionalDeclarations.build());
+          optionalDeclarations.build(),
+          Kind.forAnnotatedElement(moduleElement).get());
     }
 
     @CanIgnoreReturnValue
@@ -235,7 +236,7 @@ private void collectImplicitlyIncludedModules(
       for (ExecutableElement method : methodsIn(moduleElement.getEnclosedElements())) {
         if (isAnnotationPresent(method, contributesAndroidInjector.asType())) {
           includedModules.add(
-              create(checkTypePresent(implicitlyIncludedModuleName(method), elements)));
+              create(elements.checkTypePresent(implicitlyIncludedModuleName(method))));
         }
       }
     }
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index 0339287b2..f1c3d4cc8 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -37,6 +37,7 @@
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
 import static dagger.internal.codegen.MoreAnnotationValues.asType;
+import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.EnumSet.noneOf;
 import static java.util.stream.Collectors.joining;
@@ -67,6 +68,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
@@ -93,6 +95,20 @@
       ImmutableSet.of(Subcomponent.class, ProductionSubcomponent.class);
   private static final ImmutableSet<Class<? extends Annotation>> SUBCOMPONENT_BUILDER_TYPES =
       ImmutableSet.of(Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);
+  private static final Optional<Class<?>> ANDROID_PROCESSOR;
+  private static final String CONTRIBUTES_ANDROID_INJECTOR_NAME =
+      "dagger.android.ContributesAndroidInjector";
+  private static final String ANDROID_PROCESSOR_NAME = "dagger.android.processor.AndroidProcessor";
+
+  static {
+    Class<?> clazz;
+    try {
+      clazz = Class.forName(ANDROID_PROCESSOR_NAME, false, ModuleValidator.class.getClassLoader());
+    } catch (ClassNotFoundException ignored) {
+      clazz = null;
+    }
+    ANDROID_PROCESSOR = Optional.ofNullable(clazz);
+  }
 
   private final Types types;
   private final Elements elements;
@@ -128,7 +144,7 @@ void addKnownModules(Collection<TypeElement> modules) {
 
   /** Returns a validation report for a module type. */
   ValidationReport<TypeElement> validate(TypeElement module) {
-    return cache.computeIfAbsent(module, this::validateUncached);
+    return reentrantComputeIfAbsent(cache, module, this::validateUncached);
   }
 
   private ValidationReport<TypeElement> validateUncached(TypeElement module) {
@@ -139,6 +155,12 @@ void addKnownModules(Collection<TypeElement> modules) {
     ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
 
     Set<ModuleMethodKind> methodKinds = noneOf(ModuleMethodKind.class);
+    TypeElement contributesAndroidInjectorElement =
+        elements.getTypeElement(CONTRIBUTES_ANDROID_INJECTOR_NAME);
+    TypeMirror contributesAndroidInjector =
+        contributesAndroidInjectorElement != null
+            ? contributesAndroidInjectorElement.asType()
+            : null;
     for (ExecutableElement moduleMethod : methodsIn(module.getEnclosedElements())) {
       if (anyBindingMethodValidator.isBindingMethod(moduleMethod)) {
         builder.addSubreport(anyBindingMethodValidator.validate(moduleMethod));
@@ -150,6 +172,21 @@ void addKnownModules(Collection<TypeElement> modules) {
         methodKinds.add(ModuleMethodKind.ofMethod(moduleMethod));
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
+
+      for (AnnotationMirror annotation : moduleMethod.getAnnotationMirrors()) {
+        if (!ANDROID_PROCESSOR.isPresent()
+            && MoreTypes.equivalence()
+                .equivalent(contributesAndroidInjector, annotation.getAnnotationType())) {
+          builder.addSubreport(
+              ValidationReport.about(moduleMethod)
+                  .addError(
+                      String.format(
+                          "@%s was used, but %s was not found on the processor path",
+                          CONTRIBUTES_ANDROID_INJECTOR_NAME, ANDROID_PROCESSOR_NAME))
+                  .build());
+          break;
+        }
+      }
     }
 
     if (methodKinds.containsAll(
diff --git a/java/dagger/internal/codegen/OptionalBindingExpression.java b/java/dagger/internal/codegen/OptionalBindingExpression.java
new file mode 100644
index 000000000..ceb0c905d
--- /dev/null
+++ b/java/dagger/internal/codegen/OptionalBindingExpression.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.OptionalType.OptionalKind;
+import javax.lang.model.util.Types;
+
+/** A binding expression for optional bindings. */
+final class OptionalBindingExpression extends SimpleInvocationBindingExpression {
+  private final ProvisionBinding binding;
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final Types types;
+
+  OptionalBindingExpression(
+      ProvisionBinding binding,
+      BindingExpression delegate,
+      ComponentBindingExpressions componentBindingExpressions,
+      DaggerTypes types) {
+    super(delegate, types);
+    this.binding = binding;
+    this.componentBindingExpressions = componentBindingExpressions;
+    this.types = types;
+  }
+
+  @Override
+  Expression getInstanceDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    OptionalType optionalType = OptionalType.from(binding.key());
+    OptionalKind optionalKind = optionalType.kind();
+    if (binding.dependencies().isEmpty()) {
+      // When compiling with -source 7, javac's type inference isn't strong enough to detect
+      // Futures.immediateFuture(Optional.absent()) for keys that aren't Object
+      if (requestKind.equals(DependencyRequest.Kind.FUTURE)
+          && isTypeAccessibleFrom(binding.key().type(), requestingClass.packageName())) {
+        return Expression.create(
+            binding.key().type(),
+            optionalKind.parameterizedAbsentValueExpression(optionalType));
+      }
+      return Expression.create(binding.key().type(), optionalKind.absentValueExpression());
+    }
+    DependencyRequest dependency = getOnlyElement(binding.dependencies());
+
+    CodeBlock dependencyExpression =
+        componentBindingExpressions
+            .getDependencyExpression(dependency, requestingClass)
+            .codeBlock();
+
+    // If the dependency type is inaccessible, then we have to use Optional.<Object>of(...), or else
+    // we will get "incompatible types: inference variable has incompatible bounds.
+    // TODO(user): Do we need presentObjectExpression in androidExperimentalMode?
+    return isTypeAccessibleFrom(dependency.key().type(), requestingClass.packageName())
+        ? Expression.create(
+            binding.key().type(), optionalKind.presentExpression(dependencyExpression))
+        : Expression.create(
+            types.erasure(binding.key().type()),
+            optionalKind.presentObjectExpression(dependencyExpression));
+  }
+}
diff --git a/java/dagger/internal/codegen/OptionalFactories.java b/java/dagger/internal/codegen/OptionalFactories.java
index 4d608f8c7..49c30ad5b 100644
--- a/java/dagger/internal/codegen/OptionalFactories.java
+++ b/java/dagger/internal/codegen/OptionalFactories.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
@@ -190,11 +191,10 @@ String factoryClassName() {
     }
 
     private static PresentFactorySpec of(ContributionBinding binding) {
-      OptionalKind optionalKind = OptionalType.from(binding.key()).kind();
-      DependencyRequest.Kind valueKind =
-          DependencyRequest.extractKindAndType(OptionalType.from(binding.key()).valueType()).kind();
       return new AutoValue_OptionalFactories_PresentFactorySpec(
-          binding.bindingType(), optionalKind, valueKind);
+          binding.bindingType(),
+          OptionalType.from(binding.key()).kind(),
+          getOnlyElement(binding.dependencies()).kind());
     }
   }
   
diff --git a/java/dagger/internal/codegen/OptionalType.java b/java/dagger/internal/codegen/OptionalType.java
index f154ab2d1..cd7896ef1 100644
--- a/java/dagger/internal/codegen/OptionalType.java
+++ b/java/dagger/internal/codegen/OptionalType.java
@@ -68,10 +68,25 @@ CodeBlock absentValueExpression() {
       return CodeBlock.of("$T.$L()", clazz, absentFactoryMethodName);
     }
 
+    /**
+     * Returns an expression for the absent/empty value, parameterized with {@link #valueType()}.
+     */
+    CodeBlock parameterizedAbsentValueExpression(OptionalType optionalType) {
+      return CodeBlock.of("$T.<$T>$L()", clazz, optionalType.valueType(), absentFactoryMethodName);
+    }
+
     /** Returns an expression for the present {@code value}. */
     CodeBlock presentExpression(CodeBlock value) {
       return CodeBlock.of("$T.of($L)", clazz, value);
     }
+
+    /**
+     * Returns an expression for the present {@code value}, returning {@code Optional<Object>} no
+     * matter what type the value is.
+     */
+    CodeBlock presentObjectExpression(CodeBlock value) {
+      return CodeBlock.of("$T.<$T>of($L)", clazz, Object.class, value);
+    }
   }
 
   private static final TypeVisitor<Optional<OptionalKind>, Void> OPTIONAL_KIND =
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
new file mode 100644
index 000000000..09a4e6bbf
--- /dev/null
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.asExecutable;
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.google.auto.common.MoreTypes;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import java.util.EnumMap;
+import java.util.Map;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/**
+ * A binding expression that wraps the dependency expressions in a private, no-arg method.
+ *
+ * <p>Dependents of this binding expression will just called the no-arg method.
+ */
+final class PrivateMethodBindingExpression extends BindingExpression {
+  private final ClassName componentName;
+  private final GeneratedComponentModel generatedComponentModel;
+  private final BindingExpression delegate;
+  private final Map<DependencyRequest.Kind, String> methodNames =
+      new EnumMap<>(DependencyRequest.Kind.class);
+  private final ContributionBinding binding;
+  private final DaggerTypes types;
+  private final Elements elements;
+
+  PrivateMethodBindingExpression(
+      ResolvedBindings resolvedBindings,
+      ClassName componentName,
+      GeneratedComponentModel generatedComponentModel,
+      BindingExpression delegate,
+      DaggerTypes types,
+      Elements elements) {
+    super(resolvedBindings);
+    this.componentName = componentName;
+    this.generatedComponentModel = generatedComponentModel;
+    this.delegate = delegate;
+    binding = resolvedBindings.contributionBinding();
+    this.types = types;
+    this.elements = elements;
+  }
+
+  @Override
+  Expression getDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    // TODO(user): we should just use the component method if one matches instead of creating one.
+    if (!methodNames.containsKey(requestKind)) {
+      String name = generatedComponentModel.getUniqueMethodName(methodName(requestKind));
+      methodNames.put(requestKind, name);
+      createMethod(name, requestKind);
+    }
+
+    CodeBlock invocation =
+        componentName.equals(requestingClass)
+            ? CodeBlock.of("$N()", methodNames.get(requestKind))
+            : CodeBlock.of("$T.this.$N()", componentName, methodNames.get(requestKind));
+    return Expression.create(returnType(requestKind), invocation);
+  }
+
+  /** Creates the no-arg method used for dependency expressions. */
+  private void createMethod(String name, DependencyRequest.Kind requestKind) {
+    // TODO(user): Consider when we can make this method static.
+    // TODO(user): Fix the order that these generated methods are written to the component.
+    generatedComponentModel.addMethod(
+        methodBuilder(name)
+            .addModifiers(PRIVATE)
+            .returns(TypeName.get(returnType(requestKind)))
+            .addStatement("return $L", methodBody(requestKind))
+            .build());
+  }
+
+  /** Returns the return type for the dependency request. */
+  private TypeMirror returnType(DependencyRequest.Kind requestKind) {
+    // TODO(user): use DR.Kind.type() when that CL is submitted.
+    switch (requestKind) {
+      case INSTANCE:
+        return binding.contributesPrimitiveType()
+            ? asExecutable(binding.bindingElement().get()).getReturnType()
+            : instanceType();
+      case LAZY:
+        return accessibleType(types.lazyOf(instanceType()));
+      case PROVIDER_OF_LAZY:
+        return accessibleType(types.providerOfLazyOf(instanceType()));
+      case PROVIDER:
+        return accessibleType(types.providerOf(instanceType()));
+      case PRODUCER:
+        return accessibleType(types.producerOf(instanceType()));
+      default:
+        throw new AssertionError("Unhandled DependencyRequest: " + requestKind);
+    }
+  }
+
+  private TypeMirror instanceType() {
+    return accessibleType(binding.contributedType());
+  }
+
+  /** Returns the method body for the dependency request. */
+  private CodeBlock methodBody(DependencyRequest.Kind requestKind) {
+    switch (requestKind) {
+      case PROVIDER:
+        // TODO(user): Cache provider field instead of recreating each time.
+        return CodeBlock.of("$L", providerTypeSpec());
+      case LAZY:
+      case PROVIDER_OF_LAZY:
+        // TODO(user): Refactor the delegate BindingExpression to handle these cases?
+        // Don't use delegate.getDependencyExpression() because that will inline the provider
+        // dependency instead of delegating to the private method. To use the private method,
+        // recursively call this.getDependencyExpression().
+        return FrameworkType.PROVIDER.to(
+            requestKind,
+            getDependencyExpression(DependencyRequest.Kind.PROVIDER, componentName).codeBlock());
+      case INSTANCE:
+      case PRODUCER:
+        return delegate.getDependencyExpression(requestKind, componentName).codeBlock();
+      default:
+        throw new AssertionError("Unhandled DependencyRequest: " + requestKind);
+    }
+  }
+
+  /** Returns a {@link TypeSpec} for an anonymous provider class. */
+  private TypeSpec providerTypeSpec() {
+    return anonymousClassBuilder("")
+        .addSuperinterface(TypeName.get(returnType(DependencyRequest.Kind.PROVIDER)))
+        .addMethod(
+            methodBuilder("get")
+                .addAnnotation(Override.class)
+                .addModifiers(PUBLIC)
+                .returns(TypeName.get(instanceType()))
+                .addStatement(
+                    "return $L",
+                    getDependencyExpression(DependencyRequest.Kind.INSTANCE, componentName)
+                        .codeBlock())
+                .build())
+        .build();
+  }
+
+  /** Returns the canonical name for a no-arg dependency expression method. */
+  private String methodName(DependencyRequest.Kind dependencyKind) {
+    // TODO(user): Use a better name for @MapKey binding instances.
+    // TODO(user): Include the binding method as part of the method name.
+    return String.format("get%s%s", bindingName(), dependencyKindName(dependencyKind));
+  }
+
+  /** Returns the canonical name for the {@link Binding}. */
+  private String bindingName() {
+    return LOWER_CAMEL.to(UPPER_CAMEL, BindingVariableNamer.name(binding));
+  }
+
+  /** Returns a canonical name for the {@link DependencyRequest.Kind}. */
+  private static String dependencyKindName(DependencyRequest.Kind kind) {
+    return UPPER_UNDERSCORE.to(UPPER_CAMEL, kind.name());
+  }
+
+  /** Returns a {@link TypeName} for the binding that is accessible to the component. */
+  private TypeMirror accessibleType(TypeMirror typeMirror) {
+    if (Accessibility.isTypeAccessibleFrom(typeMirror, componentName.packageName())) {
+      return typeMirror;
+    } else if (Accessibility.isRawTypeAccessible(typeMirror, componentName.packageName())
+        && typeMirror.getKind().equals(TypeKind.DECLARED)) {
+      return types.getDeclaredType(MoreTypes.asTypeElement(typeMirror));
+    } else {
+      return elements.getTypeElement(Object.class.getCanonicalName()).asType();
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 44d656b2c..fc38de52a 100644
--- a/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -24,6 +24,7 @@
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
+import static dagger.internal.codegen.MapKeys.mapKeyFactoryMethod;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
@@ -63,6 +64,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * Generates {@link Producer} implementations from {@link ProductionBinding} instances.
@@ -71,10 +73,13 @@
  * @since 2.0
  */
 final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
+  private final Types types;
   private final CompilerOptions compilerOptions;
 
-  ProducerFactoryGenerator(Filer filer, Elements elements, CompilerOptions compilerOptions) {
+  ProducerFactoryGenerator(
+      Filer filer, Elements elements, Types types, CompilerOptions compilerOptions) {
     super(filer, elements);
+    this.types = types;
     this.compilerOptions = compilerOptions;
   }
 
@@ -182,10 +187,6 @@ ClassName nameGeneratedType(ProductionBinding binding) {
             .addModifiers(PUBLIC)
             .addParameter(futureTransform.applyArgType(), futureTransform.applyArgName())
             .addExceptions(getThrownTypeNames(binding.thrownTypes()))
-            .addStatement(
-                "assert monitor != null : $S",
-                "apply() may only be called internally from compute(); "
-                    + "if it's called explicitly, the monitor might be null")
             .addCode(
                 getInvocationCodeBlock(
                     generatedTypeName,
@@ -203,10 +204,6 @@ ClassName nameGeneratedType(ProductionBinding binding) {
             .addAnnotation(Deprecated.class)
             .addAnnotation(Override.class)
             .addParameter(RUNNABLE, "runnable")
-            .addStatement(
-                "assert monitor != null : $S",
-                "execute() may only be called internally from compute(); "
-                    + "if it's called explicitly, the monitor might be null")
             .addStatement("monitor.ready()")
             .addStatement("executorProvider.get().execute(runnable)");
 
@@ -216,6 +213,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     factoryBuilder.addMethod(executeMethodBuilder.build());
 
     gwtIncompatibleAnnotation(binding).ifPresent(factoryBuilder::addAnnotation);
+    mapKeyFactoryMethod(binding, types).ifPresent(factoryBuilder::addMethod);
 
     // TODO(gak): write a sensible toString
     return Optional.of(factoryBuilder);
@@ -234,9 +232,7 @@ private static FieldSpec addFieldAndConstructorParameter(
   }
 
   private static void assignField(MethodSpec.Builder constructorBuilder, FieldSpec field) {
-    constructorBuilder
-        .addStatement("assert $N != null", field)
-        .addStatement("this.$1N = $1N", field);
+    constructorBuilder.addStatement("this.$1N = $1N", field);
   }
 
   /** Returns a list of dependencies that are generated asynchronously. */
diff --git a/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java b/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java
deleted file mode 100644
index a0c61c85c..000000000
--- a/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
-import static dagger.internal.codegen.BindingType.PRODUCTION;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-
-/** Fulfills requests for {@link ProductionBinding} instances. */
-final class ProducerFieldRequestFulfillment extends RequestFulfillment {
-  private final MemberSelect producerFieldSelect;
-
-  ProducerFieldRequestFulfillment(BindingKey bindingKey, MemberSelect producerFieldSelect) {
-    super(bindingKey);
-    checkArgument(bindingKey.kind().equals(CONTRIBUTION));
-    this.producerFieldSelect = producerFieldSelect;
-  }
-
-  @Override
-  public CodeBlock getSnippetForDependencyRequest(
-      DependencyRequest request, ClassName requestingClass) {
-    return FrameworkType.PRODUCER.to(
-        request.kind(), producerFieldSelect.getExpressionFor(requestingClass));
-  }
-
-  @Override
-  CodeBlock getSnippetForFrameworkDependency(
-      FrameworkDependency frameworkDependency, ClassName requestingClass) {
-    checkArgument(
-        frameworkDependency.bindingType().equals(PRODUCTION),
-        "%s is not a production dependency",
-        frameworkDependency);
-    return producerFieldSelect.getExpressionFor(requestingClass);
-  }
-}
diff --git a/java/dagger/internal/codegen/ProducesMethodValidator.java b/java/dagger/internal/codegen/ProducesMethodValidator.java
index bc71b08f1..ee5386f11 100644
--- a/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -66,7 +66,7 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
   }
 
   /** Adds a warning if a {@link Produces @Produces} method is declared nullable. */
-  // TODO(beder): Make this an error.
+  // TODO(beder): Properly handle nullable with producer methods.
   private void checkNullable(ValidationReport.Builder<ExecutableElement> builder) {
     if (ConfigurationAnnotations.getNullableType(builder.getSubject()).isPresent()) {
       builder.addWarning(PRODUCES_METHOD_NULLABLE);
diff --git a/java/dagger/internal/codegen/ProductionBinding.java b/java/dagger/internal/codegen/ProductionBinding.java
index dd9f3a18b..441fb5c1e 100644
--- a/java/dagger/internal/codegen/ProductionBinding.java
+++ b/java/dagger/internal/codegen/ProductionBinding.java
@@ -109,6 +109,10 @@ private static Builder builder() {
   @AutoValue.Builder
   @CanIgnoreReturnValue
   abstract static class Builder extends ContributionBinding.Builder<Builder> {
+    abstract Builder explicitDependencies(Iterable<DependencyRequest> dependencies);
+
+    abstract Builder explicitDependencies(DependencyRequest... dependencies);
+
     abstract Builder productionKind(ProductionKind productionKind);
 
     abstract Builder thrownTypes(Iterable<? extends TypeMirror> thrownTypes);
@@ -174,28 +178,6 @@ ProductionBinding forProducesMethod(
           .build();
     }
 
-    /**
-     * A synthetic binding of {@code Map<K, V>} or {@code Map<K, Produced<V>>} that depends on
-     * {@code Map<K, Producer<V>>}.
-     */
-    ProductionBinding syntheticMapOfValuesOrProducedBinding(Key mapOfValuesOrProducedKey) {
-      checkNotNull(mapOfValuesOrProducedKey);
-      Optional<Key> mapOfProducersKey =
-          keyFactory.implicitMapProducerKeyFrom(mapOfValuesOrProducedKey);
-      checkArgument(
-          mapOfProducersKey.isPresent(),
-          "%s is not a key for of Map<K, V> or Map<K, Produced<V>>",
-          mapOfValuesOrProducedKey);
-      DependencyRequest requestForMapOfProducers =
-          dependencyRequestFactory.producerForImplicitMapBinding(mapOfProducersKey.get());
-      return ProductionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(mapOfValuesOrProducedKey)
-          .explicitDependencies(requestForMapOfProducers)
-          .bindingKind(Kind.SYNTHETIC_MAP)
-          .build();
-    }
-
     /**
      * A synthetic binding that depends explicitly on a set of individual provision or production
      * multibinding contribution methods.
@@ -208,7 +190,7 @@ ProductionBinding syntheticMultibinding(
           .contributionType(ContributionType.UNIQUE)
           .key(key)
           .explicitDependencies(
-              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
+              dependencyRequestFactory.forMultibindingContributions(key, multibindingContributions))
           .bindingKind(Kind.forMultibindingKey(key))
           .build();
     }
@@ -245,14 +227,13 @@ ProductionBinding delegate(
      * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
      * component with a binding for the underlying key.
      */
-    ProductionBinding syntheticPresentBinding(Key key) {
+    ProductionBinding syntheticPresentBinding(Key key, DependencyRequest.Kind kind) {
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(key)
           .bindingKind(Kind.SYNTHETIC_OPTIONAL_BINDING)
           .explicitDependencies(
-              dependencyRequestFactory.forSyntheticPresentOptionalBinding(
-                  key, DependencyRequest.Kind.PRODUCER))
+              dependencyRequestFactory.forSyntheticPresentOptionalBinding(key, kind))
           .build();
     }
   }
diff --git a/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java b/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
index 5368cd24f..525ae1eaa 100644
--- a/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
+++ b/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
@@ -21,7 +21,6 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.STATIC;
 
-import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeSpec;
@@ -59,9 +58,7 @@ ClassName nameGeneratedType(TypeElement componentElement) {
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
     return Optional.of(
         classBuilder(generatedTypeName)
-            .addAnnotation(
-                AnnotationSpec.builder(Module.class)
-                    .build())
+            .addAnnotation(Module.class)
             .addModifiers(FINAL)
             .addMethod(
                 methodBuilder("executor")
diff --git a/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java b/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java
deleted file mode 100644
index d17c2e54a..000000000
--- a/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import dagger.producers.internal.Producers;
-
-/** Fulfills requests for {@link ProvisionBinding} instances. */
-final class ProviderFieldRequestFulfillment extends RequestFulfillment {
-  private final MemberSelect providerFieldSelect;
-
-  ProviderFieldRequestFulfillment(BindingKey bindingKey, MemberSelect frameworkFieldSelect) {
-    super(bindingKey);
-    checkArgument(bindingKey.kind().equals(CONTRIBUTION));
-    this.providerFieldSelect = frameworkFieldSelect;
-  }
-
-  @Override
-  public CodeBlock getSnippetForDependencyRequest(
-      DependencyRequest request, ClassName requestingClass) {
-    return FrameworkType.PROVIDER.to(
-        request.kind(), providerFieldSelect.getExpressionFor(requestingClass));
-  }
-
-  @Override
-  CodeBlock getSnippetForFrameworkDependency(
-      FrameworkDependency frameworkDependency, ClassName requestingClass) {
-    switch (frameworkDependency.bindingType()) {
-      case PROVISION:
-        return providerFieldSelect.getExpressionFor(requestingClass);
-      case MEMBERS_INJECTION:
-        throw new IllegalArgumentException();
-      case PRODUCTION:
-        return CodeBlock.of(
-            "$T.producerFromProvider($L)",
-            Producers.class,
-            providerFieldSelect.getExpressionFor(requestingClass));
-      default:
-        throw new AssertionError();
-    }
-  }
-}
diff --git a/java/dagger/internal/codegen/ProviderOrProducerBindingExpression.java b/java/dagger/internal/codegen/ProviderOrProducerBindingExpression.java
new file mode 100644
index 000000000..51275f773
--- /dev/null
+++ b/java/dagger/internal/codegen/ProviderOrProducerBindingExpression.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+
+/**
+ * A {@link FrameworkInstanceBindingExpression} that is expressed with a {@link
+ * javax.inject.Provider} for all {@link DependencyRequest.Kind}s except {@link
+ * DependencyRequest.Kind#PRODUCER}, for which it uses a {@link
+ * dagger.producers.internal.Producers#producerFromProvider(javax.inject.Provider) provider wrapped
+ * by a producer}.
+ */
+final class ProviderOrProducerBindingExpression extends BindingExpression {
+  private final FrameworkInstanceBindingExpression providerBindingExpression;
+  private final FrameworkInstanceBindingExpression producerBindingExpression;
+
+  ProviderOrProducerBindingExpression(
+      FrameworkInstanceBindingExpression providerBindingExpression,
+      FrameworkInstanceBindingExpression producerBindingExpression) {
+    super(providerBindingExpression.resolvedBindings());
+    this.providerBindingExpression = providerBindingExpression;
+    this.producerBindingExpression = producerBindingExpression;
+  }
+
+  @Override
+  Expression getDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    switch (requestKind) {
+      case PRODUCER:
+        return producerBindingExpression.getDependencyExpression(requestKind, requestingClass);
+      default:
+        return providerBindingExpression.getDependencyExpression(requestKind, requestingClass);
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index 5de760e93..466def54d 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -24,31 +24,31 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
+import static dagger.internal.codegen.Util.toImmutableSet;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import java.util.Optional;
 import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 /**
@@ -62,14 +62,32 @@
 abstract class ProvisionBinding extends ContributionBinding {
 
   @Override
-  ImmutableSet<DependencyRequest> implicitDependencies() {
-    return membersInjectionRequest().isPresent()
-        ? ImmutableSet.of(membersInjectionRequest().get())
-        : ImmutableSet.of();
+  @Memoized
+  ImmutableSet<DependencyRequest> explicitDependencies() {
+    return ImmutableSet.<DependencyRequest>builder()
+        .addAll(provisionDependencies())
+        .addAll(membersInjectionDependencies())
+        .build();
   }
 
-  /** If this provision requires members injection, this will be the corresponding request. */
-  abstract Optional<DependencyRequest> membersInjectionRequest();
+  /**
+   * Dependencies necessary to invoke an {@code @Inject} constructor or {@code @Provides} method.
+   */
+  abstract ImmutableSet<DependencyRequest> provisionDependencies();
+
+  @Memoized
+  ImmutableSet<DependencyRequest> membersInjectionDependencies() {
+    return injectionSites()
+        .stream()
+        .flatMap(i -> i.dependencies().stream())
+        .collect(toImmutableSet());
+  }
+
+  /**
+   * {@link InjectionSite}s for all {@code @Inject} members if {@link #bindingKind()} is {@link
+   * ContributionBinding.Kind#INJECTION}, otherwise empty.
+   */
+  abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
   @Override
   public BindingType bindingType() {
@@ -84,16 +102,25 @@ public BindingType bindingType() {
 
   private static Builder builder() {
     return new AutoValue_ProvisionBinding.Builder()
-        .explicitDependencies(ImmutableSet.<DependencyRequest>of());
+        .provisionDependencies(ImmutableSet.of())
+        .injectionSites(ImmutableSortedSet.of());
   }
-  
+
   abstract Builder toBuilder();
 
+  boolean shouldCheckForNull(CompilerOptions compilerOptions) {
+    return !contributesPrimitiveType()
+        && !nullableType().isPresent()
+        && compilerOptions.doCheckForNulls();
+  }
+
   @AutoValue.Builder
   @CanIgnoreReturnValue
   abstract static class Builder extends ContributionBinding.Builder<Builder> {
+    abstract Builder provisionDependencies(DependencyRequest... provisionDependencies);
+    abstract Builder provisionDependencies(ImmutableSet<DependencyRequest> provisionDependencies);
 
-    abstract Builder membersInjectionRequest(Optional<DependencyRequest> membersInjectionRequest);
+    abstract Builder injectionSites(ImmutableSortedSet<InjectionSite> injectionSites);
 
     abstract Builder unresolved(ProvisionBinding unresolved);
 
@@ -104,17 +131,20 @@ private static Builder builder() {
   }
 
   static final class Factory {
-    private final Elements elements;
     private final Types types;
     private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
+    private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
 
-    Factory(Elements elements, Types types, Key.Factory keyFactory,
-        DependencyRequest.Factory dependencyRequestFactory) {
-      this.elements = elements;
+    Factory(
+        Types types,
+        Key.Factory keyFactory,
+        DependencyRequest.Factory dependencyRequestFactory,
+        MembersInjectionBinding.Factory membersInjectionBindingFactory) {
       this.types = types;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
+      this.membersInjectionBindingFactory = membersInjectionBindingFactory;
     }
 
     /**
@@ -145,19 +175,23 @@ ProvisionBinding forInjectConstructor(
 
       Key key = keyFactory.forInjectConstructorWithResolvedType(enclosingCxtorType);
       checkArgument(!key.qualifier().isPresent());
-      ImmutableSet<DependencyRequest> dependencies =
+      ImmutableSet<DependencyRequest> provisionDependencies =
           dependencyRequestFactory.forRequiredResolvedVariables(
               constructorElement.getParameters(), cxtorType.getParameterTypes());
-      Optional<DependencyRequest> membersInjectionRequest =
-          membersInjectionRequest(enclosingCxtorType);
+      // TODO(ronshapiro): instead of creating a MembersInjectionBinding just to retrieve the
+      // injection sites, create an InjectionSite.Factory and pass that in here.
+      ImmutableSortedSet<InjectionSite> injectionSites =
+          membersInjectionBindingFactory
+              .forInjectedType(enclosingCxtorType, Optional.empty())
+              .injectionSites();
 
       ProvisionBinding.Builder builder =
           ProvisionBinding.builder()
               .contributionType(ContributionType.UNIQUE)
               .bindingElement(constructorElement)
               .key(key)
-              .explicitDependencies(dependencies)
-              .membersInjectionRequest(membersInjectionRequest)
+              .provisionDependencies(provisionDependencies)
+              .injectionSites(injectionSites)
               .bindingKind(Kind.INJECTION)
               .scope(Scope.uniqueScopeOf(constructorElement.getEnclosingElement()));
 
@@ -169,24 +203,6 @@ ProvisionBinding forInjectConstructor(
       return builder.build();
     }
 
-    private static final ImmutableSet<ElementKind> MEMBER_KINDS =
-        Sets.immutableEnumSet(METHOD, FIELD);
-
-    private Optional<DependencyRequest> membersInjectionRequest(DeclaredType type) {
-      TypeElement typeElement = MoreElements.asType(type.asElement());
-      if (!types.isSameType(elements.getTypeElement(Object.class.getCanonicalName()).asType(),
-          typeElement.getSuperclass())) {
-        return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
-      }
-      for (Element enclosedElement : typeElement.getEnclosedElements()) {
-        if (MEMBER_KINDS.contains(enclosedElement.getKind())
-            && (isAnnotationPresent(enclosedElement, Inject.class))) {
-          return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
-        }
-      }
-      return Optional.empty();
-    }
-
     ProvisionBinding forProvidesMethod(
         ExecutableElement providesMethod, TypeElement contributedBy) {
       checkArgument(providesMethod.getKind().equals(METHOD));
@@ -203,7 +219,7 @@ ProvisionBinding forProvidesMethod(
           .bindingElement(providesMethod)
           .contributingModule(contributedBy)
           .key(key)
-          .explicitDependencies(dependencies)
+          .provisionDependencies(dependencies)
           .nullableType(ConfigurationAnnotations.getNullableType(providesMethod))
           .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(providesMethod)))
           .bindingKind(Kind.PROVISION)
@@ -211,21 +227,6 @@ ProvisionBinding forProvidesMethod(
           .build();
     }
 
-    /** A synthetic binding of {@code Map<K, V>} that depends on {@code Map<K, Provider<V>>}. */
-    ProvisionBinding syntheticMapOfValuesBinding(Key mapOfValuesKey) {
-      checkNotNull(mapOfValuesKey);
-      Optional<Key> mapOfProvidersKey = keyFactory.implicitMapProviderKeyFrom(mapOfValuesKey);
-      checkArgument(mapOfProvidersKey.isPresent(), "%s is not a key for Map<K, V>", mapOfValuesKey);
-      DependencyRequest requestForMapOfProviders =
-          dependencyRequestFactory.providerForImplicitMapBinding(mapOfProvidersKey.get());
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(mapOfValuesKey)
-          .explicitDependencies(requestForMapOfProviders)
-          .bindingKind(Kind.SYNTHETIC_MAP)
-          .build();
-    }
-
     /**
      * A synthetic binding that depends explicitly on a set of individual provision multibinding
      * contribution methods.
@@ -237,8 +238,8 @@ ProvisionBinding syntheticMultibinding(
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(key)
-          .explicitDependencies(
-              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
+          .provisionDependencies(
+              dependencyRequestFactory.forMultibindingContributions(key, multibindingContributions))
           .bindingKind(Kind.forMultibindingKey(key))
           .build();
     }
@@ -248,11 +249,21 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .bindingElement(componentDefinitionType)
-          .key(keyFactory.forComponent(componentDefinitionType.asType()))
+          .key(keyFactory.forType(componentDefinitionType.asType()))
           .bindingKind(Kind.COMPONENT)
           .build();
     }
 
+    ProvisionBinding forComponentDependency(TypeElement dependencyType) {
+      checkNotNull(dependencyType);
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(dependencyType)
+          .key(keyFactory.forType(dependencyType.asType()))
+          .bindingKind(Kind.COMPONENT_DEPENDENCY)
+          .build();
+    }
+
     ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
@@ -327,7 +338,7 @@ ProvisionBinding missingDelegate(DelegateDeclaration delegateDeclaration) {
           .bindingElement(delegateDeclaration.bindingElement().get())
           .contributingModule(delegateDeclaration.contributingModule().get())
           .key(keyFactory.forDelegateBinding(delegateDeclaration, Provider.class))
-          .explicitDependencies(delegateDeclaration.delegateRequest())
+          .provisionDependencies(delegateDeclaration.delegateRequest())
           .wrappedMapKey(delegateDeclaration.wrappedMapKey())
           .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
           .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()));
@@ -350,7 +361,7 @@ ProvisionBinding provideReleasableReferenceManager(Scope scope) {
      * TypedReleasableReferenceManager<metadataType>} that provides the component-instantiated
      * object.
      */
-    ContributionBinding provideTypedReleasableReferenceManager(
+    ProvisionBinding provideTypedReleasableReferenceManager(
         Scope scope, DeclaredType metadataType) {
       return provideReleasableReferenceManager(scope)
           .toBuilder()
@@ -370,7 +381,7 @@ ProvisionBinding provideSetOfReleasableReferenceManagers() {
     /**
      * Returns a synthetic binding for {@code Set<TypedReleasableReferenceManager<metadataType>}.
      */
-    ContributionBinding provideSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
+    ProvisionBinding provideSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
       return provideSetOfReleasableReferenceManagers()
           .toBuilder()
           .key(keyFactory.forSetOfTypedReleasableReferenceManagers(metadataType))
@@ -393,12 +404,11 @@ ProvisionBinding syntheticAbsentBinding(Key key) {
      * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
      * component with a binding for the underlying key.
      */
-    ProvisionBinding syntheticPresentBinding(Key key) {
+    ProvisionBinding syntheticPresentBinding(Key key, DependencyRequest.Kind kind) {
       return syntheticAbsentBinding(key)
           .toBuilder()
-          .explicitDependencies(
-              dependencyRequestFactory.forSyntheticPresentOptionalBinding(
-                  key, DependencyRequest.Kind.PROVIDER))
+          .provisionDependencies(
+              dependencyRequestFactory.forSyntheticPresentOptionalBinding(key, kind))
           .build();
     }
   }
diff --git a/java/dagger/internal/codegen/Proxies.java b/java/dagger/internal/codegen/Proxies.java
deleted file mode 100644
index 800e3272d..000000000
--- a/java/dagger/internal/codegen/Proxies.java
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.collect.Iterables.toArray;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
-import static dagger.internal.codegen.Accessibility.isElementPubliclyAccessible;
-import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
-import static dagger.internal.codegen.Accessibility.isRawTypePubliclyAccessible;
-import static dagger.internal.codegen.Accessibility.isTypePubliclyAccessible;
-import static dagger.internal.codegen.CodeBlocks.javadocLinkTo;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.TypeNames.rawTypeName;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.type.TypeKind.VOID;
-
-import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableList;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.ParameterSpec;
-import com.squareup.javapoet.TypeName;
-import com.squareup.javapoet.TypeVariableName;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Parameterizable;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.TypeParameterElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * Proxy methods ("proxies") are generated methods used to give component implementations access to
- * {@link Element}s that are inaccessible as written in the source code. For example, a component
- * cannot directly invoke a package-private {@code @Inject} constructor in a different package.
- *
- * <p>Since proxies are generated separately from their usages, they cannot make any assumptions
- * about the types or packages from which methods will be invoked. Thus, any type or element that is
- * not public is considered to be "inaccessible".
- *
- * <p>This class generates proxies for any {@link ExecutableElement}, but the form of the methods
- * are somewhat tailored to how they are used within components.
- *
- * <p>Proxies have the following attributes:
- *
- * <ul>
- *   <li>Proxies are always {@code public}, {@code static} methods.
- *   <li>The return type of the proxy is always the return type of the method or the constructed
- *       type regardless of its accessibility. For example, if a proxied method returns {@code
- *       MyPackagePrivateClass}, the proxy method will also return {@code MyPackagePrivateClass}
- *       because the accessibility of the return type does not impact callers.
- *   <li>Proxies for constructors are named "{@code newTypeName}" (where "{@code TypeName}" is the
- *       name of the type being constructed) and proxies for methods are named "{@code
- *       proxyMethodName}" (where "{@code methodName}" is the name of the method being proxied).
- *   <li>If the element being proxied is an instance method, the first parameter will be the
- *       instance.
- *   <li>The rest of the parameters of the proxy method are that of the proxied method unless the
- *       raw type of a parameter is inaccessible, in which case it is {@link Object}. Passing an
- *       object to this method that is not of the proxied parameter type will result in a {@link
- *       ClassCastException}.
- *       <p>While it is not required by the language that a method's parameter types be accessible
- *       to invoke it, components often hold references to {@link javax.inject.Provider} as raw
- *       types in order to dodge similar accessibility restrictions. This means that the {@code
- *       {@link javax.inject.Provider#get()}} method will return {@link Object}. Since it cannot be
- *       cast to the the more specific type on the calling side, we must accept {@link Object} in
- *       the proxy method.
- * </ul>
- *
- * <p>Proxies are not generated under the following conditions:
- *
- * <ul>
- *   <li>If an {@link ExecutableElement} is publicly accessible and all of its {@linkplain
- *       ExecutableElement#getParameters() parameters} are publicly accessible types, no proxy is
- *       necessary. If the type of a parameter has a type argument that is is inaccessible, but the
- *       raw type that is accessible, the type is considered to be accessible because callers can
- *       always hold references to the raw type.
- *   <li>If an {@link ExecutableElement} or any of its enclosing types are {@code private}, no proxy
- *       is generated because it is impossible to write Java (without reflection) that accesses the
- *       element.
- * </ul>
- */
-final class Proxies {
-
-  /**
-   * Returns {@code true} if the given method has limited access, thus requiring a proxy for some
-   * cases.
-   */
-  static boolean shouldGenerateProxy(ExecutableElement method) {
-    return !isElementPubliclyAccessible(method)
-        || method
-            .getParameters()
-            .stream()
-            .map(VariableElement::asType)
-            .anyMatch(type -> !isRawTypePubliclyAccessible(type));
-  }
-
-  /** Returns {@code true} if accessing the given method from the given package requires a proxy. */
-  static boolean requiresProxyAccess(ExecutableElement method, String callingPackage) {
-    return !isElementAccessibleFrom(method, callingPackage)
-        || method
-            .getParameters()
-            .stream()
-            .map(VariableElement::asType)
-            .anyMatch(type -> !isRawTypeAccessible(type, callingPackage));
-  }
-
-  /** Returns the name of the method that proxies access to the given method. */
-  static String proxyName(ExecutableElement method) {
-    switch (method.getKind()) {
-      case CONSTRUCTOR:
-        return "new" + method.getEnclosingElement().getSimpleName();
-      case METHOD:
-        return "proxy" + LOWER_CAMEL.to(UPPER_CAMEL, method.getSimpleName().toString());
-      case STATIC_INIT:
-      case INSTANCE_INIT:
-        throw new IllegalArgumentException(
-            "cannot proxy initializers because they cannot be invoked directly: " + method);
-      default:
-        throw new AssertionError(method);
-    }
-  }
-
-  /**
-   * Returns a proxy method implementation for the method.
-   *
-   * @throws IllegalArgumentException if the method is publicly accessible
-   */
-  // TODO(gak): expand support to proxy fields
-  static MethodSpec createProxy(ExecutableElement method) {
-    checkArgument(
-        shouldGenerateProxy(method),
-        "method and all of its arguments are accessible; proxy isn't necessary: %s",
-        method);
-    final MethodSpec.Builder builder;
-    switch (method.getKind()) {
-      case CONSTRUCTOR:
-        builder = forConstructor(method);
-        break;
-      case METHOD:
-        builder = forMethod(method);
-        break;
-      default:
-        throw new AssertionError();
-    }
-    builder.addJavadoc("Proxies $L.", javadocLinkTo(method));
-    builder.addModifiers(PUBLIC, STATIC);
-
-    copyTypeParameters(method, builder);
-    copyThrows(method, builder);
-
-    return builder.build();
-  }
-
-  private static MethodSpec.Builder forConstructor(ExecutableElement constructor) {
-    TypeElement enclosingType = MoreElements.asType(constructor.getEnclosingElement());
-    MethodSpec.Builder methodBuilder = methodBuilder(proxyName(constructor));
-
-    copyTypeParameters(enclosingType, methodBuilder);
-
-    methodBuilder.returns(TypeName.get(enclosingType.asType()));
-
-    CodeBlock arguments =
-        copyParameters(
-            constructor, methodBuilder, new UniqueNameSet(), new ImmutableList.Builder<>());
-
-    methodBuilder.addCode("return new $T($L);", enclosingType, arguments);
-
-    return methodBuilder;
-  }
-
-  private static MethodSpec.Builder forMethod(ExecutableElement method) {
-    TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
-    MethodSpec.Builder methodBuilder = methodBuilder(proxyName(method));
-
-    UniqueNameSet nameSet = new UniqueNameSet();
-    ImmutableList.Builder<CodeBlock> argumentsBuilder = new ImmutableList.Builder<>();
-    if (!method.getModifiers().contains(STATIC)) {
-      methodBuilder.addParameter(
-          TypeName.get(enclosingType.asType()), nameSet.getUniqueName("instance"));
-    }
-    CodeBlock arguments = copyParameters(method, methodBuilder, nameSet, argumentsBuilder);
-    if (!method.getReturnType().getKind().equals(VOID)) {
-      methodBuilder.addCode("return ");
-    }
-    if (method.getModifiers().contains(STATIC)) {
-      methodBuilder.addCode("$T", rawTypeName(TypeName.get(enclosingType.asType())));
-    } else {
-      copyTypeParameters(enclosingType, methodBuilder);
-      // "instance" is guaranteed b/c it was the first name into the UniqueNameSet
-      methodBuilder.addCode("instance", method.getSimpleName());
-    }
-    methodBuilder.addCode(".$N($L);", method.getSimpleName(), arguments);
-    methodBuilder.returns(TypeName.get(method.getReturnType()));
-    return methodBuilder;
-  }
-
-  private static void copyThrows(ExecutableElement method, MethodSpec.Builder methodBuilder) {
-    for (TypeMirror thrownType : method.getThrownTypes()) {
-      methodBuilder.addException(TypeName.get(thrownType));
-    }
-  }
-
-  private static CodeBlock copyParameters(
-      ExecutableElement method,
-      MethodSpec.Builder methodBuilder,
-      UniqueNameSet nameSet,
-      ImmutableList.Builder<CodeBlock> argumentsBuilder) {
-    for (VariableElement parameter : method.getParameters()) {
-      TypeMirror parameterType = parameter.asType();
-      boolean useObject = !isTypePubliclyAccessible(parameterType);
-      TypeName typeName = useObject ? TypeName.OBJECT : TypeName.get(parameterType);
-      String name = nameSet.getUniqueName(parameter.getSimpleName().toString());
-      argumentsBuilder.add(
-          useObject ? CodeBlock.of("($T) $L", parameterType, name) : CodeBlock.of(name));
-      ParameterSpec.Builder parameterBuilder =
-          ParameterSpec.builder(typeName, name)
-              .addModifiers(toArray(parameter.getModifiers(), Modifier.class));
-      methodBuilder.addParameter(parameterBuilder.build());
-    }
-    methodBuilder.varargs(method.isVarArgs());
-    return makeParametersCodeBlock(argumentsBuilder.build());
-  }
-
-  private static void copyTypeParameters(
-      Parameterizable parameterizable, MethodSpec.Builder methodBuilder) {
-    for (TypeParameterElement typeParameterElement : parameterizable.getTypeParameters()) {
-      methodBuilder.addTypeVariable(TypeVariableName.get(typeParameterElement));
-    }
-  }
-
-  private Proxies() {}
-}
diff --git a/java/dagger/internal/codegen/RequestFulfillment.java b/java/dagger/internal/codegen/RequestFulfillment.java
deleted file mode 100644
index db296c066..000000000
--- a/java/dagger/internal/codegen/RequestFulfillment.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-
-/**
- * A strategy interface for generating a {@link CodeBlock} that represents how a {@link Binding} is
- * used to satisfy a given {@link DependencyRequest}.
- */
-abstract class RequestFulfillment {
-  private final BindingKey bindingKey;
-
-  RequestFulfillment(BindingKey bindingKey) {
-    this.bindingKey = checkNotNull(bindingKey);
-  }
-
-  /** The key for which this instance can fulfill requests. */
-  final BindingKey bindingKey() {
-    return bindingKey;
-  }
-
-  /**
-   * Returns the {@link CodeBlock} that implements the operation represented by the {@link
-   * DependencyRequest request} from the {@code requestingClass}.
-   */
-  abstract CodeBlock getSnippetForDependencyRequest(
-      DependencyRequest request, ClassName requestingClass);
-
-  /**
-   * Returns the {@link CodeBlock} that references the {@link FrameworkDependency} as accessed from
-   * the {@code requestingClass}.
-   */
-  abstract CodeBlock getSnippetForFrameworkDependency(
-      FrameworkDependency frameworkDependency, ClassName requestingClass);
-}
diff --git a/java/dagger/internal/codegen/RequestFulfillmentRegistry.java b/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
deleted file mode 100644
index 941d314e6..000000000
--- a/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize;
-import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
-
-import com.google.common.collect.ImmutableMap;
-import java.util.Map;
-
-/**
- * A registry that associates a {@link BindingKey} with a {@link RequestFulfillment}. The registry
- * is responsible for choosing the most appropriate {@link RequestFulfillment} implementation based
- * on the properties of the binding and how it is used throughout the component.
- */
-final class RequestFulfillmentRegistry {
-  private final ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap;
-  private final HasBindingMembers hasBindingMembers;
-  /** This map is mutated as {@link #getRequestFulfillment} is invoked. */
-  private final Map<BindingKey, RequestFulfillment> requestFulfillments;
-
-  RequestFulfillmentRegistry(
-      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap,
-      HasBindingMembers hasBindingMembers) {
-    this.resolvedBindingsMap = resolvedBindingsMap;
-    this.hasBindingMembers = hasBindingMembers;
-    this.requestFulfillments = newLinkedHashMapWithExpectedSize(resolvedBindingsMap.size());
-  }
-
-  /** Returns a {@link RequestFulfillment} implementation for the given {@link BindingKey} */
-  RequestFulfillment getRequestFulfillment(BindingKey bindingKey) {
-    return requestFulfillments.computeIfAbsent(bindingKey, this::createRequestFulfillment);
-  }
-
-  private RequestFulfillment createRequestFulfillment(BindingKey bindingKey) {
-    /* TODO(gak): it is super convoluted that we create the member selects separately and then
-     * look them up again this way. Now that we have RequestFulfillment, the next step is to
-     * create it and the MemberSelect and the field on demand rather than in a first pass. */
-    MemberSelect memberSelect = hasBindingMembers.getMemberSelect(bindingKey);
-    ResolvedBindings resolvedBindings = resolvedBindingsMap.get(bindingKey);
-    switch (resolvedBindings.bindingType()) {
-      case MEMBERS_INJECTION:
-        return new MembersInjectorRequestFulfillment(bindingKey, memberSelect);
-      case PRODUCTION:
-        return new ProducerFieldRequestFulfillment(bindingKey, memberSelect);
-      case PROVISION:
-        ProvisionBinding provisionBinding =
-            (ProvisionBinding) resolvedBindings.contributionBinding();
-
-        ProviderFieldRequestFulfillment providerFieldRequestFulfillment =
-            new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
-        if (provisionBinding.implicitDependencies().isEmpty()
-            && !provisionBinding.scope().isPresent()
-            && !provisionBinding.requiresModuleInstance()
-            && provisionBinding.bindingElement().isPresent()
-            && (provisionBinding.bindingKind().equals(INJECTION)
-                || provisionBinding.bindingKind().equals(PROVISION))) {
-          return new SimpleMethodRequestFulfillment(
-              bindingKey, provisionBinding, providerFieldRequestFulfillment, this);
-        }
-        return providerFieldRequestFulfillment;
-      default:
-        throw new AssertionError();
-    }
-  }
-}
diff --git a/java/dagger/internal/codegen/ResolvedBindings.java b/java/dagger/internal/codegen/ResolvedBindings.java
index c6f381a63..4d4574f89 100644
--- a/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/java/dagger/internal/codegen/ResolvedBindings.java
@@ -19,7 +19,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static java.util.stream.Collectors.toSet;
+import static dagger.internal.codegen.Util.toImmutableSet;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.FluentIterable;
@@ -32,7 +32,6 @@
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.internal.codegen.Key.HasKey;
 import java.util.Optional;
-import java.util.Set;
 
 /**
  * The collection of bindings that have been resolved for a binding key. For valid graphs, contains
@@ -47,11 +46,7 @@
    */
   abstract BindingKey bindingKey();
 
-  /**
-   * The component in which the bindings in {@link #ownedBindings()},
-   * {@link #ownedContributionBindings()}, and {@link #ownedMembersInjectionBinding()} were
-   * resolved.
-   */
+  /** The component in which the bindings in {@link #ownedBindings()}, were resolved. */
   abstract ComponentDescriptor owningComponent();
 
   /**
@@ -97,7 +92,7 @@ public Key key() {
    * All bindings for {@link #bindingKey()}, indexed by the component in which the binding was
    * resolved.
    */
-  ImmutableSetMultimap<ComponentDescriptor, ? extends Binding> allBindings() {
+  private ImmutableSetMultimap<ComponentDescriptor, ? extends Binding> allBindings() {
     switch (bindingKey().kind()) {
       case CONTRIBUTION:
         return allContributionBindings();
@@ -141,18 +136,7 @@ boolean isEmpty() {
    * All bindings for {@link #bindingKey()} that were resolved in {@link #owningComponent()}.
    */
   ImmutableSet<? extends Binding> ownedBindings() {
-    switch (bindingKey().kind()) {
-      case CONTRIBUTION:
-        return ownedContributionBindings();
-
-      case MEMBERS_INJECTION:
-        return ownedMembersInjectionBinding().isPresent()
-            ? ImmutableSet.of(ownedMembersInjectionBinding().get())
-            : ImmutableSet.of();
-
-      default:
-        throw new AssertionError(bindingKey());
-    }
+    return allBindings().get(owningComponent());
   }
 
   /**
@@ -163,14 +147,6 @@ boolean isEmpty() {
     return ImmutableSet.copyOf(allContributionBindings().values());
   }
 
-  /**
-   * The contribution bindings that were resolved in {@link #owningComponent()}. Empty if this is a
-   * members-injection binding.
-   */
-  ImmutableSet<ContributionBinding> ownedContributionBindings() {
-    return allContributionBindings().get(owningComponent());
-  }
-
   /** The component that owns {@code binding}. */
   ComponentDescriptor owningComponent(ContributionBinding binding) {
     checkArgument(
@@ -193,14 +169,6 @@ ComponentDescriptor owningComponent(ContributionBinding binding) {
         : Optional.of(Iterables.getOnlyElement(membersInjectionBindings));
   }
 
-  /**
-   * The members-injection binding that was resolved in {@link #owningComponent()}. Empty if these
-   * are contribution bindings.
-   */
-  Optional<MembersInjectionBinding> ownedMembersInjectionBinding() {
-    return Optional.ofNullable(allMembersInjectionBindings().get(owningComponent()));
-  }
-
   /** Creates a {@link ResolvedBindings} for contribution bindings. */
   static ResolvedBindings forContributionBindings(
       BindingKey bindingKey,
@@ -213,8 +181,8 @@ static ResolvedBindings forContributionBindings(
     return new AutoValue_ResolvedBindings(
         bindingKey,
         owningComponent,
-        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>copyOf(contributionBindings),
-        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
+        ImmutableSetMultimap.copyOf(contributionBindings),
+        ImmutableMap.of(),
         ImmutableSet.copyOf(multibindings),
         ImmutableSet.copyOf(subcomponentDeclarations),
         ImmutableSet.copyOf(optionalBindingDeclarations));
@@ -231,11 +199,11 @@ static ResolvedBindings forMembersInjectionBinding(
     return new AutoValue_ResolvedBindings(
         bindingKey,
         owningComponent,
-        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
+        ImmutableSetMultimap.of(),
         ImmutableMap.of(owningComponent, ownedMembersInjectionBinding),
-        ImmutableSet.<MultibindingDeclaration>of(),
-        ImmutableSet.<SubcomponentDeclaration>of(),
-        ImmutableSet.<OptionalBindingDeclaration>of());
+        ImmutableSet.of(),
+        ImmutableSet.of(),
+        ImmutableSet.of());
   }
 
   /**
@@ -245,11 +213,11 @@ static ResolvedBindings noBindings(BindingKey bindingKey, ComponentDescriptor ow
     return new AutoValue_ResolvedBindings(
         bindingKey,
         owningComponent,
-        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
-        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
-        ImmutableSet.<MultibindingDeclaration>of(),
-        ImmutableSet.<SubcomponentDeclaration>of(),
-        ImmutableSet.<OptionalBindingDeclaration>of());
+        ImmutableSetMultimap.of(),
+        ImmutableMap.of(),
+        ImmutableSet.of(),
+        ImmutableSet.of(),
+        ImmutableSet.of());
   }
 
   /**
@@ -306,7 +274,7 @@ public BindingType bindingType() {
 
   /** The binding types for {@link #bindings()}. */
   ImmutableSet<BindingType> bindingTypes() {
-    return FluentIterable.from(bindings()).transform(HasBindingType::bindingType).toSet();
+    return bindings().stream().map(HasBindingType::bindingType).collect(toImmutableSet());
   }
 
   /**
@@ -323,19 +291,12 @@ public ContributionType contributionType() {
   /**
    * The name of the package in which these bindings must be managed, for
    * example if a binding references non-public types.
-   * 
-   * @throws IllegalArgumentException if the bindings must be managed in more than one package
+   *
+   * @throws IllegalStateException if there is more than one binding
    */
   Optional<String> bindingPackage() {
-    Set<String> bindingPackages =
-        bindings()
-            .stream()
-            .map(Binding::bindingPackage)
-            .filter(Optional::isPresent)
-            .map(Optional::get)
-            .collect(toSet());
-    checkArgument(bindingPackages.size() <= 1);
-    return bindingPackages.stream().findFirst();
+    checkState(bindings().size() == 1);
+    return binding().bindingPackage();
   }
 
   /**
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
new file mode 100644
index 000000000..d97ced043
--- /dev/null
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.SetBuilder;
+import java.util.Collections;
+import java.util.Set;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/** A binding expression for multibound sets. */
+final class SetBindingExpression extends SimpleInvocationBindingExpression {
+  private final ProvisionBinding binding;
+  private final BindingGraph graph;
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final Elements elements;
+
+  SetBindingExpression(
+      ProvisionBinding binding,
+      BindingGraph graph,
+      ComponentBindingExpressions componentBindingExpressions,
+      BindingExpression delegate,
+      DaggerTypes types,
+      Elements elements) {
+    super(delegate, types);
+    this.binding = binding;
+    this.graph = graph;
+    this.componentBindingExpressions = componentBindingExpressions;
+    this.elements = elements;
+  }
+
+  @Override
+  Expression getInstanceDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    return Expression.create(binding.key().type(), setExpression(requestingClass));
+  }
+
+  private CodeBlock setExpression(ClassName requestingClass) {
+    // TODO(ronshapiro): We should also make an ImmutableSet version of SetFactory
+    boolean isImmutableSetAvailable = isImmutableSetAvailable();
+    // TODO(ronshapiro, gak): Use Sets.immutableEnumSet() if it's available?
+    if (isImmutableSetAvailable && binding.dependencies().stream().allMatch(this::isSingleValue)) {
+      return CodeBlock.builder()
+          .add("$T.", ImmutableSet.class)
+          .add(maybeTypeParameter(requestingClass))
+          .add(
+              "of($L)",
+              binding
+                  .dependencies()
+                  .stream()
+                  .map(dependency -> getContributionExpression(dependency, requestingClass))
+                  .collect(toParametersCodeBlock()))
+          .build();
+    }
+    switch (binding.dependencies().size()) {
+      case 0:
+        return collectionsStaticFactoryInvocation(requestingClass, CodeBlock.of("emptySet()"));
+      case 1:
+        {
+          DependencyRequest dependency = getOnlyElement(binding.dependencies());
+          CodeBlock contributionExpression = getContributionExpression(dependency, requestingClass);
+          if (isSingleValue(dependency)) {
+            return collectionsStaticFactoryInvocation(
+                requestingClass, CodeBlock.of("singleton($L)", contributionExpression));
+          } else if (isImmutableSetAvailable) {
+            return CodeBlock.builder()
+                .add("$T.", ImmutableSet.class)
+                .add(maybeTypeParameter(requestingClass))
+                .add("copyOf($L)", contributionExpression)
+                .build();
+          }
+        }
+        // fall through
+      default:
+        CodeBlock.Builder instantiation = CodeBlock.builder();
+        instantiation
+            .add("$T.", isImmutableSetAvailable ? ImmutableSet.class : SetBuilder.class)
+            .add(maybeTypeParameter(requestingClass));
+        if (isImmutableSetAvailable) {
+          instantiation.add("builder()");
+        } else {
+          instantiation.add("newSetBuilder($L)", binding.dependencies().size());
+        }
+        for (DependencyRequest dependency : binding.dependencies()) {
+          String builderMethod = isSingleValue(dependency) ? "add" : "addAll";
+          instantiation.add(
+              ".$L($L)", builderMethod, getContributionExpression(dependency, requestingClass));
+        }
+        return instantiation.add(".build()").build();
+    }
+  }
+
+  private CodeBlock getContributionExpression(
+      DependencyRequest dependency, ClassName requestingClass) {
+    return componentBindingExpressions
+        .getDependencyExpression(dependency, requestingClass)
+        .codeBlock();
+  }
+
+  private CodeBlock collectionsStaticFactoryInvocation(
+      ClassName requestingClass, CodeBlock methodInvocation) {
+    return CodeBlock.builder()
+        .add("$T.", Collections.class)
+        .add(maybeTypeParameter(requestingClass))
+        .add(methodInvocation)
+        .build();
+  }
+
+  private CodeBlock maybeTypeParameter(ClassName requestingClass) {
+    TypeMirror elementType = SetType.from(binding.key()).elementType();
+    return isTypeAccessibleFrom(elementType, requestingClass.packageName())
+        ? CodeBlock.of("<$T>", elementType)
+        : CodeBlock.of("");
+  }
+
+  private boolean isSingleValue(DependencyRequest dependency) {
+    return graph
+        .resolvedBindings()
+        .get(dependency.bindingKey())
+        .contributionBinding()
+        .contributionType()
+        .equals(ContributionType.SET);
+  }
+
+  private boolean isImmutableSetAvailable() {
+    return elements.getTypeElement(ImmutableSet.class.getCanonicalName()) != null;
+  }
+
+  @Override
+  protected CodeBlock explicitTypeParameter(ClassName requestingClass) {
+    if (isImmutableSetAvailable()) {
+      TypeMirror keyType = binding.key().type();
+      return CodeBlock.of(
+          "<$T>",
+          isTypeAccessibleFrom(keyType, requestingClass.packageName()) ? keyType : Set.class);
+    }
+    return CodeBlock.of("");
+  }
+}
diff --git a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
new file mode 100644
index 000000000..3b4d81756
--- /dev/null
+++ b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+
+/**
+ * A binding expression that can use a simple expression for instance requests, and delegates to
+ * another expression for other requests.
+ */
+abstract class SimpleInvocationBindingExpression extends BindingExpression {
+  private final BindingExpression delegate;
+  private final DaggerTypes types;
+
+  SimpleInvocationBindingExpression(BindingExpression delegate, DaggerTypes types) {
+    super(delegate.resolvedBindings());
+    this.delegate = delegate;
+    this.types = types;
+  }
+
+  /**
+   * Returns an expression that evaluates to an instance of a dependency.
+   *
+   * @param requestingClass the class that will contain the expression
+   */
+  abstract Expression getInstanceDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass);
+
+  /**
+   * Java 7 type inference is not as strong as in Java 8, and therefore some generated code must
+   * make type parameters for {@link Futures#immediateFuture(Object)} explicit.
+   *
+   * <p>For example, {@code javac7} cannot detect that Futures.immediateFuture(ImmutableSet.of(T))}
+   * can safely be assigned to {@code ListenableFuture<Set<T>>}.
+   */
+  protected CodeBlock explicitTypeParameter(ClassName requestingClass) {
+    return CodeBlock.of("");
+  }
+
+  @Override
+  final Expression getDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    switch (requestKind) {
+      case INSTANCE:
+        return getInstanceDependencyExpression(requestKind, requestingClass);
+      case FUTURE:
+        Expression expression = getInstanceDependencyExpression(requestKind, requestingClass);
+        return Expression.create(
+            types.wrapType(expression.type(), ListenableFuture.class),
+            CodeBlock.builder()
+                .add("$T.", Futures.class)
+                .add(explicitTypeParameter(requestingClass))
+                .add("immediateFuture($L)", expression.codeBlock())
+                .build());
+      default:
+        return delegate.getDependencyExpression(requestKind, requestingClass);
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
new file mode 100644
index 000000000..993c8c537
--- /dev/null
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.asExecutable;
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.FactoryGenerator.checkNotNullProvidesMethod;
+import static dagger.internal.codegen.InjectionMethods.ProvisionMethod.requiresInjectionMethod;
+import static dagger.internal.codegen.TypeNames.rawTypeName;
+
+import com.google.auto.common.MoreTypes;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import dagger.internal.codegen.InjectionMethods.ProvisionMethod;
+import java.util.Optional;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/**
+ * A binding expression that invokes methods or constructors directly for a provision binding when
+ * possible.
+ */
+final class SimpleMethodBindingExpression extends SimpleInvocationBindingExpression {
+  private final CompilerOptions compilerOptions;
+  private final ProvisionBinding provisionBinding;
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentRequirementFields componentRequirementFields;
+  private final Elements elements;
+
+  SimpleMethodBindingExpression(
+      CompilerOptions compilerOptions,
+      ProvisionBinding provisionBinding,
+      BindingExpression delegate,
+      ComponentBindingExpressions componentBindingExpressions,
+      GeneratedComponentModel generatedComponentModel,
+      ComponentRequirementFields componentRequirementFields,
+      DaggerTypes types,
+      Elements elements) {
+    super(delegate, types);
+    checkArgument(
+        provisionBinding.implicitDependencies().isEmpty(),
+        "framework deps are not currently supported");
+    checkArgument(!provisionBinding.scope().isPresent());
+    checkArgument(provisionBinding.bindingElement().isPresent());
+    this.compilerOptions = compilerOptions;
+    this.provisionBinding = provisionBinding;
+    this.componentBindingExpressions = componentBindingExpressions;
+    this.generatedComponentModel = generatedComponentModel;
+    this.componentRequirementFields = componentRequirementFields;
+    this.elements = elements;
+  }
+
+  @Override
+  Expression getInstanceDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    return requiresInjectionMethod(provisionBinding, requestingClass.packageName())
+        ? invokeInjectionMethod(requestingClass)
+        : invokeMethod(requestingClass);
+  }
+
+  private Expression invokeMethod(ClassName requestingClass) {
+    // TODO(dpb): align this with the contents of InlineMethods.create
+    CodeBlock arguments =
+        provisionBinding
+            .dependencies()
+            .stream()
+            .map(request -> dependencyArgument(request, requestingClass))
+            .collect(toParametersCodeBlock());
+    ExecutableElement method = asExecutable(provisionBinding.bindingElement().get());
+    CodeBlock invocation;
+    switch (method.getKind()) {
+      case CONSTRUCTOR:
+        invocation = CodeBlock.of("new $T($L)", constructorTypeName(requestingClass), arguments);
+        break;
+      case METHOD:
+        CodeBlock module =
+            moduleReference(requestingClass)
+                .orElse(CodeBlock.of("$T", provisionBinding.bindingTypeElement().get()));
+        invocation = maybeCheckForNulls(
+            CodeBlock.of("$L.$L($L)", module, method.getSimpleName(), arguments));
+        break;
+      default:
+        throw new IllegalStateException();
+    }
+    return Expression.create(provisionBinding.key().type(), invocation);
+  }
+
+  private TypeName constructorTypeName(ClassName requestingClass) {
+    DeclaredType type = MoreTypes.asDeclared(provisionBinding.key().type());
+    TypeName typeName = TypeName.get(type);
+    if (type.getTypeArguments()
+        .stream()
+        .allMatch(t -> isTypeAccessibleFrom(t, requestingClass.packageName()))) {
+      return typeName;
+    }
+    return rawTypeName(typeName);
+  }
+
+  private Expression invokeInjectionMethod(ClassName requestingClass) {
+    return injectMembers(
+        maybeCheckForNulls(
+            ProvisionMethod.invoke(
+                provisionBinding,
+                request -> dependencyArgument(request, requestingClass),
+                requestingClass,
+                moduleReference(requestingClass))));
+  }
+
+  private CodeBlock dependencyArgument(DependencyRequest dependency, ClassName requestingClass) {
+    return componentBindingExpressions
+        .getDependencyArgumentExpression(dependency, requestingClass)
+        .codeBlock();
+  }
+
+  private CodeBlock maybeCheckForNulls(CodeBlock methodCall) {
+    return !provisionBinding.bindingKind().equals(INJECTION)
+            && provisionBinding.shouldCheckForNull(compilerOptions)
+        ? checkNotNullProvidesMethod(methodCall)
+        : methodCall;
+  }
+
+  private Expression injectMembers(CodeBlock instance) {
+    if (provisionBinding.injectionSites().isEmpty()) {
+      return Expression.create(provisionBinding.key().type(), instance);
+    }
+    // Java 7 type inference can't figure out that instance in
+    // injectParameterized(Parameterized_Factory.newParameterized()) is Parameterized<T> and not
+    // Parameterized<Object>
+    if (!MoreTypes.asDeclared(provisionBinding.key().type()).getTypeArguments().isEmpty()) {
+      TypeName keyType = TypeName.get(provisionBinding.key().type());
+      instance = CodeBlock.of("($T) ($T) $L", keyType, rawTypeName(keyType), instance);
+    }
+
+    MethodSpec membersInjectionMethod =
+        generatedComponentModel.getMembersInjectionMethod(provisionBinding.key());
+    TypeMirror returnType =
+        membersInjectionMethod.returnType.equals(TypeName.OBJECT)
+            ? elements.getTypeElement(Object.class.getCanonicalName()).asType()
+            : provisionBinding.key().type();
+    return Expression.create(returnType, CodeBlock.of("$N($L)", membersInjectionMethod, instance));
+  }
+
+  private Optional<CodeBlock> moduleReference(ClassName requestingClass) {
+    return provisionBinding.requiresModuleInstance()
+        ? provisionBinding
+            .contributingModule()
+            .map(Element::asType)
+            .map(ComponentRequirement::forModule)
+            .map(
+                requirement ->
+                    componentRequirementFields.getExpression(requirement, requestingClass))
+        : Optional.empty();
+  }
+}
diff --git a/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java b/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
deleted file mode 100644
index 8c7fb6dfb..000000000
--- a/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.MoreElements.asExecutable;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.Proxies.proxyName;
-import static dagger.internal.codegen.Proxies.requiresProxyAccess;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.TypeNames.rawTypeName;
-import static java.util.stream.Collectors.collectingAndThen;
-import static java.util.stream.Collectors.toList;
-import static javax.lang.model.element.Modifier.STATIC;
-
-import com.google.common.util.concurrent.Futures;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.TypeName;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * A request fulfillment implementation that invokes methods or constructors directly to fulfill
- * requests whenever possible. In cases where direct invocation is not possible, this implementation
- * delegates to one that uses a {@link javax.inject.Provider}.
- */
-final class SimpleMethodRequestFulfillment extends RequestFulfillment {
-
-  private final ProvisionBinding provisionBinding;
-  private final RequestFulfillment providerDelegate;
-  private final RequestFulfillmentRegistry registry;
-
-  SimpleMethodRequestFulfillment(
-      BindingKey bindingKey,
-      ProvisionBinding provisionBinding,
-      RequestFulfillment providerDelegate,
-      RequestFulfillmentRegistry registry) {
-    super(bindingKey);
-    checkArgument(
-        provisionBinding.implicitDependencies().isEmpty(),
-        "framework deps are not currently supported");
-    checkArgument(!provisionBinding.scope().isPresent());
-    checkArgument(!provisionBinding.requiresModuleInstance());
-    checkArgument(provisionBinding.bindingElement().isPresent());
-    this.provisionBinding = provisionBinding;
-    this.providerDelegate = providerDelegate;
-    this.registry = registry;
-  }
-
-  @Override
-  CodeBlock getSnippetForDependencyRequest(DependencyRequest request, ClassName requestingClass) {
-    switch (request.kind()) {
-      case INSTANCE:
-        return invokeMethodOrProxy(requestingClass);
-      case FUTURE:
-        return CodeBlock.of(
-            "$T.immediateFuture($L)", Futures.class, invokeMethodOrProxy(requestingClass));
-      default:
-        return providerDelegate.getSnippetForDependencyRequest(request, requestingClass);
-    }
-  }
-
-  @Override
-  CodeBlock getSnippetForFrameworkDependency(
-      FrameworkDependency frameworkDependency, ClassName requestingClass) {
-    return providerDelegate.getSnippetForFrameworkDependency(frameworkDependency, requestingClass);
-  }
-
-  private CodeBlock invokeMethodOrProxy(ClassName requestingClass) {
-    ExecutableElement bindingElement = asExecutable(provisionBinding.bindingElement().get());
-    return requiresProxyAccess(bindingElement, requestingClass.packageName())
-        ? invokeProxyMethod(requestingClass)
-        : invokeMethod(requestingClass);
-  }
-
-  private CodeBlock invokeMethod(ClassName requestingClass) {
-    CodeBlock parametersCodeBlock =
-        makeParametersCodeBlock(
-            provisionBinding
-                .explicitDependencies()
-                .stream()
-                .map(
-                    request -> {
-                      CodeBlock snippet = getDependencySnippet(requestingClass, request);
-                      TypeMirror requestElementType = request.requestElement().get().asType();
-                      return isTypeAccessibleFrom(requestElementType, requestingClass.packageName())
-                          ? snippet
-                          : CodeBlock.of(
-                              "($T) $L", rawTypeName(TypeName.get(requestElementType)), snippet);
-                    })
-                .collect(toList()));
-    // we use the type from the key to ensure we get the right generics
-    // TODO(gak): use <>?
-    ExecutableElement method = asExecutable(provisionBinding.bindingElement().get());
-    switch (method.getKind()) {
-      case CONSTRUCTOR:
-        return CodeBlock.of("new $T($L)", provisionBinding.key().type(), parametersCodeBlock);
-      case METHOD:
-        checkState(method.getModifiers().contains(STATIC));
-        return CodeBlock.of(
-            "$T.$L($L)",
-            provisionBinding.bindingTypeElement().get(),
-            method.getSimpleName(),
-            parametersCodeBlock);
-      default:
-        throw new IllegalStateException();
-    }
-  }
-
-  private CodeBlock invokeProxyMethod(ClassName requestingClass) {
-    return CodeBlock.of(
-        "$T.$L($L)",
-        generatedClassNameForBinding(provisionBinding),
-        proxyName(asExecutable(provisionBinding.bindingElement().get())),
-        provisionBinding
-            .explicitDependencies()
-            .stream()
-            .map(request -> getDependencySnippet(requestingClass, request))
-            .collect(collectingAndThen(toList(), CodeBlocks::makeParametersCodeBlock)));
-  }
-
-  private CodeBlock getDependencySnippet(ClassName requestingClass, DependencyRequest request) {
-    return registry
-        .getRequestFulfillment(request.bindingKey())
-        .getSnippetForDependencyRequest(request, requestingClass);
-  }
-}
diff --git a/java/dagger/internal/codegen/SourceFiles.java b/java/dagger/internal/codegen/SourceFiles.java
index 1d73fb369..3f0299ee1 100644
--- a/java/dagger/internal/codegen/SourceFiles.java
+++ b/java/dagger/internal/codegen/SourceFiles.java
@@ -19,28 +19,49 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_SET;
 import static dagger.internal.codegen.Optionals.optionalComparator;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
+import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
+import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCED_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
 import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
+import static dagger.internal.codegen.TypeNames.SET_FACTORY;
+import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
+import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
+import static dagger.internal.codegen.Util.toImmutableList;
+import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.Comparator.comparing;
 import static javax.lang.model.SourceVersion.isName;
 
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Joiner;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
+import dagger.internal.SetFactory;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.internal.SetOfProducedProducer;
+import dagger.producers.internal.SetProducer;
 import java.util.Comparator;
 import java.util.Iterator;
+import java.util.List;
+import javax.inject.Provider;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -105,7 +126,7 @@
   private static String fieldNameForDependency(ImmutableSet<DependencyRequest> dependencyRequests) {
     // collect together all of the names that we would want to call the provider
     ImmutableSet<String> dependencyNames =
-        FluentIterable.from(dependencyRequests).transform(new DependencyVariableNamer()).toSet();
+        dependencyRequests.stream().map(DependencyVariableNamer::name).collect(toImmutableSet());
 
     if (dependencyNames.size() == 1) {
       // if there's only one name, great! use it!
@@ -144,6 +165,19 @@ static CodeBlock frameworkTypeUsageStatement(
     }
   }
 
+  /**
+   * Returns a mapping of {@link DependencyRequest}s to {@link CodeBlock}s that {@linkplain
+   * #frameworkTypeUsageStatement(CodeBlock, DependencyRequest.Kind) use them}.
+   */
+  static ImmutableMap<DependencyRequest, CodeBlock> frameworkFieldUsages(
+      ImmutableSet<DependencyRequest> dependencies, ImmutableMap<BindingKey, FieldSpec> fields) {
+    return Maps.toMap(
+        dependencies,
+        dep ->
+            frameworkTypeUsageStatement(
+                CodeBlock.of("$N", fields.get(dep.bindingKey())), dep.kind()));
+  }
+
   /**
    * Returns the generated factory or members injector name for a binding.
    */
@@ -211,6 +245,43 @@ private static ClassName siblingClassName(TypeElement typeElement, String suffix
     return className.topLevelClassName().peerClass(classFileName(className) + suffix);
   }
 
+  /**
+   * The {@link java.util.Set} factory class name appropriate for set bindings.
+   *
+   * <ul>
+   * <li>{@link SetFactory} for provision bindings.
+   * <li>{@link SetProducer} for production bindings for {@code Set<T>}.
+   * <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
+   * </ul>
+   */
+  static ClassName setFactoryClassName(ContributionBinding binding) {
+    checkArgument(binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_SET));
+    if (binding.bindingType().equals(BindingType.PROVISION)) {
+      return SET_FACTORY;
+    } else {
+      SetType setType = SetType.from(binding.key());
+      return setType.elementsAreTypeOf(Produced.class) ? SET_OF_PRODUCED_PRODUCER : SET_PRODUCER;
+    }
+  }
+
+  /** The {@link java.util.Map} factory class name appropriate for map bindings. */
+  static ClassName mapFactoryClassName(ContributionBinding binding) {
+    checkState(binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP), binding.bindingKind());
+    MapType mapType = MapType.from(binding.key());
+    switch (binding.bindingType()) {
+      case PROVISION:
+        return mapType.valuesAreTypeOf(Provider.class) ? MAP_PROVIDER_FACTORY : MAP_FACTORY;
+      case PRODUCTION:
+        return mapType.valuesAreFrameworkType()
+            ? mapType.valuesAreTypeOf(Producer.class)
+                ? MAP_OF_PRODUCER_PRODUCER
+                : MAP_OF_PRODUCED_PRODUCER
+            : MAP_PRODUCER;
+      default:
+        throw new IllegalArgumentException(binding.bindingType().toString());
+    }
+  }
+
   private static String factoryPrefix(ContributionBinding binding) {
     switch (binding.bindingKind()) {
       case INJECTION:
@@ -234,12 +305,9 @@ private static String factoryPrefix(ContributionBinding binding) {
         return ImmutableList.of();
       }
     }
-    ImmutableList.Builder<TypeVariableName> builder = ImmutableList.builder();
-    for (TypeParameterElement typeParameter :
-        binding.bindingTypeElement().get().getTypeParameters()) {
-      builder.add(TypeVariableName.get(typeParameter));
-    }
-    return builder.build();
+    List<? extends TypeParameterElement> typeParameters =
+        binding.bindingTypeElement().get().getTypeParameters();
+    return typeParameters.stream().map(TypeVariableName::get).collect(toImmutableList());
   }
 
   /**
diff --git a/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java b/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
new file mode 100644
index 000000000..5215bced9
--- /dev/null
+++ b/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+
+/** A binding expression for a subcomponent builder that just invokes the constructor. */
+final class SubcomponentBuilderBindingExpression extends SimpleInvocationBindingExpression {
+  private final String subcomponentBuilderName;
+  private final ContributionBinding binding;
+
+  SubcomponentBuilderBindingExpression(
+      BindingExpression delegate,
+      ContributionBinding binding,
+      String subcomponentBuilderName,
+      DaggerTypes types) {
+    super(delegate, types);
+    this.subcomponentBuilderName = subcomponentBuilderName;
+    this.binding = binding;
+  }
+
+  @Override
+  Expression getInstanceDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    return Expression.create(
+        binding.key().type(), CodeBlock.of("new $LBuilder()", subcomponentBuilderName));
+  }
+}
diff --git a/java/dagger/internal/codegen/SubcomponentWriter.java b/java/dagger/internal/codegen/SubcomponentWriter.java
index 8f143819c..65a0bbcc7 100644
--- a/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -18,13 +18,8 @@
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Sets.difference;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.MemberSelect.localField;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -32,7 +27,9 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.CaseFormat;
+import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
@@ -77,32 +74,13 @@ private static ClassName subcomponentName(AbstractComponentWriter parent, Bindin
   }
 
   @Override
-  protected InitializationState getInitializationState(BindingKey bindingKey) {
-    InitializationState initializationState = super.getInitializationState(bindingKey);
-    return initializationState.equals(UNINITIALIZED)
-        ? parent.getInitializationState(bindingKey)
-        : initializationState;
-  }
-
-  @Override
-  protected Optional<CodeBlock> getOrCreateComponentRequirementFieldExpression(
-      ComponentRequirement componentRequirement) {
-    Optional<CodeBlock> expression =
-        super.getOrCreateComponentRequirementFieldExpression(componentRequirement);
-    return expression.isPresent()
-        ? expression
-        : parent.getOrCreateComponentRequirementFieldExpression(componentRequirement);
-  }
-
-  @Override
-  public MemberSelect getMemberSelect(BindingKey key) {
-    MemberSelect memberSelect = super.getMemberSelect(key);
-    return memberSelect == null ? parent.getMemberSelect(key) : memberSelect;
+  public CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
+    return parent.getReferenceReleasingProviderManagerExpression(scope);
   }
 
   @Override
-  protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
-    return parent.getReferenceReleasingProviderManagerExpression(scope);
+  protected boolean requiresReleasableReferences(Scope scope) {
+    return parent.requiresReleasableReferences(scope);
   }
 
   private ExecutableType resolvedSubcomponentFactoryMethod() {
@@ -128,26 +106,6 @@ protected void decorateComponent() {
                 : resolvedSubcomponentFactoryMethod().getReturnType()));
   }
 
-  @Override
-  protected void addBuilder() {
-    // Only write subcomponent builders if there is a spec.
-    if (graph.componentDescriptor().builderSpec().isPresent()) {
-      super.addBuilder();
-    }
-  }
-
-  @Override
-  protected ClassName builderName() {
-    return name.peerClass(subcomponentNames.get(graph.componentDescriptor()) + "Builder");
-  }
-
-  @Override
-  protected TypeSpec.Builder createBuilder(String builderSimpleName) {
-    // Only write subcomponent builders if there is a spec.
-    verify(graph.componentDescriptor().builderSpec().isPresent());
-    return classBuilder(builderSimpleName);
-  }
-
   @Override
   protected void addBuilderClass(TypeSpec builder) {
     parent.component.addType(builder);
@@ -168,7 +126,7 @@ protected void addFactoryMethods() {
     ExecutableType resolvedMethod = resolvedSubcomponentFactoryMethod();
     componentMethod.returns(ClassName.get(resolvedMethod.getReturnType()));
     writeSubcomponentWithoutBuilder(componentMethod, resolvedMethod);
-    parent.component.addMethod(componentMethod.build());
+    parent.interfaceMethods.add(componentMethod.build());
   }
 
   private void writeSubcomponentWithoutBuilder(
@@ -184,7 +142,7 @@ private void writeSubcomponentWithoutBuilder(
           ComponentRequirement.forModule(moduleTypeElement.asType());
       TypeName moduleType = TypeName.get(paramTypes.get(i));
       componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
-      if (!componentContributionFields.containsKey(componentRequirement)) {
+      if (!componentRequirementFields.contains(componentRequirement)) {
         String preferredModuleName =
             CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleTypeElement.getSimpleName().toString());
         FieldSpec contributionField =
@@ -193,23 +151,23 @@ private void writeSubcomponentWithoutBuilder(
                 .build();
         component.addField(contributionField);
 
-        String actualModuleName = contributionField.name;
         constructor
-            .addParameter(moduleType, actualModuleName)
+            .addParameter(moduleType, contributionField.name)
             .addStatement(
-                "this.$1L = $2T.checkNotNull($1L)",
-                actualModuleName,
-                Preconditions.class);
+                "this.$1N = $2T.checkNotNull($1N)", contributionField, Preconditions.class);
 
-        MemberSelect moduleSelect = localField(name, actualModuleName);
-        componentContributionFields.put(componentRequirement, moduleSelect);
+        componentRequirementFields.add(
+            ComponentRequirementField.componentField(
+                componentRequirement, contributionField, name));
         subcomponentConstructorParameters.add(
             CodeBlock.of("$L", moduleVariable.getSimpleName()));
       }
     }
 
     Set<ComponentRequirement> uninitializedModules =
-        difference(graph.componentRequirements(), componentContributionFields.keySet());
+        Sets.filter(
+            graph.componentRequirements(),
+            Predicates.not(componentRequirementFields::contains));
 
     for (ComponentRequirement componentRequirement : uninitializedModules) {
       checkState(componentRequirement.kind().equals(ComponentRequirement.Kind.MODULE));
@@ -221,11 +179,10 @@ private void writeSubcomponentWithoutBuilder(
               .addModifiers(PRIVATE, FINAL)
               .build();
       component.addField(contributionField);
-      String actualModuleName = contributionField.name;
-      constructor.addStatement(
-          "this.$L = new $T()", actualModuleName, ClassName.get(moduleType));
-      MemberSelect moduleSelect = localField(name, actualModuleName);
-      componentContributionFields.put(componentRequirement, moduleSelect);
+      constructor.addStatement("this.$N = new $T()", contributionField, ClassName.get(moduleType));
+      componentRequirementFields.add(
+          ComponentRequirementField.componentField(
+              componentRequirement, contributionField, name));
     }
 
     componentMethod.addStatement("return new $T($L)",
diff --git a/java/dagger/internal/codegen/UniqueNameSet.java b/java/dagger/internal/codegen/UniqueNameSet.java
index 27a275ceb..11c48b30a 100644
--- a/java/dagger/internal/codegen/UniqueNameSet.java
+++ b/java/dagger/internal/codegen/UniqueNameSet.java
@@ -19,9 +19,7 @@
 import java.util.HashSet;
 import java.util.Set;
 
-/**
- * A collector for names to be used in the same namespace that should not conflict.
- */
+/** A collector for names to be used in the same namespace that should not conflict. */
 final class UniqueNameSet {
   private final Set<String> uniqueNames = new HashSet<>();
 
@@ -36,4 +34,12 @@ String getUniqueName(CharSequence base) {
     }
     return name;
   }
+
+  /**
+   * Adds {@code name} without any modification to the name set. Has no effect if {@code name} is
+   * already present in the set.
+   */
+  void claim(CharSequence name) {
+    uniqueNames.add(name.toString());
+  }
 }
diff --git a/java/dagger/internal/codegen/Util.java b/java/dagger/internal/codegen/Util.java
index 60c3df38f..821ab513c 100644
--- a/java/dagger/internal/codegen/Util.java
+++ b/java/dagger/internal/codegen/Util.java
@@ -25,6 +25,8 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import java.util.Map;
+import java.util.function.Function;
 import java.util.stream.Collector;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
@@ -102,5 +104,21 @@ private static boolean requiresEnclosingInstance(TypeElement typeElement) {
     return collectingAndThen(toList(), ImmutableSet::copyOf);
   }
 
+  /**
+   * A version of {@link Map#computeIfAbsent(Object, Function)} that allows {@code mappingFunction}
+   * to update {@code map}.
+   */
+  static <K, V> V reentrantComputeIfAbsent(
+      Map<K, V> map, K key, Function<? super K, ? extends V> mappingFunction) {
+    V value = map.get(key);
+    if (value == null) {
+      value = mappingFunction.apply(key);
+      if (value != null) {
+        map.put(key, value);
+      }
+    }
+    return value;
+  }
+
   private Util() {}
 }
diff --git a/java/dagger/producers/internal/MapOfProducedProducer.java b/java/dagger/producers/internal/MapOfProducedProducer.java
index 7fe2ce488..6a50b22a9 100644
--- a/java/dagger/producers/internal/MapOfProducedProducer.java
+++ b/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -16,20 +16,22 @@
 
 package dagger.producers.internal;
 
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Futures.transform;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static dagger.producers.internal.Producers.producerFromProvider;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.List;
 import java.util.Map;
+import javax.inject.Provider;
 
 /**
  * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a
@@ -39,48 +41,22 @@
  * @author Jesse Beder
  */
 public final class MapOfProducedProducer<K, V> extends AbstractProducer<Map<K, Produced<V>>> {
-  private final Producer<Map<K, Producer<V>>> mapProducerProducer;
+  private final Map<K, Producer<V>> mapOfProducers;
 
-  private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
-    this.mapProducerProducer = mapProducerProducer;
-  }
-
-  /**
-   * Returns a producer of {@code Map<K, Produced<V>>}, where the map is derived from the given map
-   * of producers by waiting for those producers' resulting futures. The iteration order mirrors the
-   * order of the input map.
-   *
-   * <p>If any of the delegate producers, or their resulting values, are null, then this producer's
-   * future will succeed and the corresponding {@code Produced<V>} will fail with a
-   * {@link NullPointerException}.
-   *
-   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
-   * component futures fails or is canceled, this one is, too.
-   */
-  public static <K, V> MapOfProducedProducer<K, V> create(
-      Producer<Map<K, Producer<V>>> mapProducerProducer) {
-    return new MapOfProducedProducer<K, V>(mapProducerProducer);
+  private MapOfProducedProducer(Map<K, Producer<V>> mapOfProducers) {
+    this.mapOfProducers = mapOfProducers;
   }
 
   @Override
   public ListenableFuture<Map<K, Produced<V>>> compute() {
-    return Futures.transformAsync(
-        mapProducerProducer.get(),
-        new AsyncFunction<Map<K, Producer<V>>, Map<K, Produced<V>>>() {
+    return Futures.transform(
+        Futures.allAsList(
+            Iterables.transform(
+                mapOfProducers.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
+        new Function<List<Map.Entry<K, Produced<V>>>, Map<K, Produced<V>>>() {
           @Override
-          public ListenableFuture<Map<K, Produced<V>>> apply(final Map<K, Producer<V>> map) {
-            // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
-            return transform(
-                Futures.allAsList(
-                    Iterables.transform(
-                        map.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
-                new Function<List<Map.Entry<K, Produced<V>>>, Map<K, Produced<V>>>() {
-                  @Override
-                  public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
-                    return ImmutableMap.copyOf(entries);
-                  }
-                },
-                directExecutor());
+          public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
+            return ImmutableMap.copyOf(entries);
           }
         },
         directExecutor());
@@ -114,4 +90,35 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
           entryUnwrapper() {
     return (Function) ENTRY_UNWRAPPER;
   }
+
+  /** Returns a new {@link Builder}. */
+  public static <K, V> Builder<K, V> builder() {
+    return new Builder<>();
+  }
+
+  /** A builder for {@link MapOfProducedProducer}. */
+  public static final class Builder<K, V> {
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder = ImmutableMap.builder();
+
+    /** Returns a new {@link MapOfProducedProducer}. */
+    public MapOfProducedProducer<K, V> build() {
+      return new MapOfProducedProducer<>(mapBuilder.build());
+    }
+
+    /** Associates {@code key} with {@code producerOfValue}. */
+    public Builder<K, V> put(K key, Producer<V> producerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(producerOfValue, "producer of value");
+      mapBuilder.put(key, producerOfValue);
+      return this;
+    }
+
+    /** Associates {@code key} with {@code providerOfValue}. */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(providerOfValue, "provider of value");
+      mapBuilder.put(key, producerFromProvider(providerOfValue));
+      return this;
+    }
+  }
 }
diff --git a/java/dagger/producers/internal/MapOfProducerProducer.java b/java/dagger/producers/internal/MapOfProducerProducer.java
index 5eef863c3..282cf86a1 100644
--- a/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -17,7 +17,6 @@
 package dagger.producers.internal;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize;
 import static dagger.producers.internal.Producers.producerFromProvider;
 
 import com.google.common.collect.ImmutableMap;
@@ -34,20 +33,11 @@
  * @author Jesse Beder
  */
 public final class MapOfProducerProducer<K, V> extends AbstractProducer<Map<K, Producer<V>>> {
-  private static final MapOfProducerProducer<Object, Object> EMPTY =
-      new MapOfProducerProducer<Object, Object>(ImmutableMap.<Object, Producer<Object>>of());
-
   private final ImmutableMap<K, Producer<V>> contributingMap;
 
   /** Returns a new {@link Builder}. */
-  public static <K, V> Builder<K, V> builder(int size) {
-    return new Builder<K, V>(size);
-  }
-
-  /** Returns a producer of an empty map. */
-  @SuppressWarnings("unchecked") // safe contravariant cast
-  public static <K, V> MapOfProducerProducer<K, V> empty() {
-    return (MapOfProducerProducer<K, V>) EMPTY;
+  public static <K, V> Builder<K, V> builder() {
+    return new Builder<>();
   }
 
   private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
@@ -59,22 +49,11 @@ private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
     return Futures.<Map<K, Producer<V>>>immediateFuture(contributingMap);
   }
 
-  /**
-   * A builder to help build the {@link MapOfProducerProducer}
-   */
+  /** A builder for {@link MapOfProducerProducer} */
   public static final class Builder<K, V> {
-    private final Map<K, Producer<V>> mapBuilder;
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder = ImmutableMap.builder();
 
-    private Builder(int size) {
-      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
-    }
-
-    /** Returns a new {@link MapOfProducerProducer}. */
-    public MapOfProducerProducer<K, V> build() {
-      return new MapOfProducerProducer<K, V>(ImmutableMap.copyOf(mapBuilder));
-    }
-
-    /** Associates key with producerOfValue in {@code Builder}. */
+    /** Associates {@code key} with {@code producerOfValue}. */
     public Builder<K, V> put(K key, Producer<V> producerOfValue) {
       checkNotNull(key, "key");
       checkNotNull(producerOfValue, "producer of value");
@@ -82,12 +61,17 @@ private Builder(int size) {
       return this;
     }
 
-    /** Associates key with providerOfValue in {@code Builder}. */
+    /** Associates {@code key} with {@code providerOfValue}. */
     public Builder<K, V> put(K key, Provider<V> providerOfValue) {
       checkNotNull(key, "key");
       checkNotNull(providerOfValue, "provider of value");
       mapBuilder.put(key, producerFromProvider(providerOfValue));
       return this;
     }
+
+    /** Returns a new {@link MapOfProducerProducer}. */
+    public MapOfProducerProducer<K, V> build() {
+      return new MapOfProducerProducer<>(mapBuilder.build());
+    }
   }
 }
diff --git a/java/dagger/producers/internal/MapProducer.java b/java/dagger/producers/internal/MapProducer.java
index 1a13b9d53..ca1650e08 100644
--- a/java/dagger/producers/internal/MapProducer.java
+++ b/java/dagger/producers/internal/MapProducer.java
@@ -16,19 +16,21 @@
 
 package dagger.producers.internal;
 
-import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static dagger.producers.internal.Producers.producerFromProvider;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
+import javax.inject.Provider;
 
 /**
  * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a
@@ -37,73 +39,64 @@
  * @author Jesse Beder
  */
 public final class MapProducer<K, V> extends AbstractProducer<Map<K, V>> {
-  private final Producer<Map<K, Producer<V>>> mapProducerProducer;
+  private final ImmutableMap<K, Producer<V>> mapOfProducers;
 
-  private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
-    this.mapProducerProducer = mapProducerProducer;
+  private MapProducer(ImmutableMap<K, Producer<V>> mapOfProducers) {
+    this.mapOfProducers = mapOfProducers;
   }
 
-  /**
-   * Returns a producer of {@code Map<K, V>}, where the map is derived from the given map of
-   * producers by waiting for those producers' resulting futures. The iteration order mirrors the
-   * order of the input map.
-   *
-   * <p>If any of the delegate producers, or their resulting values, are null, then this producer's
-   * future will fail with a {@link NullPointerException}.
-   *
-   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
-   * component futures fails or is canceled, this one is, too.
-   */
-  public static <K, V> MapProducer<K, V> create(Producer<Map<K, Producer<V>>> mapProducerProducer) {
-    return new MapProducer<K, V>(mapProducerProducer);
+  /** Returns a new {@link Builder}. */
+  public static <K, V> Builder<K, V> builder() {
+    return new Builder<>();
   }
 
-  @Override
-  public ListenableFuture<Map<K, V>> compute() {
-    return Futures.transformAsync(
-        mapProducerProducer.get(),
-        new AsyncFunction<Map<K, Producer<V>>, Map<K, V>>() {
-          @Override
-          public ListenableFuture<Map<K, V>> apply(final Map<K, Producer<V>> map) {
-            // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
-            return transform(
-                Futures.allAsList(
-                    Iterables.transform(map.entrySet(), MapProducer.<K, V>entryUnwrapper())),
-                new Function<List<Map.Entry<K, V>>, Map<K, V>>() {
-                  @Override
-                  public Map<K, V> apply(List<Map.Entry<K, V>> entries) {
-                    return ImmutableMap.copyOf(entries);
-                  }
-                },
-                directExecutor());
-          }
-        },
-        directExecutor());
+  /** A builder for {@link MapProducer} */
+  public static final class Builder<K, V> {
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder = ImmutableMap.builder();
+
+    /** Associates {@code key} with {@code producerOfValue}. */
+    public Builder<K, V> put(K key, Producer<V> producerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(producerOfValue, "producer of value");
+      mapBuilder.put(key, producerOfValue);
+      return this;
+    }
+
+    /** Associates {@code key} with {@code providerOfValue}. */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(providerOfValue, "provider of value");
+      mapBuilder.put(key, producerFromProvider(providerOfValue));
+      return this;
+    }
+
+    /** Returns a new {@link MapProducer}. */
+    public MapProducer<K, V> build() {
+      return new MapProducer<>(mapBuilder.build());
+    }
   }
 
-  private static final Function<
-          Map.Entry<Object, Producer<Object>>, ListenableFuture<Map.Entry<Object, Object>>>
-      ENTRY_UNWRAPPER =
-          new Function<
-              Map.Entry<Object, Producer<Object>>, ListenableFuture<Map.Entry<Object, Object>>>() {
+  @Override
+  protected ListenableFuture<Map<K, V>> compute() {
+    final List<ListenableFuture<Map.Entry<K, V>>> listOfEntries = new ArrayList<>();
+    for (final Entry<K, Producer<V>> entry : mapOfProducers.entrySet()) {
+      listOfEntries.add(
+          Futures.transform(entry.getValue().get(), new Function<V, Entry<K, V>>() {
             @Override
-            public ListenableFuture<Map.Entry<Object, Object>> apply(
-                final Map.Entry<Object, Producer<Object>> entry) {
-              return transform(
-                  entry.getValue().get(),
-                  new Function<Object, Map.Entry<Object, Object>>() {
-                    @Override
-                    public Map.Entry<Object, Object> apply(Object value) {
-                      return Maps.immutableEntry(entry.getKey(), value);
-                    }
-                  },
-                  directExecutor());
+            public Entry<K, V> apply(V computedValue) {
+              return Maps.immutableEntry(entry.getKey(), computedValue);
             }
-          };
+          }, directExecutor()));
+    }
 
-  @SuppressWarnings({"unchecked", "rawtypes"}) // bivariate implementation
-  private static <K, V>
-      Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, V>>> entryUnwrapper() {
-    return (Function) ENTRY_UNWRAPPER;
+    return Futures.transform(
+        Futures.allAsList(listOfEntries),
+        new Function<List<Map.Entry<K, V>>, Map<K, V>>() {
+          @Override
+          public Map<K, V> apply(List<Map.Entry<K, V>> entries) {
+            return ImmutableMap.copyOf(entries);
+          }
+        },
+        directExecutor());
   }
 }
diff --git a/java/dagger/producers/internal/Producers.java b/java/dagger/producers/internal/Producers.java
index 029bcb51a..3a603bebe 100644
--- a/java/dagger/producers/internal/Producers.java
+++ b/java/dagger/producers/internal/Producers.java
@@ -22,6 +22,7 @@
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
 import com.google.common.base.Function;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
@@ -29,6 +30,7 @@
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
 
@@ -123,9 +125,9 @@
    */
   public static <T> Producer<T> producerFromProvider(final Provider<T> provider) {
     checkNotNull(provider);
-    return new AbstractProducer<T>() {
+    return new Producer<T>() {
       @Override
-      protected ListenableFuture<T> compute() {
+      public ListenableFuture<T> get() {
         return Futures.immediateFuture(provider.get());
       }
     };
@@ -151,5 +153,13 @@
     };
   }
 
+  private static final Producer<Map<Object, Object>> EMPTY_MAP_PRODUCER =
+      Producers.<Map<Object, Object>>immediateProducer(ImmutableMap.of());
+
+  @SuppressWarnings("unchecked") // safe contravariant cast
+  public static <K, V> Producer<Map<K, V>> emptyMapProducer() {
+    return (Producer<Map<K, V>>) (Producer) EMPTY_MAP_PRODUCER;
+  }
+
   private Producers() {}
 }
diff --git a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
index f3779bf0c..271bafc94 100644
--- a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
+++ b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
@@ -58,6 +58,7 @@
         ActivitySubcomponent.class,
         ParentFragmentSubcomponent.class,
         ChildFragmentSubcomponent.class,
+        DialogFragmentSubcomponent.class,
         ServiceSubcomponent.class,
         IntentServiceSubcomponent.class,
         BroadcastReceiverSubcomponent.class,
@@ -89,6 +90,12 @@
       abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForChildFragment(
           ChildFragmentSubcomponent.Builder builder);
 
+      @Binds
+      @IntoMap
+      @FragmentKey(TestDialogFragment.class)
+      abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForDialogFragment(
+          DialogFragmentSubcomponent.Builder builder);
+
       @Binds
       @IntoMap
       @ServiceKey(TestService.class)
@@ -159,6 +166,21 @@
       abstract class Builder extends AndroidInjector.Builder<TestChildFragment> {}
     }
 
+    @Subcomponent(modules = DialogFragmentSubcomponent.DialogFragmentModule.class)
+    interface DialogFragmentSubcomponent extends AndroidInjector<TestDialogFragment> {
+      @Module
+      abstract class DialogFragmentModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return DialogFragmentSubcomponent.class;
+        }
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestDialogFragment> {}
+    }
+
     @Subcomponent(modules = ServiceModule.class)
     interface ServiceSubcomponent extends AndroidInjector<TestService> {
       @Subcomponent.Builder
diff --git a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
index 6e60b4f92..9490f48e5 100644
--- a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
+++ b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
@@ -104,7 +104,7 @@
 
     @Subcomponent(modules = ActivitySubcomponent.ActivityModule.class)
     interface ActivitySubcomponent extends AndroidInjector<TestActivity> {
-      @Module(subcomponents = ParentFragmentSubcomponent.class)
+      @Module(subcomponents = {ParentFragmentSubcomponent.class, DialogFragmentSubcomponent.class})
       abstract class ActivityModule {
         @Provides
         @IntoSet
@@ -117,6 +117,12 @@
         @FragmentKey(TestParentFragment.class)
         abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForParentFragment(
             ParentFragmentSubcomponent.Builder builder);
+
+        @Binds
+        @IntoMap
+        @FragmentKey(TestDialogFragment.class)
+        abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForDialogFragment(
+            DialogFragmentSubcomponent.Builder builder);
       }
 
       @Subcomponent.Builder
@@ -157,6 +163,21 @@
           abstract class Builder extends AndroidInjector.Builder<TestChildFragment> {}
         }
       }
+
+      @Subcomponent(modules = DialogFragmentSubcomponent.DialogFragmentModule.class)
+      interface DialogFragmentSubcomponent extends AndroidInjector<TestDialogFragment> {
+        @Module
+        abstract class DialogFragmentModule {
+          @Provides
+          @IntoSet
+          static Class<?> addToComponentHierarchy() {
+            return DialogFragmentSubcomponent.class;
+          }
+        }
+
+        @Subcomponent.Builder
+        abstract class Builder extends AndroidInjector.Builder<TestDialogFragment> {}
+      }
     }
 
     @Subcomponent(modules = ServiceModule.class)
diff --git a/javatests/dagger/android/support/functional/InjectorsTest.java b/javatests/dagger/android/support/functional/InjectorsTest.java
index 578f19b10..7303e2b1c 100644
--- a/javatests/dagger/android/support/functional/InjectorsTest.java
+++ b/javatests/dagger/android/support/functional/InjectorsTest.java
@@ -39,6 +39,7 @@
   private TestActivity activity;
   private TestParentFragment parentFragment;
   private TestChildFragment childFragment;
+  private TestDialogFragment dialogFragment;
   private TestService service;
   private TestIntentService intentService;
   private TestBroadcastReceiver broadcastReceiver;
@@ -54,6 +55,9 @@ public void setUp() {
     childFragment =
         (TestChildFragment)
             parentFragment.getChildFragmentManager().findFragmentByTag("child-fragment");
+    dialogFragment =
+        (TestDialogFragment)
+            activity.getSupportFragmentManager().findFragmentByTag("dialog-fragment");
 
     service = Robolectric.buildService(TestService.class).create().get();
     intentService = Robolectric.buildIntentService(TestIntentService.class).create().get();
@@ -91,6 +95,13 @@ public void componentStructureFollowsControllerStructure() {
                 .ActivitySubcomponent.ParentFragmentSubcomponent.class,
             ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
                 .ActivitySubcomponent.ParentFragmentSubcomponent.ChildFragmentSubcomponent.class);
+    assertThat(dialogFragment.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.DialogFragmentSubcomponent.class);
 
     assertThat(service.componentHierarchy)
         .containsExactly(
@@ -136,6 +147,11 @@ public void allControllersAreDirectChildrenOfApplication() {
             AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
             AllControllersAreDirectChildrenOfApplication.ApplicationComponent
                 .ChildFragmentSubcomponent.class);
+    assertThat(dialogFragment.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .DialogFragmentSubcomponent.class);
 
     assertThat(service.componentHierarchy)
         .containsExactly(
@@ -178,6 +194,10 @@ public void usesGeneratedModules() {
         .containsExactly(
             UsesGeneratedModulesApplication.ApplicationComponent.class,
             UsesGeneratedModulesApplication.DummyChildFragmentSubcomponent.class);
+    assertThat(dialogFragment.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyDialogFragmentSubcomponent.class);
 
     assertThat(service.componentHierarchy)
         .containsExactly(
diff --git a/javatests/dagger/android/support/functional/TestActivity.java b/javatests/dagger/android/support/functional/TestActivity.java
index c4fda4293..84c44fda8 100644
--- a/javatests/dagger/android/support/functional/TestActivity.java
+++ b/javatests/dagger/android/support/functional/TestActivity.java
@@ -33,6 +33,7 @@ protected void onCreate(Bundle savedInstanceState) {
     getSupportFragmentManager()
         .beginTransaction()
         .add(new TestParentFragment(), "parent-fragment")
+        .add(new TestDialogFragment(), "dialog-fragment")
         .commit();
   }
 }
diff --git a/javatests/dagger/android/support/functional/TestDialogFragment.java b/javatests/dagger/android/support/functional/TestDialogFragment.java
new file mode 100644
index 000000000..d499ee535
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestDialogFragment.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import dagger.android.support.DaggerAppCompatDialogFragment;
+import java.util.Set;
+import javax.inject.Inject;
+
+public class TestDialogFragment extends DaggerAppCompatDialogFragment {
+  @Inject Set<Class<?>> componentHierarchy;
+}
diff --git a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
index ff43e3959..661426244 100644
--- a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
+++ b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
@@ -61,6 +61,9 @@
     @ContributesAndroidInjector(modules = DummyChildFragmentSubcomponent.AddToHierarchy.class)
     abstract TestChildFragment contributeTestChildFragmentInjector();
 
+    @ContributesAndroidInjector(modules = DummyDialogFragmentSubcomponent.AddToHierarchy.class)
+    abstract TestDialogFragment contributeTestDialogFragmentInjector();
+
     @ContributesAndroidInjector(modules = DummyServiceSubcomponent.AddToHierarchy.class)
     abstract TestService contributeTestServiceInjector();
 
@@ -120,6 +123,17 @@ static String provideScopedString() {
     }
   }
 
+  interface DummyDialogFragmentSubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyDialogFragmentSubcomponent.class;
+      }
+    }
+  }
+
   interface DummyServiceSubcomponent {
     @Module
     abstract class AddToHierarchy {
diff --git a/javatests/dagger/functional/GenericParent.java b/javatests/dagger/functional/GenericParent.java
index 658530e52..13f9e2f9c 100644
--- a/javatests/dagger/functional/GenericParent.java
+++ b/javatests/dagger/functional/GenericParent.java
@@ -24,17 +24,28 @@
   Provider<X> registeredX;
   Y registeredY;
   B registeredB;
+  Parameterized<Y> registerParameterizedOfY;
   
   @Inject GenericParent() {}
   
   @Inject Provider<X> x;
   @Inject Y y;
   @Inject B b;
-  
+  @Inject Parameterized<X> parameterizedOfX;
+
   @Inject
   void registerX(Provider<X> x) {
     this.registeredX = x;
   }
   @Inject void registerY(Y y) { this.registeredY = y; }
   @Inject void registerB(B b) { this.registeredB = b; }
+  @Inject void registerParameterizedOfY(Parameterized<Y> parameterizedOfY) {
+    this.registerParameterizedOfY = parameterizedOfY;
+  }
+
+  static class Parameterized<P> {
+    @Inject P p;
+
+    @Inject Parameterized() {}
+  }
 }
diff --git a/javatests/dagger/functional/InjectedThing.java b/javatests/dagger/functional/InjectedThing.java
index c518faafc..3041fb0ba 100644
--- a/javatests/dagger/functional/InjectedThing.java
+++ b/javatests/dagger/functional/InjectedThing.java
@@ -159,6 +159,7 @@
       Thing thing,
       Provider<Thing> thingProvider,
       Lazy<Thing> lazyThing,
+      Provider<Lazy<Thing>> lazyThingProvider,
       MembersInjector<Thing> thingMembersInjector) {}
 
   @Inject void primitiveByte(byte primitiveByte) {}
@@ -222,6 +223,7 @@
   @Inject void lazyLongArray(Lazy<long[]> lazyLongArray) {}
   @Inject void lazyBooleanArray(Lazy<boolean[]> lazyBooleanArray) {}
   @Inject void lazy(Lazy<float[]> lazy) {}
+  @Inject void lazyThingProvider(Provider<Lazy<Thing>> lazyThingProvider) {}
   @Inject void lazyDoubleArray(Lazy<double[]> lazyDoubleArray) {}
 
   @Inject void thing(Thing thing) {}
diff --git a/javatests/dagger/functional/LazyMaps.java b/javatests/dagger/functional/LazyMaps.java
new file mode 100644
index 000000000..eeb136849
--- /dev/null
+++ b/javatests/dagger/functional/LazyMaps.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.StringKey;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Provider;
+import javax.inject.Singleton;
+
+/**
+ * Bindings that use {@code Lazy<T>} as the value in a multibound map. A regression was uncovered
+ * when using {@code MapType.valuesAreFrameworkType()}, which treats {@link Lazy} as a framework
+ * type and incorrectly suggested {@link dagger.internal.MapProviderFactory} for a {@code Map<K,
+ * Lazy<V>>} instead of a plain {@link dagger.internal.MapFactory}. See b/65084589.
+ */
+class LazyMaps {
+  @Module
+  abstract static class TestModule {
+    @Provides
+    @Singleton
+    static AtomicInteger provideAtomicInteger() {
+      return new AtomicInteger();
+    }
+
+    @Provides
+    static String provideString(AtomicInteger atomicInteger) {
+      return "value-" + atomicInteger.incrementAndGet();
+    }
+
+    @Provides
+    @IntoMap
+    @StringKey("key")
+    static Lazy<String> mapContribution(Lazy<String> lazy) {
+      return lazy;
+    }
+
+    /* TODO(b/65118638) Replace once @Binds @IntoMap Lazy<T> methods work properly.
+    @Binds
+    @IntoMap
+    @StringKey("binds-key")
+    abstract Lazy<String> mapContributionAsBinds(Lazy<String> lazy);
+    */
+  }
+
+  @Singleton
+  @Component(modules = TestModule.class)
+  interface TestComponent {
+    Map<String, Lazy<String>> mapOfLazy();
+
+    Map<String, Provider<Lazy<String>>> mapOfProviderOfLazy();
+
+    Provider<Map<String, Lazy<String>>> providerForMapOfLazy();
+
+    Provider<Map<String, Provider<Lazy<String>>>> providerForMapOfProviderOfLazy();
+  }
+}
diff --git a/javatests/dagger/functional/LazyMapsTest.java b/javatests/dagger/functional/LazyMapsTest.java
new file mode 100644
index 000000000..a3e289a4c
--- /dev/null
+++ b/javatests/dagger/functional/LazyMapsTest.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Lazy;
+import dagger.functional.LazyMaps.TestComponent;
+import java.util.Map;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link LazyMaps}. */
+@RunWith(JUnit4.class)
+public class LazyMapsTest {
+  @Test
+  public void mapOfLazies() {
+    TestComponent component = DaggerLazyMaps_TestComponent.create();
+    Map<String, Lazy<String>> laziesMap = component.mapOfLazy();
+
+    String firstGet = laziesMap.get("key").get();
+    assertThat(firstGet).isEqualTo("value-1");
+    assertThat(firstGet).isSameAs(laziesMap.get("key").get());
+
+    assertThat(component.mapOfLazy().get("key").get()).isEqualTo("value-2");
+  }
+
+  @Test
+  public void mapOfProviderOfLaziesReturnsDifferentLazy() {
+    TestComponent component = DaggerLazyMaps_TestComponent.create();
+    Map<String, Provider<Lazy<String>>> providersOfLaziesMap = component.mapOfProviderOfLazy();
+
+    assertThat(providersOfLaziesMap.get("key").get().get())
+        .isNotEqualTo(providersOfLaziesMap.get("key").get().get());
+  }
+}
diff --git a/javatests/dagger/functional/binds/AccessesExposedComponent.java b/javatests/dagger/functional/binds/AccessesExposedComponent.java
new file mode 100644
index 000000000..e43eedb71
--- /dev/null
+++ b/javatests/dagger/functional/binds/AccessesExposedComponent.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.binds;
+
+import dagger.Component;
+import dagger.functional.binds.subpackage.Exposed;
+import dagger.functional.binds.subpackage.ExposedModule;
+import dagger.functional.binds.subpackage.UsesExposedInjectsMembers;
+import java.util.List;
+import javax.inject.Provider;
+import javax.inject.Singleton;
+
+/**
+ * This component tests cases where the right-hand-side of a {@link dagger.Binds} method is not
+ * accessible from the component, but the left-hand-side is. If the right-hand-side is represented
+ * as a Provider (e.g. because it is scoped), then the raw {@code Provider.get()} will return {@link
+ * Object}, which must be downcasted to the type accessible from the component. See {@code
+ * instanceRequiresCast()} in {@link dagger.internal.codegen.DelegateBindingExpression}.
+ */
+@Singleton
+@Component(modules = ExposedModule.class)
+interface AccessesExposedComponent {
+  Exposed exposed();
+  Provider<Exposed> exposedProvider();
+
+  List<? extends Exposed> listOfExposed();
+  Provider<List<? extends Exposed>> providerOfListOfExposed();
+
+  UsesExposedInjectsMembers usesExposedInjectsMembers();
+}
diff --git a/javatests/dagger/functional/binds/subpackage/Exposed.java b/javatests/dagger/functional/binds/subpackage/Exposed.java
new file mode 100644
index 000000000..885aee4a7
--- /dev/null
+++ b/javatests/dagger/functional/binds/subpackage/Exposed.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.binds.subpackage;
+
+public interface Exposed {}
\ No newline at end of file
diff --git a/javatests/dagger/functional/binds/subpackage/ExposedInjectsMembers.java b/javatests/dagger/functional/binds/subpackage/ExposedInjectsMembers.java
new file mode 100644
index 000000000..074289c0d
--- /dev/null
+++ b/javatests/dagger/functional/binds/subpackage/ExposedInjectsMembers.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.binds.subpackage;
+
+public interface ExposedInjectsMembers {}
diff --git a/javatests/dagger/functional/binds/subpackage/ExposedModule.java b/javatests/dagger/functional/binds/subpackage/ExposedModule.java
new file mode 100644
index 000000000..a2660d95c
--- /dev/null
+++ b/javatests/dagger/functional/binds/subpackage/ExposedModule.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.binds.subpackage;
+
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.List;
+import javax.inject.Singleton;
+
+@Module
+public abstract class ExposedModule {
+  @Binds
+  abstract Exposed notExposed(NotExposed notExposed);
+
+  @Provides
+  @Singleton // force a rawtypes Provider
+  static List<NotExposed> notExposedList() {
+    return new ArrayList<>();
+  }
+
+  @Binds
+  abstract List<? extends Exposed> bindList(List<NotExposed> notExposedList);
+
+  @Binds
+  abstract ExposedInjectsMembers bindExposedInjectsMembers(
+      NotExposedInjectsMembers notExposedInjectsMembers);
+}
diff --git a/javatests/dagger/functional/binds/subpackage/NotExposed.java b/javatests/dagger/functional/binds/subpackage/NotExposed.java
new file mode 100644
index 000000000..a8774ee27
--- /dev/null
+++ b/javatests/dagger/functional/binds/subpackage/NotExposed.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.binds.subpackage;
+
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton // force a Provider, which will not have a type parameter since this is not public
+class NotExposed implements Exposed {
+  @Inject
+  NotExposed() {}
+}
\ No newline at end of file
diff --git a/java/dagger/internal/codegen/KeyFormatter.java b/javatests/dagger/functional/binds/subpackage/NotExposedInjectsMembers.java
similarity index 66%
rename from java/dagger/internal/codegen/KeyFormatter.java
rename to javatests/dagger/functional/binds/subpackage/NotExposedInjectsMembers.java
index e5d391f63..1f6a1b795 100644
--- a/java/dagger/internal/codegen/KeyFormatter.java
+++ b/javatests/dagger/functional/binds/subpackage/NotExposedInjectsMembers.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 The Dagger Authors.
+ * Copyright (C) 2017 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.functional.binds.subpackage;
 
-/** Formats a {@link Key} into a {@link String} suitable for use in error messages. */
-final class KeyFormatter extends Formatter<Key> {
-  @Override
-  public String format(Key key) {
-    return key.toString();
-  }
+import javax.inject.Inject;
+
+final class NotExposedInjectsMembers implements ExposedInjectsMembers {
+  @Inject Exposed exposed;
+
+  @Inject NotExposedInjectsMembers() {}
 }
diff --git a/java/dagger/internal/codegen/HasBindingMembers.java b/javatests/dagger/functional/binds/subpackage/UsesExposedInjectsMembers.java
similarity index 51%
rename from java/dagger/internal/codegen/HasBindingMembers.java
rename to javatests/dagger/functional/binds/subpackage/UsesExposedInjectsMembers.java
index bc260d65d..3ee2e8fa9 100644
--- a/java/dagger/internal/codegen/HasBindingMembers.java
+++ b/javatests/dagger/functional/binds/subpackage/UsesExposedInjectsMembers.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Dagger Authors.
+ * Copyright (C) 2017 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,18 +14,12 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.functional.binds.subpackage;
 
-import javax.annotation.Nullable;
+import javax.inject.Inject;
 
-/** An object which associates a {@link MemberSelect} instance with a {@link BindingKey}. */
-// TODO(gak): this isn't a particularly good abstraction. This should go away when MS is reworked.
-interface HasBindingMembers {
+public class UsesExposedInjectsMembers {
+  @Inject ExposedInjectsMembers exposedInjectsMembers;
 
-  /**
-   * Returns the {@link MemberSelect} associated with the given {@link BindingKey} or {@code null}
-   * if no association exists.
-   */
-  @Nullable
-  MemberSelect getMemberSelect(BindingKey bindingKey);
+  @Inject UsesExposedInjectsMembers(ExposedInjectsMembers exposedInjectsMembers) {}
 }
diff --git a/javatests/dagger/functional/cycle/CycleTest.java b/javatests/dagger/functional/cycle/CycleTest.java
index 2e3d0c94c..d489bc65f 100644
--- a/javatests/dagger/functional/cycle/CycleTest.java
+++ b/javatests/dagger/functional/cycle/CycleTest.java
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import dagger.functional.cycle.Cycles.A;
+import dagger.functional.cycle.Cycles.BindsCycleComponent;
 import dagger.functional.cycle.Cycles.C;
 import dagger.functional.cycle.Cycles.ChildCycleComponent;
 import dagger.functional.cycle.Cycles.CycleComponent;
@@ -89,4 +90,14 @@ public void providerMapIndirectionCycle() {
     assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y").get().mapOfProvidersOfY).hasSize(1);
     assertThat(cycleMapComponent.y().mapOfProvidersOfY).hasSize(1);
   }
+
+  /**
+   * Tests that a cycle where a {@code @Binds} binding depends on a binding that has to be deferred
+   * works.
+   */
+  @Test
+  public void cycleWithDeferredBinds() {
+    BindsCycleComponent bindsCycleComponent = DaggerCycles_BindsCycleComponent.create();
+    assertThat(bindsCycleComponent.bar()).isNotNull();
+  }
 }
diff --git a/javatests/dagger/functional/cycle/Cycles.java b/javatests/dagger/functional/cycle/Cycles.java
index 2f4cd28f4..488f5a0d0 100644
--- a/javatests/dagger/functional/cycle/Cycles.java
+++ b/javatests/dagger/functional/cycle/Cycles.java
@@ -172,4 +172,26 @@ static Object provideObjectWithCycle(@SuppressWarnings("unused") Provider<Object
     @SuppressWarnings("dependency-cycle")
     Object object();
   }
+
+  interface Foo {}
+
+  static class Bar implements Foo {
+    @Inject
+    Bar(Provider<Foo> fooProvider) {}
+  }
+
+  /**
+   * A component with a cycle in which a {@code @Binds} binding depends on the binding that has to
+   * be deferred.
+   */
+  @Component(modules = BindsCycleModule.class)
+  interface BindsCycleComponent {
+    Bar bar();
+  }
+
+  @Module
+  abstract static class BindsCycleModule {
+    @Binds
+    abstract Foo foo(Bar bar);
+  }
 }
diff --git a/javatests/dagger/functional/cycle/LongCycleTest.java b/javatests/dagger/functional/cycle/LongCycleTest.java
index fd5439556..75bfad460 100644
--- a/javatests/dagger/functional/cycle/LongCycleTest.java
+++ b/javatests/dagger/functional/cycle/LongCycleTest.java
@@ -17,6 +17,7 @@
 package dagger.functional.cycle;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 
 import dagger.functional.cycle.LongCycle.LongCycleComponent;
 import org.junit.Test;
@@ -25,7 +26,7 @@
 
 @RunWith(JUnit4.class)
 public class LongCycleTest {
-  
+
   /**
    * Tests a cycle long enough that the real factory is created in a separate initialize method from
    * the delegate factory.
@@ -42,6 +43,7 @@ public void longCycle() {
    */
   @Test
   public void longCycleHasMoreThanOneInitializeMethod() throws NoSuchMethodException {
+    assume().that(System.getProperty("dagger.mode")).isNotEqualTo("ExperimentalAndroidMode");
     DaggerLongCycle_LongCycleComponent.class
         .getDeclaredMethod("initialize2", DaggerLongCycle_LongCycleComponent.Builder.class);
   }
diff --git a/javatests/dagger/functional/guava/BUILD b/javatests/dagger/functional/guava/BUILD
index d7c0c7389..dd2c8921f 100644
--- a/javatests/dagger/functional/guava/BUILD
+++ b/javatests/dagger/functional/guava/BUILD
@@ -28,6 +28,7 @@ GenJavaTests(
         "//:dagger_with_compiler",
         "//third_party:auto_value",
         "//third_party:guava",
+        "//third_party:jsr305_annotations",
         "//third_party:jsr330_inject",
         "//third_party:junit",
         "//third_party:truth",
diff --git a/javatests/dagger/functional/guava/OptionalBindingComponents.java b/javatests/dagger/functional/guava/OptionalBindingComponents.java
index 548b2bcc2..ee58865c1 100644
--- a/javatests/dagger/functional/guava/OptionalBindingComponents.java
+++ b/javatests/dagger/functional/guava/OptionalBindingComponents.java
@@ -27,6 +27,7 @@
 import dagger.Provides;
 import dagger.Subcomponent;
 import java.lang.annotation.Retention;
+import javax.annotation.Nullable;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
@@ -75,6 +76,9 @@
     @BindsOptionalOf
     @SomeQualifier abstract InjectedThing qualifiedInjectedThing();
 
+    @BindsOptionalOf
+    abstract Object nullableObject();
+
     @Provides
     static Values values(
         Optional<Value> optionalInstance,
@@ -110,6 +114,12 @@ static Value value(Optional<Provider<Value>> cycle) {
     @SomeQualifier static Value qualifiedValue() {
       return Value.QUALIFIED_VALUE;
     }
+
+    @Provides
+    @Nullable
+    static Object nullableObject() {
+      return null;
+    }
   }
 
   /** Interface for components used to test optional bindings. */
@@ -118,6 +128,14 @@ static Value value(Optional<Provider<Value>> cycle) {
 
     @SomeQualifier
     Values qualifiedValues();
+
+    // Nullable bindings can satisfy optional bindings except for Optional<Foo>.
+
+    Optional<Provider<Object>> optionalNullableProvider();
+
+    Optional<Lazy<Object>> optionalNullableLazy();
+
+    Optional<Provider<Lazy<Object>>> optionalNullableLazyProvider();
   }
 
   @Component(modules = OptionalBindingModule.class)
diff --git a/javatests/dagger/functional/guava/OptionalBindingComponentsPresentTest.java b/javatests/dagger/functional/guava/OptionalBindingComponentsPresentTest.java
index cc0832a93..124320730 100644
--- a/javatests/dagger/functional/guava/OptionalBindingComponentsPresentTest.java
+++ b/javatests/dagger/functional/guava/OptionalBindingComponentsPresentTest.java
@@ -82,4 +82,19 @@ public void qualifiedOptionalLazyProvider() {
     assertThat(component.qualifiedValues().optionalLazyProvider().get().get().get())
         .isEqualTo(QUALIFIED_VALUE);
   }
+
+  @Test
+  public void optionalNullableProvider() {
+    assertThat(component.optionalNullableProvider().get().get()).isNull();
+  }
+
+  @Test
+  public void optionalNullableLazy() {
+    assertThat(component.optionalNullableLazy().get().get()).isNull();
+  }
+
+  @Test
+  public void optionalNullableLazyProvider() {
+    assertThat(component.optionalNullableLazyProvider().get().get().get()).isNull();
+  }
 }
diff --git a/javatests/dagger/functional/jdk8/BUILD b/javatests/dagger/functional/jdk8/BUILD
index 5cb4013bd..10108bec2 100644
--- a/javatests/dagger/functional/jdk8/BUILD
+++ b/javatests/dagger/functional/jdk8/BUILD
@@ -32,5 +32,6 @@ GenJavaTests(
     deps = [
         "//:dagger_with_compiler",
         "//third_party:auto_value",
+        "//third_party:jsr305_annotations",
     ],
 )
diff --git a/javatests/dagger/functional/jdk8/OptionalBindingComponents.java b/javatests/dagger/functional/jdk8/OptionalBindingComponents.java
index 04fafa2bd..0048f8b44 100644
--- a/javatests/dagger/functional/jdk8/OptionalBindingComponents.java
+++ b/javatests/dagger/functional/jdk8/OptionalBindingComponents.java
@@ -27,6 +27,7 @@
 import dagger.Subcomponent;
 import java.lang.annotation.Retention;
 import java.util.Optional;
+import javax.annotation.Nullable;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
@@ -75,6 +76,9 @@
     @BindsOptionalOf
     @SomeQualifier abstract InjectedThing qualifiedInjectedThing();
 
+    @BindsOptionalOf
+    abstract Object nullableObject();
+
     @Provides
     static Values values(
         Optional<Value> optionalInstance,
@@ -110,6 +114,12 @@ static Value value(Optional<Provider<Value>> cycle) {
     @SomeQualifier static Value qualifiedValue() {
       return Value.QUALIFIED_VALUE;
     }
+
+    @Provides
+    @Nullable
+    static Object nullableObject() {
+      return null;
+    }
   }
 
   /** Interface for components used to test optional bindings. */
@@ -118,6 +128,14 @@ static Value value(Optional<Provider<Value>> cycle) {
 
     @SomeQualifier
     Values qualifiedValues();
+
+    // Nullable bindings can satisfy optional bindings except for Optional<Foo>.
+
+    Optional<Provider<Object>> optionalNullableProvider();
+
+    Optional<Lazy<Object>> optionalNullableLazy();
+
+    Optional<Provider<Lazy<Object>>> optionalNullableLazyProvider();
   }
 
   @Component(modules = OptionalBindingModule.class)
diff --git a/javatests/dagger/functional/jdk8/OptionalBindingComponentsPresentTest.java b/javatests/dagger/functional/jdk8/OptionalBindingComponentsPresentTest.java
index f2a52ad80..50fbefe4e 100644
--- a/javatests/dagger/functional/jdk8/OptionalBindingComponentsPresentTest.java
+++ b/javatests/dagger/functional/jdk8/OptionalBindingComponentsPresentTest.java
@@ -83,4 +83,19 @@ public void qualifiedOptionalLazyProvider() {
     assertThat(component.qualifiedValues().optionalLazyProvider().get().get().get())
         .isEqualTo(QUALIFIED_VALUE);
   }
+
+  @Test
+  public void optionalNullableProvider() {
+    assertThat(component.optionalNullableProvider().get().get()).isNull();
+  }
+
+  @Test
+  public void optionalNullableLazy() {
+    assertThat(component.optionalNullableLazy().get().get()).isNull();
+  }
+
+  @Test
+  public void optionalNullableLazyProvider() {
+    assertThat(component.optionalNullableLazyProvider().get().get().get()).isNull();
+  }
 }
diff --git a/javatests/dagger/functional/membersinject/MembersInjectionOrdering.java b/javatests/dagger/functional/membersinject/MembersInjectionOrdering.java
new file mode 100644
index 000000000..451e0e392
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/MembersInjectionOrdering.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Inject;
+
+/**
+ * This exhibits a regression case, that albeit weird, is valid according to the JSR 330 spec. JSR
+ * 330 specifies a rough ordering by which members should be injected, and it is possible to rely on
+ * such ordering. When members injecting {@link Subtype}, field injection is guaranteed to be
+ * performed on {@link Base} first. The binding for {@code @FirstToString} in {@link
+ * OrderingModule#provideToString()} relies on this ordering, and thus uses the value in {@link
+ * Base#first} to satisfy the binding.
+ */
+class MembersInjectionOrdering {
+  static class Base {
+    @Inject First first;
+  }
+
+  static class Subtype extends Base {
+    @Inject String firstToString;
+  }
+
+  @Module
+  static class OrderingModule {
+    private final Subtype subtype;
+
+    OrderingModule(Subtype subtype) {
+      this.subtype = subtype;
+    }
+
+    @Provides
+    String provideToString() {
+      return subtype.first.toString();
+    }
+  }
+
+  @Component(modules = OrderingModule.class)
+  interface TestComponent {
+    void inject(Subtype subtype);
+  }
+
+  static class First {
+    @Inject
+    First() {}
+  }
+}
diff --git a/javatests/dagger/functional/membersinject/MembersInjectionOrderingTest.java b/javatests/dagger/functional/membersinject/MembersInjectionOrderingTest.java
new file mode 100644
index 000000000..efd511722
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/MembersInjectionOrderingTest.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+import dagger.functional.membersinject.MembersInjectionOrdering.OrderingModule;
+import dagger.functional.membersinject.MembersInjectionOrdering.Subtype;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MembersInjectionOrderingTest {
+  @Test
+  public void indirection() {
+    Subtype toInject = new Subtype();
+    DaggerMembersInjectionOrdering_TestComponent.builder()
+        .orderingModule(new OrderingModule(toInject))
+        .build()
+        .inject(toInject);
+  }
+}
diff --git a/javatests/dagger/functional/membersinject/MembersWithSameName.java b/javatests/dagger/functional/membersinject/MembersWithSameName.java
new file mode 100644
index 000000000..2b0689816
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/MembersWithSameName.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+import javax.inject.Inject;
+
+// https://github.com/google/dagger/issues/755
+public class MembersWithSameName {
+  @Inject String sameName;
+  boolean sameNameStringWasInvoked;
+  boolean sameNameObjectWasInvoked;
+
+  @Inject void sameName(String sameName) {
+    sameNameStringWasInvoked = true;
+  }
+
+  @Inject void sameName(Object sameName) {
+    sameNameObjectWasInvoked = true;
+  }
+}
diff --git a/javatests/dagger/functional/membersinject/MembersWithSameNameTest.java b/javatests/dagger/functional/membersinject/MembersWithSameNameTest.java
new file mode 100644
index 000000000..0f22bf359
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/MembersWithSameNameTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.functional.membersinject.subpackage.ExtendsMembersWithSameName;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+// https://github.com/google/dagger/issues/755
+@RunWith(JUnit4.class)
+public class MembersWithSameNameTest {
+  @Test
+  public void injectsMaskedMembers() {
+    MembersWithSameName membersWithSameName = new MembersWithSameName();
+    TestComponent component = DaggerMembersWithSameNameTest_TestComponent.create();
+    component.inject(membersWithSameName);
+    verifyBaseClassInjection(membersWithSameName);
+  }
+
+  @Test
+  public void subclassInjectsMaskedMembers() {
+    ExtendsMembersWithSameName extendsMembersWithSameName = new ExtendsMembersWithSameName();
+    TestComponent component = DaggerMembersWithSameNameTest_TestComponent.create();
+    component.inject(extendsMembersWithSameName);
+    verifyBaseClassInjection(extendsMembersWithSameName);
+    verifySubclassInjection(extendsMembersWithSameName);
+  }
+
+  private void verifyBaseClassInjection(MembersWithSameName membersWithSameName) {
+    assertThat(membersWithSameName.sameName).isNotNull();
+    assertThat(membersWithSameName.sameNameStringWasInvoked).isTrue();
+    assertThat(membersWithSameName.sameNameObjectWasInvoked).isTrue();
+  }
+
+  private void verifySubclassInjection(ExtendsMembersWithSameName extendsMembersWithSameName) {
+    assertThat(extendsMembersWithSameName.sameName()).isNotNull();
+    assertThat(extendsMembersWithSameName.sameNameStringWasInvoked()).isTrue();
+    assertThat(extendsMembersWithSameName.sameNameObjectWasInvoked()).isTrue();
+  }
+
+  @Module
+  abstract static class TestModule {
+    @Provides
+    static String provideString() {
+      return "";
+    }
+
+    @Binds
+    abstract Object bindObject(String string);
+  }
+
+  @Component(modules = TestModule.class)
+  interface TestComponent {
+    void inject(MembersWithSameName membersWithSameName);
+    void inject(ExtendsMembersWithSameName extendsMembersWithSameName);
+  }
+}
diff --git a/javatests/dagger/functional/membersinject/subpackage/ExtendsMembersWithSameName.java b/javatests/dagger/functional/membersinject/subpackage/ExtendsMembersWithSameName.java
new file mode 100644
index 000000000..1eb1b159a
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/subpackage/ExtendsMembersWithSameName.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject.subpackage;
+
+import dagger.functional.membersinject.MembersWithSameName;
+import javax.inject.Inject;
+
+// https://github.com/google/dagger/issues/755
+public class ExtendsMembersWithSameName extends MembersWithSameName {
+  @Inject String sameName;
+  private boolean sameNameStringWasInvoked;
+  private boolean sameNameObjectWasInvoked;
+
+  @Inject void sameName(String sameName) {
+    sameNameStringWasInvoked = true;
+  }
+
+  @Inject void sameName(Object sameName) {
+    sameNameObjectWasInvoked = true;
+  }
+
+  public String sameName() {
+    return sameName;
+  }
+  public boolean sameNameStringWasInvoked() {
+    return sameNameStringWasInvoked;
+  }
+  public boolean sameNameObjectWasInvoked() {
+    return sameNameObjectWasInvoked;
+  }
+}
diff --git a/javatests/dagger/functional/multipackage/a/InaccessibleGeneric.java b/javatests/dagger/functional/multipackage/a/InaccessibleGeneric.java
new file mode 100644
index 000000000..f5da79db8
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/a/InaccessibleGeneric.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.a;
+
+import javax.inject.Inject;
+
+final class InaccessibleGeneric<T> {
+  @Inject
+  InaccessibleGeneric() {}
+}
diff --git a/javatests/dagger/functional/multipackage/a/UsesInaccessible.java b/javatests/dagger/functional/multipackage/a/UsesInaccessible.java
index 745bb1dc9..7a8ed7f73 100644
--- a/javatests/dagger/functional/multipackage/a/UsesInaccessible.java
+++ b/javatests/dagger/functional/multipackage/a/UsesInaccessible.java
@@ -26,5 +26,6 @@
   public UsesInaccessible(
       Inaccessible inaccessible,
       Set<Inaccessible> inaccessibleSet,
-      Map<String, Inaccessible> inaccessibleMap) {}
+      Map<String, Inaccessible> inaccessibleMap,
+      InaccessibleGeneric<Integer> inaccessibleGeneric) {}
 }
diff --git a/javatests/dagger/functional/producers/BUILD b/javatests/dagger/functional/producers/BUILD
index 44e1fba86..cf7abf30f 100644
--- a/javatests/dagger/functional/producers/BUILD
+++ b/javatests/dagger/functional/producers/BUILD
@@ -33,6 +33,7 @@ GenJavaTests(
         "//:producers_with_compiler",
         "//third_party:auto_value",
         "//third_party:guava",
+        "//third_party:jsr305_annotations",
         "//third_party:jsr330_inject",
         "//third_party:junit",
         "//third_party:mockito",
diff --git a/javatests/dagger/functional/producers/optional/OptionalBindingComponents.java b/javatests/dagger/functional/producers/optional/OptionalBindingComponents.java
index 6a36127b0..d3a7aa606 100644
--- a/javatests/dagger/functional/producers/optional/OptionalBindingComponents.java
+++ b/javatests/dagger/functional/producers/optional/OptionalBindingComponents.java
@@ -34,6 +34,7 @@
 import java.lang.annotation.Retention;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
+import javax.annotation.Nullable;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
 
@@ -79,6 +80,9 @@ static Executor executor() {
     @SomeQualifier
     abstract Value qualifiedValue();
 
+    @BindsOptionalOf
+    abstract Object nullableObject();
+
     @Produces
     static Values values(
         Optional<Value> optionalInstance,
@@ -112,6 +116,15 @@ static Value value() {
     static Value qualifiedValue() {
       return Value.QUALIFIED_VALUE;
     }
+
+    // @Produces @Nullable has no effect (and ProducesMethodValidator warns when the two are used
+    // together. Use a @Provides method and let it be wrapped into a producerFromProvider for the
+    // purposes of the test
+    @Provides
+    @Nullable
+    static Object nullableObject() {
+      return null;
+    }
   }
 
   /** Binds {@link Value} using {@link Provider}s. */
@@ -127,6 +140,12 @@ static Value value() {
     static Value qualifiedValue() {
       return Value.QUALIFIED_VALUE;
     }
+
+    @Provides
+    @Nullable
+    static Object nullableObject() {
+      return null;
+    }
   }
 
   interface OptionalBindingComponent {
@@ -149,6 +168,11 @@ static Value qualifiedValue() {
 
     @SomeQualifier
     ListenableFuture<Optional<Produced<Value>>> qualifiedOptionalProduced();
+
+    // Nullable bindings can satisfy optional bindings except for Optional<Foo>.
+    ListenableFuture<Optional<Producer<Object>>> optionalNullableProducer();
+
+    ListenableFuture<Optional<Produced<Object>>> optionalNullableProduced();
   }
 
   @ProductionComponent(modules = {ExecutorModule.class, OptionalBindingModule.class})
diff --git a/javatests/dagger/functional/producers/optional/OptionalBindingComponentsPresentTest.java b/javatests/dagger/functional/producers/optional/OptionalBindingComponentsPresentTest.java
index 030ccc669..3e2afd464 100644
--- a/javatests/dagger/functional/producers/optional/OptionalBindingComponentsPresentTest.java
+++ b/javatests/dagger/functional/producers/optional/OptionalBindingComponentsPresentTest.java
@@ -40,7 +40,7 @@
           {DaggerOptionalBindingComponents_PresentOptionalProvisionBindingComponent.create()}
         });
   }
-  
+
   private final OptionalBindingComponent component;
 
   public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {
@@ -77,4 +77,14 @@ public void qualifiedOptionalProducer() throws Exception {
   public void qualifiedOptionalProduced() throws Exception {
     assertThat(component.qualifiedOptionalProduced().get().get().get()).isEqualTo(QUALIFIED_VALUE);
   }
+
+  @Test
+  public void optionalNullableProducer() throws Exception {
+    assertThat(component.optionalNullableProducer().get().get().get().get()).isNull();
+  }
+
+  @Test
+  public void optionalNullableProduced() throws Exception {
+    assertThat(component.optionalNullableProduced().get().get().get()).isNull();
+  }
 }
diff --git a/javatests/dagger/functional/subcomponent/SubcomponentTest.java b/javatests/dagger/functional/subcomponent/SubcomponentTest.java
index 68d19d3a7..84c11f896 100644
--- a/javatests/dagger/functional/subcomponent/SubcomponentTest.java
+++ b/javatests/dagger/functional/subcomponent/SubcomponentTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.collect.Sets.intersection;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 
 import java.util.Arrays;
 import java.util.Collection;
@@ -32,23 +33,22 @@
   private static final ParentComponent parentComponent = DaggerParentComponent.create();
   private static final ParentOfGenericComponent parentOfGenericComponent =
       DaggerParentOfGenericComponent.create();
-  
+
   @Parameters
   public static Collection<Object[]> parameters() {
     return Arrays.asList(new Object[][] {
         { parentComponent, parentComponent.newChildComponent() },
         { parentComponent, parentComponent.newChildAbstractClassComponent() },
         { parentOfGenericComponent, parentOfGenericComponent.subcomponent() }});
-  }        
-  
+  }
+
   private final ParentGetters parentGetters;
   private final ChildComponent childComponent;
-  
+
   public SubcomponentTest(ParentGetters parentGetters, ChildComponent childComponent) {
     this.parentGetters = parentGetters;
     this.childComponent = childComponent;
   }
-  
 
   @Test
   public void scopePropagatesUpward_class() {
@@ -86,6 +86,7 @@ public void multibindingContributions() {
 
   @Test
   public void unscopedProviders() {
+    assume().that(System.getProperty("dagger.mode")).isNotEqualTo("ExperimentalAndroidMode");
     assertThat(parentGetters.getUnscopedTypeProvider())
         .isSameAs(childComponent.getUnscopedTypeProvider());
     assertThat(parentGetters.getUnscopedTypeProvider())
diff --git a/javatests/dagger/internal/SetBuilderTest.java b/javatests/dagger/internal/SetBuilderTest.java
new file mode 100644
index 000000000..ac7831234
--- /dev/null
+++ b/javatests/dagger/internal/SetBuilderTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static org.junit.Assert.fail;
+
+import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class SetBuilderTest {
+  private SetBuilder<String> setBuilder;
+
+  @Before
+  public void setUp() {
+    setBuilder = SetBuilder.newSetBuilder(1);
+  }
+
+  @Test
+  public void addNull() {
+    try {
+      setBuilder.add(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test
+  public void addNullCollection() {
+    try {
+      setBuilder.addAll(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test
+  public void addNullElement() {
+    try {
+      setBuilder.addAll(Arrays.asList("hello", null, "world"));
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+}
diff --git a/javatests/dagger/internal/codegen/BUILD b/javatests/dagger/internal/codegen/BUILD
index 49e155225..824d0749e 100644
--- a/javatests/dagger/internal/codegen/BUILD
+++ b/javatests/dagger/internal/codegen/BUILD
@@ -23,6 +23,7 @@ load("//:test_defs.bzl", "GenJavaTests")
 GenJavaTests(
     name = "compiler_tests",
     srcs = glob(["*.java"]),
+    functional = False,
     javacopts = DOCLINT_HTML_AND_SYNTAX,
     deps = [
         "//java/dagger:core",
@@ -33,6 +34,7 @@ GenJavaTests(
         "//third_party:compile_testing",
         "//third_party:guava",
         "//third_party:javapoet",
+        "//third_party:jsr250_annotations",
         "//third_party:jsr330_inject",
         "//third_party:junit",
         "//third_party:mockito",
diff --git a/javatests/dagger/internal/codegen/CompilerMode.java b/javatests/dagger/internal/codegen/CompilerMode.java
new file mode 100644
index 000000000..3b4a2e8ea
--- /dev/null
+++ b/javatests/dagger/internal/codegen/CompilerMode.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+
+/** The configuration options for compiler modes. */
+enum CompilerMode {
+  DEFAULT,
+  EXPERIMENTAL_ANDROID("-Adagger.experimentalAndroidMode=enabled");
+
+  /** Returns the compiler modes as a list of parameters for parameterized tests */
+  static final ImmutableList<Object[]> TEST_PARAMETERS =
+      ImmutableList.copyOf(
+          new Object[][] {
+            {CompilerMode.DEFAULT}, {CompilerMode.EXPERIMENTAL_ANDROID},
+          });
+
+  private final ImmutableList<String> javacopts;
+
+  private CompilerMode(String... javacopts) {
+    this.javacopts = ImmutableList.copyOf(javacopts);
+  }
+
+  /** Returns the javacopts for this compiler mode. */
+  FluentIterable<String> javacopts() {
+    return FluentIterable.from(javacopts);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/Compilers.java b/javatests/dagger/internal/codegen/Compilers.java
index a42d1a2ff..fed935886 100644
--- a/javatests/dagger/internal/codegen/Compilers.java
+++ b/javatests/dagger/internal/codegen/Compilers.java
@@ -16,15 +16,31 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
+import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;
 import static com.google.testing.compile.Compiler.javac;
+import static java.util.stream.Collectors.joining;
 
+import com.google.auto.value.processor.AutoAnnotationProcessor;
+import com.google.common.base.Splitter;
+import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compiler;
 
 /** {@link Compiler} instances for testing Dagger. */
 final class Compilers {
+  private static final String GUAVA = "guava";
+
+  static final ImmutableList<String> CLASS_PATH_WITHOUT_GUAVA_OPTION =
+      ImmutableList.of(
+          "-classpath",
+          Splitter.on(PATH_SEPARATOR.value())
+              .splitToList(JAVA_CLASS_PATH.value())
+              .stream()
+              .filter(jar -> !jar.contains(GUAVA))
+              .collect(joining(PATH_SEPARATOR.value())));
 
   /** Returns a compiler that runs the Dagger processor. */
   static Compiler daggerCompiler() {
-    return javac().withProcessors(new ComponentProcessor());
+    return javac().withProcessors(new ComponentProcessor(), new AutoAnnotationProcessor());
   }
 }
diff --git a/javatests/dagger/internal/codegen/ComponentBuilderTest.java b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
index d3ae193b5..b152c20b9 100644
--- a/javatests/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
@@ -16,24 +16,33 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
-import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 /** Tests for {@link dagger.Component.Builder} */
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class ComponentBuilderTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public ComponentBuilderTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
 
   private static final ErrorMessages.ComponentBuilderMessages MSGS =
       ErrorMessages.ComponentBuilderMessages.INSTANCE;
@@ -67,45 +76,86 @@ public void testEmptyBuilder() {
             "     SimpleComponent build();",
             "  }",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static SimpleComponent.Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType();",
-            "  }",
-            "",
-            "  private static final class Builder implements SimpleComponent.Builder {",
-            "    @Override",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(injectableTypeFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static SimpleComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return getSomeInjectableTypeInstance();",
+                "  }",
+                "",
+                "  private static final class Builder implements SimpleComponent.Builder {",
+                "    @Override",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static SimpleComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  private static final class Builder implements SimpleComponent.Builder {",
+                "    @Override",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectableTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test
@@ -140,66 +190,128 @@ public void testUsesBuildAndSetterNames() {
             "    TestComponent create();",
             "  }",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<String> stringProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static TestComponent.Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().create();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
-            "  }",
-            "",
-            "  @Override",
-            "  public String string() {",
-            "    return stringProvider.get();",
-            "  }",
-            "",
-            "  private static final class Builder implements TestComponent.Builder {",
-            "    private TestModule testModule;",
-            "",
-            "    @Override",
-            "    public TestComponent create() {",
-            "      if (testModule == null) {",
-            "        this.testModule = new TestModule();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    @Override",
-            "    public Builder setTestModule(TestModule testModule) {",
-            "      this.testModule = Preconditions.checkNotNull(testModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule testModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static TestComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().create();",
+                "  }",
+                "",
+                "  private String getStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule.string()," + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule = builder.testModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public String string() {",
+                "    return getStringInstance();",
+                "  }",
+                "",
+                "  private static final class Builder implements TestComponent.Builder {",
+                "    private TestModule testModule;",
+                "",
+                "    @Override",
+                "    public TestComponent create() {",
+                "      if (testModule == null) {",
+                "        this.testModule = new TestModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Override",
+                "    public Builder setTestModule(TestModule testModule) {",
+                "      this.testModule = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule testModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static TestComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().create();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule = builder.testModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public String string() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule.string()," + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private static final class Builder implements TestComponent.Builder {",
+                "    private TestModule testModule;",
+                "",
+                "    @Override",
+                "    public TestComponent create() {",
+                "      if (testModule == null) {",
+                "        this.testModule = new TestModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Override",
+                "    public Builder setTestModule(TestModule testModule) {",
+                "      this.testModule = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(moduleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test
@@ -247,77 +359,158 @@ public void testIgnoresModulesNotInApi() {
             "    TestComponent build();",
             "  }",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<String> stringProvider;",
-            "  private Provider<Integer> integerProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static TestComponent.Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
-            "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
-            "  }",
-            "",
-            "  @Override",
-            "  public String string() {",
-            "    return stringProvider.get();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Integer integer() {",
-            "    return integerProvider.get();",
-            "  }",
-            "",
-            "  private static final class Builder implements TestComponent.Builder {",
-            "    private TestModule1 testModule1;",
-            "    private TestModule2 testModule2;",
-            "",
-            "    @Override",
-            "    public TestComponent build() {",
-            "      if (testModule1 == null) {",
-            "        this.testModule1 = new TestModule1();",
-            "      }",
-            "      if (testModule2 == null) {",
-            "        this.testModule2 = new TestModule2();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    @Override",
-            "    public Builder testModule1(TestModule1 testModule1) {",
-            "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(module1, module2, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule1 testModule1;",
+                "  private TestModule2 testModule2;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static TestComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private String getStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule1.string()," + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Integer getIntegerInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule2.integer()," + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule1 = builder.testModule1;",
+                "    this.testModule2 = builder.testModule2;",
+                "  }",
+                "",
+                "  @Override",
+                "  public String string() {",
+                "    return getStringInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Integer integer() {",
+                "    return getIntegerInstance();",
+                "  }",
+                "",
+                "  private static final class Builder implements TestComponent.Builder {",
+                "    private TestModule1 testModule1;",
+                "    private TestModule2 testModule2;",
+                "",
+                "    @Override",
+                "    public TestComponent build() {",
+                "      if (testModule1 == null) {",
+                "        this.testModule1 = new TestModule1();",
+                "      }",
+                "      if (testModule2 == null) {",
+                "        this.testModule2 = new TestModule2();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Override",
+                "    public Builder testModule1(TestModule1 testModule1) {",
+                "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule1 testModule1;",
+                "  private TestModule2 testModule2;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static TestComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule1 = builder.testModule1;",
+                "    this.testModule2 = builder.testModule2;",
+                "  }",
+                "",
+                "  @Override",
+                "  public String string() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule1.string()," + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public Integer integer() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule2.integer()," + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private static final class Builder implements TestComponent.Builder {",
+                "    private TestModule1 testModule1;",
+                "    private TestModule2 testModule2;",
+                "",
+                "    @Override",
+                "    public TestComponent build() {",
+                "      if (testModule1 == null) {",
+                "        this.testModule1 = new TestModule1();",
+                "      }",
+                "      if (testModule2 == null) {",
+                "        this.testModule2 = new TestModule2();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Override",
+                "    public Builder testModule1(TestModule1 testModule1) {",
+                "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module1, module2, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test
@@ -342,15 +535,15 @@ public void testMoreThanOneBuilderFails() {
             "     SimpleComponent build();",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 MSGS.moreThanOne(),
                 "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
-        .in(componentFile);
+        .inFile(componentFile);
   }
 
   @Test
@@ -370,12 +563,10 @@ public void testBuilderGenericsFails() {
             "     SimpleComponent build();",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.generics())
-        .in(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.generics()).inFile(componentFile);
   }
 
   @Test
@@ -389,12 +580,10 @@ public void testBuilderNotInComponentFails() {
             "",
             "@Component.Builder",
             "interface Builder {}");
-    assertAbout(javaSource())
-        .that(builder)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeInComponent())
-        .in(builder);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(builder);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.mustBeInComponent()).inFile(builder);
   }
 
   @Test
@@ -412,12 +601,10 @@ public void testBuilderMissingBuildMethodFails() {
             "  @Component.Builder",
             "  interface Builder {}",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.missingBuildMethod())
-        .in(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.missingBuildMethod()).inFile(componentFile);
   }
 
   @Test
@@ -447,17 +634,14 @@ public void testBuilderBindsInstanceNoCreateGenerated() {
             "test.DaggerSimpleComponent",
             "package test;",
             "",
-            "import dagger.internal.InstanceFactory;",
             "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private Provider<Object> objectProvider;",
+            "  private Object object;",
             "",
             "  private DaggerSimpleComponent(Builder builder) {",
-            "    assert builder != null;",
             "    initialize(builder);",
             "  }",
             "",
@@ -467,12 +651,12 @@ public void testBuilderBindsInstanceNoCreateGenerated() {
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.objectProvider = InstanceFactory.create(builder.object);",
+            "    this.object = builder.object;",
             "  }",
             "",
             "  @Override",
             "  public Object object() {",
-            "    return objectProvider.get();",
+            "    return object;",
             "  }",
             "",
             "  private static final class Builder implements SimpleComponent.Builder {",
@@ -495,7 +679,8 @@ public void testBuilderBindsInstanceNoCreateGenerated() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).succeededWithoutWarnings();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -517,12 +702,10 @@ public void testPrivateBuilderFails() {
             "  @Component.Builder",
             "  private interface Builder {}",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.isPrivate())
-        .in(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.isPrivate()).inFile(componentFile);
   }
 
   @Test
@@ -540,12 +723,10 @@ public void testNonStaticBuilderFails() {
             "  @Component.Builder",
             "  abstract class Builder {}",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeStatic())
-        .in(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.mustBeStatic()).inFile(componentFile);
   }
 
   @Test
@@ -563,11 +744,10 @@ public void testNonAbstractBuilderFails() {
             "  @Component.Builder",
             "  static class Builder {}",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeAbstract());
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.mustBeAbstract()).inFile(componentFile);
   }
 
   @Test
@@ -587,12 +767,10 @@ public void testBuilderOneCxtorWithArgsFails() {
             "    Builder(String unused) {}",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
-        .in(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.cxtorOnlyOneAndNoArgs()).inFile(componentFile);
   }
 
   @Test
@@ -613,12 +791,10 @@ public void testBuilderMoreThanOneCxtorFails() {
             "    Builder(String unused) {}",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
-        .in(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.cxtorOnlyOneAndNoArgs()).inFile(componentFile);
   }
 
   @Test
@@ -636,12 +812,10 @@ public void testBuilderEnumFails() {
             "  @Component.Builder",
             "  enum Builder {}",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeClassOrInterface())
-        .in(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.mustBeClassOrInterface()).inFile(componentFile);
   }
 
   @Test
@@ -661,13 +835,13 @@ public void testBuilderBuildReturnsWrongTypeFails() {
             "    String build();",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.buildMustReturnComponentType())
-        .in(componentFile)
-        .onLine(10);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.buildMustReturnComponentType())
+        .inFile(componentFile)
+        .onLineContaining("String build();");
   }
 
   @Test
@@ -689,13 +863,13 @@ public void testInheritedBuilderBuildReturnsWrongTypeFails() {
             "  @Component.Builder",
             "  interface Builder extends Parent {}",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
-        .in(componentFile)
-        .onLine(13);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+        .inFile(componentFile)
+        .onLineContaining("interface Builder");
   }
 
   @Test
@@ -716,13 +890,13 @@ public void testTwoBuildMethodsFails() {
             "    SimpleComponent create();",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
-        .in(componentFile)
-        .onLine(11);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(String.format(MSGS.twoBuildMethods(), "build"))
+        .inFile(componentFile)
+        .onLineContaining("SimpleComponent create();");
   }
 
   @Test
@@ -745,13 +919,13 @@ public void testInheritedTwoBuildMethodsFails() {
             "  @Component.Builder",
             "  interface Builder extends Parent {}",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
-        .in(componentFile)
-        .onLine(14);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
+        .inFile(componentFile)
+        .onLineContaining("interface Builder");
   }
 
   @Test
@@ -773,17 +947,17 @@ public void testMoreThanOneArgFails() {
             "    Builder set(Number n, Double d);",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMustTakeOneArg())
-        .in(componentFile)
-        .onLine(11)
-        .and()
-        .withErrorContaining(MSGS.methodsMustTakeOneArg())
-        .in(componentFile)
-        .onLine(12);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.methodsMustTakeOneArg())
+        .inFile(componentFile)
+        .onLineContaining("Builder set(String s, Integer i);");
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.methodsMustTakeOneArg())
+        .inFile(componentFile)
+        .onLineContaining("Builder set(Number n, Double d);");
   }
 
   @Test
@@ -806,15 +980,15 @@ public void testInheritedMoreThanOneArgFails() {
             "  @Component.Builder",
             "  interface Builder extends Parent {}",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 MSGS.inheritedMethodsMustTakeOneArg(), "set1(java.lang.String,java.lang.Integer)"))
-        .in(componentFile)
-        .onLine(14);
+        .inFile(componentFile)
+        .onLineContaining("interface Builder");
   }
 
   @Test
@@ -835,13 +1009,13 @@ public void testSetterReturningNonVoidOrBuilderFails() {
             "    String set(Integer i);",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
-        .in(componentFile)
-        .onLine(11);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
+        .inFile(componentFile)
+        .onLineContaining("String set(Integer i);");
   }
 
   @Test
@@ -864,14 +1038,14 @@ public void testInheritedSetterReturningNonVoidOrBuilderFails() {
             "  @Component.Builder",
             "  interface Builder extends Parent {}",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(), "set(java.lang.Integer)"))
-        .in(componentFile)
-        .onLine(14);
+        .inFile(componentFile)
+        .onLineContaining("interface Builder");
   }
 
   @Test
@@ -892,13 +1066,13 @@ public void testGenericsOnSetterMethodFails() {
             "    <T> Builder set(T t);",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
-        .in(componentFile)
-        .onLine(11);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
+        .inFile(componentFile)
+        .onLineContaining("<T> Builder set(T t);");
   }
 
   @Test
@@ -921,14 +1095,14 @@ public void testGenericsOnInheritedSetterMethodFails() {
             "  @Component.Builder",
             "  interface Builder extends Parent {}",
             "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
-        .in(componentFile)
-        .onLine(14);
+        .inFile(componentFile)
+        .onLineContaining("interface Builder");
   }
 
   @Test
@@ -964,17 +1138,17 @@ public void testMultipleSettersPerTypeFails() {
             "    void set2(TestModule s);",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(moduleFile, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 MSGS.manyMethodsForType(),
                 "test.TestModule",
                 "[set1(test.TestModule), set2(test.TestModule)]"))
-        .in(componentFile)
-        .onLine(11);
+        .inFile(componentFile)
+        .onLineContaining("interface Builder");
   }
 
   @Test
@@ -1013,15 +1187,15 @@ public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
             "    void set2(TestModule s);",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(moduleFile, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 MSGS.manyMethodsForType(), "test.TestModule", "[set1(T), set2(test.TestModule)]"))
-        .in(componentFile)
-        .onLine(15);
+        .inFile(componentFile)
+        .onLineContaining("interface Builder");
   }
 
   @Test
@@ -1032,7 +1206,6 @@ public void testExtraSettersFails() {
             "package test;",
             "",
             "import dagger.Component;",
-            "",
             "import javax.inject.Provider;",
             "",
             "@Component(modules = AbstractModule.class)",
@@ -1053,17 +1226,19 @@ public void testExtraSettersFails() {
             "",
             "@Module",
             "abstract class AbstractModule {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(componentFile, abstractModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(componentFile, abstractModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 MSGS.extraSetters(),
                 "[void test.SimpleComponent.Builder.abstractModule(test.AbstractModule), "
                     + "void test.SimpleComponent.Builder.other(String)]"))
-        .in(componentFile)
-        .onLine(10);
+        .inFile(componentFile)
+        .onLineContaining("interface Builder");
   }
 
   @Test
@@ -1133,17 +1308,18 @@ public void testMissingSettersFail() {
             "",
             "@Component",
             "interface OtherComponent {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, module2File, module3File, componentFile, otherComponent))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .compile(moduleFile, module2File, module3File, componentFile, otherComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             // Ignores Test2Module because we can construct it ourselves.
             // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
             String.format(
                 MSGS.missingSetters(), "[test.TestModule, test.Test3Module, test.OtherComponent]"))
-        .in(componentFile)
-        .onLine(12);
+        .inFile(componentFile)
+        .onLineContaining("interface Builder");
   }
 
   @Test
@@ -1182,7 +1358,8 @@ public void covariantBuildMethodReturnType() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(foo, supertype, component);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(foo, supertype, component);
     assertThat(compilation).succeededWithoutWarnings();
   }
 
@@ -1234,7 +1411,10 @@ public void covariantBuildMethodReturnType_hasNewMethod() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(foo, bar, supertype, component);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, bar, supertype, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .hadWarningContaining(
@@ -1301,7 +1481,9 @@ public void covariantBuildMethodReturnType_hasNewMethod_buildMethodInherited() {
             "}");
 
     Compilation compilation =
-        daggerCompiler().compile(foo, bar, supertype, builderSupertype, component);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, bar, supertype, builderSupertype, component);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .hadWarningContaining(
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index 18e02de4b..d92a7b115 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
+import static dagger.internal.codegen.CodeBlocks.stringLiteral;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 import com.google.auto.common.MoreElements;
@@ -35,6 +36,7 @@
 import java.io.IOException;
 import java.io.Writer;
 import java.lang.annotation.Annotation;
+import java.util.Collection;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.ProcessingEnvironment;
@@ -48,12 +50,26 @@
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class ComponentProcessorTest {
-  private static final CodeBlock NPE_LITERAL =
-      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public ComponentProcessorTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
+  private static final CodeBlock NPE_FROM_COMPONENT_METHOD =
+      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+  private static final CodeBlock NPE_FROM_PROVIDES_METHOD =
+      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
 
   @Test public void componentOnConcreteClass() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
@@ -63,7 +79,8 @@
         "",
         "@Component",
         "final class NotAComponent {}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("interface");
   }
@@ -78,7 +95,8 @@
         "enum NotAComponent {",
         "  INSTANCE",
         "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("interface");
   }
@@ -91,7 +109,8 @@
         "",
         "@Component",
         "@interface NotAComponent {}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("interface");
   }
@@ -104,7 +123,8 @@
         "",
         "@Component(modules = Object.class)",
         "interface NotAComponent {}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("is not annotated with @Module");
   }
@@ -134,7 +154,8 @@ public void componentWithInvalidModule() {
             "interface BadComponent {",
             "  Object object();",
             "}");
-    Compilation compilation = daggerCompiler().compile(module, component);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(module, component);
     assertThat(compilation)
         .hadErrorContaining("test.BadModule has errors")
         .inFile(component)
@@ -185,7 +206,10 @@ public void componentWithInvalidModule() {
         "  List<Integer> listOfInteger();",
         "}");
 
-    Compilation compilation = daggerCompiler().compile(parent, child, another, componentFile);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(parent, child, another, componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("java.util.List<java.lang.Integer> is bound multiple times");
@@ -219,7 +243,8 @@ public void componentWithInvalidModule() {
         "}");
     Compilation compilation =
         daggerCompiler()
-            .withOptions("-Adagger.privateMemberValidation=WARNING")
+            .withOptions(
+                compilerMode.javacopts().append("-Adagger.privateMemberValidation=WARNING"))
             .compile(outerClass, componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
@@ -248,55 +273,124 @@ public void componentWithInvalidModule() {
         "  Lazy<SomeInjectableType> lazySomeInjectableType();",
         "  Provider<SomeInjectableType> someInjectableTypeProvider();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Lazy;",
-            "import dagger.internal.DoubleCheck;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-            "    return DoubleCheck.lazy(SomeInjectableType_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
-            "    return SomeInjectableType_Factory.create();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.Lazy;",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  private Provider<SomeInjectableType> getSomeInjectableTypeProvider() {",
+                "    return new Provider<SomeInjectableType>() {",
+                "      @Override",
+                "      public SomeInjectableType get() {",
+                "        return getSomeInjectableTypeInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private Lazy<SomeInjectableType> getSomeInjectableTypeLazy() {",
+                "    return DoubleCheck.lazy(getSomeInjectableTypeProvider());",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return getSomeInjectableTypeInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+                "    return getSomeInjectableTypeLazy();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+                "    return getSomeInjectableTypeProvider();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.Lazy;",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+                "    return DoubleCheck.lazy(SomeInjectableType_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+                "    return SomeInjectableType_Factory.create();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectableTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -344,7 +438,6 @@ public void componentWithInvalidModule() {
             "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
             "",
             "  private DaggerSimpleComponent(Builder builder) {",
-            "    assert builder != null;",
             "    initialize(builder);",
             "  }",
             "",
@@ -378,15 +471,17 @@ public void componentWithInvalidModule() {
             "  }",
             "",
             "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
+            "    private Builder() {}",
             "",
             "    public SimpleComponent build() {",
             "      return new DaggerSimpleComponent(this);",
             "    }",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectableTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -413,58 +508,109 @@ public void componentWithInvalidModule() {
         "  }",
         "}");
 
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerOuterType_SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerOuterType_SimpleComponent",
-            "    implements OuterType.SimpleComponent {",
-            "  private MembersInjector<OuterType.B> bMembersInjector;",
-            "",
-            "  private DaggerOuterType_SimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static OuterType.SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.bMembersInjector =",
-            "        OuterType_B_MembersInjector.create(OuterType_A_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public OuterType.A a() {",
-            "    return new OuterType.A();",
-            "  }",
-            "",
-            "  @Override",
-            "  public void inject(OuterType.B b) {",
-            "    bMembersInjector.injectMembers(b);",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public OuterType.SimpleComponent build() {",
-            "      return new DaggerOuterType_SimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(nestedTypesFile);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerOuterType_SimpleComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerOuterType_SimpleComponent",
+                "    implements OuterType.SimpleComponent {",
+                "  private DaggerOuterType_SimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static OuterType.SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private OuterType.A getAInstance() {",
+                "    return new OuterType.A();",
+                "  }",
+                "",
+                "  @Override",
+                "  public OuterType.A a() {",
+                "    return getAInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void inject(OuterType.B b) {",
+                "    injectB(b);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private OuterType.B injectB(OuterType.B instance) {",
+                "    OuterType_B_MembersInjector.injectA(instance, getAInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public OuterType.SimpleComponent build() {",
+                "      return new DaggerOuterType_SimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerOuterType_SimpleComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerOuterType_SimpleComponent",
+                "    implements OuterType.SimpleComponent {",
+                "  private DaggerOuterType_SimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static OuterType.SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public OuterType.A a() {",
+                "    return new OuterType.A();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void inject(OuterType.B b) {",
+                "    injectB(b);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private OuterType.B injectB(OuterType.B instance) {",
+                "    OuterType_B_MembersInjector.injectA(instance, new OuterType.A());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public OuterType.SimpleComponent build() {",
+                "      return new DaggerOuterType_SimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(nestedTypesFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerOuterType_SimpleComponent")
@@ -514,66 +660,135 @@ public void componentWithInvalidModule() {
         "interface TestComponent {",
         "  A a();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<B> bProvider;",
-            "  private Provider<A> aProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
-            "        C_Factory.create());",
-            "    this.aProvider = A_Factory.create(bProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public A a() {",
-            "    return new A(bProvider.get());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private TestModule testModule;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (testModule == null) {",
-            "        this.testModule = new TestModule();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder testModule(TestModule testModule) {",
-            "      this.testModule = Preconditions.checkNotNull(testModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule testModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private C getCInstance() {",
+                "    return new C();",
+                "  }",
+                "",
+                "  private B getBInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule.b(getCInstance()), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private A getAInstance() {",
+                "    return new A(getBInstance());",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule = builder.testModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return getAInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private TestModule testModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (testModule == null) {",
+                "        this.testModule = new TestModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder testModule(TestModule testModule) {",
+                "      this.testModule = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule testModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule = builder.testModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return new A(Preconditions.checkNotNull(",
+                "        testModule.b(new C()), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private TestModule testModule;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (testModule == null) {",
+                "        this.testModule = new TestModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder testModule(TestModule testModule) {",
+                "      this.testModule = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(aFile, bFile, cFile, moduleFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(aFile, bFile, cFile, moduleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -627,61 +842,103 @@ public void componentWithAbstractModule() {
             "package test;",
             "",
             "import dagger.Component;",
-            "import javax.inject.Provider;",
             "",
             "@Component(modules = TestModule.class)",
             "interface TestComponent {",
             "  A a();",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<B> bProvider;",
-            "  private Provider<A> aProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.bProvider = TestModule_BFactory.create(C_Factory.create());",
-            "    this.aProvider = A_Factory.create(bProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public A a() {",
-            "    return new A(TestModule.b(new C()));",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private C getCInstance() {",
+                "    return new C();",
+                "  }",
+                "",
+                "  private B getBInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule.b(getCInstance()), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private A getAInstance() {",
+                "    return new A(getBInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return getAInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return new A(Preconditions.checkNotNull(",
+                "        TestModule.b(new C()), " + NPE_FROM_PROVIDES_METHOD + "));",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(aFile, bFile, cFile, moduleFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(aFile, bFile, cFile, moduleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -750,7 +1007,6 @@ public void componentWithAbstractModule() {
         "package test;",
         "",
         "import dagger.Component;",
-        "import javax.inject.Provider;",
         "",
         "@Component(modules = TestModule.class)",
         "interface TestComponent {",
@@ -768,7 +1024,6 @@ public void componentWithAbstractModule() {
         "public final class DaggerTestComponent implements TestComponent {",
         "",
         "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -780,8 +1035,7 @@ public void componentWithAbstractModule() {
         "  }",
         "",
         "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
+        "    private Builder() {}",
         "",
         "    public TestComponent build() {",
         "      return new DaggerTestComponent(this);",
@@ -826,6 +1080,7 @@ public void componentWithAbstractModule() {
         "}");
     Compilation compilation =
         daggerCompiler()
+            .withOptions(compilerMode.javacopts())
             .compile(
                 always,
                 testModule,
@@ -858,7 +1113,9 @@ public void generatedTransitiveModule() {
         "",
         "@Component(modules = RootModule.class)",
         "interface TestComponent {}");
-    assertThat(daggerCompiler().compile(rootModule, component)).failed();
+    assertThat(
+            daggerCompiler().withOptions(compilerMode.javacopts()).compile(rootModule, component))
+        .failed();
     assertThat(
             daggerCompiler(
                     new GeneratingProcessor(
@@ -895,7 +1152,9 @@ public void generatedModuleInSubcomponent() {
             "interface TestComponent {",
             "  ChildComponent childComponent();",
             "}");
-    assertThat(daggerCompiler().compile(subcomponent, component)).failed();
+    assertThat(
+            daggerCompiler().withOptions(compilerMode.javacopts()).compile(subcomponent, component))
+        .failed();
     assertThat(
             daggerCompiler(
                     new GeneratingProcessor(
@@ -911,8 +1170,8 @@ public void generatedModuleInSubcomponent() {
   }
 
   @Test
-  public void subcomponentOmitsInheritedBindings() {
-    JavaFileObject parent =
+  public void subcomponentNotGeneratedIfNotUsedInGraph() {
+    JavaFileObject component =
         JavaFileObjects.forSourceLines(
             "test.Parent",
             "package test;",
@@ -921,234 +1180,136 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "@Component(modules = ParentModule.class)",
             "interface Parent {",
-            "  Child child();",
+            "  String notSubcomponent();",
             "}");
-    JavaFileObject parentModule =
+    JavaFileObject module =
         JavaFileObjects.forSourceLines(
-            "test.ParentModule",
+            "test.Parent",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
             "",
-            "@Module",
+            "@Module(subcomponents = Child.class)",
             "class ParentModule {",
-            "  @Provides @IntoSet static Object parentObject() {",
-            "    return \"parent object\";",
-            "  }",
-            "",
-            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
-            "    return \"parent value\";",
-            "  }",
+            "  @Provides static String notSubcomponent() { return new String(); }",
             "}");
-    JavaFileObject child =
+
+    JavaFileObject subcomponent =
         JavaFileObjects.forSourceLines(
             "test.Child",
             "package test;",
             "",
             "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "import java.util.Set;",
             "",
             "@Subcomponent",
             "interface Child {",
-            "  Set<Object> objectSet();",
-            "  Map<String, Object> objectMap();",
-            "}");
-    JavaFileObject expected =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParent",
-            "package test;",
-            "",
-            "import dagger.internal.MapFactory;",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParent implements Parent {",
-            "  private Provider<Object> parentKeyObjectProvider;",
-            "",
-            "  private DaggerParent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Parent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.parentKeyObjectProvider =",
-            "        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Child child() {",
-            "    return new ChildImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private ParentModule parentModule;",
-            "",
-            "    private Builder() {}",
-            "",
-            "    public Parent build() {",
-            "      if (parentModule == null) {",
-            "        this.parentModule = new ParentModule();",
-            "      }",
-            "      return new DaggerParent(this);",
-            "    }",
-            "",
-            "    public Builder parentModule(ParentModule parentModule) {",
-            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "",
-            "  private final class ChildImpl implements Child {",
-            "    private Provider<Set<Object>> setOfObjectProvider;",
-            "    private Provider<Map<String, Provider<Object>>>",
-            "        mapOfStringAndProviderOfObjectProvider;",
-            "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
-            "",
-            "    private ChildImpl() {",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      this.setOfObjectProvider = SetFactory.<Object>builder(1, 0)",
-            "          .addProvider(ParentModule_ParentObjectFactory.create()).build();",
-            "      this.mapOfStringAndProviderOfObjectProvider =",
-            "          MapProviderFactory.<String, Object>builder(1)",
-            "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
-            "              .build();",
-            "      this.mapOfStringAndObjectProvider = MapFactory.create(",
-            "          mapOfStringAndProviderOfObjectProvider);",
-            "    }",
-            "",
-            "    @Override",
-            "    public Set<Object> objectSet() {",
-            "      return setOfObjectProvider.get();",
-            "    }",
-            "",
-            "    @Override",
-            "    public Map<String, Object> objectMap() {",
-            "      return mapOfStringAndObjectProvider.get();",
-            "    }",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
             "  }",
             "}");
-    Compilation compilation = daggerCompiler().compile(parent, parentModule, child);
+
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private DaggerParent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private String getStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        ParentModule.notSubcomponent(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public String notSubcomponent() {",
+                "    return getStringInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "",
+                "  private DaggerParent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public String notSubcomponent() {",
+                "    return Preconditions.checkNotNull(",
+                "        ParentModule.notSubcomponent(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(component, module, subcomponent);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerParent")
-        .hasSourceEquivalentTo(expected);
-  }
-
-  @Test
-  public void subcomponentNotGeneratedIfNotUsedInGraph() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Parent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = ParentModule.class)",
-            "interface Parent {",
-            "  String notSubcomponent();",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.Parent",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module(subcomponents = Child.class)",
-            "class ParentModule {",
-            "  @Provides static String notSubcomponent() { return new String(); }",
-            "}");
-
-    JavaFileObject subcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Child {",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Child build();",
-            "  }",
-            "}");
-
-    JavaFileObject generatedComponentWithoutSubcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParent implements Parent {",
-            "",
-            "  private DaggerParent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Parent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public String notSubcomponent() {",
-            "    return ParentModule.notSubcomponent();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public Parent build() {",
-            "      return new DaggerParent(this);",
-            "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder parentModule(ParentModule parentModule) {",
-            "      Preconditions.checkNotNull(parentModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(component, module, subcomponent);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerParent")
-        .hasSourceEquivalentTo(generatedComponentWithoutSubcomponent);
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test
@@ -1176,127 +1337,11 @@ public void testDefaultPackage() {
         "interface SomeComponent {",
         "  BClass bClass();",
         "}");
-    assertThat(daggerCompiler().compile(aModule, aClass, bClass, component)).succeeded();
-  }
-
-  @Test public void setBindings() {
-    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import java.util.Collections;",
-        "import java.util.Set;",
-        "",
-        "@Module",
-        "final class EmptySetModule {",
-        "  @Provides @ElementsIntoSet Set<String> emptySet() { return Collections.emptySet(); }",
-        "}");
-    JavaFileObject setModuleFile = JavaFileObjects.forSourceLines("test.SetModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoSet;",
-        "",
-        "@Module",
-        "final class SetModule {",
-        "  @Provides @IntoSet String string() { return \"\"; }",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.Set;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {EmptySetModule.class, SetModule.class})",
-        "interface TestComponent {",
-        "  Set<String> strings();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Set<String>> emptySetProvider;",
-            "  private Provider<String> stringProvider;",
-            "  private Provider<Set<String>> setOfStringProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.emptySetProvider =",
-            "        EmptySetModule_EmptySetFactory.create(builder.emptySetModule);",
-            "    this.stringProvider =",
-            "        SetModule_StringFactory.create(builder.setModule);",
-            "    this.setOfStringProvider = ",
-            "        SetFactory.<String>builder(1, 1)",
-            "            .addCollectionProvider(emptySetProvider)",
-            "            .addProvider(stringProvider)",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Set<String> strings() {",
-            "    return setOfStringProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private EmptySetModule emptySetModule;",
-            "    private SetModule setModule;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (emptySetModule == null) {",
-            "        this.emptySetModule = new EmptySetModule();",
-            "      }",
-            "      if (setModule == null) {",
-            "        this.setModule = new SetModule();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
-            "      this.emptySetModule = Preconditions.checkNotNull(emptySetModule);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder setModule(SetModule setModule) {",
-            "      this.setModule = Preconditions.checkNotNull(setModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(emptySetModuleFile, setModuleFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(generatedComponent);
+    assertThat(
+            daggerCompiler()
+                .withOptions(compilerMode.javacopts())
+                .compile(aModule, aClass, bClass, component))
+        .succeeded();
   }
 
   @Test public void membersInjection() {
@@ -1329,58 +1374,111 @@ public void testDefaultPackage() {
         "  void inject(SomeInjectedType instance);",
         "  SomeInjectedType injectAndReturn(SomeInjectedType instance);",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
-        "",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return new Builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.someInjectedTypeMembersInjector =",
-        "        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public void inject(SomeInjectedType instance) {",
-        "    someInjectedTypeMembersInjector.injectMembers(instance);",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
-        "    someInjectedTypeMembersInjector.injectMembers(instance);",
-        "    return instance;",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void inject(SomeInjectedType instance) {",
+                "    injectSomeInjectedType(instance);",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
+                "    return injectSomeInjectedType(instance);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private SomeInjectedType injectSomeInjectedType(SomeInjectedType instance) {",
+                "    SomeInjectedType_MembersInjector.injectInjectedField(",
+                "        instance, getSomeInjectableTypeInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void inject(SomeInjectedType instance) {",
+                "    injectSomeInjectedType(instance);",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
+                "    return injectSomeInjectedType(instance);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private SomeInjectedType injectSomeInjectedType(SomeInjectedType instance) {",
+                "    SomeInjectedType_MembersInjector.injectInjectedField(",
+                "        instance, new SomeInjectableType());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(injectableTypeFile, injectedTypeFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectableTypeFile, injectedTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -1406,56 +1504,119 @@ public void testDefaultPackage() {
         "@Component",
         "interface SimpleComponent {",
         "  SomeInjectableType someInjectableType();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import dagger.internal.InstanceFactory;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private Provider<SimpleComponent> simpleComponentProvider;",
-            "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
-            "",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
-            "    this.someInjectableTypeProvider =",
-            "        SomeInjectableType_Factory.create(simpleComponentProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType(simpleComponentProvider.get())",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
+        "  Provider<SimpleComponent> selfProvider();",
+        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.internal.InstanceFactory;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private Provider<SimpleComponent> simpleComponentProvider;",
+                "",
+                "  private DaggerSimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType(this);",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return getSomeInjectableTypeInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<SimpleComponent> selfProvider() {",
+                "    return simpleComponentProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.internal.InstanceFactory;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private Provider<SimpleComponent> simpleComponentProvider;",
+                "",
+                "  private DaggerSimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return new SomeInjectableType(this)",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<SimpleComponent> selfProvider() {",
+                "    return simpleComponentProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectableTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -1489,56 +1650,107 @@ public void testDefaultPackage() {
         "interface SimpleComponent {",
         "  SomeInjectedType createAndInject();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
-        "  private Provider<SomeInjectedType> someInjectedTypeProvider;",
-        "",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return new Builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.someInjectedTypeMembersInjector =",
-        "        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());",
-        "    this.someInjectedTypeProvider =",
-        "        SomeInjectedType_Factory.create(someInjectedTypeMembersInjector);",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectedType createAndInject() {",
-        "    return someInjectedTypeProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  private SomeInjectedType getSomeInjectedTypeInstance() {",
+                "    return injectSomeInjectedType(",
+                "        SomeInjectedType_Factory.newSomeInjectedType());",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectedType createAndInject() {",
+                "    return getSomeInjectedTypeInstance();",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private SomeInjectedType injectSomeInjectedType(SomeInjectedType instance) {",
+                "    SomeInjectedType_MembersInjector.injectInjectedField(",
+                "        instance, getSomeInjectableTypeInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectedType createAndInject() {",
+                "    return injectSomeInjectedType(",
+                "        SomeInjectedType_Factory.newSomeInjectedType());",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private SomeInjectedType injectSomeInjectedType(SomeInjectedType instance) {",
+                "    SomeInjectedType_MembersInjector.injectInjectedField(",
+                "        instance, new SomeInjectableType());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(injectableTypeFile, injectedTypeFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectableTypeFile, injectedTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -1568,53 +1780,85 @@ public void testDefaultPackage() {
         "interface SimpleComponent {",
         "  SomeInjectableType someInjectableType();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MembersInjectors;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
-        "",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return new Builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.someInjectableTypeProvider =",
-        "        SomeInjectableType_Factory.create(MembersInjectors.<SomeInjectableType>noOp());",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return someInjectableTypeProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return getSomeInjectableTypeInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(genericType, injectableTypeFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(genericType, injectableTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -1634,101 +1878,172 @@ public void testDefaultPackage() {
         "package test;",
         "",
         "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
         "",
         "final class B {",
-        "  @Inject B(A a) {}",
+        "  @Inject B(Provider<A> a) {}",
         "}");
     JavaFileObject aComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
         "package test;",
         "",
         "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
         "",
         "@Component",
-        "interface AComponent {",
-        "  A a();",
-        "}");
-    JavaFileObject bComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(dependencies = AComponent.class)",
-        "interface BComponent {",
-        "  B b();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerBComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerBComponent implements BComponent {",
-            "  private Provider<A> aProvider;",
-            "  private Provider<B> bProvider;",
-            "",
-            "  private DaggerBComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.aProvider = new test_AComponent_a(builder.aComponent);",
-            "    this.bProvider = B_Factory.create(aProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public B b() {",
-            "    return new B(aProvider.get());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private AComponent aComponent;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public BComponent build() {",
-            "      if (aComponent == null) {",
-            "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
-            "            + \" must be set\");",
-            "      }",
-            "      return new DaggerBComponent(this);",
-            "    }",
-            "",
-            "    public Builder aComponent(AComponent aComponent) {",
-            "      this.aComponent = Preconditions.checkNotNull(aComponent);",
-            "      return this;",
-            "    }",
-            "  }",
-            "",
-            "  private static class test_AComponent_a implements Provider<A> {",
-            "    private final AComponent aComponent;",
-            "    ",
-            "    test_AComponent_a(AComponent aComponent) {",
-            "        this.aComponent = aComponent;",
-            "    }",
-            "    ",
-            "    @Override()",
-            "    public A get() {",
-            "      return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
-            "    }",
-            "  }",
-            "}");
+        "interface AComponent {",
+        "  A a();",
+        "}");
+    JavaFileObject bComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = AComponent.class)",
+        "interface BComponent {",
+        "  B b();",
+        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerBComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerBComponent implements BComponent {",
+                "  private Provider<A> aProvider;",
+                "",
+                "  private DaggerBComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  private B getBInstance() {",
+                "    return new B(aProvider);",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.aProvider = new test_AComponent_a(builder.aComponent);",
+                "  }",
+                "",
+                "  @Override",
+                "  public B b() {",
+                "    return getBInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private AComponent aComponent;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public BComponent build() {",
+                "      if (aComponent == null) {",
+                "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
+                "            + \" must be set\");",
+                "      }",
+                "      return new DaggerBComponent(this);",
+                "    }",
+                "",
+                "    public Builder aComponent(AComponent aComponent) {",
+                "      this.aComponent = Preconditions.checkNotNull(aComponent);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private static class test_AComponent_a implements Provider<A> {",
+                "    private final AComponent aComponent;",
+                "",
+                "    test_AComponent_a(AComponent aComponent) {",
+                "      this.aComponent = aComponent;",
+                "    }",
+                "",
+                "    @Override",
+                "    public A get() {",
+                "      return Preconditions.checkNotNull(",
+                "          aComponent.a(), " + NPE_FROM_COMPONENT_METHOD + ");",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerBComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerBComponent implements BComponent {",
+                "  private Provider<A> aProvider;",
+                "",
+                "  private DaggerBComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.aProvider = new test_AComponent_a(builder.aComponent);",
+                "  }",
+                "",
+                "  @Override",
+                "  public B b() {",
+                "    return new B(aProvider);",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private AComponent aComponent;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public BComponent build() {",
+                "      if (aComponent == null) {",
+                "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
+                "            + \" must be set\");",
+                "      }",
+                "      return new DaggerBComponent(this);",
+                "    }",
+                "",
+                "    public Builder aComponent(AComponent aComponent) {",
+                "      this.aComponent = Preconditions.checkNotNull(aComponent);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private static class test_AComponent_a implements Provider<A> {",
+                "    private final AComponent aComponent;",
+                "    ",
+                "    test_AComponent_a(AComponent aComponent) {",
+                "        this.aComponent = aComponent;",
+                "    }",
+                "    ",
+                "    @Override()",
+                "    public A get() {",
+                "      return Preconditions.checkNotNull(",
+                "          aComponent.a(), " + NPE_FROM_COMPONENT_METHOD + ");",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(aFile, bFile, aComponentFile, bComponentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(aFile, bFile, aComponentFile, bComponentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerBComponent")
@@ -1777,78 +2092,173 @@ public void testDefaultPackage() {
         "  A a();",
         "  other.test.A otherA();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<A> aProvider;",
-        "  private Provider<other.test.A> aProvider2;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return new Builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.aProvider = TestModule_AFactory.create(builder.testModule);",
-        "    this.aProvider2 = other.test.TestModule_AFactory.create(builder.testModule2);",
-        "  }",
-        "",
-        "  @Override",
-        "  public A a() {",
-        "    return aProvider.get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public other.test.A otherA() {",
-        "    return aProvider2.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private TestModule testModule;",
-        "    private other.test.TestModule testModule2;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (testModule == null) {",
-        "        this.testModule = new TestModule();",
-        "      }",
-        "      if (testModule2 == null) {",
-        "        this.testModule2 = new other.test.TestModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder testModule(TestModule testModule) {",
-        "      this.testModule = Preconditions.checkNotNull(testModule);",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder testModule(other.test.TestModule testModule) {",
-        "      this.testModule2 = Preconditions.checkNotNull(testModule);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import other.test.TestModule_AFactory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule testModule;",
+                "",
+                "  private other.test.TestModule testModule2;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private A getAInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule.a(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private other.test.A getAInstance2() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule_AFactory.proxyA(testModule2),"
+                    + NPE_FROM_PROVIDES_METHOD
+                    + ");",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule = builder.testModule;",
+                "    this.testModule2 = builder.testModule2;",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return getAInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public other.test.A otherA() {",
+                "    return getAInstance2();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private TestModule testModule;",
+                "",
+                "    private other.test.TestModule testModule2;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (testModule == null) {",
+                "        this.testModule = new TestModule();",
+                "      }",
+                "      if (testModule2 == null) {",
+                "        this.testModule2 = new other.test.TestModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder testModule(TestModule testModule) {",
+                "      this.testModule = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder testModule(other.test.TestModule testModule) {",
+                "      this.testModule2 = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import other.test.TestModule_AFactory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private TestModule testModule;",
+                "  private other.test.TestModule testModule2;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.testModule = builder.testModule;",
+                "    this.testModule2 = builder.testModule2;",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return Preconditions.checkNotNull(",
+                "        testModule.a(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public other.test.A otherA() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule_AFactory.proxyA(testModule2), "
+                    + NPE_FROM_PROVIDES_METHOD
+                    + ");",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private TestModule testModule;",
+                "    private other.test.TestModule testModule2;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (testModule == null) {",
+                "        this.testModule = new TestModule();",
+                "      }",
+                "      if (testModule2 == null) {",
+                "        this.testModule2 = new other.test.TestModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder testModule(TestModule testModule) {",
+                "      this.testModule = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder testModule(other.test.TestModule testModule) {",
+                "      this.testModule2 = Preconditions.checkNotNull(testModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
-        daggerCompiler().compile(aFile, otherAFile, moduleFile, otherModuleFile, componentFile);
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(aFile, otherAFile, moduleFile, otherModuleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -1901,65 +2311,117 @@ public void testDefaultPackage() {
         "  C c();",
         "  X x();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<B> bProvider;",
-            "  private Provider<A> aProvider;",
-            "  private Provider<X> xProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.bProvider = B_Factory.create(C_Factory.create());",
-            "    this.aProvider = A_Factory.create(bProvider);",
-            "    this.xProvider = X_Factory.create(C_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public A a() {",
-            "    return new A(new B(new C()));",
-            "  }",
-            "",
-            "  @Override",
-            "  public C c() {",
-            "    return new C();",
-            "  }",
-            "",
-            "  @Override",
-            "  public X x() {",
-            "    return new X(new C());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(aFile, bFile, cFile, xFile, componentFile);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private C getCInstance() {",
+                "    return new C();",
+                "  }",
+                "",
+                "  private B getBInstance() {",
+                "    return new B(getCInstance());",
+                "  }",
+                "",
+                "  private A getAInstance() {",
+                "    return new A(getBInstance());",
+                "  }",
+                "",
+                "  private X getXInstance() {",
+                "    return new X(getCInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return getAInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public C c() {",
+                "    return getCInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public X x() {",
+                "    return getXInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public A a() {",
+                "    return new A(new B(new C()));",
+                "  }",
+                "",
+                "  @Override",
+                "  public C c() {",
+                "    return new C();",
+                "  }",
+                "",
+                "  @Override",
+                "  public X x() {",
+                "    return new X(new C());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(aFile, bFile, cFile, xFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -2007,43 +2469,83 @@ public void testDefaultPackage() {
         "@Component",
         "interface SimpleComponent extends SupertypeA, SupertypeB {",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return getSomeInjectableTypeInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
         daggerCompiler()
+            .withOptions(compilerMode.javacopts())
             .compile(
                 injectableTypeFile,
                 componentSupertypeAFile,
@@ -2096,43 +2598,84 @@ public void testDefaultPackage() {
         "interface ComponentWithDep {",
         "  SomeInjectableType someInjectableType();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private SomeInjectableType getSomeInjectableTypeInstance() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return getSomeInjectableTypeInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public SomeInjectableType someInjectableType() {",
+                "    return new SomeInjectableType();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     Compilation compilation =
         daggerCompiler()
+            .withOptions(compilerMode.javacopts())
             .compile(injectableTypeFile, componentSupertype, depComponentFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
@@ -2178,7 +2721,10 @@ public void testDefaultPackage() {
         "interface SimpleComponent {",
         "  C c();",
         "}");
-    Compilation compilation = daggerCompiler().compile(aFile, bFile, cFile, componentFile);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(aFile, bFile, cFile, componentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -2199,7 +2745,8 @@ public void arrayKeyRequiresAtProvides() {
             "interface TestComponent {",
             "  String[] array();",
             "}");
-    Compilation compilation = daggerCompiler().compile(component);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("String[] cannot be provided without an @Provides-annotated method");
@@ -2235,6 +2782,7 @@ public void componentImplicitlyDependsOnGeneratedType() {
                     "final class GeneratedType {",
                     "  @Inject GeneratedType() {}",
                     "}"))
+            .withOptions(compilerMode.javacopts())
             .compile(injectableTypeFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation).generatedSourceFile("test.DaggerSimpleComponent");
@@ -2270,6 +2818,7 @@ public void componentSupertypeDependsOnGeneratedType() {
                     "final class GeneratedType {",
                     "  @Inject GeneratedType() {}",
                     "}"))
+            .withOptions(compilerMode.javacopts())
             .compile(componentFile, interfaceFile);
     assertThat(compilation).succeeded();
     assertThat(compilation).generatedSourceFile("test.DaggerSimpleComponent");
@@ -2331,7 +2880,6 @@ public void genericTestToLetMeDebugInEclipse() {
          "  private Provider<D> dProvider;",
          "",
          "  private DaggerSimpleComponent(Builder builder) {",
-         "    assert builder != null;",
          "    initialize(builder);",
          "  }",
          "",
@@ -2362,7 +2910,8 @@ public void genericTestToLetMeDebugInEclipse() {
          "    }",
          "  }",
          "}");
-    Compilation compilation = daggerCompiler().compile(aFile, bFile, componentFile);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(aFile, bFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerSimpleComponent")
@@ -2382,8 +2931,11 @@ public void unprocessedMembersInjectorNotes() {
     Compilation compilation =
         javac()
             .withOptions(
-                "-Xlint:-processing",
-                 "-Adagger.warnIfInjectionFactoryNotGeneratedUpstream=enabled")
+                compilerMode
+                    .javacopts()
+                    .append(
+                        "-Xlint:-processing",
+                        "-Adagger.warnIfInjectionFactoryNotGeneratedUpstream=enabled"))
             .withProcessors(
                 new ElementFilteringComponentProcessor(
                     Predicates.not(
@@ -2513,7 +3065,8 @@ public void scopeAnnotationOnInjectConstructorNotValid() {
             "final class AClass {",
             "  @Inject @AScope AClass() {}",
             "}");
-    Compilation compilation = daggerCompiler().compile(aScope, aClass);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(aScope, aClass);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("@Scope annotations are not allowed on @Inject constructors.")
@@ -2537,7 +3090,8 @@ public void attemptToInjectWildcardGenerics() {
             "  Lazy<? extends Number> wildcardNumberLazy();",
             "  Provider<? super Number> wildcardNumberProvider();",
             "}");
-    Compilation compilation = daggerCompiler().compile(testComponent);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testComponent);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(9);
     assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(10);
@@ -2607,7 +3161,6 @@ public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
             GENERATED_ANNOTATION,
             "public final class DaggerParent implements Parent {",
             "  private DaggerParent(Builder builder) {",
-            "    assert builder != null;",
             "  }",
             "",
             "  public static Builder builder() {",
@@ -2633,7 +3186,10 @@ public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(foo, module, component, prunedSubcomponent);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, module, component, prunedSubcomponent);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerParent")
@@ -2653,7 +3209,8 @@ public void invalidComponentDependencies() {
             "",
             "@Component(dependencies = int.class)",
             "interface TestComponent {}");
-    Compilation compilation = daggerCompiler().compile(testComponent);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testComponent);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("int is not a valid component dependency type");
   }
@@ -2669,7 +3226,8 @@ public void invalidComponentModules() {
             "",
             "@Component(modules = int.class)",
             "interface TestComponent {}");
-    Compilation compilation = daggerCompiler().compile(testComponent);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testComponent);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining("int is not a valid module type");
   }
@@ -2697,7 +3255,8 @@ public void moduleInDependencies() {
             "",
             "@Component(dependencies = TestModule.class)",
             "interface TestComponent {}");
-    Compilation compilation = daggerCompiler().compile(testModule, testComponent);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testModule, testComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("test.TestModule is a module, which cannot be a component dependency");
@@ -2717,7 +3276,8 @@ public void bindsInstanceInModule() {
             "abstract class TestModule {",
             "  @BindsInstance abstract void str(String string);",
             "}");
-    Compilation compilation = daggerCompiler().compile(testModule);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testModule);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -2738,7 +3298,8 @@ public void bindsInstanceInComponent() {
             "interface TestComponent {",
             "  @BindsInstance String s(String s);",
             "}");
-    Compilation compilation = daggerCompiler().compile(testComponent);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(testComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -2759,7 +3320,8 @@ public void bindsInstanceNotAbstract() {
             "class BindsInstanceNotAbstract {",
             "  @BindsInstance BindsInstanceNotAbstract bind(int unused) { return this; }",
             "}");
-    Compilation compilation = daggerCompiler().compile(notAbstract);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(notAbstract);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("@BindsInstance methods must be abstract")
@@ -2779,7 +3341,8 @@ public void bindsInstanceNoParameters() {
             "interface BindsInstanceNoParameters {",
             "  @BindsInstance void noParams();",
             "}");
-    Compilation compilation = daggerCompiler().compile(notAbstract);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(notAbstract);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -2800,7 +3363,8 @@ public void bindsInstanceManyParameters() {
             "interface BindsInstanceManyParameters {",
             "  @BindsInstance void manyParams(int i, long l);",
             "}");
-    Compilation compilation = daggerCompiler().compile(notAbstract);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(notAbstract);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
@@ -2824,7 +3388,8 @@ public void bindsInstanceFrameworkType() {
             "  @BindsInstance void bindsProvider(Provider<Object> objectProvider);",
             "  @BindsInstance void bindsProducer(Producer<Object> objectProducer);",
             "}");
-    Compilation compilation = daggerCompiler().compile(bindsFrameworkType);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(bindsFrameworkType);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("@BindsInstance parameters may not be framework types")
@@ -2837,6 +3402,356 @@ public void bindsInstanceFrameworkType() {
         .onLine(9);
   }
 
+  @Test
+  public void nullIncorrectlyReturnedFromNonNullableInlinedProvider() {
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "test.TestModule",
+                    "package test;",
+                    "",
+                    "import dagger.Module;",
+                    "import dagger.Provides;",
+                    "",
+                    "@Module",
+                    "public abstract class TestModule {",
+                    "  @Provides static String nonNullableString() { return \"string\"; }",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.InjectsMember",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class InjectsMember {",
+                    "  @Inject String member;",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.TestComponent",
+                    "package test;",
+                    "",
+                    "import dagger.Component;",
+                    "",
+                    "@Component(modules = TestModule.class)",
+                    "interface TestComponent {",
+                    "  String nonNullableString();",
+                    "  void inject(InjectsMember member);",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.TestModule_NonNullableStringFactory")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.TestModule_NonNullableStringFactory",
+                "package test;",
+                "",
+                "import dagger.internal.Factory;",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class TestModule_NonNullableStringFactory",
+                "    implements Factory<String> {",
+                "  private static final TestModule_NonNullableStringFactory INSTANCE =",
+                "      new TestModule_NonNullableStringFactory();",
+                "",
+                "  @Override",
+                "  public String get() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule.nonNullableString(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  public static Factory<String> create() {",
+                "    return INSTANCE;",
+                "  }",
+                "",
+                "  /** Proxies {@link TestModule#nonNullableString()}. */",
+                "  public static String proxyNonNullableString() {",
+                "    return TestModule.nonNullableString();",
+                "  }",
+                "}"));
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import dagger.internal.Preconditions",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private String getStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule.nonNullableString(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public String nonNullableString() {",
+                "    return getStringInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void inject(InjectsMember member) {",
+                "    injectInjectsMember(member);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private InjectsMember injectInjectsMember(InjectsMember instance) {",
+                "    InjectsMember_MembersInjector.injectMember(instance, getStringInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import dagger.internal.Preconditions",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public String nonNullableString() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule.nonNullableString(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "  @Override",
+                "  public void inject(InjectsMember member) {",
+                "    injectInjectsMember(member);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private InjectsMember injectInjectsMember(InjectsMember instance) {",
+                "    InjectsMember_MembersInjector.injectMember(",
+                "        instance,",
+                "        Preconditions.checkNotNull(",
+                "            TestModule.nonNullableString(), " + NPE_FROM_PROVIDES_METHOD + "));",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void nullCheckingIgnoredWhenProviderReturnsPrimitive() {
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "test.TestModule",
+                    "package test;",
+                    "",
+                    "import dagger.Module;",
+                    "import dagger.Provides;",
+                    "",
+                    "@Module",
+                    "public abstract class TestModule {",
+                    "  @Provides static int primitiveInteger() { return 1; }",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.InjectsMember",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class InjectsMember {",
+                    "  @Inject Integer member;",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.TestComponent",
+                    "package test;",
+                    "",
+                    "import dagger.Component;",
+                    "",
+                    "@Component(modules = TestModule.class)",
+                    "interface TestComponent {",
+                    "  Integer nonNullableInteger();",
+                    "  void inject(InjectsMember member);",
+                    "}"));
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.TestModule_PrimitiveIntegerFactory")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.TestModule_PrimitiveIntegerFactory",
+                "package test;",
+                "",
+                "import dagger.internal.Factory;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class TestModule_PrimitiveIntegerFactory",
+                "    implements Factory<Integer> {",
+                "  private static final TestModule_PrimitiveIntegerFactory INSTANCE =",
+                "      new TestModule_PrimitiveIntegerFactory();",
+                "",
+                "  @Override",
+                "  public Integer get() {",
+                "    return TestModule.primitiveInteger();",
+                "  }",
+                "",
+                "  public static Factory<Integer> create() {",
+                "    return INSTANCE;",
+                "  }",
+                "",
+                "  public static int proxyPrimitiveInteger() {",
+                "    return TestModule.primitiveInteger();",
+                "  }",
+                "}"));
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private int getIntegerInstance() {",
+                "    return TestModule.primitiveInteger();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Integer nonNullableInteger() {",
+                "    return getIntegerInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void inject(InjectsMember member) {",
+                "    injectInjectsMember(member);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private InjectsMember injectInjectsMember(InjectsMember instance) {",
+                "    InjectsMember_MembersInjector.injectMember(instance, getIntegerInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Integer nonNullableInteger() {",
+                "    return TestModule.primitiveInteger();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void inject(InjectsMember member) {",
+                "    injectInjectsMember(member);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private InjectsMember injectInjectsMember(InjectsMember instance) {",
+                "    InjectsMember_MembersInjector.injectMember(",
+                "        instance, TestModule.primitiveInteger());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
   private static Compiler daggerCompiler(Processor... extraProcessors) {
     return javac().withProcessors(Lists.asList(new ComponentProcessor(), extraProcessors));
   }
diff --git a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
new file mode 100644
index 000000000..9613e4104
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
@@ -0,0 +1,772 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_COMPONENT_METHOD;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class ComponentRequirementFieldTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public ComponentRequirementFieldTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
+  @Test
+  public void bindsInstance() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "import java.util.List;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  int i();",
+            "  List<String> list();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    @BindsInstance Builder i(int i);",
+            "    @BindsInstance Builder list(List<String> list);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.List;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Integer i;",
+                "  private List<String> list;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static TestComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.i = builder.i;",
+                "    this.list = builder.list;",
+                "  }",
+                "",
+                "  @Override",
+                "  public int i() {",
+                "    return i;",
+                "  }",
+                "",
+                "  @Override",
+                "  public List<String> list() {",
+                "    return list;",
+                "  }",
+                "",
+                "  private static final class Builder implements TestComponent.Builder {",
+                "    private Integer i;",
+                "    private List<String> list;",
+                "",
+                "    @Override",
+                "    public TestComponent build() {",
+                "      if (i == null) {",
+                "        throw new IllegalStateException(",
+                "            Integer.class.getCanonicalName() + \" must be set\");",
+                "      }",
+                "      if (list == null) {",
+                "        throw new IllegalStateException(",
+                "            List.class.getCanonicalName() + \" must be set\");",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Override",
+                "    public Builder i(int i) {",
+                "      this.i = Preconditions.checkNotNull(i);",
+                "      return this;",
+                "    }",
+                "",
+                "    @Override",
+                "    public Builder list(List<String> list) {",
+                "      this.list = Preconditions.checkNotNull(list);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void instanceModuleMethod() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides int i() { return 0; }",
+            "}");
+    JavaFileObject otherPackageModule =
+        JavaFileObjects.forSourceLines(
+            "other.OtherPackageModule",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "public class OtherPackageModule {",
+            "  @Provides long l() { return 0L; }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import other.OtherPackageModule;",
+            "",
+            "@Component(modules = {ParentModule.class, OtherPackageModule.class})",
+            "interface TestComponent {",
+            "  int i();",
+            "  long l();",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, otherPackageModule, component);
+    assertThat(compilation).succeeded();
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import other.OtherPackageModule;",
+                "import other.OtherPackageModule_LFactory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private ParentModule parentModule;",
+                "  private OtherPackageModule otherPackageModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private int getIntegerInstance() {",
+                "    return parentModule.i();",
+                "  }",
+                "",
+                "  private long getLongInstance() {",
+                "    return OtherPackageModule_LFactory.proxyL(otherPackageModule);",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "    this.otherPackageModule = builder.otherPackageModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public int i() {",
+                "    return getIntegerInstance();",
+                "  }",
+                "",
+                "  @Override",
+                "  public long l() {",
+                "    return getLongInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "    private OtherPackageModule otherPackageModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      if (otherPackageModule == null) {",
+                "        this.otherPackageModule = new OtherPackageModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder otherPackageModule(OtherPackageModule otherPackageModule) {",
+                "      this.otherPackageModule = Preconditions.checkNotNull(otherPackageModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import other.OtherPackageModule;",
+                "import other.OtherPackageModule_LFactory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private ParentModule parentModule;",
+                "  private OtherPackageModule otherPackageModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "    this.otherPackageModule = builder.otherPackageModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public int i() {",
+                "    return parentModule.i();",
+                "  }",
+                "",
+                "  @Override",
+                "  public long l() {",
+                "    return OtherPackageModule_LFactory.proxyL(otherPackageModule);",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "    private OtherPackageModule otherPackageModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      if (otherPackageModule == null) {",
+                "        this.otherPackageModule = new OtherPackageModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder otherPackageModule(OtherPackageModule otherPackageModule) {",
+                "      this.otherPackageModule = Preconditions.checkNotNull(otherPackageModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void componentInstances() {
+    JavaFileObject dependency =
+        JavaFileObjects.forSourceLines(
+            "test.Dep",
+            "package test;",
+            "",
+            "interface Dep {",
+            "  String string();",
+            "  Object object();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = Dep.class)",
+            "interface TestComponent {",
+            "  TestComponent self();",
+            "  TestSubcomponent subcomponent();",
+            "",
+            "  Dep dep();",
+            "  String methodOnDep();",
+            "  Object otherMethodOnDep();",
+            "}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface TestSubcomponent {",
+            "  TestComponent parent();",
+            "  Dep depFromSubcomponent();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(dependency, component, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Dep dep;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.dep = builder.dep;",
+                "  }",
+                "",
+                "  @Override",
+                "  public TestComponent self() {",
+                "    return this;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Dep dep() {",
+                "    return dep;",
+                "  }",
+                "",
+                "  @Override",
+                "  public String methodOnDep() {",
+                "    return Preconditions.checkNotNull(",
+                "        dep.string(), " + NPE_FROM_COMPONENT_METHOD + " );",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object otherMethodOnDep() {",
+                "    return Preconditions.checkNotNull(",
+                "        dep.object(), " + NPE_FROM_COMPONENT_METHOD + " );",
+                "  }",
+                "",
+                "  @Override",
+                "  public TestSubcomponent subcomponent() {",
+                "    return new TestSubcomponentImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Dep dep;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (dep == null) {",
+                "        throw new IllegalStateException(",
+                "            Dep.class.getCanonicalName() + \" must be set\");",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder dep(Dep dep) {",
+                "      this.dep = Preconditions.checkNotNull(dep);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class TestSubcomponentImpl implements TestSubcomponent {",
+                "    private TestSubcomponentImpl() {}",
+                "",
+                "    @Override",
+                "    public TestComponent parent() {",
+                "      return DaggerTestComponent.this;",
+                "    }",
+                "",
+                "    @Override",
+                "    public Dep depFromSubcomponent() {",
+                "      return DaggerTestComponent.this.dep;",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.Provides;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides",
+            // intentionally non-static. this needs to require the module when the subcompnent
+            // adds to the Set binding
+            "  Object reliesOnMultibinding(Set<Object> set) { return set; }",
+            "",
+            "  @Provides @IntoSet static Object contribution() { return new Object(); }",
+            "}");
+
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides @IntoSet static Object contribution() { return new Object(); }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface TestComponent {",
+            "  Provider<Object> dependsOnMultibinding();",
+            "  TestSubcomponent subcomponent();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface TestSubcomponent {",
+            "  Provider<Object> dependsOnMultibinding();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private ParentModule parentModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Object getObjectInstance2() {",
+                "    return Preconditions.checkNotNull(",
+                "        ParentModule.contribution(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Object getObjectInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        parentModule.reliesOnMultibinding(",
+                "            ImmutableSet.<Object>of(getObjectInstance2())),",
+                "        " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Object> getObjectProvider() {",
+                "    return new Provider<Object>() {",
+                "      @Override",
+                "      public Object get() {",
+                "        return getObjectInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Object> dependsOnMultibinding() {",
+                "    return getObjectProvider();",
+                "  }",
+                "",
+                "  @Override",
+                "  public TestSubcomponent subcomponent() {",
+                "    return new TestSubcomponentImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class TestSubcomponentImpl implements TestSubcomponent {",
+                "    private TestSubcomponentImpl() {}",
+                "",
+                "    private Object getObjectInstance2() {",
+                "      return Preconditions.checkNotNull(",
+                "          ParentModule.contribution(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "    }",
+                "",
+                "    private Object getObjectInstance3() {",
+                "      return Preconditions.checkNotNull(",
+                "          ChildModule.contribution(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "    }",
+                "",
+                "    private Object getObjectInstance() {",
+                "      return Preconditions.checkNotNull(",
+                "          DaggerTestComponent.this.parentModule.reliesOnMultibinding(",
+                "              ImmutableSet.<Object>of(",
+                "                  getObjectInstance2(), getObjectInstance3())),",
+                "          " + NPE_FROM_PROVIDES_METHOD + ");",
+                "    }",
+                "",
+                "    private Provider<Object> getObjectProvider() {",
+                "      return new Provider<Object>() {",
+                "        @Override",
+                "        public Object get() {",
+                "          return getObjectInstance();",
+                "        }",
+                "      };",
+                "    }",
+                "",
+                "    @Override",
+                "    public Provider<Object> dependsOnMultibinding() {",
+                "      return getObjectProvider();",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetFactory;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Provider<Set<Object>> setOfObjectProvider;",
+                "  private Provider<Object> reliesOnMultibindingProvider;",
+                "  private ParentModule parentModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.setOfObjectProvider =",
+                "        SetFactory.<Object>builder(1, 0)",
+                "            .addProvider(ParentModule_ContributionFactory.create())",
+                "            .build();",
+                "    this.reliesOnMultibindingProvider =",
+                "        ParentModule_ReliesOnMultibindingFactory.create(",
+                "            builder.parentModule, setOfObjectProvider);",
+                "    this.parentModule = builder.parentModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Object> dependsOnMultibinding() {",
+                "    return reliesOnMultibindingProvider;",
+                "  }",
+                "",
+                "  @Override",
+                "  public TestSubcomponent subcomponent() {",
+                "    return new TestSubcomponentImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class TestSubcomponentImpl implements TestSubcomponent {",
+                "    private Provider<Set<Object>> setOfObjectProvider;",
+                "",
+                "    private Provider<Object> reliesOnMultibindingProvider;",
+                "",
+                "    private TestSubcomponentImpl() {",
+                "      initialize();",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    private void initialize() {",
+                "      this.setOfObjectProvider =",
+                "          SetFactory.<Object>builder(2, 0)",
+                "              .addProvider(ParentModule_ContributionFactory.create())",
+                "              .addProvider(ChildModule_ContributionFactory.create())",
+                "              .build();",
+                "      this.reliesOnMultibindingProvider =",
+                "          ParentModule_ReliesOnMultibindingFactory.create(",
+                "              DaggerTestComponent.this.parentModule, setOfObjectProvider);",
+                "    }",
+                "",
+                "    @Override",
+                "    public Provider<Object> dependsOnMultibinding() {",
+                "      return reliesOnMultibindingProvider;",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(parentModule, childModule, component, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java b/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java
index a5b91de49..2a64ec137 100644
--- a/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java
+++ b/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java
@@ -76,6 +76,8 @@ public DaggerModuleMethodSubject getSubject(FailureStrategy fs, String that) {
   private ImmutableList.Builder<String> imports =
       new ImmutableList.Builder<String>()
           .add(
+              // explicitly import Module so it's not ambiguous with java.lang.Module
+              "import dagger.Module;",
               "import dagger.*;",
               "import dagger.multibindings.*;",
               "import dagger.producers.*;",
diff --git a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
new file mode 100644
index 000000000..1c52ce9ae
--- /dev/null
+++ b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
@@ -0,0 +1,1012 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.CompilationSubject;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class DelegateBindingExpressionTest {
+  private static final JavaFileObject REGULAR_SCOPED =
+      JavaFileObjects.forSourceLines(
+          "test.RegularScoped",
+          "package test;",
+          "",
+          "import javax.inject.Scope;",
+          "import javax.inject.Inject;",
+          "",
+          "@RegularScoped.CustomScope",
+          "class RegularScoped {",
+          "  @Inject RegularScoped() {}",
+          "",
+          "  @Scope @interface CustomScope {}",
+          "}");
+
+  private static final JavaFileObject REUSABLE_SCOPED =
+      JavaFileObjects.forSourceLines(
+          "test.ReusableScoped",
+          "package test;",
+          "",
+          "import dagger.Reusable;",
+          "import javax.inject.Inject;",
+          "",
+          "@Reusable",
+          "class ReusableScoped {",
+          "  @Inject ReusableScoped() {}",
+          "}");
+
+  private static final JavaFileObject RELEASABLE_SCOPED =
+      JavaFileObjects.forSourceLines(
+          "test.ReleasableScoped",
+          "package test;",
+          "",
+          "import dagger.releasablereferences.CanReleaseReferences;",
+          "import javax.inject.Scope;",
+          "import javax.inject.Inject;",
+          "",
+          "@ReleasableScoped.CustomScope",
+          "class ReleasableScoped {",
+          "  @Inject ReleasableScoped() {}",
+          "",
+          "  @CanReleaseReferences",
+          "  @Scope @interface CustomScope {}",
+          "}");
+
+  private static final JavaFileObject UNSCOPED =
+      JavaFileObjects.forSourceLines(
+          "test.Unscoped",
+          "package test;",
+          "",
+          "import javax.inject.Inject;",
+          "",
+          "class Unscoped {",
+          "  @Inject Unscoped() {}",
+          "}");
+
+  private static final JavaFileObject COMPONENT =
+      JavaFileObjects.forSourceLines(
+          "test.TestComponent",
+          "package test;",
+          "",
+          "import dagger.Component;",
+          "import dagger.releasablereferences.ForReleasableReferences;",
+          "import dagger.releasablereferences.ReleasableReferenceManager;",
+          "",
+          "@Component(modules = TestModule.class)",
+          "@RegularScoped.CustomScope",
+          "@ReleasableScoped.CustomScope",
+          "interface TestComponent {",
+          "  @Qualifier(RegularScoped.class)",
+          "  Object regular();",
+          "",
+          "  @Qualifier(ReusableScoped.class)",
+          "  Object reusable();",
+          "",
+          "  @Qualifier(ReleasableScoped.class)",
+          "  Object releasable();",
+          "",
+          "  @Qualifier(Unscoped.class)",
+          "  Object unscoped();",
+          "",
+          // force a reference releasing provider to be created
+          "  @ForReleasableReferences(ReleasableScoped.CustomScope.class)",
+          "  ReleasableReferenceManager releasableReferenceManager();",
+          "}");
+
+  private static final JavaFileObject QUALIFIER =
+      JavaFileObjects.forSourceLines(
+          "test.Qualifier",
+          "package test;",
+          "",
+          "@javax.inject.Qualifier",
+          "@interface Qualifier {",
+          "  Class<?> value();",
+          "}");
+
+  @Test
+  public void toDoubleCheck() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Binds @RegularScoped.CustomScope @Qualifier(RegularScoped.class)",
+            "  Object regular(RegularScoped delegate);",
+            "",
+            "  @Binds @RegularScoped.CustomScope @Qualifier(ReusableScoped.class)",
+            "  Object reusable(ReusableScoped delegate);",
+            "",
+            "  @Binds @RegularScoped.CustomScope @Qualifier(ReleasableScoped.class)",
+            "  Object releasable(ReleasableScoped delegate);",
+            "",
+            "  @Binds @RegularScoped.CustomScope @Qualifier(Unscoped.class)",
+            "  Object unscoped(Unscoped delegate);",
+            "}");
+
+    assertThatCompilationWithModule(module)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import dagger.internal.ReferenceReleasingProvider;",
+                "import dagger.internal.ReferenceReleasingProviderManager;",
+                "import dagger.internal.SingleCheck;",
+                "import dagger.releasablereferences.ReleasableReferenceManager;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private final ReferenceReleasingProviderManager customScopeReferences =",
+                "      new ReferenceReleasingProviderManager(ReleasableScoped.CustomScope.class);",
+                "  private Provider<RegularScoped> regularScopedProvider;",
+                "  private Provider<ReusableScoped> reusableScopedProvider;",
+                "  private Provider<Object> reusableProvider;",
+                "  private Provider<ReleasableScoped> releasableScopedProvider;",
+                "  private Provider<Object> releasableProvider;",
+                "  private Provider<Object> unscopedProvider;",
+                "  private Provider<ReleasableReferenceManager>",
+                "      forReleasableReferencesReleasableReferenceManagerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.regularScopedProvider = ",
+                "        DoubleCheck.provider(RegularScoped_Factory.create());",
+                "    this.reusableScopedProvider = ",
+                "        SingleCheck.provider(ReusableScoped_Factory.create());",
+                "    this.reusableProvider = ",
+                "        DoubleCheck.provider((Provider) reusableScopedProvider);",
+                "    this.releasableScopedProvider =",
+                "        ReferenceReleasingProvider.create(",
+                "            ReleasableScoped_Factory.create(), customScopeReferences);",
+                "    this.releasableProvider = ",
+                "        DoubleCheck.provider((Provider) releasableScopedProvider);",
+                "    this.unscopedProvider = ",
+                "        DoubleCheck.provider((Provider) Unscoped_Factory.create());",
+                "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
+                "        new Provider<ReleasableReferenceManager>() {",
+                "          @Override",
+                "          public ReleasableReferenceManager get() {",
+                "            return customScopeReferences;",
+                "          }",
+                "        };",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object regular() {",
+                "    return regularScopedProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object reusable() {",
+                "    return reusableProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object releasable() {",
+                "    return releasableProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object unscoped() {",
+                "    return unscopedProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public ReleasableReferenceManager releasableReferenceManager() {",
+                "    return forReleasableReferencesReleasableReferenceManagerProvider.get();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void toSingleCheck() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.Reusable;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Binds @Reusable @Qualifier(RegularScoped.class)",
+            "  Object regular(RegularScoped delegate);",
+            "",
+            "  @Binds @Reusable @Qualifier(ReusableScoped.class)",
+            "  Object reusable(ReusableScoped delegate);",
+            "",
+            "  @Binds @Reusable @Qualifier(ReleasableScoped.class)",
+            "  Object releasable(ReleasableScoped delegate);",
+            "",
+            "  @Binds @Reusable @Qualifier(Unscoped.class)",
+            "  Object unscoped(Unscoped delegate);",
+            "}");
+
+    assertThatCompilationWithModule(module)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import dagger.internal.ReferenceReleasingProvider;",
+                "import dagger.internal.ReferenceReleasingProviderManager;",
+                "import dagger.internal.SingleCheck;",
+                "import dagger.releasablereferences.ReleasableReferenceManager;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private final ReferenceReleasingProviderManager customScopeReferences =",
+                "      new ReferenceReleasingProviderManager(ReleasableScoped.CustomScope.class);",
+                "  private Provider<RegularScoped> regularScopedProvider;",
+                "  private Provider<ReusableScoped> reusableScopedProvider;",
+                "  private Provider<ReleasableScoped> releasableScopedProvider;",
+                "  private Provider<Object> releasableProvider;",
+                "  private Provider<Object> unscopedProvider;",
+                "  private Provider<ReleasableReferenceManager>",
+                "      forReleasableReferencesReleasableReferenceManagerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.regularScopedProvider = ",
+                "        DoubleCheck.provider(RegularScoped_Factory.create());",
+                "    this.reusableScopedProvider = ",
+                "        SingleCheck.provider(ReusableScoped_Factory.create());",
+                "    this.releasableScopedProvider = ",
+                "       ReferenceReleasingProvider.create(",
+                "           ReleasableScoped_Factory.create(), customScopeReferences);",
+                "    this.releasableProvider = ",
+                "        SingleCheck.provider((Provider) releasableScopedProvider);",
+                "    this.unscopedProvider = ",
+                "        SingleCheck.provider((Provider) Unscoped_Factory.create());",
+                "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
+                "        new Provider<ReleasableReferenceManager>() {",
+                "          @Override",
+                "          public ReleasableReferenceManager get() {",
+                "            return customScopeReferences;",
+                "          }",
+                "        };",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object regular() {",
+                "    return regularScopedProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object reusable() {",
+                "    return reusableScopedProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object releasable() {",
+                "    return releasableProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object unscoped() {",
+                "    return unscopedProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public ReleasableReferenceManager releasableReferenceManager() {",
+                "    return forReleasableReferencesReleasableReferenceManagerProvider.get();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void toReleasableCheck() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Binds @ReleasableScoped.CustomScope @Qualifier(RegularScoped.class)",
+            "  Object regular(RegularScoped delegate);",
+            "",
+            "  @Binds @ReleasableScoped.CustomScope @Qualifier(ReusableScoped.class)",
+            "  Object reusable(ReusableScoped delegate);",
+            "",
+            "  @Binds @ReleasableScoped.CustomScope @Qualifier(ReleasableScoped.class)",
+            "  Object releasable(ReleasableScoped delegate);",
+            "",
+            "  @Binds @ReleasableScoped.CustomScope @Qualifier(Unscoped.class)",
+            "  Object unscoped(Unscoped delegate);",
+            "}");
+
+    assertThatCompilationWithModule(module)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import dagger.internal.ReferenceReleasingProvider;",
+                "import dagger.internal.ReferenceReleasingProviderManager;",
+                "import dagger.internal.SingleCheck;",
+                "import dagger.releasablereferences.ReleasableReferenceManager;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private final ReferenceReleasingProviderManager customScopeReferences =",
+                "      new ReferenceReleasingProviderManager(ReleasableScoped.CustomScope.class);",
+                "  private Provider<RegularScoped> regularScopedProvider;",
+                "  private Provider<ReusableScoped> reusableScopedProvider;",
+                "  private Provider<ReleasableScoped> releasableScopedProvider;",
+                "  private Provider<Object> unscopedProvider;",
+                "  private Provider<ReleasableReferenceManager>",
+                "      forReleasableReferencesReleasableReferenceManagerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.regularScopedProvider = ",
+                "        DoubleCheck.provider(RegularScoped_Factory.create());",
+                "    this.reusableScopedProvider = ",
+                "        SingleCheck.provider(ReusableScoped_Factory.create());",
+                "    this.releasableScopedProvider = ",
+                "        ReferenceReleasingProvider.create(",
+                "            ReleasableScoped_Factory.create(), customScopeReferences);",
+                "    this.unscopedProvider = ",
+                "        ReferenceReleasingProvider.create(",
+                "            (Provider) Unscoped_Factory.create(), customScopeReferences);",
+                "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
+                "        new Provider<ReleasableReferenceManager>() {",
+                "          @Override",
+                "          public ReleasableReferenceManager get() {",
+                "            return customScopeReferences;",
+                "          }",
+                "        };",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object regular() {",
+                "    return regularScopedProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object reusable() {",
+                "    return reusableScopedProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object releasable() {",
+                "    return releasableScopedProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object unscoped() {",
+                "    return unscopedProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public ReleasableReferenceManager releasableReferenceManager() {",
+                "    return forReleasableReferencesReleasableReferenceManagerProvider.get();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void toUnscoped() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Binds @Qualifier(RegularScoped.class)",
+            "  Object regular(RegularScoped delegate);",
+            "",
+            "  @Binds @Qualifier(ReusableScoped.class)",
+            "  Object reusable(ReusableScoped delegate);",
+            "",
+            "  @Binds @Qualifier(ReleasableScoped.class)",
+            "  Object releasable(ReleasableScoped delegate);",
+            "",
+            "  @Binds @Qualifier(Unscoped.class)",
+            "  Object unscoped(Unscoped delegate);",
+            "}");
+
+    assertThatCompilationWithModule(module)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import dagger.internal.ReferenceReleasingProvider;",
+                "import dagger.internal.ReferenceReleasingProviderManager;",
+                "import dagger.internal.SingleCheck;",
+                "import dagger.releasablereferences.ReleasableReferenceManager;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private final ReferenceReleasingProviderManager customScopeReferences =",
+                "      new ReferenceReleasingProviderManager(ReleasableScoped.CustomScope.class);",
+                "  private Provider<RegularScoped> regularScopedProvider;",
+                "  private Provider<ReusableScoped> reusableScopedProvider;",
+                "  private Provider<ReleasableScoped> releasableScopedProvider;",
+                "  private Provider<ReleasableReferenceManager>",
+                "      forReleasableReferencesReleasableReferenceManagerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.regularScopedProvider = ",
+                "        DoubleCheck.provider(RegularScoped_Factory.create());",
+                "    this.reusableScopedProvider = ",
+                "        SingleCheck.provider(ReusableScoped_Factory.create());",
+                "    this.releasableScopedProvider = ",
+                "         ReferenceReleasingProvider.create(",
+                "             ReleasableScoped_Factory.create(), customScopeReferences);",
+                "    this.forReleasableReferencesReleasableReferenceManagerProvider =",
+                "        new Provider<ReleasableReferenceManager>() {",
+                "          @Override",
+                "          public ReleasableReferenceManager get() {",
+                "            return customScopeReferences;",
+                "          }",
+                "        };",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object regular() {",
+                "    return regularScopedProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object reusable() {",
+                "    return reusableScopedProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object releasable() {",
+                "    return releasableScopedProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object unscoped() {",
+                "    return new Unscoped();",
+                "  }",
+                "",
+                "  @Override",
+                "  public ReleasableReferenceManager releasableReferenceManager() {",
+                "    return forReleasableReferencesReleasableReferenceManagerProvider.get();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void castNeeded_rawTypes_Provider_get() {
+    JavaFileObject accessibleSupertype =
+        JavaFileObjects.forSourceLines(
+            "other.Supertype",
+            "package other;",
+            "",
+            // accessible from the component, but the subtype is not
+            "public interface Supertype {}");
+    JavaFileObject inaccessibleSubtype =
+        JavaFileObjects.forSourceLines(
+            "other.Subtype",
+            "package other;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "class Subtype implements Supertype {",
+            "  @Inject Subtype() {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "other.SupertypeModule",
+            "package other;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "public interface SupertypeModule {",
+            "  @Binds Supertype to(Subtype subtype);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = other.SupertypeModule.class)",
+            "interface TestComponent {",
+            "  other.Supertype supertype();",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(accessibleSupertype, inaccessibleSubtype, module, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "import other.Subtype_Factory;",
+                "import other.Supertype;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  @SuppressWarnings(\"rawtypes\")",
+                "  private Provider subtypeProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.subtypeProvider = DoubleCheck.provider(Subtype_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Supertype supertype() {",
+                "    return (Supertype) subtypeProvider.get();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void noCast_rawTypes_Provider_get_toInaccessibleType() {
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "other.Supertype",
+            "package other;",
+            "",
+            "interface Supertype {}");
+    JavaFileObject subtype =
+        JavaFileObjects.forSourceLines(
+            "other.Subtype",
+            "package other;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "class Subtype implements Supertype {",
+            "  @Inject Subtype() {}",
+            "}");
+    JavaFileObject usesSupertype =
+        JavaFileObjects.forSourceLines(
+            "other.UsesSupertype",
+            "package other;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "public class UsesSupertype {",
+            "  @Inject UsesSupertype(Supertype supertype) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "other.SupertypeModule",
+            "package other;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "public interface SupertypeModule {",
+            "  @Binds Supertype to(Subtype subtype);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = other.SupertypeModule.class)",
+            "interface TestComponent {",
+            "  other.UsesSupertype usesSupertype();",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(supertype, subtype, usesSupertype, module, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "import other.Subtype_Factory;",
+                "import other.UsesSupertype;",
+                "import other.UsesSupertype_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  @SuppressWarnings(\"rawtypes\")",
+                "  private Provider subtypeProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.subtypeProvider = DoubleCheck.provider(Subtype_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesSupertype usesSupertype() {",
+                //   can't cast the provider.get() to a type that's not accessible
+                "    return UsesSupertype_Factory.newUsesSupertype(subtypeProvider.get());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void castedToRawType() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Named;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Provides",
+            "  static String provideString() { return new String(); }",
+            "",
+            "  @Binds",
+            "  CharSequence charSequence(String string);",
+            "",
+            "  @Binds",
+            "  Object object(CharSequence charSequence);",
+            "",
+            "  @Binds",
+            "  @Named(\"named\")",
+            "  String namedString(String string);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Named;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Provider<CharSequence> charSequence();",
+            "  Provider<Object> object();",
+            "",
+            "  @Named(\"named\") Provider<String> namedString();",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<CharSequence> charSequence() {",
+                "    return (Provider) TestModule_ProvideStringFactory.create();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Object> object() {",
+                //   @Binds used twice, but no need to cast (Provider) (Provider)
+                "    return (Provider) TestModule_ProvideStringFactory.create();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<String> namedString() {",
+                "    return TestModule_ProvideStringFactory.create();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void inlineFactoryOfInacessibleType() {
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "other.Supertype", "package other;", "", "public interface Supertype {}");
+    JavaFileObject injectableSubtype =
+        JavaFileObjects.forSourceLines(
+            "other.Subtype",
+            "package other;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Subtype implements Supertype {",
+            // important: this doesn't have any dependencies and therefore the factory will be able
+            // to be referenced with an inline Subtype_Factory.create()
+            "  @Inject Subtype() {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "other.TestModule",
+            "package other;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "public interface TestModule {",
+            "  @Binds Supertype to(Subtype subtype);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.RequestsSubtypeAsProvider",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = other.TestModule.class)",
+            "interface RequestsSubtypeAsProvider {",
+            "  Provider<other.Supertype> supertypeProvider();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(supertype, injectableSubtype, module, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRequestsSubtypeAsProvider")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerRequestsSubtypeAsProvider",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "import other.Subtype_Factory;",
+                "import other.Supertype;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerRequestsSubtypeAsProvider ",
+                "    implements RequestsSubtypeAsProvider {",
+                "  private DaggerRequestsSubtypeAsProvider(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static RequestsSubtypeAsProvider create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Supertype> supertypeProvider() {",
+                "    return (Provider) Subtype_Factory.create();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public RequestsSubtypeAsProvider build() {",
+                "      return new DaggerRequestsSubtypeAsProvider(this);",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  private CompilationSubject assertThatCompilationWithModule(JavaFileObject module) {
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                module,
+                COMPONENT,
+                QUALIFIER,
+                REGULAR_SCOPED,
+                REUSABLE_SCOPED,
+                RELEASABLE_SCOPED,
+                UNSCOPED);
+    assertThat(compilation).succeeded();
+    return assertThat(compilation);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
new file mode 100644
index 000000000..9278d0378
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
@@ -0,0 +1,517 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class ElidedFactoriesTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public ElidedFactoriesTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
+  @Test
+  public void simpleComponent() {
+    JavaFileObject injectedType =
+        JavaFileObjects.forSourceLines(
+            "test.InjectedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class InjectedType {",
+            "  @Inject InjectedType() {}",
+            "}");
+
+    JavaFileObject dependsOnInjected =
+        JavaFileObjects.forSourceLines(
+            "test.InjectedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class DependsOnInjected {",
+            "  @Inject DependsOnInjected(InjectedType injected) {}",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  DependsOnInjected dependsOnInjected();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private InjectedType getInjectedTypeInstance() {",
+                "    return new InjectedType();",
+                "  }",
+                "",
+                "  private DependsOnInjected getDependsOnInjectedInstance() {",
+                "    return new DependsOnInjected(getInjectedTypeInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public DependsOnInjected dependsOnInjected() {",
+                "    return getDependsOnInjectedInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private DaggerSimpleComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public DependsOnInjected dependsOnInjected() {",
+                "    return new DependsOnInjected(new InjectedType());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectedType, dependsOnInjected, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void simpleComponent_injectsProviderOf_dependsOnScoped() {
+    JavaFileObject scopedType =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "final class ScopedType {",
+            "  @Inject ScopedType() {}",
+            "}");
+
+    JavaFileObject dependsOnScoped =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class DependsOnScoped {",
+            "  @Inject DependsOnScoped(ScopedType scoped) {}",
+            "}");
+
+    JavaFileObject needsProvider =
+        JavaFileObjects.forSourceLines(
+            "test.NeedsProvider",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "class NeedsProvider {",
+            "  @Inject NeedsProvider(Provider<DependsOnScoped> provider) {}",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component",
+            "interface SimpleComponent {",
+            "  NeedsProvider needsProvider();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private Provider<ScopedType> scopedTypeProvider;",
+                "",
+                "  private DaggerSimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private DependsOnScoped getDependsOnScopedInstance() {",
+                "    return new DependsOnScoped(scopedTypeProvider.get());",
+                "  }",
+                "",
+                "  private Provider<DependsOnScoped> getDependsOnScopedProvider() {",
+                "    return new Provider<DependsOnScoped>() {",
+                "      @Override",
+                "      public DependsOnScoped get() {",
+                "        return getDependsOnScopedInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private NeedsProvider getNeedsProviderInstance() {",
+                "    return new NeedsProvider(getDependsOnScopedProvider());",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public NeedsProvider needsProvider() {",
+                "    return getNeedsProviderInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private Provider<ScopedType> scopedTypeProvider;",
+                "  private Provider<DependsOnScoped> dependsOnScopedProvider;",
+                "  private DaggerSimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
+                "    this.dependsOnScopedProvider = ",
+                "        DependsOnScoped_Factory.create(scopedTypeProvider);",
+                "  }",
+                "",
+                "  @Override",
+                "  public NeedsProvider needsProvider() {",
+                "    return new NeedsProvider(dependsOnScopedProvider);",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(scopedType, dependsOnScoped, componentFile, needsProvider);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void scopedBinding_onlyUsedInSubcomponent() {
+    JavaFileObject scopedType =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "final class ScopedType {",
+            "  @Inject ScopedType() {}",
+            "}");
+
+    JavaFileObject dependsOnScoped =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class DependsOnScoped {",
+            "  @Inject DependsOnScoped(ScopedType scoped) {}",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component",
+            "interface SimpleComponent {",
+            "  Sub sub();",
+            "}");
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Sub {",
+            "  DependsOnScoped dependsOnScoped();",
+            "}");
+
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private Provider<ScopedType> scopedTypeProvider;",
+                "",
+                "  private DaggerSimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Sub sub() {",
+                "    return new SubImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubImpl implements Sub {",
+                "    private SubImpl() {}",
+                "",
+                "    private DependsOnScoped getDependsOnScopedInstance() {",
+                "      return new DependsOnScoped(",
+                "          DaggerSimpleComponent.this.scopedTypeProvider.get());",
+                "    }",
+                "",
+                "    @Override",
+                "    public DependsOnScoped dependsOnScoped() {",
+                "      return getDependsOnScopedInstance();",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerSimpleComponent",
+                "package test;",
+                "",
+                "import dagger.internal.DoubleCheck;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerSimpleComponent implements SimpleComponent {",
+                "  private Provider<ScopedType> scopedTypeProvider;",
+                "",
+                "  private DaggerSimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Sub sub() {",
+                "    return new SubImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public SimpleComponent build() {",
+                "      return new DaggerSimpleComponent(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubImpl implements Sub {",
+                "    private SubImpl() {}",
+                "",
+                "    @Override",
+                "    public DependsOnScoped dependsOnScoped() {",
+                "      return new DependsOnScoped(",
+                "          DaggerSimpleComponent.this.scopedTypeProvider.get());",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(scopedType, dependsOnScoped, componentFile, subcomponentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ExpressionTest.java b/javatests/dagger/internal/codegen/ExpressionTest.java
new file mode 100644
index 000000000..ba8a589ce
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ExpressionTest.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.testing.compile.CompilationRule;
+import com.squareup.javapoet.CodeBlock;
+import javax.lang.model.type.TypeMirror;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ExpressionTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  interface Supertype {}
+
+  interface Subtype extends Supertype {}
+
+  @Test
+  public void castTo() {
+    TypeMirror subtype = type(Subtype.class);
+    TypeMirror supertype = type(Supertype.class);
+    Expression expression = Expression.create(subtype, CodeBlock.of("new $T() {}", subtype));
+
+    Expression castTo = expression.castTo(supertype);
+
+    assertThat(castTo.type()).isSameAs(supertype);
+    assertThat(castTo.codeBlock().toString())
+        .isEqualTo(
+            "(dagger.internal.codegen.ExpressionTest.Supertype) "
+                + "new dagger.internal.codegen.ExpressionTest.Subtype() {}");
+  }
+
+  private TypeMirror type(Class<?> clazz) {
+    return compilationRule.getElements().getTypeElement(clazz.getCanonicalName()).asType();
+  }
+}
diff --git a/javatests/dagger/internal/codegen/GeneratedLines.java b/javatests/dagger/internal/codegen/GeneratedLines.java
index 4a6f2f477..e4eb159a8 100644
--- a/javatests/dagger/internal/codegen/GeneratedLines.java
+++ b/javatests/dagger/internal/codegen/GeneratedLines.java
@@ -16,6 +16,10 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.CodeBlocks.stringLiteral;
+
+import com.squareup.javapoet.CodeBlock;
+
 /**
  * Common lines outputted during code generation.
  */
@@ -24,4 +28,11 @@
       "@Generated("
           + "value = \"dagger.internal.codegen.ComponentProcessor\", "
           + "comments = \"https://google.github.io/dagger\")";
+
+  public static final CodeBlock NPE_FROM_PROVIDES_METHOD =
+      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
+  public static final CodeBlock NPE_FROM_COMPONENT_METHOD =
+      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+
 }
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index 949c0c1c5..2aa471a82 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -17,13 +17,16 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Arrays;
 import javax.tools.JavaFileObject;
@@ -1160,7 +1163,7 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "",
             "  static class C {",
             "    @Inject B b;",
-            "    @Inject C(X x, B b) {}",
+            "    @Inject C(X x) {}",
             "  }",
             "",
             "  interface D { }",
@@ -2527,6 +2530,77 @@ public void releasableReferenceManagerConflict() {
         .onLine(19);
   }
 
+  @Test
+  public void abstractModuleWithInstanceMethod() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides int i() { return 1; }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  int i();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("TestModule is abstract and has instance @Provides methods")
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void abstractModuleWithInstanceMethod_subclassedIsAllowed() {
+    JavaFileObject abstractModule =
+        JavaFileObjects.forSourceLines(
+            "test.AbstractModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class AbstractModule {",
+            "  @Provides int i() { return 1; }",
+            "}");
+    JavaFileObject subclassedModule =
+        JavaFileObjects.forSourceLines(
+            "test.SubclassedModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "class SubclassedModule extends AbstractModule {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = SubclassedModule.class)",
+            "interface TestComponent {",
+            "  int i();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(abstractModule, subclassedModule, component);
+    assertThat(compilation).succeeded();
+  }
+
   private String error(String... lines) {
     return Joiner.on("\n      ").join(lines);
   }
diff --git a/javatests/dagger/internal/codegen/InaccessibleTypeTest.java b/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
index 4f2932e41..c338e05f3 100644
--- a/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
+++ b/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
@@ -22,13 +22,26 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class InaccessibleTypeTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public InaccessibleTypeTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
   @Test public void basicInjectedType() {
     JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("foreign.NoDepClass",
         "package foreign;",
@@ -74,71 +87,112 @@
         "interface TestComponent {",
         "  PublicClass publicClass();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import foreign.NoDepClass_Factory;",
-            "import foreign.NonPublicClass1_Factory;",
-            "import foreign.NonPublicClass2_Factory;",
-            "import foreign.PublicClass;",
-            "import foreign.PublicClass_Factory;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  @SuppressWarnings(\"rawtypes\")",
-            "  private Provider nonPublicClass1Provider;",
-            "  @SuppressWarnings(\"rawtypes\")",
-            "  private Provider nonPublicClass2Provider;",
-            "  private Provider<PublicClass> publicClassProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.nonPublicClass1Provider =",
-            "        NonPublicClass1_Factory.create(NoDepClass_Factory.create());",
-            "    this.nonPublicClass2Provider =",
-            "        NonPublicClass2_Factory.create(NoDepClass_Factory.create());",
-            "    this.publicClassProvider = PublicClass_Factory.create(",
-            "        nonPublicClass1Provider,",
-            "        nonPublicClass2Provider,",
-            "        NoDepClass_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public PublicClass publicClass() {",
-            "    return PublicClass_Factory.newPublicClass(",
-            "        NonPublicClass1_Factory.newNonPublicClass1(",
-            "            NoDepClass_Factory.newNoDepClass()),",
-            "        NonPublicClass2_Factory.newNonPublicClass2(",
-            "            NoDepClass_Factory.newNoDepClass()),",
-            "        NoDepClass_Factory.newNoDepClass());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import foreign.NoDepClass;",
+                "import foreign.NoDepClass_Factory;",
+                "import foreign.NonPublicClass1_Factory;",
+                "import foreign.NonPublicClass2_Factory;",
+                "import foreign.PublicClass;",
+                "import foreign.PublicClass_Factory;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private NoDepClass getNoDepClassInstance() {",
+                "    return NoDepClass_Factory.newNoDepClass();",
+                "  }",
+                "",
+                "  private Object getNonPublicClass1Instance() {",
+                "    return NonPublicClass1_Factory.newNonPublicClass1(getNoDepClassInstance());",
+                "  }",
+                "",
+                "  private Object getNonPublicClass2Instance() {",
+                "    return NonPublicClass2_Factory.newNonPublicClass2(getNoDepClassInstance());",
+                "  }",
+                "",
+                "  private PublicClass getPublicClassInstance() {",
+                "    return PublicClass_Factory.newPublicClass(",
+                "        getNonPublicClass1Instance(), ",
+                "        getNonPublicClass2Instance(), ",
+                "        getNoDepClassInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public PublicClass publicClass() {",
+                "    return getPublicClassInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import foreign.NoDepClass_Factory;",
+                "import foreign.NonPublicClass1_Factory;",
+                "import foreign.NonPublicClass2_Factory;",
+                "import foreign.PublicClass;",
+                "import foreign.PublicClass_Factory;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public PublicClass publicClass() {",
+                "    return PublicClass_Factory.newPublicClass(",
+                "        NonPublicClass1_Factory.newNonPublicClass1(",
+                "            NoDepClass_Factory.newNoDepClass()),",
+                "        NonPublicClass2_Factory.newNonPublicClass2(",
+                "            NoDepClass_Factory.newNoDepClass()),",
+                "        NoDepClass_Factory.newNoDepClass());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
         .that(
             ImmutableList.of(
@@ -148,10 +202,13 @@
                 nonPublicClass2File,
                 componentFile))
         .withCompilerOptions(
-            "-Xlint:-processing",
-            "-Xlint:rawtypes",
-            "-Xlint:unchecked",
-            "-Werror")
+            compilerMode
+                .javacopts()
+                .append(
+                    "-Xlint:-processing",
+                    "-Xlint:rawtypes",
+                    "-Xlint:unchecked",
+                    "-Werror"))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -214,59 +271,117 @@
         "interface TestComponent {",
         "  void injectA(A a);",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private MembersInjector<A> aMembersInjector;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "     this.aMembersInjector = A_MembersInjector.create(NoDepClass_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public void injectA(A a) {",
-            "    aMembersInjector.injectMembers(a);",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import foreign.B_MembersInjector;",
+                "import foreign.C_MembersInjector;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private NoDepClass getNoDepClassInstance() {",
+                "    return new NoDepClass();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void injectA(A a) {",
+                "    injectA2(a);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private A injectA2(A instance) {",
+                "    D_MembersInjector.injectDep(instance, getNoDepClassInstance());",
+                "    C_MembersInjector.injectDep(instance, getNoDepClassInstance());",
+                "    B_MembersInjector.injectDep(instance, getNoDepClassInstance());",
+                "    A_MembersInjector.injectDep(instance, getNoDepClassInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import foreign.B_MembersInjector;",
+                "import foreign.C_MembersInjector;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void injectA(A a) {",
+                "    injectA2(a);",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private A injectA2(A instance) {",
+                "    D_MembersInjector.injectDep(instance, new NoDepClass());",
+                "    C_MembersInjector.injectDep(instance, new NoDepClass());",
+                "    B_MembersInjector.injectDep(instance, new NoDepClass());",
+                "    A_MembersInjector.injectDep(instance, new NoDepClass());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
         .that(
             ImmutableList.of(
                 noDepClassFile, aClassFile, bClassFile, cClassFile, dClassFile, componentFile))
         .withCompilerOptions(
-            "-Xlint:-processing",
-            "-Xlint:rawtypes",
-            "-Xlint:unchecked",
-            "-Werror")
+            compilerMode
+                .javacopts()
+                .append(
+                    "-Xlint:-processing",
+                    "-Xlint:rawtypes",
+                    "-Xlint:unchecked",
+                    "-Werror"))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
diff --git a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index bf557bdc8..25b2f9863 100644
--- a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -146,7 +146,6 @@
             "  private final Provider<T> tProvider;",
             "",
             "  public GenericClass_Factory(Provider<T> tProvider) {",
-            "    assert tProvider != null;",
             "    this.tProvider = tProvider;",
             "  }",
             "",
@@ -187,30 +186,36 @@
             "test.GenericClass_Factory",
             "package test;",
             "",
-            "import dagger.MembersInjector;",
             "import dagger.internal.Factory;",
-            "import dagger.internal.MembersInjectors;",
             "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
-            "  private final MembersInjector<GenericClass<A, B>> genericClassMembersInjector;",
+            "  private final Provider<A> aProvider;",
+            "  private final Provider<B> bProvider;",
             "",
             "  public GenericClass_Factory(",
-            "      MembersInjector<GenericClass<A, B>> genericClassMembersInjector) {",
-            "    assert genericClassMembersInjector != null;",
-            "    this.genericClassMembersInjector = genericClassMembersInjector;",
+            "      Provider<A> aProvider, Provider<B> bProvider) {",
+            "    this.aProvider = aProvider;",
+            "    this.bProvider = bProvider;",
             "  }",
             "",
             "  @Override",
             "  public GenericClass<A, B> get() {",
-            "    return MembersInjectors.injectMembers(",
-            "        genericClassMembersInjector, new GenericClass<A, B>());",
+            "    GenericClass<A, B> instance = new GenericClass<A, B>();",
+            "    GenericClass_MembersInjector.injectA(instance, aProvider.get());",
+            "    GenericClass_MembersInjector.injectRegister(instance, bProvider.get());",
+            "    return instance;",
             "  }",
             "",
             "  public static <A, B> Factory<GenericClass<A, B>> create(",
-            "      MembersInjector<GenericClass<A, B>> genericClassMembersInjector) {",
-            "    return new GenericClass_Factory<A, B>(genericClassMembersInjector);",
+            "      Provider<A> aProvider, Provider<B> bProvider) {",
+            "    return new GenericClass_Factory<A, B>(aProvider, bProvider);",
+            "  }",
+            "",
+            "  public static <A, B> GenericClass<A, B> newGenericClass() {",
+            "    return new GenericClass<A, B>();",
             "  }",
             "}");
     assertAbout(javaSource()).that(file)
@@ -285,9 +290,7 @@
             "  private final Provider<B> bProvider;",
             "",
             "  public GenericClass_Factory(Provider<A> aProvider, Provider<B> bProvider) {",
-            "    assert aProvider != null;",
             "    this.aProvider = aProvider;",
-            "    assert bProvider != null;",
             "    this.bProvider = bProvider;",
             "  }",
             "",
@@ -345,11 +348,8 @@
             "  public GenericClass_Factory(Provider<A> aProvider,",
             "      Provider<B> bProvider,",
             "      Provider<C> cProvider) {",
-            "    assert aProvider != null;",
             "    this.aProvider = aProvider;",
-            "    assert bProvider != null;",
             "    this.bProvider = bProvider;",
-            "    assert cProvider != null;",
             "    this.cProvider = cProvider;",
             "  }",
             "",
@@ -421,17 +421,11 @@
             "      Provider<String> qsProvider,",
             "      Provider<B> bAndB2AndPbAndLbProvider,",
             "      Provider<B> qbProvider) {",
-            "    assert aAndA2AndPaAndLaProvider != null;",
             "    this.aAndA2AndPaAndLaProvider = aAndA2AndPaAndLaProvider;",
-            "    assert qaProvider != null;",
             "    this.qaProvider = qaProvider;",
-            "    assert sAndS2AndPsAndLsProvider != null;",
             "    this.sAndS2AndPsAndLsProvider = sAndS2AndPsAndLsProvider;",
-            "    assert qsProvider != null;",
             "    this.qsProvider = qsProvider;",
-            "    assert bAndB2AndPbAndLbProvider != null;",
             "    this.bAndB2AndPbAndLbProvider = bAndB2AndPbAndLbProvider;",
-            "    assert qbProvider != null;",
             "    this.qbProvider = qbProvider;",
             "  }",
             "",
@@ -988,7 +982,6 @@
             "  private final Provider<String> sProvider;",
             "",
             "  public InjectConstructor_Factory(Provider<String> sProvider) {",
-            "    assert sProvider != null;",
             "    this.sProvider = sProvider;",
             "  }",
             "",
@@ -1025,38 +1018,32 @@
             "test.AllInjections_Factory",
             "package test;",
             "",
-            "import dagger.MembersInjector;",
             "import dagger.internal.Factory;",
-            "import dagger.internal.MembersInjectors;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
-            "public final class AllInjections_Factory ",
-            "    implements Factory<AllInjections> {",
-            "",
-            "  private final MembersInjector<AllInjections> allInjectionsMembersInjector;",
+            "public final class AllInjections_Factory implements Factory<AllInjections> {",
             "  private final Provider<String> sProvider;",
             "",
-            "  public AllInjections_Factory(",
-            "      MembersInjector<AllInjections> allInjectionsMembersInjector, ",
-            "      Provider<String> sProvider) {",
-            "    assert allInjectionsMembersInjector != null;",
-            "    this.allInjectionsMembersInjector = allInjectionsMembersInjector;",
-            "    assert sProvider != null;",
+            "  public AllInjections_Factory(Provider<String> sProvider) {",
             "    this.sProvider = sProvider;",
             "  }",
             "",
             "  @Override public AllInjections get() {",
-            "    return MembersInjectors.injectMembers(",
-            "        allInjectionsMembersInjector, new AllInjections(sProvider.get()));",
+            "    AllInjections instance = new AllInjections(sProvider.get());",
+            "    AllInjections_MembersInjector.injectS(instance, sProvider.get());",
+            "    AllInjections_MembersInjector.injectS2(instance, sProvider.get());",
+            "    return instance;",
             "  }",
             "",
-            "  public static Factory<AllInjections> create(",
-            "      MembersInjector<AllInjections> allInjectionsMembersInjector, ",
-            "      Provider<String> sProvider) {",
-            "    return new AllInjections_Factory(allInjectionsMembersInjector, sProvider);",
+            "  public static Factory<AllInjections> create(Provider<String> sProvider) {",
+            "    return new AllInjections_Factory(sProvider);",
             "  }",
+            "",
+            "  public static AllInjections newAllInjections(String s) {",
+            "     return new AllInjections(s);",
+            "   }",
             "}");
     assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1064,7 +1051,8 @@
         .generatesSources(expectedFactory);
   }
 
-  @Test public void supertypeRequiresMemberInjection() {
+  @Test
+  public void neitherTypeNorSupertypeRequiresMemberInjection() {
     JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
         "package test;",
         "",
@@ -1082,27 +1070,23 @@
             "test.B_Factory",
             "package test;",
             "",
-            "import dagger.MembersInjector;",
             "import dagger.internal.Factory;",
-            "import dagger.internal.MembersInjectors;",
             "import javax.annotation.Generated;",
             "",
             GENERATED_ANNOTATION,
             "public final class B_Factory implements Factory<B> {",
+            "  private static final B_Factory INSTANCE = new B_Factory();",
             "",
-            "  private final MembersInjector<B> bMembersInjector;",
-            "",
-            "  public B_Factory(MembersInjector<B> bMembersInjector) {",
-            "    assert bMembersInjector != null;",
-            "    this.bMembersInjector = bMembersInjector;",
+            "  @Override public B get() {",
+            "    return new B();",
             "  }",
             "",
-            "  @Override public B get() {",
-            "    return MembersInjectors.injectMembers(bMembersInjector, new B());",
+            "  public static Factory<B> create() {",
+            "    return INSTANCE;",
             "  }",
             "",
-            "  public static Factory<B> create(MembersInjector<B> bMembersInjector) {",
-            "    return new B_Factory(bMembersInjector);",
+            "  public static B newB() {",
+            "    return new B();",
             "  }",
             "}");
     assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
@@ -1139,7 +1123,6 @@ public void wildcardDependency() {
             "  private final Provider<List<?>> objectsProvider;",
             "",
             "  public InjectConstructor_Factory(Provider<List<?>> objectsProvider) {",
-            "    assert objectsProvider != null;",
             "    this.objectsProvider = objectsProvider;",
             "  }",
             "",
@@ -1192,7 +1175,6 @@ public void basicNameCollision() {
             "  private final Provider<other.pkg.Factory> factoryProvider;",
             "",
             "  public InjectConstructor_Factory(Provider<other.pkg.Factory> factoryProvider) {",
-            "    assert factoryProvider != null;",
             "    this.factoryProvider = factoryProvider;",
             "  }",
             "",
@@ -1205,7 +1187,8 @@ public void basicNameCollision() {
             "    return new InjectConstructor_Factory(factoryProvider);",
             "  }",
             "",
-            "  public static InjectConstructor newInjectConstructor(other.pkg.Factory factory) {",
+            "  public static InjectConstructor newInjectConstructor(",
+            "      other.pkg.Factory factory) {",
             "    return new InjectConstructor(factory);",
             "  }",
             "}");
@@ -1249,7 +1232,6 @@ public void nestedNameCollision() {
             "  private final Provider<Outer.Factory> factoryProvider;",
             "",
             "  public InjectConstructor_Factory(Provider<Outer.Factory> factoryProvider) {",
-            "    assert factoryProvider != null;",
             "    this.factoryProvider = factoryProvider;",
             "  }",
             "",
@@ -1262,7 +1244,8 @@ public void nestedNameCollision() {
             "    return new InjectConstructor_Factory(factoryProvider);",
             "  }",
             "",
-            "  public static InjectConstructor newInjectConstructor(Outer.Factory factory) {",
+            "  public static InjectConstructor newInjectConstructor(",
+            "      Outer.Factory factory) {",
             "    return new InjectConstructor(factory);",
             "  }",
             "}");
@@ -1310,9 +1293,7 @@ public void samePackageNameCollision() {
             "  public InjectConstructor_Factory(",
             "      Provider<other.pkg.CommonName> otherPackageProvider,",
             "      Provider<CommonName> samePackageProvider) {",
-            "    assert otherPackageProvider != null;",
             "    this.otherPackageProvider = otherPackageProvider;",
-            "    assert samePackageProvider != null;",
             "    this.samePackageProvider = samePackageProvider;",
             "  }",
             "",
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 5c4f98214..4299abdc9 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -17,19 +17,35 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.auto.value.processor.AutoAnnotationProcessor;
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class MapBindingComponentProcessorTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public MapBindingComponentProcessorTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
 
   @Test
   public void mapBindingsWithEnumKey() {
@@ -107,98 +123,490 @@ public void mapBindingsWithEnumKey() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<PathEnum, Provider<Handler>> dispatcher();",
+        "  Provider<Map<PathEnum, Provider<Handler>>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent =
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapProviderFactory;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private MapModuleOne mapModuleOne;",
+                "",
+                "  private MapModuleTwo mapModuleTwo;",
+                "",
+                "  private Provider<Map<PathEnum, Provider<Handler>>>",
+                "      mapOfPathEnumAndProviderOfHandlerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Handler getMapOfPathEnumAndProviderOfHandlerInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModuleOne.provideAdminHandler(),",
+                "        " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Handler> getMapOfPathEnumAndProviderOfHandlerProvider() {",
+                "    return new Provider<Handler>() {",
+                "      @Override",
+                "      public Handler get() {",
+                "        return getMapOfPathEnumAndProviderOfHandlerInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private Handler getMapOfPathEnumAndProviderOfHandlerInstance2() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModuleTwo.provideLoginHandler(),",
+                "        " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Handler> getMapOfPathEnumAndProviderOfHandlerProvider2() {",
+                "    return new Provider<Handler>() {",
+                "      @Override",
+                "      public Handler get() {",
+                "        return getMapOfPathEnumAndProviderOfHandlerInstance2();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.mapModuleOne = builder.mapModuleOne;",
+                "    this.mapModuleTwo = builder.mapModuleTwo;",
+                "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
+                "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+                "            .put(PathEnum.ADMIN, getMapOfPathEnumAndProviderOfHandlerProvider())",
+                "            .put(PathEnum.LOGIN, getMapOfPathEnumAndProviderOfHandlerProvider2())",
+                "            .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<PathEnum, Provider<Handler>>> dispatcher() {",
+                "    return mapOfPathEnumAndProviderOfHandlerProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapProviderFactory;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Provider<Handler> provideAdminHandlerProvider;",
+                "  private Provider<Handler> provideLoginHandlerProvider;",
+                "  private Provider<Map<PathEnum, Provider<Handler>>>",
+                "      mapOfPathEnumAndProviderOfHandlerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.provideAdminHandlerProvider =",
+                "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+                "    this.provideLoginHandlerProvider =",
+                "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+                "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
+                "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+                "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
+                "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
+                "            .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<PathEnum, Provider<Handler>>> dispatcher() {",
+                "    return mapOfPathEnumAndProviderOfHandlerProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                enumKeyFile,
+                pathEnumFile,
+                HandlerFile,
+                LoginHandlerFile,
+                AdminHandlerFile,
+                componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapBindingsWithInaccessibleKeys() {
+    JavaFileObject mapKeys =
         JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
+            "mapkeys.MapKeys",
+            "package mapkeys;",
             "",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Handler> provideAdminHandlerProvider;",
-            "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathEnum, Provider<Handler>>>",
-            "      mapOfPathEnumAndProviderOfHandlerProvider;",
+            "import dagger.MapKey;",
+            "import dagger.multibindings.ClassKey;",
             "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
+            "public class MapKeys {",
+            "  @MapKey(unwrapValue = false)",
+            "  public @interface ComplexKey {",
+            "    Class<?>[] manyClasses();",
+            "    Class<?> oneClass();",
+            "    ClassKey annotation();",
             "  }",
             "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
+            "  @MapKey",
+            "  @interface EnumKey {",
+            "    PackagePrivateEnum value();",
             "  }",
             "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
+            "  enum PackagePrivateEnum { INACCESSIBLE }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.provideAdminHandlerProvider =",
-            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-            "    this.provideLoginHandlerProvider =",
-            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-            "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
-            "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
-            "            .build();",
-            "  }",
+            "  interface Inaccessible {}",
+            "}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "mapkeys.MapModule",
+            "package mapkeys;",
             "",
-            "  @Override",
-            "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
-            "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
-            "  }",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ClassKey;",
+            "import dagger.multibindings.IntoMap;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "public interface MapModule {",
+            "  @Provides @IntoMap @ClassKey(MapKeys.Inaccessible.class)",
+            "  static int classKey() { return 1; }",
             "",
-            "  public static final class Builder {",
-            "    private MapModuleOne mapModuleOne;",
-            "    private MapModuleTwo mapModuleTwo;",
+            "  @Provides @IntoMap @MapKeys.EnumKey(MapKeys.PackagePrivateEnum.INACCESSIBLE)",
+            "  static int enumKey() { return 1; }",
             "",
-            "    private Builder() {",
-            "    }",
+            "  @Binds Object bindInaccessibleEnumMapToAccessibleTypeForComponent(",
+            "    Map<MapKeys.PackagePrivateEnum, Integer> map);",
             "",
-            "    public TestComponent build() {",
-            "      if (mapModuleOne == null) {",
-            "        this.mapModuleOne = new MapModuleOne();",
-            "      }",
-            "      if (mapModuleTwo == null) {",
-            "        this.mapModuleTwo = new MapModuleTwo();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
+            "  @Provides @IntoMap",
+            "  @MapKeys.ComplexKey(",
+            "    manyClasses = {java.lang.Object.class, java.lang.String.class},",
+            "    oneClass = MapKeys.Inaccessible.class,",
+            "    annotation = @ClassKey(java.lang.Object.class)",
+            "  )",
+            "  static int complexKeyWithInaccessibleValue() { return 1; }",
             "",
-            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
-            "      return this;",
-            "    }",
+            "  @Provides @IntoMap",
+            "  @MapKeys.ComplexKey(",
+            "    manyClasses = {MapKeys.Inaccessible.class, java.lang.String.class},",
+            "    oneClass = java.lang.String.class,",
+            "    annotation = @ClassKey(java.lang.Object.class)",
+            "  )",
+            "  static int complexKeyWithInaccessibleArrayValue() { return 1; }",
             "",
-            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
-            "      return this;",
-            "    }",
-            "  }",
+            "  @Provides @IntoMap",
+            "  @MapKeys.ComplexKey(",
+            "    manyClasses = {java.lang.String.class},",
+            "    oneClass = java.lang.String.class,",
+            "    annotation = @ClassKey(MapKeys.Inaccessible.class)",
+            "  )",
+            "  static int complexKeyWithInaccessibleAnnotationValue() { return 1; }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(mapModuleOneFile,
-            mapModuleTwoFile,
-            enumKeyFile,
-            pathEnumFile,
-            HandlerFile,
-            LoginHandlerFile,
-            AdminHandlerFile,
-            componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "import mapkeys.MapKeys;",
+            "import mapkeys.MapModule;",
+            "",
+            "@Component(modules = MapModule.class)",
+            "interface TestComponent {",
+            "  Map<Class<?>, Integer> classKey();",
+            "  Provider<Map<Class<?>, Integer>> classKeyProvider();",
+            "",
+            "  Object inaccessibleEnum();",
+            "  Provider<Object> inaccessibleEnumProvider();",
+            "",
+            "  Map<MapKeys.ComplexKey, Integer> complexKey();",
+            "  Provider<Map<MapKeys.ComplexKey, Integer>> complexKeyProvider();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(mapKeys, moduleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import dagger.internal.MapFactory;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "import mapkeys.MapKeys;",
+                "import mapkeys.MapModule;",
+                "import mapkeys.MapModule_ClassKeyFactory;",
+                "import mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory;",
+                "import mapkeys.MapModule_ComplexKeyWithInaccessibleArrayValueFactory;",
+                "import mapkeys.MapModule_ComplexKeyWithInaccessibleValueFactory;",
+                "import mapkeys.MapModule_EnumKeyFactory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Provider<Map<Class<?>, Integer>> mapOfClassOfAndIntegerProvider;",
+                "",
+                "  @SuppressWarnings(\"rawtypes\")",
+                "  private Provider mapOfPackagePrivateEnumAndIntegerProvider;",
+                "",
+                "  private Provider<Map<MapKeys.ComplexKey, Integer>>",
+                "      mapOfComplexKeyAndIntegerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.mapOfClassOfAndIntegerProvider =",
+                "        MapFactory.<Class<?>, Integer>builder(1)",
+                "            .put(MapModule_ClassKeyFactory.mapKey(),",
+                "                 MapModule_ClassKeyFactory.create())",
+                "            .build();",
+                "    this.mapOfPackagePrivateEnumAndIntegerProvider =",
+                "        MapFactory.builder(1)",
+                "            .put(MapModule_EnumKeyFactory.mapKey(), ",
+                "                 (Provider) MapModule_EnumKeyFactory.create())",
+                "            .build();",
+                "    this.mapOfComplexKeyAndIntegerProvider =",
+                "       MapFactory.<MapKeys.ComplexKey, Integer>builder(3)",
+                "          .put(",
+                "             MapModule_ComplexKeyWithInaccessibleValueFactory.mapKey(),",
+                "             MapModule_ComplexKeyWithInaccessibleValueFactory.create())",
+                "          .put(",
+                "             MapModule_ComplexKeyWithInaccessibleArrayValueFactory.mapKey(),",
+                "             MapModule_ComplexKeyWithInaccessibleArrayValueFactory.create())",
+                "          .put(",
+                "             MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory.mapKey(),",
+                "             MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory.create())",
+                "          .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Class<?>, Integer> classKey() {",
+                "    return ImmutableMap.<Class<?>, Integer>of(",
+                "        MapModule_ClassKeyFactory.mapKey(), MapModule.classKey());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<Class<?>, Integer>> classKeyProvider() {",
+                "    return mapOfClassOfAndIntegerProvider;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Object inaccessibleEnum() {",
+                "    return ImmutableMap.of(",
+                "        MapModule_EnumKeyFactory.mapKey(), MapModule.enumKey());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Object> inaccessibleEnumProvider() {",
+                "    return mapOfPackagePrivateEnumAndIntegerProvider;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<MapKeys.ComplexKey, Integer> complexKey() {",
+                "    return ImmutableMap.<MapKeys.ComplexKey, Integer>of(",
+                "        MapModule_ComplexKeyWithInaccessibleValueFactory.mapKey(),",
+                "        MapModule.complexKeyWithInaccessibleValue(),",
+                "        MapModule_ComplexKeyWithInaccessibleArrayValueFactory.mapKey(),",
+                "        MapModule.complexKeyWithInaccessibleArrayValue(),",
+                "        MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory.mapKey(),",
+                "        MapModule.complexKeyWithInaccessibleAnnotationValue());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<MapKeys.ComplexKey, Integer>> complexKeyProvider() {",
+                "    return mapOfComplexKeyAndIntegerProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}"));
+    assertThat(compilation)
+        .generatedSourceFile(
+            "mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory",
+                "package mapkeys;",
+                "",
+                "import dagger.internal.Factory;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class",
+                "    MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory",
+                "        implements Factory<Integer> {",
+                "  private static final",
+                "    MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory INSTANCE =",
+                "      new MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory();",
+                "",
+                "  @Override",
+                "  public Integer get() {",
+                "    return MapModule.complexKeyWithInaccessibleAnnotationValue();",
+                "  }",
+                "",
+                "  public static Factory<Integer> create() {",
+                "    return INSTANCE;",
+                "  }",
+                "",
+                "  public static MapKeys.ComplexKey mapKey() {",
+                "    return MapKeys_ComplexKeyCreator.createComplexKey(",
+                "        new Class[] {String.class},",
+                "        String.class,",
+                "        MapKeys_ComplexKeyCreator.createClassKey(MapKeys.Inaccessible.class));",
+                "  }",
+                "}"));
+    assertThat(compilation)
+        .generatedSourceFile("mapkeys.MapModule_ClassKeyFactory")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "mapkeys.MapModule_ClassKeyFactory",
+                "package mapkeys;",
+                "",
+                "import dagger.internal.Factory;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class MapModule_ClassKeyFactory implements Factory<Integer> {",
+                "  private static final MapModule_ClassKeyFactory INSTANCE = ",
+                "      new MapModule_ClassKeyFactory();",
+                "",
+                "  @Override",
+                "  public Integer get() {",
+                "    return MapModule.classKey();",
+                "  }",
+                "",
+                "  public static Factory<Integer> create() {",
+                "    return INSTANCE;",
+                "  }",
+                "",
+                "  public static Class<?> mapKey() {",
+                "    return MapKeys.Inaccessible.class;",
+                "  }",
+                "}"));
   }
 
   @Test
@@ -260,92 +668,206 @@ public void mapBindingsWithStringKey() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<String, Provider<Handler>> dispatcher();",
+        "  Provider<Map<String, Provider<Handler>>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Handler> provideAdminHandlerProvider;",
-            "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<String, Provider<Handler>>>",
-            "      mapOfStringAndProviderOfHandlerProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.provideAdminHandlerProvider =",
-            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-            "    this.provideLoginHandlerProvider =",
-            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfStringAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<String, Handler>builder(2)",
-            "            .put(\"Admin\", provideAdminHandlerProvider)",
-            "            .put(\"Login\", provideLoginHandlerProvider)",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<String, Provider<Handler>> dispatcher() {",
-            "    return mapOfStringAndProviderOfHandlerProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private MapModuleOne mapModuleOne;",
-            "    private MapModuleTwo mapModuleTwo;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (mapModuleOne == null) {",
-            "        this.mapModuleOne = new MapModuleOne();",
-            "      }",
-            "      if (mapModuleTwo == null) {",
-            "        this.mapModuleTwo = new MapModuleTwo();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapProviderFactory;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private MapModuleOne mapModuleOne;",
+                "",
+                "  private MapModuleTwo mapModuleTwo;",
+                "",
+                "  private Provider<Map<String, Provider<Handler>>>",
+                "      mapOfStringAndProviderOfHandlerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Handler getMapOfStringAndProviderOfHandlerInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModuleOne.provideAdminHandler(),",
+                "        " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Handler> getMapOfStringAndProviderOfHandlerProvider() {",
+                "    return new Provider<Handler>() {",
+                "      @Override",
+                "      public Handler get() {",
+                "        return getMapOfStringAndProviderOfHandlerInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private Handler getMapOfStringAndProviderOfHandlerInstance2() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModuleTwo.provideLoginHandler(),",
+                "        " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Handler> getMapOfStringAndProviderOfHandlerProvider2() {",
+                "    return new Provider<Handler>() {",
+                "      @Override",
+                "      public Handler get() {",
+                "        return getMapOfStringAndProviderOfHandlerInstance2();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.mapModuleOne = builder.mapModuleOne;",
+                "    this.mapModuleTwo = builder.mapModuleTwo;",
+                "    this.mapOfStringAndProviderOfHandlerProvider =",
+                "        MapProviderFactory.<String, Handler>builder(2)",
+                "            .put(\"Admin\", getMapOfStringAndProviderOfHandlerProvider())",
+                "            .put(\"Login\", getMapOfStringAndProviderOfHandlerProvider2())",
+                "            .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<String, Provider<Handler>>> dispatcher() {",
+                "    return mapOfStringAndProviderOfHandlerProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapProviderFactory;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Provider<Handler> provideAdminHandlerProvider;",
+                "  private Provider<Handler> provideLoginHandlerProvider;",
+                "  private Provider<Map<String, Provider<Handler>>>",
+                "      mapOfStringAndProviderOfHandlerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.provideAdminHandlerProvider =",
+                "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+                "    this.provideLoginHandlerProvider =",
+                "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+                "    this.mapOfStringAndProviderOfHandlerProvider =",
+                "        MapProviderFactory.<String, Handler>builder(2)",
+                "            .put(\"Admin\", provideAdminHandlerProvider)",
+                "            .put(\"Login\", provideLoginHandlerProvider)",
+                "            .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<String, Provider<Handler>>> dispatcher() {",
+                "    return mapOfStringAndProviderOfHandlerProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
-        .that(ImmutableList.of(mapModuleOneFile,
-            mapModuleTwoFile,
-            HandlerFile,
-            LoginHandlerFile,
-            AdminHandlerFile,
-            componentFile))
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                HandlerFile,
+                LoginHandlerFile,
+                AdminHandlerFile,
+                componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -422,95 +944,215 @@ public void mapBindingsWithWrappedKey() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<WrappedClassKey, Provider<Handler>> dispatcher();",
+        "  Provider<Map<WrappedClassKey, Provider<Handler>>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Handler> provideAdminHandlerProvider;",
-            "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<WrappedClassKey, Provider<Handler>>>",
-            "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.provideAdminHandlerProvider =",
-            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-            "    this.provideLoginHandlerProvider =",
-            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<WrappedClassKey, Handler>builder(2)",
-            "            .put(WrappedClassKeyCreator.createWrappedClassKey(Integer.class),",
-            "                provideAdminHandlerProvider)",
-            "            .put(WrappedClassKeyCreator.createWrappedClassKey(Long.class),",
-            "                provideLoginHandlerProvider)",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<WrappedClassKey, Provider<Handler>> dispatcher() {",
-            "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private MapModuleOne mapModuleOne;",
-            "    private MapModuleTwo mapModuleTwo;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (mapModuleOne == null) {",
-            "        this.mapModuleOne = new MapModuleOne();",
-            "      }",
-            "      if (mapModuleTwo == null) {",
-            "        this.mapModuleTwo = new MapModuleTwo();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapProviderFactory;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private MapModuleOne mapModuleOne;",
+                "",
+                "  private MapModuleTwo mapModuleTwo;",
+                "",
+                "  private Provider<Map<WrappedClassKey, Provider<Handler>>>",
+                "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Handler getMapOfWrappedClassKeyAndProviderOfHandlerInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModuleOne.provideAdminHandler(),",
+                "        " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Handler>",
+                "        getMapOfWrappedClassKeyAndProviderOfHandlerProvider() {",
+                "    return new Provider<Handler>() {",
+                "      @Override",
+                "      public Handler get() {",
+                "        return getMapOfWrappedClassKeyAndProviderOfHandlerInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private Handler getMapOfWrappedClassKeyAndProviderOfHandlerInstance2() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModuleTwo.provideLoginHandler(),",
+                "        " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Handler>",
+                "        getMapOfWrappedClassKeyAndProviderOfHandlerProvider2() {",
+                "    return new Provider<Handler>() {",
+                "      @Override",
+                "      public Handler get() {",
+                "        return getMapOfWrappedClassKeyAndProviderOfHandlerInstance2();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.mapModuleOne = builder.mapModuleOne;",
+                "    this.mapModuleTwo = builder.mapModuleTwo;",
+                "    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
+                "        MapProviderFactory.<WrappedClassKey, Handler>builder(2)",
+                "            .put(",
+                "                WrappedClassKeyCreator.createWrappedClassKey(Integer.class),",
+                "                getMapOfWrappedClassKeyAndProviderOfHandlerProvider())",
+                "            .put(",
+                "                WrappedClassKeyCreator.createWrappedClassKey(Long.class),",
+                "                getMapOfWrappedClassKeyAndProviderOfHandlerProvider2())",
+                "            .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<WrappedClassKey, Provider<Handler>>> dispatcher() {",
+                "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapProviderFactory;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Provider<Handler> provideAdminHandlerProvider;",
+                "  private Provider<Handler> provideLoginHandlerProvider;",
+                "  private Provider<Map<WrappedClassKey, Provider<Handler>>>",
+                "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.provideAdminHandlerProvider =",
+                "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+                "    this.provideLoginHandlerProvider =",
+                "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+                "    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
+                "        MapProviderFactory.<WrappedClassKey, Handler>builder(2)",
+                "            .put(WrappedClassKeyCreator.createWrappedClassKey(Integer.class),",
+                "                provideAdminHandlerProvider)",
+                "            .put(WrappedClassKeyCreator.createWrappedClassKey(Long.class),",
+                "                provideLoginHandlerProvider)",
+                "            .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<WrappedClassKey, Provider<Handler>>> dispatcher() {",
+                "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
-        .that(ImmutableList.of(mapModuleOneFile,
-            mapModuleTwoFile,
-            wrappedClassKeyFile,
-            HandlerFile,
-            LoginHandlerFile,
-            AdminHandlerFile,
-            componentFile))
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                wrappedClassKeyFile,
+                HandlerFile,
+                LoginHandlerFile,
+                AdminHandlerFile,
+                componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
         .compilesWithoutError()
         .and()
@@ -588,101 +1230,210 @@ public void mapBindingsWithNonProviderValue() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<PathEnum, Handler> dispatcher();",
+        "  Provider<Map<PathEnum, Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.MapFactory;",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Handler> provideAdminHandlerProvider;",
-            "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathEnum, Provider<Handler>>>",
-            "      mapOfPathEnumAndProviderOfHandlerProvider;",
-            "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.provideAdminHandlerProvider =",
-            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-            "    this.provideLoginHandlerProvider =",
-            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-            "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
-            "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
-            "            .build();",
-            "    this.mapOfPathEnumAndHandlerProvider =",
-            "        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<PathEnum, Handler> dispatcher() {",
-            "    return mapOfPathEnumAndHandlerProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private MapModuleOne mapModuleOne;",
-            "    private MapModuleTwo mapModuleTwo;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (mapModuleOne == null) {",
-            "        this.mapModuleOne = new MapModuleOne();",
-            "      }",
-            "      if (mapModuleTwo == null) {",
-            "        this.mapModuleTwo = new MapModuleTwo();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapFactory;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private MapModuleOne mapModuleOne;",
+                "",
+                "  private MapModuleTwo mapModuleTwo;",
+                "",
+                "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Handler getMapOfPathEnumAndProviderOfHandlerInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModuleOne.provideAdminHandler(),",
+                "        " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Handler> getMapOfPathEnumAndProviderOfHandlerProvider() {",
+                "    return new Provider<Handler>() {",
+                "      @Override",
+                "      public Handler get() {",
+                "        return getMapOfPathEnumAndProviderOfHandlerInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private Handler getMapOfPathEnumAndProviderOfHandlerInstance2() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModuleTwo.provideLoginHandler(),",
+                "        " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Handler> getMapOfPathEnumAndProviderOfHandlerProvider2() {",
+                "    return new Provider<Handler>() {",
+                "      @Override",
+                "      public Handler get() {",
+                "        return getMapOfPathEnumAndProviderOfHandlerInstance2();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.mapModuleOne = builder.mapModuleOne;",
+                "    this.mapModuleTwo = builder.mapModuleTwo;",
+                "    this.mapOfPathEnumAndHandlerProvider =",
+                "        MapFactory.<PathEnum, Handler>builder(2)",
+                "            .put(PathEnum.ADMIN, getMapOfPathEnumAndProviderOfHandlerProvider())",
+                "            .put(PathEnum.LOGIN, getMapOfPathEnumAndProviderOfHandlerProvider2())",
+                "            .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<PathEnum, Handler>> dispatcher() {",
+                "    return mapOfPathEnumAndHandlerProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapFactory;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Provider<Handler> provideAdminHandlerProvider;",
+                "  private Provider<Handler> provideLoginHandlerProvider;",
+                "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.provideAdminHandlerProvider =",
+                "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+                "    this.provideLoginHandlerProvider =",
+                "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+                "    this.mapOfPathEnumAndHandlerProvider =",
+                "        MapFactory.<PathEnum, Handler>builder(2)",
+                "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
+                "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
+                "            .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Map<PathEnum, Handler>> dispatcher() {",
+                "    return mapOfPathEnumAndHandlerProvider;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
-        .that(ImmutableList.of(mapModuleOneFile,
-            mapModuleTwoFile,
-            enumKeyFile,
-            pathEnumFile,
-            HandlerFile,
-            LoginHandlerFile,
-            AdminHandlerFile,
-            componentFile)).
-        processedWith(new ComponentProcessor())
-            .compilesWithoutError()
-            .and().generatesSources(generatedComponent);
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                enumKeyFile,
+                pathEnumFile,
+                HandlerFile,
+                LoginHandlerFile,
+                AdminHandlerFile,
+                componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
@@ -713,63 +1464,132 @@ public void injectMapWithoutMapBinding() {
         "interface TestComponent {",
         "  Map<String, String> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Map<String, String>> provideAMapProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return new Builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.provideAMapProvider = MapModule_ProvideAMapFactory.create(builder.mapModule);",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<String, String> dispatcher() {",
-        "    return provideAMapProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModule mapModule;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModule == null) {",
-        "        this.mapModule = new MapModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModule(MapModule mapModule) {",
-        "      this.mapModule = Preconditions.checkNotNull(mapModule);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))
-        .processedWith(new ComponentProcessor()).compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private MapModule mapModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Map<String, String> getMapOfStringAndStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModule.provideAMap(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.mapModule = builder.mapModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, String> dispatcher() {",
+                "    return getMapOfStringAndStringInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModule mapModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModule == null) {",
+                "        this.mapModule = new MapModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModule(MapModule mapModule) {",
+                "      this.mapModule = Preconditions.checkNotNull(mapModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private MapModule mapModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.mapModule = builder.mapModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, String> dispatcher() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModule.provideAMap(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModule mapModule;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModule == null) {",
+                "        this.mapModule = new MapModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModule(MapModule mapModule) {",
+                "      this.mapModule = Preconditions.checkNotNull(mapModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    assertAbout(javaSources())
+        .that(ImmutableList.of(mapModuleFile, componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
@@ -809,6 +1629,7 @@ public void mapBindingsWithDuplicateKeys() {
             "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(module, componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("The same map key is bound more than once")
@@ -867,6 +1688,7 @@ public void mapBindingsWithInconsistentKeyAnnotations() {
             "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(module, stringKeyTwoFile, componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("uses more than one @MapKey annotation type")
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
new file mode 100644
index 000000000..061b39b13
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
@@ -0,0 +1,632 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.CLASS_PATH_WITHOUT_GUAVA_OPTION;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.Compiler;
+import com.google.testing.compile.JavaFileObjects;
+import com.squareup.javapoet.CodeBlock;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class MapBindingExpressionTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public MapBindingExpressionTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
+  public static final CodeBlock NPE_FROM_PROVIDES =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
+  @Test
+  public void mapBindings() {
+    JavaFileObject mapModuleFile = JavaFileObjects.forSourceLines("test.MapModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.IntKey;",
+        "import dagger.multibindings.IntoMap;",
+        "import dagger.multibindings.LongKey;",
+        "import dagger.multibindings.Multibinds;",
+        "import java.util.Map;",
+        "",
+        "@Module",
+        "interface MapModule {",
+        "  @Multibinds Map<String, String> stringMap();",
+        "  @Provides @IntoMap @IntKey(0) static int provideInt() { return 0; }",
+        "  @Provides @IntoMap @LongKey(0) static long provideLong0() { return 0; }",
+        "  @Provides @IntoMap @LongKey(1) static long provideLong1() { return 1; }",
+        "  @Provides @IntoMap @LongKey(2) static long provideLong2() { return 2; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = MapModule.class)",
+        "interface TestComponent {",
+        "  Map<String, String> strings();",
+        "  Map<String, Provider<String>> providerStrings();",
+        "",
+        "  Map<Integer, Integer> ints();",
+        "  Map<Integer, Provider<Integer>> providerInts();",
+        "  Map<Long, Long> longs();",
+        "  Map<Long, Provider<Long>> providerLongs();",
+        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapBuilder;",
+                "import java.util.Collections;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private int getMapOfIntegerAndProviderOfIntegerInstance() {",
+                "    return MapModule.provideInt();",
+                "  }",
+                "",
+                "  private Provider<Integer> getMapOfIntegerAndProviderOfIntegerProvider() {",
+                "    return new Provider<Integer>() {",
+                "      @Override",
+                "      public Integer get() {",
+                "        return getMapOfIntegerAndProviderOfIntegerInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private long getMapOfLongAndProviderOfLongInstance() {",
+                "    return MapModule.provideLong0();",
+                "  }",
+                "",
+                "  private long getMapOfLongAndProviderOfLongInstance2() {",
+                "    return MapModule.provideLong1();",
+                "  }",
+                "",
+                "  private long getMapOfLongAndProviderOfLongInstance3() {",
+                "    return MapModule.provideLong2();",
+                "  }",
+                "",
+                "  private Provider<Long> getMapOfLongAndProviderOfLongProvider() {",
+                "    return new Provider<Long>() {",
+                "      @Override",
+                "      public Long get() {",
+                "        return getMapOfLongAndProviderOfLongInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private Provider<Long> getMapOfLongAndProviderOfLongProvider2() {",
+                "    return new Provider<Long>() {",
+                "      @Override",
+                "      public Long get() {",
+                "        return getMapOfLongAndProviderOfLongInstance2();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private Provider<Long> getMapOfLongAndProviderOfLongProvider3() {",
+                "    return new Provider<Long>() {",
+                "      @Override",
+                "      public Long get() {",
+                "        return getMapOfLongAndProviderOfLongInstance3();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, String> strings() {",
+                "    return Collections.<String, String>emptyMap();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, Provider<String>> providerStrings() {",
+                "    return Collections.<String, Provider<String>>emptyMap();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Integer> ints() {",
+                "    return Collections.<Integer, Integer>singletonMap(",
+                "        0, getMapOfIntegerAndProviderOfIntegerInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Provider<Integer>> providerInts() {",
+                "    return Collections.<Integer, Provider<Integer>>singletonMap(",
+                "        0, getMapOfIntegerAndProviderOfIntegerProvider());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Long> longs() {",
+                "    return MapBuilder.<Long, Long>newMapBuilder(3)",
+                "        .put(0L, getMapOfLongAndProviderOfLongInstance())",
+                "        .put(1L, getMapOfLongAndProviderOfLongInstance2())",
+                "        .put(2L, getMapOfLongAndProviderOfLongInstance3())",
+                "        .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Provider<Long>> providerLongs() {",
+                "    return MapBuilder.<Long, Provider<Long>>newMapBuilder(3)",
+                "        .put(0L, getMapOfLongAndProviderOfLongProvider())",
+                "        .put(1L, getMapOfLongAndProviderOfLongProvider2())",
+                "        .put(2L, getMapOfLongAndProviderOfLongProvider3())",
+                "        .build();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.MapBuilder;",
+                "import java.util.Collections;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, String> strings() {",
+                "    return Collections.<String, String>emptyMap();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, Provider<String>> providerStrings() {",
+                "    return Collections.<String, Provider<String>>emptyMap();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Integer> ints() {",
+                "    return Collections.<Integer, Integer>singletonMap(0, MapModule.provideInt());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Provider<Integer>> providerInts() {",
+                "    return Collections.<Integer, Provider<Integer>>singletonMap(",
+                "        0, MapModule_ProvideIntFactory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Long> longs() {",
+                "    return MapBuilder.<Long, Long>newMapBuilder(3)",
+                "        .put(0L, MapModule.provideLong0())",
+                "        .put(1L, MapModule.provideLong1())",
+                "        .put(2L, MapModule.provideLong2())",
+                "        .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Provider<Long>> providerLongs() {",
+                "    return MapBuilder.<Long, Provider<Long>>newMapBuilder(3)",
+                "        .put(0L, MapModule_ProvideLong0Factory.create())",
+                "        .put(1L, MapModule_ProvideLong1Factory.create())",
+                "        .put(2L, MapModule_ProvideLong2Factory.create())",
+                "        .build();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation = daggerCompilerWithoutGuava().compile(mapModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void inaccessible() {
+    JavaFileObject inaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible",
+            "package other;",
+            "",
+            "class Inaccessible {}");
+    JavaFileObject usesInaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.UsesInaccessible",
+            "package other;",
+            "",
+            "import java.util.Map;",
+            "import javax.inject.Inject;",
+            "",
+            "public class UsesInaccessible {",
+            "  @Inject UsesInaccessible(Map<Integer, Inaccessible> map) {}",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "other.TestModule",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "public abstract class TestModule {",
+            "  @Multibinds abstract Map<Integer, Inaccessible> ints();",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "import other.TestModule;",
+            "import other.UsesInaccessible;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  UsesInaccessible usesInaccessible();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import java.util.Collections;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private UsesInaccessible getUsesInaccessibleInstance() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        (Map) Collections.emptyMap());",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return getUsesInaccessibleInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import java.util.Collections;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        (Map) Collections.emptyMap());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompilerWithoutGuava().compile(module, inaccessible, usesInaccessible, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void subcomponentOmitsInheritedBindings() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
+            "    return \"parent value\";",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Map<String, Object> objectMap();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Collections;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private ParentModule parentModule;",
+                "",
+                "  private DaggerParent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Object getMapOfStringAndProviderOfObjectInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        parentModule.parentKeyObject(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    @Override",
+                "    public Map<String, Object> objectMap() {",
+                "      return Collections.<String, Object>singletonMap(",
+                "          \"parent key\",",
+                "          DaggerParent.this.getMapOfStringAndProviderOfObjectInstance());",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Collections;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private ParentModule parentModule;",
+                "",
+                "  private DaggerParent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    @Override",
+                "    public Map<String, Object> objectMap() {",
+                "      return Collections.<String, Object>singletonMap(",
+                "          \"parent key\",",
+                "          Preconditions.checkNotNull(",
+                "              DaggerParent.this.parentModule.parentKeyObject(),",
+                "              " + NPE_FROM_PROVIDES_METHOD + "));",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation = daggerCompilerWithoutGuava().compile(parent, parentModule, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  private Compiler daggerCompilerWithoutGuava() {
+    return daggerCompiler()
+        .withOptions(compilerMode.javacopts().append(CLASS_PATH_WITHOUT_GUAVA_OPTION));
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
new file mode 100644
index 000000000..6eadd389f
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
@@ -0,0 +1,880 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class MapBindingExpressionWithGuavaTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public MapBindingExpressionWithGuavaTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
+  @Test
+  public void mapBindings() {
+    JavaFileObject mapModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.LongKey;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface MapModule {",
+            "  @Multibinds Map<String, String> stringMap();",
+            "  @Provides @IntoMap @IntKey(0) static int provideInt() { return 0; }",
+            "  @Provides @IntoMap @LongKey(0) static long provideLong0() { return 0; }",
+            "  @Provides @IntoMap @LongKey(1) static long provideLong1() { return 1; }",
+            "  @Provides @IntoMap @LongKey(2) static long provideLong2() { return 2; }",
+            "}");
+    JavaFileObject subcomponentModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.SubcomponentMapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.LongKey;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface SubcomponentMapModule {",
+            "  @Provides @IntoMap @LongKey(3) static long provideLong3() { return 3; }",
+            "  @Provides @IntoMap @LongKey(4) static long provideLong4() { return 4; }",
+            "  @Provides @IntoMap @LongKey(5) static long provideLong5() { return 5; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = MapModule.class)",
+            "interface TestComponent {",
+            "  Map<String, String> strings();",
+            "  Map<String, Provider<String>> providerStrings();",
+            "",
+            "  Map<Integer, Integer> ints();",
+            "  Map<Integer, Provider<Integer>> providerInts();",
+            "  Map<Long, Long> longs();",
+            "  Map<Long, Provider<Long>> providerLongs();",
+            "",
+            "  Sub sub();",
+            "}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = SubcomponentMapModule.class)",
+            "interface Sub {",
+            "  Map<Long, Long> longs();",
+            "  Map<Long, Provider<Long>> providerLongs();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private int getMapOfIntegerAndProviderOfIntegerInstance() {",
+                "    return MapModule.provideInt();",
+                "  }",
+                "",
+                "  private Provider<Integer> getMapOfIntegerAndProviderOfIntegerProvider() {",
+                "    return new Provider<Integer>() {",
+                "      @Override",
+                "      public Integer get() {",
+                "        return getMapOfIntegerAndProviderOfIntegerInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private long getMapOfLongAndProviderOfLongInstance() {",
+                "    return MapModule.provideLong0();",
+                "  }",
+                "",
+                "  private long getMapOfLongAndProviderOfLongInstance2() {",
+                "    return MapModule.provideLong1();",
+                "  }",
+                "",
+                "  private long getMapOfLongAndProviderOfLongInstance3() {",
+                "    return MapModule.provideLong2();",
+                "  }",
+                "",
+                "  private Provider<Long> getMapOfLongAndProviderOfLongProvider() {",
+                "    return new Provider<Long>() {",
+                "      @Override",
+                "      public Long get() {",
+                "        return getMapOfLongAndProviderOfLongInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private Provider<Long> getMapOfLongAndProviderOfLongProvider2() {",
+                "    return new Provider<Long>() {",
+                "      @Override",
+                "      public Long get() {",
+                "        return getMapOfLongAndProviderOfLongInstance2();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private Provider<Long> getMapOfLongAndProviderOfLongProvider3() {",
+                "    return new Provider<Long>() {",
+                "      @Override",
+                "      public Long get() {",
+                "        return getMapOfLongAndProviderOfLongInstance3();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, String> strings() {",
+                "    return ImmutableMap.<String, String>of();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, Provider<String>> providerStrings() {",
+                "    return ImmutableMap.<String, Provider<String>>of();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Integer> ints() {",
+                "    return ImmutableMap.<Integer, Integer>of(",
+                "        0, getMapOfIntegerAndProviderOfIntegerInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Provider<Integer>> providerInts() {",
+                "    return ImmutableMap.<Integer, Provider<Integer>>of(",
+                "        0, getMapOfIntegerAndProviderOfIntegerProvider());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Long> longs() {",
+                "    return ImmutableMap.<Long, Long>of(",
+                "        0L, getMapOfLongAndProviderOfLongInstance(),",
+                "        1L, getMapOfLongAndProviderOfLongInstance2(),",
+                "        2L, getMapOfLongAndProviderOfLongInstance3());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Provider<Long>> providerLongs() {",
+                "    return ImmutableMap.<Long, Provider<Long>>of(",
+                "        0L, getMapOfLongAndProviderOfLongProvider(),",
+                "        1L, getMapOfLongAndProviderOfLongProvider2(),",
+                "        2L, getMapOfLongAndProviderOfLongProvider3());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Sub sub() {",
+                "    return new SubImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubImpl implements Sub {",
+                "    private SubImpl() {}",
+                "",
+                "    private long getMapOfLongAndProviderOfLongInstance() {",
+                "      return MapModule.provideLong0();",
+                "    }",
+                "",
+                "    private long getMapOfLongAndProviderOfLongInstance2() {",
+                "      return MapModule.provideLong1();",
+                "    }",
+                "",
+                "    private long getMapOfLongAndProviderOfLongInstance3() {",
+                "      return MapModule.provideLong2();",
+                "    }",
+                "",
+                "    private long getMapOfLongAndProviderOfLongInstance4() {",
+                "      return SubcomponentMapModule.provideLong3();",
+                "    }",
+                "",
+                "    private long getMapOfLongAndProviderOfLongInstance5() {",
+                "      return SubcomponentMapModule.provideLong4();",
+                "    }",
+                "",
+                "    private long getMapOfLongAndProviderOfLongInstance6() {",
+                "      return SubcomponentMapModule.provideLong5();",
+                "    }",
+                "",
+                "    private Provider<Long> getMapOfLongAndProviderOfLongProvider() {",
+                "      return new Provider<Long>() {",
+                "        @Override",
+                "        public Long get() {",
+                "          return getMapOfLongAndProviderOfLongInstance();",
+                "        }",
+                "      };",
+                "    }",
+                "",
+                "    private Provider<Long> getMapOfLongAndProviderOfLongProvider2() {",
+                "      return new Provider<Long>() {",
+                "        @Override",
+                "        public Long get() {",
+                "          return getMapOfLongAndProviderOfLongInstance2();",
+                "        }",
+                "      };",
+                "    }",
+                "",
+                "    private Provider<Long> getMapOfLongAndProviderOfLongProvider3() {",
+                "      return new Provider<Long>() {",
+                "        @Override",
+                "        public Long get() {",
+                "          return getMapOfLongAndProviderOfLongInstance3();",
+                "        }",
+                "      };",
+                "    }",
+                "",
+                "    private Provider<Long> getMapOfLongAndProviderOfLongProvider4() {",
+                "      return new Provider<Long>() {",
+                "        @Override",
+                "        public Long get() {",
+                "          return getMapOfLongAndProviderOfLongInstance4();",
+                "        }",
+                "      };",
+                "    }",
+                "",
+                "    private Provider<Long> getMapOfLongAndProviderOfLongProvider5() {",
+                "      return new Provider<Long>() {",
+                "        @Override",
+                "        public Long get() {",
+                "          return getMapOfLongAndProviderOfLongInstance5();",
+                "        }",
+                "      };",
+                "    }",
+                "",
+                "    private Provider<Long> getMapOfLongAndProviderOfLongProvider6() {",
+                "      return new Provider<Long>() {",
+                "        @Override",
+                "        public Long get() {",
+                "          return getMapOfLongAndProviderOfLongInstance6();",
+                "        }",
+                "      };",
+                "    }",
+                "",
+                "    @Override",
+                "    public Map<Long, Long> longs() {",
+                "      return ImmutableMap.<Long, Long>builder()",
+                "          .put(0L, getMapOfLongAndProviderOfLongInstance())",
+                "          .put(1L, getMapOfLongAndProviderOfLongInstance2())",
+                "          .put(2L, getMapOfLongAndProviderOfLongInstance3())",
+                "          .put(3L, getMapOfLongAndProviderOfLongInstance4())",
+                "          .put(4L, getMapOfLongAndProviderOfLongInstance5())",
+                "          .put(5L, getMapOfLongAndProviderOfLongInstance6())",
+                "          .build();",
+                "    }",
+                "",
+                "    @Override",
+                "    public Map<Long, Provider<Long>> providerLongs() {",
+                "      return ImmutableMap.<Long, Provider<Long>>builder()",
+                "          .put(0L, getMapOfLongAndProviderOfLongProvider())",
+                "          .put(1L, getMapOfLongAndProviderOfLongProvider2())",
+                "          .put(2L, getMapOfLongAndProviderOfLongProvider3())",
+                "          .put(3L, getMapOfLongAndProviderOfLongProvider4())",
+                "          .put(4L, getMapOfLongAndProviderOfLongProvider5())",
+                "          .put(5L, getMapOfLongAndProviderOfLongProvider6())",
+                "          .build();",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, String> strings() {",
+                "    return ImmutableMap.<String, String>of();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<String, Provider<String>> providerStrings() {",
+                "    return ImmutableMap.<String, Provider<String>>of();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Integer> ints() {",
+                "    return ImmutableMap.<Integer, Integer>of(0, MapModule.provideInt());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Integer, Provider<Integer>> providerInts() {",
+                "    return ImmutableMap.<Integer, Provider<Integer>>of(",
+                "        0, MapModule_ProvideIntFactory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Long> longs() {",
+                "    return ImmutableMap.<Long, Long>of(",
+                "      0L, MapModule.provideLong0(),",
+                "      1L, MapModule.provideLong1(),",
+                "      2L, MapModule.provideLong2());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<Long, Provider<Long>> providerLongs() {",
+                "    return ImmutableMap.<Long, Provider<Long>>of(",
+                "      0L, MapModule_ProvideLong0Factory.create(),",
+                "      1L, MapModule_ProvideLong1Factory.create(),",
+                "      2L, MapModule_ProvideLong2Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Sub sub() {",
+                "    return new SubImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "  private final class SubImpl implements Sub {",
+                "    private SubImpl() {}",
+                "",
+                "    @Override",
+                "    public Map<Long, Long> longs() {",
+                "      return ImmutableMap.<Long, Long>builder()",
+                "          .put(0L, MapModule.provideLong0())",
+                "          .put(1L, MapModule.provideLong1())",
+                "          .put(2L, MapModule.provideLong2())",
+                "          .put(3L, SubcomponentMapModule.provideLong3())",
+                "          .put(4L, SubcomponentMapModule.provideLong4())",
+                "          .put(5L, SubcomponentMapModule.provideLong5())",
+                "          .build();",
+                "    }",
+                "",
+                "    @Override",
+                "    public Map<Long, Provider<Long>> providerLongs() {",
+                "      return ImmutableMap.<Long, Provider<Long>>builder()",
+                "          .put(0L, MapModule_ProvideLong0Factory.create())",
+                "          .put(1L, MapModule_ProvideLong1Factory.create())",
+                "          .put(2L, MapModule_ProvideLong2Factory.create())",
+                "          .put(3L, SubcomponentMapModule_ProvideLong3Factory.create())",
+                "          .put(4L, SubcomponentMapModule_ProvideLong4Factory.create())",
+                "          .put(5L, SubcomponentMapModule_ProvideLong5Factory.create())",
+                "          .build();",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(mapModuleFile, componentFile, subcomponentModuleFile, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void inaccessible() {
+    JavaFileObject inaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible", "package other;", "", "class Inaccessible {}");
+    JavaFileObject usesInaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.UsesInaccessible",
+            "package other;",
+            "",
+            "import java.util.Map;",
+            "import javax.inject.Inject;",
+            "",
+            "public class UsesInaccessible {",
+            "  @Inject UsesInaccessible(Map<Integer, Inaccessible> map) {}",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "other.TestModule",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "public abstract class TestModule {",
+            "  @Multibinds abstract Map<Integer, Inaccessible> ints();",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "import other.TestModule;",
+            "import other.UsesInaccessible;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  UsesInaccessible usesInaccessible();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private UsesInaccessible getUsesInaccessibleInstance() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible((Map) ImmutableMap.of());",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return getUsesInaccessibleInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible((Map) ImmutableMap.of());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, inaccessible, usesInaccessible, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void subcomponentOmitsInheritedBindings() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
+            "    return \"parent value\";",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Map<String, Object> objectMap();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private ParentModule parentModule;",
+                "",
+                "  private DaggerParent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Object getMapOfStringAndProviderOfObjectInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        parentModule.parentKeyObject(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    @Override",
+                "    public Map<String, Object> objectMap() {",
+                "      return ImmutableMap.<String, Object>of(",
+                "          \"parent key\",",
+                "          DaggerParent.this.getMapOfStringAndProviderOfObjectInstance());",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private ParentModule parentModule;",
+                "",
+                "  private DaggerParent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    @Override",
+                "    public Map<String, Object> objectMap() {",
+                "      return ImmutableMap.<String, Object>of(",
+                "          \"parent key\",",
+                "          Preconditions.checkNotNull(",
+                "              DaggerParent.this.parentModule.parentKeyObject(),",
+                "              " + NPE_FROM_PROVIDES_METHOD + ");",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(parent, parentModule, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void productionComponents() {
+    JavaFileObject mapModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface MapModule {",
+            "  @Multibinds Map<String, String> stringMap();",
+            "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProductionComponent;",
+        "import java.util.Map;",
+        "",
+        "@ProductionComponent(modules = MapModule.class)",
+        "interface TestComponent {",
+        "  ListenableFuture<Map<String, String>> stringMap();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private DaggerTestComponent(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public ListenableFuture<Map<String, String>> stringMap() {",
+            "    return Futures.<Map<String, String>>immediateFuture(",
+            "        ImmutableMap.<String, String>of());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder testComponent_ProductionExecutorModule(",
+            "        TestComponent_ProductionExecutorModule",
+            "            testComponent_ProductionExecutorModule) {",
+            "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(mapModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MapKeyProcessorTest.java b/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
index 62fe2fdb6..fc1da0395 100644
--- a/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -20,17 +20,31 @@
 import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.auto.value.processor.AutoAnnotationProcessor;
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class MapKeyProcessorTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public MapKeyProcessorTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
   @Test
   public void mapKeyCreatorFile() {
     JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
@@ -71,6 +85,7 @@ public void mapKeyCreatorFile() {
             "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(enumKeyFile, pathEnumFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
         .compilesWithoutError()
         .and()
@@ -121,6 +136,7 @@ public void nestedMapKeyCreatorFile() {
             "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(enumKeyFile, pathEnumFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
         .compilesWithoutError()
         .and()
@@ -207,85 +223,187 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "interface TestComponent {",
         "  Map<PathKey, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Handler> provideAdminHandlerProvider;",
-            "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathKey, Provider<Handler>>>",
-            "      mapOfPathKeyAndProviderOfHandlerProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.provideAdminHandlerProvider =",
-            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-            "    this.provideLoginHandlerProvider =",
-            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathKey, Handler>builder(2)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
-            "                provideAdminHandlerProvider)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-            "                provideLoginHandlerProvider)",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private MapModuleOne mapModuleOne;",
-            "    private MapModuleTwo mapModuleTwo;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (mapModuleOne == null) {",
-            "        this.mapModuleOne = new MapModuleOne();",
-            "      }",
-            "      if (mapModuleTwo == null) {",
-            "        this.mapModuleTwo = new MapModuleTwo();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private MapModuleOne mapModuleOne;",
+                "",
+                "  private MapModuleTwo mapModuleTwo;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Handler getMapOfPathKeyAndProviderOfHandlerInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModuleOne.provideAdminHandler(),",
+                "        " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Handler> getMapOfPathKeyAndProviderOfHandlerProvider() {",
+                "    return new Provider<Handler>() {",
+                "      @Override",
+                "      public Handler get() {",
+                "        return getMapOfPathKeyAndProviderOfHandlerInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private Handler getMapOfPathKeyAndProviderOfHandlerInstance2() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModuleTwo.provideLoginHandler(),",
+                "        " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Handler> getMapOfPathKeyAndProviderOfHandlerProvider2() {",
+                "    return new Provider<Handler>() {",
+                "      @Override",
+                "      public Handler get() {",
+                "        return getMapOfPathKeyAndProviderOfHandlerInstance2();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.mapModuleOne = builder.mapModuleOne;",
+                "    this.mapModuleTwo = builder.mapModuleTwo;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+                "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
+                "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
+                "        getMapOfPathKeyAndProviderOfHandlerProvider(),",
+                "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+                "        getMapOfPathKeyAndProviderOfHandlerProvider2());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Provider<Handler> provideAdminHandlerProvider;",
+                "  private Provider<Handler> provideLoginHandlerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.provideAdminHandlerProvider =",
+                "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+                "    this.provideLoginHandlerProvider =",
+                "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+                "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
+                "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
+                "        provideAdminHandlerProvider,",
+                "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+                "        provideLoginHandlerProvider);",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
         .that(
             ImmutableList.of(
@@ -297,6 +415,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
                 loginHandlerFile,
                 adminHandlerFile,
                 componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
         .compilesWithoutError()
         .and()
@@ -382,85 +501,187 @@ public void mapKeyComponentFileWithDefaultField() {
         "interface TestComponent {",
         "  Map<PathKey, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Handler> provideAdminHandlerProvider;",
-            "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathKey, Provider<Handler>>>",
-            "      mapOfPathKeyAndProviderOfHandlerProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.provideAdminHandlerProvider =",
-            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-            "    this.provideLoginHandlerProvider =",
-            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathKey, Handler>builder(2)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
-            "                provideAdminHandlerProvider)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-            "                provideLoginHandlerProvider)",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private MapModuleOne mapModuleOne;",
-            "    private MapModuleTwo mapModuleTwo;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (mapModuleOne == null) {",
-            "        this.mapModuleOne = new MapModuleOne();",
-            "      }",
-            "      if (mapModuleTwo == null) {",
-            "        this.mapModuleTwo = new MapModuleTwo();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private MapModuleOne mapModuleOne;",
+                "",
+                "  private MapModuleTwo mapModuleTwo;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Handler getMapOfPathKeyAndProviderOfHandlerInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModuleOne.provideAdminHandler(),",
+                "        " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Handler> getMapOfPathKeyAndProviderOfHandlerProvider() {",
+                "    return new Provider<Handler>() {",
+                "      @Override",
+                "      public Handler get() {",
+                "        return getMapOfPathKeyAndProviderOfHandlerInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private Handler getMapOfPathKeyAndProviderOfHandlerInstance2() {",
+                "    return Preconditions.checkNotNull(",
+                "        mapModuleTwo.provideLoginHandler(),",
+                "        " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Handler> getMapOfPathKeyAndProviderOfHandlerProvider2() {",
+                "    return new Provider<Handler>() {",
+                "      @Override",
+                "      public Handler get() {",
+                "        return getMapOfPathKeyAndProviderOfHandlerInstance2();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.mapModuleOne = builder.mapModuleOne;",
+                "    this.mapModuleTwo = builder.mapModuleTwo;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+                "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
+                "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
+                "        getMapOfPathKeyAndProviderOfHandlerProvider(),",
+                "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+                "        getMapOfPathKeyAndProviderOfHandlerProvider2());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableMap;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Map;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Provider<Handler> provideAdminHandlerProvider;",
+                "  private Provider<Handler> provideLoginHandlerProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.provideAdminHandlerProvider =",
+                "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+                "    this.provideLoginHandlerProvider =",
+                "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+                "  }",
+                "",
+                "  @Override",
+                "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+                "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
+                "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
+                "        provideAdminHandlerProvider,",
+                "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+                "        provideLoginHandlerProvider);",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private MapModuleOne mapModuleOne;",
+                "    private MapModuleTwo mapModuleTwo;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      if (mapModuleOne == null) {",
+                "        this.mapModuleOne = new MapModuleOne();",
+                "      }",
+                "      if (mapModuleTwo == null) {",
+                "        this.mapModuleTwo = new MapModuleTwo();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+                "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+                "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
         .that(
             ImmutableList.of(
@@ -472,6 +693,7 @@ public void mapKeyComponentFileWithDefaultField() {
                 loginHandlerFile,
                 adminHandlerFile,
                 componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
         .compilesWithoutError()
         .and()
@@ -515,6 +737,7 @@ public void mapKeyWithDefaultValue() {
             "  boolean value() default false;",
             "}");
     assertThat(module, mapKey)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
         .compilesWithoutError();
   }
diff --git a/javatests/dagger/internal/codegen/MembersInjectionTest.java b/javatests/dagger/internal/codegen/MembersInjectionTest.java
index 35337fce5..4100bdcea 100644
--- a/javatests/dagger/internal/codegen/MembersInjectionTest.java
+++ b/javatests/dagger/internal/codegen/MembersInjectionTest.java
@@ -17,9 +17,11 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static javax.tools.StandardLocation.CLASS_OUTPUT;
@@ -27,9 +29,11 @@
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import java.io.IOException;
 import java.io.Writer;
+import java.util.Collection;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
@@ -37,10 +41,22 @@
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class MembersInjectionTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public MembersInjectionTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
   @Test
   public void parentClass_noInjectedMembers() {
     JavaFileObject childFile = JavaFileObjects.forSourceLines("test.Child",
@@ -61,61 +77,92 @@ public void parentClass_noInjectedMembers() {
         "",
         "import dagger.Component;",
         "",
-        "",
         "@Component",
         "interface TestComponent {",
         "  Child child();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MembersInjectors;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Child> childProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return new Builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.childProvider =",
-        "        Child_Factory.create(MembersInjectors.<Child>noOp());",
-        "  }",
-        "",
-        "  @Override",
-        "  public Child child() {",
-        "    return childProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Child getChildInstance() {",
+                "    return new Child();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return getChildInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new Child();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
         .that(ImmutableList.of(childFile, parentFile, componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
@@ -149,59 +196,105 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         "import dagger.Component;",
         "",
-        "",
         "@Component",
         "interface TestComponent {",
         "  Child child();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private MembersInjector<Child> childMembersInjector;",
-            "  private Provider<Child> childProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.childMembersInjector = Child_MembersInjector.create(Dep_Factory.create());",
-            "    this.childProvider = Child_Factory.create(childMembersInjector);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Child child() {",
-            "    return childProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Dep getDepInstance() {",
+                "    return new Dep();",
+                "  }",
+                "",
+                "  private Child getChildInstance() {",
+                "    return injectChild(Child_Factory.newChild());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return getChildInstance();",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private Child injectChild(Child instance) {",
+                "    Parent_MembersInjector.injectDep(instance, getDepInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return injectChild(Child_Factory.newChild());",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private Child injectChild(Child instance) {",
+                "    Parent_MembersInjector.injectDep(instance, new Dep());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
         .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -236,9 +329,7 @@ public void parentClass_injectedMembersInSupertype() {
         "  private final Provider<B> bProvider;",
         "",
         "  public GenericClass_MembersInjector(Provider<A> aProvider, Provider<B> bProvider) {",
-        "    assert aProvider != null;",
         "    this.aProvider = aProvider;",
-        "    assert bProvider != null;",
         "    this.bProvider = bProvider;",
         "  }",
         "",
@@ -249,25 +340,21 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         "  @Override",
         "  public void injectMembers(GenericClass<A, B> instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.a = aProvider.get();",
-        "    instance.register(bProvider.get());",
+        "    injectA(instance, aProvider.get());",
+        "    injectRegister(instance, bProvider.get());",
         "  }",
         "",
-        "  public static <A, B> void injectA(GenericClass<A, B> instance, Provider<A> aProvider) {",
-        "    instance.a = aProvider.get();",
+        "  public static <A, B> void injectA(Object instance, A a) {",
+        "    ((GenericClass<A, B>) instance).a = a;",
         "  }",
         "",
-        "  public static <A, B> void injectRegister(",
-        "      GenericClass<A, B> instance, Provider<B> bProvider) {",
-        "    instance.register(bProvider.get());",
+        "  public static <A, B> void injectRegister(Object instance, B b) {",
+        "    ((GenericClass<A, B>) instance).register(b);",
         "  }",
-        "",
         "}");
     assertAbout(javaSource())
         .that(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -331,11 +418,8 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         "  public Child_MembersInjector(",
         "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
-        "    assert tAndXProvider != null;",
         "    this.tAndXProvider = tAndXProvider;",
-        "    assert aAndYProvider != null;",
         "    this.aAndYProvider = aAndYProvider;",
-        "    assert a2Provider != null;",
         "    this.a2Provider = a2Provider;",
         "  }",
         "",
@@ -346,26 +430,24 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         "  @Override",
         "  public void injectMembers(Child<T> instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    ((Parent) instance).x = tAndXProvider.get();",
-        "    ((Parent) instance).y = aAndYProvider.get();",
-        "    ((Parent) instance).a2 = a2Provider.get();",
-        "    instance.a = aAndYProvider.get();",
-        "    instance.t = tAndXProvider.get();",
+        "    Parent_MembersInjector.injectX(instance, tAndXProvider.get());",
+        "    Parent_MembersInjector.injectY(instance, aAndYProvider.get());",
+        "    Parent_MembersInjector.injectA2(instance, a2Provider.get());",
+        "    injectA(instance, aAndYProvider.get());",
+        "    injectT(instance, tAndXProvider.get());",
         "  }",
         "",
-        "  public static <T> void injectA(Child<T> instance, Provider<A> aProvider) {",
-        "    instance.a = aProvider.get();",
+        "  public static <T> void injectA(Object instance, Object a) {",
+        "    ((Child<T>) instance).a = (A) a;",
         "  }",
         "",
-        "  public static <T> void injectT(Child<T> instance, Provider<T> tProvider) {",
-        "    instance.t = tProvider.get();",
+        "  public static <T> void injectT(Object instance, T t) {",
+        "    ((Child<T>) instance).t = t;",
         "  }",
         "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(a, a2, parent, child))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -390,6 +472,7 @@ public void parentClass_injectedMembersInSupertype() {
             "test.FieldInjection_MembersInjector",
             "package test;",
             "",
+            "import dagger.Lazy;",
             "import dagger.MembersInjector;",
             "import dagger.internal.DoubleCheck;",
             "import javax.annotation.Generated;",
@@ -401,41 +484,37 @@ public void parentClass_injectedMembersInSupertype() {
             "  private final Provider<String> stringProvider;",
             "",
             "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
-            "    assert stringProvider != null;",
             "    this.stringProvider = stringProvider;",
             "  }",
             "",
-            "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
+            "  public static MembersInjector<FieldInjection> create(",
+            "      Provider<String> stringProvider) {",
             "    return new FieldInjection_MembersInjector(stringProvider);",
             "  }",
             "",
             "  @Override",
             "  public void injectMembers(FieldInjection instance) {",
-            "    if (instance == null) {",
-            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-            "    }",
-            "    instance.string = stringProvider.get();",
-            "    instance.lazyString = DoubleCheck.lazy(stringProvider);",
-            "    instance.stringProvider = stringProvider;",
+            "    injectString(instance, stringProvider.get());",
+            "    injectLazyString(instance, DoubleCheck.lazy(stringProvider));",
+            "    injectStringProvider(instance, stringProvider);",
             "  }",
             "",
-            "  public static void injectString(",
-            "      FieldInjection instance, Provider<String> stringProvider) {",
-            "    instance.string = stringProvider.get();",
+            "  public static void injectString(Object instance, String string) {",
+            "    ((FieldInjection) instance).string = string;",
             "  }",
             "",
-            "  public static void injectLazyString(",
-            "      FieldInjection instance, Provider<String> lazyStringProvider) {",
-            "    instance.lazyString = DoubleCheck.lazy(lazyStringProvider);",
+            "  public static void injectLazyString(Object instance, Lazy<String> lazyString) {",
+            "    ((FieldInjection) instance).lazyString = lazyString;",
             "  }",
             "",
             "  public static void injectStringProvider(",
-            "      FieldInjection instance, Provider<String> stringProvider) {",
-            "    instance.stringProvider = stringProvider;",
+            "      Object instance, Provider<String> stringProvider) {",
+            "    ((FieldInjection) instance).stringProvider = stringProvider;",
             "  }",
             "}");
     assertAbout(javaSource())
         .that(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -461,6 +540,7 @@ public void parentClass_injectedMembersInSupertype() {
             "test.MethodInjection_MembersInjector",
             "package test;",
             "",
+            "import dagger.Lazy;",
             "import dagger.MembersInjector;",
             "import dagger.internal.DoubleCheck;",
             "import javax.annotation.Generated;",
@@ -473,7 +553,6 @@ public void parentClass_injectedMembersInSupertype() {
             "  private final Provider<String> stringProvider;",
             "",
             "  public MethodInjection_MembersInjector(Provider<String> stringProvider) {",
-            "    assert stringProvider != null;",
             "    this.stringProvider = stringProvider;",
             "  }",
             "",
@@ -484,39 +563,34 @@ public void parentClass_injectedMembersInSupertype() {
             "",
             "  @Override",
             "  public void injectMembers(MethodInjection instance) {",
-            "    if (instance == null) {",
-            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-            "    }",
-            "    instance.noArgs();",
-            "    instance.oneArg(stringProvider.get());",
-            "    instance.manyArgs(",
+            "    injectNoArgs(instance);",
+            "    injectOneArg(instance, stringProvider.get());",
+            "    injectManyArgs(",
+            "        instance,",
             "        stringProvider.get(),",
             "        DoubleCheck.lazy(stringProvider),",
             "        stringProvider);",
             "  }",
             "",
-            "  public static void injectNoArgs(MethodInjection instance) {",
-            "    instance.noArgs();",
+            "  public static void injectNoArgs(Object instance) {",
+            "    ((MethodInjection) instance).noArgs();",
             "  }",
             "",
-            "  public static void injectOneArg(",
-            "      MethodInjection instance, Provider<String> stringProvider) {",
-            "    instance.oneArg(stringProvider.get());",
+            "  public static void injectOneArg(Object instance, String string) {",
+            "    ((MethodInjection) instance).oneArg(string);",
             "  }",
             "",
             "  public static void injectManyArgs(",
-            "      MethodInjection instance,",
-            "      Provider<String> stringProvider,",
-            "      Provider<String> lazyStringProvider,",
-            "      Provider<String> stringProvider2) {",
-            "    instance.manyArgs(",
-            "        stringProvider.get(),",
-            "        DoubleCheck.lazy(lazyStringProvider),",
-            "        stringProvider2);",
+            "      Object instance,",
+            "      String string,",
+            "      Lazy<String> lazyString,",
+            "      Provider<String> stringProvider) {",
+            "    ((MethodInjection) instance).manyArgs(string, lazyString, stringProvider);",
             "  }",
             "}");
     assertAbout(javaSource())
         .that(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -557,9 +631,7 @@ public void mixedMemberInjection() {
         "  public MixedMemberInjection_MembersInjector(",
         "      Provider<String> stringAndSProvider,",
         "      Provider<Object> objectAndOProvider) {",
-        "    assert stringAndSProvider != null;",
         "    this.stringAndSProvider = stringAndSProvider;",
-        "    assert objectAndOProvider != null;",
         "    this.objectAndOProvider = objectAndOProvider;",
         "  }",
         "",
@@ -572,37 +644,31 @@ public void mixedMemberInjection() {
         "",
         "  @Override",
         "  public void injectMembers(MixedMemberInjection instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.string = stringAndSProvider.get();",
-        "    instance.object = objectAndOProvider.get();",
-        "    instance.setString(stringAndSProvider.get());",
-        "    instance.setObject(objectAndOProvider.get());",
+        "    injectString(instance, stringAndSProvider.get());",
+        "    injectObject(instance, objectAndOProvider.get());",
+        "    injectSetString(instance, stringAndSProvider.get());",
+        "    injectSetObject(instance, objectAndOProvider.get());",
         "  }",
         "",
-        "  public static void injectString(",
-        "      MixedMemberInjection instance, Provider<String> stringProvider) {",
-        "    instance.string = stringProvider.get();",
+        "  public static void injectString(Object instance, String string) {",
+        "    ((MixedMemberInjection) instance).string = string;",
         "  }",
         "",
-        "  public static void injectObject(",
-        "      MixedMemberInjection instance, Provider<Object> objectProvider) {",
-        "    instance.object = objectProvider.get();",
+        "  public static void injectObject(Object instance, Object object) {",
+        "    ((MixedMemberInjection) instance).object = object;",
         "  }",
         "",
-        "  public static void injectSetString(",
-        "      MixedMemberInjection instance, Provider<String> sProvider) {",
-        "    instance.setString(sProvider.get());",
+        "  public static void injectSetString(Object instance, String s) {",
+        "    ((MixedMemberInjection) instance).setString(s);",
         "  }",
         "",
-        "  public static void injectSetObject(",
-        "      MixedMemberInjection instance, Provider<Object> oProvider) {",
-        "    instance.setObject(oProvider.get());",
+        "  public static void injectSetObject(Object instance, Object o) {",
+        "    ((MixedMemberInjection) instance).setObject(o);",
         "  }",
         "}");
     assertAbout(javaSource())
         .that(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -635,7 +701,6 @@ public void mixedMemberInjection() {
         "  private final Provider<String> sProvider;",
         "",
         "  public AllInjections_MembersInjector(Provider<String> sProvider) {",
-        "    assert sProvider != null;",
         "    this.sProvider = sProvider;",
         "  }",
         "",
@@ -645,19 +710,24 @@ public void mixedMemberInjection() {
         "",
         "  @Override",
         "  public void injectMembers(AllInjections instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.s = sProvider.get();",
-        "    instance.s(sProvider.get());",
+        "    injectS(instance, sProvider.get());",
+        "    injectS2(instance, sProvider.get());",
         "  }",
         "",
-        "  public static void injectS(AllInjections instance, Provider<String> sProvider) {",
-        "    instance.s = sProvider.get();",
+        // TODO(b/64477506): now that these all take "object", it would be nice to rename "instance"
+        // to the type name
+        "  public static void injectS(Object instance, String s) {",
+        "    ((AllInjections) instance).s = s;",
         "  }",
+        "",
+        "  public static void injectS2(Object instance, String s) {",
+        "    ((AllInjections) instance).s(s);",
+        "  }",
+        "",
         "}");
     assertAbout(javaSource())
         .that(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -690,7 +760,6 @@ public void mixedMemberInjection() {
         "  private final Provider<String> sProvider;",
         "",
         "  public B_MembersInjector(Provider<String> sProvider) {",
-        "    assert sProvider != null;",
         "    this.sProvider = sProvider;",
         "  }",
         "",
@@ -700,18 +769,16 @@ public void mixedMemberInjection() {
         "",
         "  @Override",
         "  public void injectMembers(B instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.s = sProvider.get();",
+        "    injectS(instance, sProvider.get());",
         "  }",
         "",
-        "  public static void injectS(B instance, Provider<String> sProvider) {",
-        "    instance.s = sProvider.get();",
+        "  public static void injectS(Object instance, String s) {",
+        "    ((B) instance).s = s;",
         "  }",
         "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(aFile, bFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -753,7 +820,6 @@ public void simpleComponentWithNesting() {
           "  private final Provider<OuterType.A> aProvider;",
           "",
           "  public OuterType_B_MembersInjector(Provider<OuterType.A> aProvider) {",
-          "    assert aProvider != null;",
           "    this.aProvider = aProvider;",
           "  }",
           "",
@@ -763,18 +829,16 @@ public void simpleComponentWithNesting() {
           "",
           "  @Override",
           "  public void injectMembers(OuterType.B instance) {",
-          "    if (instance == null) {",
-          "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-          "    }",
-          "    instance.a = aProvider.get();",
+          "    injectA(instance, aProvider.get());",
           "  }",
           "",
-          "  public static void injectA(OuterType.B instance, Provider<OuterType.A> aProvider) {",
-          "    instance.a = aProvider.get();",
+          "  public static void injectA(Object instance, Object a) {",
+          "    ((OuterType.B) instance).a = (OuterType.A) a;",
           "  }",
           "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(nestedTypesFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -819,28 +883,26 @@ public void componentWithNestingAndGeneratedType() {
             "  private final Provider<OuterType.A> aProvider;",
             "",
             "  public OuterType_B_MembersInjector(Provider<OuterType.A> aProvider) {",
-            "    assert aProvider != null;",
             "    this.aProvider = aProvider;",
             "  }",
             "",
-            "  public static MembersInjector<OuterType.B> create(Provider<OuterType.A> aProvider) {",
+            "  public static MembersInjector<OuterType.B> create(",
+            "      Provider<OuterType.A> aProvider) {",
             "    return new OuterType_B_MembersInjector(aProvider);",
             "  }",
             "",
             "  @Override",
             "  public void injectMembers(OuterType.B instance) {",
-            "    if (instance == null) {",
-            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-            "    }",
-            "    instance.a = aProvider.get();",
+            "    injectA(instance, aProvider.get());",
             "  }",
             "",
-            "  public static void injectA(OuterType.B instance, Provider<OuterType.A> aProvider) {",
-            "    instance.a = aProvider.get();",
+            "  public static void injectA(Object instance, Object a) {",
+            "    ((OuterType.B) instance).a = (OuterType.A) a;",
             "  }",
             "}");
     assertAbout(javaSource())
         .that(nestedTypesFile)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(
             new ComponentProcessor(),
             new AbstractProcessor() {
@@ -857,10 +919,10 @@ public boolean process(
                 if (!done) {
                   done = true;
                   try (Writer writer =
-                          processingEnv
-                              .getFiler()
-                              .createSourceFile("test.GeneratedType")
-                              .openWriter()) {
+                      processingEnv
+                          .getFiler()
+                          .createSourceFile("test.GeneratedType")
+                          .openWriter()) {
                     writer.write(
                         Joiner.on('\n')
                             .join(
@@ -921,9 +983,11 @@ public void lowerCaseNamedMembersInjector_forLowerCaseType() {
 
     assertAbout(javaSources())
         .that(ImmutableList.of(foo, fooModule, fooComponent))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesFileNamed(CLASS_OUTPUT, "test", "foo_MembersInjector.class");
+        .and()
+        .generatesFileNamed(CLASS_OUTPUT, "test", "foo_MembersInjector.class");
   }
 
   @Test
@@ -996,9 +1060,7 @@ public void fieldInjectionForShadowedMember() {
             "",
             "  public Child_MembersInjector(",
             "        Provider<Foo> objectProvider, Provider<Bar> objectProvider2) {",
-            "    assert objectProvider != null;",
             "    this.objectProvider = objectProvider;",
-            "    assert objectProvider2 != null;",
             "    this.objectProvider2 = objectProvider2;",
             "  }",
             "",
@@ -1009,24 +1071,22 @@ public void fieldInjectionForShadowedMember() {
             "",
             "  @Override",
             "  public void injectMembers(Child instance) {",
-            "    if (instance == null) {",
-            "      throw new NullPointerException(",
-            "          \"Cannot inject members into a null reference\");",
-            "    }",
-            "    ((Parent) instance).object = objectProvider.get();",
-            "    instance.object = objectProvider2.get();",
+            "    Parent_MembersInjector.injectObject(instance, objectProvider.get());",
+            "    injectObject(instance, objectProvider2.get());",
             "  }",
             "",
-            "  public static void injectObject(Child instance, Provider<Bar> objectProvider) {",
-            "    instance.object = objectProvider.get();",
+            "  public static void injectObject(Object instance, Object object) {",
+            "    ((Child) instance).object = (Bar) object;",
             "  }",
             "}");
 
     assertAbout(javaSources())
         .that(ImmutableList.of(foo, bar, parent, child, component))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expectedMembersInjector);
+        .and()
+        .generatesSources(expectedMembersInjector);
   }
 
   @Test public void privateNestedClassError() {
@@ -1042,8 +1102,12 @@ public void fieldInjectionForShadowedMember() {
         "}");
     assertAbout(javaSource())
         .that(file)
-        .processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);
+        .withCompilerOptions(compilerMode.javacopts())
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS)
+        .in(file)
+        .onLine(6);
   }
 
   @Test public void privateNestedClassWarning() {
@@ -1059,10 +1123,13 @@ public void fieldInjectionForShadowedMember() {
         "}");
     assertAbout(javaSource())
         .that(file)
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .withCompilerOptions(
+            compilerMode.javacopts().append("-Adagger.privateMemberValidation=WARNING"))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);
+        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS)
+        .in(file)
+        .onLine(6);
   }
 
   @Test public void privateSuperclassIsOkIfNotInjectedInto() {
@@ -1080,6 +1147,7 @@ public void fieldInjectionForShadowedMember() {
         "}");
     assertAbout(javaSource())
         .that(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
@@ -1108,10 +1176,710 @@ public void fieldInjectionForShadowedMember() {
             "  void inject(RawProviderParameter rawProviderParameter);",
             "}");
     assertThat(file)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("javax.inject.Provider cannot be provided").in(file).onLine(17)
+        .withErrorContaining("javax.inject.Provider cannot be provided")
+        .in(file)
+        .onLine(17)
         .and()
-        .withErrorContaining("javax.inject.Provider cannot be provided").in(file).onLine(18);
+        .withErrorContaining("javax.inject.Provider cannot be provided")
+        .in(file)
+        .onLine(18);
+  }
+
+  @Test
+  public void injectsPrimitive() {
+    JavaFileObject injectedType =
+        JavaFileObjects.forSourceLines(
+            "test.InjectedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class InjectedType {",
+            "  @Inject InjectedType() {}",
+            "",
+            "  @Inject int primitiveInt;",
+            "  @Inject Integer boxedInt;",
+            "}");
+    JavaFileObject membersInjector =
+        JavaFileObjects.forSourceLines(
+            "test.InjectedType_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class InjectedType_MembersInjector ",
+            "    implements MembersInjector<InjectedType> {",
+            "  private final Provider<Integer> boxedIntAndPrimitiveIntProvider;",
+            "",
+            "  public InjectedType_MembersInjector(",
+            "      Provider<Integer> boxedIntAndPrimitiveIntProvider) {",
+            "    this.boxedIntAndPrimitiveIntProvider = boxedIntAndPrimitiveIntProvider;",
+            "  }",
+            "",
+            "  public static MembersInjector<InjectedType> create(",
+            "      Provider<Integer> boxedIntAndPrimitiveIntProvider) {",
+            "    return new InjectedType_MembersInjector(boxedIntAndPrimitiveIntProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectMembers(InjectedType instance) {",
+            "    injectPrimitiveInt(instance, boxedIntAndPrimitiveIntProvider.get());",
+            "    injectBoxedInt(instance, boxedIntAndPrimitiveIntProvider.get());",
+            "  }",
+            "",
+            "  public static void injectPrimitiveInt(Object instance, int primitiveInt) {",
+            "    ((InjectedType) instance).primitiveInt = primitiveInt;",
+            "  }",
+            "",
+            "  public static void injectBoxedInt(Object instance, Integer boxedInt) {",
+            "    ((InjectedType) instance).boxedInt = boxedInt;",
+            "  }",
+            "}");
+    JavaFileObject factory =
+        JavaFileObjects.forSourceLines(
+            "test.InjectedType_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class InjectedType_Factory implements Factory<InjectedType> {",
+            "  private final Provider<Integer> boxedIntAndPrimitiveIntProvider;",
+            "",
+            "  public InjectedType_Factory(Provider<Integer> boxedIntAndPrimitiveIntProvider) {",
+            "    this.boxedIntAndPrimitiveIntProvider = boxedIntAndPrimitiveIntProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public InjectedType get() {",
+            "    InjectedType instance = new InjectedType();",
+            "    InjectedType_MembersInjector.injectPrimitiveInt(",
+            "        instance, boxedIntAndPrimitiveIntProvider.get());",
+            "    InjectedType_MembersInjector.injectBoxedInt(",
+            "        instance, boxedIntAndPrimitiveIntProvider.get());",
+            "    return instance;",
+            "  }",
+            "",
+            "  public static Factory<InjectedType> create(",
+            "      Provider<Integer> boxedIntAndPrimitiveIntProvider) {",
+            "    return new InjectedType_Factory(boxedIntAndPrimitiveIntProvider);",
+            "  }",
+            "",
+            "  public static InjectedType newInjectedType() {",
+            "    return new InjectedType();",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(injectedType);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.InjectedType_MembersInjector")
+        .hasSourceEquivalentTo(membersInjector);
+    assertThat(compilation)
+        .generatedSourceFile("test.InjectedType_Factory")
+        .hasSourceEquivalentTo(factory);
+  }
+
+  @Test
+  public void accessibility() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "other.Foo",
+            "package other;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject inaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible",
+            "package other;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Inaccessible {",
+            "  @Inject Inaccessible() {}",
+            "  @Inject Foo foo;",
+            "  @Inject void method(Foo foo) {}",
+            "}");
+    JavaFileObject usesInaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.UsesInaccessible",
+            "package other;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "public class UsesInaccessible {",
+            "  @Inject UsesInaccessible(Inaccessible inaccessible) {}",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import other.UsesInaccessible;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  UsesInaccessible usesInaccessible();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, inaccessible, usesInaccessible, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("other.Inaccessible_MembersInjector")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "other.Inaccessible_MembersInjector",
+                "package other;",
+                "",
+                "import dagger.MembersInjector;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class Inaccessible_MembersInjector",
+                "    implements MembersInjector<Inaccessible> {",
+                "  private final Provider<Foo> fooProvider;",
+                "",
+                "  public Inaccessible_MembersInjector(Provider<Foo> fooProvider) {",
+                "    this.fooProvider = fooProvider;",
+                "  }",
+                "",
+                "  public static MembersInjector<Inaccessible> create(Provider<Foo> fooProvider) {",
+                "    return new Inaccessible_MembersInjector(fooProvider);",
+                "  }",
+                "",
+                "  @Override",
+                "  public void injectMembers(Inaccessible instance) {",
+                "    injectFoo(instance, fooProvider.get());",
+                "    injectMethod(instance, fooProvider.get());",
+                "  }",
+                "",
+                "  public static void injectFoo(Object instance, Object foo) {",
+                "    ((Inaccessible) instance).foo = (Foo) foo;",
+                "  }",
+                "",
+                "  public static void injectMethod(Object instance, Object foo) {",
+                "    ((Inaccessible) instance).method((Foo) foo);",
+                "  }",
+                "}"));
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "import other.Foo_Factory;",
+                "import other.Inaccessible_Factory;",
+                "import other.Inaccessible_MembersInjector;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Object getFooInstance() {",
+                "    return Foo_Factory.newFoo();",
+                "  }",
+                "",
+                "  private Object getInaccessibleInstance() {",
+                "    return injectInaccessible(Inaccessible_Factory.newInaccessible());",
+                "  }",
+                "",
+                "  private UsesInaccessible getUsesInaccessibleInstance() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        getInaccessibleInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return getUsesInaccessibleInstance();",
+                "  }",
+                "",
+                // TODO(ronshapiro): if possible, it would be great to rename "instance", but we
+                // need to make sure that this doesn't conflict with any framework field in this or
+                // any parent component
+                "  @CanIgnoreReturnValue",
+                "  private Object injectInaccessible(Object instance) {",
+                "    Inaccessible_MembersInjector.injectFoo(instance, getFooInstance());",
+                "    Inaccessible_MembersInjector.injectMethod(instance, getFooInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "import other.Foo_Factory;",
+                "import other.Inaccessible_Factory;",
+                "import other.Inaccessible_MembersInjector;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        injectInaccessible(Inaccessible_Factory.newInaccessible()));",
+                "  }",
+                "",
+                // TODO(ronshapiro): if possible, it would be great to rename "instance", but we
+                // need to make sure that this doesn't conflict with any framework field in this or
+                // any parent component
+                "  @CanIgnoreReturnValue",
+                "  private Object injectInaccessible(Object instance) {",
+                "    Inaccessible_MembersInjector.injectFoo(instance, Foo_Factory.newFoo());",
+                "    Inaccessible_MembersInjector.injectMethod(",
+                "        instance, Foo_Factory.newFoo());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void accessibleRawType_ofInaccessibleType() {
+    JavaFileObject inaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible",
+            "package other;",
+            "",
+            "class Inaccessible {}");
+    JavaFileObject inaccessiblesModule =
+        JavaFileObjects.forSourceLines(
+            "other.InaccessiblesModule",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import java.util.ArrayList;",
+            "import java.util.List;",
+            "import javax.inject.Provider;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Module",
+            "public class InaccessiblesModule {",
+            // force Provider initialization
+            "  @Provides @Singleton static List<Inaccessible> inaccessibles() {",
+            "    return new ArrayList<>();",
+            "  }",
+            "}");
+    JavaFileObject usesInaccessibles =
+        JavaFileObjects.forSourceLines(
+            "other.UsesInaccessibles",
+            "package other;",
+            "",
+            "import java.util.List;",
+            "import javax.inject.Inject;",
+            "",
+            "public class UsesInaccessibles {",
+            "  @Inject UsesInaccessibles() {}",
+            "  @Inject List<Inaccessible> inaccessibles;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "import other.UsesInaccessibles;",
+            "",
+            "@Singleton",
+            "@Component(modules = other.InaccessiblesModule.class)",
+            "interface TestComponent {",
+            "  UsesInaccessibles usesInaccessibles();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(inaccessible, inaccessiblesModule, usesInaccessibles, component);
+    assertThat(compilation).succeeded();
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "other.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import dagger.internal.DoubleCheck;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.List;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "import other.InaccessiblesModule;",
+                "import other.InaccessiblesModule_InaccessiblesFactory;",
+                "import other.UsesInaccessibles;",
+                "import other.UsesInaccessibles_Factory;",
+                "import other.UsesInaccessibles_MembersInjector;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  @SuppressWarnings(\"rawtypes\")",
+                "  private Provider inaccessiblesProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private UsesInaccessibles getUsesInaccessiblesInstance() {",
+                "    return injectUsesInaccessibles(",
+                "        UsesInaccessibles_Factory.newUsesInaccessibles());",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.inaccessiblesProvider =",
+                "        DoubleCheck.provider(InaccessiblesModule_InaccessiblesFactory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessibles usesInaccessibles() {",
+                "    return getUsesInaccessiblesInstance();",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private UsesInaccessibles injectUsesInaccessibles(UsesInaccessibles instance) {",
+                "    UsesInaccessibles_MembersInjector.injectInaccessibles(",
+                "        instance, (List) inaccessiblesProvider.get());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder inaccessiblesModule(InaccessiblesModule inaccessiblesModule) {",
+                "      Preconditions.checkNotNull(inaccessiblesModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "other.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import dagger.internal.DoubleCheck;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.List;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "import other.InaccessiblesModule;",
+                "import other.InaccessiblesModule_InaccessiblesFactory;",
+                "import other.UsesInaccessibles;",
+                "import other.UsesInaccessibles_Factory;",
+                "import other.UsesInaccessibles_MembersInjector;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  @SuppressWarnings(\"rawtypes\")",
+                "  private Provider inaccessiblesProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.inaccessiblesProvider =",
+                "        DoubleCheck.provider(InaccessiblesModule_InaccessiblesFactory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessibles usesInaccessibles() {",
+                "    return injectUsesInaccessibles(",
+                "        UsesInaccessibles_Factory.newUsesInaccessibles());",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private UsesInaccessibles injectUsesInaccessibles(",
+                "        UsesInaccessibles instance) {",
+                "    UsesInaccessibles_MembersInjector.injectInaccessibles(",
+                "        instance, (List) inaccessiblesProvider.get());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder inaccessiblesModule(InaccessiblesModule inaccessiblesModule) {",
+                "      Preconditions.checkNotNull(inaccessiblesModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void publicSupertypeHiddenSubtype() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "other.Foo",
+            "package other;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "other.Supertype",
+            "package other;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "public class Supertype<T> {",
+            "  @Inject T t;",
+            "}");
+    JavaFileObject subtype =
+        JavaFileObjects.forSourceLines(
+            "other.Subtype",
+            "package other;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Subtype extends Supertype<Foo> {",
+            "  @Inject Subtype() {}",
+            "}");
+    JavaFileObject injectsSubtype =
+        JavaFileObjects.forSourceLines(
+            "other.InjectsSubtype",
+            "package other;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "public class InjectsSubtype {",
+            "  @Inject InjectsSubtype(Subtype s) {}",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  other.InjectsSubtype injectsSubtype();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, supertype, subtype, injectsSubtype, component);
+    assertThat(compilation).succeeded();
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "import other.Foo_Factory;",
+                "import other.InjectsSubtype;",
+                "import other.InjectsSubtype_Factory;",
+                "import other.Subtype_Factory;",
+                "import other.Supertype;",
+                "import other.Supertype_MembersInjector;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Object getFooInstance() {",
+                "    return Foo_Factory.newFoo();",
+                "  }",
+                "",
+                "  private Object getSubtypeInstance() {",
+                "    return injectSubtype(Subtype_Factory.newSubtype());",
+                "  }",
+                "",
+                "  private InjectsSubtype getInjectsSubtypeInstance() {",
+                "    return InjectsSubtype_Factory.newInjectsSubtype(getSubtypeInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public InjectsSubtype injectsSubtype() {",
+                "    return getInjectsSubtypeInstance();",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private Object injectSubtype(Object instance) {",
+                "    Supertype_MembersInjector.injectT((Supertype) instance, getFooInstance());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import javax.annotation.Generated;",
+                "import other.Foo_Factory;",
+                "import other.InjectsSubtype;",
+                "import other.InjectsSubtype_Factory;",
+                "import other.Subtype_Factory;",
+                "import other.Supertype;",
+                "import other.Supertype_MembersInjector;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public InjectsSubtype injectsSubtype() {",
+                "    return InjectsSubtype_Factory.newInjectsSubtype(",
+                "        injectSubtype(Subtype_Factory.newSubtype()));",
+                "  }",
+                "",
+                "  @CanIgnoreReturnValue",
+                "  private Object injectSubtype(Object instance) {",
+                "    Supertype_MembersInjector.injectT(",
+                "        (Supertype) instance, Foo_Factory.newFoo());",
+                "    return instance;",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 }
diff --git a/javatests/dagger/internal/codegen/MissingAndroidProcessorTest.java b/javatests/dagger/internal/codegen/MissingAndroidProcessorTest.java
new file mode 100644
index 000000000..0f91e0ebf
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MissingAndroidProcessorTest.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MissingAndroidProcessorTest {
+  @Test
+  public void missingProcessor() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.android.ContributesAndroidInjector;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @ContributesAndroidInjector",
+            "  Object o();",
+            "}");
+    JavaFileObject contributesAndroidInjectorStub =
+        JavaFileObjects.forSourceLines(
+            "dagger.android.ContributesAndroidInjector",
+            "package dagger.android;",
+            "",
+            "public @interface ContributesAndroidInjector {}");
+    Compilation compilation = daggerCompiler().compile(module, contributesAndroidInjectorStub);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("dagger.android.processor.AndroidProcessor")
+        .inFile(module)
+        .onLine(9);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 8d02a499c..b30e3638a 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -261,7 +261,6 @@ public void providesMethodReturnsProduced() {
             "  private final TestModule module;",
             "",
             "  public TestModule_ProvideStringFactory(TestModule module) {",
-            "    assert module != null;",
             "    this.module = module;",
             "  }",
             "",
@@ -309,7 +308,6 @@ public void providesMethodReturnsProduced() {
             "  private final TestModule module;",
             "",
             "  public TestModule_ProvideStringFactory(TestModule module) {",
-            "    assert module != null;",
             "    this.module = module;",
             "  }",
             "",
@@ -356,7 +354,6 @@ public void providesMethodReturnsProduced() {
             "  private final TestModule module;",
             "",
             "  public TestModule_ProvideStringFactory(TestModule module) {",
-            "    assert module != null;",
             "    this.module = module;",
             "  }",
             "",
@@ -370,6 +367,7 @@ public void providesMethodReturnsProduced() {
             "    return new TestModule_ProvideStringFactory(module);",
             "  }",
             "",
+            "  @Nullable",
             "  public static String proxyProvideString(TestModule instance) {",
             "    return instance.provideString();",
             "  }",
@@ -453,13 +451,9 @@ public void providesMethodReturnsProduced() {
             "      Provider<Object> aProvider,",
             "      Provider<Object> bProvider,",
             "      MembersInjector<X> xMembersInjector) {",
-            "    assert module != null;",
             "    this.module = module;",
-            "    assert aProvider != null;",
             "    this.aProvider = aProvider;",
-            "    assert bProvider != null;",
             "    this.bProvider = bProvider;",
-            "    assert xMembersInjector != null;",
             "    this.xMembersInjector = xMembersInjector;",
             "  }",
             "",
@@ -479,8 +473,8 @@ public void providesMethodReturnsProduced() {
             "  }",
             "",
             "  public static List<Object> proxyProvideObjects(",
-            "      TestModule instance, Object a, Object b, Object x) {",
-            "    return instance.provideObjects(a, b, (MembersInjector<X>) x);",
+            "      TestModule instance, Object a, Object b, MembersInjector<X> x) {",
+            "    return instance.provideObjects(a, b, x);",
             "  }",
             "}");
     assertAbout(javaSources()).that(
@@ -519,7 +513,6 @@ public void providesMethodReturnsProduced() {
             "  private final TestModule module;",
             "",
             "  public TestModule_ProvideStringFactory(TestModule module) {",
-            "    assert module != null;",
             "    this.module = module;",
             "  }",
             "",
@@ -574,14 +567,12 @@ public void providesMethodReturnsProduced() {
             "  private final TestModule module;",
             "",
             "  public TestModule_ProvideWildcardListFactory(TestModule module) {",
-            "    assert module != null;",
             "    this.module = module;",
             "  }",
             "",
             "  @Override public List<List<?>> get() {",
-            "    return Preconditions.checkNotNull(module.provideWildcardList(), "
-                + NPE_LITERAL
-                + ");",
+            "    return Preconditions.checkNotNull(",
+            "        module.provideWildcardList(), " + NPE_LITERAL + ");",
             "  }",
             "",
             "  public static Factory<List<List<?>>> create(TestModule module) {",
@@ -628,7 +619,6 @@ public void providesMethodReturnsProduced() {
             "  private final TestModule module;",
             "",
             "  public TestModule_ProvideStringsFactory(TestModule module) {",
-            "    assert module != null;",
             "    this.module = module;",
             "  }",
             "",
@@ -920,9 +910,7 @@ public void genericSubclassedModule() {
             "",
             "  public ParentModule_ProvideListBFactory(",
             "        ParentModule<A, B, C> module, Provider<B> bProvider) {",
-            "    assert module != null;",
             "    this.module = module;",
-            "    assert bProvider != null;",
             "    this.bProvider = bProvider;",
             "  }",
             "",
@@ -961,9 +949,7 @@ public void genericSubclassedModule() {
             "",
             "  public ParentModule_ProvideBElementFactory(",
             "        ParentModule<A, B, C> module, Provider<B> bProvider) {",
-            "    assert module != null;",
             "    this.module = module;",
-            "    assert bProvider != null;",
             "    this.bProvider = bProvider;",
             "  }",
             "",
@@ -1002,9 +988,7 @@ public void genericSubclassedModule() {
             "",
             "  public ParentModule_ProvideBEntryFactory(",
             "        ParentModule<A, B, C> module, Provider<B> bProvider) {",
-            "    assert module != null;",
             "    this.module = module;",
-            "    assert bProvider != null;",
             "    this.bProvider = bProvider;",
             "  }",
             "",
@@ -1040,7 +1024,6 @@ public void genericSubclassedModule() {
             "  private final ChildNumberModule module;",
             "",
             "  public ChildNumberModule_ProvideNumberFactory(ChildNumberModule module) {",
-            "    assert module != null;",
             "    this.module = module;",
             "  }",
             "",
@@ -1072,7 +1055,6 @@ public void genericSubclassedModule() {
             "  private final ChildIntegerModule module;",
             "",
             "  public ChildIntegerModule_ProvideIntegerFactory(ChildIntegerModule module) {",
-            "    assert module != null;",
             "    this.module = module;",
             "  }",
             "",
@@ -1207,7 +1189,6 @@ public void genericSubclassedModule() {
             "",
             "  public ParameterizedModule_ProvideNonGenericTypeWithDepsFactory(",
             "      Provider<Object> oProvider) {",
-            "    assert oProvider != null;",
             "    this.oProvider = oProvider;",
             "  }",
             "",
diff --git a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
new file mode 100644
index 000000000..35480e2ab
--- /dev/null
+++ b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
@@ -0,0 +1,436 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import com.squareup.javapoet.CodeBlock;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class OptionalBindingRequestFulfillmentTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public OptionalBindingRequestFulfillmentTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
+  public static final CodeBlock NPE_FROM_PROVIDES =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
+  @Test
+  public void inlinedOptionalBindings() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.BindsOptionalOf;",
+            "import other.Maybe;",
+            "import other.DefinitelyNot;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @BindsOptionalOf Maybe maybe();",
+            "  @BindsOptionalOf DefinitelyNot definitelyNot();",
+            "}");
+    JavaFileObject maybe =
+        JavaFileObjects.forSourceLines(
+            "other.Maybe",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "public class Maybe {",
+            "  @Module",
+            "  public interface MaybeModule {",
+            "    @Provides static Maybe provideMaybe() { return new Maybe(); }",
+            "  }",
+            "}");
+    JavaFileObject definitelyNot =
+        JavaFileObjects.forSourceLines(
+            "other.DefinitelyNot",
+            "package other;",
+            "",
+            "public class DefinitelyNot {}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.Component;",
+            "import dagger.Lazy;",
+            "import javax.inject.Provider;",
+            "import other.Maybe;",
+            "import other.DefinitelyNot;",
+            "",
+            "@Component(modules = {TestModule.class, Maybe.MaybeModule.class})",
+            "interface TestComponent {",
+            "  Optional<Maybe> maybe();",
+            "  Optional<Provider<Lazy<Maybe>>> providerOfLazyOfMaybe();",
+            "  Optional<DefinitelyNot> definitelyNot();",
+            "  Optional<Provider<Lazy<DefinitelyNot>>> providerOfLazyOfDefinitelyNot();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.base.Optional;",
+                "import dagger.Lazy;",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.ProviderOfLazy;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "import other.DefinitelyNot;",
+                "import other.Maybe;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Maybe getMaybeInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        Maybe.MaybeModule.provideMaybe(),",
+                "        " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  private Provider<Maybe> getMaybeProvider() {",
+                "    return new Provider<Maybe>() {",
+                "      @Override",
+                "      public Maybe get() {",
+                "        return getMaybeInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private Provider<Lazy<Maybe>> getMaybeProviderOfLazy() {",
+                "    return ProviderOfLazy.create(getMaybeProvider());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Maybe> maybe() {",
+                "    return Optional.of(getMaybeInstance());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Provider<Lazy<Maybe>>> providerOfLazyOfMaybe() {",
+                "    return Optional.of(getMaybeProviderOfLazy());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<DefinitelyNot> definitelyNot() {",
+                "    return Optional.absent();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Provider<Lazy<DefinitelyNot>>>",
+                "        providerOfLazyOfDefinitelyNot() {",
+                "    return Optional.absent();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.base.Optional;",
+                "import dagger.Lazy;",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.ProviderOfLazy;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "import other.DefinitelyNot;",
+                "import other.Maybe;",
+                "import other.Maybe_MaybeModule_ProvideMaybeFactory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Maybe> maybe() {",
+                "    return Optional.of(",
+                "        Preconditions.checkNotNull(",
+                "            Maybe.MaybeModule.provideMaybe(), " + NPE_FROM_PROVIDES + "));",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Provider<Lazy<Maybe>>> providerOfLazyOfMaybe() {",
+                "    return Optional.of(",
+                "        ProviderOfLazy.create(Maybe_MaybeModule_ProvideMaybeFactory.create()));",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<DefinitelyNot> definitelyNot() {",
+                "    return Optional.absent();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Optional<Provider<Lazy<DefinitelyNot>>>",
+                "      providerOfLazyOfDefinitelyNot() {",
+                "    return Optional.absent();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, maybe, definitelyNot, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void requestForFuture() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.BindsOptionalOf;",
+            "import other.Maybe;",
+            "import other.DefinitelyNot;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @BindsOptionalOf Maybe maybe();",
+            "  @BindsOptionalOf DefinitelyNot definitelyNot();",
+            "}");
+    JavaFileObject maybe =
+        JavaFileObjects.forSourceLines(
+            "other.Maybe",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "public class Maybe {",
+            "  @Module",
+            "  public interface MaybeModule {",
+            "    @Provides static Maybe provideMaybe() { return new Maybe(); }",
+            "  }",
+            "}");
+    JavaFileObject definitelyNot =
+        JavaFileObjects.forSourceLines(
+            "other.DefinitelyNot",
+            "package other;",
+            "",
+            "public class DefinitelyNot {}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionComponent;",
+            "import javax.inject.Provider;",
+            "import other.Maybe;",
+            "import other.DefinitelyNot;",
+            "",
+            "@ProductionComponent(modules = {TestModule.class, Maybe.MaybeModule.class})",
+            "interface TestComponent {",
+            "  ListenableFuture<Optional<Maybe>> maybe();",
+            "  ListenableFuture<Optional<DefinitelyNot>> definitelyNot();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.base.Optional;",
+                "import com.google.common.util.concurrent.Futures;",
+                "import com.google.common.util.concurrent.ListenableFuture;",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import other.DefinitelyNot;",
+                "import other.Maybe;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Maybe getMaybeInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        Maybe.MaybeModule.provideMaybe(),",
+                "        " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<Optional<Maybe>> maybe() {",
+                "    return Futures.immediateFuture(Optional.of(getMaybeInstance()));",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<Optional<DefinitelyNot>> definitelyNot() {",
+                "    return Futures.immediateFuture(Optional.<DefinitelyNot>absent());",
+
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder testComponent_ProductionExecutorModule(",
+                "        TestComponent_ProductionExecutorModule",
+                "            testComponent_ProductionExecutorModule) {",
+                "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.base.Optional;",
+                "import com.google.common.util.concurrent.Futures;",
+                "import com.google.common.util.concurrent.ListenableFuture;",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import other.DefinitelyNot;",
+                "import other.Maybe;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<Optional<Maybe>> maybe() {",
+                "    return Futures.immediateFuture(Optional.of(Preconditions.checkNotNull(",
+                "        Maybe.MaybeModule.provideMaybe(), " + NPE_FROM_PROVIDES + ")));",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<Optional<DefinitelyNot>> definitelyNot() {",
+                "    return Futures.immediateFuture(Optional.<DefinitelyNot>absent());",
+
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder testComponent_ProductionExecutorModule(",
+                "        TestComponent_ProductionExecutorModule",
+                "            testComponent_ProductionExecutorModule) {",
+                "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, maybe, definitelyNot, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 066ed9792..f527c3634 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -380,11 +380,8 @@ public void publicModuleNonPublicIncludes() {
             "    super(",
             "        monitorProvider,",
             "        ProducerToken.create(TestModule_ProduceStringFactory.class));",
-            "    assert module != null;",
             "    this.module = module;",
-            "    assert executorProvider != null;",
             "    this.executorProvider = executorProvider;",
-            "    assert monitorProvider != null;",
             "    this.monitorProvider = monitorProvider;",
             "  }",
             "",
@@ -395,9 +392,6 @@ public void publicModuleNonPublicIncludes() {
             "",
             "  @Deprecated",
             "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
-            "    assert monitor != null :",
-            "        \"apply() may only be called internally from compute(); \"",
-            "        + \"if it's called explicitly, the monitor might be null\";",
             "    monitor.methodStarting();",
             "    try {",
             "      return TestModule_ProduceStringFactory.this.module.produceString();",
@@ -408,9 +402,6 @@ public void publicModuleNonPublicIncludes() {
             "",
             "  @Deprecated",
             "  @Override public void execute(Runnable runnable) {",
-            "    assert monitor != null :",
-            "        \"execute() may only be called internally from compute(); \"",
-            "        + \"if it's called explicitly, the monitor might be null\";",
             "    monitor.ready();",
             "    executorProvider.get().execute(runnable);",
             "  }",
@@ -471,11 +462,8 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "    super(",
             "        monitorProvider,",
             "        ProducerToken.create(\"test.TestModule#produceString\"));",
-            "    assert module != null;",
             "    this.module = module;",
-            "    assert executorProvider != null;",
             "    this.executorProvider = executorProvider;",
-            "    assert monitorProvider != null;",
             "    this.monitorProvider = monitorProvider;",
             "  }",
             "",
@@ -486,9 +474,6 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "",
             "  @Deprecated",
             "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
-            "    assert monitor != null :",
-            "        \"apply() may only be called internally from compute(); \"",
-            "        + \"if it's called explicitly, the monitor might be null\";",
             "    monitor.methodStarting();",
             "    try {",
             "      return TestModule_ProduceStringFactory.this.module.produceString();",
@@ -499,9 +484,6 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "",
             "  @Deprecated",
             "  @Override public void execute(Runnable runnable) {",
-            "    assert monitor != null :",
-            "        \"execute() may only be called internally from compute(); \"",
-            "        + \"if it's called explicitly, the monitor might be null\";",
             "    monitor.ready();",
             "    executorProvider.get().execute(runnable);",
             "  }",
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 561795632..16b2b56c0 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -20,16 +20,30 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class ProductionComponentProcessorTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public ProductionComponentProcessorTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
   @Test public void componentOnConcreteClass() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
         "package test;",
@@ -54,7 +68,9 @@
         "enum NotAComponent {",
         "  INSTANCE",
         "}");
-    assertAbout(javaSource()).that(componentFile)
+    assertAbout(javaSource())
+        .that(componentFile)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("interface");
@@ -68,7 +84,9 @@
         "",
         "@ProductionComponent",
         "@interface NotAComponent {}");
-    assertAbout(javaSource()).that(componentFile)
+    assertAbout(javaSource())
+        .that(componentFile)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("interface");
@@ -84,6 +102,7 @@
         "interface NotAComponent {}");
     assertAbout(javaSource())
         .that(componentFile)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("is not annotated with one of @Module, @ProducerModule");
@@ -144,6 +163,7 @@ public void dependsOnProductionExecutor() {
             "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("may not depend on the production executor");
@@ -198,116 +218,266 @@ public void simpleComponent() {
             "    ListenableFuture<A> a();",
             "  }",
             "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestClass_SimpleComponent",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.internal.DoubleCheck;",
-            "import dagger.internal.InstanceFactory;",
-            "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetFactory;",
-            "import dagger.producers.Producer;",
-            "import dagger.producers.internal.Producers;",
-            "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import java.util.concurrent.Executor;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestClass_SimpleComponent",
-            "    implements TestClass.SimpleComponent {",
-            "  private Provider<Executor> executorProvider;",
-            "  private Provider<Executor> executorProvider2;",
-            "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
-            "  private Provider<ProductionComponentMonitor> monitorProvider;",
-            "  private Provider<TestClass.B> bProvider;",
-            "  private Producer<TestClass.A> aProducer;",
-            "  private Producer<TestClass.B> bProducer;",
-            "",
-            "  private DaggerTestClass_SimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestClass.SimpleComponent create() {",
-            "    return new Builder().build()",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.executorProvider =",
-            "        TestClass_BModule_ExecutorFactory.create(builder.bModule);",
-            "     this.executorProvider2 =",
-            "         DoubleCheck.provider(",
-            "             TestClass_SimpleComponent_ProductionExecutorModule_ExecutorFactory",
-            "                 .create(executorProvider));",
-            "    this.simpleComponentProvider =",
-            "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
-            "    this.monitorProvider =",
-            "        DoubleCheck.provider(",
-            "            TestClass_SimpleComponent_MonitoringModule_MonitorFactory.create(",
-            "                simpleComponentProvider,",
-            "                SetFactory.<ProductionComponentMonitor.Factory>empty());",
-            "    this.bProvider = TestClass_BModule_BFactory.create(",
-            "        builder.bModule, TestClass_C_Factory.create());",
-            "    this.bProducer = Producers.producerFromProvider(bProvider);",
-            "    this.aProducer = new TestClass_AModule_AFactory(",
-            "        builder.aModule,",
-            "        executorProvider2,",
-            "        monitorProvider,",
-            "        bProducer);",
-            "  }",
-            "",
-            "  @Override",
-            "  public ListenableFuture<TestClass.A> a() {",
-            "    return aProducer.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private TestClass.BModule bModule;",
-            "    private TestClass.AModule aModule;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestClass.SimpleComponent build() {",
-            "      if (bModule == null) {",
-            "        this.bModule = new TestClass.BModule();",
-            "      }",
-            "      if (aModule == null) {",
-            "        this.aModule = new TestClass.AModule();",
-            "      }",
-            "      return new DaggerTestClass_SimpleComponent(this);",
-            "    }",
-            "",
-            "    public Builder aModule(TestClass.AModule aModule) {",
-            "      this.aModule = Preconditions.checkNotNull(aModule);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder bModule(TestClass.BModule bModule) {",
-            "      this.bModule = Preconditions.checkNotNull(bModule);",
-            "      return this;",
-            "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder testClass_SimpleComponent_ProductionExecutorModule(",
-            "        TestClass_SimpleComponent_ProductionExecutorModule",
-            "        testClass_SimpleComponent_ProductionExecutorModule) {",
-            "      Preconditions.checkNotNull(testClass_SimpleComponent_ProductionExecutorModule);",
-            "      return this;",
-            "    }",
-            "}");
-    assertAbout(javaSource()).that(component)
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestClass_SimpleComponent",
+                "package test;",
+                "",
+                "import com.google.common.util.concurrent.ListenableFuture;",
+                "import dagger.internal.DoubleCheck;",
+                "import dagger.internal.InstanceFactory;",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetFactory;",
+                "import dagger.producers.Producer;",
+                "import dagger.producers.internal.Producers;",
+                "import dagger.producers.monitoring.ProductionComponentMonitor;",
+                "import java.util.concurrent.Executor;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestClass_SimpleComponent",
+                "    implements TestClass.SimpleComponent {",
+                "  private TestClass.BModule bModule;",
+                "",
+                "  private Provider<Executor> executorProvider2;",
+                "",
+                "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
+                "",
+                "  private Provider<ProductionComponentMonitor> monitorProvider;",
+                "",
+                "  private Producer<TestClass.B> bProducer;",
+                "",
+                "  private Producer<TestClass.A> aProducer;",
+                "",
+                "  private DaggerTestClass_SimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestClass.SimpleComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Executor getProductionExecutorInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        bModule.executor(), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<Executor> getProductionExecutorProvider() {",
+                "    return new Provider<Executor>() {",
+                "      @Override",
+                "      public Executor get() {",
+                "        return getProductionExecutorInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private TestClass.C getCInstance() {",
+                "    return new TestClass.C();",
+                "  }",
+                "",
+                "  private TestClass.B getBInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        bModule.b(getCInstance()), " + NPE_FROM_PROVIDES_METHOD + ");",
+                "  }",
+                "",
+                "  private Provider<TestClass.B> getBProvider() {",
+                "    return new Provider<TestClass.B>() {",
+                "      @Override",
+                "      public TestClass.B get() {",
+                "        return getBInstance();",
+                "      }",
+                "    };",
+                "  }",
+                "",
+                "  private Producer<TestClass.B> getBProducer() {",
+                "    return bProducer;",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.bModule = builder.bModule;",
+                "    this.executorProvider2 =",
+                "        DoubleCheck.provider(",
+                "            TestClass_SimpleComponent_ProductionExecutorModule_ExecutorFactory",
+                "                .create(getProductionExecutorProvider()));",
+                "    this.simpleComponentProvider =",
+                "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
+                "    this.monitorProvider =",
+                "        DoubleCheck.provider(",
+                "            TestClass_SimpleComponent_MonitoringModule_MonitorFactory.create(",
+                "                simpleComponentProvider,",
+                "                SetFactory.<ProductionComponentMonitor.Factory>empty()));",
+                "    this.bProducer = Producers.producerFromProvider(getBProvider());",
+                "    this.aProducer =",
+                "        new TestClass_AModule_AFactory(",
+                "            builder.aModule, executorProvider2, monitorProvider, getBProducer());",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<TestClass.A> a() {",
+                "    return aProducer.get();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private TestClass.BModule bModule;",
+                "",
+                "    private TestClass.AModule aModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestClass.SimpleComponent build() {",
+                "      if (bModule == null) {",
+                "        this.bModule = new TestClass.BModule();",
+                "      }",
+                "      if (aModule == null) {",
+                "        this.aModule = new TestClass.AModule();",
+                "      }",
+                "      return new DaggerTestClass_SimpleComponent(this);",
+                "    }",
+                "",
+                "    public Builder aModule(TestClass.AModule aModule) {",
+                "      this.aModule = Preconditions.checkNotNull(aModule);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder bModule(TestClass.BModule bModule) {",
+                "      this.bModule = Preconditions.checkNotNull(bModule);",
+                "      return this;",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder testClass_SimpleComponent_ProductionExecutorModule(",
+                "        TestClass_SimpleComponent_ProductionExecutorModule",
+                "            testClass_SimpleComponent_ProductionExecutorModule) {",
+                "      Preconditions.checkNotNull(",
+                "          testClass_SimpleComponent_ProductionExecutorModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestClass_SimpleComponent",
+                "package test;",
+                "",
+                "import com.google.common.util.concurrent.ListenableFuture;",
+                "import dagger.internal.DoubleCheck;",
+                "import dagger.internal.InstanceFactory;",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetFactory;",
+                "import dagger.producers.Producer;",
+                "import dagger.producers.internal.Producers;",
+                "import dagger.producers.monitoring.ProductionComponentMonitor;",
+                "import java.util.concurrent.Executor;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestClass_SimpleComponent",
+                "    implements TestClass.SimpleComponent {",
+                "  private Provider<Executor> executorProvider;",
+                "  private Provider<Executor> executorProvider2;",
+                "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
+                "  private Provider<ProductionComponentMonitor> monitorProvider;",
+                "  private Provider<TestClass.B> bProvider;",
+                "  private Producer<TestClass.B> bProducer;",
+                "  private Producer<TestClass.A> aProducer;",
+                "",
+                "  private DaggerTestClass_SimpleComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestClass.SimpleComponent create() {",
+                "    return new Builder().build()",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.executorProvider =",
+                "        TestClass_BModule_ExecutorFactory.create(builder.bModule);",
+                "     this.executorProvider2 =",
+                "         DoubleCheck.provider(",
+                "             TestClass_SimpleComponent_ProductionExecutorModule_ExecutorFactory",
+                "                 .create(executorProvider));",
+                "    this.simpleComponentProvider = ",
+                "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
+                "    this.monitorProvider =",
+                "        DoubleCheck.provider(",
+                "            TestClass_SimpleComponent_MonitoringModule_MonitorFactory.create(",
+                "                simpleComponentProvider,",
+                "                SetFactory.<ProductionComponentMonitor.Factory>empty());",
+                "    this.bProvider = TestClass_BModule_BFactory.create(",
+                "        builder.bModule, TestClass_C_Factory.create());",
+                "    this.bProducer = Producers.producerFromProvider(bProvider);",
+                "    this.aProducer = new TestClass_AModule_AFactory(",
+                "        builder.aModule,",
+                "        executorProvider2,",
+                "        monitorProvider,",
+                "        bProducer);",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<TestClass.A> a() {",
+                "    return aProducer.get();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private TestClass.BModule bModule;",
+                "    private TestClass.AModule aModule;",
+                "",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestClass.SimpleComponent build() {",
+                "      if (bModule == null) {",
+                "        this.bModule = new TestClass.BModule();",
+                "      }",
+                "      if (aModule == null) {",
+                "        this.aModule = new TestClass.AModule();",
+                "      }",
+                "      return new DaggerTestClass_SimpleComponent(this);",
+                "    }",
+                "",
+                "    public Builder aModule(TestClass.AModule aModule) {",
+                "      this.aModule = Preconditions.checkNotNull(aModule);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder bModule(TestClass.BModule bModule) {",
+                "      this.bModule = Preconditions.checkNotNull(bModule);",
+                "      return this;",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder testClass_SimpleComponent_ProductionExecutorModule(",
+                "        TestClass_SimpleComponent_ProductionExecutorModule",
+                "        testClass_SimpleComponent_ProductionExecutorModule) {",
+                "      Preconditions.checkNotNull(testClass_SimpleComponent_ProductionExecutorModule);",
+                "      return this;",
+                "    }",
+                "}");
+    }
+    assertAbout(javaSource())
+        .that(component)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test public void nullableProducersAreNotErrors() {
@@ -358,7 +528,9 @@ public void simpleComponent() {
         "    ListenableFuture<A> a();",
         "  }",
         "}");
-    assertAbout(javaSource()).that(component)
+    assertAbout(javaSource())
+        .that(component)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .withWarningContaining("@Nullable on @Produces methods does not do anything")
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
new file mode 100644
index 000000000..32348e69a
--- /dev/null
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
@@ -0,0 +1,561 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.CLASS_PATH_WITHOUT_GUAVA_OPTION;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.Compiler;
+import com.google.testing.compile.JavaFileObjects;
+import com.squareup.javapoet.CodeBlock;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class SetBindingRequestFulfillmentTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public SetBindingRequestFulfillmentTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
+  public static final CodeBlock NPE_FROM_PROVIDES =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
+  @Test
+  public void setBindings() {
+    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
+        "import dagger.multibindings.Multibinds;",
+        "import java.util.Collections;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "abstract class EmptySetModule {",
+        "  @Multibinds abstract Set<Object> objects();",
+        "",
+        "  @Provides @ElementsIntoSet",
+        "  static Set<String> emptySet() { ",
+        "    return Collections.emptySet();",
+        "  }",
+        "}");
+    JavaFileObject setModuleFile = JavaFileObjects.forSourceLines("test.SetModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.IntoSet;",
+        "",
+        "@Module",
+        "final class SetModule {",
+        "  @Provides @IntoSet static String string() { return \"\"; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Set;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {EmptySetModule.class, SetModule.class})",
+        "interface TestComponent {",
+        "  Set<String> strings();",
+        "  Set<Object> objects();",
+        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetBuilder;",
+                "import java.util.Collections;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Set<String> getSetOfStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  private String getStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        SetModule.string(), " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<String> strings() {",
+                "    return SetBuilder.<String>newSetBuilder(2)",
+                "        .addAll(getSetOfStringInstance())",
+                "        .add(getStringInstance())",
+                "        .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<Object> objects() {",
+                "    return Collections.<Object>emptySet();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder setModule(SetModule setModule) {",
+                "      Preconditions.checkNotNull(setModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetBuilder;",
+                "import java.util.Collections;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<String> strings() {",
+                "    return SetBuilder.<String>newSetBuilder(2)",
+                "        .addAll(Preconditions.checkNotNull(",
+                "            EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + "))",
+                "        .add(Preconditions.checkNotNull(",
+                "            SetModule.string(), " + NPE_FROM_PROVIDES + "))",
+                "        .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<Object> objects() {",
+                "    return Collections.<Object>emptySet();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder setModule(SetModule setModule) {",
+                "      Preconditions.checkNotNull(setModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompilerWithoutGuava().compile(emptySetModuleFile, setModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void inaccessible() {
+    JavaFileObject inaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible",
+            "package other;",
+            "",
+            "class Inaccessible {}");
+    JavaFileObject inaccessible2 =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible2",
+            "package other;",
+            "",
+            "class Inaccessible2 {}");
+    JavaFileObject usesInaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.UsesInaccessible",
+            "package other;",
+            "",
+            "import java.util.Set;",
+            "import javax.inject.Inject;",
+            "",
+            "public class UsesInaccessible {",
+            "  @Inject UsesInaccessible(Set<Inaccessible> set1, Set<Inaccessible2> set2) {}",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "other.TestModule",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Collections;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "public abstract class TestModule {",
+            "  @Multibinds abstract Set<Inaccessible> objects();",
+            "",
+            "  @Provides @ElementsIntoSet",
+            "  static Set<Inaccessible2> emptySet() { ",
+            "    return Collections.emptySet();",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "import other.TestModule;",
+            "import other.UsesInaccessible;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  UsesInaccessible usesInaccessible();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetBuilder;",
+                "import java.util.Collections;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "import other.TestModule_EmptySetFactory;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Set getSetOfInaccessible2Instance() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule_EmptySetFactory.proxyEmptySet(),",
+                "        " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  private UsesInaccessible getUsesInaccessibleInstance() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        (Set) Collections.emptySet(),",
+                "        (Set) SetBuilder.newSetBuilder(1)",
+                "            .addAll(getSetOfInaccessible2Instance())",
+                "            .build());",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return getUsesInaccessibleInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetBuilder;",
+                "import java.util.Collections;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "import other.TestModule_EmptySetFactory;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        (Set) Collections.emptySet(),",
+                "        (Set) SetBuilder.newSetBuilder(1)",
+                "            .addAll(Preconditions.checkNotNull(",
+                "                TestModule_EmptySetFactory.proxyEmptySet(),",
+                "                " + NPE_FROM_PROVIDES + "))",
+                "            .build());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompilerWithoutGuava()
+            .compile(module, inaccessible, inaccessible2, usesInaccessible, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void subcomponentOmitsInheritedBindings() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides @IntoSet static Object parentObject() {",
+            "    return \"parent object\";",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Set<Object> objectSet();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Collections;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private DaggerParent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    private Object getObjectInstance() {",
+                "      return Preconditions.checkNotNull(",
+                "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + ");",
+                "    }",
+                "",
+                "    @Override",
+                "    public Set<Object> objectSet() {",
+                "      return Collections.<Object>singleton(getObjectInstance());",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Collections;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private DaggerParent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    @Override",
+                "    public Set<Object> objectSet() {",
+                "      return Collections.<Object>singleton(Preconditions.checkNotNull(",
+                "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + "));",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation = daggerCompilerWithoutGuava().compile(parent, parentModule, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  private Compiler daggerCompilerWithoutGuava() {
+    return daggerCompiler()
+        .withOptions(compilerMode.javacopts().append(CLASS_PATH_WITHOUT_GUAVA_OPTION));
+  }
+}
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
new file mode 100644
index 000000000..6926ab023
--- /dev/null
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -0,0 +1,720 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import com.squareup.javapoet.CodeBlock;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class SetBindingRequestFulfillmentWithGuavaTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public SetBindingRequestFulfillmentWithGuavaTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
+  public static final CodeBlock NPE_FROM_PROVIDES =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
+  @Test
+  public void setBindings() {
+    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
+        "import dagger.multibindings.Multibinds;",
+        "import java.util.Collections;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "abstract class EmptySetModule {",
+        "  @Multibinds abstract Set<Object> objects();",
+        "",
+        "  @Provides @ElementsIntoSet",
+        "  static Set<String> emptySet() { ",
+        "    return Collections.emptySet();",
+        "  }",
+        "  @Provides @ElementsIntoSet",
+        "  static Set<Integer> onlyContributionIsElementsIntoSet() { ",
+        "    return Collections.emptySet();",
+        "  }",
+        "}");
+    JavaFileObject setModuleFile = JavaFileObjects.forSourceLines("test.SetModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.IntoSet;",
+        "",
+        "@Module",
+        "final class SetModule {",
+        "  @Provides @IntoSet static String string() { return \"\"; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Set;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {EmptySetModule.class, SetModule.class})",
+        "interface TestComponent {",
+        "  Set<String> strings();",
+        "  Set<Object> objects();",
+        "  Set<Integer> onlyContributionIsElementsIntoSet();",
+        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Set<String> getSetOfStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  private String getStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        SetModule.string(), " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  private Set<Integer> getSetOfIntegerInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        EmptySetModule.onlyContributionIsElementsIntoSet(),",
+                "        " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<String> strings() {",
+                "    return ImmutableSet.<String>builder()",
+                "        .addAll(getSetOfStringInstance())",
+                "        .add(getStringInstance())",
+                "        .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<Object> objects() {",
+                "    return ImmutableSet.<Object>of();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<Integer> onlyContributionIsElementsIntoSet() {",
+                "    return ImmutableSet.<Integer>copyOf(getSetOfIntegerInstance());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder setModule(SetModule setModule) {",
+                "      Preconditions.checkNotNull(setModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<String> strings() {",
+                "    return ImmutableSet.<String>builder()",
+                "        .addAll(Preconditions.checkNotNull(",
+                "            EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + "))",
+                "        .add(Preconditions.checkNotNull(",
+                "            SetModule.string(), " + NPE_FROM_PROVIDES + "))",
+                "        .build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<Object> objects() {",
+                "    return ImmutableSet.<Object>of();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Set<Integer> onlyContributionIsElementsIntoSet() {",
+                "    return ImmutableSet.<Integer>copyOf(",
+                "        Preconditions.checkNotNull(",
+                "            EmptySetModule.onlyContributionIsElementsIntoSet(),",
+                "            " + NPE_FROM_PROVIDES + "));",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {",
+                "    }",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder setModule(SetModule setModule) {",
+                "      Preconditions.checkNotNull(setModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(emptySetModuleFile, setModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void inaccessible() {
+    JavaFileObject inaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible",
+            "package other;",
+            "",
+            "class Inaccessible {}");
+    JavaFileObject inaccessible2 =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible2",
+            "package other;",
+            "",
+            "class Inaccessible2 {}");
+    JavaFileObject usesInaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.UsesInaccessible",
+            "package other;",
+            "",
+            "import java.util.Set;",
+            "import javax.inject.Inject;",
+            "",
+            "public class UsesInaccessible {",
+            "  @Inject UsesInaccessible(Set<Inaccessible> set1, Set<Inaccessible2> set2) {}",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "other.TestModule",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Collections;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "public abstract class TestModule {",
+            "  @Multibinds abstract Set<Inaccessible> objects();",
+            "",
+            "  @Provides @ElementsIntoSet",
+            "  static Set<Inaccessible2> emptySet() { ",
+            "    return Collections.emptySet();",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "import other.TestModule;",
+            "import other.UsesInaccessible;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  UsesInaccessible usesInaccessible();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "import other.TestModule_EmptySetFactory;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Set getSetOfInaccessible2Instance() {",
+                "    return Preconditions.checkNotNull(",
+                "        TestModule_EmptySetFactory.proxyEmptySet(),",
+                "        " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  private UsesInaccessible getUsesInaccessibleInstance() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        (Set) ImmutableSet.of(),",
+                "        (Set) ImmutableSet.copyOf(getSetOfInaccessible2Instance()));",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return getUsesInaccessibleInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "import other.TestModule_EmptySetFactory;",
+                "import other.UsesInaccessible;",
+                "import other.UsesInaccessible_Factory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesInaccessible usesInaccessible() {",
+                "    return UsesInaccessible_Factory.newUsesInaccessible(",
+                "        (Set) ImmutableSet.of(),",
+                "        (Set) ImmutableSet.copyOf(",
+                "            Preconditions.checkNotNull(",
+                "                TestModule_EmptySetFactory.proxyEmptySet(),",
+                "                " + NPE_FROM_PROVIDES + ")));",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, inaccessible, inaccessible2, usesInaccessible, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void subcomponentOmitsInheritedBindings() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides @IntoSet static Object parentObject() {",
+            "    return \"parent object\";",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Set<Object> objectSet();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private DaggerParent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    private Object getObjectInstance() {",
+                "      return Preconditions.checkNotNull(",
+                "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + ");",
+                "    }",
+                "",
+                "    @Override",
+                "    public Set<Object> objectSet() {",
+                "      return ImmutableSet.<Object>of(getObjectInstance());",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParent implements Parent {",
+                "  private DaggerParent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static Parent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Child child() {",
+                "    return new ChildImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public Parent build() {",
+                "      return new DaggerParent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildImpl implements Child {",
+                "    private ChildImpl() {}",
+                "",
+                "    @Override",
+                "    public Set<Object> objectSet() {",
+                "      return ImmutableSet.<Object>of(Preconditions.checkNotNull(",
+                "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + "));",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(parent, parentModule, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void productionComponents() {
+    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
+        "import java.util.Collections;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "abstract class EmptySetModule {",
+        "  @Provides @ElementsIntoSet",
+        "  static Set<String> emptySet() { ",
+        "    return Collections.emptySet();",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProductionComponent;",
+        "import java.util.Set;",
+        "",
+        "@ProductionComponent(modules = EmptySetModule.class)",
+        "interface TestComponent {",
+        "  ListenableFuture<Set<String>> strings();",
+        "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import com.google.common.util.concurrent.Futures;",
+                "import com.google.common.util.concurrent.ListenableFuture;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private Set<String> getSetOfStringInstance() {",
+                "    return Preconditions.checkNotNull(",
+                "        EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + ");",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<Set<String>> strings() {",
+                "    return Futures.<Set<String>>immediateFuture(",
+
+                "        ImmutableSet.<String>copyOf(getSetOfStringInstance()));",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder testComponent_ProductionExecutorModule(",
+                "        TestComponent_ProductionExecutorModule",
+                "            testComponent_ProductionExecutorModule) {",
+                "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import com.google.common.collect.ImmutableSet;",
+                "import com.google.common.util.concurrent.Futures;",
+                "import com.google.common.util.concurrent.ListenableFuture;",
+                "import dagger.internal.Preconditions;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private DaggerTestComponent(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public ListenableFuture<Set<String>> strings() {",
+                "    return Futures.<Set<String>>immediateFuture(",
+
+                "        ImmutableSet.<String>copyOf(Preconditions.checkNotNull(",
+                "            EmptySetModule.emptySet(), " + NPE_FROM_PROVIDES + "));",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Deprecated",
+                "    public Builder testComponent_ProductionExecutorModule(",
+                "        TestComponent_ProductionExecutorModule",
+                "            testComponent_ProductionExecutorModule) {",
+                "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(emptySetModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
new file mode 100644
index 000000000..4284b5b18
--- /dev/null
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class SubcomponentBuilderRequestFulfillmentTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public SubcomponentBuilderRequestFulfillmentTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
+
+  @Test
+  public void testInlinedSubcomponentBuilders_componentMethod() {
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Sub {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Sub build();",
+            "  }",
+            "}");
+    JavaFileObject usesSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.UsesSubcomponent",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class UsesSubcomponent {",
+            "  @Inject UsesSubcomponent(Sub.Builder subBuilder) {}",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface C {",
+            "  Sub.Builder sBuilder();",
+            "  UsesSubcomponent usesSubcomponent();",
+            "}");
+
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerC",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerC implements C {",
+                "  private DaggerC(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static C create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  private UsesSubcomponent getUsesSubcomponentInstance() {",
+                "    return new UsesSubcomponent(new SubBuilder());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Sub.Builder sBuilder() {",
+                "    return new SubBuilder();",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesSubcomponent usesSubcomponent() {",
+                "    return getUsesSubcomponentInstance();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public C build() {",
+                "      return new DaggerC(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubBuilder implements Sub.Builder {",
+                "    @Override",
+                "    public Sub build() {",
+                "      return new SubImpl(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubImpl implements Sub {",
+                "    private SubImpl(SubBuilder builder) {}",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerC",
+                "package test;",
+                "",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerC implements C {",
+                "  private DaggerC(Builder builder) {}",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static C create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Sub.Builder sBuilder() {",
+                "    return new SubBuilder();",
+                "  }",
+                "",
+                "  @Override",
+                "  public UsesSubcomponent usesSubcomponent() {",
+                "    return new UsesSubcomponent(new SubBuilder());",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public C build() {",
+                "      return new DaggerC(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubBuilder implements Sub.Builder {",
+                "    @Override",
+                "    public Sub build() {",
+                "      return new SubImpl(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class SubImpl implements Sub {",
+                "    private SubImpl(SubBuilder builder) {}",
+                "  }",
+                "}");
+    }
+
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(subcomponent, usesSubcomponent, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerC")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index 225918e9a..94ba7f33b 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -20,16 +20,30 @@
 import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class SubcomponentValidationTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return CompilerMode.TEST_PARAMETERS;
+  }
+
+  private final CompilerMode compilerMode;
+
+  public SubcomponentValidationTest(CompilerMode compilerMode) {
+    this.compilerMode = compilerMode;
+  }
 
-@RunWith(JUnit4.class)
-public final class SubcomponentValidationTest {
   @Test public void factoryMethod_missingModulesWithParameters() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
         "package test;",
@@ -67,14 +81,17 @@
         "    return object;",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
             "test.ChildComponent requires modules which have no visible default constructors. "
                 + "Add the following modules as parameters to this method: "
                 + "test.ModuleWithParameters")
-        .in(componentFile).onLine(7);
+        .in(componentFile)
+        .onLine(7);
   }
 
   @Test public void factoryMethod_nonModuleParameter() {
@@ -94,12 +111,16 @@
         "",
         "@Subcomponent",
         "interface ChildComponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, childComponentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
             "Subcomponent factory methods may only accept modules, but java.lang.String is not.")
-        .in(componentFile).onLine(7).atColumn(43);
+        .in(componentFile)
+        .onLine(7)
+        .atColumn(43);
   }
 
   @Test public void factoryMethod_duplicateParameter() {
@@ -126,13 +147,17 @@
         "",
         "@Subcomponent(modules = TestModule.class)",
         "interface ChildComponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
             "A module may only occur once an an argument in a Subcomponent factory method, "
                 + "but test.TestModule was already passed.")
-        .in(componentFile).onLine(7).atColumn(71);
+        .in(componentFile)
+        .onLine(7)
+        .atColumn(71);
   }
 
   @Test public void factoryMethod_superflouousModule() {
@@ -159,13 +184,16 @@
         "",
         "@Subcomponent",
         "interface ChildComponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-    .processedWith(new ComponentProcessor())
-    .failsToCompile()
-    .withErrorContaining(
-        "test.TestModule is present as an argument to the test.ChildComponent factory method, but "
-            + "is not one of the modules used to implement the subcomponent.")
-                .in(componentFile).onLine(7);
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .withCompilerOptions(compilerMode.javacopts())
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.TestModule is present as an argument to the test.ChildComponent factory method, "
+                + "but is not one of the modules used to implement the subcomponent.")
+        .in(componentFile)
+        .onLine(7);
   }
 
   @Test public void missingBinding() {
@@ -201,6 +229,7 @@
         "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
@@ -219,7 +248,9 @@
         "",
         "@Subcomponent",
         "final class NotASubcomponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(subcomponentFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(subcomponentFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("interface");
@@ -257,7 +288,9 @@
         "final class ChildModule {",
         "  @Provides @Singleton Object provideObject() { return null; }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, subcomponentFile, moduleFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, subcomponentFile, moduleFile))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("@Singleton");
@@ -271,7 +304,9 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
             "package test;",
             "",
             "import dagger.Component;",
+            "import javax.inject.Singleton;",
             "",
+            "@Singleton",
             "@Component",
             "interface ParentComponent {",
             "  ChildComponent childComponent();",
@@ -328,7 +363,9 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
             "package test;",
             "",
             "import javax.inject.Inject;",
+            "import javax.inject.Singleton;",
             "",
+            "@Singleton",
             "final class Dep1 {",
             "  @Inject public Dep1() { }",
             "  @Inject public void dep1Method() { }",
@@ -339,105 +376,199 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
             "package test;",
             "",
             "import javax.inject.Inject;",
+            "import javax.inject.Singleton;",
             "",
+            "@Singleton",
             "final class Dep2 {",
             "  @Inject public Dep2() { }",
             "  @Inject public void dep2Method() { }",
             "}");
 
-    JavaFileObject componentGeneratedFile =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParentComponent",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParentComponent implements ParentComponent {",
-            "  private MembersInjector<Dep1> dep1MembersInjector;",
-            "  private Provider<Dep1> dep1Provider;",
-            "  private MembersInjector<Dep2> dep2MembersInjector;",
-            "  private Provider<Dep2> dep2Provider;",
-            "",
-            "  private DaggerParentComponent(Builder builder) {  ",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {  ",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static ParentComponent create() {  ",
-            "    return new Builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {  ",
-            "    this.dep1MembersInjector = Dep1_MembersInjector.create();",
-            "    this.dep1Provider = Dep1_Factory.create(dep1MembersInjector);",
-            "    this.dep2MembersInjector = Dep2_MembersInjector.create();",
-            "    this.dep2Provider = Dep2_Factory.create(dep2MembersInjector);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Dep1 getDep1() {  ",
-            "    return dep1Provider.get();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Dep2 getDep2() {  ",
-            "    return dep2Provider.get();",
-            "  }",
-            "",
-            "  @Override",
-            "  public ChildComponent childComponent() {  ",
-            "    return new ChildComponentImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {  ",
-            "    }",
-            "  ",
-            "    public ParentComponent build() {  ",
-            "      return new DaggerParentComponent(this);",
-            "    }",
-            "  }",
-            "",
-            "  private final class ChildComponentImpl implements ChildComponent {",
-            "    private final ChildModule childModule;",
-            "    private MembersInjector<A> aMembersInjector;",
-            "    private Provider<NeedsDep1> needsDep1Provider;",
-            "    private Provider<A> aProvider;",
-            "    private Provider<Object> provideObjectProvider;",
-            "  ",
-            "    private ChildComponentImpl() {  ",
-            "      this.childModule = new ChildModule();",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {  ",
-            "      this.aMembersInjector = A_MembersInjector.create();",
-            "      this.needsDep1Provider = NeedsDep1_Factory.create(",
-            "          DaggerParentComponent.this.dep1Provider);",
-            "      this.aProvider = A_Factory.create(",
-            "          aMembersInjector,",
-            "          needsDep1Provider,",
-            "          DaggerParentComponent.this.dep1Provider,",
-            "          DaggerParentComponent.this.dep2Provider);",
-            "      this.provideObjectProvider = ChildModule_ProvideObjectFactory.create(",
-            "          childModule, aProvider);",
-            "    }",
-            "  ",
-            "    @Override",
-            "    public Object getObject() {  ",
-            "      return provideObjectProvider.get();",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParentComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import dagger.internal.DoubleCheck;",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParentComponent implements ParentComponent {",
+                "  private Provider<Dep1> dep1Provider;",
+                "  private Provider<Dep2> dep2Provider;",
+                "",
+                "  private DaggerParentComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static ParentComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.dep1Provider = DoubleCheck.provider(Dep1_Factory.create());",
+                "    this.dep2Provider = DoubleCheck.provider(Dep2_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Dep1 getDep1() {",
+                "    return dep1Provider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Dep2 getDep2() {",
+                "    return dep2Provider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public ChildComponent childComponent() {",
+                "    return new ChildComponentImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {}",
+                "",
+                "    public ParentComponent build() {",
+                "      return new DaggerParentComponent(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildComponentImpl implements ChildComponent {",
+                "    private final ChildModule childModule;",
+                "",
+                "    private ChildComponentImpl() {",
+                "      this.childModule = new ChildModule();",
+                "    }",
+                "",
+                "    private NeedsDep1 getNeedsDep1Instance() {",
+                "      return new NeedsDep1(DaggerParentComponent.this.dep1Provider.get());",
+                "    }",
+                "",
+                "    private A getAInstance() {",
+                "      return injectA(",
+                "          A_Factory.newA(",
+                "              getNeedsDep1Instance(),",
+                "              DaggerParentComponent.this.dep1Provider.get(),",
+                "              DaggerParentComponent.this.dep2Provider.get()));",
+                "    }",
+                "",
+                "    private Object getObjectInstance() {",
+                "      return Preconditions.checkNotNull(",
+                "          childModule.provideObject(getAInstance()),",
+                "          " + NPE_FROM_PROVIDES_METHOD + ");",
+                "    }",
+                "",
+                "    @Override",
+                "    public Object getObject() {",
+                "      return getObjectInstance();",
+                "    }",
+                "",
+                "    @CanIgnoreReturnValue",
+                "    private A injectA(A instance) {",
+                "      A_MembersInjector.injectMethodA(instance);",
+                "      return instance;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerParentComponent",
+                "package test;",
+                "",
+                "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
+                "import dagger.internal.DoubleCheck;",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerParentComponent implements ParentComponent {",
+                "  private Provider<Dep1> dep1Provider;",
+                "  private Provider<Dep2> dep2Provider;",
+                "",
+                "  private DaggerParentComponent(Builder builder) {  ",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {  ",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static ParentComponent create() {  ",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {  ",
+                "    this.dep1Provider = DoubleCheck.provider(Dep1_Factory.create());",
+                "    this.dep2Provider = DoubleCheck.provider(Dep2_Factory.create());",
+                "  }",
+                "",
+                "  @Override",
+                "  public Dep1 getDep1() {  ",
+                "    return dep1Provider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public Dep2 getDep2() {  ",
+                "    return dep2Provider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public ChildComponent childComponent() {  ",
+                "    return new ChildComponentImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Builder() {  ",
+                "    }",
+                "  ",
+                "    public ParentComponent build() {  ",
+                "      return new DaggerParentComponent(this);",
+                "    }",
+                "  }",
+                "",
+                "  private final class ChildComponentImpl implements ChildComponent {",
+                "    private final ChildModule childModule;",
+                "  ",
+                "    private ChildComponentImpl() {  ",
+                "      this.childModule = new ChildModule();",
+                "    }",
+                "  ",
+                "    @Override",
+                "    public Object getObject() {  ",
+                "      return Preconditions.checkNotNull(",
+                "          childModule.provideObject(",
+                "              injectA(",
+                "                  A_Factory.newA(",
+                "                      new NeedsDep1(",
+                "                          DaggerParentComponent.this.dep1Provider.get()),",
+                "                      DaggerParentComponent.this.dep1Provider.get(),",
+                "                      DaggerParentComponent.this.dep2Provider.get()))),",
+                "          " + NPE_FROM_PROVIDES_METHOD + ");",
+                "    }",
+                "",
+                "    @CanIgnoreReturnValue",
+                "    private A injectA(A instance) {",
+                "      A_MembersInjector.injectMethodA(instance);",
+                "      return instance;",
+                "    }",
+                "  }",
+                "}");
+    }
     assertAbout(javaSources())
         .that(
             ImmutableList.of(
@@ -448,10 +579,11 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
                 needsDep1File,
                 dep1File,
                 dep2File))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
-        .generatesSources(componentGeneratedFile);
+        .generatesSources(generatedComponent);
   }
 
   @Test
@@ -520,7 +652,6 @@ public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
             GENERATED_ANNOTATION,
             "public final class DaggerParentComponent implements ParentComponent {",
             "  private DaggerParentComponent(Builder builder) {",
-            "    assert builder != null;",
             "  }",
             "",
             "  public static Builder builder() {",
@@ -579,6 +710,7 @@ public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
 
     assertAbout(javaSources())
         .that(ImmutableList.of(parent, foo, bar, baz, noConflict))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -626,9 +758,7 @@ public void subcomponentSimpleNamesDisambiguated() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParentComponent implements ParentComponent {",
-            "  private DaggerParentComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
+            "  private DaggerParentComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -669,6 +799,7 @@ public void subcomponentSimpleNamesDisambiguated() {
 
     assertAbout(javaSources())
         .that(ImmutableList.of(parent, sub, deepSub))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -710,9 +841,7 @@ public void subcomponentSimpleNamesDisambiguatedInRoot() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParentComponent implements ParentComponent {",
-            "  private DaggerParentComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
+            "  private DaggerParentComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -753,6 +882,7 @@ public void subcomponentSimpleNamesDisambiguatedInRoot() {
 
     assertAbout(javaSources())
         .that(ImmutableList.of(parent, sub, deepSub))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -808,9 +938,7 @@ public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParentComponent implements ParentComponent {",
-            "  private DaggerParentComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
+            "  private DaggerParentComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -848,6 +976,7 @@ public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
 
     assertAbout(javaSources())
         .that(ImmutableList.of(parent, top1, top2))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -887,9 +1016,7 @@ public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubco
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerC implements C {",
-            "  private DaggerC(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
+            "  private DaggerC(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -919,6 +1046,7 @@ public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubco
 
     assertAbout(javaSources())
         .that(ImmutableList.of(parent, subcomponentWithSameSimpleNameAsParent))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -966,18 +1094,11 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "package test;",
             "",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerC implements C {",
             "",
-            "  private Provider<C.Foo.Sub.Builder> fooBuilderProvider;",
-            "  private Provider<C.Bar.Sub.Builder> barBuilderProvider;",
-            "",
-            "  private DaggerC(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerC(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -987,33 +1108,14 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.fooBuilderProvider = ",
-            "        new dagger.internal.Factory<C.Foo.Sub.Builder>() {",
-            "          @Override",
-            "          public C.Foo.Sub.Builder get() {",
-            "            return new F_SubBuilder();",
-            "          }",
-            "        };",
-            "",
-            "    this.barBuilderProvider = ",
-            "        new dagger.internal.Factory<C.Bar.Sub.Builder>() {",
-            "          @Override",
-            "          public C.Bar.Sub.Builder get() {",
-            "            return new B_SubBuilder();",
-            "          }",
-            "        };",
-            "  }",
-            "",
             "  @Override",
             "  public C.Foo.Sub.Builder fooBuilder() {",
-            "    return fooBuilderProvider.get();",
+            "    return new F_SubBuilder();",
             "  }",
             "",
             "  @Override",
             "  public C.Bar.Sub.Builder barBuilder() {",
-            "    return barBuilderProvider.get();",
+            "    return new B_SubBuilder();",
             "  }",
             "",
             "  public static final class Builder {",
@@ -1032,9 +1134,7 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "  }",
             "",
             "  private final class F_SubImpl implements C.Foo.Sub {",
-            "    private F_SubImpl(F_SubBuilder builder) {",
-            "      assert builder != null;",
-            "    }",
+            "    private F_SubImpl(F_SubBuilder builder) {}",
             "  }",
             "",
             "  private final class B_SubBuilder implements C.Bar.Sub.Builder {",
@@ -1045,14 +1145,13 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "  }",
             "",
             "  private final class B_SubImpl implements C.Bar.Sub {",
-            "    private B_SubImpl(B_SubBuilder builder) {",
-            "      assert builder != null;",
-            "    }",
+            "    private B_SubImpl(B_SubBuilder builder) {}",
             "  }",
             "}");
 
     assertAbout(javaSources())
         .that(ImmutableList.of(parent))
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
@@ -1105,6 +1204,7 @@ public void duplicateBindingWithSubcomponentDeclaration() {
             "}");
 
     assertThat(module, component, subcomponent)
+        .withCompilerOptions(compilerMode.javacopts())
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("test.Sub.Builder is bound multiple times:")
diff --git a/javatests/dagger/producers/internal/MapOfProducerProducerTest.java b/javatests/dagger/producers/internal/MapOfProducerProducerTest.java
index fe285ed5c..645a016b5 100644
--- a/javatests/dagger/producers/internal/MapOfProducerProducerTest.java
+++ b/javatests/dagger/producers/internal/MapOfProducerProducerTest.java
@@ -31,7 +31,7 @@
   @Test
   public void success() throws Exception {
     MapOfProducerProducer<Integer, String> mapOfProducerProducer =
-        MapOfProducerProducer.<Integer, String>builder(2)
+        MapOfProducerProducer.<Integer, String>builder()
             .put(15, Producers.<String>immediateProducer("fifteen"))
             .put(42, Producers.<String>immediateProducer("forty two"))
             .build();
@@ -47,7 +47,7 @@ public void success() throws Exception {
   public void failingContributionDoesNotFailMap() throws Exception {
     RuntimeException cause = new RuntimeException("monkey");
     MapOfProducerProducer<Integer, String> mapOfProducerProducer =
-        MapOfProducerProducer.<Integer, String>builder(2)
+        MapOfProducerProducer.<Integer, String>builder()
             .put(15, Producers.<String>immediateProducer("fifteen"))
             .put(42, Producers.<String>immediateFailedProducer(cause))
             .build();
diff --git a/javatests/dagger/producers/internal/MapProducerTest.java b/javatests/dagger/producers/internal/MapProducerTest.java
index 3a8f19ddc..ee7978b7b 100644
--- a/javatests/dagger/producers/internal/MapProducerTest.java
+++ b/javatests/dagger/producers/internal/MapProducerTest.java
@@ -19,7 +19,6 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
-import com.google.common.collect.ImmutableMap;
 import dagger.producers.Producer;
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
@@ -32,13 +31,10 @@
   @Test
   public void success() throws Exception {
     Producer<Map<Integer, String>> mapProducer =
-        MapProducer.create(
-            Producers.<Map<Integer, Producer<String>>>immediateProducer(
-                ImmutableMap.<Integer, Producer<String>>of(
-                    15,
-                    Producers.<String>immediateProducer("fifteen"),
-                    42,
-                    Producers.<String>immediateProducer("forty two"))));
+        MapProducer.<Integer, String>builder()
+            .put(15, Producers.immediateProducer("fifteen"))
+            .put(42, Producers.immediateProducer("forty two"))
+            .build();
     Map<Integer, String> map = mapProducer.get().get();
     assertThat(map).hasSize(2);
     assertThat(map).containsEntry(15, "fifteen");
@@ -49,27 +45,11 @@ public void success() throws Exception {
   public void failingContribution() throws Exception {
     RuntimeException cause = new RuntimeException("monkey");
     Producer<Map<Integer, String>> mapProducer =
-        MapProducer.create(
-            Producers.<Map<Integer, Producer<String>>>immediateProducer(
-                ImmutableMap.<Integer, Producer<String>>of(
-                    15,
-                    Producers.<String>immediateProducer("fifteen"),
-                    42,
-                    Producers.<String>immediateFailedProducer(cause))));
-    try {
-      mapProducer.get().get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isSameAs(cause);
-    }
-  }
-
-  @Test
-  public void failingInput() throws Exception {
-    RuntimeException cause = new RuntimeException("monkey");
-    Producer<Map<Integer, String>> mapProducer =
-        MapProducer.create(
-            Producers.<Map<Integer, Producer<String>>>immediateFailedProducer(cause));
+        MapProducer.<Integer, String>builder()
+            .put(15, Producers.immediateProducer("fifteen"))
+            // TODO(ronshapiro): remove the type parameter when we drop java7 support
+            .put(42, Producers.<String>immediateFailedProducer(cause))
+            .build();
     try {
       mapProducer.get().get();
       fail();
diff --git a/javatests/dagger/producers/internal/ProducersTest.java b/javatests/dagger/producers/internal/ProducersTest.java
index 910b73ca0..8c4a256b2 100644
--- a/javatests/dagger/producers/internal/ProducersTest.java
+++ b/javatests/dagger/producers/internal/ProducersTest.java
@@ -124,7 +124,7 @@ public void allAsSet_failure() throws Exception {
     }
   }
 
-  @Test public void producerFromProvider() throws Exception {
+  @Test public void producerFromProvider_doesntCache() throws Exception {
     Producer<Integer> producer = Producers.producerFromProvider(new Provider<Integer>() {
       int i = 0;
 
@@ -133,7 +133,7 @@ public void allAsSet_failure() throws Exception {
       }
     });
     assertThat(producer.get().get()).isEqualTo(0);
-    assertThat(producer.get().get()).isEqualTo(0);
-    assertThat(producer.get().get()).isEqualTo(0);
+    assertThat(producer.get().get()).isEqualTo(1);
+    assertThat(producer.get().get()).isEqualTo(2);
   }
 }
diff --git a/test_defs.bzl b/test_defs.bzl
index 4c86d3543..9e076e2d4 100644
--- a/test_defs.bzl
+++ b/test_defs.bzl
@@ -12,11 +12,17 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+# Defines a set of build variants and the list of extra javacopts to build with.
+# The key will be appended to the generated test names to ensure uniqueness.
+BUILD_VARIANTS = {
+    "ExperimentalAndroidMode": ["-Adagger.experimentalAndroidMode=enabled"],
+}
+
+# TODO(user): split into two functions for functional vs non-functional tests?
 def GenJavaTests(name, srcs, deps, test_only_deps=None, plugins=None, javacopts=None,
-                 lib_javacopts=None, test_javacopts=None):
-  _GenTests(native.java_library, native.java_test, name, srcs, deps, test_only_deps=test_only_deps,
-            plugins=plugins, javacopts=javacopts, lib_javacopts=lib_javacopts,
-            test_javacopts=test_javacopts)
+                 lib_javacopts=None, test_javacopts=None, functional=True):
+  _GenTests(native.java_library, native.java_test, name, srcs, deps, test_only_deps,
+            plugins, javacopts, lib_javacopts, test_javacopts, functional)
 
 def GenRobolectricTests(name, srcs, deps, test_only_deps=None, plugins=None, javacopts=None,
                         lib_javacopts=None, test_javacopts=None):
@@ -24,9 +30,33 @@ def GenRobolectricTests(name, srcs, deps, test_only_deps=None, plugins=None, jav
   pass
 
 def _GenTests(library_rule_type, test_rule_type, name, srcs, deps, test_only_deps=None,
-              plugins=None, javacopts=None, lib_javacopts=None, test_javacopts=None):
+              plugins=None, javacopts=None, lib_javacopts=None, test_javacopts=None,
+              functional=True):
+  _gen_tests(library_rule_type, test_rule_type, name, srcs, deps, test_only_deps,
+             plugins, javacopts, lib_javacopts, test_javacopts)
+
+  if functional:
+    for (variant_name, extra_javacopts) in BUILD_VARIANTS.items():
+      _gen_tests(library_rule_type, test_rule_type, name, srcs, deps, test_only_deps,
+                 plugins, javacopts, lib_javacopts, test_javacopts, variant_name,
+                 extra_javacopts)
+
+def _gen_tests(library_rule_type, test_rule_type, name, srcs, deps, test_only_deps,
+               plugins, javacopts, lib_javacopts, test_javacopts, variant_name=None,
+               extra_javacopts=None):
+  if variant_name:
+    suffix = "_" + variant_name
+    tags = [variant_name]
+    # Add jvm_flags so that the mode can be accessed from within tests.
+    jvm_flags = ["-Ddagger.mode=" + variant_name]
+  else:
+    suffix = ""
+    tags = []
+    jvm_flags = []
+
   test_files = []
   supporting_files = []
+
   for src in srcs:
     if src.endswith("Test.java"):
       test_files.append(src)
@@ -36,16 +66,20 @@ def _GenTests(library_rule_type, test_rule_type, name, srcs, deps, test_only_dep
   if not test_only_deps:
     test_only_deps = []
 
+  if not extra_javacopts:
+    extra_javacopts = []
+
   test_deps = test_only_deps + deps
-  if len(supporting_files) > 0:
-    supporting_files_name = name + "_lib"
+  if supporting_files:
+    supporting_files_name = name + suffix + "_lib"
     test_deps.append(":" + supporting_files_name)
     library_rule_type(
         name = supporting_files_name,
         deps = deps,
         srcs = supporting_files,
         plugins = plugins,
-        javacopts = (javacopts or []) + (lib_javacopts or []),
+        javacopts = extra_javacopts + (javacopts or []) + (lib_javacopts or []),
+        tags = tags,
         testonly = 1,
     )
 
@@ -56,10 +90,12 @@ def _GenTests(library_rule_type, test_rule_type, name, srcs, deps, test_only_dep
       prefix_path = "javatests/"
     test_class = (PACKAGE_NAME + "/" + test_name).rpartition(prefix_path)[2].replace("/",".")
     test_rule_type(
-        name = test_name,
+        name = test_name + suffix,
         deps = test_deps,
         srcs = [test_file],
         plugins = plugins,
-        javacopts = (javacopts or []) + (test_javacopts or []),
+        javacopts = extra_javacopts + (javacopts or []) + (test_javacopts or []),
+        jvm_flags = jvm_flags,
+        tags = tags,
         test_class = test_class,
     )
diff --git a/third_party/BUILD b/third_party/BUILD
index d2e6d52c4..1ba7aa72f 100644
--- a/third_party/BUILD
+++ b/third_party/BUILD
@@ -15,7 +15,7 @@
 package(default_visibility = ["//visibility:public"])
 
 java_library(
-    name = "jsr_250",
+    name = "jsr250_annotations",
     exports = ["@javax_annotation_jsr250_api//jar"],
 )
 
@@ -113,7 +113,7 @@ java_library(
     ],
     tags = ["maven:compile_only"],
     exports = [
-        ":jsr_250",
+        ":jsr250_annotations",
         "@com_google_auto_value_auto_value//jar",
     ],
 )
diff --git a/util/deploy-to-maven-central.sh b/util/deploy-to-maven-central.sh
index e2e7d2898..532d43b0f 100755
--- a/util/deploy-to-maven-central.sh
+++ b/util/deploy-to-maven-central.sh
@@ -47,6 +47,10 @@ cd gh-pages
 unzip ../bazel-genfiles/user-docs.jar -d api/$version_name
 rm -rf api/$version_name/META-INF/
 git add api/$version_name
+sed -i -r \
+  s/"2\.[[:digit:]]+(-rc[[:digit:]]+)?"/"${version_name}"/g \
+  public_docs/_layouts/default.html
+git add public_docs/_layouts/default.html
 git commit -m "$version_name docs"
 git push origin gh-pages
 cd ..
diff --git a/util/publish-local-snapshot.sh b/util/install-local-snapshot.sh
similarity index 56%
rename from util/publish-local-snapshot.sh
rename to util/install-local-snapshot.sh
index 577ea462b..8f77a41fb 100755
--- a/util/publish-local-snapshot.sh
+++ b/util/install-local-snapshot.sh
@@ -2,10 +2,10 @@
 
 set -eu
 
-echo -e "Publishing maven snapshot locally...\n"
+echo -e "Installing maven snapshot locally...\n"
 
 bash $(dirname $0)/execute-deploy.sh \
   "install:install-file" \
   "LOCAL-SNAPSHOT"
 
-echo -e "Published local snapshot"
+echo -e "Installed local snapshot"
