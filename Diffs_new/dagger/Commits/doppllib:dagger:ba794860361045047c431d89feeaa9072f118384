diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 3b6d72175..529062f2c 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -148,6 +148,7 @@
             this,
             childComponentNames(keyFactory, subcomponentNames),
             graph,
+            types,
             elements,
             optionalFactories);
     this.componentRequirementFieldFactory =
@@ -399,7 +400,8 @@ private void implementInterfaceMethods() {
             }
           } else {
             interfaceMethod.addStatement(
-                "return $L", bindingExpressions.getDependencyExpression(interfaceRequest, name));
+                "return $L",
+                bindingExpressions.getDependencyExpression(interfaceRequest, name).codeBlock());
           }
           interfaceMethods.add(interfaceMethod.build());
         }
@@ -495,7 +497,8 @@ private MethodSpec membersInjectionMethod(Key key) {
             instance,
             membersInjectedType,
             types,
-            request -> bindingExpressions.getDependencyArgumentExpression(request, name)));
+            request ->
+                bindingExpressions.getDependencyArgumentExpression(request, name).codeBlock()));
     method.addStatement("return $L", instance);
 
     return method.build();
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 6a56b70e1..7518ef3bd 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -23,10 +23,10 @@
 
 import com.google.common.collect.ImmutableMap;
 import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import java.util.Optional;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /** A factory of code expressions used to access a single binding in a component. */
 abstract class BindingExpression {
@@ -47,7 +47,7 @@ final ResolvedBindings resolvedBindings() {
    *
    * @param requestingClass the class that will contain the expression
    */
-  abstract CodeBlock getDependencyExpression(
+  abstract Expression getDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass);
 
   /** Factory for building a {@link BindingExpression}. */
@@ -60,6 +60,7 @@ abstract CodeBlock getDependencyExpression(
     private final GeneratedComponentModel generatedComponentModel;
     private final ImmutableMap<BindingKey, String> subcomponentNames;
     private final BindingGraph graph;
+    private final Types types;
     private final Elements elements;
     private final OptionalFactories optionalFactories;
 
@@ -72,6 +73,7 @@ abstract CodeBlock getDependencyExpression(
         GeneratedComponentModel generatedComponentModel,
         ImmutableMap<BindingKey, String> subcomponentNames,
         BindingGraph graph,
+        Types types,
         Elements elements,
         OptionalFactories optionalFactories) {
       this.compilerOptions = checkNotNull(compilerOptions);
@@ -82,6 +84,7 @@ abstract CodeBlock getDependencyExpression(
       this.generatedComponentModel = checkNotNull(generatedComponentModel);
       this.subcomponentNames = checkNotNull(subcomponentNames);
       this.graph = checkNotNull(graph);
+      this.types = checkNotNull(types);
       this.elements = checkNotNull(elements);
       this.optionalFactories = checkNotNull(optionalFactories);
     }
@@ -149,7 +152,9 @@ private BindingExpression create(
               fieldSpec,
               generatedComponentModel,
               memberSelect,
-              frameworkFieldInitializer);
+              frameworkFieldInitializer,
+              types,
+              elements);
 
       if (!resolvedBindings.bindingType().equals(BindingType.PROVISION)) {
         return frameworkInstanceBindingExpression;
@@ -165,13 +170,16 @@ private BindingExpression create(
       ProvisionBinding provisionBinding = (ProvisionBinding) resolvedBindings.contributionBinding();
       switch (provisionBinding.bindingKind()) {
         case COMPONENT:
-          return new ComponentInstanceBindingExpression(bindingExpression, componentName);
+          return new ComponentInstanceBindingExpression(
+              bindingExpression, provisionBinding, componentName, types, elements);
 
         case COMPONENT_DEPENDENCY:
           return new BoundInstanceBindingExpression(
               bindingExpression,
               ComponentRequirement.forDependency(provisionBinding.key().type()),
-              componentRequirementFields);
+              componentRequirementFields,
+              types,
+              elements);
 
         case COMPONENT_PROVISION:
           return new ComponentProvisionBindingExpression(
@@ -179,29 +187,47 @@ private BindingExpression create(
               provisionBinding,
               graph,
               componentRequirementFields,
-              compilerOptions);
+              compilerOptions,
+              types,
+              elements);
 
         case SUBCOMPONENT_BUILDER:
           return new SubcomponentBuilderBindingExpression(
-              bindingExpression, subcomponentNames.get(resolvedBindings.bindingKey()));
+              bindingExpression,
+              provisionBinding,
+              subcomponentNames.get(resolvedBindings.bindingKey()),
+              types,
+              elements);
 
         case SYNTHETIC_MULTIBOUND_SET:
           return new SetBindingExpression(
-              provisionBinding, graph, componentBindingExpressions, bindingExpression, elements);
+              provisionBinding,
+              graph,
+              componentBindingExpressions,
+              bindingExpression,
+              types,
+              elements);
 
         case SYNTHETIC_MULTIBOUND_MAP:
           return new MapBindingExpression(
-              provisionBinding, graph, componentBindingExpressions, bindingExpression, elements);
+              provisionBinding,
+              graph,
+              componentBindingExpressions,
+              bindingExpression,
+              types,
+              elements);
 
         case SYNTHETIC_OPTIONAL_BINDING:
           return new OptionalBindingExpression(
-              provisionBinding, bindingExpression, componentBindingExpressions);
+              provisionBinding, bindingExpression, componentBindingExpressions, types, elements);
 
         case BUILDER_BINDING:
-              return new BoundInstanceBindingExpression(
-                  bindingExpression,
-                  ComponentRequirement.forBinding(provisionBinding),
-                  componentRequirementFields);
+          return new BoundInstanceBindingExpression(
+              bindingExpression,
+              ComponentRequirement.forBinding(provisionBinding),
+              componentRequirementFields,
+              types,
+              elements);
 
         case INJECTION:
         case PROVISION:
@@ -214,13 +240,17 @@ private BindingExpression create(
                     bindingExpression,
                     componentBindingExpressions,
                     generatedComponentModel,
-                    componentRequirementFields);
+                    componentRequirementFields,
+                    types,
+                    elements);
             return compilerOptions.experimentalAndroidMode()
                 ? new PrivateMethodBindingExpression(
                     resolvedBindings,
                     componentName,
                     generatedComponentModel,
-                    simpleMethodBindingExpression)
+                    simpleMethodBindingExpression,
+                    types,
+                    elements)
                 : simpleMethodBindingExpression;
           }
           // fall through
diff --git a/java/dagger/internal/codegen/BoundInstanceBindingExpression.java b/java/dagger/internal/codegen/BoundInstanceBindingExpression.java
index 2f3cd5bd1..8b790c76c 100644
--- a/java/dagger/internal/codegen/BoundInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/BoundInstanceBindingExpression.java
@@ -17,8 +17,9 @@
 package dagger.internal.codegen;
 
 import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
 import dagger.Component;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * A binding expression for instances bound with {@link dagger.BindsInstance} and instances of
@@ -31,15 +32,19 @@
   BoundInstanceBindingExpression(
       BindingExpression delegate,
       ComponentRequirement componentRequirement,
-      ComponentRequirementFields componentRequirementFields) {
-    super(delegate);
+      ComponentRequirementFields componentRequirementFields,
+      Types types,
+      Elements elements) {
+    super(delegate, types, elements);
     this.componentRequirement = componentRequirement;
     this.componentRequirementFields = componentRequirementFields;
   }
 
   @Override
-  CodeBlock getInstanceDependencyExpression(
+  Expression getInstanceDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
-    return componentRequirementFields.getExpression(componentRequirement, requestingClass);
+    return Expression.create(
+        componentRequirement.type(),
+        componentRequirementFields.getExpression(componentRequirement, requestingClass));
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index b49076575..7bb9312f7 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -18,16 +18,14 @@
 
 import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.TypeNames.rawTypeName;
 
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.TypeName;
 import java.util.HashMap;
 import java.util.Map;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
 
 /** A central repository of code expressions used to access any binding available to a component. */
 final class ComponentBindingExpressions {
@@ -41,14 +39,16 @@
    * component; the second contains the bindings owned by its parent; and so on.
    */
   private final ImmutableList<Map<BindingKey, BindingExpression>> bindingExpressionsMaps;
+  private final Types types;
 
   private ComponentBindingExpressions(
-      ImmutableList<Map<BindingKey, BindingExpression>> bindingExpressionsMaps) {
+      ImmutableList<Map<BindingKey, BindingExpression>> bindingExpressionsMaps, Types types) {
     this.bindingExpressionsMaps = bindingExpressionsMaps;
+    this.types = types;
   }
 
-  ComponentBindingExpressions() {
-    this(ImmutableList.of(newBindingExpressionMap()));
+  ComponentBindingExpressions(Types types) {
+    this(ImmutableList.of(newBindingExpressionMap()), types);
   }
 
   /**
@@ -59,9 +59,21 @@ private ComponentBindingExpressions(
    * @throws IllegalStateException if there is no binding expression that satisfies the dependency
    *     request
    */
-  CodeBlock getDependencyExpression(DependencyRequest request, ClassName requestingClass) {
-    return getBindingExpression(request.bindingKey())
-        .getDependencyExpression(request.kind(), requestingClass);
+  Expression getDependencyExpression(
+      BindingKey bindingKey, DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    return getBindingExpression(bindingKey).getDependencyExpression(requestKind, requestingClass);
+  }
+
+  /**
+   * Returns an expression that evaluates to the value of a dependency request for a binding owned
+   * by this component or an ancestor.
+   *
+   * @param requestingClass the class that will contain the expression
+   * @throws IllegalStateException if there is no binding expression that satisfies the dependency
+   *     request
+   */
+  Expression getDependencyExpression(DependencyRequest request, ClassName requestingClass) {
+    return getDependencyExpression(request.bindingKey(), request.kind(), requestingClass);
   }
 
   /**
@@ -72,10 +84,12 @@ CodeBlock getDependencyExpression(DependencyRequest request, ClassName requestin
    * @throws IllegalStateException if there is no binding expression that satisfies the dependency
    *     request
    */
-  CodeBlock getDependencyExpression(
+  Expression getDependencyExpression(
       FrameworkDependency frameworkDependency, ClassName requestingClass) {
-    return getBindingExpression(frameworkDependency.bindingKey())
-        .getDependencyExpression(frameworkDependency.dependencyRequestKind(), requestingClass);
+    return getDependencyExpression(
+        frameworkDependency.bindingKey(),
+        frameworkDependency.dependencyRequestKind(),
+        requestingClass);
   }
 
   /**
@@ -89,18 +103,18 @@ CodeBlock getDependencyExpression(
    * @param requestingClass the class that will contain the expression
    */
   // TODO(b/64024402) Merge with getDependencyExpression(DependencyRequest, ClassName) if possible.
-  CodeBlock getDependencyArgumentExpression(
+  Expression getDependencyArgumentExpression(
       DependencyRequest dependencyRequest, ClassName requestingClass) {
-    CodeBlock.Builder argument = CodeBlock.builder();
 
     TypeMirror dependencyType = dependencyRequest.key().type();
+    Expression dependencyExpression = getDependencyExpression(dependencyRequest, requestingClass);
+
     if (!isTypeAccessibleFrom(dependencyType, requestingClass.packageName())
         && isRawTypeAccessible(dependencyType, requestingClass.packageName())) {
-      argument.add("($T) ", rawTypeName(TypeName.get(dependencyType)));
+      return dependencyExpression.castTo(types.erasure(dependencyType));
     }
 
-    argument.add(getDependencyExpression(dependencyRequest, requestingClass));
-    return argument.build();
+    return dependencyExpression;
   }
 
   private BindingExpression getBindingExpression(BindingKey bindingKey) {
@@ -125,7 +139,8 @@ void addBindingExpression(BindingExpression bindingExpression) {
    */
   ComponentBindingExpressions forChildComponent() {
     return new ComponentBindingExpressions(
-        FluentIterable.of(newBindingExpressionMap()).append(bindingExpressionsMaps).toList());
+        FluentIterable.of(newBindingExpressionMap()).append(bindingExpressionsMaps).toList(),
+        types);
   }
 
   private static Map<BindingKey, BindingExpression> newBindingExpressionMap() {
diff --git a/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
index 7523cf389..0c8635e95 100644
--- a/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
@@ -18,21 +18,32 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /** A binding expression for the instance of the component itself, i.e. {@code this}. */
 final class ComponentInstanceBindingExpression extends SimpleInvocationBindingExpression {
   private final ClassName componentName;
+  private final ContributionBinding binding;
 
-  ComponentInstanceBindingExpression(BindingExpression delegate, ClassName componentName) {
-    super(delegate);
+  ComponentInstanceBindingExpression(
+      BindingExpression delegate,
+      ContributionBinding binding,
+      ClassName componentName,
+      Types types,
+      Elements elements) {
+    super(delegate, types, elements);
     this.componentName = componentName;
+    this.binding = binding;
   }
 
   @Override
-  CodeBlock getInstanceDependencyExpression(
+  Expression getInstanceDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
-    return componentName.equals(requestingClass)
-        ? CodeBlock.of("this")
-        : CodeBlock.of("$T.this", componentName);
+    return Expression.create(
+        binding.key().type(),
+        componentName.equals(requestingClass)
+            ? CodeBlock.of("this")
+            : CodeBlock.of("$T.this", componentName));
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
index f05a7594f..af8b1f9c8 100644
--- a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
@@ -24,6 +24,8 @@
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.Preconditions;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /** A binding expression for component provision methods. */
 final class ComponentProvisionBindingExpression extends SimpleInvocationBindingExpression {
@@ -37,8 +39,10 @@
       ProvisionBinding binding,
       BindingGraph bindingGraph,
       ComponentRequirementFields componentRequirementFields,
-      CompilerOptions compilerOptions) {
-    super(providerBindingExpression);
+      CompilerOptions compilerOptions,
+      Types types,
+      Elements elements) {
+    super(providerBindingExpression, types, elements);
     this.binding = checkNotNull(binding);
     this.bindingGraph = checkNotNull(bindingGraph);
     this.componentRequirementFields = checkNotNull(componentRequirementFields);
@@ -46,14 +50,15 @@
   }
 
   @Override
-  CodeBlock getInstanceDependencyExpression(
+  Expression getInstanceDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
     CodeBlock invocation =
         CodeBlock.of(
             "$L.$L()",
             componentRequirementFields.getExpression(componentRequirement(), requestingClass),
             binding.bindingElement().get().getSimpleName());
-    return maybeCheckForNull(binding, compilerOptions, invocation);
+    return Expression.create(
+        binding.key().type(), maybeCheckForNull(binding, compilerOptions, invocation));
   }
 
   private ComponentRequirement componentRequirement() {
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index 0797433f8..1bd1820c2 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -65,7 +65,7 @@
         graph,
         new UniqueSubcomponentNamesGenerator(graph).generate(),
         new OptionalFactories(),
-        new ComponentBindingExpressions(),
+        new ComponentBindingExpressions(types),
         new ComponentRequirementFields());
   }
 
diff --git a/java/dagger/internal/codegen/DaggerTypes.java b/java/dagger/internal/codegen/DaggerTypes.java
index b000e1353..31967472d 100644
--- a/java/dagger/internal/codegen/DaggerTypes.java
+++ b/java/dagger/internal/codegen/DaggerTypes.java
@@ -16,8 +16,14 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.getOnlyElement;
+
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import java.util.List;
 import java.util.Optional;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
@@ -27,6 +33,7 @@
  * Utilities for working with {@link TypeMirror} objects. Each is a candidate to move to {@link
  * MoreTypes}.
  */
+// TODO(dpb): Change this to an object that contains a Types.
 final class DaggerTypes {
   /**
    * Returns the non-{@link Object} superclass of the type with the proper type parameters. An empty
@@ -36,4 +43,60 @@
       Types types, Elements elements, DeclaredType type) {
     return Optional.ofNullable(MoreTypes.nonObjectSuperclass(types, elements, type).orNull());
   }
+
+  /**
+   * Returns {@code type}'s single type argument, if one exists, or {@link Object} if not.
+   *
+   * <p>For example, if {@code type} is {@code List<Number>} this will return {@code Number}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not a declared type or has more than one
+   *     type argument.
+   */
+  static TypeMirror unwrapTypeOrObject(TypeMirror type, Elements elements) {
+    DeclaredType declaredType = MoreTypes.asDeclared(type);
+    TypeElement typeElement = MoreElements.asType(declaredType.asElement());
+    checkArgument(
+        !typeElement.getTypeParameters().isEmpty(),
+        "%s does not have a type parameter",
+        typeElement.getQualifiedName());
+    return getOnlyElement(
+        declaredType.getTypeArguments(),
+        elements.getTypeElement(Object.class.getCanonicalName()).asType());
+  }
+
+  /**
+   * Returns {@code type} wrapped in {@code wrappingClass}.
+   *
+   * <p>For example, if {@code type} is {@code List<Number>} and {@code wrappingClass} is {@code
+   * Set.class}, this will return {@code Set<List<Number>>}.
+   */
+  static TypeMirror wrapType(
+      TypeMirror type, Class<?> wrappingClass, Types types, Elements elements) {
+    return types.getDeclaredType(elements.getTypeElement(wrappingClass.getCanonicalName()), type);
+  }
+
+  /**
+   * Returns {@code type}'s single type argument wrapped in {@code wrappingClass}.
+   *
+   * <p>For example, if {@code type} is {@code List<Number>} and {@code wrappingClass} is {@code
+   * Set.class}, this will return {@code Set<Number>}.
+   *
+   * <p>If {@code type} has no type parameters, returns a {@link TypeMirror} for {@code
+   * wrappingClass} as a raw type.
+   *
+   * @throws IllegalArgumentException if {@code} has more than one type argument.
+   */
+  static DeclaredType rewrapType(
+      TypeMirror type, Class<?> wrappingClass, Types types, Elements elements) {
+    List<? extends TypeMirror> typeArguments = MoreTypes.asDeclared(type).getTypeArguments();
+    TypeElement wrappingType = elements.getTypeElement(wrappingClass.getCanonicalName());
+    switch (typeArguments.size()) {
+      case 0:
+        return types.getDeclaredType(wrappingType);
+      case 1:
+        return types.getDeclaredType(wrappingType, getOnlyElement(typeArguments));
+      default:
+        throw new IllegalArgumentException(type + " has more than 1 type argument");
+    }
+  }
 }
diff --git a/java/dagger/internal/codegen/Expression.java b/java/dagger/internal/codegen/Expression.java
new file mode 100644
index 000000000..0678cd7f4
--- /dev/null
+++ b/java/dagger/internal/codegen/Expression.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.CodeBlock;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Encapsulates a {@link CodeBlock} for an <a
+ * href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html">expression</a> and the
+ * {@link TypeMirror} that it represents from the perspective of the compiler. Consider the
+ * following example:
+ *
+ * <pre><code>
+ *   {@literal @SuppressWarnings("rawtypes")}
+ *   private Provider fooImplProvider = DoubleCheck.provider(FooImpl_Factory.create());
+ * </code></pre>
+ *
+ * <p>An {@code Expression} for {@code fooImplProvider.get()} would have a {@link #type()} of {@code
+ * java.lang.Object} and not {@code FooImpl}.
+ */
+final class Expression {
+  private final TypeMirror type;
+  private final CodeBlock codeBlock;
+
+  private Expression(TypeMirror type, CodeBlock codeBlock) {
+    this.type = type;
+    this.codeBlock = codeBlock;
+  }
+
+  /** Creates a new {@link Expression} with a {@link TypeMirror} and {@link CodeBlock}. */
+  static Expression create(TypeMirror type, CodeBlock expression) {
+    return new Expression(type, expression);
+  }
+
+  /** Returns a new expression that casts the current expression to {@code newType}. */
+  // TODO(ronshapiro): consider overloads that take a Types and Elements and only cast if necessary,
+  // or just embedding a Types/Elements instance in an Expression.
+  Expression castTo(TypeMirror newType) {
+    return Expression.create(newType, CodeBlock.of("($T) $L", newType, codeBlock));
+  }
+
+  /** The {@link TypeMirror type} to which the expression evaluates. */
+  TypeMirror type() {
+    return type;
+  }
+
+  /** The code of the expression. */
+  CodeBlock codeBlock() {
+    return codeBlock;
+  }
+
+  @Override
+  public String toString() {
+    return String.format("[%s] %s", type, codeBlock);
+  }
+}
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index f5ddfb423..b78902e8b 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -135,8 +135,11 @@ CodeBlock getFieldInitialization() {
     if (isProducerFromProvider) {
       return FrameworkType.PROVIDER.to(
           DependencyRequest.Kind.PRODUCER,
-          componentBindingExpressions.getDependencyExpression(
-              FrameworkDependency.create(resolvedBindings.bindingKey(), PROVISION), componentName));
+          componentBindingExpressions
+              .getDependencyExpression(
+                  FrameworkDependency.create(resolvedBindings.bindingKey(), PROVISION),
+                  componentName)
+              .codeBlock());
     }
 
     switch (resolvedBindings.bindingKey().kind()) {
@@ -466,6 +469,7 @@ private CodeBlock factoryForMapMultibindingInitialization(ContributionBinding bi
     return CodeBlocks.concat(codeBlocks.build());
   }
 
+  // TODO(ronshapiro): Use functionality from Expression
   private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, CodeBlock notCasted) {
     if (!shouldCast) {
       return notCasted;
@@ -618,7 +622,9 @@ private CodeBlock factoryForSyntheticOptionalBindingInitialization(ContributionB
 
   /** Returns a code block referencing the given dependency. */
   private CodeBlock getDependencyExpression(FrameworkDependency frameworkDependency) {
-    return componentBindingExpressions.getDependencyExpression(frameworkDependency, componentName);
+    return componentBindingExpressions
+        .getDependencyExpression(frameworkDependency, componentName)
+        .codeBlock();
   }
 
   FrameworkFieldInitializer forProducerFromProvider() {
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index f4748b6b8..1e2606cac 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -19,6 +19,8 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.DaggerTypes.wrapType;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 
 import com.squareup.javapoet.ClassName;
@@ -26,6 +28,10 @@
 import com.squareup.javapoet.FieldSpec;
 import dagger.internal.DelegateFactory;
 import java.util.Optional;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /** A binding expression that uses an instance of a {@link FrameworkType}. */
 final class FrameworkInstanceBindingExpression extends BindingExpression {
@@ -34,6 +40,8 @@
   private final MemberSelect memberSelect;
   private final FrameworkType frameworkType;
   private final FrameworkFieldInitializer fieldInitializer;
+  private final Types types;
+  private final Elements elements;
   private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
   /** Returns a binding expression for a binding. */
@@ -42,14 +50,18 @@ static FrameworkInstanceBindingExpression create(
       Optional<FieldSpec> fieldSpec,
       GeneratedComponentModel generatedComponentModel,
       MemberSelect memberSelect,
-      FrameworkFieldInitializer frameworkFieldInitializer) {
+      FrameworkFieldInitializer frameworkFieldInitializer,
+      Types types,
+      Elements elements) {
     return new FrameworkInstanceBindingExpression(
         resolvedBindings,
         fieldSpec,
         generatedComponentModel,
         memberSelect,
         resolvedBindings.bindingType().frameworkType(),
-        frameworkFieldInitializer);
+        frameworkFieldInitializer,
+        types,
+        elements);
   }
 
   private FrameworkInstanceBindingExpression(
@@ -58,13 +70,17 @@ private FrameworkInstanceBindingExpression(
       GeneratedComponentModel generatedComponentModel,
       MemberSelect memberSelect,
       FrameworkType frameworkType,
-      FrameworkFieldInitializer fieldInitializer) {
+      FrameworkFieldInitializer fieldInitializer,
+      Types types,
+      Elements elements) {
     super(resolvedBindings);
     this.generatedComponentModel = generatedComponentModel;
     this.memberSelect = memberSelect;
     this.fieldSpec = fieldSpec;
     this.frameworkType = frameworkType;
     this.fieldInitializer = fieldInitializer;
+    this.types = types;
+    this.elements = elements;
   }
 
   FrameworkInstanceBindingExpression producerFromProvider(
@@ -76,12 +92,9 @@ FrameworkInstanceBindingExpression producerFromProvider(
         generatedComponentModel,
         MemberSelect.localField(componentName, fieldSpec.name),
         FrameworkType.PRODUCER,
-        fieldInitializer.forProducerFromProvider());
-  }
-
-  @Override
-  CodeBlock getDependencyExpression(DependencyRequest.Kind requestKind, ClassName requestingClass) {
-    return frameworkType.to(requestKind, getFrameworkTypeInstance(requestingClass));
+        fieldInitializer.forProducerFromProvider(),
+        types,
+        elements);
   }
 
   /**
@@ -90,9 +103,37 @@ CodeBlock getDependencyExpression(DependencyRequest.Kind requestKind, ClassName
    * initialized} and {@link GeneratedComponentModel#addField(FieldSpec) added} to the component the
    * first time this method is invoked.
    */
-  final CodeBlock getFrameworkTypeInstance(ClassName requestingClass) {
+  @Override
+  Expression getDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
     maybeInitializeField();
-    return memberSelect.getExpressionFor(requestingClass);
+    TypeMirror expressionType =
+        isTypeAccessibleFrom(instanceType(), requestingClass.packageName())
+            ? wrapType(instanceType(), resolvedBindings().frameworkClass(), types, elements)
+            : rawFrameworkType();
+
+    return frameworkType.to(
+        requestKind,
+        Expression.create(expressionType, memberSelect.getExpressionFor(requestingClass)),
+        types,
+        elements);
+  }
+
+  /**
+   * The instance type {@code T} of this {@code FrameworkType<T>}. For {@link
+   * MembersInjectionBinding}s, this is the {@linkplain Key#type() key type}; for {@link
+   * ContributionBinding}s, this the {@link ContributionBinding#contributedType()}.
+   */
+  private TypeMirror instanceType() {
+    return resolvedBindings()
+        .membersInjectionBinding()
+        .map(binding -> binding.key().type())
+        .orElseGet(() -> resolvedBindings().contributionBinding().contributedType());
+  }
+
+  private DeclaredType rawFrameworkType() {
+    return types.getDeclaredType(
+        elements.getTypeElement(resolvedBindings().frameworkClass().getCanonicalName()));
   }
 
   /**
diff --git a/java/dagger/internal/codegen/FrameworkType.java b/java/dagger/internal/codegen/FrameworkType.java
index 15cb4fccf..01ff94525 100644
--- a/java/dagger/internal/codegen/FrameworkType.java
+++ b/java/dagger/internal/codegen/FrameworkType.java
@@ -18,10 +18,15 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static dagger.internal.codegen.DaggerTypes.rewrapType;
+import static dagger.internal.codegen.DaggerTypes.unwrapTypeOrObject;
+import static dagger.internal.codegen.DaggerTypes.wrapType;
 import static dagger.internal.codegen.DependencyRequest.Kind.INSTANCE;
 
 import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.CodeBlock;
+import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.internal.DoubleCheck;
 import dagger.internal.ProviderOfLazy;
@@ -29,6 +34,9 @@
 import dagger.producers.Producer;
 import dagger.producers.internal.Producers;
 import javax.inject.Provider;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /** One of the core types initialized as fields in a generated component. */
 enum FrameworkType {
@@ -63,6 +71,32 @@ CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
               String.format("Cannot request a %s from a %s", requestKind, this));
       }
     }
+
+    @Override
+    Expression to(
+        DependencyRequest.Kind requestKind, Expression from, Types types, Elements elements) {
+      CodeBlock codeBlock = to(requestKind, from.codeBlock());
+      switch (requestKind) {
+        case INSTANCE:
+          return Expression.create(unwrapTypeOrObject(from.type(), elements), codeBlock);
+
+        case PROVIDER:
+          return from;
+
+        case PROVIDER_OF_LAZY:
+          TypeMirror lazyType = rewrapType(from.type(), Lazy.class, types, elements);
+          return Expression.create(wrapType(lazyType, Provider.class, types, elements), codeBlock);
+
+        case FUTURE:
+          return Expression.create(
+              rewrapType(from.type(), ListenableFuture.class, types, elements), codeBlock);
+
+        default:
+          return Expression.create(
+              rewrapType(from.type(), requestKind.frameworkClass.get(), types, elements),
+              codeBlock);
+      }
+    }
   },
 
   /** A {@link Producer}. */
@@ -81,6 +115,24 @@ CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
               String.format("Cannot request a %s from a %s", requestKind, this));
       }
     }
+
+    @Override
+    Expression to(
+        DependencyRequest.Kind requestKind, Expression from, Types types, Elements elements) {
+      switch (requestKind) {
+        case FUTURE:
+          return Expression.create(
+              rewrapType(from.type(), ListenableFuture.class, types, elements),
+              to(requestKind, from.codeBlock()));
+
+        case PRODUCER:
+          return from;
+
+        default:
+          throw new IllegalArgumentException(
+              String.format("Cannot request a %s from a %s", requestKind, this));
+      }
+    }
   },
 
   /** A {@link MembersInjector}. */
@@ -96,21 +148,47 @@ CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
               String.format("Cannot request a %s from a %s", requestKind, this));
       }
     }
+
+    @Override
+    Expression to(
+        DependencyRequest.Kind requestKind, Expression from, Types types, Elements elements) {
+      switch (requestKind) {
+        case MEMBERS_INJECTOR:
+          return from;
+
+        default:
+          throw new IllegalArgumentException(
+              String.format("Cannot request a %s from a %s", requestKind, this));
+      }
+    }
   },
   ;
 
   /**
-   * Returns an expression that evaluates to a requested object given an expression that evaluates
-   * to an instance of this framework type.
+   * Returns a {@link CodeBlock} that evaluates to a requested object given an expression that
+   * evaluates to an instance of this framework type.
    *
    * @param requestKind the kind of {@link DependencyRequest} that the returned expression can
    *     satisfy
-   * @param from an expression that evaluates to an instance of this framework type
+   * @param from a {@link CodeBlock} that evaluates to an instance of this framework type
    * @throws IllegalArgumentException if a valid expression cannot be generated for {@code
    *     requestKind}
    */
   abstract CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from);
 
+  /**
+   * Returns an {@link Expression} that evaluates to a requested object given an expression that
+   * evaluates to an instance of this framework type.
+   *
+   * @param requestKind the kind of {@link DependencyRequest} that the returned expression can
+   *     satisfy
+   * @param from an expression that evaluates to an instance of this framework type
+   * @throws IllegalArgumentException if a valid expression cannot be generated for {@code
+   *     requestKind}
+   */
+  abstract Expression to(
+      DependencyRequest.Kind requestKind, Expression from, Types types, Elements elements);
+
   @Override
   public String toString() {
     return UPPER_UNDERSCORE.to(UPPER_CAMEL, super.toString());
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index eba95111b..165d695ae 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -32,6 +32,7 @@
 import java.util.Map;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /** A {@link BindingExpression} for multibound maps. */
 final class MapBindingExpression extends SimpleInvocationBindingExpression {
@@ -48,8 +49,9 @@
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       BindingExpression delegate,
+      Types types,
       Elements elements) {
-    super(delegate);
+    super(delegate, types, elements);
     ContributionBinding.Kind bindingKind = binding.bindingKind();
     checkArgument(bindingKind.equals(SYNTHETIC_MULTIBOUND_MAP), bindingKind);
     this.binding = binding;
@@ -62,8 +64,12 @@
   }
 
   @Override
-  CodeBlock getInstanceDependencyExpression(
+  Expression getInstanceDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    return Expression.create(binding.key().type(), mapExpression(requestingClass));
+  }
+
+  private CodeBlock mapExpression(ClassName requestingClass) {
     // TODO(ronshapiro): We should also make an ImmutableMap version of MapFactory
     boolean isImmutableMapAvailable = isImmutableMapAvailable();
     // TODO(ronshapiro, gak): Use Maps.immutableEnumMap() if it's available?
@@ -111,7 +117,9 @@ private CodeBlock keyAndValueExpression(DependencyRequest dependency, ClassName
     return CodeBlock.of(
         "$L, $L",
         getMapKeyExpression(dependencies.get(dependency), requestingClass),
-        componentBindingExpressions.getDependencyExpression(dependency, requestingClass));
+        componentBindingExpressions
+            .getDependencyExpression(dependency, requestingClass)
+            .codeBlock());
   }
 
   private CodeBlock collectionsStaticFactoryInvocation(
diff --git a/java/dagger/internal/codegen/OptionalBindingExpression.java b/java/dagger/internal/codegen/OptionalBindingExpression.java
index a4cca110a..7c565f1ab 100644
--- a/java/dagger/internal/codegen/OptionalBindingExpression.java
+++ b/java/dagger/internal/codegen/OptionalBindingExpression.java
@@ -22,23 +22,29 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.OptionalType.OptionalKind;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /** A binding expression for optional bindings. */
 final class OptionalBindingExpression extends SimpleInvocationBindingExpression {
   private final ProvisionBinding binding;
   private final ComponentBindingExpressions componentBindingExpressions;
+  private final Types types;
 
   OptionalBindingExpression(
       ProvisionBinding binding,
       BindingExpression delegate,
-      ComponentBindingExpressions componentBindingExpressions) {
-    super(delegate);
+      ComponentBindingExpressions componentBindingExpressions,
+      Types types,
+      Elements elements) {
+    super(delegate, types, elements);
     this.binding = binding;
     this.componentBindingExpressions = componentBindingExpressions;
+    this.types = types;
   }
 
   @Override
-  CodeBlock getInstanceDependencyExpression(
+  Expression getInstanceDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
     OptionalType optionalType = OptionalType.from(binding.key());
     OptionalKind optionalKind = optionalType.kind();
@@ -47,20 +53,27 @@ CodeBlock getInstanceDependencyExpression(
       // Futures.immediateFuture(Optional.absent()) for keys that aren't Object
       if (requestKind.equals(DependencyRequest.Kind.FUTURE)
           && isTypeAccessibleFrom(binding.key().type(), requestingClass.packageName())) {
-        return optionalKind.parameterizedAbsentValueExpression(optionalType);
+        return Expression.create(
+            binding.key().type(),
+            optionalKind.parameterizedAbsentValueExpression(optionalType));
       }
-      return optionalKind.absentValueExpression();
+      return Expression.create(binding.key().type(), optionalKind.absentValueExpression());
     }
     DependencyRequest dependency = getOnlyElement(binding.dependencies());
 
     CodeBlock dependencyExpression =
-        componentBindingExpressions.getDependencyExpression(dependency, requestingClass);
+        componentBindingExpressions
+            .getDependencyExpression(dependency, requestingClass)
+            .codeBlock();
 
     // If the dependency type is inaccessible, then we have to use Optional.<Object>of(...), or else
     // we will get "incompatible types: inference variable has incompatible bounds.
     // TODO(user): Do we need presentObjectExpression in androidExperimentalMode?
     return isTypeAccessibleFrom(dependency.key().type(), requestingClass.packageName())
-        ? optionalKind.presentExpression(dependencyExpression)
-        : optionalKind.presentObjectExpression(dependencyExpression);
+        ? Expression.create(
+            binding.key().type(), optionalKind.presentExpression(dependencyExpression))
+        : Expression.create(
+            types.erasure(binding.key().type()),
+            optionalKind.presentObjectExpression(dependencyExpression));
   }
 }
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index f85659e82..c917b4efa 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -23,13 +23,17 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
+import com.google.auto.common.MoreTypes;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import java.util.EnumMap;
 import java.util.Map;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * A binding expression that wraps the dependency expressions in a private, no-arg method.
@@ -43,30 +47,37 @@
   private final Map<DependencyRequest.Kind, MethodSpec> methods =
       new EnumMap<>(DependencyRequest.Kind.class);
   private final ContributionBinding binding;
-  private final TypeName instanceType;
+  private final Types types;
+  private final Elements elements;
 
   PrivateMethodBindingExpression(
       ResolvedBindings resolvedBindings,
       ClassName componentName,
       GeneratedComponentModel generatedComponentModel,
-      BindingExpression delegate) {
+      BindingExpression delegate,
+      Types types,
+      Elements elements) {
     super(resolvedBindings);
     this.componentName = componentName;
     this.generatedComponentModel = generatedComponentModel;
     this.delegate = delegate;
     binding = resolvedBindings.contributionBinding();
-    instanceType = accessibleType(binding.contributedType(), componentName);
+    this.types = types;
+    this.elements = elements;
   }
 
   @Override
-  CodeBlock getDependencyExpression(DependencyRequest.Kind requestKind, ClassName requestingClass) {
+  Expression getDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
     // TODO(user): we should just use the component method if one matches instead of creating one.
     switch (requestKind) {
       case INSTANCE:
         MethodSpec method = methods.computeIfAbsent(requestKind, this::createMethod);
-        return componentName.equals(requestingClass)
-            ? CodeBlock.of("$N()", method)
-            : CodeBlock.of("$T.this.$N()", componentName, method);
+        CodeBlock invocation =
+            componentName.equals(requestingClass)
+                ? CodeBlock.of("$N()", method)
+                : CodeBlock.of("$T.this.$N()", componentName, method);
+        return Expression.create(returnType(), invocation);
       default:
         return delegate.getDependencyExpression(requestKind, requestingClass);
     }
@@ -77,18 +88,20 @@ private MethodSpec createMethod(DependencyRequest.Kind requestKind) {
     MethodSpec method =
         methodBuilder(generatedComponentModel.getUniqueMethodName(methodName(requestKind)))
             .addModifiers(PRIVATE)
-            .returns(returnType())
-            .addStatement("return $L", delegate.getDependencyExpression(requestKind, componentName))
+            .returns(TypeName.get(returnType()))
+            .addStatement(
+                "return $L",
+                delegate.getDependencyExpression(requestKind, componentName).codeBlock())
             .build();
 
     generatedComponentModel.addMethod(method);
     return method;
   }
 
-  private TypeName returnType() {
+  private TypeMirror returnType() {
     return binding.contributesPrimitiveType()
-        ? TypeName.get(asExecutable(binding.bindingElement().get()).getReturnType())
-        : instanceType;
+        ? asExecutable(binding.bindingElement().get()).getReturnType()
+        : accessibleType(binding.contributedType(), componentName);
   }
 
   /** Returns the canonical name for a no-arg dependency expression method. */
@@ -107,15 +120,15 @@ private static String dependencyKindName(DependencyRequest.Kind kind) {
     return UPPER_UNDERSCORE.to(UPPER_CAMEL, kind.name());
   }
 
-  // TODO(ronshapiro): Move this logic to some common place.
   /** Returns a {@link TypeName} for the binding that is accessible to the component. */
-  private static TypeName accessibleType(TypeMirror typeMirror, ClassName componentName) {
+  private TypeMirror accessibleType(TypeMirror typeMirror, ClassName componentName) {
     if (Accessibility.isTypeAccessibleFrom(typeMirror, componentName.packageName())) {
-      return TypeName.get(typeMirror);
-    } else if (Accessibility.isRawTypeAccessible(typeMirror, componentName.packageName())) {
-      return TypeNames.rawTypeName(TypeName.get(typeMirror));
+      return typeMirror;
+    } else if (Accessibility.isRawTypeAccessible(typeMirror, componentName.packageName())
+        && typeMirror.getKind().equals(TypeKind.DECLARED)) {
+      return types.getDeclaredType(MoreTypes.asTypeElement(typeMirror));
     } else {
-      return TypeName.OBJECT;
+      return elements.getTypeElement(Object.class.getCanonicalName()).asType();
     }
   }
 }
diff --git a/java/dagger/internal/codegen/ProviderOrProducerBindingExpression.java b/java/dagger/internal/codegen/ProviderOrProducerBindingExpression.java
index 07cb22a6e..51275f773 100644
--- a/java/dagger/internal/codegen/ProviderOrProducerBindingExpression.java
+++ b/java/dagger/internal/codegen/ProviderOrProducerBindingExpression.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
 
 /**
  * A {@link FrameworkInstanceBindingExpression} that is expressed with a {@link
@@ -39,7 +38,8 @@
   }
 
   @Override
-  CodeBlock getDependencyExpression(DependencyRequest.Kind requestKind, ClassName requestingClass) {
+  Expression getDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
     switch (requestKind) {
       case PRODUCER:
         return producerBindingExpression.getDependencyExpression(requestKind, requestingClass);
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
index 4c2c2023e..1c5650949 100644
--- a/java/dagger/internal/codegen/SetBindingExpression.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -28,6 +28,7 @@
 import java.util.Set;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /** A binding expression for multibound sets. */
 final class SetBindingExpression extends SimpleInvocationBindingExpression {
@@ -41,8 +42,9 @@
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       BindingExpression delegate,
+      Types types,
       Elements elements) {
-    super(delegate);
+    super(delegate, types, elements);
     this.binding = binding;
     this.graph = graph;
     this.componentBindingExpressions = componentBindingExpressions;
@@ -50,8 +52,12 @@
   }
 
   @Override
-  CodeBlock getInstanceDependencyExpression(
+  Expression getInstanceDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    return Expression.create(binding.key().type(), setExpression(requestingClass));
+  }
+
+  private CodeBlock setExpression(ClassName requestingClass) {
     // TODO(ronshapiro): We should also make an ImmutableSet version of SetFactory
     boolean isImmutableSetAvailable = isImmutableSetAvailable();
     // TODO(ronshapiro, gak): Use Sets.immutableEnumSet() if it's available?
@@ -108,7 +114,9 @@ CodeBlock getInstanceDependencyExpression(
 
   private CodeBlock getContributionExpression(
       DependencyRequest dependency, ClassName requestingClass) {
-    return componentBindingExpressions.getDependencyExpression(dependency, requestingClass);
+    return componentBindingExpressions
+        .getDependencyExpression(dependency, requestingClass)
+        .codeBlock();
   }
 
   private CodeBlock collectionsStaticFactoryInvocation(
diff --git a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
index f01ecd80e..1582d492d 100644
--- a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
@@ -16,9 +16,14 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.DaggerTypes.wrapType;
+
 import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * A binding expression that can use a simple expression for instance requests, and delegates to
@@ -26,10 +31,14 @@
  */
 abstract class SimpleInvocationBindingExpression extends BindingExpression {
   private final BindingExpression delegate;
+  private final Types types;
+  private final Elements elements;
 
-  SimpleInvocationBindingExpression(BindingExpression delegate) {
+  SimpleInvocationBindingExpression(BindingExpression delegate, Types types, Elements elements) {
     super(delegate.resolvedBindings());
     this.delegate = delegate;
+    this.types = types;
+    this.elements = elements;
   }
 
   /**
@@ -37,7 +46,7 @@
    *
    * @param requestingClass the class that will contain the expression
    */
-  abstract CodeBlock getInstanceDependencyExpression(
+  abstract Expression getInstanceDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass);
 
   /**
@@ -52,19 +61,20 @@ protected CodeBlock explicitTypeParameter(ClassName requestingClass) {
   }
 
   @Override
-  final CodeBlock getDependencyExpression(
+  final Expression getDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
     switch (requestKind) {
       case INSTANCE:
         return getInstanceDependencyExpression(requestKind, requestingClass);
       case FUTURE:
-        return CodeBlock.builder()
-            .add("$T.", Futures.class)
-            .add(explicitTypeParameter(requestingClass))
-            .add(
-                "immediateFuture($L)",
-                getInstanceDependencyExpression(requestKind, requestingClass))
-            .build();
+        Expression expression = getInstanceDependencyExpression(requestKind, requestingClass);
+        return Expression.create(
+            wrapType(expression.type(), ListenableFuture.class, types, elements),
+            CodeBlock.builder()
+                .add("$T.", Futures.class)
+                .add(explicitTypeParameter(requestingClass))
+                .add("immediateFuture($L)", expression.codeBlock())
+                .build());
       default:
         return delegate.getDependencyExpression(requestKind, requestingClass);
     }
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index 4586c3d83..6c3ccec27 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -28,12 +28,16 @@
 import com.google.auto.common.MoreTypes;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import dagger.internal.codegen.InjectionMethods.ProvisionMethod;
 import java.util.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * A binding expression that invokes methods or constructors directly for a provision binding when
@@ -45,6 +49,7 @@
   private final ComponentBindingExpressions componentBindingExpressions;
   private final GeneratedComponentModel generatedComponentModel;
   private final ComponentRequirementFields componentRequirementFields;
+  private final Elements elements;
 
   SimpleMethodBindingExpression(
       CompilerOptions compilerOptions,
@@ -52,8 +57,10 @@
       BindingExpression delegate,
       ComponentBindingExpressions componentBindingExpressions,
       GeneratedComponentModel generatedComponentModel,
-      ComponentRequirementFields componentRequirementFields) {
-    super(delegate);
+      ComponentRequirementFields componentRequirementFields,
+      Types types,
+      Elements elements) {
+    super(delegate, types, elements);
     checkArgument(
         provisionBinding.implicitDependencies().isEmpty(),
         "framework deps are not currently supported");
@@ -64,17 +71,18 @@
     this.componentBindingExpressions = componentBindingExpressions;
     this.generatedComponentModel = generatedComponentModel;
     this.componentRequirementFields = componentRequirementFields;
+    this.elements = elements;
   }
 
   @Override
-  CodeBlock getInstanceDependencyExpression(
+  Expression getInstanceDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
     return requiresInjectionMethod(provisionBinding, requestingClass.packageName())
         ? invokeInjectionMethod(requestingClass)
         : invokeMethod(requestingClass);
   }
 
-  private CodeBlock invokeMethod(ClassName requestingClass) {
+  private Expression invokeMethod(ClassName requestingClass) {
     // TODO(dpb): align this with the contents of InlineMethods.create
     CodeBlock arguments =
         provisionBinding
@@ -83,18 +91,22 @@ private CodeBlock invokeMethod(ClassName requestingClass) {
             .map(request -> dependencyArgument(request, requestingClass))
             .collect(toParametersCodeBlock());
     ExecutableElement method = asExecutable(provisionBinding.bindingElement().get());
+    CodeBlock invocation;
     switch (method.getKind()) {
       case CONSTRUCTOR:
-        return CodeBlock.of("new $T($L)", constructorTypeName(requestingClass), arguments);
+        invocation = CodeBlock.of("new $T($L)", constructorTypeName(requestingClass), arguments);
+        break;
       case METHOD:
         CodeBlock module =
             moduleReference(requestingClass)
                 .orElse(CodeBlock.of("$T", provisionBinding.bindingTypeElement().get()));
-        return maybeCheckForNulls(
+        invocation = maybeCheckForNulls(
             CodeBlock.of("$L.$L($L)", module, method.getSimpleName(), arguments));
+        break;
       default:
         throw new IllegalStateException();
     }
+    return Expression.create(provisionBinding.key().type(), invocation);
   }
 
   private TypeName constructorTypeName(ClassName requestingClass) {
@@ -108,7 +120,7 @@ private TypeName constructorTypeName(ClassName requestingClass) {
     return rawTypeName(typeName);
   }
 
-  private CodeBlock invokeInjectionMethod(ClassName requestingClass) {
+  private Expression invokeInjectionMethod(ClassName requestingClass) {
     return injectMembers(
         maybeCheckForNulls(
             ProvisionMethod.invoke(
@@ -119,7 +131,9 @@ private CodeBlock invokeInjectionMethod(ClassName requestingClass) {
   }
 
   private CodeBlock dependencyArgument(DependencyRequest dependency, ClassName requestingClass) {
-    return componentBindingExpressions.getDependencyArgumentExpression(dependency, requestingClass);
+    return componentBindingExpressions
+        .getDependencyArgumentExpression(dependency, requestingClass)
+        .codeBlock();
   }
 
   private CodeBlock maybeCheckForNulls(CodeBlock methodCall) {
@@ -129,9 +143,9 @@ private CodeBlock maybeCheckForNulls(CodeBlock methodCall) {
         : methodCall;
   }
 
-  private CodeBlock injectMembers(CodeBlock instance) {
+  private Expression injectMembers(CodeBlock instance) {
     if (provisionBinding.injectionSites().isEmpty()) {
-      return instance;
+      return Expression.create(provisionBinding.key().type(), instance);
     }
     // Java 7 type inference can't figure out that instance in
     // injectParameterized(Parameterized_Factory.newParameterized()) is Parameterized<T> and not
@@ -141,10 +155,13 @@ private CodeBlock injectMembers(CodeBlock instance) {
       instance = CodeBlock.of("($T) ($T) $L", keyType, rawTypeName(keyType), instance);
     }
 
-    return CodeBlock.of(
-        "$N($L)",
-        generatedComponentModel.getMembersInjectionMethod(provisionBinding.key()),
-        instance);
+    MethodSpec membersInjectionMethod =
+        generatedComponentModel.getMembersInjectionMethod(provisionBinding.key());
+    TypeMirror returnType =
+        membersInjectionMethod.returnType.equals(TypeName.OBJECT)
+            ? elements.getTypeElement(Object.class.getCanonicalName()).asType()
+            : provisionBinding.key().type();
+    return Expression.create(returnType, CodeBlock.of("$N($L)", membersInjectionMethod, instance));
   }
 
   private Optional<CodeBlock> moduleReference(ClassName requestingClass) {
diff --git a/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java b/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
index 1e87fe752..02b99d594 100644
--- a/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
+++ b/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
@@ -18,19 +18,29 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /** A binding expression for a subcomponent builder that just invokes the constructor. */
 final class SubcomponentBuilderBindingExpression extends SimpleInvocationBindingExpression {
   private final String subcomponentBuilderName;
+  private final ContributionBinding binding;
 
-  SubcomponentBuilderBindingExpression(BindingExpression delegate, String subcomponentBuilderName) {
-    super(delegate);
+  SubcomponentBuilderBindingExpression(
+      BindingExpression delegate,
+      ContributionBinding binding,
+      String subcomponentBuilderName,
+      Types types,
+      Elements elements) {
+    super(delegate, types, elements);
     this.subcomponentBuilderName = subcomponentBuilderName;
+    this.binding = binding;
   }
 
   @Override
-  CodeBlock getInstanceDependencyExpression(
+  Expression getInstanceDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
-    return CodeBlock.of("new $LBuilder()", subcomponentBuilderName);
+    return Expression.create(
+        binding.key().type(), CodeBlock.of("new $LBuilder()", subcomponentBuilderName));
   }
 }
diff --git a/javatests/dagger/internal/codegen/ExpressionTest.java b/javatests/dagger/internal/codegen/ExpressionTest.java
new file mode 100644
index 000000000..ba8a589ce
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ExpressionTest.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.testing.compile.CompilationRule;
+import com.squareup.javapoet.CodeBlock;
+import javax.lang.model.type.TypeMirror;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ExpressionTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  interface Supertype {}
+
+  interface Subtype extends Supertype {}
+
+  @Test
+  public void castTo() {
+    TypeMirror subtype = type(Subtype.class);
+    TypeMirror supertype = type(Supertype.class);
+    Expression expression = Expression.create(subtype, CodeBlock.of("new $T() {}", subtype));
+
+    Expression castTo = expression.castTo(supertype);
+
+    assertThat(castTo.type()).isSameAs(supertype);
+    assertThat(castTo.codeBlock().toString())
+        .isEqualTo(
+            "(dagger.internal.codegen.ExpressionTest.Supertype) "
+                + "new dagger.internal.codegen.ExpressionTest.Subtype() {}");
+  }
+
+  private TypeMirror type(Class<?> clazz) {
+    return compilationRule.getElements().getTypeElement(clazz.getCanonicalName()).asType();
+  }
+}
