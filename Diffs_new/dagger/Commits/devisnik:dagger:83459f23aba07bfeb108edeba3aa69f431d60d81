diff --git a/java/dagger/internal/codegen/OptionalBindingExpression.java b/java/dagger/internal/codegen/OptionalBindingExpression.java
index 2316e65e7..962b4bce1 100644
--- a/java/dagger/internal/codegen/OptionalBindingExpression.java
+++ b/java/dagger/internal/codegen/OptionalBindingExpression.java
@@ -22,7 +22,6 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.OptionalType.OptionalKind;
-import dagger.model.RequestKind;
 import javax.lang.model.util.Types;
 
 /** A binding expression for optional bindings. */
@@ -48,9 +47,10 @@ Expression getInstanceDependencyExpression(ClassName requestingClass) {
     OptionalKind optionalKind = optionalType.kind();
     if (binding.dependencies().isEmpty()) {
       // When compiling with -source 7, javac's type inference isn't strong enough to detect
-      // Futures.immediateFuture(Optional.absent()) for keys that aren't Object
-      if (requestKind().equals(RequestKind.FUTURE)
-          && isTypeAccessibleFrom(binding.key().type(), requestingClass.packageName())) {
+      // Futures.immediateFuture(Optional.absent()) for keys that aren't Object. It also has issues
+      // when used as an argument to some members injection proxy methods (see
+      // https://github.com/google/dagger/issues/916)
+      if (isTypeAccessibleFrom(binding.key().type(), requestingClass.packageName())) {
         return Expression.create(
             binding.key().type(),
             optionalKind.parameterizedAbsentValueExpression(optionalType));
diff --git a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
index 79a4e2e9d..1d5f0f6e4 100644
--- a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
@@ -125,13 +125,13 @@ public void inlinedOptionalBindings() {
             "",
             "  @Override",
             "  public Optional<DefinitelyNot> definitelyNot() {",
-            "    return Optional.absent();",
+            "    return Optional.<DefinitelyNot>absent();",
             "  }",
             "",
             "  @Override",
             "  public Optional<Provider<Lazy<DefinitelyNot>>>",
             "      providerOfLazyOfDefinitelyNot() {",
-            "    return Optional.absent();",
+            "    return Optional.<Provider<Lazy<DefinitelyNot>>>absent();",
             "  }",
             "}");
     Compilation compilation =
