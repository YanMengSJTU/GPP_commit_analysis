diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 036040852..1b8db0235 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -19,18 +19,14 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_SET;
-import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
-import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import java.util.EnumSet;
 import java.util.HashMap;
@@ -260,74 +256,28 @@ private BindingExpression createBindingExpression(BindingKey bindingKey) {
               generatedComponentModel, componentBindingExpressions, graph, elements, types);
     }
 
-    /** Creates a binding expression */
-    BindingExpression create(ResolvedBindings resolvedBindings) {
-      return forStaticMethod(resolvedBindings).orElseGet(() -> forField(resolvedBindings));
-    }
-
-    /** Creates a binding expression for a field. */
-    private BindingExpression forField(ResolvedBindings resolvedBindings) {
-      FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.empty());
-      return internalCreate(
-          resolvedBindings,
-          MemberSelect.localField(generatedComponentModel.name(), fieldSpec.name),
-          Optional.of(newFrameworkFieldInitializer(fieldSpec, resolvedBindings)));
-    }
-
-    /** Creates a binding expression for a static method call. */
-    private Optional<BindingExpression> forStaticMethod(ResolvedBindings resolvedBindings) {
-      return staticMemberSelect(resolvedBindings)
-          .map(memberSelect -> internalCreate(resolvedBindings, memberSelect, Optional.empty()));
-    }
-
-    /**
-     * Adds a field representing the resolved bindings, optionally forcing it to use a particular
-     * binding type (instead of the type the resolved bindings would typically use).
-     */
-    private FieldSpec generateFrameworkField(
-        ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
-      boolean useRawType =
-          !isTypeAccessibleFrom(
-              resolvedBindings.key().type(), generatedComponentModel.name().packageName());
-
-      FrameworkField contributionBindingField =
-          FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);
-      FieldSpec.Builder contributionField =
-          FieldSpec.builder(
-              useRawType
-                  ? contributionBindingField.type().rawType
-                  : contributionBindingField.type(),
-              generatedComponentModel.getUniqueFieldName(contributionBindingField.name()));
-      contributionField.addModifiers(PRIVATE);
-      if (useRawType) {
-        contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
-      }
-
-      return contributionField.build();
-    }
-
-    private FrameworkFieldInitializer newFrameworkFieldInitializer(
-        FieldSpec fieldSpec, ResolvedBindings resolvedBindings) {
-      return new FrameworkFieldInitializer(
-          fieldSpec,
+    private FrameworkInstanceBindingExpression newFrameworkInstanceBindingExpression(
+        boolean isProducerFromProvider, ResolvedBindings resolvedBindings) {
+      return FrameworkInstanceBindingExpression.create(
           resolvedBindings,
+          graph,
           subcomponentNames,
           generatedComponentModel,
           componentBindingExpressions,
           componentRequirementFields,
           referenceReleasingManagerFields,
+          isProducerFromProvider,
+          optionalFactories,
           compilerOptions,
-          graph,
-          optionalFactories);
+          types,
+          elements);
     }
 
-    private BindingExpression internalCreate(
-        ResolvedBindings resolvedBindings,
-        MemberSelect memberSelect,
-        Optional<FrameworkFieldInitializer> frameworkFieldInitializer) {
+    /** Creates a binding expression */
+    BindingExpression create(ResolvedBindings resolvedBindings) {
       FrameworkInstanceBindingExpression frameworkInstanceBindingExpression =
-          FrameworkInstanceBindingExpression.create(
-              resolvedBindings, memberSelect, frameworkFieldInitializer, types, elements);
+          newFrameworkInstanceBindingExpression(
+              false /* isProducerFromProvider */, resolvedBindings);
 
       switch (resolvedBindings.bindingType()) {
         case MEMBERS_INJECTION:
@@ -341,16 +291,22 @@ private BindingExpression internalCreate(
     }
 
     private BindingExpression provisionBindingExpression(
-        FrameworkInstanceBindingExpression frameworkInstanceBindingExpression) {
+        FrameworkInstanceBindingExpression providerBindingExpression) {
+      // TODO(user): this can be removed once we pass DependencyRequest.Kind to the factory.
+      // With DependencyRequest.Kind, we can know if it's a ProducerFromProvider or not, so we won't
+      // have to pass in both types of binding expressions.
+      ResolvedBindings resolvedBindings = providerBindingExpression.resolvedBindings();
+      FrameworkInstanceBindingExpression producerBindingExpression =
+          newFrameworkInstanceBindingExpression(
+              true /* isProducerFromProvider */, resolvedBindings);
       BindingExpression bindingExpression =
           new ProviderOrProducerBindingExpression(
-              frameworkInstanceBindingExpression,
-              producerFromProviderBindingExpression(frameworkInstanceBindingExpression));
+              providerBindingExpression,
+              producerBindingExpression);
 
       BindingExpression inlineBindingExpression =
           inlineProvisionBindingExpression(bindingExpression);
 
-      ResolvedBindings resolvedBindings = frameworkInstanceBindingExpression.resolvedBindings();
       if (usePrivateMethod(resolvedBindings.contributionBinding())) {
         return new PrivateMethodBindingExpression(
             resolvedBindings,
@@ -365,16 +321,6 @@ private BindingExpression provisionBindingExpression(
       return inlineBindingExpression;
     }
 
-    private FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
-        FrameworkInstanceBindingExpression providerBindingExpression) {
-      ResolvedBindings resolvedBindings = providerBindingExpression.resolvedBindings();
-      FieldSpec producerField =
-          generateFrameworkField(resolvedBindings, Optional.of(TypeNames.PRODUCER));
-      return providerBindingExpression.producerFromProvider(
-          MemberSelect.localField(generatedComponentModel.name(), producerField.name),
-          newFrameworkFieldInitializer(producerField, resolvedBindings).forProducerFromProvider());
-    }
-
     private BindingExpression inlineProvisionBindingExpression(
         BindingExpression bindingExpression) {
       ProvisionBinding provisionBinding =
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index 807733d66..5f3be4247 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -25,6 +25,7 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.BindingType.PROVISION;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
@@ -83,8 +84,8 @@
  * An object that can initialize a framework-type component field for a binding. An instance should
  * be created for each field.
  */
+// TODO(dpb): Split this class up, at least by binding kind, but maybe also producerFromProvider?
 final class FrameworkFieldInitializer {
-  private final FieldSpec fieldSpec;
   private final SubcomponentNames subcomponentNames;
   private final GeneratedComponentModel generatedComponentModel;
   private final ComponentBindingExpressions componentBindingExpressions;
@@ -96,35 +97,10 @@
   private final boolean isProducerFromProvider;
   private final OptionalFactories optionalFactories;
   private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
+  private FieldSpec fieldSpec;
   private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
   FrameworkFieldInitializer(
-      FieldSpec fieldSpec,
-      ResolvedBindings resolvedBindings,
-      SubcomponentNames subcomponentNames,
-      GeneratedComponentModel generatedComponentModel,
-      ComponentBindingExpressions componentBindingExpressions,
-      ComponentRequirementFields componentRequirementFields,
-      ReferenceReleasingManagerFields referenceReleasingManagerFields,
-      CompilerOptions compilerOptions,
-      BindingGraph graph,
-      OptionalFactories optionalFactories) {
-    this(
-        fieldSpec,
-        resolvedBindings,
-        subcomponentNames,
-        generatedComponentModel,
-        componentBindingExpressions,
-        componentRequirementFields,
-        referenceReleasingManagerFields,
-        compilerOptions,
-        graph,
-        false,
-        optionalFactories);
-  }
-
-  private FrameworkFieldInitializer(
-      FieldSpec fieldSpec,
       ResolvedBindings resolvedBindings,
       SubcomponentNames subcomponentNames,
       GeneratedComponentModel generatedComponentModel,
@@ -145,17 +121,25 @@ private FrameworkFieldInitializer(
     this.graph = checkNotNull(graph);
     this.optionalFactories = checkNotNull(optionalFactories);
     this.isProducerFromProvider = isProducerFromProvider;
-    this.fieldSpec = checkNotNull(fieldSpec);
   }
 
-  /** Adds the field and its initialization code to the component. */
-  void initializeField() {
+  /**
+   * Returns the {@link MemberSelect} for the framework field, and adds the field and its
+   * initialization code to the component if it's needed and not already added.
+   */
+  MemberSelect getOrCreateMemberSelect() {
+    initializeField();
+    return MemberSelect.localField(generatedComponentModel.name(), checkNotNull(fieldSpec).name);
+  }
+
+  private void initializeField() {
     switch (fieldInitializationState) {
       case UNINITIALIZED:
         // Change our state in case we are recursively invoked via initializeBindingExpression
         fieldInitializationState = InitializationState.INITIALIZING;
         CodeBlock.Builder codeBuilder = CodeBlock.builder();
-        CodeBlock initCode = CodeBlock.of("this.$N = $L;", fieldSpec, getFieldInitialization());
+        CodeBlock fieldInitialization = getFieldInitialization();
+        CodeBlock initCode = CodeBlock.of("this.$N = $L;", getOrCreateField(), fieldInitialization);
 
         if (fieldInitializationState == InitializationState.DELEGATED) {
           // If we were recursively invoked, set the delegate factory as part of our initialization
@@ -169,7 +153,6 @@ void initializeField() {
           codeBuilder.add(initCode);
         }
         generatedComponentModel.addInitialization(codeBuilder.build());
-        generatedComponentModel.addField(FRAMEWORK_FIELD, fieldSpec);
 
         fieldInitializationState = InitializationState.INITIALIZED;
         break;
@@ -177,7 +160,7 @@ void initializeField() {
       case INITIALIZING:
         // We were recursively invoked, so create a delegate factory instead
         generatedComponentModel.addInitialization(
-            CodeBlock.of("this.$N = new $T<>();", fieldSpec, DelegateFactory.class));
+            CodeBlock.of("this.$N = new $T<>();", getOrCreateField(), DelegateFactory.class));
         fieldInitializationState = InitializationState.DELEGATED;
         break;
 
@@ -190,6 +173,36 @@ void initializeField() {
     }
   }
 
+  /**
+   * Adds a field representing the resolved bindings, optionally forcing it to use a particular
+   * binding type (instead of the type the resolved bindings would typically use).
+   */
+  private FieldSpec getOrCreateField() {
+    if (fieldSpec != null) {
+      return fieldSpec;
+    }
+    boolean useRawType =
+        !isTypeAccessibleFrom(
+            resolvedBindings.key().type(), generatedComponentModel.name().packageName());
+
+    Optional<ClassName> alternativeFrameworkClass =
+        isProducerFromProvider ? Optional.of(TypeNames.PRODUCER) : Optional.empty();
+    FrameworkField contributionBindingField =
+        FrameworkField.forResolvedBindings(resolvedBindings, alternativeFrameworkClass);
+    FieldSpec.Builder contributionField =
+        FieldSpec.builder(
+            useRawType ? contributionBindingField.type().rawType : contributionBindingField.type(),
+            generatedComponentModel.getUniqueFieldName(contributionBindingField.name()));
+    contributionField.addModifiers(PRIVATE);
+    if (useRawType) {
+      contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
+    }
+    fieldSpec = contributionField.build();
+    generatedComponentModel.addField(FRAMEWORK_FIELD, fieldSpec);
+
+    return fieldSpec;
+  }
+
   /** Returns the expression to use to initialize the field. */
   private CodeBlock getFieldInitialization() {
     if (isProducerFromProvider) {
@@ -713,21 +726,6 @@ private CodeBlock getDependencyExpression(FrameworkDependency frameworkDependenc
         .codeBlock();
   }
 
-  FrameworkFieldInitializer forProducerFromProvider() {
-    return new FrameworkFieldInitializer(
-        fieldSpec,
-        resolvedBindings,
-        subcomponentNames,
-        generatedComponentModel,
-        componentBindingExpressions,
-        componentRequirementFields,
-        referenceReleasingManagerFields,
-        compilerOptions,
-        graph,
-        true,
-        optionalFactories);
-  }
-
   /** Initialization state for a factory field. */
   private enum InitializationState {
     /** The field is {@code null}. */
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 0af99148b..367ff063c 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -16,9 +16,11 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
 
+import com.google.common.base.Supplier;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
@@ -29,55 +31,69 @@
 
 /** A binding expression that uses an instance of a {@link FrameworkType}. */
 final class FrameworkInstanceBindingExpression extends BindingExpression {
-  private final MemberSelect memberSelect;
+  private final Supplier<MemberSelect> frameworkFieldSupplier;
   private final FrameworkType frameworkType;
-  private final Optional<FrameworkFieldInitializer> fieldInitializer;
   private final DaggerTypes types;
   private final Elements elements;
 
   /** Returns a binding expression for a binding. */
   static FrameworkInstanceBindingExpression create(
       ResolvedBindings resolvedBindings,
-      MemberSelect memberSelect,
-      Optional<FrameworkFieldInitializer> frameworkFieldInitializer,
+      BindingGraph graph,
+      SubcomponentNames subcomponentNames,
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions,
+      ComponentRequirementFields componentRequirementFields,
+      ReferenceReleasingManagerFields referenceReleasingManagerFields,
+      boolean isProducerFromProvider,
+      OptionalFactories optionalFactories,
+      CompilerOptions compilerOptions,
       DaggerTypes types,
       Elements elements) {
+    FrameworkType frameworkType = resolvedBindings.bindingType().frameworkType();
+    checkArgument(!isProducerFromProvider || frameworkType.equals(FrameworkType.PROVIDER));
+
+    Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
+    Supplier<MemberSelect> frameworkFieldSupplier;
+    if (!isProducerFromProvider && staticMemberSelect.isPresent()) {
+      frameworkFieldSupplier = staticMemberSelect::get;
+    } else {
+      FrameworkFieldInitializer fieldInitializer =
+          new FrameworkFieldInitializer(
+              resolvedBindings,
+              subcomponentNames,
+              generatedComponentModel,
+              componentBindingExpressions,
+              componentRequirementFields,
+              referenceReleasingManagerFields,
+              compilerOptions,
+              graph,
+              isProducerFromProvider,
+              optionalFactories);
+      frameworkFieldSupplier = fieldInitializer::getOrCreateMemberSelect;
+    }
+
     return new FrameworkInstanceBindingExpression(
         resolvedBindings,
-        memberSelect,
-        resolvedBindings.bindingType().frameworkType(),
-        frameworkFieldInitializer,
+        isProducerFromProvider ? FrameworkType.PRODUCER : frameworkType,
+        frameworkFieldSupplier,
         types,
         elements);
   }
 
   private FrameworkInstanceBindingExpression(
       ResolvedBindings resolvedBindings,
-      MemberSelect memberSelect,
       FrameworkType frameworkType,
-      Optional<FrameworkFieldInitializer> fieldInitializer,
+      Supplier<MemberSelect> frameworkFieldSupplier,
       DaggerTypes types,
       Elements elements) {
     super(resolvedBindings);
-    this.memberSelect = memberSelect;
     this.frameworkType = frameworkType;
-    this.fieldInitializer = fieldInitializer;
+    this.frameworkFieldSupplier = frameworkFieldSupplier;
     this.types = types;
     this.elements = elements;
   }
 
-  FrameworkInstanceBindingExpression producerFromProvider(
-      MemberSelect memberSelect, FrameworkFieldInitializer producerFieldInitializer) {
-    checkState(frameworkType.equals(FrameworkType.PROVIDER));
-    return new FrameworkInstanceBindingExpression(
-        resolvedBindings(),
-        memberSelect,
-        FrameworkType.PRODUCER,
-        Optional.of(producerFieldInitializer),
-        types,
-        elements);
-  }
-
   /**
    * The expression for the framework instance for this binding. If the instance comes from a
    * component field, it will be {@link GeneratedComponentModel#addInitialization(CodeBlock)
@@ -87,10 +103,11 @@ FrameworkInstanceBindingExpression producerFromProvider(
   @Override
   Expression getDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
-    fieldInitializer.ifPresent(FrameworkFieldInitializer::initializeField);
+    MemberSelect memberSelect = frameworkFieldSupplier.get();
+
     TypeMirror expressionType =
         isTypeAccessibleFrom(instanceType(), requestingClass.packageName())
-                || isInlinedFactoryCreation()
+                || isInlinedFactoryCreation(memberSelect)
             ? types.wrapType(instanceType(), resolvedBindings().frameworkClass())
             : rawFrameworkType();
 
@@ -124,7 +141,7 @@ private TypeMirror instanceType() {
    * will still be able to determine the type that is returned from the {@code Foo_Factory.create()}
    * method.
    */
-  private boolean isInlinedFactoryCreation() {
+  private static boolean isInlinedFactoryCreation(MemberSelect memberSelect) {
     return memberSelect.staticMember();
   }
 
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 66ee29799..b0c27c03a 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -138,6 +138,7 @@ void addSupertype(TypeElement supertype) {
     TypeSpecs.addSupertype(component, supertype);
   }
 
+  // TODO(dpb): Consider taking FieldSpec, and returning identical FieldSpec with unique name?
   /** Adds the given field to the component. */
   void addField(FieldSpecKind fieldKind, FieldSpec fieldSpec) {
     fieldSpecsMap.put(fieldKind, fieldSpec);
@@ -148,6 +149,7 @@ void addFields(FieldSpecKind fieldKind, Iterable<FieldSpec> fieldSpecs) {
     fieldSpecsMap.putAll(fieldKind, fieldSpecs);
   }
 
+  // TODO(dpb): Consider taking MethodSpec, and returning identical MethodSpec with unique name?
   /** Adds the given method to the component. */
   void addMethod(MethodSpecKind methodKind, MethodSpec methodSpec) {
     methodSpecsMap.put(methodKind, methodSpec);
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 219dea264..be773d28d 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -407,10 +407,8 @@ public void simpleComponent() {
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestClass_SimpleComponent",
                 "    implements TestClass.SimpleComponent {",
-                // TODO(user): Fix the order of the fields. This happens because the field name
-                // is created before the field is written in ComponentBindingExpression.
-                "  private Provider<Executor> executorProvider2;",
                 "  private Provider<Executor> executorProvider;",
+                "  private Provider<Executor> executorProvider2;",
                 "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
                 "  private Provider<ProductionComponentMonitor> monitorProvider;",
                 "  private Provider<TestClass.B> bProvider;",
@@ -431,12 +429,12 @@ public void simpleComponent() {
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
                 "  private void initialize(final Builder builder) {",
-                "    this.executorProvider2 =",
-                "        TestClass_BModule_ExecutorFactory.create(builder.bModule);",
                 "    this.executorProvider =",
+                "        TestClass_BModule_ExecutorFactory.create(builder.bModule);",
+                "    this.executorProvider2 =",
                 "        DoubleCheck.provider(",
                 "            TestClass_SimpleComponent_ProductionExecutorModule_ExecutorFactory",
-                "                .create(executorProvider2));",
+                "                .create(executorProvider));",
                 "    this.simpleComponentProvider = ",
                 "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
                 "    this.monitorProvider =",
@@ -449,7 +447,7 @@ public void simpleComponent() {
                 "    this.bProducer = Producers.producerFromProvider(bProvider);",
                 "    this.aProducer = new TestClass_AModule_AFactory(",
                 "        builder.aModule,",
-                "        executorProvider,",
+                "        executorProvider2,",
                 "        monitorProvider,",
                 "        bProducer);",
                 "  }",
