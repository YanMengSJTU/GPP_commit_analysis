diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 67ddf8f4f..b8ae53abf 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -26,12 +26,9 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
-import static dagger.internal.codegen.BindingExpression.InitializationState.DELEGATED;
-import static dagger.internal.codegen.BindingExpression.InitializationState.INITIALIZED;
-import static dagger.internal.codegen.BindingExpression.InitializationState.UNINITIALIZED;
 import static dagger.internal.codegen.BindingKey.contribution;
+import static dagger.internal.codegen.BindingType.PRODUCTION;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
@@ -45,7 +42,6 @@
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
 import static dagger.internal.codegen.SourceFiles.simpleVariableName;
-import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
 import static dagger.internal.codegen.TypeNames.LISTENABLE_FUTURE;
@@ -66,7 +62,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
@@ -90,9 +85,9 @@
 import dagger.releasablereferences.ForReleasableReferences;
 import dagger.releasablereferences.ReleasableReferenceManager;
 import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.EnumSet;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -123,8 +118,13 @@
   protected final ImmutableMap<ComponentDescriptor, String> subcomponentNames;
   protected final TypeSpec.Builder component;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
+  // TODO(user): Merge these two maps if we refactor BindingKey to allow us to unify
+  // these two key spaces
   private final Map<BindingKey, BindingExpression> bindingExpressions = new LinkedHashMap<>();
-  private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
+  private final Map<BindingKey, BindingExpression> producerFromProviderBindingExpressions =
+      new LinkedHashMap<>();
+  private final List<CodeBlock> initializations = new ArrayList<>();
+  protected final List<MethodSpec> interfaceMethods = new ArrayList<>();
   private final BindingExpression.Factory bindingExpressionFactory;
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   private final OptionalFactories optionalFactories;
@@ -174,6 +174,7 @@
         new BindingExpression.Factory(
             compilerOptions,
             name,
+            componentFieldNames,
             this,
             childComponentNames(keyFactory, subcomponentNames),
             graph,
@@ -265,6 +266,18 @@ public BindingExpression getBindingExpression(BindingKey key) {
     return bindingExpressions.get(key);
   }
 
+  /** Adds the given code block to the initialize methods of the component. */
+  @Override
+  public void addInitialization(CodeBlock codeBlock) {
+    initializations.add(codeBlock);
+  }
+
+  /** Adds the given field to the component. */
+  @Override
+  public void addField(FieldSpec fieldSpec) {
+    component.addField(fieldSpec);
+  }
+
   /**
    * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
    * object for a scope.
@@ -287,10 +300,9 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
     addFactoryMethods();
     addReferenceReleasingProviderManagerFields();
     createBindingExpressions();
-    initializeFrameworkFields();
-    writeFieldsAndInitializeMethods();
     implementInterfaceMethods();
     addSubcomponents();
+    writeInitializeAndInterfaceMethods();
     component.addMethod(constructor.build());
     if (graph.componentDescriptor().kind().isTopLevel()) {
       optionalFactories.addMembers(component);
@@ -431,37 +443,7 @@ private void createBindingExpression(ResolvedBindings resolvedBindings) {
 
     // TODO(gak): get rid of the field for unscoped delegated bindings
     bindingExpressions.put(
-        resolvedBindings.bindingKey(),
-        bindingExpressionFactory.forField(
-            resolvedBindings, generateFrameworkField(resolvedBindings, Optional.empty())));
-  }
-
-  /**
-   * Adds a field representing the resolved bindings, optionally forcing it to use a particular
-   * framework class (instead of the class the resolved bindings would typically use).
-   */
-  private FieldSpec generateFrameworkField(
-      ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
-    boolean useRawType = useRawType(resolvedBindings);
-
-    FrameworkField contributionBindingField =
-        FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);
-    FieldSpec.Builder contributionField =
-        componentField(
-            useRawType
-                ? contributionBindingField.type().rawType
-                : contributionBindingField.type(),
-            contributionBindingField.name());
-    contributionField.addModifiers(PRIVATE);
-    if (useRawType) {
-      contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
-    }
-
-    return contributionField.build();
-  }
-
-  private boolean useRawType(ResolvedBindings resolvedBindings) {
-    return useRawType(resolvedBindings.bindingPackage());
+        resolvedBindings.bindingKey(), bindingExpressionFactory.forField(resolvedBindings));
   }
 
   private boolean useRawType(Binding binding) {
@@ -473,7 +455,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
   }
 
   private void implementInterfaceMethods() {
-    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
+    Set<MethodSignature> interfaceMethodSignatures = Sets.newHashSet();
     for (ComponentMethodDescriptor componentMethod :
         graph.componentDescriptor().componentMethods()) {
       if (componentMethod.dependencyRequest().isPresent()) {
@@ -487,8 +469,8 @@ private void implementInterfaceMethods() {
         MethodSignature signature =
             MethodSignature.fromExecutableType(
                 methodElement.getSimpleName().toString(), requestType);
-        if (!interfaceMethods.contains(signature)) {
-          interfaceMethods.add(signature);
+        if (!interfaceMethodSignatures.contains(signature)) {
+          interfaceMethodSignatures.add(signature);
           MethodSpec.Builder interfaceMethod =
               methodSpecForComponentMethod(methodElement, requestType);
           CodeBlock codeBlock = getRequestFulfillment(interfaceRequest);
@@ -503,7 +485,7 @@ private void implementInterfaceMethods() {
           } else {
             interfaceMethod.addStatement("return $L", codeBlock);
           }
-          component.addMethod(interfaceMethod.build());
+          interfaceMethods.add(interfaceMethod.build());
         }
       }
     }
@@ -556,22 +538,9 @@ private void addSubcomponents() {
 
   private static final int INITIALIZATIONS_PER_INITIALIZE_METHOD = 100;
 
-  private void initializeFrameworkFields() {
-    bindingExpressions.values().forEach(this::initializeFrameworkType);
-  }
-
-  private void writeFieldsAndInitializeMethods() {
-    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    for (BindingExpression bindingExpression : bindingExpressions.values()) {
-      bindingExpression.initializeField(
-          (field, initialization) -> {
-            component.addField(field);
-            codeBlocks.add(initialization);
-          });
-    }
-
+  private void writeInitializeAndInterfaceMethods() {
     List<List<CodeBlock>> partitions =
-        Lists.partition(codeBlocks.build(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
+        Lists.partition(initializations, INITIALIZATIONS_PER_INITIALIZE_METHOD);
 
     UniqueNameSet methodNames = new UniqueNameSet();
     for (List<CodeBlock> partition : partitions) {
@@ -593,13 +562,20 @@ private void writeFieldsAndInitializeMethods() {
       }
       component.addMethod(initializeMethod.build());
     }
+
+    component.addMethods(interfaceMethods);
   }
 
-  /** Adds code to the given binding expression to initialize it, if necessary. */
-  private void initializeFrameworkType(BindingExpression bindingExpression) {
+  // TODO(user): Instead of this method knowing about all BindingExpression types, move this
+  // onto a method on different BindingExpression subtypes.
+  @Override
+  public CodeBlock getFieldInitialization(BindingExpression bindingExpression) {
     // If there is no field, don't initialize it.
-    if (!bindingExpression.hasFieldSpec()) {
-      return;
+    checkState(bindingExpression.hasFieldSpec());
+
+    if (bindingExpression.isProducerFromProvider()) {
+      return getRequestFulfillment(
+          FrameworkDependency.create(bindingExpression.bindingKey(), PRODUCTION));
     }
 
     // We don't have to check whether we own the field because this method is called only for
@@ -608,23 +584,17 @@ private void initializeFrameworkType(BindingExpression bindingExpression) {
 
     switch (bindingExpression.bindingKey().kind()) {
       case CONTRIBUTION:
-        initializeContributionBinding(bindingExpression);
-        break;
-
+        return contributionBindingInitialization(bindingExpression);
       case MEMBERS_INJECTION:
-        initializeMembersInjectionBinding(bindingExpression);
-        break;
-
+        return membersInjectionBindingInitialization(bindingExpression);
       default:
         throw new AssertionError();
     }
   }
 
-  private void initializeContributionBinding(BindingExpression bindingExpression) {
+  private CodeBlock contributionBindingInitialization(BindingExpression bindingExpression) {
     ContributionBinding binding =
         graph.resolvedBindings().get(bindingExpression.bindingKey()).contributionBinding();
-    /* We have some duplication in the branches below b/c initializeDeferredDependencies must be
-     * called before we get the code block that initializes the member. */
     switch (binding.factoryCreationStrategy()) {
       case DELEGATE:
         CodeBlock delegatingCodeBlock =
@@ -632,96 +602,34 @@ private void initializeContributionBinding(BindingExpression bindingExpression)
                 "($T) $L",
                 binding.bindingType().frameworkClass(),
                 getRequestFulfillment(getOnlyElement(binding.frameworkDependencies())));
-        bindingExpression.setInitializationCode(
-            initializeDeferredDependencies(binding),
-            initializeMember(
-                bindingExpression, decorateForScope(delegatingCodeBlock, binding.scope())));
-        break;
+        return decorateForScope(delegatingCodeBlock, binding.scope());
       case SINGLETON_INSTANCE:
-        if (!binding.scope().isPresent()) {
-          break;
-        }
+        checkState(binding.scope().isPresent());
         // fall through
       case CLASS_CONSTRUCTOR:
-        bindingExpression.setInitializationCode(
-            initializeDeferredDependencies(binding),
-            initializeMember(bindingExpression, initializeFactoryForContributionBinding(binding)));
-        break;
+        return factoryForContributionBindingInitialization(binding);
+
       default:
         throw new AssertionError();
     }
   }
 
-  private void initializeMembersInjectionBinding(BindingExpression bindingExpression) {
+  private CodeBlock membersInjectionBindingInitialization(BindingExpression bindingExpression) {
     BindingKey bindingKey = bindingExpression.bindingKey();
     MembersInjectionBinding binding =
         graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();
-
-    if (binding.injectionSites().isEmpty()) {
-      return;
-    }
-
-    bindingExpression.setInitializationCode(
-        initializeDeferredDependencies(binding),
-        initializeMember(bindingExpression, initializeMembersInjectorForBinding(binding)));
+    checkState(!binding.injectionSites().isEmpty());
+    return membersInjectorForBindingInitialization(binding);
   }
 
-  /**
-   * Initializes any dependencies of the given binding that need to be instantiated, i.e., as we get
-   * to them during normal initialization.
-   */
-  private CodeBlock initializeDeferredDependencies(Binding binding) {
-    return CodeBlocks.concat(
-        ImmutableList.of(
-            initializeDelegateFactoriesForUninitializedDependencies(binding),
-            initializeProducersFromProviderDependencies(binding)));
-  }
-
-  /**
-   * Initializes delegate factories for any dependencies of {@code binding} that are uninitialized
-   * because of a dependency cycle.
-   */
-  private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {
-    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
-
-    for (BindingKey dependencyKey :
-        FluentIterable.from(binding.dependencies())
-            .transform(DependencyRequest::bindingKey)
-            .toSet()) {
-      BindingExpression dependencyExpression = getBindingExpression(dependencyKey);
-      if (dependencyExpression.hasFieldSpec()
-          && dependencyExpression.fieldInitializationState().equals(UNINITIALIZED)) {
-        initializations.add(
-            CodeBlock.of(
-                "this.$L = new $T();", dependencyExpression.fieldName(), DELEGATE_FACTORY));
-        dependencyExpression.setFieldInitializationState(DELEGATED);
-      }
-    }
-
-    return CodeBlocks.concat(initializations.build());
-  }
-
-  private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {
-    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
-    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
-      if (isProducerFromProvider(frameworkDependency)) {
-        BindingKey dependencyKey = frameworkDependency.bindingKey();
-        if (producerFromProviderMemberSelects.containsKey(dependencyKey)) {
-          continue;
-        }
-        ResolvedBindings resolvedBindings = graph.resolvedBindings().get(dependencyKey);
-        FieldSpec frameworkField = generateFrameworkField(resolvedBindings, Optional.of(PRODUCER));
-        component.addField(frameworkField);
-        MemberSelect memberSelect = localField(name, frameworkField.name);
-        producerFromProviderMemberSelects.put(dependencyKey, memberSelect);
-        initializations.add(
-            CodeBlock.of(
-                "this.$L = $L;",
-                memberSelect.getExpressionFor(name),
-                getRequestFulfillment(frameworkDependency)));
-      }
-    }
-    return CodeBlocks.concat(initializations.build());
+  private BindingExpression getProducerFromProviderBindingExpression(
+      FrameworkDependency frameworkDependency) {
+    checkState(isProducerFromProvider(frameworkDependency));
+    return producerFromProviderBindingExpressions.computeIfAbsent(
+        frameworkDependency.bindingKey(),
+        dependencyKey ->
+            bindingExpressionFactory.forProducerFromProviderField(
+                graph.resolvedBindings().get(dependencyKey)));
   }
 
   private boolean isProducerFromProvider(FrameworkDependency frameworkDependency) {
@@ -731,32 +639,7 @@ private boolean isProducerFromProvider(FrameworkDependency frameworkDependency)
         && frameworkDependency.frameworkClass().equals(Producer.class);
   }
 
-  private CodeBlock initializeMember(
-      BindingExpression bindingExpression, CodeBlock initializationCodeBlock) {
-    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
-    String fieldName = bindingExpression.fieldName();
-    CodeBlock delegateFactoryVariable = delegateFactoryVariableName(bindingExpression);
-
-    if (bindingExpression.fieldInitializationState().equals(DELEGATED)) {
-      initializations.add(
-          CodeBlock.of(
-              "$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, fieldName));
-    }
-    initializations.add(CodeBlock.of("this.$L = $L;", fieldName, initializationCodeBlock));
-    if (bindingExpression.fieldInitializationState().equals(DELEGATED)) {
-      initializations.add(
-          CodeBlock.of("$L.setDelegatedProvider($L);", delegateFactoryVariable, fieldName));
-    }
-    bindingExpression.setFieldInitializationState(INITIALIZED);
-
-    return CodeBlocks.concat(initializations.build());
-  }
-
-  private CodeBlock delegateFactoryVariableName(BindingExpression bindingExpression) {
-    return CodeBlock.of("$LDelegate", bindingExpression.fieldName().replace('.', '_'));
-  }
-
-  private CodeBlock initializeFactoryForContributionBinding(ContributionBinding binding) {
+  private CodeBlock factoryForContributionBindingInitialization(ContributionBinding binding) {
     TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
     switch (binding.bindingKind()) {
       case COMPONENT:
@@ -925,19 +808,19 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
             getRequestFulfillment(frameworkDependency));
 
       case SYNTHETIC_MULTIBOUND_SET:
-        return initializeFactoryForSetMultibinding(binding);
+        return factoryForSetMultibindingInitialization(binding);
 
       case SYNTHETIC_MULTIBOUND_MAP:
-        return initializeFactoryForMapMultibinding(binding);
+        return factoryForMapMultibindingInitialization(binding);
 
       case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
-        return initializeFactoryForSyntheticReleasableReferenceManagerBinding(binding);
+        return factoryForSyntheticReleasableReferenceManagerBindingInitialization(binding);
 
       case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
-        return initializeFactoryForSyntheticSetOfReleasableReferenceManagers(binding);
+        return factoryForSyntheticSetOfReleasableReferenceManagersInitialization(binding);
 
       case SYNTHETIC_OPTIONAL_BINDING:
-        return initializeFactoryForSyntheticOptionalBinding(binding);
+        return factoryForSyntheticOptionalBindingInitialization(binding);
 
       default:
         throw new AssertionError(binding);
@@ -967,7 +850,7 @@ private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> mayb
     }
   }
 
-  private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
+  private CodeBlock membersInjectorForBindingInitialization(MembersInjectionBinding binding) {
     return binding.injectionSites().isEmpty()
         ? CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS)
         : CodeBlock.of(
@@ -986,13 +869,13 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
 
   /** Returns the expression to use as an argument for a dependency. */
   private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency) {
-    BindingKey requestedKey = frameworkDependency.bindingKey();
     return isProducerFromProvider(frameworkDependency)
-        ? producerFromProviderMemberSelects.get(requestedKey).getExpressionFor(name)
+        ? getProducerFromProviderBindingExpression(frameworkDependency)
+            .getSnippetForFrameworkDependency(frameworkDependency, name)
         : getRequestFulfillment(frameworkDependency);
   }
 
-  private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding binding) {
+  private CodeBlock factoryForSetMultibindingInitialization(ContributionBinding binding) {
     CodeBlock.Builder builder = CodeBlock.builder().add("$T.", setFactoryClassName(binding));
     boolean useRawTypes = useRawType(binding);
     if (!useRawTypes) {
@@ -1037,7 +920,7 @@ private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding bindin
     return builder.add(".build()").build();
   }
 
-  private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding binding) {
+  private CodeBlock factoryForMapMultibindingInitialization(ContributionBinding binding) {
     ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
 
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
@@ -1084,7 +967,7 @@ private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, Code
    * <p>The {@code get()} method just returns the component field with the {@link
    * dagger.internal.ReferenceReleasingProviderManager} object.
    */
-  private CodeBlock initializeFactoryForSyntheticReleasableReferenceManagerBinding(
+  private CodeBlock factoryForSyntheticReleasableReferenceManagerBindingInitialization(
       ContributionBinding binding) {
     // The scope is the value of the @ForReleasableReferences annotation.
     Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
@@ -1127,7 +1010,7 @@ private CodeBlock initializeFactoryForSyntheticReleasableReferenceManagerBinding
    * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
    * include managers for all reference-releasing scopes whose metadata type is {@code M}.
    */
-  private CodeBlock initializeFactoryForSyntheticSetOfReleasableReferenceManagers(
+  private CodeBlock factoryForSyntheticSetOfReleasableReferenceManagersInitialization(
       ContributionBinding binding) {
     Key key = binding.key();
     SetType keyType = SetType.from(key);
@@ -1197,7 +1080,7 @@ private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation
    * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
    * binding.
    */
-  private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBinding binding) {
+  private CodeBlock factoryForSyntheticOptionalBindingInitialization(ContributionBinding binding) {
     if (binding.explicitDependencies().isEmpty()) {
       verify(
           binding.bindingType().equals(BindingType.PROVISION),
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 6dffed953..59a2bd176 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -18,42 +18,52 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
+import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
+import static dagger.internal.codegen.TypeNames.PRODUCER;
+import static javax.lang.model.element.Modifier.PRIVATE;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import dagger.internal.DelegateFactory;
 import java.util.Optional;
-import java.util.function.BiConsumer;
 import javax.lang.model.util.Elements;
 
 /** The code expressions to declare, initialize, and/or access a binding in a component. */
 final class BindingExpression extends RequestFulfillment {
   private final Optional<FieldSpec> fieldSpec;
   private final RequestFulfillment requestFulfillmentDelegate;
-  private CodeBlock initializeDeferredBindingFields;
-  private CodeBlock initializeField;
+  private final HasBindingExpressions hasBindingExpressions;
+  private final boolean isProducerFromProvider;
   private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
   private BindingExpression(
-      RequestFulfillment requestFulfillmentDelegate, Optional<FieldSpec> fieldSpec) {
+      RequestFulfillment requestFulfillmentDelegate,
+      Optional<FieldSpec> fieldSpec,
+      HasBindingExpressions hasBindingExpressions,
+      boolean isProducerFromProvider) {
     super(requestFulfillmentDelegate.bindingKey());
     this.requestFulfillmentDelegate = requestFulfillmentDelegate;
     this.fieldSpec = fieldSpec;
+    this.hasBindingExpressions = hasBindingExpressions;
+    this.isProducerFromProvider = isProducerFromProvider;
   }
 
   @Override
   CodeBlock getSnippetForDependencyRequest(DependencyRequest request, ClassName requestingClass) {
+    // TODO(user): We don't always have to initialize ourselves depending on the request and
+    // inlining.
+    maybeInitializeField();
     return requestFulfillmentDelegate.getSnippetForDependencyRequest(request, requestingClass);
   }
 
   @Override
   CodeBlock getSnippetForFrameworkDependency(
       FrameworkDependency frameworkDependency, ClassName requestingClass) {
+    maybeInitializeField();
     return requestFulfillmentDelegate.getSnippetForFrameworkDependency(
         frameworkDependency, requestingClass);
   }
@@ -68,41 +78,15 @@ boolean hasFieldSpec() {
    *
    * @throws UnsupportedOperationException if {@link #hasFieldSpec()} is {@code false}
    */
-  String fieldName() {
+  private String fieldName() {
     checkHasField();
     return fieldSpec.get().name;
   }
 
-  /**
-   * Sets the code for initializing the binding's underlying field.
-   *
-   * @throws UnsupportedOperationException if {@link #hasFieldSpec()} is {@code false}
-   */
-  void setInitializationCode(CodeBlock initializeDeferredBindingFields, CodeBlock initializeField) {
-    checkHasField();
-    this.initializeDeferredBindingFields = checkNotNull(initializeDeferredBindingFields);
-    this.initializeField = checkNotNull(initializeField);
-  }
-
-  /**
-   * Returns the initialization code for the binding's underlying field.
-   *
-   * @throws UnsupportedOperationException if {@link #hasFieldSpec()} is {@code false}
-   */
-  private CodeBlock getInitializationCode() {
-    checkHasField();
-    checkState(initializeDeferredBindingFields != null && initializeField != null);
-    return CodeBlocks.concat(ImmutableList.of(initializeDeferredBindingFields, initializeField));
-  }
-
-  /**
-   * Returns the initialization state for the binding's underlying field.
-   *
-   * @throws UnsupportedOperationException if {@link #hasFieldSpec()} is {@code false}
-   */
-  InitializationState fieldInitializationState() {
-    checkHasField();
-    return fieldInitializationState;
+  /** Returns true if this binding expression represents a producer from provider. */
+  // TODO(user): remove this and represent this via a subtype of BindingExpression
+  boolean isProducerFromProvider() {
+    return isProducerFromProvider;
   }
 
   /**
@@ -110,22 +94,63 @@ InitializationState fieldInitializationState() {
    *
    * @throws UnsupportedOperationException if {@link #hasFieldSpec()} is {@code false}
    */
-  void setFieldInitializationState(InitializationState fieldInitializationState) {
+  private void setFieldInitializationState(InitializationState fieldInitializationState) {
     checkHasField();
     checkArgument(this.fieldInitializationState.compareTo(fieldInitializationState) < 0);
     this.fieldInitializationState = fieldInitializationState;
   }
 
-  /** Calls the consumer to initialize the binding's underlying field if it has one. */
-  void initializeField(BiConsumer<FieldSpec, CodeBlock> initializationConsumer) {
-    if (hasFieldSpec()) {
-      initializationConsumer.accept(fieldSpec.get(), getInitializationCode());
+  private void checkHasField() {
+    if (!hasFieldSpec()) {
+      throw new UnsupportedOperationException();
     }
   }
 
-  private void checkHasField() {
+  // Adds our field and initialization of our field to the component.
+  private void maybeInitializeField() {
     if (!hasFieldSpec()) {
-      throw new UnsupportedOperationException();
+      return;
+    }
+    switch (fieldInitializationState) {
+      case UNINITIALIZED:
+        // Change our state in case we are recursively invoked via initializeBindingExpression
+        setFieldInitializationState(InitializationState.INITIALIZING);
+        CodeBlock.Builder codeBuilder = CodeBlock.builder();
+        CodeBlock initCode =
+            CodeBlock.of(
+                "this.$L = $L;",
+                fieldName(),
+                checkNotNull(hasBindingExpressions.getFieldInitialization(this)));
+
+        if (fieldInitializationState == InitializationState.DELEGATED) {
+          // If we were recursively invoked, set the delegate factory as part of our initialization
+          String delegateFactoryVariable = fieldName() + "Delegate";
+          codeBuilder
+              .add("$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, fieldName())
+              .add(initCode)
+              .add("$L.setDelegatedProvider($L);", delegateFactoryVariable, fieldName())
+              .build();
+        } else {
+          codeBuilder.add(initCode);
+        }
+        hasBindingExpressions.addInitialization(codeBuilder.build());
+        hasBindingExpressions.addField(fieldSpec.get());
+
+        setFieldInitializationState(InitializationState.INITIALIZED);
+        break;
+
+      case INITIALIZING:
+        // We were recursively invoked, so create a delegate factory instead
+        hasBindingExpressions.addInitialization(
+            CodeBlock.of("this.$L = new $T();", fieldName(), DELEGATE_FACTORY));
+        setFieldInitializationState(InitializationState.DELEGATED);
+        break;
+
+      case DELEGATED:
+      case INITIALIZED:
+        break;
+      default:
+        throw new AssertionError("Unhandled initialization state: " + fieldInitializationState);
     }
   }
 
@@ -134,7 +159,16 @@ private void checkHasField() {
     /** The field is {@code null}. */
     UNINITIALIZED,
 
-    /** The field is set to a {@link DelegateFactory}. */
+    /**
+     * The field's dependencies are being set up. If the field is needed in this state, use a {@link
+     * DelegateFactory}.
+     */
+    INITIALIZING,
+
+    /**
+     * The field's dependencies are being set up, but the field can be used because it has already
+     * been set to a {@link DelegateFactory}.
+     */
     DELEGATED,
 
     /** The field is set to an undelegated factory. */
@@ -145,6 +179,7 @@ private void checkHasField() {
   static final class Factory {
     private final CompilerOptions compilerOptions;
     private final ClassName componentName;
+    private final UniqueNameSet componentFieldNames;
     private final HasBindingExpressions hasBindingExpressions;
     private final ImmutableMap<BindingKey, String> subcomponentNames;
     private final BindingGraph graph;
@@ -153,12 +188,14 @@ private void checkHasField() {
     Factory(
         CompilerOptions compilerOptions,
         ClassName componentName,
+        UniqueNameSet componentFieldNames,
         HasBindingExpressions hasBindingExpressions,
         ImmutableMap<BindingKey, String> subcomponentNames,
         BindingGraph graph,
         Elements elements) {
       this.compilerOptions = checkNotNull(compilerOptions);
       this.componentName = checkNotNull(componentName);
+      this.componentFieldNames = checkNotNull(componentFieldNames);
       this.hasBindingExpressions = checkNotNull(hasBindingExpressions);
       this.subcomponentNames = checkNotNull(subcomponentNames);
       this.graph = checkNotNull(graph);
@@ -166,11 +203,24 @@ private void checkHasField() {
     }
 
     /** Creates a binding expression for a field. */
-    BindingExpression forField(ResolvedBindings resolvedBindings, FieldSpec fieldSpec) {
+    BindingExpression forField(ResolvedBindings resolvedBindings) {
+      FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.empty());
       MemberSelect memberSelect = MemberSelect.localField(componentName, fieldSpec.name);
       return new BindingExpression(
           createRequestFulfillment(resolvedBindings, memberSelect),
-          Optional.of(fieldSpec));
+          Optional.of(fieldSpec),
+          hasBindingExpressions,
+          false);
+    }
+
+    BindingExpression forProducerFromProviderField(ResolvedBindings resolvedBindings) {
+      FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.of(PRODUCER));
+      MemberSelect memberSelect = MemberSelect.localField(componentName, fieldSpec.name);
+      return new BindingExpression(
+          new ProducerFieldRequestFulfillment(resolvedBindings.bindingKey(), memberSelect),
+          Optional.of(fieldSpec),
+          hasBindingExpressions,
+          true);
     }
 
     /** Creates a binding expression for a static method call. */
@@ -180,7 +230,39 @@ BindingExpression forField(ResolvedBindings resolvedBindings, FieldSpec fieldSpe
           value ->
               new BindingExpression(
                   createRequestFulfillment(resolvedBindings, value),
-                  Optional.empty()));
+                  Optional.empty(),
+                  hasBindingExpressions,
+                  false));
+    }
+
+    /**
+     * Adds a field representing the resolved bindings, optionally forcing it to use a particular
+     * binding type (instead of the type the resolved bindings would typically use).
+     */
+    private FieldSpec generateFrameworkField(
+        ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
+      boolean useRawType = useRawType(resolvedBindings);
+
+      FrameworkField contributionBindingField =
+          FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);
+      FieldSpec.Builder contributionField =
+          FieldSpec.builder(
+              useRawType
+                  ? contributionBindingField.type().rawType
+                  : contributionBindingField.type(),
+              componentFieldNames.getUniqueName(contributionBindingField.name()));
+      contributionField.addModifiers(PRIVATE);
+      if (useRawType) {
+        contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
+      }
+
+      return contributionField.build();
+    }
+
+    private boolean useRawType(ResolvedBindings resolvedBindings) {
+      Optional<String> bindingPackage = resolvedBindings.bindingPackage();
+      return bindingPackage.isPresent()
+          && !bindingPackage.get().equals(componentName.packageName());
     }
 
     private RequestFulfillment createRequestFulfillment(
diff --git a/java/dagger/internal/codegen/HasBindingExpressions.java b/java/dagger/internal/codegen/HasBindingExpressions.java
index 207658813..30ee2cf90 100644
--- a/java/dagger/internal/codegen/HasBindingExpressions.java
+++ b/java/dagger/internal/codegen/HasBindingExpressions.java
@@ -16,10 +16,12 @@
 
 package dagger.internal.codegen;
 
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
 import javax.annotation.Nullable;
 
 /** An object which associates a {@link BindingExpression} instance with a {@link BindingKey}. */
-// TODO(gak): this isn't a particularly good abstraction. This should go away when MS is reworked.
+// TODO(dpb): Rename and/or split up this type.
 interface HasBindingExpressions {
 
   /**
@@ -30,4 +32,13 @@
   // This should remove the need for HasBindingExpressions
   @Nullable
   BindingExpression getBindingExpression(BindingKey bindingKey);
+
+  /** Returns the expression used to initialize a binding expression field. */
+  CodeBlock getFieldInitialization(BindingExpression bindingExpression);
+
+  /** Adds the given field to the component. */
+  void addField(FieldSpec fieldSpec);
+
+  /** Adds the given code block to the initialize methods of the component. */
+  void addInitialization(CodeBlock codeBlock);
 }
diff --git a/java/dagger/internal/codegen/SubcomponentWriter.java b/java/dagger/internal/codegen/SubcomponentWriter.java
index 3a059f0d0..bfa3a2327 100644
--- a/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -137,7 +137,7 @@ protected void addFactoryMethods() {
     ExecutableType resolvedMethod = resolvedSubcomponentFactoryMethod();
     componentMethod.returns(ClassName.get(resolvedMethod.getReturnType()));
     writeSubcomponentWithoutBuilder(componentMethod, resolvedMethod);
-    parent.component.addMethod(componentMethod.build());
+    parent.interfaceMethods.add(componentMethod.build());
   }
 
   private void writeSubcomponentWithoutBuilder(
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 2977d4b8f..c873fadca 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -218,12 +218,12 @@ public void simpleComponent() {
             GENERATED_ANNOTATION,
             "public final class DaggerTestClass_SimpleComponent",
             "    implements TestClass.SimpleComponent {",
-            "  private Producer<TestClass.B> bProducer;",
             "  private Provider<Executor> executorProvider;",
             "  private Provider<Executor> executorProvider2;",
             "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
             "  private Provider<ProductionComponentMonitor> monitorProvider;",
             "  private Provider<TestClass.B> bProvider;",
+            "  private Producer<TestClass.B> bProducer;",
             "  private Producer<TestClass.A> aProducer;",
             "",
             "  private DaggerTestClass_SimpleComponent(Builder builder) {",
