diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index e269fdb8e..02d28043b 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -202,17 +202,17 @@ java_library(
     name = "binding_graph_validation",
     srcs = [
         "BindingGraphValidationModule.java",
-        "DependencyCycleValidation.java",
+        "DependencyCycleValidator.java",
         "DependsOnProductionExecutorValidator.java",
-        "DuplicateBindingsValidation.java",
-        "IncompatiblyScopedBindingsValidation.java",
+        "DuplicateBindingsValidator.java",
+        "IncompatiblyScopedBindingsValidator.java",
         "IncorrectlyInstalledBindsMethodsValidator.java",
-        "InjectBindingValidation.java",
-        "MapMultibindingValidation.java",
-        "MissingBindingValidation.java",
-        "NullableBindingValidation.java",
-        "ProvisionDependencyOnProducerBindingValidation.java",
-        "SubcomponentFactoryMethodValidation.java",
+        "InjectBindingValidator.java",
+        "MapMultibindingValidator.java",
+        "MissingBindingValidator.java",
+        "NullableBindingValidator.java",
+        "ProvisionDependencyOnProducerBindingValidator.java",
+        "SubcomponentFactoryMethodValidator.java",
         "Validation.java",
     ],
     plugins = CODEGEN_PLUGINS,
diff --git a/java/dagger/internal/codegen/BindingGraphValidationModule.java b/java/dagger/internal/codegen/BindingGraphValidationModule.java
index fb7ecda20..63e1fa255 100644
--- a/java/dagger/internal/codegen/BindingGraphValidationModule.java
+++ b/java/dagger/internal/codegen/BindingGraphValidationModule.java
@@ -28,7 +28,7 @@
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin dependencyCycle(DependencyCycleValidation validation);
+  BindingGraphPlugin dependencyCycle(DependencyCycleValidator validation);
 
   @Binds
   @IntoSet
@@ -38,41 +38,41 @@
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin duplicateBindings(DuplicateBindingsValidation validation);
+  BindingGraphPlugin duplicateBindings(DuplicateBindingsValidator validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin incompatiblyScopedBindings(IncompatiblyScopedBindingsValidation validation);
+  BindingGraphPlugin incompatiblyScopedBindings(IncompatiblyScopedBindingsValidator validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin injectBinding(InjectBindingValidation validation);
+  BindingGraphPlugin injectBinding(InjectBindingValidator validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin mapMultibinding(MapMultibindingValidation validation);
+  BindingGraphPlugin mapMultibinding(MapMultibindingValidator validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin missingBinding(MissingBindingValidation validation);
+  BindingGraphPlugin missingBinding(MissingBindingValidator validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin nullableBinding(NullableBindingValidation validation);
+  BindingGraphPlugin nullableBinding(NullableBindingValidator validation);
 
   @Binds
   @IntoSet
   @Validation
   BindingGraphPlugin provisionDependencyOnProducerBinding(
-      ProvisionDependencyOnProducerBindingValidation validation);
+      ProvisionDependencyOnProducerBindingValidator validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin subcomponentFactoryMethod(SubcomponentFactoryMethodValidation validation);
+  BindingGraphPlugin subcomponentFactoryMethod(SubcomponentFactoryMethodValidator validation);
 }
diff --git a/java/dagger/internal/codegen/DependencyCycleValidation.java b/java/dagger/internal/codegen/DependencyCycleValidator.java
similarity index 94%
rename from java/dagger/internal/codegen/DependencyCycleValidation.java
rename to java/dagger/internal/codegen/DependencyCycleValidator.java
index 5e91fac1a..87564cdd7 100644
--- a/java/dagger/internal/codegen/DependencyCycleValidation.java
+++ b/java/dagger/internal/codegen/DependencyCycleValidator.java
@@ -56,12 +56,12 @@
 import javax.lang.model.type.TypeMirror;
 
 /** Reports errors for dependency cycles. */
-final class DependencyCycleValidation implements BindingGraphPlugin {
+final class DependencyCycleValidator implements BindingGraphPlugin {
 
   private final DependencyRequestFormatter dependencyRequestFormatter;
 
   @Inject
-  DependencyCycleValidation(DependencyRequestFormatter dependencyRequestFormatter) {
+  DependencyCycleValidator(DependencyRequestFormatter dependencyRequestFormatter) {
     this.dependencyRequestFormatter = dependencyRequestFormatter;
   }
 
@@ -156,9 +156,7 @@ private void reportCycle(
   private String errorMessage(Cycle<Node> cycle, BindingGraph graph) {
     StringBuilder message = new StringBuilder("Found a dependency cycle:");
     ImmutableList<DependencyRequest> cycleRequests =
-        cycle
-            .endpointPairs()
-            .stream()
+        cycle.endpointPairs().stream()
             // TODO(dpb): Would be nice to take the dependency graph here.
             .map(endpointPair -> nonCycleBreakingEdge(endpointPair, graph))
             .map(DependencyEdge::dependencyRequest)
@@ -173,9 +171,7 @@ private String errorMessage(Cycle<Node> cycle, BindingGraph graph) {
    * #breaksCycle(DependencyEdge, BindingGraph) break} a cycle.
    */
   private DependencyEdge nonCycleBreakingEdge(EndpointPair<Node> endpointPair, BindingGraph graph) {
-    return graph
-        .edgesConnecting(endpointPair.source(), endpointPair.target())
-        .stream()
+    return graph.edgesConnecting(endpointPair.source(), endpointPair.target()).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .filter(edge -> !breaksCycle(edge, graph))
         .findFirst()
@@ -222,9 +218,7 @@ private boolean breaksCycle(TypeMirror requestedType, RequestKind requestKind) {
 
   private DependencyEdge chooseDependencyEdgeConnecting(
       Node source, Node target, BindingGraph bindingGraph) {
-    return bindingGraph
-        .edgesConnecting(source, target)
-        .stream()
+    return bindingGraph.edgesConnecting(source, target).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .findFirst()
         .get();
@@ -238,9 +232,7 @@ private DependencyEdge chooseDependencyEdgeConnecting(
             .expectedNodeCount(bindingGraph.nodes().size())
             .expectedEdgeCount(bindingGraph.dependencyEdges().size())
             .build();
-    bindingGraph
-        .dependencyEdges()
-        .stream()
+    bindingGraph.dependencyEdges().stream()
         .filter(edge -> !breaksCycle(edge, bindingGraph))
         .forEach(
             edge -> {
@@ -265,8 +257,7 @@ private DependencyEdge chooseDependencyEdgeConnecting(
 
     /** Returns the nodes that participate in the cycle. */
     ImmutableSet<N> nodes() {
-      return endpointPairs()
-          .stream()
+      return endpointPairs().stream()
           .flatMap(pair -> Stream.of(pair.source(), pair.target()))
           .collect(toImmutableSet());
     }
@@ -291,7 +282,7 @@ int size() {
       ImmutableSet.Builder<EndpointPair<N>> shifted = ImmutableSet.builder();
       shifted.addAll(skip(endpointPairs(), startIndex));
       shifted.addAll(limit(endpointPairs(), size() - startIndex));
-      return new AutoValue_DependencyCycleValidation_Cycle<>(shifted.build());
+      return new AutoValue_DependencyCycleValidator_Cycle<>(shifted.build());
     }
 
     @Override
@@ -310,7 +301,7 @@ public final String toString() {
       for (int i = 0; i < nodes.size() - 1; i++) {
         cycle.add(EndpointPair.ordered(nodes.get(i), nodes.get(i + 1)));
       }
-      return new AutoValue_DependencyCycleValidation_Cycle<>(cycle.build());
+      return new AutoValue_DependencyCycleValidator_Cycle<>(cycle.build());
     }
   }
 }
diff --git a/java/dagger/internal/codegen/DuplicateBindingsValidation.java b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
similarity index 92%
rename from java/dagger/internal/codegen/DuplicateBindingsValidation.java
rename to java/dagger/internal/codegen/DuplicateBindingsValidator.java
index 39460d295..2e54f84ae 100644
--- a/java/dagger/internal/codegen/DuplicateBindingsValidation.java
+++ b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
@@ -21,7 +21,7 @@
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSetMultimap;
-import static dagger.internal.codegen.DuplicateBindingsValidation.SourceAndRequest.indexEdgesBySourceAndRequest;
+import static dagger.internal.codegen.DuplicateBindingsValidator.SourceAndRequest.indexEdgesBySourceAndRequest;
 import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.internal.codegen.Optionals.emptiesLast;
 import static java.util.Comparator.comparing;
@@ -48,7 +48,7 @@
 import javax.lang.model.element.TypeElement;
 
 /** Reports errors for conflicting bindings with the same key. */
-final class DuplicateBindingsValidation implements BindingGraphPlugin {
+final class DuplicateBindingsValidator implements BindingGraphPlugin {
 
   // 1. contributing module or enclosing type
   // 2. binding element's simple name
@@ -69,7 +69,7 @@
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
 
   @Inject
-  DuplicateBindingsValidation(BindingDeclarationFormatter bindingDeclarationFormatter) {
+  DuplicateBindingsValidator(BindingDeclarationFormatter bindingDeclarationFormatter) {
     this.bindingDeclarationFormatter = bindingDeclarationFormatter;
   }
 
@@ -96,8 +96,7 @@ private void reportDuplicateBindings(
       BindingGraph bindingGraph,
       DiagnosticReporter diagnosticReporter) {
     ImmutableSet<BindingNode> duplicateBindings =
-        duplicateDependencies
-            .stream()
+        duplicateDependencies.stream()
             .map(edge -> bindingGraph.incidentNodes(edge).target())
             .flatMap(instancesOf(BindingNode.class))
             .collect(toImmutableSet());
@@ -124,8 +123,7 @@ private String incompatibleBindingsMessage(
       ImmutableSet<BindingNode> duplicateBindings,
       BindingGraph graph) {
     ImmutableSet<BindingNode> multibindings =
-        duplicateBindings
-            .stream()
+        duplicateBindings.stream()
             .filter(node -> node.binding().kind().isMultibinding())
             .collect(toImmutableSet());
     verify(
@@ -164,8 +162,7 @@ private void formatDeclarations(
 
   private ImmutableSet<BindingDeclaration> declarations(
       BindingGraph graph, Set<BindingNode> bindings) {
-    return bindings
-        .stream()
+    return bindings.stream()
         .flatMap(node -> declarations(graph, node).stream())
         .distinct()
         .sorted(BINDING_DECLARATION_COMPARATOR)
@@ -180,9 +177,7 @@ private void formatDeclarations(
       if (bindingDeclarationFormatter.canFormat(declaration)) {
         declarations.add(declaration);
       } else {
-        graph
-            .successors(node)
-            .stream()
+        graph.successors(node).stream()
             .flatMap(instancesOf(BindingNode.class))
             .flatMap(dependency -> declarations(graph, dependency).stream())
             .forEach(declarations::add);
@@ -211,9 +206,7 @@ private String multibindingTypeString(BindingNode multibinding) {
 
     static ImmutableSetMultimap<SourceAndRequest, DependencyEdge> indexEdgesBySourceAndRequest(
         BindingGraph bindingGraph) {
-      return bindingGraph
-          .dependencyEdges()
-          .stream()
+      return bindingGraph.dependencyEdges().stream()
           .collect(
               toImmutableSetMultimap(
                   edge ->
@@ -222,7 +215,7 @@ private String multibindingTypeString(BindingNode multibinding) {
     }
 
     static SourceAndRequest create(Node source, DependencyRequest request) {
-      return new AutoValue_DuplicateBindingsValidation_SourceAndRequest(source, request);
+      return new AutoValue_DuplicateBindingsValidator_SourceAndRequest(source, request);
     }
   }
 }
diff --git a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidation.java b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
similarity index 96%
rename from java/dagger/internal/codegen/IncompatiblyScopedBindingsValidation.java
rename to java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
index 0a1c708ff..17b8c7eb2 100644
--- a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidation.java
+++ b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
@@ -38,12 +38,12 @@
  * Reports an error for any component that uses bindings with scopes that are not assigned to the
  * component.
  */
-final class IncompatiblyScopedBindingsValidation implements BindingGraphPlugin {
+final class IncompatiblyScopedBindingsValidator implements BindingGraphPlugin {
 
   private final MethodSignatureFormatter methodSignatureFormatter;
 
   @Inject
-  IncompatiblyScopedBindingsValidation(MethodSignatureFormatter methodSignatureFormatter) {
+  IncompatiblyScopedBindingsValidator(MethodSignatureFormatter methodSignatureFormatter) {
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
diff --git a/java/dagger/internal/codegen/InjectBindingValidation.java b/java/dagger/internal/codegen/InjectBindingValidator.java
similarity index 91%
rename from java/dagger/internal/codegen/InjectBindingValidation.java
rename to java/dagger/internal/codegen/InjectBindingValidator.java
index baf7abc2d..a275bcbe4 100644
--- a/java/dagger/internal/codegen/InjectBindingValidation.java
+++ b/java/dagger/internal/codegen/InjectBindingValidator.java
@@ -28,12 +28,12 @@
 import javax.lang.model.element.TypeElement;
 
 /** Validates bindings from {@code @Inject}-annotated constructors. */
-final class InjectBindingValidation implements BindingGraphPlugin {
+final class InjectBindingValidator implements BindingGraphPlugin {
 
   private final InjectValidator injectValidator;
 
   @Inject
-  InjectBindingValidation(InjectValidator injectValidator) {
+  InjectBindingValidator(InjectValidator injectValidator) {
     this.injectValidator = injectValidator.whenGeneratingCode();
   }
 
@@ -44,9 +44,7 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    bindingGraph
-        .bindingNodes()
-        .stream()
+    bindingGraph.bindingNodes().stream()
         .filter(node -> node.binding().kind().equals(INJECTION)) // TODO(dpb): Move to BindingGraph
         .forEach(node -> validateInjectionBinding(node, diagnosticReporter));
   }
diff --git a/java/dagger/internal/codegen/MapMultibindingValidation.java b/java/dagger/internal/codegen/MapMultibindingValidator.java
similarity index 96%
rename from java/dagger/internal/codegen/MapMultibindingValidation.java
rename to java/dagger/internal/codegen/MapMultibindingValidator.java
index b2d50a041..d7ccf2be0 100644
--- a/java/dagger/internal/codegen/MapMultibindingValidation.java
+++ b/java/dagger/internal/codegen/MapMultibindingValidator.java
@@ -41,12 +41,12 @@
  * Reports an error for any map binding with either more than one contribution with the same map key
  * or contributions with inconsistent map key annotation types.
  */
-final class MapMultibindingValidation implements BindingGraphPlugin {
+final class MapMultibindingValidator implements BindingGraphPlugin {
 
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
 
   @Inject
-  MapMultibindingValidation(BindingDeclarationFormatter bindingDeclarationFormatter) {
+  MapMultibindingValidator(BindingDeclarationFormatter bindingDeclarationFormatter) {
     this.bindingDeclarationFormatter = bindingDeclarationFormatter;
   }
 
@@ -70,9 +70,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
   private ImmutableSet<ContributionBinding> mapBindingContributions(
       BindingNode bindingNode, BindingGraph bindingGraph) {
     checkArgument(bindingNode.binding().kind().equals(MULTIBOUND_MAP));
-    return bindingGraph
-        .successors(bindingNode)
-        .stream()
+    return bindingGraph.successors(bindingNode).stream()
         .flatMap(instancesOf(BindingNode.class))
         .map(node -> (ContributionBinding) node.binding())
         .collect(toImmutableSet());
diff --git a/java/dagger/internal/codegen/MissingBindingValidation.java b/java/dagger/internal/codegen/MissingBindingValidator.java
similarity index 97%
rename from java/dagger/internal/codegen/MissingBindingValidation.java
rename to java/dagger/internal/codegen/MissingBindingValidator.java
index b3c597cbd..bdcc3e944 100644
--- a/java/dagger/internal/codegen/MissingBindingValidation.java
+++ b/java/dagger/internal/codegen/MissingBindingValidator.java
@@ -56,14 +56,14 @@
 import javax.lang.model.type.TypeMirror;
 
 /** Reports errors for missing bindings. */
-final class MissingBindingValidation implements BindingGraphPlugin {
+final class MissingBindingValidator implements BindingGraphPlugin {
 
   private final DaggerTypes types;
   private final DaggerElements elements;
   private final InjectBindingRegistry injectBindingRegistry;
 
   @Inject
-  MissingBindingValidation(
+  MissingBindingValidator(
       DaggerTypes types, DaggerElements elements, InjectBindingRegistry injectBindingRegistry) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
@@ -78,9 +78,7 @@ public String pluginName() {
   @Override
   public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
     // TODO(ronshapiro): Maybe report each missing binding once instead of each dependency.
-    graph
-        .missingBindingNodes()
-        .stream()
+    graph.missingBindingNodes().stream()
         .flatMap(node -> graph.inEdges(node).stream())
         .flatMap(instancesOf(DependencyEdge.class))
         .forEach(edge -> reportMissingBinding(edge, graph, diagnosticReporter));
@@ -115,9 +113,7 @@ private String missingBindingErrorMessage(DependencyEdge edge, BindingGraph grap
       errorMessage.append(
           " This type supports members injection but cannot be implicitly provided.");
     }
-    graph
-        .bindingNodes(key)
-        .stream()
+    graph.bindingNodes(key).stream()
         .map(bindingNode -> bindingNode.componentPath().currentComponent())
         .distinct()
         .forEach(
@@ -214,9 +210,7 @@ private static String notAnnotated(Key key, TypeElement type, TypeElement annota
   }
 
   private Stream<Scope> releasableReferencesScopes(BindingGraph graph) {
-    return graph
-        .componentNodes()
-        .stream()
+    return graph.componentNodes().stream()
         .flatMap(node -> node.scopes().stream())
         .filter(Scope::canReleaseReferences);
   }
diff --git a/java/dagger/internal/codegen/NullableBindingValidation.java b/java/dagger/internal/codegen/NullableBindingValidator.java
similarity index 90%
rename from java/dagger/internal/codegen/NullableBindingValidation.java
rename to java/dagger/internal/codegen/NullableBindingValidator.java
index 648922b5f..951e4d410 100644
--- a/java/dagger/internal/codegen/NullableBindingValidation.java
+++ b/java/dagger/internal/codegen/NullableBindingValidator.java
@@ -32,12 +32,12 @@
  * Reports errors or warnings (depending on the {@code -Adagger.nullableValidation} value) for each
  * non-nullable dependency request that is satisfied by a nullable binding.
  */
-final class NullableBindingValidation implements BindingGraphPlugin {
+final class NullableBindingValidator implements BindingGraphPlugin {
 
   private final CompilerOptions compilerOptions;
 
   @Inject
-  NullableBindingValidation(CompilerOptions compilerOptions) {
+  NullableBindingValidator(CompilerOptions compilerOptions) {
     this.compilerOptions = compilerOptions;
   }
 
@@ -61,18 +61,14 @@ public String pluginName() {
   }
 
   private ImmutableList<BindingNode> nullableBindings(BindingGraph bindingGraph) {
-    return bindingGraph
-        .bindingNodes()
-        .stream()
+    return bindingGraph.bindingNodes().stream()
         .filter(bindingNode -> bindingNode.binding().isNullable())
         .collect(toImmutableList());
   }
 
   private ImmutableList<DependencyEdge> nonNullableDependencies(
       BindingGraph bindingGraph, BindingNode bindingNode) {
-    return bindingGraph
-        .inEdges(bindingNode)
-        .stream()
+    return bindingGraph.inEdges(bindingNode).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .filter(edge -> !edge.dependencyRequest().isNullable())
         .collect(toImmutableList());
diff --git a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidation.java b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
similarity index 95%
rename from java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidation.java
rename to java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
index 2f3de94e9..a9a9c7d2d 100644
--- a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidation.java
+++ b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
@@ -36,10 +36,10 @@
  * binding.
  */
 // TODO(b/29509141): Clarify the error.
-final class ProvisionDependencyOnProducerBindingValidation implements BindingGraphPlugin {
+final class ProvisionDependencyOnProducerBindingValidator implements BindingGraphPlugin {
 
   @Inject
-  ProvisionDependencyOnProducerBindingValidation() {}
+  ProvisionDependencyOnProducerBindingValidator() {}
 
   @Override
   public String pluginName() {
@@ -61,9 +61,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
   private Stream<DependencyEdge> provisionDependenciesOnProductionBindings(
       BindingGraph bindingGraph) {
-    return bindingGraph
-        .bindingNodes()
-        .stream()
+    return bindingGraph.bindingNodes().stream()
         .filter(bindingNode -> bindingNode.binding().isProduction())
         .flatMap(binding -> incomingDependencies(binding, bindingGraph))
         .filter(edge -> !dependencyCanUseProduction(edge, bindingGraph));
diff --git a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidation.java b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
similarity index 95%
rename from java/dagger/internal/codegen/SubcomponentFactoryMethodValidation.java
rename to java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
index f958c9556..4c3cffa83 100644
--- a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidation.java
+++ b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
@@ -44,13 +44,13 @@
 import javax.lang.model.type.ExecutableType;
 
 /** Reports an error if a subcomponent factory method is missing required modules. */
-final class SubcomponentFactoryMethodValidation implements BindingGraphPlugin {
+final class SubcomponentFactoryMethodValidator implements BindingGraphPlugin {
 
   private final DaggerTypes types;
   private final Map<ComponentNode, Set<TypeElement>> inheritedModulesCache = new HashMap<>();
 
   @Inject
-  SubcomponentFactoryMethodValidation(DaggerTypes types) {
+  SubcomponentFactoryMethodValidator(DaggerTypes types) {
     this.types = types;
   }
 
@@ -61,9 +61,7 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    bindingGraph
-        .edges()
-        .stream()
+    bindingGraph.edges().stream()
         .flatMap(instancesOf(ChildFactoryMethodEdge.class))
         .forEach(
             edge -> {
@@ -81,9 +79,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
         subgraphFactoryMethodParameters(edge, graph);
     ComponentNode child = (ComponentNode) graph.incidentNodes(edge).target();
     SetView<TypeElement> modulesOwnedByChild = ownedModules(child, graph);
-    return graph
-        .bindingNodes()
-        .stream()
+    return graph.bindingNodes().stream()
         // bindings owned by child
         .filter(node -> node.componentPath().equals(child.componentPath()))
         // that require a module instance
diff --git a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java b/javatests/dagger/internal/codegen/BindsMethodValidationTest.java
similarity index 96%
rename from javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
rename to javatests/dagger/internal/codegen/BindsMethodValidationTest.java
index 479e8031c..c3de6c0cf 100644
--- a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
+++ b/javatests/dagger/internal/codegen/BindsMethodValidationTest.java
@@ -37,7 +37,7 @@
 import org.junit.runners.Parameterized.Parameters;
 
 @RunWith(Parameterized.class)
-public class BindsMethodValidatorTest {
+public class BindsMethodValidationTest {
   @Parameters
   public static Collection<Object[]> data() {
     return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});
@@ -45,7 +45,7 @@
 
   private final String moduleDeclaration;
 
-  public BindsMethodValidatorTest(Class<? extends Annotation> moduleAnnotation) {
+  public BindsMethodValidationTest(Class<? extends Annotation> moduleAnnotation) {
     moduleDeclaration = "@" + moduleAnnotation.getCanonicalName() + " abstract class %s { %s }";
   }
 
@@ -59,7 +59,7 @@ public void nonAbstract() {
   public void notAssignable() {
     assertThatMethod("@Binds abstract String notAssignable(Object impl);").hasError("assignable");
   }
-  
+
   @Test
   public void moreThanOneParameter() {
     assertThatMethod("@Binds abstract Object tooManyParameters(String s1, String s2);")
@@ -134,7 +134,7 @@ public void elementsIntoSet_withRawSets() {
   @Test
   public void intoMap_noMapKey() {
     assertThatMethod("@Binds @IntoMap abstract Object bindNoMapKey(String string);")
-         .hasError("methods of type map must declare a map key");
+        .hasError("methods of type map must declare a map key");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java b/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidationTest.java
similarity index 96%
rename from javatests/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
rename to javatests/dagger/internal/codegen/BindsOptionalOfMethodValidationTest.java
index 64942ccdc..c268fa0ac 100644
--- a/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
+++ b/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidationTest.java
@@ -34,7 +34,7 @@
 
 /** Tests {@link BindsOptionalOfMethodValidator}. */
 @RunWith(Parameterized.class)
-public class BindsOptionalOfMethodValidatorTest {
+public class BindsOptionalOfMethodValidationTest {
   @Parameters(name = "{0}")
   public static Collection<Object[]> data() {
     return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});
@@ -42,7 +42,7 @@
 
   private final String moduleDeclaration;
 
-  public BindsOptionalOfMethodValidatorTest(Class<? extends Annotation> moduleAnnotation) {
+  public BindsOptionalOfMethodValidationTest(Class<? extends Annotation> moduleAnnotation) {
     moduleDeclaration = "@" + moduleAnnotation.getCanonicalName() + " abstract class %s { %s }";
   }
 
diff --git a/javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java b/javatests/dagger/internal/codegen/CanReleaseReferencesValidationTest.java
similarity index 96%
rename from javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
rename to javatests/dagger/internal/codegen/CanReleaseReferencesValidationTest.java
index 00e9bb2cb..fda3a04c0 100644
--- a/javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
+++ b/javatests/dagger/internal/codegen/CanReleaseReferencesValidationTest.java
@@ -28,7 +28,7 @@
 
 /** Tests for {@link CanReleaseReferencesValidator}. */
 @RunWith(JUnit4.class)
-public final class CanReleaseReferencesValidatorTest {
+public final class CanReleaseReferencesValidationTest {
   @Test
   public void annotatesSourceRetainedAnnotation() {
     JavaFileObject annotation =
diff --git a/javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java b/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
similarity index 98%
rename from javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
rename to javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
index 6fbdbd3bd..757d5d7cc 100644
--- a/javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
@@ -28,7 +28,7 @@
 
 /** Tests for {ComponentHierarchyValidator}. */
 @RunWith(JUnit4.class)
-public class ComponentHierarchyValidatorTest {
+public class ComponentHierarchyValidationTest {
   @Test
   public void singletonSubcomponent() {
     JavaFileObject component =
@@ -67,7 +67,7 @@ public void singletonSubcomponent() {
             .compile(component, subcomponent);
     assertThat(withoutScopeValidation).succeeded();
   }
-  
+
   @Test
   public void productionComponents_productionScopeImplicitOnBoth() {
     JavaFileObject component =
diff --git a/javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java b/javatests/dagger/internal/codegen/ForReleasableReferencesValidationTest.java
similarity index 98%
rename from javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
rename to javatests/dagger/internal/codegen/ForReleasableReferencesValidationTest.java
index 8a529e91c..e15c6dbc1 100644
--- a/javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
+++ b/javatests/dagger/internal/codegen/ForReleasableReferencesValidationTest.java
@@ -28,7 +28,7 @@
 
 /** Tests validation of {@code @ForReleasableRefernces}. */
 @RunWith(JUnit4.class)
-public class ForReleasableReferencesValidatorTest {
+public class ForReleasableReferencesValidationTest {
   @Test
   public void notAScope() {
     JavaFileObject notAScope =
diff --git a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
deleted file mode 100644
index 2e7aa7d2a..000000000
--- a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
+++ /dev/null
@@ -1,499 +0,0 @@
-/*
- * Copyright (C) 2014 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.TestUtils.message;
-
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class GraphValidationScopingTest {
-  @Test public void componentWithoutScopeIncludesScopedBindings_Fail() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Component(modules = ScopedModule.class)",
-        "interface MyComponent {",
-        "  ScopedType string();",
-        "}");
-    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "class ScopedType {",
-        "  @Inject ScopedType(String s, long l, float f) {}",
-        "}");
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Module",
-        "class ScopedModule {",
-        "  @Provides @Singleton String string() { return \"a string\"; }",
-        "  @Provides long integer() { return 0L; }",
-        "  @Provides float floatingPoint() { return 0.0f; }",
-        "}");
-
-    Compilation compilation = daggerCompiler().compile(componentFile, typeFile, moduleFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "test.MyComponent (unscoped) may not reference scoped bindings:",
-                "    @Singleton class test.ScopedType",
-                "    @Provides @Singleton String test.ScopedModule.string()"));
-  }
-
-  @Test // b/79859714
-  public void bindsWithChildScope_inParentModule_notAllowed() {
-    JavaFileObject childScope =
-        JavaFileObjects.forSourceLines(
-            "test.ChildScope",
-            "package test;",
-            "",
-            "import javax.inject.Scope;",
-            "",
-            "@Scope",
-            "@interface ChildScope {}");
-
-    JavaFileObject foo =
-        JavaFileObjects.forSourceLines(
-            "test.Foo",
-            "package test;",
-            "", //
-            "interface Foo {}");
-
-    JavaFileObject fooImpl =
-        JavaFileObjects.forSourceLines(
-            "test.ChildModule",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class FooImpl implements Foo {",
-            "  @Inject FooImpl() {}",
-            "}");
-
-    JavaFileObject parentModule =
-        JavaFileObjects.forSourceLines(
-            "test.ParentModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "interface ParentModule {",
-            "  @Binds @ChildScope Foo bind(FooImpl fooImpl);",
-            "}");
-
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "test.ParentComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Singleton;",
-            "",
-            "@Singleton",
-            "@Component(modules = ParentModule.class)",
-            "interface Parent {",
-            "  Child child();",
-            "}");
-
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@ChildScope",
-            "@Subcomponent",
-            "interface Child {",
-            "  Foo foo();",
-            "}");
-
-    Compilation compilation =
-        daggerCompiler().compile(childScope, foo, fooImpl, parentModule, parent, child);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "test.Parent scoped with @Singleton may not reference bindings with different "
-                    + "scopes:",
-                "    @Binds @test.ChildScope test.Foo test.ParentModule.bind(test.FooImpl)"));
-  }
-
-  @Test public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "@Component(modules = ScopedModule.class)",
-        "interface MyComponent {",
-        "  ScopedType string();",
-        "}");
-    JavaFileObject scopeFile = JavaFileObjects.forSourceLines("test.PerTest",
-        "package test;",
-        "",
-        "import javax.inject.Scope;",
-        "",
-        "@Scope",
-        "@interface PerTest {}");
-    JavaFileObject scopeWithAttribute =
-        JavaFileObjects.forSourceLines(
-            "test.Per",
-            "package test;",
-            "",
-            "import javax.inject.Scope;",
-            "",
-            "@Scope",
-            "@interface Per {",
-            "  Class<?> value();",
-            "}");
-    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "@PerTest", // incompatible scope
-        "class ScopedType {",
-        "  @Inject ScopedType(String s, long l, float f, boolean b) {}",
-        "}");
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Module",
-        "class ScopedModule {",
-        "  @Provides @PerTest String string() { return \"a string\"; }", // incompatible scope
-        "  @Provides long integer() { return 0L; }", // unscoped - valid
-        "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
-        "  @Provides @Per(MyComponent.class) boolean bool() { return false; }", // incompatible
-        "}");
-
-    Compilation compilation =
-        daggerCompiler()
-            .compile(componentFile, scopeFile, scopeWithAttribute, typeFile, moduleFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "test.MyComponent scoped with @Singleton "
-                    + "may not reference bindings with different scopes:",
-                "    @test.PerTest class test.ScopedType",
-                "    @Provides @test.PerTest String test.ScopedModule.string()",
-                "    @Provides @test.Per(test.MyComponent.class) boolean "
-                    + "test.ScopedModule.bool()"));
-  }
-
-  @Test public void componentWithScopeMayDependOnOnlyOneScopedComponent() {
-    // If a scoped component will have dependencies, they must only include, at most, a single
-    // scoped component
-    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class SimpleType {",
-        "  @Inject SimpleType() {}",
-        "  static class A { @Inject A() {} }",
-        "  static class B { @Inject B() {} }",
-        "}");
-    JavaFileObject simpleScope = JavaFileObjects.forSourceLines("test.SimpleScope",
-        "package test;",
-        "",
-        "import javax.inject.Scope;",
-        "",
-        "@Scope @interface SimpleScope {}");
-    JavaFileObject singletonScopedA = JavaFileObjects.forSourceLines("test.SingletonComponentA",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "@Component",
-        "interface SingletonComponentA {",
-        "  SimpleType.A type();",
-        "}");
-    JavaFileObject singletonScopedB = JavaFileObjects.forSourceLines("test.SingletonComponentB",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "@Component",
-        "interface SingletonComponentB {",
-        "  SimpleType.B type();",
-        "}");
-    JavaFileObject scopeless = JavaFileObjects.forSourceLines("test.ScopelessComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface ScopelessComponent {",
-        "  SimpleType type();",
-        "}");
-    JavaFileObject simpleScoped = JavaFileObjects.forSourceLines("test.SimpleScopedComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@SimpleScope",
-        "@Component(dependencies = {SingletonComponentA.class, SingletonComponentB.class})",
-        "interface SimpleScopedComponent {",
-        "  SimpleType.A type();",
-        "}");
-
-    Compilation compilation =
-        daggerCompiler()
-            .compile(
-                type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped "
-                    + "component:",
-                "    @Singleton test.SingletonComponentA",
-                "    @Singleton test.SingletonComponentB"));
-  }
-
-  @Test public void componentWithoutScopeCannotDependOnScopedComponent() {
-    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class SimpleType {",
-        "  @Inject SimpleType() {}",
-        "}");
-    JavaFileObject scopedComponent = JavaFileObjects.forSourceLines("test.ScopedComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "@Component",
-        "interface ScopedComponent {",
-        "  SimpleType type();",
-        "}");
-    JavaFileObject unscopedComponent = JavaFileObjects.forSourceLines("test.UnscopedComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Component(dependencies = ScopedComponent.class)",
-        "interface UnscopedComponent {",
-        "  SimpleType type();",
-        "}");
-
-    Compilation compilation = daggerCompiler().compile(type, scopedComponent, unscopedComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "test.UnscopedComponent (unscoped) cannot depend on scoped components:",
-                "    @Singleton test.ScopedComponent"));
-  }
-
-  @Test public void componentWithSingletonScopeMayNotDependOnOtherScope() {
-    // Singleton must be the widest lifetime of present scopes.
-    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class SimpleType {",
-        "  @Inject SimpleType() {}",
-        "}");
-    JavaFileObject simpleScope = JavaFileObjects.forSourceLines("test.SimpleScope",
-        "package test;",
-        "",
-        "import javax.inject.Scope;",
-        "",
-        "@Scope @interface SimpleScope {}");
-    JavaFileObject simpleScoped = JavaFileObjects.forSourceLines("test.SimpleScopedComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@SimpleScope",
-        "@Component",
-        "interface SimpleScopedComponent {",
-        "  SimpleType type();",
-        "}");
-    JavaFileObject singletonScoped = JavaFileObjects.forSourceLines("test.SingletonComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "@Component(dependencies = SimpleScopedComponent.class)",
-        "interface SingletonComponent {",
-        "  SimpleType type();",
-        "}");
-
-    Compilation compilation =
-        daggerCompiler().compile(type, simpleScope, simpleScoped, singletonScoped);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "This @Singleton component cannot depend on scoped components:",
-                "    @test.SimpleScope test.SimpleScopedComponent"));
-  }
-
-  @Test public void componentScopeAncestryMustNotCycle() {
-    // The dependency relationship of components is necessarily from shorter lifetimes to
-    // longer lifetimes.  The scoping annotations must reflect this, and so one cannot declare
-    // scopes on components such that they cycle.
-    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class SimpleType {",
-        "  @Inject SimpleType() {}",
-        "}");
-    JavaFileObject scopeA = JavaFileObjects.forSourceLines("test.ScopeA",
-        "package test;",
-        "",
-        "import javax.inject.Scope;",
-        "",
-        "@Scope @interface ScopeA {}");
-    JavaFileObject scopeB = JavaFileObjects.forSourceLines("test.ScopeB",
-        "package test;",
-        "",
-        "import javax.inject.Scope;",
-        "",
-        "@Scope @interface ScopeB {}");
-    JavaFileObject longLifetime = JavaFileObjects.forSourceLines("test.ComponentLong",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@ScopeA",
-        "@Component",
-        "interface ComponentLong {",
-        "  SimpleType type();",
-        "}");
-    JavaFileObject mediumLifetime = JavaFileObjects.forSourceLines("test.ComponentMedium",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@ScopeB",
-        "@Component(dependencies = ComponentLong.class)",
-        "interface ComponentMedium {",
-        "  SimpleType type();",
-        "}");
-    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@ScopeA",
-        "@Component(dependencies = ComponentMedium.class)",
-        "interface ComponentShort {",
-        "  SimpleType type();",
-        "}");
-
-    Compilation compilation =
-        daggerCompiler().compile(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "test.ComponentShort depends on scoped components in a non-hierarchical scope "
-                    + "ordering:",
-                "    @test.ScopeA test.ComponentLong",
-                "    @test.ScopeB test.ComponentMedium",
-                "    @test.ScopeA test.ComponentShort"));
-  }
-
-  @Test
-  public void reusableNotAllowedOnComponent() {
-    JavaFileObject someComponent =
-        JavaFileObjects.forSourceLines(
-            "test.SomeComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Reusable;",
-            "",
-            "@Reusable",
-            "@Component",
-            "interface SomeComponent {}");
-    Compilation compilation = daggerCompiler().compile(someComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents")
-        .inFile(someComponent)
-        .onLine(6);
-  }
-
-  @Test
-  public void reusableNotAllowedOnSubcomponent() {
-    JavaFileObject someSubcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.SomeComponent",
-            "package test;",
-            "",
-            "import dagger.Reusable;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Reusable",
-            "@Subcomponent",
-            "interface SomeSubcomponent {}");
-    Compilation compilation = daggerCompiler().compile(someSubcomponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents")
-        .inFile(someSubcomponent)
-        .onLine(6);
-  }
-}
diff --git a/javatests/dagger/internal/codegen/ModuleValidatorTest.java b/javatests/dagger/internal/codegen/ModuleValidationTest.java
similarity index 99%
rename from javatests/dagger/internal/codegen/ModuleValidatorTest.java
rename to javatests/dagger/internal/codegen/ModuleValidationTest.java
index 1c605bb5c..9823c097d 100644
--- a/javatests/dagger/internal/codegen/ModuleValidatorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleValidationTest.java
@@ -33,7 +33,7 @@
 import org.junit.runners.Parameterized;
 
 @RunWith(Parameterized.class)
-public final class ModuleValidatorTest {
+public final class ModuleValidationTest {
 
   @Parameterized.Parameters(name = "{0}")
   public static Collection<Object[]> parameters() {
@@ -66,7 +66,7 @@ String simpleName() {
 
   private final ModuleType moduleType;
 
-  public ModuleValidatorTest(ModuleType moduleType) {
+  public ModuleValidationTest(ModuleType moduleType) {
     this.moduleType = moduleType;
   }
 
diff --git a/javatests/dagger/internal/codegen/MultibindsValidatorTest.java b/javatests/dagger/internal/codegen/MultibindsValidationTest.java
similarity index 97%
rename from javatests/dagger/internal/codegen/MultibindsValidatorTest.java
rename to javatests/dagger/internal/codegen/MultibindsValidationTest.java
index cdd74df0d..e5603a4d6 100644
--- a/javatests/dagger/internal/codegen/MultibindsValidatorTest.java
+++ b/javatests/dagger/internal/codegen/MultibindsValidationTest.java
@@ -31,7 +31,7 @@
 import org.junit.runners.Parameterized.Parameters;
 
 @RunWith(Parameterized.class)
-public class MultibindsValidatorTest {
+public class MultibindsValidationTest {
 
   @Parameters(name = "{0}")
   public static Collection<Object[]> parameters() {
@@ -40,7 +40,7 @@
 
   private final String moduleDeclaration;
 
-  public MultibindsValidatorTest(Class<? extends Annotation> moduleAnnotation) {
+  public MultibindsValidationTest(Class<? extends Annotation> moduleAnnotation) {
     moduleDeclaration = "@" + moduleAnnotation.getCanonicalName() + " abstract class %s { %s }";
   }
 
diff --git a/javatests/dagger/internal/codegen/NullableBindingValidationTest.java b/javatests/dagger/internal/codegen/NullableBindingValidationTest.java
index 4b5429ede..710f77721 100644
--- a/javatests/dagger/internal/codegen/NullableBindingValidationTest.java
+++ b/javatests/dagger/internal/codegen/NullableBindingValidationTest.java
@@ -19,7 +19,7 @@
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.NullableBindingValidation.nullableToNonNullable;
+import static dagger.internal.codegen.NullableBindingValidator.nullableToNonNullable;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
diff --git a/javatests/dagger/internal/codegen/ScopingValidationTest.java b/javatests/dagger/internal/codegen/ScopingValidationTest.java
new file mode 100644
index 000000000..cbe358013
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ScopingValidationTest.java
@@ -0,0 +1,557 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ScopingValidationTest {
+  @Test
+  public void componentWithoutScopeIncludesScopedBindings_Fail() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.MyComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Component(modules = ScopedModule.class)",
+            "interface MyComponent {",
+            "  ScopedType string();",
+            "}");
+    JavaFileObject typeFile =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "class ScopedType {",
+            "  @Inject ScopedType(String s, long l, float f) {}",
+            "}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Module",
+            "class ScopedModule {",
+            "  @Provides @Singleton String string() { return \"a string\"; }",
+            "  @Provides long integer() { return 0L; }",
+            "  @Provides float floatingPoint() { return 0.0f; }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(componentFile, typeFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.MyComponent (unscoped) may not reference scoped bindings:",
+                "    @Singleton class test.ScopedType",
+                "    @Provides @Singleton String test.ScopedModule.string()"));
+  }
+
+  @Test // b/79859714
+  public void bindsWithChildScope_inParentModule_notAllowed() {
+    JavaFileObject childScope =
+        JavaFileObjects.forSourceLines(
+            "test.ChildScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface ChildScope {}");
+
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "", //
+            "interface Foo {}");
+
+    JavaFileObject fooImpl =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class FooImpl implements Foo {",
+            "  @Inject FooImpl() {}",
+            "}");
+
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface ParentModule {",
+            "  @Binds @ChildScope Foo bind(FooImpl fooImpl);",
+            "}");
+
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@ChildScope",
+            "@Subcomponent",
+            "interface Child {",
+            "  Foo foo();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(childScope, foo, fooImpl, parentModule, parent, child);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Parent scoped with @Singleton may not reference bindings with different "
+                    + "scopes:",
+                "    @Binds @test.ChildScope test.Foo test.ParentModule.bind(test.FooImpl)"));
+  }
+
+  @Test
+  public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.MyComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = ScopedModule.class)",
+            "interface MyComponent {",
+            "  ScopedType string();",
+            "}");
+    JavaFileObject scopeFile =
+        JavaFileObjects.forSourceLines(
+            "test.PerTest",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface PerTest {}");
+    JavaFileObject scopeWithAttribute =
+        JavaFileObjects.forSourceLines(
+            "test.Per",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface Per {",
+            "  Class<?> value();",
+            "}");
+    JavaFileObject typeFile =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "@PerTest", // incompatible scope
+            "class ScopedType {",
+            "  @Inject ScopedType(String s, long l, float f, boolean b) {}",
+            "}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Module",
+            "class ScopedModule {",
+            "  @Provides @PerTest String string() { return \"a string\"; }", // incompatible scope
+            "  @Provides long integer() { return 0L; }", // unscoped - valid
+            "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
+            "  @Provides @Per(MyComponent.class) boolean bool() { return false; }", // incompatible
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .compile(componentFile, scopeFile, scopeWithAttribute, typeFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.MyComponent scoped with @Singleton "
+                    + "may not reference bindings with different scopes:",
+                "    @test.PerTest class test.ScopedType",
+                "    @Provides @test.PerTest String test.ScopedModule.string()",
+                "    @Provides @test.Per(test.MyComponent.class) boolean "
+                    + "test.ScopedModule.bool()"));
+  }
+
+  @Test
+  public void componentWithScopeMayDependOnOnlyOneScopedComponent() {
+    // If a scoped component will have dependencies, they must only include, at most, a single
+    // scoped component
+    JavaFileObject type =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class SimpleType {",
+            "  @Inject SimpleType() {}",
+            "  static class A { @Inject A() {} }",
+            "  static class B { @Inject B() {} }",
+            "}");
+    JavaFileObject simpleScope =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope @interface SimpleScope {}");
+    JavaFileObject singletonScopedA =
+        JavaFileObjects.forSourceLines(
+            "test.SingletonComponentA",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component",
+            "interface SingletonComponentA {",
+            "  SimpleType.A type();",
+            "}");
+    JavaFileObject singletonScopedB =
+        JavaFileObjects.forSourceLines(
+            "test.SingletonComponentB",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component",
+            "interface SingletonComponentB {",
+            "  SimpleType.B type();",
+            "}");
+    JavaFileObject scopeless =
+        JavaFileObjects.forSourceLines(
+            "test.ScopelessComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ScopelessComponent {",
+            "  SimpleType type();",
+            "}");
+    JavaFileObject simpleScoped =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleScopedComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@SimpleScope",
+            "@Component(dependencies = {SingletonComponentA.class, SingletonComponentB.class})",
+            "interface SimpleScopedComponent {",
+            "  SimpleType.A type();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped "
+                    + "component:",
+                "    @Singleton test.SingletonComponentA",
+                "    @Singleton test.SingletonComponentB"));
+  }
+
+  @Test
+  public void componentWithoutScopeCannotDependOnScopedComponent() {
+    JavaFileObject type =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class SimpleType {",
+            "  @Inject SimpleType() {}",
+            "}");
+    JavaFileObject scopedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component",
+            "interface ScopedComponent {",
+            "  SimpleType type();",
+            "}");
+    JavaFileObject unscopedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.UnscopedComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Component(dependencies = ScopedComponent.class)",
+            "interface UnscopedComponent {",
+            "  SimpleType type();",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(type, scopedComponent, unscopedComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.UnscopedComponent (unscoped) cannot depend on scoped components:",
+                "    @Singleton test.ScopedComponent"));
+  }
+
+  @Test
+  public void componentWithSingletonScopeMayNotDependOnOtherScope() {
+    // Singleton must be the widest lifetime of present scopes.
+    JavaFileObject type =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class SimpleType {",
+            "  @Inject SimpleType() {}",
+            "}");
+    JavaFileObject simpleScope =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope @interface SimpleScope {}");
+    JavaFileObject simpleScoped =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleScopedComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@SimpleScope",
+            "@Component",
+            "interface SimpleScopedComponent {",
+            "  SimpleType type();",
+            "}");
+    JavaFileObject singletonScoped =
+        JavaFileObjects.forSourceLines(
+            "test.SingletonComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(dependencies = SimpleScopedComponent.class)",
+            "interface SingletonComponent {",
+            "  SimpleType type();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(type, simpleScope, simpleScoped, singletonScoped);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "This @Singleton component cannot depend on scoped components:",
+                "    @test.SimpleScope test.SimpleScopedComponent"));
+  }
+
+  @Test
+  public void componentScopeAncestryMustNotCycle() {
+    // The dependency relationship of components is necessarily from shorter lifetimes to
+    // longer lifetimes.  The scoping annotations must reflect this, and so one cannot declare
+    // scopes on components such that they cycle.
+    JavaFileObject type =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class SimpleType {",
+            "  @Inject SimpleType() {}",
+            "}");
+    JavaFileObject scopeA =
+        JavaFileObjects.forSourceLines(
+            "test.ScopeA",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope @interface ScopeA {}");
+    JavaFileObject scopeB =
+        JavaFileObjects.forSourceLines(
+            "test.ScopeB",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope @interface ScopeB {}");
+    JavaFileObject longLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentLong",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@ScopeA",
+            "@Component",
+            "interface ComponentLong {",
+            "  SimpleType type();",
+            "}");
+    JavaFileObject mediumLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentMedium",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@ScopeB",
+            "@Component(dependencies = ComponentLong.class)",
+            "interface ComponentMedium {",
+            "  SimpleType type();",
+            "}");
+    JavaFileObject shortLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentShort",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@ScopeA",
+            "@Component(dependencies = ComponentMedium.class)",
+            "interface ComponentShort {",
+            "  SimpleType type();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentShort depends on scoped components in a non-hierarchical scope "
+                    + "ordering:",
+                "    @test.ScopeA test.ComponentLong",
+                "    @test.ScopeB test.ComponentMedium",
+                "    @test.ScopeA test.ComponentShort"));
+  }
+
+  @Test
+  public void reusableNotAllowedOnComponent() {
+    JavaFileObject someComponent =
+        JavaFileObjects.forSourceLines(
+            "test.SomeComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Reusable;",
+            "",
+            "@Reusable",
+            "@Component",
+            "interface SomeComponent {}");
+    Compilation compilation = daggerCompiler().compile(someComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents")
+        .inFile(someComponent)
+        .onLine(6);
+  }
+
+  @Test
+  public void reusableNotAllowedOnSubcomponent() {
+    JavaFileObject someSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.SomeComponent",
+            "package test;",
+            "",
+            "import dagger.Reusable;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Reusable",
+            "@Subcomponent",
+            "interface SomeSubcomponent {}");
+    Compilation compilation = daggerCompiler().compile(someSubcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents")
+        .inFile(someSubcomponent)
+        .onLine(6);
+  }
+}
