diff --git a/java/dagger/internal/codegen/Binding.java b/java/dagger/internal/codegen/Binding.java
index 0a27f4ba4..93dc514f6 100644
--- a/java/dagger/internal/codegen/Binding.java
+++ b/java/dagger/internal/codegen/Binding.java
@@ -19,9 +19,7 @@
 import static com.google.common.base.Suppliers.memoize;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
-import static javax.lang.model.element.Modifier.PUBLIC;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Supplier;
 import com.google.common.collect.FluentIterable;
@@ -37,16 +35,11 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
-import java.util.Set;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
-import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
@@ -239,63 +232,6 @@ static DependencyAssociation create(
             .values());
   }
 
-  /**
-   * Returns the name of the package in which this binding must be managed. E.g.: a binding
-   * may reference non-public types.
-   */
-  final Optional<String> bindingPackage() {
-    Set<String> packages = nonPublicPackageUse(key().type());
-    switch (packages.size()) {
-      case 0:
-        return Optional.empty();
-      case 1:
-        return Optional.of(packages.iterator().next());
-      default:
-        throw new IllegalStateException();
-    }
-  }
-
-  private static Set<String> nonPublicPackageUse(TypeMirror typeMirror) {
-    ImmutableSet.Builder<String> packages = ImmutableSet.builder();
-    typeMirror.accept(new SimpleTypeVisitor6<Void, ImmutableSet.Builder<String>>() {
-      @Override
-      public Void visitArray(ArrayType t, ImmutableSet.Builder<String> p) {
-        return t.getComponentType().accept(this, p);
-      }
-
-      @Override
-      public Void visitDeclared(DeclaredType t, ImmutableSet.Builder<String> p) {
-        for (TypeMirror typeArgument : t.getTypeArguments()) {
-          typeArgument.accept(this, p);
-        }
-        // TODO(gak): address public nested types in non-public types
-        TypeElement typeElement = MoreElements.asType(t.asElement());
-        if (!typeElement.getModifiers().contains(PUBLIC)) {
-          PackageElement elementPackage = MoreElements.getPackage(typeElement);
-          Name qualifiedName = elementPackage.getQualifiedName();
-          p.add(qualifiedName.toString());
-        }
-        // Also make sure enclosing types are visible, otherwise we're fooled by
-        // class Foo { public class Bar }
-        // (Note: we can't use t.getEnclosingType() because it doesn't work!)
-        typeElement.getEnclosingElement().asType().accept(this, p);
-        return null;
-      }
-
-      @Override
-      public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
-        if (t.getExtendsBound() != null) {
-          t.getExtendsBound().accept(this, p);
-        }
-        if (t.getSuperBound() != null) {
-          t.getSuperBound().accept(this, p);
-        }
-        return null;
-      }
-    }, packages);
-    return packages.build();
-  }
-
   /**
    * If this binding's key's type parameters are different from those of the
    * {@link #bindingTypeElement()}, this is the binding for the {@link #bindingTypeElement()}'s
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index e15645fea..5e4891ee6 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
@@ -127,7 +128,8 @@ BindingExpression forField(ResolvedBindings resolvedBindings) {
      */
     private FieldSpec generateFrameworkField(
         ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
-      boolean useRawType = useRawType(resolvedBindings);
+      boolean useRawType =
+          !isTypeAccessibleFrom(resolvedBindings.key().type(), componentName.packageName());
 
       FrameworkField contributionBindingField =
           FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);
@@ -145,12 +147,6 @@ private FieldSpec generateFrameworkField(
       return contributionField.build();
     }
 
-    private boolean useRawType(ResolvedBindings resolvedBindings) {
-      Optional<String> bindingPackage = resolvedBindings.bindingPackage();
-      return bindingPackage.isPresent()
-          && !bindingPackage.get().equals(componentName.packageName());
-    }
-
     private FrameworkFieldInitializer newFrameworkFieldInitializer(
         FieldSpec fieldSpec, ResolvedBindings resolvedBindings) {
       return new FrameworkFieldInitializer(
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index 750a69667..88bb1fe17 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -24,6 +24,7 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.BindingType.PROVISION;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
@@ -527,8 +528,7 @@ private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, Code
   }
 
   private boolean useRawType() {
-    Optional<String> bindingPackage = resolvedBindings.binding().bindingPackage();
-    return bindingPackage.isPresent() && !bindingPackage.get().equals(componentName.packageName());
+    return !isTypeAccessibleFrom(resolvedBindings.key().type(), componentName.packageName());
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ResolvedBindings.java b/java/dagger/internal/codegen/ResolvedBindings.java
index c42839e46..f3787d23b 100644
--- a/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/java/dagger/internal/codegen/ResolvedBindings.java
@@ -289,17 +289,6 @@ public ContributionType contributionType() {
     return contributionBinding().contributionType();
   }
 
-  /**
-   * The name of the package in which these bindings must be managed, for
-   * example if a binding references non-public types.
-   *
-   * @throws IllegalStateException if there is more than one binding
-   */
-  Optional<String> bindingPackage() {
-    checkState(bindings().size() == 1);
-    return binding().bindingPackage();
-  }
-
   /**
    * The framework class associated with these bindings.
    */
