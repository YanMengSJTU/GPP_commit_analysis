diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index d466dbb50..1d36de555 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -69,6 +69,7 @@ java_library(
         "DaggerElements.java",
         "DaggerStreams.java",
         "DaggerTypes.java",
+        "DiagnosticFormatting.java",
         "Expression.java",
         "FeatureStatus.java",
         "ForwardingNetwork.java",
@@ -84,6 +85,7 @@ java_library(
         "OptionalType.java",
         "Optionals.java",
         "RequestKinds.java",
+        "Scopes.java",
         "SetType.java",
         "SimpleAnnotationMirror.java",
         "SimpleTypeAnnotationValue.java",
@@ -137,7 +139,6 @@ java_library(
         "ProductionBinding.java",
         "ProvisionBinding.java",
         "ResolvedBindings.java",
-        "Scope.java",
         "SourceFiles.java",  # Consider splitting this up?
         "SubcomponentDeclaration.java",
     ],
diff --git a/java/dagger/internal/codegen/Binding.java b/java/dagger/internal/codegen/Binding.java
index 3906bfe4a..9c9da715f 100644
--- a/java/dagger/internal/codegen/Binding.java
+++ b/java/dagger/internal/codegen/Binding.java
@@ -31,6 +31,7 @@
 import com.google.common.collect.Sets;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.model.Key;
+import dagger.model.Scope;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
diff --git a/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index 334298dad..b17ce14d3 100644
--- a/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -21,7 +21,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGER;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS;
-import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.EXECUTABLE;
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 98fc901c0..0113e4dcd 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -27,7 +27,6 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.Keys.indexByKey;
-import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static java.util.function.Predicate.isEqual;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -53,6 +52,7 @@
 import dagger.internal.codegen.Keys.HasKey;
 import dagger.model.Key;
 import dagger.model.RequestKind;
+import dagger.model.Scope;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.releasablereferences.CanReleaseReferences;
@@ -794,7 +794,7 @@ private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding bi
       }
 
       private Optional<Resolver> getOwningResolver(ContributionBinding binding) {
-        if (binding.scope().isPresent() && binding.scope().get().equals(reusableScope(elements))) {
+        if (binding.scope().isPresent() && binding.scope().get().isReusable()) {
           for (Resolver requestResolver : getResolverLineage().reverse()) {
             // If a @Reusable binding was resolved in an ancestor, use that component.
             if (requestResolver.resolvedBindings.containsKey(
@@ -1095,8 +1095,7 @@ boolean dependsOnLocalBindings(Binding binding) {
         }
 
         private boolean dependsOnLocalBindingsUncached(Binding binding) {
-          if ((!binding.scope().isPresent()
-                  || binding.scope().get().equals(reusableScope(elements)))
+          if ((!binding.scope().isPresent() || binding.scope().get().isReusable())
               // TODO(beder): Figure out what happens with production subcomponents.
               && !binding.bindingType().equals(BindingType.PRODUCTION)) {
             for (DependencyRequest dependency : binding.dependencies()) {
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index 2f47beae3..20b2d6a1c 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -37,6 +37,7 @@
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
 import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;
@@ -59,12 +60,12 @@
 import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeMetadataMissingCanReleaseReferences;
 import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotAnnotatedWithMetadata;
 import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotInComponentHierarchy;
-import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
 import static dagger.internal.codegen.Keys.isValidMembersInjectionKey;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
-import static dagger.internal.codegen.Scope.reusableScope;
-import static dagger.internal.codegen.Scope.scopesOf;
+import static dagger.internal.codegen.Scopes.getReadableSource;
+import static dagger.internal.codegen.Scopes.scopesOf;
+import static dagger.internal.codegen.Scopes.singletonScope;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static java.util.stream.Collectors.groupingBy;
@@ -98,6 +99,7 @@
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.model.Key;
 import dagger.model.RequestKind;
+import dagger.model.Scope;
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
 import dagger.releasablereferences.ReleasableReferenceManager;
@@ -292,7 +294,7 @@ private void validateDependencyScopes(BindingGraph graph) {
       ImmutableSet<Scope> scopes = descriptor.scopes();
       ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
       if (!scopes.isEmpty()) {
-        Scope singletonScope = Scope.singletonScope(elements);
+        Scope singletonScope = singletonScope(elements);
         // Dagger 1.x scope compatibility requires this be suppress-able.
         if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()
             && scopes.contains(singletonScope)) {
@@ -313,7 +315,7 @@ private void validateDependencyScopes(BindingGraph graph) {
           // Scoped components may depend on at most one scoped component.
           StringBuilder message = new StringBuilder();
           for (Scope scope : scopes) {
-            message.append(scope.getReadableSource()).append(' ');
+            message.append(getReadableSource(scope)).append(' ');
           }
           message
               .append(descriptor.componentDefinitionType().getQualifiedName())
@@ -457,7 +459,7 @@ private void validateDependencyScopeHierarchy(
         TypeElement dependency,
         Deque<ImmutableSet<Scope>> scopeStack,
         Deque<TypeElement> scopedDependencyStack) {
-      ImmutableSet<Scope> scopes = Scope.scopesOf(dependency);
+      ImmutableSet<Scope> scopes = scopesOf(dependency);
       if (stackOverlaps(scopeStack, scopes)) {
         scopedDependencyStack.push(dependency);
         // Current scope has already appeared in the component chain.
@@ -514,7 +516,7 @@ private void validateDependencyScopeHierarchy(
     private void checkBindingScope(
         ContributionBinding binding, ComponentDescriptor owningComponent) {
       if (binding.scope().isPresent()
-          && !binding.scope().get().equals(reusableScope(elements))
+          && !binding.scope().get().isReusable()
           && !owningComponent.scopes().contains(binding.scope().get())) {
         incompatiblyScopedBindings.put(owningComponent, binding);
       }
@@ -534,7 +536,7 @@ private void checkScopedBindings(BindingGraph graph) {
       if (!graph.componentDescriptor().scopes().isEmpty()) {
         message.append(" scoped with ");
         for (Scope scope : graph.componentDescriptor().scopes()) {
-          message.append(scope.getReadableSource()).append(' ');
+          message.append(getReadableSource(scope)).append(' ');
         }
         message.append("may not reference bindings with different scopes:\n");
       } else {
@@ -554,7 +556,7 @@ private void checkScopedBindings(BindingGraph graph) {
 
           case INJECTION:
             message
-                .append(binding.scope().get().getReadableSource())
+                .append(getReadableSource(binding.scope().get()))
                 .append(" class ")
                 .append(binding.bindingTypeElement().get().getQualifiedName());
             break;
@@ -954,7 +956,7 @@ private boolean reportMissingReleasableReferenceManager() {
         }
 
         Scope scope =
-            Scope.scope(MoreTypes.asTypeElement(getTypeValue(key.qualifier().get(), "value")));
+            Scopes.scope(MoreTypes.asTypeElement(getTypeValue(key.qualifier().get(), "value")));
         String missingRequestKey = formatCurrentDependencyRequestKey();
         if (!rootGraph.componentDescriptor().releasableReferencesScopes().contains(scope)) {
           reportErrorAtEntryPoint(
@@ -1200,8 +1202,8 @@ private String formatCurrentDependencyRequestKey() {
   private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeElement> types) {
     for (TypeElement scopedComponent : types) {
       message.append(INDENT);
-      for (Scope scope : Scope.scopesOf(scopedComponent)) {
-        message.append(scope.getReadableSource()).append(' ');
+      for (Scope scope : scopesOf(scopedComponent)) {
+        message.append(getReadableSource(scope)).append(' ');
       }
       message.append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))
           .append('\n');
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 96ae010ea..4643921c4 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -28,6 +28,8 @@
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.Scopes.productionScope;
+import static dagger.internal.codegen.Scopes.scopesOf;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -50,6 +52,7 @@
 import dagger.MembersInjector;
 import dagger.Module;
 import dagger.Subcomponent;
+import dagger.model.Scope;
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
 import dagger.releasablereferences.CanReleaseReferences;
@@ -564,9 +567,9 @@ private ComponentDescriptor create(
           Optional.ofNullable(getOnlyElement(enclosedBuilders, null));
       Optional<BuilderSpec> builderSpec = createBuilderSpec(builderType);
 
-      ImmutableSet<Scope> scopes = Scope.scopesOf(componentDefinitionType);
+      ImmutableSet<Scope> scopes = scopesOf(componentDefinitionType);
       if (kind.isProducer()) {
-        scopes = FluentIterable.from(scopes).append(Scope.productionScope(elements)).toSet();
+        scopes = FluentIterable.from(scopes).append(productionScope(elements)).toSet();
       }
 
       return new AutoValue_ComponentDescriptor(
diff --git a/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index 936b4d35f..5cf7ce7f6 100644
--- a/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -18,9 +18,9 @@
 
 import static com.google.common.base.Functions.constant;
 import static com.google.common.base.Predicates.and;
-import static com.google.common.base.Predicates.equalTo;
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
+import static dagger.internal.codegen.Scopes.getReadableSource;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Predicate;
@@ -31,19 +31,17 @@
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.model.Scope;
 import java.util.Map;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.util.Elements;
 
 /** Validates the relationships between parent components and subcomponents. */
 final class ComponentHierarchyValidator {
   private final CompilerOptions compilerOptions;
-  private final Elements elements;
 
-  ComponentHierarchyValidator(CompilerOptions compilerOptions, Elements elements) {
+  ComponentHierarchyValidator(CompilerOptions compilerOptions) {
     this.compilerOptions = compilerOptions;
-    this.elements = elements;
   }
 
   ValidationReport<TypeElement> validate(ComponentDescriptor componentDescriptor) {
@@ -120,7 +118,7 @@ private void validateScopeHierarchy(
     Predicate<Scope> subjectScopes =
         subject.kind().isProducer()
             // TODO(beder): validate that @ProductionScope is only applied on production components
-            ? and(in(subject.scopes()), not(equalTo(Scope.productionScope(elements))))
+            ? and(in(subject.scopes()), not(Scope::isProductionScope))
             : in(subject.scopes());
     SetMultimap<ComponentDescriptor, Scope> overlappingScopes =
         Multimaps.filterValues(scopesByComponent, subjectScopes);
@@ -134,7 +132,7 @@ private void validateScopeHierarchy(
         error.append("\n  ")
             .append(entry.getKey().componentDefinitionType().getQualifiedName())
             .append(" also has ")
-            .append(scope.getReadableSource());
+            .append(getReadableSource(scope));
       }
       report.addItem(
           error.toString(),
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index a7d680f2f..bebe6aa95 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -196,7 +196,7 @@ public SourceVersion getSupportedSourceVersion() {
     CanReleaseReferencesValidator canReleaseReferencesValidator =
         new CanReleaseReferencesValidator();
     ComponentHierarchyValidator componentHierarchyValidator =
-        new ComponentHierarchyValidator(compilerOptions, elements);
+        new ComponentHierarchyValidator(compilerOptions);
     BindingGraphValidator bindingGraphValidator =
         new BindingGraphValidator(
             elements,
diff --git a/java/dagger/internal/codegen/DelegateBindingExpression.java b/java/dagger/internal/codegen/DelegateBindingExpression.java
index 163d5a328..0a52a3258 100644
--- a/java/dagger/internal/codegen/DelegateBindingExpression.java
+++ b/java/dagger/internal/codegen/DelegateBindingExpression.java
@@ -20,10 +20,10 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.RequestKinds.requestType;
-import static dagger.internal.codegen.Scope.reusableScope;
 
 import com.squareup.javapoet.ClassName;
 import dagger.model.RequestKind;
+import dagger.model.Scope;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
@@ -128,7 +128,7 @@ static ScopeKind get(Binding binding, BindingGraph graph, Elements elements) {
       if (graph.scopesRequiringReleasableReferenceManagers().contains(scope)) {
         return RELEASABLE;
       }
-      return scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK;
+      return scope.isReusable() ? SINGLE_CHECK : DOUBLE_CHECK;
     }
 
     boolean isSimilarOrWeakerScopeThan(ScopeKind other) {
diff --git a/java/dagger/internal/codegen/DiagnosticFormatting.java b/java/dagger/internal/codegen/DiagnosticFormatting.java
new file mode 100644
index 000000000..8502ecb25
--- /dev/null
+++ b/java/dagger/internal/codegen/DiagnosticFormatting.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Utility methods for formatting diagnostics to the {@link javax.annotation.processing.Messager}.
+ */
+final class DiagnosticFormatting {
+
+  /**
+   * A regular expression to match a small list of specific packages deemed to be unhelpful to
+   * display in fully qualified types in error messages.
+   *
+   * <p>Note: This should never be applied to messages themselves.
+   */
+  private static final Pattern COMMON_PACKAGE_PATTERN =
+      Pattern.compile(
+          "(?:^|[^.a-z_])" // What we want to match on but not capture.
+              + "((?:" // Start a group with a non-capturing or part
+              + "java[.]lang"
+              + "|java[.]util"
+              + "|javax[.]inject"
+              + "|dagger"
+              + "|com[.]google[.]common[.]base"
+              + "|com[.]google[.]common[.]collect"
+              + ")[.])" // Always end with a literal .
+              + "[A-Z]"); // What we want to match on but not capture.
+
+  /**
+   * A method to strip out common packages and a few rare type prefixes from types' string
+   * representation before being used in error messages.
+   *
+   * <p>This type assumes a String value that is a valid fully qualified (and possibly
+   * parameterized) type, and should NOT be used with arbitrary text, especially prose error
+   * messages.
+   *
+   * <p>TODO(cgruber): Tighten these to take type representations (mirrors and elements) to avoid
+   * accidental mis-use by running errors through this method.
+   */
+  static String stripCommonTypePrefixes(String type) {
+    // Do regex magic to remove common packages we care to shorten.
+    Matcher matcher = COMMON_PACKAGE_PATTERN.matcher(type);
+    StringBuilder result = new StringBuilder();
+    int index = 0;
+    while (matcher.find()) {
+      result.append(type.subSequence(index, matcher.start(1)));
+      index = matcher.end(1); // Skip the matched pattern content.
+    }
+    result.append(type.subSequence(index, type.length()));
+    return result.toString();
+  }
+
+  private DiagnosticFormatting() {}
+}
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index af084f6db..520fb2b24 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -18,20 +18,20 @@
 
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
+import static dagger.internal.codegen.Scopes.getReadableSource;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toList;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
+import dagger.model.Scope;
 import dagger.multibindings.Multibinds;
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -379,12 +379,12 @@ static String referenceReleasingScopeNotInComponentHierarchy(
             + "annotated with %s. The available reference-releasing scopes are %s.",
         formattedKey,
         topLevelGraph.componentType().getQualifiedName(),
-        scope.getReadableSource(),
+        getReadableSource(scope),
         topLevelGraph
             .componentDescriptor()
             .releasableReferencesScopes()
             .stream()
-            .map(Scope::getReadableSource)
+            .map(Scopes::getReadableSource)
             .collect(toList()));
   }
 
@@ -399,7 +399,7 @@ static String referenceReleasingScopeNotAnnotatedWithMetadata(
       String formattedKey, Scope scope, TypeMirror metadataType) {
     return String.format(
         "There is no binding for %s because %s is not annotated with @%s.",
-        formattedKey, scope.getQualifiedName(), metadataType);
+        formattedKey, scope.scopeAnnotationElement().getQualifiedName(), metadataType);
   }
 
   /**
@@ -637,52 +637,9 @@ static String moduleSubcomponentsDoesntHaveBuilder(
     }
   }
 
-  /**
-   * A regular expression to match a small list of specific packages deemed to
-   * be unhelpful to display in fully qualified types in error messages.
-   *
-   * Note: This should never be applied to messages themselves.
-   */
-  private static final Pattern COMMON_PACKAGE_PATTERN = Pattern.compile(
-      "(?:^|[^.a-z_])"     // What we want to match on but not capture.
-      + "((?:"             // Start a group with a non-capturing or part
-      + "java[.]lang"
-      + "|java[.]util"
-      + "|javax[.]inject"
-      + "|dagger"
-      + "|com[.]google[.]common[.]base"
-      + "|com[.]google[.]common[.]collect"
-      + ")[.])"            // Always end with a literal .
-      + "[A-Z]");           // What we want to match on but not capture.
-
-  /**
-   * A method to strip out common packages and a few rare type prefixes
-   * from types' string representation before being used in error messages.
-   *
-   * This type assumes a String value that is a valid fully qualified
-   * (and possibly parameterized) type, and should NOT be used with
-   * arbitrary text, especially prose error messages.
-   *
-   * TODO(cgruber): Tighten these to take type representations (mirrors
-   *     and elements) to avoid accidental mis-use by running errors
-   *     through this method.
-   */
-  static String stripCommonTypePrefixes(String type) {
-    // Do regex magic to remove common packages we care to shorten.
-    Matcher matcher = COMMON_PACKAGE_PATTERN.matcher(type);
-    StringBuilder result = new StringBuilder();
-    int index = 0;
-    while (matcher.find()) {
-      result.append(type.subSequence(index, matcher.start(1)));
-      index = matcher.end(1); // Skip the matched pattern content.
-    }
-    result.append(type.subSequence(index, type.length()));
-    return result.toString();
-  }
-
   //TODO(cgruber): Extract Formatter and do something less stringy.
   static String format(AnnotationMirror annotation) {
-    return stripCommonTypePrefixes(annotation.toString());
+    return DiagnosticFormatting.stripCommonTypePrefixes(annotation.toString());
   }
 
   private ErrorMessages() {}
diff --git a/java/dagger/internal/codegen/ForReleasableReferencesValidator.java b/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
index b21b5e09e..48947ed17 100644
--- a/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
+++ b/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
@@ -22,8 +22,8 @@
 import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueCannotReleaseReferences;
 import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueNotAScope;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
-import static dagger.internal.codegen.Scope.isScope;
-import static dagger.internal.codegen.Scope.scope;
+import static dagger.internal.codegen.Scopes.scope;
+import static dagger.model.Scope.isScope;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreTypes;
diff --git a/java/dagger/internal/codegen/InjectValidator.java b/java/dagger/internal/codegen/InjectValidator.java
index 4230e3d2f..9eaa82a08 100644
--- a/java/dagger/internal/codegen/InjectValidator.java
+++ b/java/dagger/internal/codegen/InjectValidator.java
@@ -37,8 +37,8 @@
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
-import static dagger.internal.codegen.InjectionAnnotations.getScopes;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
+import static dagger.internal.codegen.Scopes.scopesOf;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -48,6 +48,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
+import dagger.model.Scope;
 import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
@@ -112,8 +113,8 @@ InjectValidator whenGeneratingCode() {
       builder.addError(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);
     }
 
-    for (AnnotationMirror scope : getScopes(constructorElement)) {
-      builder.addError(SCOPE_ON_INJECT_CONSTRUCTOR, constructorElement, scope);
+    for (Scope scope : scopesOf(constructorElement)) {
+      builder.addError(SCOPE_ON_INJECT_CONSTRUCTOR, constructorElement, scope.scopeAnnotation());
     }
 
     for (VariableElement parameter : constructorElement.getParameters()) {
@@ -164,10 +165,10 @@ InjectValidator whenGeneratingCode() {
       builder.addError(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
     }
 
-    ImmutableSet<? extends AnnotationMirror> scopes = getScopes(enclosingElement);
+    ImmutableSet<Scope> scopes = scopesOf(enclosingElement);
     if (scopes.size() > 1) {
-      for (AnnotationMirror scope : scopes) {
-        builder.addError(MULTIPLE_SCOPES, enclosingElement, scope);
+      for (Scope scope : scopes) {
+        builder.addError(MULTIPLE_SCOPES, enclosingElement, scope.scopeAnnotation());
       }
     }
 
diff --git a/java/dagger/internal/codegen/InjectionAnnotations.java b/java/dagger/internal/codegen/InjectionAnnotations.java
index c1d31bacc..b8f7809a4 100644
--- a/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -26,7 +26,6 @@
 import java.util.Optional;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
-import javax.inject.Scope;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
@@ -57,10 +56,6 @@
     return AnnotationMirrors.getAnnotatedAnnotations(element, Qualifier.class);
   }
 
-  static ImmutableSet<? extends AnnotationMirror> getScopes(Element element) {
-    return AnnotationMirrors.getAnnotatedAnnotations(element, Scope.class);
-  }
-
   /** Returns the constructors in {@code type} that are annotated with {@link Inject}. */
   static ImmutableSet<ExecutableElement> injectedConstructors(TypeElement type) {
     return FluentIterable.from(constructorsIn(type.getEnclosedElements()))
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
index 1fa2d4429..c616ec88e 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -38,6 +38,7 @@
 import dagger.BindsOptionalOf;
 import dagger.model.Key;
 import dagger.model.Key.MultibindingContributionIdentifier;
+import dagger.model.Scope;
 import dagger.multibindings.Multibinds;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
diff --git a/java/dagger/internal/codegen/MethodSignatureFormatter.java b/java/dagger/internal/codegen/MethodSignatureFormatter.java
index 45bb9ef15..66054ed43 100644
--- a/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -17,7 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 
 import com.google.auto.common.MoreElements;
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 02535c462..c71e91d81 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -25,7 +25,6 @@
 import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
 import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.PRIVATE_METHOD;
 import static dagger.internal.codegen.RequestKinds.requestType;
-import static dagger.internal.codegen.Scope.reusableScope;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.VOLATILE;
@@ -39,6 +38,7 @@
 import dagger.internal.MemoizedSentinel;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.RequestKind;
+import dagger.model.Scope;
 import java.util.EnumMap;
 import java.util.Map;
 import java.util.Optional;
@@ -208,7 +208,7 @@ private CodeBlock methodBody() {
       case INSTANCE:
         if (canInlineScope()) {
           Scope scope = resolvedBindings().scope().get();
-          return scope.equals(reusableScope(elements)) ? singleCheck() : doubleCheck();
+          return scope.isReusable() ? singleCheck() : doubleCheck();
         }
         // fall through
       default:
diff --git a/java/dagger/internal/codegen/ProducesMethodValidator.java b/java/dagger/internal/codegen/ProducesMethodValidator.java
index ee5386f11..715aacc13 100644
--- a/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -25,6 +25,7 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SCOPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.Scopes.scopesOf;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -75,7 +76,7 @@ private void checkNullable(ValidationReport.Builder<ExecutableElement> builder)
 
   /** Adds an error if a {@link Produces @Produces} method has a scope annotation. */
   private void checkScope(ValidationReport.Builder<ExecutableElement> builder) {
-    if (!Scope.scopesOf(builder.getSubject()).isEmpty()) {
+    if (!scopesOf(builder.getSubject()).isEmpty()) {
       builder.addError(PRODUCES_METHOD_SCOPE);
     }
   }
diff --git a/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java b/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
index 50dee233e..f9c388360 100644
--- a/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
+++ b/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
@@ -62,6 +62,7 @@
 import dagger.internal.InstanceFactory;
 import dagger.internal.TypedReleasableReferenceManagerDecorator;
 import dagger.model.Key;
+import dagger.model.Scope;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.releasablereferences.ForReleasableReferences;
@@ -576,7 +577,7 @@ private CodeBlock typedReleasableReferenceManagerDecoratorExpression(
   private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
     checkArgument(
         MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
-    return Scope.scope(
+    return Scopes.scope(
         MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
   }
 
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index 000d8de02..ecbfa0b52 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -25,6 +25,7 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
+import static dagger.internal.codegen.Scopes.uniqueScopeOf;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
 
@@ -41,6 +42,7 @@
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import dagger.model.Key;
 import dagger.model.RequestKind;
+import dagger.model.Scope;
 import java.util.Optional;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -200,7 +202,7 @@ ProvisionBinding forInjectConstructor(
               .provisionDependencies(provisionDependencies)
               .injectionSites(injectionSites)
               .bindingKind(Kind.INJECTION)
-              .scope(Scope.uniqueScopeOf(constructorElement.getEnclosingElement()));
+              .scope(uniqueScopeOf(constructorElement.getEnclosingElement()));
 
       TypeElement bindingTypeElement =
           MoreElements.asType(constructorElement.getEnclosingElement());
@@ -230,7 +232,7 @@ ProvisionBinding forProvidesMethod(
           .nullableType(ConfigurationAnnotations.getNullableType(providesMethod))
           .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(providesMethod)))
           .bindingKind(Kind.PROVISION)
-          .scope(Scope.uniqueScopeOf(providesMethod))
+          .scope(uniqueScopeOf(providesMethod))
           .build();
     }
 
@@ -281,7 +283,7 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           .key(keyFactory.forComponentMethod(componentMethod))
           .nullableType(ConfigurationAnnotations.getNullableType(componentMethod))
           .bindingKind(Kind.COMPONENT_PROVISION)
-          .scope(Scope.uniqueScopeOf(componentMethod))
+          .scope(uniqueScopeOf(componentMethod))
           .build();
     }
 
@@ -348,7 +350,7 @@ ProvisionBinding missingDelegate(DelegateDeclaration delegateDeclaration) {
           .provisionDependencies(delegateDeclaration.delegateRequest())
           .wrappedMapKey(delegateDeclaration.wrappedMapKey())
           .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
-          .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()));
+          .scope(uniqueScopeOf(delegateDeclaration.bindingElement().get()));
     }
 
     /**
diff --git a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
index d5a57c318..d915a70b2 100644
--- a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
+++ b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
@@ -30,6 +30,7 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
+import dagger.model.Scope;
 import java.util.HashMap;
 import java.util.Map;
 
diff --git a/java/dagger/internal/codegen/ResolvedBindings.java b/java/dagger/internal/codegen/ResolvedBindings.java
index 7d2ad6ff7..cef7c74a3 100644
--- a/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/java/dagger/internal/codegen/ResolvedBindings.java
@@ -32,6 +32,7 @@
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.internal.codegen.Keys.HasKey;
 import dagger.model.Key;
+import dagger.model.Scope;
 import java.util.Optional;
 
 /**
diff --git a/java/dagger/internal/codegen/Scope.java b/java/dagger/internal/codegen/Scope.java
deleted file mode 100644
index 9b5e797e3..000000000
--- a/java/dagger/internal/codegen/Scope.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
-import static dagger.internal.codegen.InjectionAnnotations.getScopes;
-
-import com.google.auto.common.AnnotationMirrors;
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import dagger.Reusable;
-import dagger.producers.ProductionScope;
-import dagger.releasablereferences.CanReleaseReferences;
-import java.lang.annotation.Annotation;
-import java.util.Optional;
-import javax.inject.Singleton;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-
-/** A javax.inject.Scope. */
-@AutoValue
-abstract class Scope {
-
-  /** The underlying {@link AnnotationMirror} that represents the scope annotation. */
-  abstract Equivalence.Wrapper<AnnotationMirror> scopeAnnotation();
-
-  /**
-   * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.
-   */
-  static Scope scope(AnnotationMirror scopeAnnotation) {
-    checkArgument(isScope(scopeAnnotation));
-    return new AutoValue_Scope(AnnotationMirrors.equivalence().wrap(scopeAnnotation));
-  }
-
-  /** Returns {@code true} if {@code scopeAnnotation} is a {@link javax.inject.Scope} annotation. */
-  static boolean isScope(AnnotationMirror scopeAnnotation) {
-    return isScope(MoreElements.asType(scopeAnnotation.getAnnotationType().asElement()));
-  }
-
-  /**
-   * Returns {@code true} if {@code scopeAnnotationType} is a {@link javax.inject.Scope} annotation.
-   */
-  static boolean isScope(TypeElement scopeAnnotationType) {
-    return isAnnotationPresent(scopeAnnotationType, javax.inject.Scope.class);
-  }
-  
-  /**
-   * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.
-   */
-  static Scope scope(TypeElement scopeType) {
-    return scope(SimpleAnnotationMirror.of(scopeType));
-  }
-
-  private static Scope scope(Elements elements, Class<? extends Annotation> scopeAnnotationClass) {
-    return scope(elements.getTypeElement(scopeAnnotationClass.getCanonicalName()));
-  }
-
-  /** Returns all of the associated scopes for a source code element. */
-  static ImmutableSet<Scope> scopesOf(Element element) {
-    return FluentIterable.from(getScopes(element)).transform(Scope::scope).toSet();
-  }
-
-  /**
-   * Returns at most one associated scoped annotation from the source code element, throwing an
-   * exception if there are more than one.
-   */
-  static Optional<Scope> uniqueScopeOf(Element element) {
-    ImmutableSet<? extends AnnotationMirror> scopeAnnotations = getScopes(element);
-    if (scopeAnnotations.isEmpty()) {
-      return Optional.empty();
-    }
-    return Optional.of(scope(Iterables.getOnlyElement(scopeAnnotations)));
-  }
-
-  /**
-   * Returns a representation for {@link ProductionScope @ProductionScope} scope.
-   */
-  static Scope productionScope(Elements elements) {
-    return scope(elements, ProductionScope.class);
-  }
-
-  /**
-   * Returns a representation for {@link Singleton @Singleton} scope.
-   */
-  static Scope singletonScope(Elements elements) {
-    return scope(elements, Singleton.class);
-  }
-
-  /**
-   * Returns a representation for {@link Reusable @Reusable} scope.
-   */
-  static Scope reusableScope(Elements elements) {
-    return scope(elements, Reusable.class);
-  }
-
-  /** Returns {@code true} if this scope is the {@link Reusable @Reusable} scope. */
-  boolean isReusable() {
-    return getQualifiedName().contentEquals(Reusable.class.getName());
-  }
-
-  /**
-   * Returns {@code true} for scopes that are annotated with {@link CanReleaseReferences} or some
-   * other annotation that is itself annotated with {@link CanReleaseReferences}.
-   *
-   * <p>Note that you need to check
-   * {@link BindingGraph#scopesRequiringReleasableReferenceManagers()} to see if a given binding
-   * graph actually binds a {@link dagger.releasablereferences.ReleasableReferenceManager} for this
-   * scope.
-   */
-  boolean canReleaseReferences() {
-    return isAnnotationPresent(scopeAnnotationElement(), CanReleaseReferences.class)
-        || !releasableReferencesMetadata().isEmpty();
-  }
-
-  /**
-   * Returns the set of annotations on the scope that are themselves annotated with {@link
-   * CanReleaseReferences}. These annotations are used as metadata for {@link
-   * dagger.releasablereferences.TypedReleasableReferenceManager}.
-   */
-  ImmutableSet<? extends AnnotationMirror> releasableReferencesMetadata() {
-    return getAnnotatedAnnotations(scopeAnnotationElement(), CanReleaseReferences.class);
-  }
-
-  /**
-   * Returns the {@linkplain #releasableReferencesMetadata() releasable references metadata}
-   * annotation of the given type, if there is one for this scope.
-   */
-  Optional<AnnotationMirror> releasableReferencesMetadata(TypeMirror metadataType) {
-    for (AnnotationMirror metadata : releasableReferencesMetadata()) {
-      if (MoreTypes.equivalence().equivalent(metadata.getAnnotationType(), metadataType)) {
-        return Optional.of(metadata);
-      }
-    }
-    return Optional.empty();
-  }
-
-  /**
-   * Returns the readable source representation (name with @ prefix) of the annotation type.
-   *
-   * <p>It's readable source because it has had common package prefixes removed, e.g.
-   * {@code @javax.inject.Singleton} is returned as {@code @Singleton}.
-   *
-   * <p>Does not return any annotation values, since {@link javax.inject.Scope @Scope}
-   * annotations are not supposed to have any.
-   */
-  public String getReadableSource() {
-    return stripCommonTypePrefixes("@" + getQualifiedName());
-  }
-
-  /**
-   * Returns the fully qualified name of the annotation type.
-   */
-  public String getQualifiedName() {
-    return scopeAnnotationElement().getQualifiedName().toString();
-  }
-
-  /**
-   * The scope annotation element.
-   */
-  public TypeElement scopeAnnotationElement() {
-    return MoreTypes.asTypeElement(scopeAnnotation().get().getAnnotationType());
-  }
-
-  /**
-   * Returns a debug representation of the scope.
-   */
-  @Override
-  public String toString() {
-    return scopeAnnotation().get().toString();
-  }
-}
diff --git a/java/dagger/internal/codegen/Scopes.java b/java/dagger/internal/codegen/Scopes.java
new file mode 100644
index 000000000..a6376dc34
--- /dev/null
+++ b/java/dagger/internal/codegen/Scopes.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.common.collect.ImmutableSet;
+import dagger.model.Scope;
+import dagger.producers.ProductionScope;
+import java.lang.annotation.Annotation;
+import java.util.Optional;
+import javax.inject.Singleton;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+
+/** Common names and convenience methods for {@link Scope}s. */
+final class Scopes {
+  /**
+   * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.
+   */
+  static Scope scope(TypeElement scopeType) {
+    return Scope.scope(SimpleAnnotationMirror.of(scopeType));
+  }
+
+  /** Returns a representation for {@link ProductionScope @ProductionScope} scope. */
+  static Scope productionScope(Elements elements) {
+    return scope(elements, ProductionScope.class);
+  }
+
+  /** Returns a representation for {@link Singleton @Singleton} scope. */
+  static Scope singletonScope(Elements elements) {
+    return scope(elements, Singleton.class);
+  }
+
+  private static Scope scope(Elements elements, Class<? extends Annotation> scopeAnnotationClass) {
+    return scope(elements.getTypeElement(scopeAnnotationClass.getCanonicalName()));
+  }
+
+  /**
+   * Returns at most one associated scoped annotation from the source code element, throwing an
+   * exception if there are more than one.
+   */
+  static Optional<Scope> uniqueScopeOf(Element element) {
+    // TODO(ronshapiro): Use MoreCollectors.toOptional() once we can use guava-jre
+    return Optional.ofNullable(getOnlyElement(scopesOf(element), null));
+  }
+
+  /**
+   * Returns the readable source representation (name with @ prefix) of the scope's annotation type.
+   *
+   * <p>It's readable source because it has had common package prefixes removed, e.g.
+   * {@code @javax.inject.Singleton} is returned as {@code @Singleton}.
+   *
+   * <p>Does not return any annotation values, since {@link javax.inject.Scope @Scope} annotations
+   * are not supposed to have any.
+   */
+  static String getReadableSource(Scope scope) {
+    return stripCommonTypePrefixes("@" + scope.scopeAnnotationElement().getQualifiedName());
+  }
+
+  /** Returns all of the associated scopes for a source code element. */
+  static ImmutableSet<Scope> scopesOf(Element element) {
+    return AnnotationMirrors.getAnnotatedAnnotations(element, javax.inject.Scope.class)
+        .stream()
+        .map(Scope::scope)
+        .collect(toImmutableSet());
+  }
+}
diff --git a/java/dagger/model/Scope.java b/java/dagger/model/Scope.java
new file mode 100644
index 000000000..8e8457724
--- /dev/null
+++ b/java/dagger/model/Scope.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.model;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.DoNotMock;
+import dagger.Reusable;
+import dagger.producers.ProductionScope;
+import dagger.releasablereferences.CanReleaseReferences;
+import java.lang.annotation.Annotation;
+import java.util.Optional;
+import javax.inject.Singleton;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+
+/** A representation of a {@link javax.inject.Scope}. */
+@AutoValue
+// TODO(ronshapiro): point to SimpleAnnotationMirror
+@DoNotMock("Use Scope.scope(AnnotationMirror) to create an instance")
+public abstract class Scope {
+  abstract Equivalence.Wrapper<AnnotationMirror> wrappedScopeAnnotation();
+
+  /** The {@link AnnotationMirror} that represents the scope annotation. */
+  public final AnnotationMirror scopeAnnotation() {
+    return wrappedScopeAnnotation().get();
+  }
+
+  /** The scope annotation element. */
+  public final TypeElement scopeAnnotationElement() {
+    return MoreTypes.asTypeElement(scopeAnnotation().getAnnotationType());
+  }
+
+  /**
+   * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.
+   */
+  public static Scope scope(AnnotationMirror scopeAnnotation) {
+    checkArgument(isScope(scopeAnnotation));
+    return new AutoValue_Scope(AnnotationMirrors.equivalence().wrap(scopeAnnotation));
+  }
+
+  /**
+   * Returns {@code true} if {@link #scopeAnnotation()} is a {@link javax.inject.Scope} annotation.
+   */
+  public static boolean isScope(AnnotationMirror scopeAnnotation) {
+    return isScope(MoreElements.asType(scopeAnnotation.getAnnotationType().asElement()));
+  }
+
+  /**
+   * Returns {@code true} if {@code scopeAnnotationType} is a {@link javax.inject.Scope} annotation.
+   */
+  public static boolean isScope(TypeElement scopeAnnotationType) {
+    return isAnnotationPresent(scopeAnnotationType, javax.inject.Scope.class);
+  }
+
+  /** Returns {@code true} if this scope is the {@link Singleton @Singleton} scope. */
+  public final boolean isSingleton() {
+    return isScope(Singleton.class);
+  }
+
+  /** Returns {@code true} if this scope is the {@link Reusable @Reusable} scope. */
+  public final boolean isReusable() {
+    return isScope(Reusable.class);
+  }
+
+  /** Returns {@code true} if this scope is the {@link ProductionScope @ProductionScope} scope. */
+  public final boolean isProductionScope() {
+    return isScope(ProductionScope.class);
+  }
+
+  private boolean isScope(Class<? extends Annotation> annotation) {
+    return scopeAnnotationElement().getQualifiedName().contentEquals(annotation.getCanonicalName());
+  }
+
+  /**
+   * Returns {@code true} for scopes that are annotated with {@link CanReleaseReferences} or some
+   * other annotation that is itself annotated with {@link CanReleaseReferences}.
+   */
+  // Implementation note: you need to check
+  // BindingGraph.scopesRequiringReleasableReferenceManagers() to see if a given binding graph
+  // actually binds a ReleasableReferenceManager for this scope.
+  public final boolean canReleaseReferences() {
+    return isAnnotationPresent(scopeAnnotationElement(), CanReleaseReferences.class)
+        || !releasableReferencesMetadata().isEmpty();
+  }
+
+  /**
+   * Returns the set of annotations on the scope that are themselves annotated with {@link
+   * CanReleaseReferences}. These annotations are used as metadata for {@link
+   * dagger.releasablereferences.TypedReleasableReferenceManager}.
+   */
+  public final ImmutableSet<AnnotationMirror> releasableReferencesMetadata() {
+    return ImmutableSet.copyOf(
+        getAnnotatedAnnotations(scopeAnnotationElement(), CanReleaseReferences.class));
+  }
+
+  /**
+   * Returns the {@linkplain #releasableReferencesMetadata() releasable references metadata}
+   * annotation of the given type, if there is one for this scope.
+   */
+  public final Optional<AnnotationMirror> releasableReferencesMetadata(TypeMirror metadataType) {
+    for (AnnotationMirror metadata : releasableReferencesMetadata()) {
+      if (MoreTypes.equivalence().equivalent(metadata.getAnnotationType(), metadataType)) {
+        return Optional.of(metadata);
+      }
+    }
+    return Optional.empty();
+  }
+
+  /** Returns a debug representation of the scope. */
+  @Override
+  public String toString() {
+    return scopeAnnotation().toString();
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ErrorMessagesTest.java b/javatests/dagger/internal/codegen/ErrorMessagesTest.java
index e7c392150..4d50d4413 100644
--- a/javatests/dagger/internal/codegen/ErrorMessagesTest.java
+++ b/javatests/dagger/internal/codegen/ErrorMessagesTest.java
@@ -26,6 +26,6 @@
 public class ErrorMessagesTest {
   @Test public void stripCommonTypePrefixes() {
     String typeName = "com.google.common.collect.ImmutableList<java.lang.Boolean>";
-    assertThat(ErrorMessages.stripCommonTypePrefixes(typeName)).isEqualTo("ImmutableList<Boolean>");
+    assertThat(DiagnosticFormatting.stripCommonTypePrefixes(typeName)).isEqualTo("ImmutableList<Boolean>");
   }
 }
