diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index 57f46899f..aec497e82 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -70,8 +70,11 @@
     unreachableNodes(traverser.network.asGraph(), rootComponentNode(traverser.network))
         .forEach(traverser.network::removeNode);
 
+    ComponentKind rootComponentKind = rootGraph.componentDescriptor().kind();
     return BindingGraphProxies.bindingGraph(
-        traverser.network, rootGraph.componentDescriptor().kind().isForModuleValidation());
+        traverser.network,
+        rootComponentKind.isForModuleValidation(),
+        !rootComponentKind.isTopLevel());
   }
 
   // TODO(dpb): Example of BindingGraph logic applied to derived networks.
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 6f3062726..748fd1bbb 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -291,7 +291,7 @@ private ModuleDescriptor descriptorForProductionExecutorModule() {
         ImmutableSetMultimap<Key, SubcomponentDeclaration> subcomponentDeclarations,
         ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations,
         ImmutableSetMultimap<Key, OptionalBindingDeclaration> optionalBindingDeclarations) {
-      this.parentResolver = checkNotNull(parentResolver);
+      this.parentResolver = parentResolver;
       this.componentDescriptor = checkNotNull(componentDescriptor);
       this.explicitBindings = checkNotNull(explicitBindings);
       this.explicitBindingsSet = ImmutableSet.copyOf(explicitBindings.values());
@@ -371,7 +371,9 @@ ResolvedBindings lookUpBindings(Key requestKey) {
 
       // If there are no bindings, add the implicit @Inject-constructed binding if there is one.
       if (bindings.isEmpty()) {
-        injectBindingRegistry.getOrFindProvisionBinding(requestKey).ifPresent(bindings::add);
+        injectBindingRegistry.getOrFindProvisionBinding(requestKey)
+            .filter(binding -> !isIncorrectlyScopedInPartialGraph(binding))
+            .ifPresent(bindings::add);
       }
 
       return ResolvedBindings.forContributionBindings(
@@ -383,6 +385,26 @@ ResolvedBindings lookUpBindings(Key requestKey) {
           optionalBindingDeclarations);
     }
 
+    /**
+     * Returns true if this binding graph resolution is for a partial graph and the {@code @Inject}
+     * binding's scope doesn't match any of the components in the current component ancestry. If so,
+     * the binding is not owned by any of the currently known components, and will be owned by a
+     * future ancestor (or, if never owned, will result in an incompatibly scoped binding error at
+     * the root component).
+     */
+    private boolean isIncorrectlyScopedInPartialGraph(ProvisionBinding binding) {
+      checkArgument(binding.kind().equals(INJECTION));
+      Resolver owningResolver = getOwningResolver(binding).orElse(this);
+      ComponentDescriptor owningComponent = owningResolver.componentDescriptor;
+      return !rootComponent().kind().isTopLevel()
+          && binding.scope().isPresent()
+          && !owningComponent.scopes().contains(binding.scope().get());
+    }
+
+    private ComponentDescriptor rootComponent() {
+      return parentResolver.map(Resolver::rootComponent).orElse(componentDescriptor);
+    }
+
     /** Returns the resolved members injection bindings for the given {@link Key}. */
     ResolvedBindings lookUpMembersInjectionBinding(Key requestKey) {
       // no explicit deps for members injection, so just look it up
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 4d10b3ab5..2a6397241 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -146,8 +146,9 @@ protected void process(
       }
       ComponentDescriptor componentDescriptor = componentDescriptorFactory.forTypeElement(element);
       BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-      // TODO(b/72748365): Do subgraph validation.
-      generateComponent(bindingGraph);
+      if (isValid(bindingGraph)) {
+        generateComponent(bindingGraph);
+      }
     }
   }
 
diff --git a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
index 60a40adc5..984b686e1 100644
--- a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
+++ b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
@@ -70,8 +70,8 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
                 ComponentNode componentNode =
                     bindingGraph.componentNode(binding.componentPath()).get();
                 if (!componentNode.scopes().contains(scope)) {
-                  // @Inject bindings in for module binding graphs will appear at the properly
-                  // scoped ancestor component, so ignore them here.
+                  // @Inject bindings in module binding graphs will appear at the properly scoped
+                  // ancestor component, so ignore them here.
                   if (binding.kind().equals(INJECTION) && bindingGraph.isModuleBindingGraph()) {
                     return;
                   }
diff --git a/java/dagger/internal/codegen/MissingBindingValidator.java b/java/dagger/internal/codegen/MissingBindingValidator.java
index ddd71c16e..dd2f6e3b1 100644
--- a/java/dagger/internal/codegen/MissingBindingValidator.java
+++ b/java/dagger/internal/codegen/MissingBindingValidator.java
@@ -54,8 +54,8 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
-    if (graph.isModuleBindingGraph()) {
-      return; // Don't report missing bindings when validating a module.
+    if (graph.isModuleBindingGraph() || graph.isPartialBindingGraph()) {
+      return; // Don't report missing bindings when validating a module or a partial binding graph
     }
     graph
         .missingBindings()
diff --git a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
index f0dea0994..c29aa69e5 100644
--- a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
+++ b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
@@ -61,7 +61,7 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    if (bindingGraph.isModuleBindingGraph()) {
+    if (bindingGraph.isModuleBindingGraph() || bindingGraph.isPartialBindingGraph()) {
       // We don't know all the modules that might be owned by the child until we know the root.
       return;
     }
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 74f51a2c1..65e0bac1d 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -90,8 +90,10 @@
 @AutoValue
 public abstract class BindingGraph {
 
-  static BindingGraph create(Network<Node, Edge> network, boolean isModuleBindingGraph) {
-    return new AutoValue_BindingGraph(ImmutableNetwork.copyOf(network), isModuleBindingGraph);
+  static BindingGraph create(
+      Network<Node, Edge> network, boolean isModuleBindingGraph, boolean isPartialBindingGraph) {
+    return new AutoValue_BindingGraph(
+        ImmutableNetwork.copyOf(network), isModuleBindingGraph, isPartialBindingGraph);
   }
 
   BindingGraph() {}
@@ -110,8 +112,16 @@ public final String toString() {
    * @see <a href="https://google.github.io/dagger/compiler-options#module-binding-validation">Module binding
    *     validation</a>
    */
+  // TODO(dpb): Figure out the relationship between this and isPartialBindingGraph(). Maybe this
+  // implies that?
   public abstract boolean isModuleBindingGraph();
 
+  /**
+   * Returns {@code true} if this graph was constructed with a root subcomponent in ahead-of-time
+   * subcomponents mode.
+   */
+  public abstract boolean isPartialBindingGraph();
+
   /** Returns the bindings. */
   public final ImmutableSet<Binding> bindings() {
     return nodes(Binding.class);
diff --git a/java/dagger/model/BindingGraphProxies.java b/java/dagger/model/BindingGraphProxies.java
index 4d514f328..cd7080636 100644
--- a/java/dagger/model/BindingGraphProxies.java
+++ b/java/dagger/model/BindingGraphProxies.java
@@ -29,8 +29,8 @@
 public final class BindingGraphProxies {
   /** Creates a new {@link BindingGraph}. */
   public static BindingGraph bindingGraph(
-      Network<Node, Edge> network, boolean isModuleBindingGraph) {
-    return BindingGraph.create(network, isModuleBindingGraph);
+      Network<Node, Edge> network, boolean isModuleBindingGraph, boolean isPartialBindingGraph) {
+    return BindingGraph.create(network, isModuleBindingGraph, isPartialBindingGraph);
   }
 
   /** Creates a new {@link MissingBinding}. */
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index ea013ffcf..e27bfbbfc 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -6979,6 +6979,93 @@ public void subcomponentInducedFromAncestor() {
         .hasSourceEquivalentTo(generatedAncestor);
   }
 
+  @Test
+  public void rootScopedAtInjectConstructor_effectivelyMissingInSubcomponent() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "ProvidesMethodRootScoped");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.RootScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "public @interface RootScope {}"),
+        JavaFileObjects.forSourceLines(
+            "test.AtInjectRootScoped",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "@RootScope",
+            "class AtInjectRootScoped {",
+            "  @Inject AtInjectRootScoped() {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  AtInjectRootScoped shouldBeEffectivelyMissingInLeaf();",
+            "}"));
+
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@RootScope",
+            "@Component",
+            "interface Root {",
+            "  Leaf leaf();",
+            "}"));
+
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  protected final class LeafImpl extends DaggerLeaf {",
+            "    @Override",
+            "    public AtInjectRootScoped shouldBeEffectivelyMissingInLeaf() {",
+            "      return DaggerRoot.this.atInjectRootScopedProvider.get();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .containsElementsIn(generatedRoot);
+  }
+
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
     for (String className : ancillaryClasses) {
