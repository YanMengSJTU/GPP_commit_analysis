diff --git a/README.md b/README.md
index 8a9c90b60..2de25f580 100644
--- a/README.md
+++ b/README.md
@@ -14,7 +14,7 @@ removing the traditional ObjectGraph/Injector in favor of user-specified
 
 This github project represents the Dagger 2 development stream.  The earlier
 [project page][square] (Square, Inc's repository) represents the earlier 1.0
-development stream. Both versions have benefitted from strong involvement from
+development stream. Both versions have benefited from strong involvement from
 Square, Google, and other contributors.
 
 Dagger is currently in active development, primarily internally at Google,
diff --git a/java/dagger/android/AndroidInjectionKey.java b/java/dagger/android/AndroidInjectionKey.java
new file mode 100644
index 000000000..d4a5d72c2
--- /dev/null
+++ b/java/dagger/android/AndroidInjectionKey.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+/**
+ * {@link MapKey} annotation to key {@link AndroidInjector.Factory} bindings. The {@linkplain
+ * #value() value} of the annotation is the canonical name of the class that will be passed to
+ * {@link AndroidInjector#inject(Object)}.
+ *
+ * <p>All key strings will be obfuscated by ProGuard/R8/AppReduce if the named class is obfuscated.
+ *
+ * <p>
+ * You should only use this annotation if you are using a version of ProGuard/R8/AppReduce that
+ * supports the {@code -identifiernamestring} flag.
+ */
+@Beta
+@MapKey
+@Target(METHOD)
+@Documented
+public @interface AndroidInjectionKey {
+  /** The fully qualified class name of the type to be injected. */
+  String value();
+}
diff --git a/java/dagger/android/AndroidInjectionModule.java b/java/dagger/android/AndroidInjectionModule.java
index 224e07f71..05f1adae3 100644
--- a/java/dagger/android/AndroidInjectionModule.java
+++ b/java/dagger/android/AndroidInjectionModule.java
@@ -38,23 +38,42 @@
   abstract Map<Class<? extends Activity>, AndroidInjector.Factory<? extends Activity>>
       activityInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Activity>>
+      activityInjectorFactoriesWithStringKeys();
+
   @Multibinds
   abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
       fragmentInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Fragment>>
+      fragmentInjectorFactoriesWithStringKeys();
+
   @Multibinds
   abstract Map<Class<? extends Service>, AndroidInjector.Factory<? extends Service>>
       serviceInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Service>>
+      serviceInjectorFactoriesWithStringKeys();
+
   @Multibinds
   abstract Map<
           Class<? extends BroadcastReceiver>, AndroidInjector.Factory<? extends BroadcastReceiver>>
       broadcastReceiverInjectorFactories();
 
   @Multibinds
-  abstract Map<
-          Class<? extends ContentProvider>, AndroidInjector.Factory<? extends ContentProvider>>
+  abstract Map<String, AndroidInjector.Factory<? extends BroadcastReceiver>>
+      broadcastReceiverInjectorFactoriesWithStringKeys();
+
+  @Multibinds
+  abstract Map<Class<? extends ContentProvider>, AndroidInjector.Factory<? extends ContentProvider>>
       contentProviderInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends ContentProvider>>
+      contentProviderInjectorFactoriesWithStringKeys();
+
   private AndroidInjectionModule() {}
 }
diff --git a/java/dagger/android/BUILD b/java/dagger/android/BUILD
index cb2aa8c17..6dfa1c5e3 100644
--- a/java/dagger/android/BUILD
+++ b/java/dagger/android/BUILD
@@ -27,7 +27,10 @@ load("//tools:maven.bzl", "pom_file", "POM_VERSION")
 
 # Work around b/70476182 which prevents Kythe from connecting :producers to the .java files it
 # contains.
-SRCS = glob(["*.java"])
+SRCS = glob([
+    "*.java",
+    "internal/*.java",
+])
 
 filegroup(
     name = "android-srcs",
@@ -82,6 +85,7 @@ javadoc_library(
     name = "android-javadoc",
     srcs = [":android-srcs"],
     android_api_level = 26,
+    exclude_packages = ["dagger.android.internal"],
     root_packages = ["dagger.android"],
     deps = [":android"],
 )
diff --git a/java/dagger/android/DispatchingAndroidInjector.java b/java/dagger/android/DispatchingAndroidInjector.java
index 3c9b7775b..9b011dd13 100644
--- a/java/dagger/android/DispatchingAndroidInjector.java
+++ b/java/dagger/android/DispatchingAndroidInjector.java
@@ -16,6 +16,7 @@
 
 package dagger.android;
 
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
 import static dagger.internal.Preconditions.checkNotNull;
 
 import android.app.Activity;
@@ -26,6 +27,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import javax.inject.Inject;
 import javax.inject.Provider;
 
@@ -47,13 +49,39 @@
       "No injector factory bound for Class<%1$s>. Injector factories were bound for supertypes "
           + "of %1$s: %2$s. Did you mean to bind an injector factory for the subtype?";
 
-  private final Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>>
-      injectorFactories;
+  private final Map<String, Provider<AndroidInjector.Factory<? extends T>>> injectorFactories;
 
   @Inject
   DispatchingAndroidInjector(
-      Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>> injectorFactories) {
-    this.injectorFactories = injectorFactories;
+      Map<Class<? extends T>, Provider<Factory<? extends T>>> injectorFactoriesWithClassKeys,
+      Map<String, Provider<Factory<? extends T>>> injectorFactoriesWithStringKeys) {
+    this.injectorFactories = merge(injectorFactoriesWithClassKeys, injectorFactoriesWithStringKeys);
+  }
+
+  /**
+   * Merges the two maps into one by transforming the values of the {@code classKeyedMap} with
+   * {@link Class#getName()}.
+   *
+   * <p>An SPI plugin verifies the logical uniqueness of the keysets of these two maps so we're
+   * assured there's no overlap.
+   *
+   * <p>Ideally we could achieve this with a generic {@code @Provides} method, but we'd need to have
+   * <i>N</i> modules that each extend one base module.
+   */
+  private static <C, V> Map<String, V> merge(
+      Map<Class<? extends C>, V> classKeyedMap, Map<String, V> stringKeyedMap) {
+    if (classKeyedMap.isEmpty()) {
+      return stringKeyedMap;
+    }
+
+    Map<String, V> merged =
+        newLinkedHashMapWithExpectedSize(classKeyedMap.size() + stringKeyedMap.size());
+    merged.putAll(stringKeyedMap);
+    for (Entry<Class<? extends C>, V> entry : classKeyedMap.entrySet()) {
+      merged.put(entry.getKey().getName(), entry.getValue());
+    }
+
+    return Collections.unmodifiableMap(merged);
   }
 
   /**
@@ -66,7 +94,7 @@
   @CanIgnoreReturnValue
   public boolean maybeInject(T instance) {
     Provider<AndroidInjector.Factory<? extends T>> factoryProvider =
-        injectorFactories.get(instance.getClass());
+        injectorFactories.get(instance.getClass().getName());
     if (factoryProvider == null) {
       return false;
     }
@@ -119,13 +147,12 @@ public void inject(T instance) {
 
   /** Returns an error message with the class names that are supertypes of {@code instance}. */
   private String errorMessageSuggestions(T instance) {
-    List<String> suggestions = new ArrayList<String>();
-    for (Class<? extends T> activityClass : injectorFactories.keySet()) {
-      if (activityClass.isInstance(instance)) {
-        suggestions.add(activityClass.getCanonicalName());
+    List<String> suggestions = new ArrayList<>();
+    for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {
+      if (injectorFactories.containsKey(clazz.getCanonicalName())) {
+        suggestions.add(clazz.getCanonicalName());
       }
     }
-    Collections.sort(suggestions);
 
     return suggestions.isEmpty()
         ? String.format(NO_SUPERTYPES_BOUND_FORMAT, instance.getClass().getCanonicalName())
diff --git a/java/dagger/android/internal/AndroidInjectionKeys.java b/java/dagger/android/internal/AndroidInjectionKeys.java
new file mode 100644
index 000000000..f30b92cdd
--- /dev/null
+++ b/java/dagger/android/internal/AndroidInjectionKeys.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.internal;
+
+/**
+ * An internal implementation detail of Dagger's generated code. This is not guaranteed to remain
+ * consistent from version to version.
+ */
+public final class AndroidInjectionKeys {
+  /**
+   * Accepts the fully qualified name of a class that is injected with {@code dagger.android}.
+   *
+   * <p>From a runtime perspective, this method does nothing except return its single argument. It
+   * is used as a signal to bytecode shrinking tools that its argument should be rewritten if it
+   * corresponds to a class that has been obfuscated/relocated. Once it is done so, it is expected
+   * that the argument will be inlined and this method will go away.
+   */
+  public static String of(String mapKey) {
+    return mapKey;
+  }
+
+  private AndroidInjectionKeys() {}
+}
diff --git a/java/dagger/android/processor/AndroidMapKeyValidator.java b/java/dagger/android/processor/AndroidMapKeyValidator.java
index a6c8a80f0..4084ff4e2 100644
--- a/java/dagger/android/processor/AndroidMapKeyValidator.java
+++ b/java/dagger/android/processor/AndroidMapKeyValidator.java
@@ -17,11 +17,11 @@
 package dagger.android.processor;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.android.processor.AndroidMapKeys.annotationsAndFrameworkTypes;
+import static dagger.android.processor.AndroidMapKeys.injectedTypeFromMapKey;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
@@ -29,6 +29,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.Binds;
+import dagger.android.AndroidInjectionKey;
 import dagger.android.AndroidInjector;
 import java.lang.annotation.Annotation;
 import java.util.Set;
@@ -62,7 +63,10 @@
 
   @Override
   public Set<? extends Class<? extends Annotation>> annotations() {
-    return annotationsAndFrameworkTypes(elements).keySet();
+    return ImmutableSet.<Class<? extends Annotation>>builder()
+        .addAll(annotationsAndFrameworkTypes(elements).keySet())
+        .add(AndroidInjectionKey.class)
+        .build();
   }
 
   @Override
@@ -84,7 +88,7 @@ private void validateMethod(Class<? extends Annotation> annotation, ExecutableEl
       return;
     }
 
-    TypeMirror frameworkType = annotationsAndFrameworkTypes(elements).get(annotation);
+    TypeMirror frameworkType = frameworkTypeForMapKey(method, annotation);
 
     if (!getAnnotatedAnnotations(method, Scope.class).isEmpty()) {
       SuppressWarnings suppressedWarnings = method.getAnnotation(SuppressWarnings.class);
@@ -102,11 +106,16 @@ private void validateMethod(Class<? extends Annotation> annotation, ExecutableEl
 
     DeclaredType intendedReturnType = injectorFactoryOf(types.getWildcardType(frameworkType, null));
     if (!MoreTypes.equivalence().equivalent(returnType, intendedReturnType)) {
+      String subject =
+          annotation.equals(AndroidInjectionKey.class)
+              ? method.toString()
+              : String.format("@%s methods", annotation.getCanonicalName());
+
       messager.printMessage(
           Kind.ERROR,
           String.format(
-              "@%s methods should bind %s, not %s. See https://google.github.io/dagger/android",
-              annotation.getCanonicalName(), intendedReturnType, returnType),
+              "%s should bind %s, not %s. See https://google.github.io/dagger/android",
+              subject, intendedReturnType, returnType),
           method);
     }
 
@@ -135,16 +144,30 @@ private void validateMapKeyMatchesBindsParameter(
       Class<? extends Annotation> annotation, ExecutableElement method) {
     TypeMirror parameterType = getOnlyElement(method.getParameters()).asType();
     AnnotationMirror annotationMirror = getAnnotationMirror(method, annotation).get();
-    TypeMirror mapKeyValue = (TypeMirror) getAnnotationValue(annotationMirror, "value").getValue();
-    if (!types.isAssignable(parameterType, injectorFactoryOf(mapKeyValue))) {
+    TypeMirror mapKeyType =
+        elements.getTypeElement(injectedTypeFromMapKey(annotationMirror).get()).asType();
+    if (!types.isAssignable(parameterType, injectorFactoryOf(mapKeyType))) {
       messager.printMessage(
           Kind.ERROR,
-          String.format("%s does not implement AndroidInjector<%s>", parameterType, mapKeyValue),
+          String.format("%s does not implement AndroidInjector<%s>", parameterType, mapKeyType),
           method,
           annotationMirror);
     }
   }
 
+  private TypeMirror frameworkTypeForMapKey(
+      ExecutableElement method, Class<? extends Annotation> annotation) {
+    AnnotationMirror annotationMirror = getAnnotationMirror(method, annotation).get();
+    TypeMirror mapKeyType =
+        elements.getTypeElement(injectedTypeFromMapKey(annotationMirror).get()).asType();
+    return annotationsAndFrameworkTypes(elements)
+        .values()
+        .stream()
+        .filter(frameworkType -> types.isAssignable(mapKeyType, frameworkType))
+        .findFirst()
+        .get();
+  }
+
   /** Returns a {@link DeclaredType} for {@code AndroidInjector.Factory<implementationType>}. */
   private DeclaredType injectorFactoryOf(TypeMirror implementationType) {
     return types.getDeclaredType(factoryElement(), implementationType);
diff --git a/java/dagger/android/processor/AndroidMapKeys.java b/java/dagger/android/processor/AndroidMapKeys.java
index 61eee8e75..64682070a 100644
--- a/java/dagger/android/processor/AndroidMapKeys.java
+++ b/java/dagger/android/processor/AndroidMapKeys.java
@@ -16,6 +16,7 @@
 
 package dagger.android.processor;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static java.util.stream.Collectors.toMap;
@@ -25,9 +26,12 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableMap;
 import dagger.MapKey;
+import dagger.android.AndroidInjectionKey;
 import java.lang.annotation.Annotation;
 import java.util.List;
+import java.util.Optional;
 import java.util.stream.Stream;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
@@ -50,12 +54,17 @@
                 elements.getPackageElement("dagger.android.support"))
             .filter(packageElement -> packageElement != null)
             .flatMap(packageElement -> typesIn(packageElement.getEnclosedElements()).stream())
+            .filter(AndroidMapKeys::isNotAndroidInjectionKey)
             .filter(type -> isAnnotationPresent(type, MapKey.class))
             .filter(mapKey -> mapKey.getAnnotation(MapKey.class).unwrapValue())
             .flatMap(AndroidMapKeys::classForAnnotationElement)
             .collect(toMap(key -> key, key -> mapKeyValue(key, elements))));
   }
 
+  private static boolean isNotAndroidInjectionKey(TypeElement type) {
+    return !type.getQualifiedName().contentEquals(AndroidInjectionKey.class.getCanonicalName());
+  }
+
   private static Stream<Class<? extends Annotation>> classForAnnotationElement(TypeElement type) {
     try {
       @SuppressWarnings("unchecked")
@@ -75,4 +84,21 @@ private static TypeMirror mapKeyValue(Class<? extends Annotation> annotation, El
     return ((WildcardType) getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments()))
         .getExtendsBound();
   }
+
+  /**
+   * If {@code mapKey} is {@link AndroidInjectionKey}, returns the string value for the map key. If
+   * it's {@link dagger.android.ActivityKey} or one of the other class-based keys, returns the
+   * fully-qualified class name of the annotation value. Otherwise returns {@link Optional#empty()}.
+   */
+  static Optional<String> injectedTypeFromMapKey(AnnotationMirror mapKey) {
+    Object mapKeyClass = getAnnotationValue(mapKey, "value").getValue();
+    if (mapKeyClass instanceof String) {
+      return Optional.of((String) mapKeyClass);
+    } else if (mapKeyClass instanceof TypeMirror) {
+      TypeElement type = MoreTypes.asTypeElement((TypeMirror) mapKeyClass);
+      return Optional.of(type.getQualifiedName().toString());
+    } else {
+      return Optional.empty();
+    }
+  }
 }
diff --git a/java/dagger/android/processor/AndroidProcessor.java b/java/dagger/android/processor/AndroidProcessor.java
index 5db7fabeb..c46817018 100644
--- a/java/dagger/android/processor/AndroidProcessor.java
+++ b/java/dagger/android/processor/AndroidProcessor.java
@@ -16,13 +16,23 @@
 
 package dagger.android.processor;
 
+import static javax.tools.Diagnostic.Kind.ERROR;
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
+
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
+import com.google.common.base.Ascii;
+import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.googlejavaformat.java.filer.FormattingFiler;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -30,9 +40,22 @@
 /**
  * An {@linkplain javax.annotation.processing.Processor annotation processor} to verify usage of
  * {@code dagger.android} code.
+ *
+ * <p>Additionally, if {@code -Adagger.android.experimentalUseStringKeys} is passed to the
+ * compilation, a file will be generated to support obfuscated injected Android types used with
+ * {@code @AndroidInjectionKey}. The fact that this is generated is deliberate: not all versions of
+ * ProGuard/R8 support {@code -identifiernamestring}, so we can't include a ProGuard file in the
+ * dagger-android artifact Instead, we generate the file in {@code META-INF/proguard} only when
+ * users enable the flag. They should only be enabling it if their shrinker supports those files,
+ * and any version that does so will also support {@code -identifiernamestring}. This was added to
+ * R8 in <a href="https://r8.googlesource.com/r8/+/389123dfcc11e6dda0eec31ab62e1b7eb0da80d2">May
+ * 2018</a>.
  */
 @AutoService(Processor.class)
 public final class AndroidProcessor extends BasicAnnotationProcessor {
+  private static final String FLAG_EXPERIMENTAL_USE_STRING_KEYS =
+      "dagger.android.experimentalUseStringKeys";
+
   @Override
   protected Iterable<? extends ProcessingStep> initSteps() {
     Filer filer = new FormattingFiler(processingEnv.getFiler());
@@ -44,11 +67,61 @@
         new AndroidMapKeyValidator(elements, types, messager),
         new ContributesAndroidInjectorGenerator(
             new AndroidInjectorDescriptor.Validator(types, elements, messager),
+            useStringKeys(),
             filer,
             elements,
             processingEnv.getSourceVersion()));
   }
 
+  private boolean useStringKeys() {
+    if (!processingEnv.getOptions().containsKey(FLAG_EXPERIMENTAL_USE_STRING_KEYS)) {
+      return false;
+    }
+    String flagValue = processingEnv.getOptions().get(FLAG_EXPERIMENTAL_USE_STRING_KEYS);
+    if (flagValue == null || Ascii.equalsIgnoreCase(flagValue, "true")) {
+      return true;
+    } else if (Ascii.equalsIgnoreCase(flagValue, "false")) {
+      return false;
+    } else {
+      processingEnv
+          .getMessager()
+          .printMessage(
+              ERROR,
+              String.format(
+                  "Unknown flag value: %s. %s must be set to either 'true' or 'false'.",
+                  flagValue, FLAG_EXPERIMENTAL_USE_STRING_KEYS));
+      return false;
+    }
+  }
+
+  @Override
+  protected void postRound(RoundEnvironment roundEnv) {
+    if (roundEnv.processingOver() && useStringKeys()) {
+      try (Writer writer = createProguardFile()){
+        writer.write(
+            Joiner.on("\n")
+                .join(
+                    "-identifiernamestring class dagger.android.internal.AndroidInjectionKeys {",
+                    "  java.lang.String of(java.lang.String);",
+                    "}"));
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }
+  }
+
+  private Writer createProguardFile() throws IOException {
+    return processingEnv
+        .getFiler()
+        .createResource(CLASS_OUTPUT, "", "META-INF/proguard/dagger.android.AndroidInjectionKeys")
+        .openWriter();
+  }
+
+  @Override
+  public Set<String> getSupportedOptions() {
+    return ImmutableSet.of(FLAG_EXPERIMENTAL_USE_STRING_KEYS);
+  }
+
   @Override
   public SourceVersion getSupportedSourceVersion() {
     return SourceVersion.latestSupported();
diff --git a/java/dagger/android/processor/BUILD b/java/dagger/android/processor/BUILD
index 565b1b8a3..94caad6a1 100644
--- a/java/dagger/android/processor/BUILD
+++ b/java/dagger/android/processor/BUILD
@@ -42,6 +42,8 @@ java_library(
         "@google_bazel_common//third_party/java/javapoet",
         "@google_bazel_common//third_party/java/google_java_format",
         "//java/dagger:core",
+        "//java/dagger/model",
+        "//java/dagger/spi",
         # https://github.com/bazelbuild/bazel/issues/2517
         ":dagger-android-jars",
     ],
diff --git a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
index 2d1023abc..57404764c 100644
--- a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
+++ b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
@@ -46,6 +46,7 @@
 import dagger.Module;
 import dagger.Subcomponent;
 import dagger.Subcomponent.Builder;
+import dagger.android.AndroidInjectionKey;
 import dagger.android.AndroidInjector;
 import dagger.android.ContributesAndroidInjector;
 import dagger.android.processor.AndroidInjectorDescriptor.Validator;
@@ -65,12 +66,18 @@
   private final AndroidInjectorDescriptor.Validator validator;
   private final Filer filer;
   private final Elements elements;
+  private final boolean useStringKeys;
   private final SourceVersion sourceVersion;
 
   ContributesAndroidInjectorGenerator(
-      Validator validator, Filer filer, Elements elements, SourceVersion sourceVersion) {
-    this.filer = filer;
+      Validator validator,
+      boolean useStringKeys,
+      Filer filer,
+      Elements elements,
+      SourceVersion sourceVersion) {
     this.validator = validator;
+    this.useStringKeys = useStringKeys;
+    this.filer = filer;
     this.elements = elements;
     this.sourceVersion = sourceVersion;
   }
@@ -131,10 +138,7 @@ private MethodSpec bindAndroidInjectorFactory(
     return methodBuilder("bindAndroidInjectorFactory")
         .addAnnotation(Binds.class)
         .addAnnotation(IntoMap.class)
-        .addAnnotation(
-            AnnotationSpec.builder(descriptor.mapKeyType())
-                .addMember("value", "$T.class", descriptor.injectedType())
-                .build())
+        .addAnnotation(androidInjectorMapKey(descriptor))
         .addModifiers(ABSTRACT)
         .returns(
             parameterizedTypeName(
@@ -144,6 +148,17 @@ private MethodSpec bindAndroidInjectorFactory(
         .build();
   }
 
+  private AnnotationSpec androidInjectorMapKey(AndroidInjectorDescriptor descriptor) {
+    if (useStringKeys) {
+      return AnnotationSpec.builder(AndroidInjectionKey.class)
+          .addMember("value", "$S", descriptor.injectedType().toString())
+          .build();
+    }
+    return AnnotationSpec.builder(descriptor.mapKeyType())
+        .addMember("value", "$T.class", descriptor.injectedType())
+        .build();
+  }
+
   private TypeSpec subcomponent(
       AndroidInjectorDescriptor descriptor,
       ClassName subcomponentName,
diff --git a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
new file mode 100644
index 000000000..0e08debb3
--- /dev/null
+++ b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.android.processor.AndroidMapKeys.injectedTypeFromMapKey;
+import static java.util.stream.Collectors.collectingAndThen;
+import static java.util.stream.Collectors.toList;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
+import dagger.MapKey;
+import dagger.android.AndroidInjector;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingKind;
+import dagger.model.Key;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.Formatter;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.stream.Stream;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * Validates that the two maps that {@link DispatchingAndroidInjector} injects have logically
+ * different keys. If a contribution exists for the same {@code FooActivity} with
+ * {@code @ActivityKey(FooActivity.class)} and
+ * {@code @AndroidInjectionKey("com.example.FooActivity")}, report an error.
+ */
+@AutoService(BindingGraphPlugin.class)
+public final class DuplicateAndroidInjectorsChecker implements BindingGraphPlugin {
+  private Types types;
+  private Elements elements;
+
+  @Override
+  public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
+    for (BindingNode node : graph.bindingNodes()) {
+      if (isDispatchingAndroidInjector(node)) {
+        validateMapKeyUniqueness(node, graph, diagnosticReporter);
+      }
+    }
+  }
+
+  private boolean isDispatchingAndroidInjector(BindingNode node) {
+    Key key = node.binding().key();
+    return MoreTypes.isTypeOf(DispatchingAndroidInjector.class, key.type())
+        && !key.qualifier().isPresent();
+  }
+
+  private void validateMapKeyUniqueness(
+      BindingNode dispatchingAndroidInjectorNode,
+      BindingGraph graph,
+      DiagnosticReporter diagnosticReporter) {
+    ImmutableSet<BindingNode> injectorFactories =
+        injectorMapDependencies(dispatchingAndroidInjectorNode, graph)
+            .flatMap(injectorFactoryMap -> dependencies(injectorFactoryMap, graph))
+            .collect(collectingAndThen(toList(), ImmutableSet::copyOf));
+
+    ImmutableListMultimap.Builder<String, BindingNode> mapKeyIndex =
+        ImmutableListMultimap.builder();
+    for (BindingNode injectorFactory : injectorFactories) {
+      AnnotationMirror mapKey = mapKey(injectorFactory).get();
+      Optional<String> injectedType = injectedTypeFromMapKey(mapKey);
+      if (injectedType.isPresent()) {
+        mapKeyIndex.put(injectedType.get(), injectorFactory);
+      } else {
+        diagnosticReporter.reportBinding(
+            ERROR, injectorFactory, "Unrecognized class: %s", mapKey);
+      }
+    }
+
+    Map<String, List<BindingNode>> duplicates =
+        Maps.filterValues(
+            Multimaps.asMap(mapKeyIndex.build()), bindingNodes -> bindingNodes.size() > 1);
+    if (!duplicates.isEmpty()) {
+      StringBuilder errorMessage =
+          new StringBuilder("Multiple injector factories bound for the same type:\n");
+      Formatter formatter = new Formatter(errorMessage);
+      duplicates.forEach(
+          (injectedType, duplicateFactories) -> {
+            formatter.format("  %s:\n", injectedType);
+            duplicateFactories.forEach(duplicate -> formatter.format("    %s\n", duplicate));
+          });
+      diagnosticReporter.reportBinding(
+          ERROR, dispatchingAndroidInjectorNode, errorMessage.toString());
+    }
+  }
+
+  private Stream<BindingNode> dependencies(BindingNode bindingNode, BindingGraph graph) {
+    return graph
+        .successors(bindingNode)
+        .stream()
+        // TODO(ronshapiro): reuse DaggerStreams.instancesOf()?
+        .filter(BindingNode.class::isInstance)
+        .map(BindingNode.class::cast);
+  }
+
+  /**
+   * Returns a stream of the dependencies of {@code bindingNode} that have a key type of {@code
+   * Map<K, Provider<AndroidInjector.Factory<?>>}.
+   */
+  private Stream<BindingNode> injectorMapDependencies(BindingNode bindingNode, BindingGraph graph) {
+    return dependencies(bindingNode, graph)
+        .filter(node -> node.binding().kind().equals(BindingKind.MULTIBOUND_MAP))
+        .filter(
+            node -> {
+              TypeMirror valueType =
+                  MoreTypes.asDeclared(node.binding().key().type()).getTypeArguments().get(1);
+              if (!MoreTypes.isTypeOf(Provider.class, valueType)
+                  || !valueType.getKind().equals(TypeKind.DECLARED)) {
+                return false;
+              }
+              TypeMirror providedType = MoreTypes.asDeclared(valueType).getTypeArguments().get(0);
+              return MoreTypes.isTypeOf(AndroidInjector.Factory.class, providedType);
+            });
+  }
+
+  private Optional<AnnotationMirror> mapKey(BindingNode bindingNode) {
+    return bindingNode
+        .binding()
+        .bindingElement()
+        .map(bindingElement -> getAnnotatedAnnotations(bindingElement, MapKey.class))
+        .flatMap(
+            annotations ->
+                annotations.isEmpty()
+                    ? Optional.empty()
+                    : Optional.of(getOnlyElement(annotations)));
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/Android/DuplicateAndroidInjectors";
+  }
+
+  @Override
+  public void initTypes(Types types) {
+    this.types = types;
+  }
+
+  @Override
+  public void initElements(Elements elements) {
+    this.elements = elements;
+  }
+}
diff --git a/java/dagger/android/support/AndroidSupportInjectionModule.java b/java/dagger/android/support/AndroidSupportInjectionModule.java
index 6349afb67..85b277a97 100644
--- a/java/dagger/android/support/AndroidSupportInjectionModule.java
+++ b/java/dagger/android/support/AndroidSupportInjectionModule.java
@@ -36,5 +36,9 @@
   abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
       supportFragmentInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Fragment>>
+      supportFragmentInjectorFactoriesWithStringKeys();
+
   private AndroidSupportInjectionModule() {}
 }
diff --git a/java/dagger/internal/DaggerCollections.java b/java/dagger/internal/DaggerCollections.java
index 3d47a8497..cebca42d2 100644
--- a/java/dagger/internal/DaggerCollections.java
+++ b/java/dagger/internal/DaggerCollections.java
@@ -70,7 +70,7 @@ public static boolean hasDuplicates(List<?> list) {
    * Creates a {@link LinkedHashMap} instance, with a high enough "initial capacity" that it
    * <em>should</em> hold {@code expectedSize} elements without growth.
    */
-  static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
+  public static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
     return new LinkedHashMap<K, V>(calculateInitialCapacity(expectedSize));
   }
 
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 45597b0f4..558ee7d4d 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -203,6 +203,7 @@ java_library(
         "DependsOnProductionExecutorValidator.java",
         "DuplicateBindingsValidation.java",
         "IncompatiblyScopedBindingsValidation.java",
+        "IncorrectlyInstalledBindsMethodsValidator.java",
         "InjectBindingValidation.java",
         "MapMultibindingValidation.java",
         "MembersInjectionBindingValidation.java",
@@ -212,6 +213,7 @@ java_library(
         "SubcomponentFactoryMethodValidation.java",
         "Validation.java",
     ],
+    plugins = CODEGEN_PLUGINS,
     tags = ["maven:merged"],
     deps = CODEGEN_DEPS + [
         ":base",
@@ -232,11 +234,11 @@ java_library(
         "ComponentGenerator.java",
         "ComponentInstanceBindingExpression.java",
         "ComponentMethodBindingExpression.java",
+        "ComponentModelBuilder.java",
         "ComponentProvisionBindingExpression.java",
         "ComponentRequirementBindingExpression.java",
         "ComponentRequirementField.java",
         "ComponentRequirementFields.java",
-        "ComponentWriter.java",
         "DelegateBindingExpression.java",
         "DelegatingFrameworkInstanceCreationExpression.java",
         "DependencyMethodProducerCreationExpression.java",
@@ -248,6 +250,7 @@ java_library(
         "FrameworkInstanceBindingExpression.java",
         "FrameworkInstanceSupplier.java",
         "GeneratedComponentModel.java",
+        "GeneratedInstanceBindingExpression.java",
         "GwtCompatibility.java",
         "ImmediateFutureBindingExpression.java",
         "InaccessibleMapKeyProxyGenerator.java",
@@ -263,6 +266,7 @@ java_library(
         "MembersInjectorGenerator.java",
         "MembersInjectorProviderCreationExpression.java",
         "MethodBindingExpression.java",
+        "MissingBindingExpression.java",
         "MonitoringModuleGenerator.java",
         "MonitoringModuleProcessingStep.java",
         "OptionalBindingExpression.java",
@@ -350,6 +354,7 @@ java_library(
     deps = [
         ":base",
         ":binding",
+        ":binding_graph_validation",
         ":kythe_plugin",
         ":processor",
         ":validation",
diff --git a/java/dagger/internal/codegen/BindingCycleValidation.java b/java/dagger/internal/codegen/BindingCycleValidation.java
index 2d6108408..ed61c36b6 100644
--- a/java/dagger/internal/codegen/BindingCycleValidation.java
+++ b/java/dagger/internal/codegen/BindingCycleValidation.java
@@ -27,7 +27,6 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.RequestKinds.extractKeyType;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
-import static java.util.Comparator.comparingInt;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 import com.google.auto.value.AutoValue;
@@ -40,6 +39,7 @@
 import com.google.common.graph.NetworkBuilder;
 import dagger.model.BindingGraph;
 import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Node;
 import dagger.model.BindingKind;
@@ -106,6 +106,15 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
   /**
    * Reports a dependency cycle at the dependency into the cycle that is closest to an entry point.
+   *
+   * <p>Looks for the shortest path from the component that contains the cycle (all bindings in a
+   * cycle must be in the same component; see below) to some binding in the cycle. Then looks for
+   * the last dependency in that path that is not in the cycle; that is the dependency that will be
+   * reported, so that the dependency trace will end just before the cycle.
+   *
+   * <p>Proof (by counterexample) that all bindings in a cycle must be in the same component: Assume
+   * one binding in the cycle is in a parent component. Bindings cannot depend on bindings in child
+   * components, so that binding cannot depend on the next binding in the cycle.
    */
   private void reportCycle(
       Cycle<Node> cycle, BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
@@ -121,18 +130,11 @@ private void reportCycle(
   private ImmutableList<Node> shortestPathToCycleFromAnEntryPoint(
       Cycle<Node> cycle, BindingGraph bindingGraph) {
     Node someCycleNode = cycle.nodes().asList().get(0);
-    return bindingGraph
-        .componentNodes()
-        .stream()
-        .map(componentNode -> shortestPath(bindingGraph, componentNode, someCycleNode))
-        // Ignore paths that go through subcomponents by requiring all nodes after the first to be
-        // BindingNodes. We can't just use nonCycleBreakingDependencyGraph because that filters out
-        // edges that might break a cycle, but those edges might still be part of the shortest path
-        // TO a cycle.
-        .filter(path -> path.stream().skip(1).allMatch(node -> node instanceof BindingNode))
-        .map(path -> subpathToCycle(path, cycle))
-        .min(comparingInt(ImmutableList::size))
-        .get();
+    ComponentNode componentContainingCycle =
+        bindingGraph.componentNode(someCycleNode.componentPath()).get();
+    ImmutableList<Node> pathToCycle =
+        shortestPath(bindingGraph, componentContainingCycle, someCycleNode);
+    return subpathToCycle(pathToCycle, cycle);
   }
 
   /**
@@ -232,13 +234,8 @@ private DependencyEdge chooseDependencyEdgeConnecting(
   private ImmutableNetwork<Node, DependencyEdge> nonCycleBreakingDependencyGraph(
       BindingGraph bindingGraph) {
     MutableNetwork<Node, DependencyEdge> dependencyNetwork =
-        NetworkBuilder.directed()
-            .allowsParallelEdges(true)
-            .allowsSelfLoops(true)
-            .nodeOrder(bindingGraph.nodeOrder())
-            .edgeOrder(bindingGraph.edgeOrder())
-            .expectedNodeCount(
-                bindingGraph.bindingNodes().size() + bindingGraph.componentNodes().size())
+        NetworkBuilder.from(bindingGraph)
+            .expectedNodeCount(bindingGraph.nodes().size())
             .expectedEdgeCount(bindingGraph.dependencyEdges().size())
             .build();
     bindingGraph
@@ -298,7 +295,7 @@ int size() {
     }
 
     @Override
-    public String toString() {
+    public final String toString() {
       return endpointPairs().toString();
     }
 
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
index 23e0745c7..9406467c2 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -27,6 +27,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
 import static dagger.internal.codegen.ContributionBinding.bindingKindForMultibindingKey;
+import static dagger.internal.codegen.DaggerElements.DECLARATION_ORDER;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
@@ -614,7 +615,7 @@ MembersInjectionBinding membersInjectionBinding(
             .thenComparing(injectionSite -> injectionSite.element().getKind())
             // then sort by whichever element comes first in the parent
             // this isn't necessary, but makes the processor nice and predictable
-            .thenComparing(InjectionSite::indexAmongSiblingMembers),
+            .thenComparing(InjectionSite::element, DECLARATION_ORDER),
         injectionSites);
   }
 
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 1eec2ee97..2edd63d1b 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
+import static dagger.internal.codegen.DaggerStreams.presentValues;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
 import com.google.auto.value.AutoValue;
@@ -187,9 +188,8 @@ TypeElement componentType() {
         .flatMap(graph -> graph.contributionBindings().values().stream())
         .flatMap(bindings -> bindings.contributionBindings().stream())
         .filter(ContributionBinding::requiresModuleInstance)
-        .map(bindingDeclaration -> bindingDeclaration.contributingModule())
-        .filter(Optional::isPresent)
-        .map(Optional::get)
+        .map(ContributionBinding::contributingModule)
+        .flatMap(presentValues())
         .filter(module -> ownedModuleTypes().contains(module))
         .map(module -> ComponentRequirement.forModule(module.asType()))
         .forEach(requirements::add);
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index cb8f7e15a..533f4344b 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -16,9 +16,14 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreTypes.asTypeElement;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static dagger.internal.codegen.DaggerStreams.presentValues;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.model.BindingGraphProxies.childFactoryMethodEdge;
 import static dagger.model.BindingGraphProxies.dependencyEdge;
+import static dagger.model.BindingGraphProxies.subcomponentBuilderBindingEdge;
+import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -35,15 +40,20 @@
 import dagger.model.DependencyRequest;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 
 /** Converts {@link dagger.internal.codegen.BindingGraph}s to {@link dagger.model.BindingGraph}s. */
 final class BindingGraphConverter {
 
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
+  private final CompilerOptions compilerOptions;
 
   @Inject
-  BindingGraphConverter(BindingDeclarationFormatter bindingDeclarationFormatter) {
+  BindingGraphConverter(
+      BindingDeclarationFormatter bindingDeclarationFormatter, CompilerOptions compilerOptions) {
     this.bindingDeclarationFormatter = bindingDeclarationFormatter;
+    this.compilerOptions = compilerOptions;
   }
 
   /**
@@ -65,7 +75,7 @@
     private ComponentNode currentComponent;
 
     Traverser(BindingGraph graph) {
-      super(graph);
+      super(graph, compilerOptions);
     }
 
     @Override
@@ -83,7 +93,16 @@ protected void visitComponent(BindingGraph graph) {
       }
 
       for (ResolvedBindings resolvedBindings : graph.resolvedBindings()) {
-        bindingNodes(resolvedBindings).forEach(node -> addBindingNode(node));
+        for (BindingNode node : bindingNodes(resolvedBindings)) {
+          addBindingNode(node);
+          if (node.binding().kind().equals(SUBCOMPONENT_BUILDER)
+              && node.componentPath().equals(currentComponent.componentPath())) {
+            network.addEdge(
+                node,
+                subcomponentNode(node.binding().key().type(), graph),
+                subcomponentBuilderBindingEdge(subcomponentDeclaringModules(resolvedBindings)));
+          }
+        }
       }
 
       super.visitComponent(graph);
@@ -188,5 +207,24 @@ private MissingBindingNode missingBindingNode(ResolvedBindings dependencies) {
               .toComponentPath(),
           dependencies.key());
     }
+
+    private ComponentNode subcomponentNode(TypeMirror subcomponentBuilderType, BindingGraph graph) {
+      TypeElement subcomponentBuilderElement = asTypeElement(subcomponentBuilderType);
+      ComponentDescriptor subcomponent =
+          graph.componentDescriptor().subcomponentsByBuilderType().get(subcomponentBuilderElement);
+      return ComponentNodeImpl.create(
+          componentTreePath().childPath(subcomponent.componentDefinitionType()).toComponentPath(),
+          subcomponent);
+    }
+
+    private ImmutableSet<TypeElement> subcomponentDeclaringModules(
+        ResolvedBindings resolvedBindings) {
+      return resolvedBindings
+          .subcomponentDeclarations()
+          .stream()
+          .map(SubcomponentDeclaration::contributingModule)
+          .flatMap(presentValues())
+          .collect(toImmutableSet());
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 6647eb6c2..318f334bc 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -27,6 +27,7 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
+import static dagger.model.BindingKind.DELEGATE;
 import static dagger.model.BindingKind.OPTIONAL;
 import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
 import static java.util.function.Predicate.isEqual;
@@ -47,6 +48,7 @@
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind;
+import dagger.model.ComponentPath;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.Scope;
@@ -79,22 +81,29 @@
   private final InjectBindingRegistry injectBindingRegistry;
   private final KeyFactory keyFactory;
   private final BindingFactory bindingFactory;
+  private final IncorrectlyInstalledBindsMethodsValidator incorrectlyInstalledBindsMethodsValidator;
+  private final CompilerOptions compilerOptions;
 
   @Inject
   BindingGraphFactory(
       DaggerElements elements,
       InjectBindingRegistry injectBindingRegistry,
       KeyFactory keyFactory,
-      BindingFactory bindingFactory) {
+      BindingFactory bindingFactory,
+      IncorrectlyInstalledBindsMethodsValidator incorrectlyInstalledBindsMethodsValidator,
+      CompilerOptions compilerOptions) {
     this.elements = elements;
     this.injectBindingRegistry = injectBindingRegistry;
     this.keyFactory = keyFactory;
     this.bindingFactory = bindingFactory;
+    this.incorrectlyInstalledBindsMethodsValidator = incorrectlyInstalledBindsMethodsValidator;
+    this.compilerOptions = compilerOptions;
   }
 
   /** Creates a binding graph for a root component. */
   BindingGraph create(ComponentDescriptor componentDescriptor) {
-    checkArgument(componentDescriptor.kind().isTopLevel());
+    checkArgument(
+        componentDescriptor.kind().isTopLevel() || compilerOptions.aheadOfTimeSubcomponents());
     return create(Optional.empty(), componentDescriptor);
   }
 
@@ -593,7 +602,9 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
       if (binding.scope().isPresent() && binding.scope().get().isReusable()) {
         for (Resolver requestResolver : getResolverLineage().reverse()) {
           // If a @Reusable binding was resolved in an ancestor, use that component.
-          if (requestResolver.resolvedContributionBindings.containsKey(binding.key())) {
+          ResolvedBindings resolvedBindings =
+              requestResolver.resolvedContributionBindings.get(binding.key());
+          if (resolvedBindings != null && resolvedBindings.bindings().contains(binding)) {
             return Optional.of(requestResolver);
           }
         }
@@ -603,6 +614,7 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
 
       for (Resolver requestResolver : getResolverLineage().reverse()) {
         if (requestResolver.explicitBindingsSet.contains(binding)
+            || resolverContainsDelegateDeclarationForBinding(requestResolver, binding)
             || requestResolver.subcomponentDeclarations.containsKey(binding.key())) {
           return Optional.of(requestResolver);
         }
@@ -621,6 +633,71 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
       return Optional.empty();
     }
 
+    /**
+     * Returns true if {@code binding} was installed in a module in this resolver's component. If
+     * {@link CompilerOptions#floatingBindsMethods()} is enabled, calls {@link
+     * #recordFloatingBindsMethod(Resolver, ContributionBinding)} and returns false.
+     */
+    private boolean resolverContainsDelegateDeclarationForBinding(
+        Resolver resolver, ContributionBinding binding) {
+      // TODO(ronshapiro): remove the flag once we feel enough time has passed, and return this
+      // value directly. At that point, this can be remove the resolver parameter and become a
+      // method invoked on a particular resolver
+      boolean resolverContainsDeclaration =
+          binding.kind().equals(DELEGATE)
+              && resolver
+                  .delegateDeclarations
+                  .get(binding.key())
+                  .stream()
+                  .anyMatch(
+                      declaration ->
+                          declaration.contributingModule().equals(binding.contributingModule())
+                              && declaration.bindingElement().equals(binding.bindingElement()));
+      if (resolverContainsDeclaration && compilerOptions.floatingBindsMethods()) {
+        recordFloatingBindsMethod(resolver, binding);
+        return false;
+      }
+      return resolverContainsDeclaration;
+    }
+
+    /**
+     * Records binds methods that are resolved in the wrong component due to b/79859714. These will
+     * be reported later on in {@link IncorrectlyInstalledBindsMethodsValidator}.
+     */
+    private void recordFloatingBindsMethod(Resolver idealResolver, ContributionBinding binding) {
+      Resolver actualResolver = this;
+      if (binding.scope().isPresent()) {
+        for (Resolver requestResolver : getResolverLineage().reverse()) {
+          if (requestResolver.componentDescriptor.scopes().contains(binding.scope().get())) {
+            actualResolver = requestResolver;
+            break;
+          }
+        }
+      }
+      if (actualResolver != idealResolver) {
+        incorrectlyInstalledBindsMethodsValidator.recordBinding(
+            componentPath(idealResolver), binding);
+      }
+    }
+
+    /**
+     * Constructs a {@link ComponentPath} from the root component of this resolver to a {@code
+     * destination}.
+     */
+    private ComponentPath componentPath(Resolver destination) {
+      ImmutableList.Builder<TypeElement> path = ImmutableList.builder();
+      for (Resolver resolver : getResolverLineage()) {
+        path.add(resolver.componentDescriptor.componentDefinitionType());
+        if (resolver == destination) {
+          return ComponentPath.create(path.build());
+        }
+      }
+      throw new AssertionError(
+          String.format(
+              "%s not found in %s",
+              destination.componentDescriptor.componentDefinitionType(), path.build()));
+    }
+
     /** Returns the resolver lineage from parent to child. */
     private ImmutableList<Resolver> getResolverLineage() {
       List<Resolver> resolverList = Lists.newArrayList();
@@ -806,8 +883,8 @@ void resolve(Key key) {
       cycleStack.push(key);
       try {
         ResolvedBindings bindings = lookUpBindings(key);
-        resolveDependencies(bindings);
         resolvedContributionBindings.put(key, bindings);
+        resolveDependencies(bindings);
       } finally {
         cycleStack.pop();
       }
diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index 685a26e47..f23234a04 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -79,6 +79,9 @@ boolean doCheckForNulls() {
 
   abstract boolean aheadOfTimeSubcomponents();
 
+  /** See b/79859714 */
+  abstract boolean floatingBindsMethods();
+
   static Builder builder() {
     return new AutoValue_CompilerOptions.Builder().headerCompilation(false);
   }
@@ -111,6 +114,8 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, DaggerElement
                 .equals(FeatureStatus.ENABLED))
         .aheadOfTimeSubcomponents(
             aheadOfTimeSubcomponentsFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
+        .floatingBindsMethods(
+            floatingBindsMethodsFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
         .build();
   }
 
@@ -142,6 +147,8 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
 
     Builder aheadOfTimeSubcomponents(boolean aheadOfTimeSubcomponents);
 
+    Builder floatingBindsMethods(boolean enabled);
+
     CompilerOptions build();
   }
 
@@ -180,6 +187,8 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
 
   static final String AHEAD_OF_TIME_COMPONENTS_KEY = "dagger.experimentalAheadOfTimeSubcomponents";
 
+  static final String FLOATING_BINDS_METHODS_KEY = "dagger.floatingBindsMethods";
+
   static final ImmutableSet<String> SUPPORTED_OPTIONS =
       ImmutableSet.of(
           FAST_INIT,
@@ -192,7 +201,8 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
           STATIC_MEMBER_VALIDATION_TYPE_KEY,
           WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
           IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT,
-          AHEAD_OF_TIME_COMPONENTS_KEY);
+          AHEAD_OF_TIME_COMPONENTS_KEY,
+          FLOATING_BINDS_METHODS_KEY);
 
   private static boolean fastInitEnabled(ProcessingEnvironment processingEnv) {
     return valueOf(
@@ -286,6 +296,15 @@ private static FeatureStatus aheadOfTimeSubcomponentsFeatureStatus(
         EnumSet.allOf(FeatureStatus.class));
   }
 
+  private static FeatureStatus floatingBindsMethodsFeatureStatus(
+      ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        FLOATING_BINDS_METHODS_KEY,
+        FeatureStatus.DISABLED,
+        EnumSet.allOf(FeatureStatus.class));
+  }
+
   private static <T extends Enum<T>> T valueOf(
       ProcessingEnvironment processingEnv, String key, T defaultValue, Set<T> validValues) {
     Map<String, String> options = processingEnv.getOptions();
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index e87e6f558..92c0233ec 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -84,7 +84,7 @@
         generatedComponentModel,
         subcomponentNames,
         componentRequirementFields,
-        new ReferenceReleasingManagerFields(graph, generatedComponentModel),
+        new ReferenceReleasingManagerFields(graph, generatedComponentModel, compilerOptions),
         new StaticSwitchingProviders(generatedComponentModel, types),
         optionalFactories,
         types,
@@ -249,13 +249,20 @@ MethodSpec getComponentMethod(ComponentMethodDescriptor componentMethod) {
   }
 
   private BindingExpression getBindingExpression(Key key, RequestKind requestKind) {
-    ResolvedBindings resolvedBindings = graph.resolvedBindings(requestKind, key);
-    if (resolvedBindings != null && !resolvedBindings.ownedBindings().isEmpty()) {
-      if (!expressions.contains(key, requestKind)) {
-        expressions.put(key, requestKind, createBindingExpression(resolvedBindings, requestKind));
-      }
+    if (expressions.contains(key, requestKind)) {
       return expressions.get(key, requestKind);
     }
+    Optional<BindingExpression> expression = Optional.empty();
+    if (resolvedInThisComponent(key, requestKind)) {
+      ResolvedBindings resolvedBindings = graph.resolvedBindings(requestKind, key);
+      expression = Optional.of(createBindingExpression(resolvedBindings, requestKind));
+    } else if (!resolvableBinding(key, requestKind) && generatedComponentModel.isAbstract()) {
+      expression = Optional.of(new MissingBindingExpression(key));
+    }
+    if (expression.isPresent()) {
+      expressions.put(key, requestKind, expression.get());
+      return expression.get();
+    }
     checkArgument(parent.isPresent(), "no expression found for %s-%s", key, requestKind);
     return parent.get().getBindingExpression(key, requestKind);
   }
@@ -263,6 +270,9 @@ private BindingExpression getBindingExpression(Key key, RequestKind requestKind)
   /** Creates a binding expression. */
   private BindingExpression createBindingExpression(
       ResolvedBindings resolvedBindings, RequestKind requestKind) {
+    if (generatedInstanceForAbstractSubcomponent(resolvedBindings)) {
+      return new GeneratedInstanceBindingExpression(resolvedBindings);
+    }
     switch (resolvedBindings.bindingType()) {
       case MEMBERS_INJECTION:
         checkArgument(requestKind.equals(RequestKind.MEMBERS_INJECTION));
@@ -279,6 +289,37 @@ private BindingExpression createBindingExpression(
     }
   }
 
+  /**
+   * Returns true if the binding exposes an instance of a generated type, but no concrete
+   * implementation of that type is available.
+   */
+  private boolean generatedInstanceForAbstractSubcomponent(ResolvedBindings resolvedBindings) {
+    return !resolvedBindings.contributionBindings().isEmpty()
+        && resolvedBindings.contributionBinding().requiresGeneratedInstance()
+        && generatedComponentModel.isAbstract();
+  }
+
+  /**
+   * Returns true if the binding can be resolved by the graph for this component or any parent
+   * component.
+   */
+  private boolean resolvableBinding(Key key, RequestKind requestKind) {
+    for (ComponentBindingExpressions expressions = this;
+        expressions != null;
+        expressions = expressions.parent.orElse(null)) {
+      if (expressions.resolvedInThisComponent(key, requestKind)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** Returns true if the binding can be resolved by the graph for this component. */
+  private boolean resolvedInThisComponent(Key key, RequestKind requestKind) {
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(requestKind, key);
+    return resolvedBindings != null && !resolvedBindings.ownedBindings().isEmpty();
+  }
+
   /**
    * Returns a binding expression that uses a {@link javax.inject.Provider} for provision bindings
    * or a {@link dagger.producers.Producer} for production bindings.
@@ -373,7 +414,8 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
         return new SetFactoryCreationExpression(binding, generatedComponentModel, this, graph);
 
       case MULTIBOUND_MAP:
-        return new MapFactoryCreationExpression(binding, generatedComponentModel, this, graph);
+        return new MapFactoryCreationExpression(
+            binding, generatedComponentModel, this, graph, elements);
 
       case RELEASABLE_REFERENCE_MANAGER:
         return new ReleasableReferenceManagerProviderCreationExpression(
diff --git a/java/dagger/internal/codegen/ComponentBuilder.java b/java/dagger/internal/codegen/ComponentBuilder.java
index 4b89ebe4c..a9f6aff16 100644
--- a/java/dagger/internal/codegen/ComponentBuilder.java
+++ b/java/dagger/internal/codegen/ComponentBuilder.java
@@ -24,6 +24,7 @@
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -76,14 +77,15 @@ ClassName name() {
   }
 
   static Optional<ComponentBuilder> create(
-      ClassName componentName,
+      GeneratedComponentModel generatedComponentModel,
       BindingGraph graph,
       SubcomponentNames subcomponentNames,
       Elements elements,
       Types types) {
     return hasBuilder(graph.componentDescriptor())
         ? Optional.of(
-            new Creator(componentName, graph, subcomponentNames, elements, types).create())
+            new Creator(generatedComponentModel, graph, subcomponentNames, elements, types)
+                .create())
         : Optional.empty();
   }
 
@@ -97,20 +99,20 @@ private static boolean hasBuilder(ComponentDescriptor component) {
             + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
     private final BindingGraph graph;
     private final TypeSpec.Builder builder;
-    private final ClassName componentName;
+    private final GeneratedComponentModel generatedComponentModel;
     private final ClassName builderName;
     private final Elements elements;
     private final Types types;
-    private ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
 
     Creator(
-        ClassName componentName,
+        GeneratedComponentModel generatedComponentModel,
         BindingGraph graph,
         SubcomponentNames subcomponentNames,
         Elements elements,
         Types types) {
-      this.componentName = componentName;
-      if (graph.componentDescriptor().kind().isTopLevel()) {
+      this.generatedComponentModel = generatedComponentModel;
+      ClassName componentName = generatedComponentModel.name();
+      if (!generatedComponentModel.isNested()) {
         builderName = componentName.nestedClass("Builder");
         builder = classBuilder(builderName).addModifiers(STATIC);
       } else {
@@ -125,21 +127,30 @@ private static boolean hasBuilder(ComponentDescriptor component) {
 
     ComponentBuilder create() {
       if (builderSpec().isPresent()) {
-        builder.addModifiers(PRIVATE);
+        if (generatedComponentModel.isAbstract()) {
+          builder.addModifiers(PROTECTED);
+        } else {
+          builder.addModifiers(PRIVATE);
+        }
         addSupertype(builder, builderSpec().get().builderDefinitionType());
       } else {
         builder.addModifiers(PUBLIC).addMethod(constructorBuilder().addModifiers(PRIVATE).build());
       }
 
-      builderFields = builderFields(graph);
+      ImmutableMap<ComponentRequirement, FieldSpec> builderFields = builderFields(graph);
+
+      if (generatedComponentModel.isAbstract()) {
+        builder.addModifiers(ABSTRACT);
+      } else {
+        builder.addModifiers(FINAL);
+        builder.addMethod(buildMethod(builderFields)); // Can only instantiate concrete classes.
+      }
 
       builder
-          .addModifiers(FINAL)
           .addFields(builderFields.values())
-          .addMethod(buildMethod())
           // TODO(ronshapiro): this should be switched with buildMethod(), but that currently breaks
           // compile-testing tests that rely on the order of the methods
-          .addMethods(builderMethods());
+          .addMethods(builderMethods(builderFields));
 
       return new ComponentBuilder(builder.build(), builderName, builderFields);
     }
@@ -160,7 +171,7 @@ ComponentBuilder create() {
       return builderFields.build();
     }
 
-    private MethodSpec buildMethod() {
+    private MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
       MethodSpec.Builder buildMethod;
       if (builderSpec().isPresent()) {
         ExecutableElement specBuildMethod = builderSpec().get().buildMethod();
@@ -195,7 +206,7 @@ private MethodSpec buildMethod() {
                 throw new AssertionError(requirement);
             }
           });
-      buildMethod.addStatement("return new $T(this)", componentName);
+      buildMethod.addStatement("return new $T(this)", generatedComponentModel.name());
       return buildMethod.build();
     }
 
@@ -203,7 +214,8 @@ private MethodSpec buildMethod() {
      * Computes the methods that set each of parameters on the builder. If the {@link BuilderSpec}
      * is present, it will tailor the methods to match the spec.
      */
-    private ImmutableSet<MethodSpec> builderMethods() {
+    private ImmutableSet<MethodSpec> builderMethods(
+        ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
       ImmutableSet<ComponentRequirement> componentRequirements = graph.componentRequirements();
       ImmutableSet.Builder<MethodSpec> methods = ImmutableSet.builder();
       if (builderSpec().isPresent()) {
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index dea137fc8..b2fea631a 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -442,30 +442,38 @@ Kind componentKind() {
     private final Types types;
     private final DependencyRequestFactory dependencyRequestFactory;
     private final ModuleDescriptor.Factory moduleDescriptorFactory;
+    private final CompilerOptions compilerOptions;
 
     @Inject
     Factory(
         DaggerElements elements,
         Types types,
         DependencyRequestFactory dependencyRequestFactory,
-        ModuleDescriptor.Factory moduleDescriptorFactory) {
+        ModuleDescriptor.Factory moduleDescriptorFactory,
+        CompilerOptions compilerOptions) {
       this.elements = elements;
       this.types = types;
       this.dependencyRequestFactory = dependencyRequestFactory;
       this.moduleDescriptorFactory = moduleDescriptorFactory;
+      this.compilerOptions = compilerOptions;
     }
 
     /**
      * Returns a component descriptor for a type annotated with either {@link Component @Component}
-     * or {@link ProductionComponent @ProductionComponent}.
+     * or {@link ProductionComponent @ProductionComponent}. This is also compatible with {@link
+     * Subcomponent @Subcomponent} or {@link ProductionSubcomponent @ProductionSubcomponent} when
+     * generating ahead-of-time subcomponents.
      */
-    ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
-      Optional<Kind> kind = Kind.forAnnotatedElement(componentDefinitionType);
+    ComponentDescriptor forComponent(TypeElement componentType) {
+      Optional<Kind> kind = Kind.forAnnotatedElement(componentType);
       checkArgument(
-          kind.isPresent() && kind.get().isTopLevel(),
-          "%s must be annotated with @Component or @ProductionComponent",
-          componentDefinitionType);
-      return create(componentDefinitionType, kind.get(), Optional.empty());
+          kind.isPresent(), "%s must have a component or subcomponent annotation", componentType);
+      if (!compilerOptions.aheadOfTimeSubcomponents()) {
+        checkArgument(kind.get().isTopLevel(),
+            "%s must be annotated with @Component or @ProductionComponent.",
+            componentType);
+      }
+      return create(componentType, kind.get(), Optional.empty());
     }
 
     private ComponentDescriptor create(
diff --git a/java/dagger/internal/codegen/ComponentGenerator.java b/java/dagger/internal/codegen/ComponentGenerator.java
index 1b8086dfe..4420d6332 100644
--- a/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/java/dagger/internal/codegen/ComponentGenerator.java
@@ -70,7 +70,8 @@ static ClassName componentName(TypeElement componentDefinitionType) {
   @Override
   Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
     return Optional.of(
-        ComponentWriter.writeComponent(
-            types, elements, keyFactory, compilerOptions, componentName, input));
+        ComponentModelBuilder.buildComponentModel(
+                types, elements, keyFactory, compilerOptions, componentName, input)
+            .generate());
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index fbbd0718a..3e08b80a9 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -72,7 +72,7 @@
  * compilation succeeded.
  *
  * <p>The components emitted by this processing step include all of the API elements exposed by the
- * normal {@link ComponentWriter}. Method bodies are omitted as Turbine ignores them entirely.
+ * normal step. Method bodies are omitted as Turbine ignores them entirely.
  */
 final class ComponentHjarProcessingStep implements ProcessingStep {
   private final Elements elements;
@@ -188,7 +188,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
       }
 
       DeclaredType componentType = MoreTypes.asDeclared(componentElement.asType());
-      // TODO(ronshapiro): unify with AbstractComponentWriter
+      // TODO(ronshapiro): unify with ComponentModelBuilder
       Set<MethodSignature> methodSignatures =
           Sets.newHashSetWithExpectedSize(componentDescriptor.componentMethods().size());
       componentDescriptor
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentModelBuilder.java
similarity index 73%
rename from java/dagger/internal/codegen/ComponentWriter.java
rename to java/dagger/internal/codegen/ComponentModelBuilder.java
index dbeea6565..be99cfe8b 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentModelBuilder.java
@@ -32,6 +32,7 @@
 import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.SUBCOMPONENT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -53,20 +54,25 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.util.Elements;
 
-/** Creates the implementation class for a component or subcomponent. */
-abstract class ComponentWriter {
-  static TypeSpec.Builder writeComponent(
+/** Builds the model for an implementation of a component or subcomponent. */
+abstract class ComponentModelBuilder {
+  static GeneratedComponentModel buildComponentModel(
       DaggerTypes types,
       DaggerElements elements,
       KeyFactory keyFactory,
       CompilerOptions compilerOptions,
       ClassName name,
       BindingGraph graph) {
-    GeneratedComponentModel generatedComponentModel = GeneratedComponentModel.forComponent(name);
+    GeneratedComponentModel generatedComponentModel;
+    if (graph.componentDescriptor().kind().isTopLevel()) {
+      generatedComponentModel = GeneratedComponentModel.forComponent(name);
+    } else {
+      generatedComponentModel = GeneratedComponentModel.forBaseSubcomponent(name);
+    }
     SubcomponentNames subcomponentNames = new SubcomponentNames(graph, keyFactory);
     OptionalFactories optionalFactories = new OptionalFactories(generatedComponentModel);
     Optional<ComponentBuilder> builder =
-        ComponentBuilder.create(name, graph, subcomponentNames, elements, types);
+        ComponentBuilder.create(generatedComponentModel, graph, subcomponentNames, elements, types);
     ComponentRequirementFields componentRequirementFields =
         new ComponentRequirementFields(graph, generatedComponentModel, builder);
     ComponentBindingExpressions bindingExpressions =
@@ -79,43 +85,56 @@
             types,
             elements,
             compilerOptions);
-    return new RootComponentWriter(
-            types,
-            elements,
-            graph,
-            generatedComponentModel,
-            subcomponentNames,
-            optionalFactories,
-            bindingExpressions,
-            componentRequirementFields,
-            builder)
-        .write();
+    if (generatedComponentModel.isAbstract()) {
+      checkState(
+          compilerOptions.aheadOfTimeSubcomponents(),
+          "Calling 'buildComponentModel()' on %s when not generating ahead-of-time subcomponents.",
+          graph.componentDescriptor().componentDefinitionType());
+      return new BaseSubcomponentModelBuilder(
+              types,
+              elements,
+              graph,
+              generatedComponentModel,
+              subcomponentNames,
+              optionalFactories,
+              bindingExpressions,
+              componentRequirementFields,
+              builder)
+          .build();
+    } else {
+      return new RootComponentModelBuilder(
+              types,
+              elements,
+              graph,
+              generatedComponentModel,
+              subcomponentNames,
+              optionalFactories,
+              bindingExpressions,
+              componentRequirementFields,
+              builder)
+          .build();
+    }
   }
 
-  private static TypeSpec writeSubcomponent(ComponentWriter parent, BindingGraph childGraph) {
-    ClassName parentName = parent.generatedComponentModel.name();
+  private GeneratedComponentModel buildSubcomponentModel(BindingGraph childGraph) {
+    ClassName parentName = generatedComponentModel.name();
     ClassName childName =
-        parentName.nestedClass(
-            parent.subcomponentNames.get(childGraph.componentDescriptor()) + "Impl");
-    GeneratedComponentModel childGeneratedComponentModel =
-        GeneratedComponentModel.forSubcomponent(childName);
+        parentName.nestedClass(subcomponentNames.get(childGraph.componentDescriptor()) + "Impl");
+    GeneratedComponentModel childModel = GeneratedComponentModel.forSubcomponent(childName);
     Optional<ComponentBuilder> childBuilder =
-        ComponentBuilder.create(
-            childName, childGraph, parent.subcomponentNames, parent.elements, parent.types);
+        ComponentBuilder.create(childModel, childGraph, subcomponentNames, elements, types);
     ComponentRequirementFields childComponentRequirementFields =
-        parent.componentRequirementFields.forChildComponent(
-            childGraph, childGeneratedComponentModel, childBuilder);
+        componentRequirementFields.forChildComponent(childGraph, childModel, childBuilder);
     ComponentBindingExpressions childBindingExpressions =
-        parent.bindingExpressions.forChildComponent(
-            childGraph, childGeneratedComponentModel, childComponentRequirementFields);
-    return new SubcomponentWriter(
-            parent,
+        bindingExpressions.forChildComponent(
+            childGraph, childModel, childComponentRequirementFields);
+    return new SubComponentModelBuilder(
+            this,
             childGraph,
-            childGeneratedComponentModel,
+            childModel,
             childBindingExpressions,
             childComponentRequirementFields,
             childBuilder)
-        .write()
         .build();
   }
 
@@ -130,7 +149,7 @@ private static TypeSpec writeSubcomponent(ComponentWriter parent, BindingGraph c
   private final Optional<ComponentBuilder> builder;
   private boolean done;
 
-  private ComponentWriter(
+  private ComponentModelBuilder(
       DaggerTypes types,
       Elements elements,
       BindingGraph graph,
@@ -152,12 +171,15 @@ private ComponentWriter(
   }
 
   /**
-   * Constructs a {@link TypeSpec.Builder} that models the {@link BindingGraph} for this component.
-   * This is only intended to be called once (and will throw on successive invocations). If the
-   * component must be regenerated, use a new instance.
+   * Returns a {@link GeneratedComponentModel} for this component. This is only intended to be
+   * called once (and will throw on successive invocations). If the component must be regenerated,
+   * use a new instance.
    */
-  protected final TypeSpec.Builder write() {
-    checkState(!done, "ComponentWriter has already been generated.");
+  protected final GeneratedComponentModel build() {
+    checkState(
+        !done,
+        "ComponentModelBuilder has already built the GeneratedComponentModel for [%s].",
+        generatedComponentModel.name());
     generatedComponentModel.addSupertype(graph.componentType());
     builder.map(ComponentBuilder::typeSpec).ifPresent(this::addBuilderClass);
 
@@ -171,7 +193,7 @@ private ComponentWriter(
     addConstructor();
 
     done = true;
-    return generatedComponentModel.generate();
+    return generatedComponentModel;
   }
 
   /**
@@ -201,9 +223,9 @@ private MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
         method, MoreTypes.asDeclared(graph.componentType().asType()), types);
   }
 
-  private void addSubcomponents() {
+  protected void addSubcomponents() {
     for (BindingGraph subgraph : graph.subgraphs()) {
-      generatedComponentModel.addType(SUBCOMPONENT, writeSubcomponent(this, subgraph));
+      generatedComponentModel.addSubcomponent(buildSubcomponentModel(subgraph));
     }
   }
 
@@ -216,7 +238,9 @@ private void addConstructor() {
 
     ImmutableList<ParameterSpec> constructorParameters = constructorParameters();
     MethodSpec.Builder constructor =
-        constructorBuilder().addModifiers(PRIVATE).addParameters(constructorParameters);
+        constructorBuilder()
+            .addModifiers(generatedComponentModel.isAbstract() ? PROTECTED : PRIVATE)
+            .addParameters(constructorParameters);
 
     ImmutableList<ParameterSpec> initializeParameters = initializeParameters();
     CodeBlock initializeParametersCodeBlock =
@@ -258,17 +282,17 @@ private void addConstructor() {
       return ImmutableList.of(ParameterSpec.builder(builder.get().name(), "builder").build());
     } else if (graph.factoryMethod().isPresent()) {
       return getFactoryMethodParameterSpecs(graph);
+    } else if (generatedComponentModel.isAbstract() && !generatedComponentModel.isNested()) {
+      return ImmutableList.of();
     } else {
       throw new AssertionError(
           "Expected either a component builder or factory method but found neither.");
     }
   }
 
-  /**
-   * Creates the implementation class for the root component.
-   */
-  private static final class RootComponentWriter extends ComponentWriter {
-    RootComponentWriter(
+  /** Builds the model for the root component. */
+  private static final class RootComponentModelBuilder extends ComponentModelBuilder {
+    RootComponentModelBuilder(
         DaggerTypes types,
         Elements elements,
         BindingGraph graph,
@@ -334,14 +358,12 @@ private boolean canInstantiateAllRequirements() {
     }
   }
 
-  /**
-   * Creates the nested implementation class for a subcomponent.
-   */
-  private static final class SubcomponentWriter extends ComponentWriter {
-    private final ComponentWriter parent;
+  /** Builds the model for a nested subcomponent. */
+  private static final class SubComponentModelBuilder extends ComponentModelBuilder {
+    private final ComponentModelBuilder parent;
 
-    SubcomponentWriter(
-        ComponentWriter parent,
+    SubComponentModelBuilder(
+        ComponentModelBuilder parent,
         BindingGraph graph,
         GeneratedComponentModel generatedComponentModel,
         ComponentBindingExpressions bindingExpressions,
@@ -391,6 +413,49 @@ private DeclaredType parentType() {
     }
   }
 
+  /** Builds the model for a top-level abstract base implementation of a subcomponent. */
+  private static final class BaseSubcomponentModelBuilder extends ComponentModelBuilder {
+    private final GeneratedComponentModel generatedComponentModel;
+
+    BaseSubcomponentModelBuilder(
+        DaggerTypes types,
+        Elements elements,
+        BindingGraph graph,
+        GeneratedComponentModel generatedComponentModel,
+        SubcomponentNames subcomponentNames,
+        OptionalFactories optionalFactories,
+        ComponentBindingExpressions bindingExpressions,
+        ComponentRequirementFields componentRequirementFields,
+        Optional<ComponentBuilder> builder) {
+      super(
+          types,
+          elements,
+          graph,
+          generatedComponentModel,
+          subcomponentNames,
+          optionalFactories,
+          bindingExpressions,
+          componentRequirementFields,
+          builder);
+      this.generatedComponentModel = generatedComponentModel;
+    }
+
+    @Override
+    protected void addBuilderClass(TypeSpec builder) {
+      generatedComponentModel.addType(SUBCOMPONENT, builder);
+    }
+
+    @Override
+    protected void addFactoryMethods() {
+      // Only construct instances of subcomponents that have concrete implementations.
+    }
+
+    @Override
+    protected void addSubcomponents() {
+      // TODO(b/72748365): Implement abstract inner subcomponents.
+    }
+  }
+
   /** Returns the list of {@link ParameterSpec}s for the corresponding graph's factory method. */
   private static ImmutableList<ParameterSpec> getFactoryMethodParameterSpecs(BindingGraph graph) {
     return graph
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 0b5ba2699..62881c3d3 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -53,6 +53,7 @@
   private final BindingGraphConverter bindingGraphConverter;
   private final BindingGraphPlugins validationPlugins;
   private final BindingGraphPlugins spiPlugins;
+  private final CompilerOptions compilerOptions;
 
   @Inject
   ComponentProcessingStep(
@@ -65,7 +66,8 @@
       ComponentGenerator componentGenerator,
       BindingGraphConverter bindingGraphConverter,
       @Validation BindingGraphPlugins validationPlugins,
-      BindingGraphPlugins spiPlugins) {
+      BindingGraphPlugins spiPlugins,
+      CompilerOptions compilerOptions) {
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.builderValidator = builderValidator;
@@ -76,6 +78,7 @@
     this.bindingGraphConverter = bindingGraphConverter;
     this.validationPlugins = validationPlugins;
     this.spiPlugins = spiPlugins;
+    this.compilerOptions = compilerOptions;
   }
 
   @Override
@@ -146,6 +149,25 @@
         rejectedElements.add(componentTypeElement);
       }
     }
+
+    if (compilerOptions.aheadOfTimeSubcomponents()) {
+      for (TypeElement subcomponentTypeElement : typesIn(subcomponentElements)) {
+        if (!subcomponentIsClean(
+            subcomponentTypeElement, reportsBySubcomponent, builderReportsBySubcomponent)) {
+          continue;
+        }
+        try {
+          ComponentDescriptor componentDescriptor =
+              componentDescriptorFactory.forComponent(subcomponentTypeElement);
+          BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+          // TODO(b/72748365): Do subgraph validation.
+          generateComponent(bindingGraph);
+        } catch (TypeNotPresentException e) {
+          rejectedElements.add(subcomponentTypeElement);
+        }
+      }
+    }
+
     return rejectedElements.build();
   }
 
@@ -212,15 +234,27 @@ private boolean isClean(
       return false;
     }
     for (Element element : report.referencedSubcomponents()) {
-      ValidationReport<?> subcomponentBuilderReport = builderReportsBySubcomponent.get(element);
-      if (subcomponentBuilderReport != null && !subcomponentBuilderReport.isClean()) {
-        return false;
-      }
-      ValidationReport<?> subcomponentReport = reportsBySubcomponent.get(element);
-      if (subcomponentReport != null && !subcomponentReport.isClean()) {
+      if (!subcomponentIsClean(element, reportsBySubcomponent, builderReportsBySubcomponent)) {
         return false;
       }
     }
     return true;
   }
+
+  /** Returns true if the reports associated with the subcomponent are clean. */
+  private boolean subcomponentIsClean(
+      Element subcomponentElement,
+      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
+      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
+    ValidationReport<?> subcomponentBuilderReport =
+        builderReportsBySubcomponent.get(subcomponentElement);
+    if (subcomponentBuilderReport != null && !subcomponentBuilderReport.isClean()) {
+      return false;
+    }
+    ValidationReport<?> subcomponentReport = reportsBySubcomponent.get(subcomponentElement);
+    if (subcomponentReport != null && !subcomponentReport.isClean()) {
+      return false;
+    }
+    return true;
+  }
 }
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index a77509fc5..bd3a9129b 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -116,6 +116,7 @@ public SourceVersion getSupportedSourceVersion() {
         BindingGraphPluginsModule.class,
         BindingGraphValidationModule.class,
         BindingMethodValidatorsModule.class,
+        IncorrectlyInstalledBindsMethodsValidator.Module.class,
         ProcessingStepsModule.class,
       })
   interface ProcessorComponent {
diff --git a/java/dagger/internal/codegen/ComponentRequirementFields.java b/java/dagger/internal/codegen/ComponentRequirementFields.java
index f38fbdaec..62d6aa6fc 100644
--- a/java/dagger/internal/codegen/ComponentRequirementFields.java
+++ b/java/dagger/internal/codegen/ComponentRequirementFields.java
@@ -113,7 +113,8 @@ private ComponentRequirementField create(ComponentRequirement requirement) {
     if (componentBuilder.isPresent()) {
       FieldSpec builderField = componentBuilder.get().builderFields().get(requirement);
       return new BuilderField(requirement, generatedComponentModel, builderField);
-    } else if (graph.factoryMethodParameters().containsKey(requirement)) {
+    } else if (graph.factoryMethod().isPresent()
+        && graph.factoryMethodParameters().containsKey(requirement)) {
       ParameterSpec factoryParameter =
           ParameterSpec.get(graph.factoryMethodParameters().get(requirement));
       return new ComponentParameterField(requirement, generatedComponentModel, factoryParameter);
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/ComponentTreeTraverser.java
index 778c651e9..f79c1d0cb 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -74,9 +74,10 @@
   private final Deque<BindingGraph> bindingGraphPath = new ArrayDeque<>();
 
   /** Constructs a traverser for a root (component, not subcomponent) binding graph. */
-  public ComponentTreeTraverser(BindingGraph rootGraph) {
+  public ComponentTreeTraverser(BindingGraph rootGraph, CompilerOptions compilerOptions) {
     checkArgument(
-        rootGraph.componentDescriptor().kind().isTopLevel(),
+        rootGraph.componentDescriptor().kind().isTopLevel()
+            || compilerOptions.aheadOfTimeSubcomponents(),
         "only top-level graphs can be traversed, not %s",
         rootGraph.componentDescriptor().componentDefinitionType().getQualifiedName());
     bindingGraphPath.add(rootGraph);
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index 9b7685103..c58a980b3 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -164,6 +164,17 @@ final boolean isSyntheticMultibinding() {
     }
   }
 
+  /** Whether the bound type has a generated implementation. */
+  final boolean requiresGeneratedInstance() {
+    switch (kind()) {
+      case COMPONENT:
+      case SUBCOMPONENT_BUILDER:
+        return true;
+      default:
+        return false;
+    }
+  }
+
   /**
    * Returns {@link BindingKind#MULTIBOUND_SET} or {@link
    * BindingKind#MULTIBOUND_MAP} if the key is a set or map.
diff --git a/java/dagger/internal/codegen/DaggerElements.java b/java/dagger/internal/codegen/DaggerElements.java
index 92bf2a3ca..e9e505213 100644
--- a/java/dagger/internal/codegen/DaggerElements.java
+++ b/java/dagger/internal/codegen/DaggerElements.java
@@ -23,6 +23,7 @@
 import static com.google.common.collect.Lists.asList;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.Formatter.formatArgumentInList;
+import static java.util.Comparator.comparing;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toSet;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -38,6 +39,7 @@
 import java.io.Writer;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
+import java.util.Comparator;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -184,6 +186,13 @@ public TypeElement visitType(TypeElement type, Void p) {
         }
       };
 
+  /**
+   * Compares elements according to their declaration order among siblings. Only valid to compare
+   * elements enclosed by the same parent.
+   */
+  static final Comparator<Element> DECLARATION_ORDER =
+      comparing(element -> element.getEnclosingElement().getEnclosedElements().indexOf(element));
+
   /**
    * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
    * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
diff --git a/java/dagger/internal/codegen/DaggerKythePlugin.java b/java/dagger/internal/codegen/DaggerKythePlugin.java
index 98d210cc6..26e0a8ce4 100644
--- a/java/dagger/internal/codegen/DaggerKythePlugin.java
+++ b/java/dagger/internal/codegen/DaggerKythePlugin.java
@@ -155,6 +155,7 @@ public void run(
       DaggerDaggerKythePlugin_PluginComponent.builder()
           .types(JavacTypes.instance(javaContext))
           .elements(JavacElements.instance(javaContext))
+          .compilerOptions(KytheBindingGraphFactory.createCompilerOptions())
           .build()
           .inject(this);
     }
@@ -168,8 +169,15 @@ public void run(
 
     @Component.Builder
     interface Builder {
-      @BindsInstance Builder types(Types types);
-      @BindsInstance Builder elements(Elements elements);
+      @BindsInstance
+      Builder types(Types types);
+
+      @BindsInstance
+      Builder elements(Elements elements);
+
+      @BindsInstance
+      Builder compilerOptions(CompilerOptions compilerOptions);
+
       PluginComponent build();
     }
   }
diff --git a/java/dagger/internal/codegen/DaggerStreams.java b/java/dagger/internal/codegen/DaggerStreams.java
index 83a4e30d1..ff4c44698 100644
--- a/java/dagger/internal/codegen/DaggerStreams.java
+++ b/java/dagger/internal/codegen/DaggerStreams.java
@@ -25,6 +25,7 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Maps;
 import java.util.Map;
+import java.util.Optional;
 import java.util.function.Function;
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
@@ -98,5 +99,19 @@
     return f -> to.isInstance(f) ? Stream.of(to.cast(f)) : Stream.empty();
   }
 
+  /**
+   * A function that you can use to extract the present values from a stream of {@link Optional}s.
+   *
+   * <pre>{@code
+   * Set<Foo> foos =
+   *     optionalFoos()
+   *         .flatMap(DaggerStreams.presentValues())
+   *         .collect(toSet());
+   * }</pre>
+   */
+  public static <T> Function<Optional<T>, Stream<T>> presentValues() {
+    return optional -> optional.map(Stream::of).orElse(Stream.empty());
+  }
+
   private DaggerStreams() {}
 }
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index 1b295b7e4..0695d81c2 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Lists.asList;
 import static dagger.internal.codegen.DaggerElements.elementEncloses;
 import static dagger.internal.codegen.DaggerElements.elementToString;
@@ -197,16 +198,23 @@ private void reportAtEntryPointsWithDependencyTrace(
     private CharSequence dependencyTrace(DependencyEdge entryPoint, BindingNode bindingNode) {
       checkArgument(entryPoint.isEntryPoint());
       Node entryPointBinding = graph.incidentNodes(entryPoint).target();
-      ImmutableList<Node> shortestPath =
+      ImmutableList<Node> shortestBindingPath =
           shortestPath(
               node -> Sets.filter(graph.successors(node), BindingNode.class::isInstance),
               entryPointBinding,
               bindingNode);
+      verify(
+          !shortestBindingPath.isEmpty(),
+          "no dependency path from %s to %s in %s",
+          entryPoint,
+          bindingNode,
+          graph);
 
-      StringBuilder trace = new StringBuilder(shortestPath.size() * 100 /* a guess heuristic */);
-      for (int i = shortestPath.size() - 1; i > 0; i--) {
+      StringBuilder trace =
+          new StringBuilder(shortestBindingPath.size() * 100 /* a guess heuristic */);
+      for (int i = shortestBindingPath.size() - 1; i > 0; i--) {
         Set<Edge> dependenciesBetween =
-            graph.edgesConnecting(shortestPath.get(i - 1), shortestPath.get(i));
+            graph.edgesConnecting(shortestBindingPath.get(i - 1), shortestBindingPath.get(i));
         DependencyRequest dependencyRequest =
             // If a binding requests a key more than once, any of them should be fine to get to
             // the shortest path
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 636b5a181..01d986b06 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -18,6 +18,7 @@
 
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -33,9 +34,11 @@
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.ReferenceReleasingProviderManager;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
+import javax.lang.model.element.NestingKind;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
@@ -107,6 +110,8 @@
   }
 
   private final ClassName name;
+  private final NestingKind nestingKind;
+  private final boolean isAbstract;
   private final TypeSpec.Builder component;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
@@ -119,17 +124,23 @@
       MultimapBuilder.enumKeys(TypeSpecKind.class).arrayListValues().build();
   private final List<Supplier<TypeSpec>> switchingProviderSupplier = new ArrayList<>();
 
-  private GeneratedComponentModel(ClassName name, Modifier... modifiers) {
+  private GeneratedComponentModel(ClassName name, NestingKind nestingKind, Modifier... modifiers) {
     this.name = name;
+    this.nestingKind = nestingKind;
+    this.isAbstract = Arrays.asList(modifiers).contains(ABSTRACT);
     this.component = classBuilder(name).addModifiers(modifiers);
   }
 
   static GeneratedComponentModel forComponent(ClassName name) {
-    return new GeneratedComponentModel(name, PUBLIC, FINAL);
+    return new GeneratedComponentModel(name, NestingKind.TOP_LEVEL, PUBLIC, FINAL);
   }
 
   static GeneratedComponentModel forSubcomponent(ClassName name) {
-    return new GeneratedComponentModel(name, PRIVATE, FINAL);
+    return new GeneratedComponentModel(name, NestingKind.MEMBER, PRIVATE, FINAL);
+  }
+
+  static GeneratedComponentModel forBaseSubcomponent(ClassName name) {
+    return new GeneratedComponentModel(name, NestingKind.TOP_LEVEL, PUBLIC, ABSTRACT);
   }
 
   /** Returns the name of the component. */
@@ -137,6 +148,16 @@ ClassName name() {
     return name;
   }
 
+  /** Returns whether or not the implementation is nested within another class. */
+  boolean isNested() {
+    return nestingKind.isNested();
+  }
+
+  /** Returns whether or not the implementation is abstract. */
+  boolean isAbstract() {
+    return isAbstract;
+  }
+
   /** Returns {@code true} if {@code type} is accessible from the generated component. */
   boolean isTypeAccessible(TypeMirror type) {
     return isTypeAccessibleFrom(type, name.packageName());
@@ -179,6 +200,11 @@ void addTypes(TypeSpecKind typeKind, Iterable<TypeSpec> typeSpecs) {
     typeSpecsMap.putAll(typeKind, typeSpecs);
   }
 
+  void addSubcomponent(GeneratedComponentModel subcomponentModel) {
+    // TODO(user): Hold a reference to each subcomponent model.
+    addType(TypeSpecKind.SUBCOMPONENT, subcomponentModel.generate().build());
+  }
+
   /** Adds a {@link Supplier} for the SwitchingProvider for the component. */
   void addSwitchingProvider(Supplier<TypeSpec> typeSpecSupplier) {
     switchingProviderSupplier.add(typeSpecSupplier);
diff --git a/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java b/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
new file mode 100644
index 000000000..112154433
--- /dev/null
+++ b/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.model.Key;
+
+/**
+ * A {@link BindingExpression} that invokes a method that encapsulates a binding that requires an
+ * instance of a generated type. This expression is used in abstract implementations of a
+ * subcomponent when there are no concrete definitions of generated types available. The
+ * (unimplemented) method is added to the {@code GeneratedComponentModel} when this dependency
+ * expression is requested. The method is overridden when generating the concrete implementation of
+ * an ancestor component.
+ */
+final class GeneratedInstanceBindingExpression extends BindingExpression {
+  private final Key key;
+
+  GeneratedInstanceBindingExpression(ResolvedBindings resolvedBindings) {
+    this.key = resolvedBindings.key();
+  }
+
+  @Override
+  final Expression getDependencyExpression(ClassName requestingClass) {
+    // TODO(b/72748365): Implement method encapsulating binding to invoke in this expression.
+    return Expression.create(key.type(), CodeBlock.of("null"));
+  }
+}
diff --git a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
index 0a042332c..db6844706 100644
--- a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
+++ b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
@@ -36,12 +36,14 @@
  */
 final class InaccessibleMapKeyProxyGenerator extends SourceFileGenerator<ContributionBinding> {
   private final DaggerTypes types;
+  private final DaggerElements elements;
 
   @Inject
   InaccessibleMapKeyProxyGenerator(
       Filer filer, DaggerTypes types, DaggerElements elements, SourceVersion sourceVersion) {
     super(filer, elements, sourceVersion);
     this.types = types;
+    this.elements = elements;
   }
 
   @Override
@@ -56,7 +58,7 @@ ClassName nameGeneratedType(ContributionBinding binding) {
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedName, ContributionBinding binding) {
-    return MapKeys.mapKeyFactoryMethod(binding, types)
+    return MapKeys.mapKeyFactoryMethod(binding, types, elements)
         .map(
             method ->
                 classBuilder(generatedName)
diff --git a/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java b/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
new file mode 100644
index 000000000..5df3b9a2f
--- /dev/null
+++ b/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkState;
+import static java.util.stream.Collectors.toCollection;
+import static javax.tools.Diagnostic.Kind.WARNING;
+
+import com.google.common.collect.Iterables;
+import com.google.common.collect.MultimapBuilder;
+import com.google.common.collect.SetMultimap;
+import com.google.common.graph.EndpointPair;
+import com.google.common.graph.Graphs;
+import com.google.common.graph.ImmutableGraph;
+import com.google.common.graph.ImmutableNetwork;
+import com.google.common.graph.MutableNetwork;
+import com.google.common.graph.NetworkBuilder;
+import dagger.Binds;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.Edge;
+import dagger.model.BindingGraph.Node;
+import dagger.model.ComponentPath;
+import dagger.multibindings.IntoSet;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.LinkedHashSet;
+import java.util.Map.Entry;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/**
+ * Prints warnings to help users debug <a
+ * href="https://github.com/google/dagger/wiki/Dagger-2.17-@Binds-bugs">the floating {@code @Binds}
+ * bug</a>.
+ */
+@Singleton
+final class IncorrectlyInstalledBindsMethodsValidator implements BindingGraphPlugin {
+  private final SetMultimap<ComponentPath, ContributionBinding> incorrectlyInstalledBindingsCache =
+      MultimapBuilder.hashKeys().linkedHashSetValues().build();
+  private final CompilerOptions compilerOptions;
+
+  @Inject
+  IncorrectlyInstalledBindsMethodsValidator(CompilerOptions compilerOptions) {
+    this.compilerOptions = compilerOptions;
+  }
+
+  @Override
+  public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
+    checkState(
+        compilerOptions.floatingBindsMethods() || incorrectlyInstalledBindingsCache.isEmpty());
+    for (Entry<ComponentPath, ContributionBinding> entry :
+        incorrectlyInstalledBindingsCache.entries()) {
+      ComponentPath idealComponentPath = entry.getKey();
+      ContributionBinding incorrectlyInstalledBinding = entry.getValue();
+      graph
+          .bindingNodes(incorrectlyInstalledBinding.key())
+          .stream()
+          .filter(bindingNode -> bindingNode.binding().equals(incorrectlyInstalledBinding))
+          .forEach(
+              bindingNode -> report(bindingNode, idealComponentPath, graph, diagnosticReporter));
+    }
+  }
+
+  private void report(
+      BindingNode incompatiblyInstalledBinding,
+      ComponentPath idealComponentPath,
+      BindingGraph graph,
+      DiagnosticReporter diagnosticReporter) {
+    // TODO(dpb): consider creating this once per visitGraph()
+    ImmutableGraph<Node> dependencyGraph = dependencyGraph(graph).asGraph();
+    Set<Node> culpableDependencies =
+        Graphs.reachableNodes(dependencyGraph, incompatiblyInstalledBinding)
+            .stream()
+            .filter(node -> isChild(idealComponentPath, node.componentPath()))
+            .filter(node -> !node.equals(incompatiblyInstalledBinding))
+            .collect(toCollection(LinkedHashSet::new));
+    if (culpableDependencies.isEmpty()) {
+      return;
+    }
+    StringBuilder warning =
+        new StringBuilder()
+            .append("Floating @Binds method detected:\n  ")
+            .append(incompatiblyInstalledBinding)
+            .append("\n  It is installed in:       ")
+            .append(idealComponentPath)
+            .append("\n  But is being resolved in: ")
+            .append(incompatiblyInstalledBinding.componentPath())
+            .append("\n  This is because it depends transitively on:");
+
+    while (!culpableDependencies.isEmpty()) {
+      BindingNode culpableDependency = (BindingNode) Iterables.get(culpableDependencies, 0);
+      warning
+          .append("\n      ")
+          .append(culpableDependency)
+          .append(", resolved in: ")
+          .append(culpableDependency.componentPath());
+      culpableDependencies.removeAll(Graphs.reachableNodes(dependencyGraph, culpableDependency));
+    }
+
+    diagnosticReporter.reportComponent(WARNING, graph.rootComponentNode(), warning.toString());
+  }
+
+  private boolean isChild(ComponentPath possibleParent, ComponentPath possibleChild) {
+    return !possibleParent.equals(possibleChild)
+        && possibleChild.components().containsAll(possibleParent.components());
+  }
+
+  private ImmutableNetwork<Node, Edge> dependencyGraph(BindingGraph graph) {
+    MutableNetwork<Node, Edge> dependencyGraph = NetworkBuilder.from(graph).build();
+    for (DependencyEdge dependencyEdge : graph.dependencyEdges()) {
+      EndpointPair<Node> endpoint = graph.incidentNodes(dependencyEdge);
+      dependencyGraph.addEdge(endpoint.source(), endpoint.target(), dependencyEdge);
+    }
+    return ImmutableNetwork.copyOf(dependencyGraph);
+  }
+
+  void recordBinding(ComponentPath componentPath, ContributionBinding binding) {
+    incorrectlyInstalledBindingsCache.put(componentPath, binding);
+  }
+
+  @dagger.Module
+  interface Module {
+    @Binds
+    @IntoSet
+    @Validation
+    BindingGraphPlugin validator(IncorrectlyInstalledBindsMethodsValidator validator);
+  }
+}
diff --git a/java/dagger/internal/codegen/KytheBindingGraphFactory.java b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
index 0d49637de..1af20601c 100644
--- a/java/dagger/internal/codegen/KytheBindingGraphFactory.java
+++ b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
@@ -41,11 +41,13 @@
   private final BindingGraphFactory bindingGraphFactory;
 
   @Inject
-  KytheBindingGraphFactory(Types types, Elements elements) {
+  KytheBindingGraphFactory(Types types, Elements elements, CompilerOptions compilerOptions) {
     DaggerElements daggerElements = new DaggerElements(elements, types);
     DaggerTypes daggerTypes = new DaggerTypes(types, daggerElements);
-    this.componentDescriptorFactory = createComponentDescriptorFactory(daggerElements, daggerTypes);
-    this.bindingGraphFactory = createBindingGraphFactory(daggerTypes, daggerElements);
+    this.componentDescriptorFactory =
+        createComponentDescriptorFactory(daggerElements, daggerTypes, compilerOptions);
+    this.bindingGraphFactory =
+        createBindingGraphFactory(daggerTypes, daggerElements, compilerOptions);
   }
 
   /**
@@ -60,8 +62,26 @@
     return Optional.empty();
   }
 
+  /** Creates the {@link CompilerOptions} for use during {@link BindingGraph} construction. */
+  static CompilerOptions createCompilerOptions() {
+    return CompilerOptions.builder()
+        .usesProducers(true)
+        .writeProducerNameInToken(true)
+        .nullableValidationKind(Diagnostic.Kind.NOTE)
+        .privateMemberValidationKind(Diagnostic.Kind.NOTE)
+        .staticMemberValidationKind(Diagnostic.Kind.NOTE)
+        .ignorePrivateAndStaticInjectionForComponent(false)
+        .scopeCycleValidationType(ValidationType.NONE)
+        .warnIfInjectionFactoryNotGeneratedUpstream(false)
+        .fastInit(false)
+        .experimentalAndroidMode2(false)
+        .aheadOfTimeSubcomponents(false)
+        .floatingBindsMethods(false)
+        .build();
+  }
+
   private static ComponentDescriptor.Factory createComponentDescriptorFactory(
-      DaggerElements elements, DaggerTypes types) {
+      DaggerElements elements, DaggerTypes types, CompilerOptions compilerOptions) {
     KeyFactory keyFactory = new KeyFactory(types, elements);
     DependencyRequestFactory dependencyRequestFactory =
         new DependencyRequestFactory(keyFactory, types);
@@ -85,29 +105,15 @@
             subcomponentDeclarationFactory,
             optionalBindingDeclarationFactory);
     return new ComponentDescriptor.Factory(
-        elements, types, dependencyRequestFactory, moduleDescriptorFactory);
+        elements, types, dependencyRequestFactory, moduleDescriptorFactory, compilerOptions);
   }
 
   private static BindingGraphFactory createBindingGraphFactory(
-      DaggerTypes types, DaggerElements elements) {
+      DaggerTypes types, DaggerElements elements, CompilerOptions compilerOptions) {
     KeyFactory keyFactory = new KeyFactory(types, elements);
     DependencyRequestFactory dependencyRequestFactory =
         new DependencyRequestFactory(keyFactory, types);
     Messager messager = new NullMessager();
-    CompilerOptions compilerOptions =
-        CompilerOptions.builder()
-            .usesProducers(true)
-            .writeProducerNameInToken(true)
-            .nullableValidationKind(Diagnostic.Kind.NOTE)
-            .privateMemberValidationKind(Diagnostic.Kind.NOTE)
-            .staticMemberValidationKind(Diagnostic.Kind.NOTE)
-            .ignorePrivateAndStaticInjectionForComponent(false)
-            .scopeCycleValidationType(ValidationType.NONE)
-            .warnIfInjectionFactoryNotGeneratedUpstream(false)
-            .fastInit(false)
-            .experimentalAndroidMode2(false)
-            .aheadOfTimeSubcomponents(false)
-            .build();
 
     BindingFactory bindingFactory =
         new BindingFactory(types, elements, keyFactory, dependencyRequestFactory);
@@ -123,8 +129,13 @@ private static BindingGraphFactory createBindingGraphFactory(
             keyFactory,
             bindingFactory,
             compilerOptions);
-
-    return new BindingGraphFactory(elements, injectBindingRegistry, keyFactory, bindingFactory);
+    return new BindingGraphFactory(
+        elements,
+        injectBindingRegistry,
+        keyFactory,
+        bindingFactory,
+        new IncorrectlyInstalledBindsMethodsValidator(compilerOptions),
+        compilerOptions);
   }
 
   private static class NullMessager implements Messager {
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index 8a1f70360..25e2e001b 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -124,7 +124,7 @@ private DeclaredType immutableMapType() {
   private CodeBlock keyAndValueExpression(DependencyRequest dependency, ClassName requestingClass) {
     return CodeBlock.of(
         "$L, $L",
-        getMapKeyExpression(dependencies.get(dependency), requestingClass),
+        getMapKeyExpression(dependencies.get(dependency), requestingClass, elements),
         componentBindingExpressions
             .getDependencyExpression(dependency, requestingClass)
             .codeBlock());
diff --git a/java/dagger/internal/codegen/MapFactoryCreationExpression.java b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
index b5804908b..3e61293b7 100644
--- a/java/dagger/internal/codegen/MapFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
@@ -37,16 +37,19 @@
   private final ComponentBindingExpressions componentBindingExpressions;
   private final BindingGraph graph;
   private final ContributionBinding binding;
+  private final DaggerElements elements;
 
   MapFactoryCreationExpression(
       ContributionBinding binding,
       GeneratedComponentModel generatedComponentModel,
       ComponentBindingExpressions componentBindingExpressions,
-      BindingGraph graph) {
+      BindingGraph graph,
+      DaggerElements elements) {
     this.binding = checkNotNull(binding);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.graph = checkNotNull(graph);
+    this.elements = checkNotNull(elements);
   }
 
   @Override
@@ -84,7 +87,7 @@ public CodeBlock creationExpression() {
               .codeBlock();
       builder.add(
           ".put($L, $L)",
-          getMapKeyExpression(contributionBinding, generatedComponentModel.name()),
+          getMapKeyExpression(contributionBinding, generatedComponentModel.name(), elements),
           useRawType ? CodeBlocks.cast(value, frameworkDependency.frameworkClass()) : value);
     }
     builder.add(".build()");
diff --git a/java/dagger/internal/codegen/MapKeys.java b/java/dagger/internal/codegen/MapKeys.java
index 59dea8660..af0e98ea1 100644
--- a/java/dagger/internal/codegen/MapKeys.java
+++ b/java/dagger/internal/codegen/MapKeys.java
@@ -42,6 +42,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.PrimitiveType;
@@ -145,11 +146,12 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
    * @throws IllegalStateException if {@code binding} is not a {@link dagger.multibindings.IntoMap
    *     map} contribution.
    */
-  static CodeBlock getMapKeyExpression(ContributionBinding binding, ClassName requestingClass) {
+  static CodeBlock getMapKeyExpression(
+      ContributionBinding binding, ClassName requestingClass, DaggerElements elements) {
     AnnotationMirror mapKeyAnnotation = binding.mapKeyAnnotation().get();
     return MapKeyAccessibility.isMapKeyAccessibleFrom(
             mapKeyAnnotation, requestingClass.packageName())
-        ? directMapKeyExpression(mapKeyAnnotation)
+        ? directMapKeyExpression(mapKeyAnnotation, elements)
         : CodeBlock.of("$T.create()", mapKeyProxyClassName(binding));
   }
 
@@ -157,17 +159,30 @@ static CodeBlock getMapKeyExpression(ContributionBinding binding, ClassName requ
    * Returns a code block for the map key annotation {@code mapKey}.
    *
    * <p>This method assumes the map key will be accessible in the context that the returned {@link
-   * CodeBlock} is used. Use {@link #getMapKeyExpression(ContributionBinding, ClassName)} when that
-   * assumption is not guaranteed.
+   * CodeBlock} is used. Use {@link #getMapKeyExpression(ContributionBinding, ClassName,
+   * DaggerElements)} when that assumption is not guaranteed.
    *
    * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
    *     annotation
    * @throws IllegalStateException if {@code bindingElement} is not annotated with a {@code MapKey}
    *     annotation
    */
-  private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
+  private static CodeBlock directMapKeyExpression(
+      AnnotationMirror mapKey, DaggerElements elements) {
     Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
     AnnotationExpression annotationExpression = new AnnotationExpression(mapKey);
+
+    if (MoreTypes.asTypeElement(mapKey.getAnnotationType())
+        .getQualifiedName()
+        .contentEquals("dagger.android.AndroidInjectionKey")) {
+      TypeElement unwrappedType =
+          elements.checkTypePresent((String) unwrappedValue.get().getValue());
+      return CodeBlock.of(
+          "$T.of($S)",
+          ClassName.get("dagger.android.internal", "AndroidInjectionKeys"),
+          ClassName.get(unwrappedType).reflectionName());
+    }
+
     if (unwrappedValue.isPresent()) {
       TypeMirror unwrappedValueType =
           getOnlyElement(getAnnotationValuesWithDefaults(mapKey).keySet()).getReturnType();
@@ -178,8 +193,8 @@ private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
   }
 
   /**
-   * Returns the {@link ClassName} in which {@link #mapKeyFactoryMethod(ContributionBinding, Types)}
-   * is generated.
+   * Returns the {@link ClassName} in which {@link #mapKeyFactoryMethod(ContributionBinding, Types,
+   * DaggerElements)} is generated.
    */
   static ClassName mapKeyProxyClassName(ContributionBinding binding) {
     return elementBasedClassName(
@@ -191,7 +206,8 @@ static ClassName mapKeyProxyClassName(ContributionBinding binding) {
    * #mapKeyProxyClassName(ContributionBinding)} when the {@code @MapKey} annotation is not publicly
    * accessible.
    */
-  static Optional<MethodSpec> mapKeyFactoryMethod(ContributionBinding binding, Types types) {
+  static Optional<MethodSpec> mapKeyFactoryMethod(
+      ContributionBinding binding, Types types, DaggerElements elements) {
     return binding
         .mapKeyAnnotation()
         .filter(mapKey -> !isMapKeyPubliclyAccessible(mapKey))
@@ -200,7 +216,7 @@ static ClassName mapKeyProxyClassName(ContributionBinding binding) {
                 methodBuilder("create")
                     .addModifiers(PUBLIC, STATIC)
                     .returns(TypeName.get(mapKeyType(mapKey, types)))
-                    .addStatement("return $L", directMapKeyExpression(mapKey))
+                    .addStatement("return $L", directMapKeyExpression(mapKey, elements))
                     .build());
   }
 
diff --git a/java/dagger/internal/codegen/MembersInjectionBinding.java b/java/dagger/internal/codegen/MembersInjectionBinding.java
index 81dd05b5f..2b6c94040 100644
--- a/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -98,10 +98,6 @@ public final boolean isProduction() {
 
     abstract ImmutableSet<DependencyRequest> dependencies();
 
-    int indexAmongSiblingMembers() {
-      return element().getEnclosingElement().getEnclosedElements().indexOf(element());
-    }
-
     /**
      * Returns the index of {@link #element()} in its parents {@code @Inject} members that have the
      * same simple name. This method filters out private elements so that the results will be
diff --git a/java/dagger/internal/codegen/MissingBindingExpression.java b/java/dagger/internal/codegen/MissingBindingExpression.java
new file mode 100644
index 000000000..197c388c6
--- /dev/null
+++ b/java/dagger/internal/codegen/MissingBindingExpression.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.model.Key;
+
+/**
+ * A {@link BindingExpression} that invokes a method that encapsulates a binding that is missing
+ * when generating the abstract base class implementation of a subcomponent. The (unimplemented)
+ * method is added to the {@link GeneratedComponentModel} when the dependency expression is
+ * requested. The method is overridden when generating the implementation of an ancestor component.
+ */
+final class MissingBindingExpression extends BindingExpression {
+  private final Key key;
+
+  MissingBindingExpression(Key key) {
+    this.key = key;
+  }
+
+  @Override
+  final Expression getDependencyExpression(ClassName requestingClass) {
+    // TODO(b/72748365): Implement method encapsulating binding to invoke in this expression.
+    return Expression.create(key.type(), CodeBlock.of("null"));
+  }
+}
diff --git a/java/dagger/internal/codegen/MissingBindingValidation.java b/java/dagger/internal/codegen/MissingBindingValidation.java
index 5ce5f9bab..811c5624a 100644
--- a/java/dagger/internal/codegen/MissingBindingValidation.java
+++ b/java/dagger/internal/codegen/MissingBindingValidation.java
@@ -194,7 +194,7 @@ private boolean typeHasInjectionSites(Key key) {
               "There is no binding for %s because no component in %s's component hierarchy is "
                   + "annotated with %s. The available reference-releasing scopes are %s.",
               key,
-              graph.rootComponentNode().toString(),
+              graph.rootComponentNode().componentPath().currentComponent().getQualifiedName(),
               getReadableSource(scope),
               releasableReferencesScopes(graph).map(Scopes::getReadableSource).collect(toList())));
     }
diff --git a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
index fe6962184..0a42fb2ac 100644
--- a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
+++ b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
@@ -56,10 +56,14 @@
   private final GeneratedComponentModel generatedComponentModel;
 
   ReferenceReleasingManagerFields(
-      BindingGraph graph, GeneratedComponentModel generatedComponentModel) {
+      BindingGraph graph,
+      GeneratedComponentModel generatedComponentModel,
+      CompilerOptions compilerOptions) {
     this.graph = checkNotNull(graph);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    checkArgument(graph.componentDescriptor().kind().isTopLevel());
+    if (!compilerOptions.aheadOfTimeSubcomponents()) {
+      checkArgument(graph.componentDescriptor().kind().isTopLevel());
+    }
   }
 
   /**
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 7e49da620..9b1294205 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -30,7 +30,9 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.graph.EndpointPair;
 import com.google.common.graph.ImmutableNetwork;
+import com.google.common.graph.MutableNetwork;
 import com.google.common.graph.Network;
+import com.google.common.graph.NetworkBuilder;
 import dagger.Module;
 import dagger.model.BindingGraph.Edge;
 import dagger.model.BindingGraph.Node;
@@ -173,12 +175,30 @@ public ComponentNode rootComponentNode() {
   /** Returns the edges for entry points that transitively depend on a binding. */
   public ImmutableSet<DependencyEdge> entryPointEdgesDependingOnBindingNode(
       BindingNode bindingNode) {
-    Network<Node, Edge> subgraphDependingOnBindingNode =
-        inducedSubgraph(this, reachableNodes(transpose(this).asGraph(), bindingNode));
+    ImmutableNetwork<Node, DependencyEdge> dependencyGraph = dependencyGraph();
+    Network<Node, DependencyEdge> subgraphDependingOnBindingNode =
+        inducedSubgraph(
+            dependencyGraph, reachableNodes(transpose(dependencyGraph).asGraph(), bindingNode));
     return ImmutableSet.copyOf(
         intersection(entryPointEdges(), subgraphDependingOnBindingNode.edges()));
   }
 
+  // TODO(dpb): Make public. Cache.
+  private ImmutableNetwork<Node, DependencyEdge> dependencyGraph() {
+    MutableNetwork<Node, DependencyEdge> dependencyGraph =
+        NetworkBuilder.from(this)
+            .expectedNodeCount(nodes().size())
+            .expectedEdgeCount((int) dependencyEdgeStream().count())
+            .build();
+    dependencyEdgeStream()
+        .forEach(
+            edge -> {
+              EndpointPair<Node> endpoints = incidentNodes(edge);
+              dependencyGraph.addEdge(endpoints.source(), endpoints.target(), edge);
+            });
+    return ImmutableNetwork.copyOf(dependencyGraph);
+  }
+
   private <N extends Node> ImmutableSet<N> nodes(Class<N> clazz) {
     return nodeStream(clazz).collect(toImmutableSet());
   }
diff --git a/javatests/dagger/android/DispatchingAndroidInjectorTest.java b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
index 2d1e6132c..338e7039c 100644
--- a/javatests/dagger/android/DispatchingAndroidInjectorTest.java
+++ b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
@@ -20,12 +20,9 @@
 import static org.junit.Assert.fail;
 
 import android.app.Activity;
+import com.google.common.collect.ImmutableMap;
 import org.robolectric.RobolectricTestRunner;
 import dagger.android.DispatchingAndroidInjector.InvalidInjectorBindingException;
-import java.util.HashMap;
-import java.util.Map;
-import javax.inject.Provider;
-import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
@@ -34,36 +31,59 @@
 @Config(manifest = Config.NONE)
 @RunWith(RobolectricTestRunner.class)
 public final class DispatchingAndroidInjectorTest {
-  private DispatchingAndroidInjector<Activity> dispatchingAndroidInjector;
-
-  @Before
-  public void setup() {
-    Map<Class<? extends Activity>, Provider<AndroidInjector.Factory<? extends Activity>>>
-        injectorFactories = new HashMap<>();
-    injectorFactories.put(FooActivity.class, FooInjector.Factory::new);
-    injectorFactories.put(ReturnsNullActivity.class, () -> null);
-    injectorFactories.put(WrongActivity.class, FooInjector.Factory::new);
-    dispatchingAndroidInjector = new DispatchingAndroidInjector<>(injectorFactories);
+  @Test
+  public void withClassKeys() {
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, FooInjector.Factory::new), ImmutableMap.of());
+
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(activity)).isTrue();
+  }
+
+  @Test
+  public void withStringKeys() {
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(),
+            ImmutableMap.of(FooActivity.class.getName(), FooInjector.Factory::new));
+
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(activity)).isTrue();
   }
 
   @Test
-  public void maybeInject_returnsTrue_ifMatchingInjectorExists() {
+  public void withMixedKeys() {
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, FooInjector.Factory::new),
+            ImmutableMap.of(BarActivity.class.getName(), BarInjector.Factory::new));
+
     FooActivity fooActivity = Robolectric.setupActivity(FooActivity.class);
     assertThat(dispatchingAndroidInjector.maybeInject(fooActivity)).isTrue();
+    BarActivity barActivity = Robolectric.setupActivity(BarActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(barActivity)).isTrue();
   }
 
   @Test
   public void maybeInject_returnsFalse_ifNoMatchingInjectorExists() {
-    BarActivity barActivity = Robolectric.setupActivity(BarActivity.class);
-    assertThat(dispatchingAndroidInjector.maybeInject(barActivity)).isFalse();
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(ImmutableMap.of(), ImmutableMap.of());
+    
+    BarActivity activity = Robolectric.setupActivity(BarActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(activity)).isFalse();
   }
 
   @Test
   public void throwsIfFactoryCreateReturnsNull() {
-    ReturnsNullActivity returnsNullActivity = Robolectric.setupActivity(ReturnsNullActivity.class);
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, () -> null),
+            ImmutableMap.of());
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
 
     try {
-      dispatchingAndroidInjector.maybeInject(returnsNullActivity);
+      dispatchingAndroidInjector.maybeInject(activity);
       fail("Expected NullPointerException");
     } catch (NullPointerException expected) {
     }
@@ -71,10 +91,13 @@ public void throwsIfFactoryCreateReturnsNull() {
 
   @Test
   public void throwsIfClassMismatched() {
-    WrongActivity wrongActivity = Robolectric.setupActivity(WrongActivity.class);
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, BarInjector.Factory::new), ImmutableMap.of());
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
 
     try {
-      dispatchingAndroidInjector.maybeInject(wrongActivity);
+      dispatchingAndroidInjector.maybeInject(activity);
       fail("Expected InvalidInjectorBindingException");
     } catch (InvalidInjectorBindingException expected) {
     }
@@ -84,10 +107,6 @@ public void throwsIfClassMismatched() {
 
   static class BarActivity extends Activity {}
 
-  static class ReturnsNullActivity extends Activity {}
-
-  static class WrongActivity extends Activity {}
-
   static class FooInjector implements AndroidInjector<FooActivity> {
     @Override
     public void inject(FooActivity instance) {}
@@ -99,4 +118,16 @@ public void inject(FooActivity instance) {}
       }
     }
   }
+
+  static class BarInjector implements AndroidInjector<BarActivity> {
+    @Override
+    public void inject(BarActivity instance) {}
+
+    static class Factory implements AndroidInjector.Factory<BarActivity> {
+      @Override
+      public AndroidInjector<BarActivity> create(BarActivity activity) {
+        return new BarInjector();
+      }
+    }
+  }
 }
diff --git a/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
new file mode 100644
index 000000000..8f1a5290b
--- /dev/null
+++ b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
@@ -0,0 +1,451 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ComponentProcessor;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class AndroidMapKeyValidatorTest {
+  private static final JavaFileObject FOO_ACTIVITY =
+      JavaFileObjects.forSourceLines(
+          "test.FooActivity",
+          "package test;",
+          "",
+          "import android.app.Activity;",
+          "import dagger.android.AndroidInjector;",
+          "",
+          "public class FooActivity extends Activity {",
+          "  interface Factory extends AndroidInjector.Factory<FooActivity> {}",
+          "  abstract static class Builder extends AndroidInjector.Builder<FooActivity> {}",
+          "}");
+  private static final JavaFileObject BAR_ACTIVITY =
+      JavaFileObjects.forSourceLines(
+          "test.BarActivity",
+          "package test;",
+          "",
+          "import android.app.Activity;",
+          "",
+          "public class BarActivity extends Activity {}");
+  private static final JavaFileObject BAZ_FRAGMENT =
+      JavaFileObjects.forSourceLines(
+          "test.BazFragment",
+          "package test;",
+          "",
+          "import android.app.Fragment;",
+          "",
+          "public class BazFragment extends Fragment {}");
+
+  private static JavaFileObject moduleWithMethod(String... lines) {
+    return JavaFileObjects.forSourceLines(
+        "test.AndroidModule",
+        "package test;",
+        "",
+        "import android.app.Activity;",
+        "import android.app.Fragment;",
+        "import dagger.Module;",
+        "import dagger.*;",
+        "import dagger.android.*;",
+        "import dagger.multibindings.IntoMap;",
+        "import javax.inject.*;",
+        "",
+        "@Module",
+        "abstract class AndroidModule {",
+        "  " + Joiner.on("\n  ").join(lines),
+        "}");
+  }
+
+  // TODO(dpb): Change these tests to use onLineContaining() instead of onLine().
+  private static final int LINES_BEFORE_METHOD = 12;
+
+  @Test
+  public void rawFactoryType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Factory bindRawFactory(FooActivity.Factory factory);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Factory");
+  }
+
+  @Test
+  public void rawBuilderType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder bindRawBuilder(FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder");
+  }
+
+  @Test
+  public void bindsToBuilderNotFactory() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder<? extends Activity> bindBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder<? extends android.app.Activity>");
+  }
+
+  @Test
+  public void providesToBuilderNotFactory() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Provides",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "static AndroidInjector.Builder<? extends Activity> bindBuilder(",
+            "    FooActivity.Builder builder) {",
+            "  return builder;",
+            "}");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder<? extends android.app.Activity>");
+  }
+
+  @Test
+  public void mapKeyDoesntMatchCoreType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@FragmentKey(BazFragment.class)",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWrongFrameworkType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAZ_FRAGMENT);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.FragmentKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement " + "AndroidInjector<test.BazFragment>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mapKeyDoesntMatchCoreType_AndroidInjectionKey() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@AndroidInjectionKey(\"test.BazFragment\")",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWrongFrameworkType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAZ_FRAGMENT);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "bindWrongFrameworkType(test.FooActivity.Builder) should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BazFragment>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mapKeyDoesntMatchCoreType_supportFragments() {
+    JavaFileObject supportFragment =
+        JavaFileObjects.forSourceLines(
+            "test.SupportFragment",
+            "package test;",
+            "",
+            "import android.support.v4.app.Fragment;",
+            "import dagger.android.AndroidInjector;",
+            "",
+            "public class SupportFragment extends Fragment {",
+            "  interface Factory extends AndroidInjector.Factory<SupportFragment> {}",
+            "}");
+
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@dagger.android.FragmentKey(BazFragment.class)",
+            "abstract AndroidInjector.Factory<? extends android.support.v4.app.Fragment> ",
+            "    bindWrongFrameworkType(SupportFragment.Factory factory);");
+    Compilation compilation = compile(module, BAZ_FRAGMENT, supportFragment);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.FragmentKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
+                + "dagger.android.AndroidInjector.Factory<? extends "
+                + "android.support.v4.app.Fragment>");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.SupportFragment.Factory does not implement AndroidInjector<test.BazFragment>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void bindsToConcreteTypeInsteadOfWildcard() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder<FooActivity> bindBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder<test.FooActivity>");
+  }
+
+  @Test
+  public void bindsToBaseTypeInsteadOfWildcard() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder<Activity> bindBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Binds methods' parameter type must be assignable to the return type");
+  }
+
+  @Test
+  public void bindsCorrectType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Factory<? extends Activity> bindCorrectType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindsCorrectType_AndroidInjectionKey() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@AndroidInjectionKey(\"test.FooActivity\")",
+            "abstract AndroidInjector.Factory<? extends Activity> bindCorrectType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindsWithScope() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "@Singleton",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWithScope(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("should not be scoped");
+  }
+
+  @Test
+  public void bindsWithScope_suppressWarnings() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@SuppressWarnings(\"dagger.android.ScopedInjectorFactory\")",
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "@Singleton",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWithScope(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void mismatchedMapKey_bindsFactory() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(BarActivity.class)",
+            "abstract AndroidInjector.Factory<?> mismatchedFactory(",
+            "    FooActivity.Factory factory);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Factory does not implement AndroidInjector<test.BarActivity>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mismatchedMapKey_bindsBuilder() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(BarActivity.class)",
+            "abstract AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BarActivity>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mismatchedMapKey_bindsBuilder_androidInjectionKey() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@AndroidInjectionKey(\"test.BarActivity\")",
+            "abstract AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BarActivity>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mismatchedMapKey_providesBuilder() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Provides",
+            "@IntoMap",
+            "@ActivityKey(BarActivity.class)",
+            "static AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
+            "    FooActivity.Builder builder) {",
+            "  return builder;",
+            "}");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindsQualifier_ignoresChecks() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "@Named(\"unused\")",
+            // normally this should fail, since it is binding to a Builder not a Factory
+            "abstract AndroidInjector.Builder<?> bindsBuilderWithQualifier(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindToPrimitive() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract int bindInt(@Named(\"unused\") int otherInt);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindToNonFrameworkClass() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract Number bindInt(Integer integer);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void invalidBindsMethod() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Factory<?> bindCorrectType(",
+            "    FooActivity.Builder builder, FooActivity.Builder builder2);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+  }
+
+  private Compilation compile(JavaFileObject... files) {
+    return javac().withProcessors(new ComponentProcessor(), new AndroidProcessor()).compile(files);
+  }
+}
diff --git a/javatests/dagger/android/processor/AndroidProcessorTest.java b/javatests/dagger/android/processor/AndroidProcessorTest.java
new file mode 100644
index 000000000..1a45bdd05
--- /dev/null
+++ b/javatests/dagger/android/processor/AndroidProcessorTest.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.common.truth.Truth8.assertThat;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class AndroidProcessorTest {
+  @Test
+  public void generatedProguardFile() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.android.AndroidInjectionKey;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @AndroidInjectionKey(\"test.TestActivity\")",
+            "  static int i() { ",
+            "    return 1;",
+            "  }",
+            "}");
+    Compilation enabled =
+        javac()
+            .withProcessors(new AndroidProcessor())
+            .withOptions("-Adagger.android.experimentalUseStringKeys=true")
+            .compile(module);
+    assertThat(enabled).succeeded();
+    assertThat(enabled)
+        .generatedFile(CLASS_OUTPUT, "META-INF/proguard/dagger.android.AndroidInjectionKeys");
+
+    Compilation disabled =
+        javac()
+            .withProcessors(new AndroidProcessor())
+            .withOptions("-Adagger.android.experimentalUseStringKeys=false")
+            .compile(module);
+    assertThat(disabled).succeeded();
+    assertThat(
+            disabled.generatedFile(
+                CLASS_OUTPUT, "META-INF/proguard/dagger.android.AndroidInjectionKeys"))
+        .isEmpty();
+
+    Compilation noFlag = javac().withProcessors(new AndroidProcessor()).compile(module);
+    assertThat(noFlag).succeeded();
+    assertThat(
+            noFlag.generatedFile(
+                CLASS_OUTPUT, "META-INF/proguard/dagger.android.AndroidInjectionKeys"))
+        .isEmpty();
+  }
+}
diff --git a/javatests/dagger/android/processor/BUILD b/javatests/dagger/android/processor/BUILD
new file mode 100644
index 000000000..8a9c16e67
--- /dev/null
+++ b/javatests/dagger/android/processor/BUILD
@@ -0,0 +1,42 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Tests for Dagger's Android integrations
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "android_processor_tests",
+    srcs = glob(["*.java"]),
+    functional = False,
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "@google_bazel_common//third_party/java/guava",
+        "@androidsdk//com.android.support:support-fragment-25.0.0",
+        # TODO(ronshapiro): create a common location to define the current Android version
+        "@androidsdk//:platforms/android-26/android.jar",
+        "@google_bazel_common//third_party/java/compile_testing",
+        "//:dagger_with_compiler",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/truth",
+        "@google_bazel_common//third_party/java/truth:truth8",
+        "//java/dagger/android",
+        "//java/dagger/android/processor",
+        "//java/dagger/internal/codegen:processor",
+    ],
+)
diff --git a/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java b/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
new file mode 100644
index 000000000..7ac0d53ac
--- /dev/null
+++ b/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ContributesAndroidInjectorTest {
+  private static final JavaFileObject TEST_ACTIVITY =
+      JavaFileObjects.forSourceLines(
+          "test.TestActivity",
+          "package test;",
+          "",
+          "import android.app.Activity;",
+          "",
+          "class TestActivity extends Activity {}");
+
+  @Test
+  public void notAbstract() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  static TestActivity test() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("must be abstract")
+        .inFile(module)
+        .onLineContaining("test()");
+  }
+
+  @Test
+  public void hasParameters() {
+    JavaFileObject otherActivity =
+        JavaFileObjects.forSourceLines(
+            "test.OtherActivity",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "",
+            "class OtherActivity extends Activity {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  abstract TestActivity oneParam(TestActivity one);",
+            "",
+            "  @ContributesAndroidInjector",
+            "  abstract OtherActivity manyParams(OtherActivity two, Object o);",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY, otherActivity);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("cannot have parameters")
+        .inFile(module)
+        .onLineContaining("oneParam(");
+    assertThat(compilation)
+        .hadErrorContaining("cannot have parameters")
+        .inFile(module)
+        .onLineContaining("manyParams(");
+  }
+
+  @Test
+  public void notInAModule() {
+    JavaFileObject randomFile =
+        JavaFileObjects.forSourceLines(
+            "test.RandomFile",
+            "package test;",
+            "",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "abstract class RandomFile {",
+            "  @ContributesAndroidInjector",
+            "  abstract TestActivity test() {}",
+            "}");
+
+    Compilation compilation = compile(randomFile, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("must be in a @Module")
+        .inFile(randomFile)
+        .onLineContaining("test()");
+  }
+
+  @Test
+  public void parameterizedReturnType() {
+    JavaFileObject parameterizedActivity =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedActivity",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "",
+            "class ParameterizedActivity<T> extends Activity {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  abstract <T> ParameterizedActivity<T> test();",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY, parameterizedActivity);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("cannot return parameterized types")
+        .inFile(module)
+        .onLineContaining("test()");
+  }
+
+  @Test
+  public void notAFrameworkType() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  abstract android.content.Intent intent();",
+            "}");
+
+    Compilation compilation = compile(module);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("is not a framework type")
+        .inFile(module)
+        .onLineContaining("intent()");
+  }
+
+  @Test
+  public void moduleIsntModule() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector(modules = android.content.Intent.class)",
+            "  abstract TestActivity test();",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Intent is not a @Module")
+        .inFile(module)
+        .onLineContaining("modules = android.content.Intent.class");
+  }
+
+  @Test
+  public void hasQualifier() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Qualifier @interface AndroidQualifier {}",
+            "",
+            "  @AndroidQualifier",
+            "  @ContributesAndroidInjector",
+            "  abstract TestActivity test();",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@ContributesAndroidInjector methods cannot have qualifiers")
+        .inFile(module)
+        .onLineContaining("@AndroidQualifier");
+  }
+
+  private static Compilation compile(JavaFileObject... javaFileObjects) {
+    return javac().withProcessors(new AndroidProcessor()).compile(javaFileObjects);
+  }
+}
diff --git a/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
new file mode 100644
index 000000000..76167511e
--- /dev/null
+++ b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ComponentProcessor;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class DuplicateAndroidInjectorsCheckerTest {
+  @Test
+  public void conflictingMapKeys() {
+    JavaFileObject activity =
+        JavaFileObjects.forSourceLines(
+            "test.TestActivity",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "",
+            "public class TestActivity extends Activity {}");
+    JavaFileObject injectorFactory =
+        JavaFileObjects.forSourceLines(
+            "test.TestInjectorFactory",
+            "package test;",
+            "",
+            "import dagger.android.AndroidInjector;",
+            "import javax.inject.Inject;",
+            "",
+            "class TestInjectorFactory implements AndroidInjector.Factory<TestActivity> {",
+            "  @Inject TestInjectorFactory() {}",
+            "",
+            "  @Override",
+            "  public AndroidInjector<TestActivity> create(TestActivity instance) { return null; }",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.android.*;",
+            "import dagger.multibindings.*;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Binds",
+            "  @IntoMap",
+            "  @ActivityKey(TestActivity.class)",
+            "  AndroidInjector.Factory<? extends Activity> classKey(TestInjectorFactory factory);",
+            "",
+            "  @Binds",
+            "  @IntoMap",
+            "  @AndroidInjectionKey(\"test.TestActivity\")",
+            "  AndroidInjector.Factory<? extends Activity> stringKey(TestInjectorFactory factory);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "import dagger.Component;",
+            "import dagger.android.DispatchingAndroidInjector;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  DispatchingAndroidInjector<Activity> dispatchingInjector();",
+            "}");
+
+    Compilation compilation =
+        javac()
+            .withProcessors(ComponentProcessor.forTesting(new DuplicateAndroidInjectorsChecker()))
+            .compile(activity, injectorFactory, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Multiple injector factories bound for the same type")
+        .inFile(component)
+        .onLineContaining("dispatchingInjector()");
+    assertThat(compilation).hadErrorContaining("classKey(test.TestInjectorFactory)");
+    assertThat(compilation).hadErrorContaining("stringKey(test.TestInjectorFactory)");
+    assertThat(compilation).hadErrorCount(1);
+  }
+}
diff --git a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
index 271bafc94..1382af1ed 100644
--- a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
+++ b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
@@ -36,6 +36,7 @@
 import dagger.android.support.FragmentKey;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ContentProviderSubcomponent.ContentProviderModule;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.InnerActivitySubcomponent.InnerActivityModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
 import dagger.multibindings.IntoMap;
@@ -56,6 +57,7 @@
     @Module(
       subcomponents = {
         ActivitySubcomponent.class,
+        InnerActivitySubcomponent.class,
         ParentFragmentSubcomponent.class,
         ChildFragmentSubcomponent.class,
         DialogFragmentSubcomponent.class,
@@ -78,6 +80,12 @@
       abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
           ActivitySubcomponent.Builder builder);
 
+      @Binds
+      @IntoMap
+      @ActivityKey(OuterClass.TestInnerClassActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForInnerActivity(
+          InnerActivitySubcomponent.Builder builder);
+
       @Binds
       @IntoMap
       @FragmentKey(TestParentFragment.class)
@@ -136,6 +144,21 @@
       abstract class Builder extends AndroidInjector.Builder<TestActivity> {}
     }
 
+    @Subcomponent(modules = InnerActivityModule.class)
+    interface InnerActivitySubcomponent extends AndroidInjector<OuterClass.TestInnerClassActivity> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<OuterClass.TestInnerClassActivity> {}
+
+      @Module
+      abstract class InnerActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return InnerActivitySubcomponent.class;
+        }
+      }
+    }
+
     @Subcomponent(modules = ParentFragmentSubcomponent.ParentFragmentModule.class)
     interface ParentFragmentSubcomponent extends AndroidInjector<TestParentFragment> {
       @Module
diff --git a/javatests/dagger/android/support/functional/AndroidManifest.xml b/javatests/dagger/android/support/functional/AndroidManifest.xml
index 1ace8cb8f..c89d30667 100644
--- a/javatests/dagger/android/support/functional/AndroidManifest.xml
+++ b/javatests/dagger/android/support/functional/AndroidManifest.xml
@@ -16,7 +16,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="dagger.android.support.functional">
 
-  <application android:theme="@style/Theme.AppCompat">
+  <application android:theme="@style/Theme.AppCompat"
+      android:name=".UsesGeneratedModulesApplication">
     <activity android:name="dagger.android.support.functional.ParentOfFragmentActivity"/>
     <activity android:name="dagger.android.support.functional.SiblingOfFragmentActivity"/>
     <activity android:name="dagger.android.support.functional.InjectedWithoutSubcomponentActivity"/>
diff --git a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
index 9490f48e5..379c795f0 100644
--- a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
+++ b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
@@ -36,6 +36,7 @@
 import dagger.android.support.FragmentKey;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ContentProviderSubcomponent.ContentProviderModule;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.InnerActivitySubcomponent.InnerActivityModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
 import dagger.multibindings.IntoMap;
@@ -58,6 +59,7 @@
     @Module(
       subcomponents = {
         ActivitySubcomponent.class,
+        InnerActivitySubcomponent.class,
         ServiceSubcomponent.class,
         IntentServiceSubcomponent.class,
         BroadcastReceiverSubcomponent.class,
@@ -77,6 +79,12 @@
       abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
           ActivitySubcomponent.Builder builder);
 
+      @Binds
+      @IntoMap
+      @ActivityKey(OuterClass.TestInnerClassActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForInnerActivity(
+          InnerActivitySubcomponent.Builder builder);
+
       @Binds
       @IntoMap
       @ServiceKey(TestService.class)
@@ -180,6 +188,21 @@
       }
     }
 
+    @Subcomponent(modules = InnerActivityModule.class)
+    interface InnerActivitySubcomponent extends AndroidInjector<OuterClass.TestInnerClassActivity> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<OuterClass.TestInnerClassActivity> {}
+
+      @Module
+      abstract class InnerActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return InnerActivitySubcomponent.class;
+        }
+      }
+    }
+
     @Subcomponent(modules = ServiceModule.class)
     interface ServiceSubcomponent extends AndroidInjector<TestService> {
       @Subcomponent.Builder
diff --git a/javatests/dagger/android/support/functional/InjectorsTest.java b/javatests/dagger/android/support/functional/InjectorsTest.java
index 7303e2b1c..277b156c1 100644
--- a/javatests/dagger/android/support/functional/InjectorsTest.java
+++ b/javatests/dagger/android/support/functional/InjectorsTest.java
@@ -127,6 +127,14 @@ public void componentStructureFollowsControllerStructure() {
                 .ContentProviderSubcomponent.class);
 
     changeConfiguration();
+
+    OuterClass.TestInnerClassActivity innerClassActivity =
+        Robolectric.setupActivity(OuterClass.TestInnerClassActivity.class);
+    assertThat(innerClassActivity.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .InnerActivitySubcomponent.class);
   }
 
   @Test
@@ -177,6 +185,14 @@ public void allControllersAreDirectChildrenOfApplication() {
                 .ContentProviderSubcomponent.class);
 
     changeConfiguration();
+
+    OuterClass.TestInnerClassActivity innerClassActivity =
+        Robolectric.setupActivity(OuterClass.TestInnerClassActivity.class);
+    assertThat(innerClassActivity.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .InnerActivitySubcomponent.class);
   }
 
   @Test
@@ -224,6 +240,13 @@ public void usesGeneratedModules() {
         Robolectric.setupActivity(TestActivityWithScope.class);
     assertThat(activityWithScope.scopedStringProvider.get())
         .isSameAs(activityWithScope.scopedStringProvider.get());
+
+    OuterClass.TestInnerClassActivity innerClassActivity =
+        Robolectric.setupActivity(OuterClass.TestInnerClassActivity.class);
+    assertThat(innerClassActivity.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyInnerActivitySubcomponent.class);
   }
 
   // https://github.com/google/dagger/issues/598
diff --git a/javatests/dagger/android/support/functional/OuterClass.java b/javatests/dagger/android/support/functional/OuterClass.java
new file mode 100644
index 000000000..e5d6ed595
--- /dev/null
+++ b/javatests/dagger/android/support/functional/OuterClass.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import dagger.android.support.DaggerAppCompatActivity;
+import java.util.Set;
+import javax.inject.Inject;
+
+final class OuterClass {
+  public static class TestInnerClassActivity extends DaggerAppCompatActivity {
+    @Inject
+    Set<Class<?>> componentHierarchy;
+  }
+}
diff --git a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
index 661426244..cf340e319 100644
--- a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
+++ b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
@@ -55,6 +55,9 @@
     @ContributesAndroidInjector(modules = DummyActivitySubcomponent.AddToHierarchy.class)
     abstract TestActivity contributeTestActivityInjector();
 
+    @ContributesAndroidInjector(modules = DummyInnerActivitySubcomponent.AddToHierarchy.class)
+    abstract OuterClass.TestInnerClassActivity contributeInnerActivityInjector();
+
     @ContributesAndroidInjector(modules = DummyParentFragmentSubcomponent.AddToHierarchy.class)
     abstract TestParentFragment contributeTestParentFragmentInjector();
 
@@ -101,6 +104,17 @@ static String provideScopedString() {
     }
   }
 
+  interface DummyInnerActivitySubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyInnerActivitySubcomponent.class;
+      }
+    }
+  }
+
   interface DummyParentFragmentSubcomponent {
     @Module
     abstract class AddToHierarchy {
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
new file mode 100644
index 000000000..ac1b7cdbf
--- /dev/null
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.CompilerMode.AHEAD_OF_TIME_SUBCOMPONENTS_MODE;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class AheadOfTimeSubcomponentsTest {
+  @Test
+  public void simpleSubcomponent() {
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface Child {",
+            "  String string();",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Provides String provideString() { return \"florp\"; }",
+            "}");
+
+    JavaFileObject generatedSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  private TestModule testModule;",
+            "",
+            "  protected DaggerChild() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.testModule = new TestModule();",
+            "  }",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return TestModule_ProvideStringFactory.proxyProvideString(testModule);",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(subcomponent, module);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedSubcomponent);
+  }
+
+  @Test
+  public void subcomponent_MissingBinding() {
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  String string();",
+            "}");
+
+    JavaFileObject generatedSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return null;",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(subcomponent);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedSubcomponent);
+  }
+
+  @Test
+  public void subcomponent_BuilderAndGeneratedInstanceBinding() {
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  Integer i();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder module(GrandchildModule module);",
+            "",
+            "    Grandchild build();",
+            "  }",
+            "}");
+
+    JavaFileObject grandchildModule =
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class GrandchildModule {",
+            "  @Provides static Integer provideInteger() { return 0; }",
+            "}");
+
+    JavaFileObject generatedGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandchild",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandchild implements Grandchild {",
+            "  protected DaggerGrandchild(Builder builder) {}",
+            "",
+            "  @Override",
+            "  public Integer i() {",
+            "    return GrandchildModule_ProvideIntegerFactory.proxyProvideInteger();",
+            "  }",
+            "",
+            "  protected abstract static class Builder implements Grandchild.Builder {",
+            "",
+            "    @Override",
+            "    public Builder module(GrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Grandchild.Builder grandchild();",
+            "}");
+
+    JavaFileObject generatedChild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  @Override",
+            "  public Grandchild.Builder grandchild() {",
+            "    return null;",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(child, grandchild, grandchildModule);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandchild")
+        .hasSourceEquivalentTo(generatedGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedChild);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/BindingGraphCapturer.java b/javatests/dagger/internal/codegen/BindingGraphCapturer.java
index b06b504b0..503fd47f4 100644
--- a/javatests/dagger/internal/codegen/BindingGraphCapturer.java
+++ b/javatests/dagger/internal/codegen/BindingGraphCapturer.java
@@ -32,7 +32,14 @@
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    bindingGraphs.put(bindingGraph.rootComponentNode().toString(), bindingGraph);
+    bindingGraphs.put(
+        bindingGraph
+            .rootComponentNode()
+            .componentPath()
+            .currentComponent()
+            .getQualifiedName()
+            .toString(),
+        bindingGraph);
   }
 
   /** Returns a map of binding graphs, indexed by the canonical name of the root component type. */
diff --git a/javatests/dagger/internal/codegen/CompilerMode.java b/javatests/dagger/internal/codegen/CompilerMode.java
index 2173c2639..4dcc21548 100644
--- a/javatests/dagger/internal/codegen/CompilerMode.java
+++ b/javatests/dagger/internal/codegen/CompilerMode.java
@@ -22,7 +22,8 @@
 /** The configuration options for compiler modes. */
 enum CompilerMode {
   DEFAULT_MODE,
-  FAST_INIT_MODE("-Adagger.fastInit=enabled");
+  FAST_INIT_MODE("-Adagger.fastInit=enabled"),
+  AHEAD_OF_TIME_SUBCOMPONENTS_MODE("-Adagger.experimentalAheadOfTimeSubcomponents=enabled");
 
   /** Returns the compiler modes as a list of parameters for parameterized tests */
   static final ImmutableList<Object[]> TEST_PARAMETERS =
diff --git a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
index c11d04fbc..bd7ccb744 100644
--- a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -71,6 +71,85 @@
     assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
+  @Test // b/79859714
+  public void bindsWithChildScope_inParentModule_notAllowed() {
+    JavaFileObject childScope =
+        JavaFileObjects.forSourceLines(
+            "test.ChildScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface ChildScope {}");
+
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "", //
+            "interface Foo {}");
+
+    JavaFileObject fooImpl =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class FooImpl implements Foo {",
+            "  @Inject FooImpl() {}",
+            "}");
+
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface ParentModule {",
+            "  @Binds @ChildScope Foo bind(FooImpl fooImpl);",
+            "}");
+
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@ChildScope",
+            "@Subcomponent",
+            "interface Child {",
+            "  Foo foo();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(childScope, foo, fooImpl, parentModule, parent, child);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.Parent scoped with @Singleton may not reference bindings with different scopes:\n"
+                + "      @Binds @test.ChildScope test.Foo test.ParentModule.bind(test.FooImpl)");
+  }
+
   @Test public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
         "package test;",
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index cd64d7685..2abceae51 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -616,7 +616,7 @@ public void cyclicDependencyInSubcomponents() {
             "",
             "@Component",
             "interface Parent {",
-            "  Child child();",
+            "  Child.Builder child();",
             "}");
     JavaFileObject child =
         JavaFileObjects.forSourceLines(
@@ -625,9 +625,14 @@ public void cyclicDependencyInSubcomponents() {
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = ChildModule.class)",
+            "@Subcomponent(modules = CycleModule.class)",
             "interface Child {",
-            "  Grandchild grandchild();",
+            "  Grandchild.Builder grandchild();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
             "}");
     JavaFileObject grandchild =
         JavaFileObjects.forSourceLines(
@@ -639,17 +644,22 @@ public void cyclicDependencyInSubcomponents() {
             "@Subcomponent",
             "interface Grandchild {",
             "  String entry();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Grandchild build();",
+            "  }",
             "}");
-    JavaFileObject childModule =
+    JavaFileObject cycleModule =
         JavaFileObjects.forSourceLines(
-            "test.ChildModule",
+            "test.CycleModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
             "",
             "@Module",
-            "abstract class ChildModule {",
+            "abstract class CycleModule {",
             "  @Provides static Object object(String string) {",
             "    return string;",
             "  }",
@@ -659,20 +669,102 @@ public void cyclicDependencyInSubcomponents() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, childModule);
+    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, cycleModule);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
             message(
                 "[test.Grandchild.entry()] Found a dependency cycle:",
                 "java.lang.String is injected at",
-                "    test.ChildModule.object(string)",
+                "    test.CycleModule.object(string)",
                 "java.lang.Object is injected at",
-                "    test.ChildModule.string(object)",
+                "    test.CycleModule.string(object)",
                 "java.lang.String is provided at",
                 "    test.Grandchild.entry()"))
         .inFile(parent)
-        .onLineContaining("interface Parent {");
+        .onLineContaining("interface Parent");
+  }
+
+  @Test
+  public void cyclicDependencyInSubcomponentsWithChildren() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Parent {",
+            "  Child.Builder child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = CycleModule.class)",
+            "interface Child {",
+            "  String entry();",
+            "",
+            "  Grandchild grandchild();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "}");
+    // Grandchild has no entry point that depends on the cycle. http://b/111317986
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Grandchild build();",
+            "  }",
+            "}");
+    JavaFileObject cycleModule =
+        JavaFileObjects.forSourceLines(
+            "test.CycleModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class CycleModule {",
+            "  @Provides static Object object(String string) {",
+            "    return string;",
+            "  }",
+            "",
+            "  @Provides static String string(Object object) {",
+            "    return object.toString();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, cycleModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "[test.Child.entry()] Found a dependency cycle:",
+                "java.lang.String is injected at",
+                "    test.CycleModule.object(string)",
+                "java.lang.Object is injected at",
+                "    test.CycleModule.string(object)",
+                "java.lang.String is provided at",
+                "    test.Child.entry()"))
+        .inFile(parent)
+        .onLineContaining("interface Parent");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 8c3299960..4486dd733 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -351,19 +351,18 @@ public void simpleComponent() {
                 "  }",
                 "",
                 "  public static final class Builder {",
-                "    private TestClass.BModule bModule;",
-                "",
                 "    private TestClass.AModule aModule;",
+                "    private TestClass.BModule bModule;",
                 "",
                 "    private Builder() {}",
                 "",
                 "    public TestClass.SimpleComponent build() {",
-                "      if (bModule == null) {",
-                "        this.bModule = new TestClass.BModule();",
-                "      }",
                 "      if (aModule == null) {",
                 "        this.aModule = new TestClass.AModule();",
                 "      }",
+                "      if (bModule == null) {",
+                "        this.bModule = new TestClass.BModule();",
+                "      }",
                 "      return new DaggerTestClass_SimpleComponent(this);",
                 "    }",
                 "",
@@ -479,18 +478,18 @@ public void simpleComponent() {
                 "  }",
                 "",
                 "  public static final class Builder {",
-                "    private TestClass.BModule bModule;",
                 "    private TestClass.AModule aModule;",
+                "    private TestClass.BModule bModule;",
                 "",
                 "    private Builder() {}",
                 "",
                 "    public TestClass.SimpleComponent build() {",
-                "      if (bModule == null) {",
-                "        this.bModule = new TestClass.BModule();",
-                "      }",
                 "      if (aModule == null) {",
                 "        this.aModule = new TestClass.AModule();",
                 "      }",
+                "      if (bModule == null) {",
+                "        this.bModule = new TestClass.BModule();",
+                "      }",
                 "      return new DaggerTestClass_SimpleComponent(this);",
                 "    }",
                 "",
