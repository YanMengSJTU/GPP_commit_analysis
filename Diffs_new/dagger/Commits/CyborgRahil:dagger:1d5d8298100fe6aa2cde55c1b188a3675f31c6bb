diff --git a/java/dagger/internal/codegen/DaggerElements.java b/java/dagger/internal/codegen/DaggerElements.java
index 0ac07b8ed..5faab26e4 100644
--- a/java/dagger/internal/codegen/DaggerElements.java
+++ b/java/dagger/internal/codegen/DaggerElements.java
@@ -49,6 +49,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Name;
@@ -171,6 +172,19 @@ private StringBuilder enclosingTypeAndMemberName(Element element) {
         }
       };
 
+  /** A formatter that calls {@link #elementToString(Element)}. */
+  static Formatter<Element> elementFormatter() {
+    return ELEMENT_FORMATTER;
+  }
+
+  private static final Formatter<Element> ELEMENT_FORMATTER =
+      new Formatter<Element>() {
+        @Override
+        public String format(Element element) {
+          return elementToString(element);
+        }
+      };
+
   /** Returns the argument or the closest enclosing element that is a {@link TypeElement}. */
   static TypeElement closestEnclosingTypeElement(Element element) {
     return element.accept(CLOSEST_ENCLOSING_TYPE_ELEMENT, null);
@@ -194,7 +208,15 @@ public TypeElement visitType(TypeElement type, Void p) {
    * elements enclosed by the same parent.
    */
   static final Comparator<Element> DECLARATION_ORDER =
-      comparing(element -> element.getEnclosingElement().getEnclosedElements().indexOf(element));
+      comparing(element -> siblings(element).indexOf(element));
+
+  // For parameter elements, element.getEnclosingElement().getEnclosedElements() is empty. So
+  // instead look at the parameter list of the enclosing executable.
+  private static List<? extends Element> siblings(Element element) {
+    return element.getKind().equals(ElementKind.PARAMETER)
+        ? asExecutable(element.getEnclosingElement()).getParameters()
+        : element.getEnclosingElement().getEnclosedElements();
+  }
 
   /**
    * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index 9c6c13b21..cdbdcff03 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -27,10 +27,12 @@
 import static dagger.internal.codegen.DaggerElements.DECLARATION_ORDER;
 import static dagger.internal.codegen.DaggerElements.closestEnclosingTypeElement;
 import static dagger.internal.codegen.DaggerElements.elementEncloses;
+import static dagger.internal.codegen.DaggerElements.elementFormatter;
 import static dagger.internal.codegen.DaggerElements.elementToString;
 import static dagger.internal.codegen.DaggerGraphs.shortestPath;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.presentValues;
+import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.ValidationType.NONE;
 import static java.util.Collections.min;
@@ -59,7 +61,6 @@
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
 import java.util.Comparator;
-import java.util.Formatter;
 import java.util.Set;
 import java.util.function.Function;
 import javax.annotation.processing.Messager;
@@ -253,12 +254,12 @@ void printMessage(
 
     private void appendComponentPathUnlessAtRoot(StringBuilder message, Node node) {
       if (!node.componentPath().equals(graph.rootComponentNode().componentPath())) {
-        new Formatter(message).format(" [%s]", node.componentPath());
+        message.append(String.format(" [%s]", node.componentPath()));
       }
     }
 
     private void appendBracketPrefix(StringBuilder message, String prefix) {
-      new Formatter(message).format("[%s] ", prefix);
+      message.append(String.format("[%s] ", prefix));
     }
 
     /** The diagnostic information associated with an error. */
@@ -322,44 +323,48 @@ public String toString() {
               .append("\nIt is")
               .append(graph.isModuleBindingGraph() ? " " : " also ")
               .append("requested at:");
-          for (Element request : requestsToPrint) {
-            message.append("\n    ").append(elementToString(request));
-          }
+          elementFormatter().formatIndentedList(message, requestsToPrint, 1);
         }
 
         // Print the remaining entry points, showing which component they're in, unless we're in a
         // module binding graph
         if (!graph.isModuleBindingGraph() && entryPoints.size() > 1) {
           message.append("\nThe following other entry points also depend on it:");
-          entryPoints.stream()
-              .filter(entryPoint -> !entryPoint.equals(getLast(dependencyTrace)))
-              .sorted(
-                  // start with entry points in components closest to the root
-                  rootComponentFirst()
-                      // then list entry points declared in the component before those declared in a
-                      // supertype
-                      .thenComparing(nearestComponentSupertypeFirst())
-                      // finally list entry points in declaration order in their declaring type
-                      .thenComparing(requestElementDeclarationOrder()))
-              .forEachOrdered(
-                  entryPoint -> {
-                    message.append("\n    ");
-                    Element requestElement = entryPoint.dependencyRequest().requestElement().get();
-                    message.append(elementToString(requestElement));
-
-                    // For entry points declared in subcomponents or supertypes of the root
-                    // component, append the component path to make clear to the user which
-                    // component it's in.
-                    ComponentPath componentPath = source(entryPoint).componentPath();
-                    if (!componentPath.atRoot()
-                        || !requestElement.getEnclosingElement().equals(rootComponent)) {
-                      message.append(String.format(" [%s]", componentPath));
-                    }
-                  });
+          entryPointFormatter.formatIndentedList(
+              message,
+              entryPoints.stream()
+                  .filter(entryPoint -> !entryPoint.equals(getLast(dependencyTrace)))
+                  .sorted(
+                      // 1. List entry points in components closest to the root first.
+                      // 2. List entry points declared in a component before those in a supertype.
+                      // 3. List entry points in declaration order in their declaring type.
+                      rootComponentFirst()
+                          .thenComparing(nearestComponentSupertypeFirst())
+                          .thenComparing(requestElementDeclarationOrder()))
+                  .collect(toImmutableList()),
+              1);
         }
         return message.toString();
       }
 
+      private final Formatter<DependencyEdge> entryPointFormatter =
+          new Formatter<DependencyEdge>() {
+            @Override
+            public String format(DependencyEdge object) {
+              Element requestElement = object.dependencyRequest().requestElement().get();
+              StringBuilder element = new StringBuilder(elementToString(requestElement));
+
+              // For entry points declared in subcomponents or supertypes of the root component,
+              // append the component path to make clear to the user which component it's in.
+              ComponentPath componentPath = source(object).componentPath();
+              if (!componentPath.atRoot()
+                  || !requestElement.getEnclosingElement().equals(rootComponent)) {
+                element.append(String.format(" [%s]", componentPath));
+              }
+              return element.toString();
+            }
+          };
+
       private boolean isTracedRequest(DependencyEdge request) {
         return !dependencyTrace.isEmpty() && request.equals(dependencyTrace.get(0));
       }
diff --git a/javatests/dagger/internal/codegen/MissingBindingValidationTest.java b/javatests/dagger/internal/codegen/MissingBindingValidationTest.java
index 661379459..8eaa8d5a2 100644
--- a/javatests/dagger/internal/codegen/MissingBindingValidationTest.java
+++ b/javatests/dagger/internal/codegen/MissingBindingValidationTest.java
@@ -663,4 +663,118 @@ public void manyDependencies() {
         .onLineContaining("interface TestComponent");
     assertThat(compilation).hadErrorCount(1);
   }
+
+  @Test
+  public void tooManyRequests() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Foo {",
+            "  @Inject Foo(",
+            "      String one,",
+            "      String two,",
+            "      String three,",
+            "      String four,",
+            "      String five,",
+            "      String six,",
+            "      String seven,",
+            "      String eight,",
+            "      String nine,",
+            "      String ten,",
+            "      String eleven,",
+            "      String twelve,",
+            "      String thirteen) {",
+            "  }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  String string();",
+            "  Foo foo();",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "[Dagger/MissingBinding] java.lang.String cannot be provided without an @Inject "
+                    + "constructor or an @Provides-annotated method.",
+                "    java.lang.String is provided at",
+                "        test.TestComponent.string()",
+                "It is also requested at:",
+                "    test.Foo(one, …)",
+                "    test.Foo(…, two, …)",
+                "    test.Foo(…, three, …)",
+                "    test.Foo(…, four, …)",
+                "    test.Foo(…, five, …)",
+                "    test.Foo(…, six, …)",
+                "    test.Foo(…, seven, …)",
+                "    test.Foo(…, eight, …)",
+                "    test.Foo(…, nine, …)",
+                "    test.Foo(…, ten, …)",
+                "    and 3 others"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void tooManyEntryPoints() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  String string1();",
+            "  String string2();",
+            "  String string3();",
+            "  String string4();",
+            "  String string5();",
+            "  String string6();",
+            "  String string7();",
+            "  String string8();",
+            "  String string9();",
+            "  String string10();",
+            "  String string11();",
+            "  String string12();",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "[Dagger/MissingBinding] java.lang.String cannot be provided without an @Inject "
+                    + "constructor or an @Provides-annotated method.",
+                "    java.lang.String is provided at",
+                "        test.TestComponent.string1()",
+                "The following other entry points also depend on it:",
+                "    test.TestComponent.string2()",
+                "    test.TestComponent.string3()",
+                "    test.TestComponent.string4()",
+                "    test.TestComponent.string5()",
+                "    test.TestComponent.string6()",
+                "    test.TestComponent.string7()",
+                "    test.TestComponent.string8()",
+                "    test.TestComponent.string9()",
+                "    test.TestComponent.string10()",
+                "    test.TestComponent.string11()",
+                "    and 1 other"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
 }
