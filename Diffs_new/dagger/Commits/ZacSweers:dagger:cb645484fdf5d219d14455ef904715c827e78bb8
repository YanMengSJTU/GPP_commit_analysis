diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 1f0e20665..e7b6b6053 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -83,6 +83,7 @@ java_library(
         "ClearableCache.java",
         "CodeBlocks.java",
         "CompilerOptions.java",
+        "ComponentAnnotation.java",
         "ContributionType.java",
         "DaggerElements.java",
         "DaggerStatistics.java",
diff --git a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index 5ff1d14c5..6ee2485ec 100644
--- a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -17,9 +17,8 @@
 package dagger.internal.codegen;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentOrSubcomponentAnnotation;
+import static dagger.internal.codegen.ComponentAnnotation.anyComponentAnnotation;
 import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
-import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static javax.lang.model.element.ElementKind.METHOD;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.type.TypeKind.DECLARED;
@@ -92,14 +91,14 @@ private void validateBindsInstanceMethod(
     TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
     moduleAnnotation(enclosingType)
         .ifPresent(moduleAnnotation -> report.addError(didYouMeanBinds(moduleAnnotation)));
-    getComponentOrSubcomponentAnnotation(enclosingType)
+    anyComponentAnnotation(enclosingType)
         .ifPresent(
             componentAnnotation ->
                 report.addError(
                     String.format(
                         "@BindsInstance methods should not be included in @%1$ss. "
                             + "Did you mean to put it in a @%1$s.Builder?",
-                        simpleName(componentAnnotation))));
+                        componentAnnotation.simpleName())));
   }
 
   private static String didYouMeanBinds(ModuleAnnotation moduleAnnotation) {
diff --git a/java/dagger/internal/codegen/ComponentAnnotation.java b/java/dagger/internal/codegen/ComponentAnnotation.java
new file mode 100644
index 000000000..41cbabe5a
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentAnnotation.java
@@ -0,0 +1,309 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreTypes.asTypeElements;
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.collect.Sets.union;
+import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
+import static dagger.internal.codegen.DaggerStreams.toImmutableList;
+import static dagger.internal.codegen.MoreAnnotationValues.asAnnotationValues;
+
+import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import dagger.Component;
+import dagger.Subcomponent;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import java.util.Optional;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * A {@code @Component}, {@code @Subcomponent}, {@code @ProductionComponent}, or
+ * {@code @ProductionSubcomponent} annotation, or a {@code @Module} or {@code @ProducerModule}
+ * annotation that is being treated as a component annotation when validating full binding graphs
+ * for modules.
+ */
+abstract class ComponentAnnotation {
+  /** The annotation itself. */
+  abstract AnnotationMirror annotation();
+
+  /** The simple name of the annotation type. */
+  String simpleName() {
+    return MoreAnnotationMirrors.simpleName(annotation()).toString();
+  }
+
+  /**
+   * Returns {@code true} if the annotation is a {@code @Subcomponent} or
+   * {@code @ProductionSubcomponent}.
+   */
+  abstract boolean isSubcomponent();
+
+  /**
+   * Returns {@code true} if the annotation is a {@code @ProductionComponent},
+   * {@code @ProductionSubcomponent}, or {@code @ProducerModule}.
+   */
+  abstract boolean isProduction();
+
+  /**
+   * Returns {@code true} if the annotation is a real component annotation and not a module
+   * annotation.
+   */
+  abstract boolean isRealComponent();
+
+  /** The values listed as {@code dependencies}. */
+  abstract ImmutableList<AnnotationValue> dependencyValues();
+
+  /** The types listed as {@code dependencies}. */
+  ImmutableList<TypeMirror> dependencyTypes() {
+    return dependencyValues().stream().map(MoreAnnotationValues::asType).collect(toImmutableList());
+  }
+
+  /**
+   * The types listed as {@code dependencies}.
+   *
+   * @throws IllegalArgumentException if any of {@link #dependencyTypes()} are error types
+   */
+  ImmutableList<TypeElement> dependencies() {
+    return asTypeElements(dependencyTypes()).asList();
+  }
+
+  /** The values listed as {@code modules}. */
+  abstract ImmutableList<AnnotationValue> moduleValues();
+
+  /** The types listed as {@code modules}. */
+  ImmutableList<TypeMirror> moduleTypes() {
+    return moduleValues().stream().map(MoreAnnotationValues::asType).collect(toImmutableList());
+  }
+
+  /**
+   * The types listed as {@code modules}.
+   *
+   * @throws IllegalArgumentException if any of {@link #moduleTypes()} are error types
+   */
+  ImmutableSet<TypeElement> modules() {
+    return asTypeElements(moduleTypes());
+  }
+
+  protected final ImmutableList<AnnotationValue> getAnnotationValues(String parameterName) {
+    return asAnnotationValues(getAnnotationValue(annotation(), parameterName));
+  }
+
+  /**
+   * Returns an object representing a root component annotation, not a subcomponent annotation, if
+   * one is present on {@code typeElement}.
+   */
+  static Optional<ComponentAnnotation> rootComponentAnnotation(TypeElement typeElement) {
+    return anyComponentAnnotation(typeElement, rootComponentAnnotations());
+  }
+
+  /**
+   * Returns an object representing a subcomponent annotation, if one is present on {@code
+   * typeElement}.
+   */
+  static Optional<ComponentAnnotation> subcomponentAnnotation(TypeElement typeElement) {
+    return anyComponentAnnotation(typeElement, subcomponentAnnotations());
+  }
+
+  /**
+   * Returns an object representing a root component or subcomponent annotation, if one is present
+   * on {@code typeElement}.
+   */
+  static Optional<ComponentAnnotation> anyComponentAnnotation(TypeElement typeElement) {
+    return anyComponentAnnotation(typeElement, allComponentAnnotations());
+  }
+
+  private static Optional<ComponentAnnotation> anyComponentAnnotation(
+      TypeElement typeElement, Collection<Class<? extends Annotation>> annotations) {
+    return getAnyAnnotation(typeElement, annotations).map(ComponentAnnotation::componentAnnotation);
+  }
+
+  /** Returns {@code true} if the argument is a component annotation. */
+  static boolean isComponentAnnotation(AnnotationMirror annotation) {
+    return allComponentAnnotations().stream()
+        .anyMatch(annotationClass -> isTypeOf(annotationClass, annotation.getAnnotationType()));
+  }
+
+  /** Creates an object representing a component or subcomponent annotation. */
+  static ComponentAnnotation componentAnnotation(AnnotationMirror annotation) {
+    RealComponentAnnotation.Builder annotationBuilder =
+        RealComponentAnnotation.builder().annotation(annotation);
+
+    if (isTypeOf(Component.class, annotation.getAnnotationType())) {
+      return annotationBuilder.isProduction(false).isSubcomponent(false).build();
+    }
+    if (isTypeOf(Subcomponent.class, annotation.getAnnotationType())) {
+      return annotationBuilder.isProduction(false).isSubcomponent(true).build();
+    }
+    if (isTypeOf(ProductionComponent.class, annotation.getAnnotationType())) {
+      return annotationBuilder.isProduction(true).isSubcomponent(false).build();
+    }
+    if (isTypeOf(ProductionSubcomponent.class, annotation.getAnnotationType())) {
+      return annotationBuilder.isProduction(true).isSubcomponent(true).build();
+    }
+    throw new IllegalArgumentException(
+        annotation
+            + " must be a Component, Subcomponent, ProductionComponent, "
+            + "or ProductionSubcomponent annotation");
+  }
+
+  /** Creates a fictional component annotation representing a module. */
+  static ComponentAnnotation fromModuleAnnotation(ModuleAnnotation moduleAnnotation) {
+    return new AutoValue_ComponentAnnotation_FictionalComponentAnnotation(moduleAnnotation);
+  }
+
+  /** The root component annotation types. */
+  static ImmutableSet<Class<? extends Annotation>> rootComponentAnnotations() {
+    return ImmutableSet.of(Component.class, ProductionComponent.class);
+  }
+
+  /** The subcomponent annotation types. */
+  static ImmutableSet<Class<? extends Annotation>> subcomponentAnnotations() {
+    return ImmutableSet.of(Subcomponent.class, ProductionSubcomponent.class);
+  }
+
+  /** All component annotation types. */
+  static ImmutableSet<Class<? extends Annotation>> allComponentAnnotations() {
+    return union(rootComponentAnnotations(), subcomponentAnnotations()).immutableCopy();
+  }
+
+  /**
+   * An actual component annotation.
+   *
+   * @see FictionalComponentAnnotation
+   */
+  @AutoValue
+  abstract static class RealComponentAnnotation extends ComponentAnnotation {
+
+    @Override
+    @Memoized
+    ImmutableList<AnnotationValue> dependencyValues() {
+      return isSubcomponent() ? ImmutableList.of() : getAnnotationValues("dependencies");
+    }
+
+    @Override
+    @Memoized
+    ImmutableList<TypeMirror> dependencyTypes() {
+      return super.dependencyTypes();
+    }
+
+    @Override
+    @Memoized
+    ImmutableList<TypeElement> dependencies() {
+      return super.dependencies();
+    }
+
+    @Override
+    boolean isRealComponent() {
+      return true;
+    }
+
+    @Override
+    @Memoized
+    ImmutableList<AnnotationValue> moduleValues() {
+      return getAnnotationValues("modules");
+    }
+
+    @Override
+    @Memoized
+    ImmutableList<TypeMirror> moduleTypes() {
+      return super.moduleTypes();
+    }
+
+    @Override
+    @Memoized
+    ImmutableSet<TypeElement> modules() {
+      return super.modules();
+    }
+
+    static Builder builder() {
+      return new AutoValue_ComponentAnnotation_RealComponentAnnotation.Builder();
+    }
+
+    @AutoValue.Builder
+    interface Builder {
+      Builder annotation(AnnotationMirror annotation);
+
+      Builder isSubcomponent(boolean isSubcomponent);
+
+      Builder isProduction(boolean isProduction);
+
+      RealComponentAnnotation build();
+    }
+  }
+
+  /**
+   * A fictional component annotation used to represent modules or other collections of bindings as
+   * a component.
+   */
+  @AutoValue
+  abstract static class FictionalComponentAnnotation extends ComponentAnnotation {
+
+    @Override
+    AnnotationMirror annotation() {
+      return moduleAnnotation().annotation();
+    }
+
+    @Override
+    boolean isSubcomponent() {
+      return false;
+    }
+
+    @Override
+    boolean isProduction() {
+      return moduleAnnotation().annotationClass().equals(ProducerModule.class);
+    }
+
+    @Override
+    boolean isRealComponent() {
+      return false;
+    }
+
+    @Override
+    ImmutableList<AnnotationValue> dependencyValues() {
+      return ImmutableList.of();
+    }
+
+    @Override
+    ImmutableList<AnnotationValue> moduleValues() {
+      return moduleAnnotation().includesAsAnnotationValues();
+    }
+
+    @Override
+    @Memoized
+    ImmutableList<TypeMirror> moduleTypes() {
+      return super.moduleTypes();
+    }
+
+    @Override
+    @Memoized
+    ImmutableSet<TypeElement> modules() {
+      return super.modules();
+    }
+
+    abstract ModuleAnnotation moduleAnnotation();
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentCreatorAnnotation.java b/java/dagger/internal/codegen/ComponentCreatorAnnotation.java
index 56b850036..4bc4ab269 100644
--- a/java/dagger/internal/codegen/ComponentCreatorAnnotation.java
+++ b/java/dagger/internal/codegen/ComponentCreatorAnnotation.java
@@ -60,7 +60,7 @@
               ComponentCreatorAnnotation::annotation);
 
   /** Returns the set of all component creator annotations. */
-  static ImmutableSet<Class<? extends Annotation>> allAnnotations() {
+  static ImmutableSet<Class<? extends Annotation>> allCreatorAnnotations() {
     return ANNOTATIONS.keySet();
   }
 
@@ -79,6 +79,20 @@
         .collect(toImmutableSet());
   }
 
+  /** Returns the legal creator annotations for the given {@code componentAnnotation}. */
+  static ImmutableSet<Class<? extends Annotation>> creatorAnnotationsFor(
+      ComponentAnnotation componentAnnotation) {
+    return ANNOTATIONS.values().stream()
+        .filter(
+            creatorAnnotation ->
+                creatorAnnotation
+                    .componentAnnotation()
+                    .getSimpleName()
+                    .equals(componentAnnotation.simpleName()))
+        .map(ComponentCreatorAnnotation::annotation)
+        .collect(toImmutableSet());
+  }
+
   /** Returns all creator annotations present on the given {@code type}. */
   static ImmutableSet<ComponentCreatorAnnotation> getCreatorAnnotations(TypeElement type) {
     return ImmutableSet.copyOf(
@@ -88,6 +102,11 @@
   /** The actual annotation. */
   abstract Class<? extends Annotation> annotation();
 
+  /** The component annotation type that encloses this creator annotation type. */
+  final Class<? extends Annotation> componentAnnotation() {
+    return (Class<? extends Annotation>) annotation().getEnclosingClass();
+  }
+
   /** The component kind the annotation is associated with. */
   abstract ComponentKind componentKind();
 
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 6cdd19bbf..c25c44da5 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
@@ -39,15 +38,10 @@
 import dagger.model.DependencyRequest;
 import dagger.model.Scope;
 import dagger.producers.CancellationPolicy;
-import dagger.producers.ProducerModule;
 import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
-import java.lang.annotation.Annotation;
 import java.util.Objects;
 import java.util.Optional;
-import java.util.function.Predicate;
 import java.util.stream.Stream;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -66,11 +60,11 @@
 @AutoValue
 abstract class ComponentDescriptor {
   /** The annotation that specifies that {@link #typeElement()} is a component. */
-  abstract AnnotationMirror annotation();
+  abstract ComponentAnnotation annotation();
 
   /** Returns {@code true} if this is a subcomponent. */
   final boolean isSubcomponent() {
-    return Stream.of(Subcomponent.class, ProductionSubcomponent.class).anyMatch(isAnnotationType());
+    return annotation().isSubcomponent();
   }
 
   /**
@@ -78,8 +72,7 @@ final boolean isSubcomponent() {
    * {@code @ProducerModule} when doing module binding validation.
    */
   final boolean isProduction() {
-    return Stream.of(ProductionComponent.class, ProductionSubcomponent.class, ProducerModule.class)
-        .anyMatch(isAnnotationType());
+    return annotation().isProduction();
   }
 
   /**
@@ -87,16 +80,7 @@ final boolean isProduction() {
    * module bindings.
    */
   final boolean isRealComponent() {
-    return Stream.of(
-            Component.class,
-            Subcomponent.class,
-            ProductionComponent.class,
-            ProductionSubcomponent.class)
-        .anyMatch(isAnnotationType());
-  }
-
-  private Predicate<Class<? extends Annotation>> isAnnotationType() {
-    return clazz -> isTypeOf(clazz, annotation().getAnnotationType());
+    return annotation().isRealComponent();
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentDescriptorFactory.java b/java/dagger/internal/codegen/ComponentDescriptorFactory.java
index f63fe2d8b..431d7848f 100644
--- a/java/dagger/internal/codegen/ComponentDescriptorFactory.java
+++ b/java/dagger/internal/codegen/ComponentDescriptorFactory.java
@@ -18,15 +18,12 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.isTypeOf;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ComponentAnnotation.subcomponentAnnotation;
 import static dagger.internal.codegen.ComponentCreatorAnnotation.creatorAnnotationsFor;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedAnnotatedTypes;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentCreator;
-import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.Scopes.productionScope;
@@ -48,10 +45,9 @@
 import dagger.model.Scope;
 import java.util.List;
 import java.util.Optional;
-import java.util.function.Predicate;
+import java.util.function.Function;
 import javax.inject.Inject;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -82,16 +78,20 @@
   ComponentDescriptor rootComponentDescriptor(TypeElement typeElement) {
     return create(
         typeElement,
-        checkComponentKind(
-            typeElement, ComponentKind::isRoot, "%s must have a component annotation"));
+        checkAnnotation(
+            typeElement,
+            ComponentAnnotation::rootComponentAnnotation,
+            "must have a component annotation"));
   }
 
   /** Returns a descriptor for a subcomponent type. */
   ComponentDescriptor subcomponentDescriptor(TypeElement typeElement) {
     return create(
         typeElement,
-        checkComponentKind(
-            typeElement, kind -> !kind.isRoot(), "%s must have a subcomponent annotation"));
+        checkAnnotation(
+            typeElement,
+            ComponentAnnotation::subcomponentAnnotation,
+            "must have a subcomponent annotation"));
   }
 
   /**
@@ -101,32 +101,27 @@ ComponentDescriptor subcomponentDescriptor(TypeElement typeElement) {
   ComponentDescriptor moduleComponentDescriptor(TypeElement typeElement) {
     return create(
         typeElement,
-        checkComponentKind(
-            typeElement, ComponentKind::isForModuleValidation, "%s must have a module annotation"));
+        ComponentAnnotation.fromModuleAnnotation(
+            checkAnnotation(
+                typeElement, ModuleAnnotation::moduleAnnotation, "must have a module annotation")));
   }
 
-  private ComponentKind checkComponentKind(
+  private static <A> A checkAnnotation(
       TypeElement typeElement,
-      Predicate<ComponentKind> componentKindPredicate,
-      String errorMessageTemplate) {
-    Optional<ComponentKind> kind = ComponentKind.forAnnotatedElement(typeElement);
-    checkArgument(
-        kind.isPresent() && componentKindPredicate.test(kind.get()),
-        errorMessageTemplate,
-        typeElement);
-    return kind.get();
+      Function<TypeElement, Optional<A>> annotationFunction,
+      String message) {
+    return annotationFunction
+        .apply(typeElement)
+        .orElseThrow(() -> new IllegalArgumentException(typeElement + " " + message));
   }
 
-  private ComponentDescriptor create(TypeElement typeElement, ComponentKind kind) {
-    AnnotationMirror componentAnnotation =
-        getAnnotationMirror(typeElement, kind.annotation()).get();
+  private ComponentDescriptor create(
+      TypeElement typeElement, ComponentAnnotation componentAnnotation) {
     DeclaredType declaredComponentType = MoreTypes.asDeclared(typeElement.asType());
     ImmutableSet<ComponentRequirement> componentDependencies =
-        kind.isRoot() && !kind.isForModuleValidation()
-            ? getComponentDependencies(componentAnnotation).stream()
-                .map(ComponentRequirement::forDependency)
-                .collect(toImmutableSet())
-            : ImmutableSet.of();
+        componentAnnotation.dependencyTypes().stream()
+            .map(ComponentRequirement::forDependency)
+            .collect(toImmutableSet());
 
     ImmutableMap.Builder<ExecutableElement, ComponentRequirement> dependenciesByDependencyMethod =
         ImmutableMap.builder();
@@ -140,12 +135,12 @@ private ComponentDescriptor create(TypeElement typeElement, ComponentKind kind)
       }
     }
 
+    // Start with the component's modules. For fictional components built from a module, start with
+    // that module.
     ImmutableSet<TypeElement> modules =
-        kind.isForModuleValidation()
-            ? ImmutableSet.of(typeElement)
-            : getComponentModules(componentAnnotation).stream()
-                .map(MoreTypes::asTypeElement)
-                .collect(toImmutableSet());
+        componentAnnotation.isRealComponent()
+            ? componentAnnotation.modules()
+            : ImmutableSet.of(typeElement);
 
     ImmutableSet<ModuleDescriptor> transitiveModules =
         moduleDescriptorFactory.transitiveModules(modules);
@@ -164,14 +159,14 @@ private ComponentDescriptor create(TypeElement typeElement, ComponentKind kind)
         subcomponentsByFactoryMethod = ImmutableBiMap.builder();
     ImmutableBiMap.Builder<ComponentMethodDescriptor, ComponentDescriptor>
         subcomponentsByBuilderMethod = ImmutableBiMap.builder();
-    if (!kind.isForModuleValidation()) {
+    if (componentAnnotation.isRealComponent()) {
       ImmutableSet<ExecutableElement> unimplementedMethods =
           elements.getUnimplementedMethods(typeElement);
       for (ExecutableElement componentMethod : unimplementedMethods) {
         ExecutableType resolvedMethod =
             MoreTypes.asExecutable(types.asMemberOf(declaredComponentType, componentMethod));
         ComponentMethodDescriptor componentMethodDescriptor =
-            getDescriptorForComponentMethod(typeElement, kind, componentMethod);
+            getDescriptorForComponentMethod(typeElement, componentAnnotation, componentMethod);
         componentMethodsBuilder.add(componentMethodDescriptor);
         switch (componentMethodDescriptor.kind()) {
           case SUBCOMPONENT:
@@ -198,7 +193,7 @@ private ComponentDescriptor create(TypeElement typeElement, ComponentKind kind)
 
     // Validation should have ensured that this set will have at most one element.
     ImmutableSet<DeclaredType> enclosedCreators =
-        creatorAnnotationsFor(kind).stream()
+        creatorAnnotationsFor(componentAnnotation).stream()
             .flatMap(
                 creatorAnnotation ->
                     enclosedAnnotatedTypes(typeElement, creatorAnnotation).stream())
@@ -211,7 +206,7 @@ private ComponentDescriptor create(TypeElement typeElement, ComponentKind kind)
                     getOnlyElement(enclosedCreators), elements, types, dependencyRequestFactory));
 
     ImmutableSet<Scope> scopes = scopesOf(typeElement);
-    if (kind.isProducer()) {
+    if (componentAnnotation.isProduction()) {
       scopes = ImmutableSet.<Scope>builder().addAll(scopes).add(productionScope(elements)).build();
     }
 
@@ -231,7 +226,7 @@ private ComponentDescriptor create(TypeElement typeElement, ComponentKind kind)
 
   private ComponentMethodDescriptor getDescriptorForComponentMethod(
       TypeElement componentElement,
-      ComponentKind componentKind,
+      ComponentAnnotation componentAnnotation,
       ExecutableElement componentMethod) {
     ExecutableType resolvedComponentMethod =
         MoreTypes.asExecutable(
@@ -245,11 +240,14 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
                 componentMethod, resolvedComponentMethod));
       } else if (!getQualifier(componentMethod).isPresent()) {
         Element returnTypeElement = MoreTypes.asElement(returnType);
-        if (ConfigurationAnnotations.isSubcomponent(returnTypeElement)) {
+        Optional<ComponentAnnotation> subcomponentAnnotation =
+            subcomponentAnnotation(MoreElements.asType(returnTypeElement));
+        if (subcomponentAnnotation.isPresent()) {
           return ComponentMethodDescriptor.forSubcomponent(
-              isAnnotationPresent(returnTypeElement, Subcomponent.class)
-                  ? ComponentMethodKind.SUBCOMPONENT
-                  : ComponentMethodKind.PRODUCTION_SUBCOMPONENT,
+              subcomponentAnnotation.get().isProduction()
+                  // TODO(dpb): Do we really need all these enums?
+                  ? ComponentMethodKind.PRODUCTION_SUBCOMPONENT
+                  : ComponentMethodKind.SUBCOMPONENT,
               componentMethod);
         } else if (isSubcomponentCreator(returnTypeElement)) {
           DependencyRequest dependencyRequest =
@@ -268,22 +266,13 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
     // a typical provision method
     if (componentMethod.getParameters().isEmpty()
         && !componentMethod.getReturnType().getKind().equals(VOID)) {
-      switch (componentKind) {
-        case COMPONENT:
-        case SUBCOMPONENT:
-          return ComponentMethodDescriptor.forProvision(
-              componentMethod,
-              dependencyRequestFactory.forComponentProvisionMethod(
-                  componentMethod, resolvedComponentMethod));
-        case PRODUCTION_COMPONENT:
-        case PRODUCTION_SUBCOMPONENT:
-          return ComponentMethodDescriptor.forProvision(
-              componentMethod,
-              dependencyRequestFactory.forComponentProductionMethod(
+      return ComponentMethodDescriptor.forProvision(
+          componentMethod,
+          componentAnnotation.isProduction()
+              ? dependencyRequestFactory.forComponentProductionMethod(
+                  componentMethod, resolvedComponentMethod)
+              : dependencyRequestFactory.forComponentProvisionMethod(
                   componentMethod, resolvedComponentMethod));
-        default:
-          throw new AssertionError();
-      }
     }
 
     List<? extends TypeMirror> parameterTypes = resolvedComponentMethod.getParameterTypes();
diff --git a/java/dagger/internal/codegen/ComponentDescriptorValidator.java b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
index 5a1e16858..ad8499c7a 100644
--- a/java/dagger/internal/codegen/ComponentDescriptorValidator.java
+++ b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
@@ -21,9 +21,7 @@
 import static com.google.common.base.Predicates.in;
 import static com.google.common.collect.Collections2.transform;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.ComponentAnnotation.rootComponentAnnotation;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSetMultimap;
 import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
@@ -34,6 +32,7 @@
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toList;
+import static javax.tools.Diagnostic.Kind.ERROR;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -42,7 +41,6 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
-import dagger.Component;
 import dagger.internal.codegen.ComponentRequirement.NullPolicy;
 import dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages;
 import dagger.model.Scope;
@@ -56,7 +54,6 @@
 import java.util.Set;
 import java.util.StringJoiner;
 import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -65,6 +62,7 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic;
 
 /**
  * Reports errors in the component hierarchy.
@@ -129,6 +127,16 @@
           reports, component, descriptor -> ValidationReport.about(descriptor.typeElement()));
     }
 
+    private void reportComponentItem(
+        Diagnostic.Kind kind, ComponentDescriptor component, String message) {
+      report(component)
+          .addItem(message, kind, component.typeElement(), component.annotation().annotation());
+    }
+
+    private void reportComponentError(ComponentDescriptor component, String error) {
+      reportComponentItem(ERROR, component, error);
+    }
+
     void visitComponent(ComponentDescriptor component) {
       validateDependencyScopes(component);
       validateComponentDependencyHierarchy(component);
@@ -153,25 +161,23 @@ private void validateComponentDependencyHierarchy(
         dependencyStack.push(dependency);
         appendIndentedComponentsList(message, dependencyStack);
         dependencyStack.pop();
-        report(component)
-            .addItem(
-                message.toString(),
-                compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                component.typeElement(),
-                getComponentAnnotation(component.typeElement()).get());
+        reportComponentItem(
+            compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+            component,
+            message.toString());
       } else {
-        Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(dependency);
-        if (componentAnnotation.isPresent()) {
-          dependencyStack.push(dependency);
-
-          ImmutableSet<TypeElement> dependencies =
-              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get()));
-          for (TypeElement nextDependency : dependencies) {
-            validateComponentDependencyHierarchy(component, nextDependency, dependencyStack);
-          }
+        rootComponentAnnotation(dependency)
+            .ifPresent(
+                componentAnnotation -> {
+                  dependencyStack.push(dependency);
 
-          dependencyStack.pop();
-        }
+                  for (TypeElement nextDependency : componentAnnotation.dependencies()) {
+                    validateComponentDependencyHierarchy(
+                        component, nextDependency, dependencyStack);
+                  }
+
+                  dependencyStack.pop();
+                });
       }
     }
 
@@ -200,12 +206,10 @@ private void validateDependencyScopes(ComponentDescriptor component) {
                 new StringBuilder(
                     "This @Singleton component cannot depend on scoped components:\n");
             appendIndentedComponentsList(message, scopedDependencies);
-            report(component)
-                .addItem(
-                    message.toString(),
-                    compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                    component.typeElement(),
-                    component.annotation());
+            reportComponentItem(
+                compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+                component,
+                message.toString());
           }
         } else if (scopedDependencies.size() > 1) {
           // Scoped components may depend on at most one scoped component.
@@ -217,8 +221,7 @@ private void validateDependencyScopes(ComponentDescriptor component) {
               .append(component.typeElement().getQualifiedName())
               .append(" depends on more than one scoped component:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          report(component)
-              .addError(message.toString(), component.typeElement(), component.annotation());
+          reportComponentError(component, message.toString());
         } else {
           // Dagger 1.x scope compatibility requires this be suppress-able.
           if (!compilerOptions.scopeCycleValidationType().equals(ValidationType.NONE)) {
@@ -233,8 +236,7 @@ private void validateDependencyScopes(ComponentDescriptor component) {
               new StringBuilder(component.typeElement().getQualifiedName())
                   .append(" (unscoped) cannot depend on scoped components:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          report(component)
-              .addError(message.toString(), component.typeElement(), component.annotation());
+          reportComponentError(component, message.toString());
         }
       }
     }
@@ -417,22 +419,20 @@ private void validateDependencyScopeHierarchy(
         message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
         appendIndentedComponentsList(message, scopedDependencyStack);
         if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
-          report(component)
-              .addItem(
-                  message.toString(),
-                  compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                  component.typeElement(),
-                  getComponentAnnotation(component.typeElement()).get());
+          reportComponentItem(
+              compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+              component,
+              message.toString());
         }
         scopedDependencyStack.pop();
       } else {
         // TODO(beder): transitively check scopes of production components too.
-        getAnnotationMirror(dependency, Component.class)
+        rootComponentAnnotation(dependency)
+            .filter(componentAnnotation -> !componentAnnotation.isProduction())
             .ifPresent(
                 componentAnnotation -> {
                   ImmutableSet<TypeElement> scopedDependencies =
-                      scopedTypesIn(
-                          MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation)));
+                      scopedTypesIn(componentAnnotation.dependencies());
                   if (scopedDependencies.size() == 1) {
                     // empty can be ignored (base-case), and > 1 is a separately-reported error.
                     scopeStack.push(scopes);
@@ -475,7 +475,7 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
      * Returns a set of type elements containing only those found in the input set that have a
      * scoping annotation.
      */
-    private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
+    private ImmutableSet<TypeElement> scopedTypesIn(Collection<TypeElement> types) {
       return types.stream().filter(type -> !scopesOf(type).isEmpty()).collect(toImmutableSet());
     }
   }
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index bae0e5da6..fe9d33e7d 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -21,10 +21,9 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static dagger.internal.codegen.ComponentAnnotation.rootComponentAnnotations;
 import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
 import static dagger.internal.codegen.ComponentGenerator.componentName;
-import static dagger.internal.codegen.ComponentKind.annotationsFor;
-import static dagger.internal.codegen.ComponentKind.rootComponentKinds;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -101,7 +100,7 @@
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return annotationsFor(rootComponentKinds());
+    return rootComponentAnnotations();
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/ComponentKind.java b/java/dagger/internal/codegen/ComponentKind.java
index b0f0a331c..8e5b9bac6 100644
--- a/java/dagger/internal/codegen/ComponentKind.java
+++ b/java/dagger/internal/codegen/ComponentKind.java
@@ -83,14 +83,6 @@
     return SUBCOMPONENT_KINDS;
   }
 
-  /** Returns all annotations that mark a component type. */
-  static ImmutableSet<Class<? extends Annotation>> allAnnotations() {
-    return valuesOf(ComponentKind.class)
-        .filter(kind -> !kind.isForModuleValidation())
-        .map(ComponentKind::annotation)
-        .collect(toImmutableSet());
-  }
-
   /** Returns the annotations for components of the given kinds. */
   static ImmutableSet<Class<? extends Annotation>> annotationsFor(Iterable<ComponentKind> kinds) {
     return stream(kinds).map(ComponentKind::annotation).collect(toImmutableSet());
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 9df8b0b2d..3d283b68d 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -16,8 +16,12 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.collect.Sets.union;
+import static dagger.internal.codegen.ComponentAnnotation.allComponentAnnotations;
+import static dagger.internal.codegen.ComponentAnnotation.rootComponentAnnotations;
+import static dagger.internal.codegen.ComponentAnnotation.subcomponentAnnotations;
+import static dagger.internal.codegen.ComponentCreatorAnnotation.allCreatorAnnotations;
 import static dagger.internal.codegen.ComponentCreatorAnnotation.creatorAnnotationsFor;
-import static dagger.internal.codegen.ComponentKind.annotationsFor;
 import static dagger.internal.codegen.ComponentKind.rootComponentKinds;
 import static dagger.internal.codegen.ComponentKind.subcomponentKinds;
 import static java.util.Collections.disjoint;
@@ -29,7 +33,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
-import com.google.common.collect.Sets;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
 import java.lang.annotation.Annotation;
 import java.util.HashMap;
@@ -88,14 +91,14 @@
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return Sets.union(ComponentKind.allAnnotations(), ComponentCreatorAnnotation.allAnnotations());
+    return union(allComponentAnnotations(), allCreatorAnnotations());
   }
 
   @Override
   public ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     subcomponentElements =
-        getElementsFromAnnotations(elementsByAnnotation, annotationsFor(subcomponentKinds()));
+        getElementsFromAnnotations(elementsByAnnotation, subcomponentAnnotations());
     subcomponentCreatorElements =
         getElementsFromAnnotations(
             elementsByAnnotation, creatorAnnotationsFor(subcomponentKinds()));
@@ -117,7 +120,7 @@
   @Override
   protected void process(
       TypeElement element, ImmutableSet<Class<? extends Annotation>> annotations) {
-    if (!disjoint(annotations, annotationsFor(rootComponentKinds()))) {
+    if (!disjoint(annotations, rootComponentAnnotations())) {
       ComponentValidationReport validationReport =
           componentValidator.validate(element, subcomponentElements, subcomponentCreatorElements);
       validationReport.report().printMessagesTo(messager);
@@ -138,7 +141,7 @@ protected void process(
       }
     }
     if (compilerOptions.aheadOfTimeSubcomponents()
-        && !disjoint(annotations, annotationsFor(subcomponentKinds()))) {
+        && !disjoint(annotations, subcomponentAnnotations())) {
       if (!subcomponentIsClean(element)) {
         return;
       }
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index a8f9e3543..a0da261b2 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -24,11 +24,11 @@
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Multimaps.asMap;
+import static dagger.internal.codegen.ComponentAnnotation.anyComponentAnnotation;
+import static dagger.internal.codegen.ComponentAnnotation.componentAnnotation;
 import static dagger.internal.codegen.ComponentCreatorAnnotation.creatorAnnotationsFor;
 import static dagger.internal.codegen.ComponentKind.annotationsFor;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedAnnotatedTypes;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
@@ -138,9 +138,11 @@ public ComponentValidationReport validate(
       allSubcomponents = ImmutableSet.of();
     } else {
       ComponentKind componentKind = getOnlyElement(componentKinds);
+      ComponentAnnotation componentAnnotation = anyComponentAnnotation(subject).get();
       allSubcomponents =
           validate(
               subject,
+              componentAnnotation,
               componentKind,
               validatedSubcomponents,
               validatedSubcomponentCreators,
@@ -153,6 +155,7 @@ public ComponentValidationReport validate(
 
   private ImmutableSet<Element> validate(
       TypeElement subject,
+      ComponentAnnotation componentAnnotation,
       ComponentKind componentKind,
       Set<? extends Element> validatedSubcomponents,
       Set<? extends Element> validatedSubcomponentCreators,
@@ -272,14 +275,13 @@ public ComponentValidationReport validate(
                 report.addError(
                     String.format(moreThanOneRefToSubcomponent(), subcomponent, methods), subject));
 
-    AnnotationMirror componentMirror =
-        getAnnotationMirror(subject, componentKind.annotation()).get();
-    if (componentKind.isRoot()) {
-      validateComponentDependencies(report, getComponentDependencies(componentMirror));
-    }
+    validateComponentDependencies(report, componentAnnotation.dependencyTypes());
     report.addSubreport(
         moduleValidator.validateReferencedModules(
-            subject, componentMirror, componentKind.legalModuleKinds(), new HashSet<>()));
+            subject,
+            componentAnnotation.annotation(),
+            componentKind.legalModuleKinds(),
+            new HashSet<>()));
 
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
@@ -389,7 +391,7 @@ private void validateSubcomponentMethod(
       TypeMirror returnType,
       Optional<AnnotationMirror> subcomponentAnnotation) {
     ImmutableSet<TypeElement> moduleTypes =
-        MoreTypes.asTypeElements(getComponentModules(subcomponentAnnotation.get()));
+        componentAnnotation(subcomponentAnnotation.get()).modules();
 
     // TODO(gak): This logic maybe/probably shouldn't live here as it requires us to traverse
     // subcomponents and their modules separately from how it is done in ComponentDescriptor and
diff --git a/java/dagger/internal/codegen/ConfigurationAnnotations.java b/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 8e2325f73..8e39ca761 100644
--- a/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -16,20 +16,15 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.consumingIterable;
+import static dagger.internal.codegen.ComponentAnnotation.subcomponentAnnotation;
 import static dagger.internal.codegen.ComponentCreatorAnnotation.creatorAnnotationsFor;
-import static dagger.internal.codegen.ComponentKind.annotationsFor;
-import static dagger.internal.codegen.ComponentKind.rootComponentKinds;
 import static dagger.internal.codegen.ComponentKind.subcomponentKinds;
-import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
-import static dagger.internal.codegen.ModuleAnnotation.isModuleAnnotation;
 import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeListValue;
-import static dagger.internal.codegen.MoreAnnotationValues.asAnnotationValues;
 import static javax.lang.model.util.ElementFilter.typesIn;
 
 import com.google.auto.common.MoreElements;
@@ -47,7 +42,6 @@
 import java.util.Queue;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -60,28 +54,8 @@
  */
 final class ConfigurationAnnotations {
 
-  static Optional<AnnotationMirror> getComponentAnnotation(TypeElement component) {
-    return getAnyAnnotation(component, annotationsFor(rootComponentKinds()));
-  }
-
-  static Optional<AnnotationMirror> getSubcomponentAnnotation(TypeElement subcomponent) {
-    return getAnyAnnotation(subcomponent, annotationsFor(subcomponentKinds()));
-  }
-
-  static Optional<AnnotationMirror> getComponentOrSubcomponentAnnotation(TypeElement type) {
-    Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(type);
-    if (componentAnnotation.isPresent()) {
-      return componentAnnotation;
-    }
-    return getSubcomponentAnnotation(type);
-  }
-
-  static boolean isSubcomponent(Element element) {
-    return isAnyAnnotationPresent(element, annotationsFor(subcomponentKinds()));
-  }
-
   static Optional<TypeElement> getSubcomponentCreator(TypeElement subcomponent) {
-    checkArgument(isSubcomponent(subcomponent));
+    checkArgument(subcomponentAnnotation(subcomponent).isPresent());
     for (TypeElement nestedType : typesIn(subcomponent.getEnclosedElements())) {
       if (isSubcomponentCreator(nestedType)) {
         return Optional.of(nestedType);
@@ -94,40 +68,6 @@ static boolean isSubcomponentCreator(Element element) {
     return isAnyAnnotationPresent(element, creatorAnnotationsFor(subcomponentKinds()));
   }
 
-  /**
-   * Returns the annotation values for the modules directly installed into a component or included
-   * in a module.
-   *
-   * @param annotatedType the component or module type
-   * @param annotation the component or module annotation
-   */
-  static ImmutableList<AnnotationValue> getModules(
-      TypeElement annotatedType, AnnotationMirror annotation) {
-    if (ComponentKind.forAnnotatedElement(annotatedType)
-        .filter(kind -> !kind.isForModuleValidation())
-        .isPresent()) {
-      return asAnnotationValues(getAnnotationValue(annotation, MODULES_ATTRIBUTE));
-    }
-    if (isModuleAnnotation(annotation)) {
-      return moduleAnnotation(annotation).includesAsAnnotationValues();
-    }
-    throw new IllegalArgumentException(String.format("unsupported annotation: %s", annotation));
-  }
-
-  private static final String MODULES_ATTRIBUTE = "modules";
-
-  static ImmutableList<TypeMirror> getComponentModules(AnnotationMirror componentAnnotation) {
-    checkNotNull(componentAnnotation);
-    return getTypeListValue(componentAnnotation, MODULES_ATTRIBUTE);
-  }
-
-  private static final String DEPENDENCIES_ATTRIBUTE = "dependencies";
-
-  static ImmutableList<TypeMirror> getComponentDependencies(AnnotationMirror componentAnnotation) {
-    checkNotNull(componentAnnotation);
-    return getTypeListValue(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
-  }
-
   // Dagger 1 support.
   static ImmutableList<TypeMirror> getModuleInjects(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 39cced950..c1ec23238 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -51,6 +51,13 @@ static ComponentMessages componentMessagesFor(ComponentKind componentKind) {
     return new ComponentMessages(COMPONENT_TRANSFORMATIONS.get(componentKind));
   }
 
+  static ComponentMessages componentMessagesFor(ComponentAnnotation componentAnnotation) {
+    return new ComponentMessages(
+        componentAnnotation.isProduction()
+            ? componentAnnotation.isSubcomponent() ? PRODUCTION.andThen(SUBCOMPONENT) : PRODUCTION
+            : componentAnnotation.isSubcomponent() ? SUBCOMPONENT : UnaryOperator.identity());
+  }
+
   static ComponentCreatorMessages creatorMessagesFor(ComponentCreatorAnnotation creatorAnnotation) {
     return creatorMessagesFor(creatorAnnotation.componentKind(), creatorAnnotation.creatorKind());
   }
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index 74841e48d..403a32136 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -21,13 +21,15 @@
 import static com.google.auto.common.Visibility.PUBLIC;
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ComponentAnnotation.componentAnnotation;
+import static dagger.internal.codegen.ComponentAnnotation.isComponentAnnotation;
+import static dagger.internal.codegen.ComponentAnnotation.subcomponentAnnotation;
 import static dagger.internal.codegen.ComponentCreatorAnnotation.getCreatorAnnotations;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModules;
-import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentCreator;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.ModuleAnnotation.isModuleAnnotation;
 import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static dagger.internal.codegen.MoreAnnotationValues.asType;
@@ -43,6 +45,7 @@
 import com.google.auto.common.Visibility;
 import com.google.common.base.Joiner;
 import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.Sets;
@@ -287,7 +290,7 @@ private static String moduleSubcomponentsIncludesCreator(
     return String.format(
         "%s is a @%s.%s. Did you mean to use %s?",
         moduleSubcomponentsAttribute.getQualifiedName(),
-        simpleName(getSubcomponentAnnotation(subcomponentType).get()),
+        subcomponentAnnotation(subcomponentType).get().simpleName(),
         creatorAnnotation.creatorKind().typeName(),
         subcomponentType.getQualifiedName());
   }
@@ -307,14 +310,11 @@ private static void validateSubcomponentHasBuilder(
 
   private static String moduleSubcomponentsDoesntHaveCreator(
       TypeElement subcomponent, AnnotationMirror moduleAnnotation) {
-    String subcomponentAnnotation =
-        simpleName(getSubcomponentAnnotation(subcomponent).get()).toString();
     return String.format(
-        "%s doesn't have a @%s.Builder or @%s.Factory, which is required when used with "
-            + "@%s.subcomponents",
+        "%1$s doesn't have a @%2$s.Builder or @%2$s.Factory, which is required when used with "
+            + "@%3$s.subcomponents",
         subcomponent.getQualifiedName(),
-        subcomponentAnnotation,
-        subcomponentAnnotation,
+        subcomponentAnnotation(subcomponent).get().simpleName(),
         simpleName(moduleAnnotation));
   }
 
@@ -396,7 +396,7 @@ private void validateReferencedModules(
     ImmutableSet<? extends Class<? extends Annotation>> validModuleAnnotations =
         validModuleKinds.stream().map(ModuleKind::annotation).collect(toImmutableSet());
 
-    for (AnnotationValue includedModule : getModules(annotatedType, annotation)) {
+    for (AnnotationValue includedModule : getModules(annotation)) {
       asType(includedModule)
           .accept(
               new SimpleTypeVisitor8<Void, Void>() {
@@ -440,6 +440,16 @@ private void reportError(String format, Object... args) {
     return subreport.build();
   }
 
+  private static ImmutableList<AnnotationValue> getModules(AnnotationMirror annotation) {
+    if (isModuleAnnotation(annotation)) {
+      return moduleAnnotation(annotation).includesAsAnnotationValues();
+    }
+    if (isComponentAnnotation(annotation)) {
+      return componentAnnotation(annotation).moduleValues();
+    }
+    throw new IllegalArgumentException(String.format("unsupported annotation: %s", annotation));
+  }
+
   private void validateBindingMethodOverrides(
       TypeElement subject,
       ValidationReport.Builder<TypeElement> builder,
