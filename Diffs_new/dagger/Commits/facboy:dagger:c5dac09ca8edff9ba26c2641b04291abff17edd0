diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 3a6b53640..3a03dbafc 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -17,32 +17,18 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
-import static dagger.internal.codegen.MemberSelect.localField;
-import static dagger.internal.codegen.Scope.reusableScope;
-import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
-import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
-import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER_MANAGER;
-import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.type.TypeKind.VOID;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
@@ -53,44 +39,32 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.InjectionMethods.InjectionSiteMethod;
-import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-import dagger.releasablereferences.CanReleaseReferences;
 import java.util.ArrayList;
-import java.util.LinkedHashMap;
 import java.util.List;
-import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
 /** Creates the implementation class for a component or subcomponent. */
-abstract class AbstractComponentWriter implements GeneratedComponentModel {
+abstract class AbstractComponentWriter {
   // TODO(dpb): Make all these fields private after refactoring is complete.
   protected final Elements elements;
   protected final DaggerTypes types;
   protected final CompilerOptions compilerOptions;
-  protected final ClassName name;
   protected final BindingGraph graph;
   protected final SubcomponentNames subcomponentNames;
-  protected final TypeSpec.Builder component;
-  private final UniqueNameSet componentFieldNames = new UniqueNameSet();
-  private final UniqueNameSet componentMethodNames = new UniqueNameSet();
   private final ComponentBindingExpressions bindingExpressions;
   protected final ComponentRequirementFields componentRequirementFields;
-  private final List<CodeBlock> initializations = new ArrayList<>();
+  protected final GeneratedComponentModel generatedComponentModel;
+  private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
+  private final MembersInjectionMethods membersInjectionMethods;
   protected final List<MethodSpec> interfaceMethods = new ArrayList<>();
   private final BindingExpression.Factory bindingExpressionFactory;
   private final ComponentRequirementField.Factory componentRequirementFieldFactory;
-
-  private final Map<Key, MethodSpec> membersInjectionMethods = new LinkedHashMap<>();
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   private final OptionalFactories optionalFactories;
   private ComponentBuilder builder;
@@ -102,53 +76,55 @@
    */
   private final ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
 
-  /**
-   * The member-selects for {@link dagger.internal.ReferenceReleasingProviderManager} fields,
-   * indexed by their {@link CanReleaseReferences @CanReleaseReferences} scope.
-   */
-  private ImmutableMap<Scope, MemberSelect> referenceReleasingProviderManagerFields;
-
   AbstractComponentWriter(
       DaggerTypes types,
       Elements elements,
       CompilerOptions compilerOptions,
-      ClassName name,
       BindingGraph graph,
+      GeneratedComponentModel generatedComponentModel,
       SubcomponentNames subcomponentNames,
       OptionalFactories optionalFactories,
       ComponentBindingExpressions bindingExpressions,
-      ComponentRequirementFields componentRequirementFields) {
+      ComponentRequirementFields componentRequirementFields,
+      ReferenceReleasingManagerFields referenceReleasingManagerFields) {
     this.types = types;
     this.elements = elements;
     this.compilerOptions = compilerOptions;
-    this.component = classBuilder(name);
-    this.name = name;
     this.graph = graph;
     this.subcomponentNames = subcomponentNames;
+    this.generatedComponentModel = generatedComponentModel;
     this.optionalFactories = optionalFactories;
     this.bindingExpressions = bindingExpressions;
     // TODO(dpb): Allow ComponentBuilder.create to return a no-op object
     if (hasBuilder(graph)) {
-      builder = ComponentBuilder.create(name, graph, subcomponentNames, elements, types);
+      builder =
+          ComponentBuilder.create(
+              generatedComponentModel.name(), graph, subcomponentNames, elements, types);
       builderFields = builder.builderFields();
     } else {
       builderFields = ImmutableMap.of();
     }
     this.componentRequirementFields = componentRequirementFields;
+    this.referenceReleasingManagerFields = referenceReleasingManagerFields;
+    this.membersInjectionMethods =
+        new MembersInjectionMethods(
+            generatedComponentModel, bindingExpressions, graph, elements, types);
+    // TODO(user): move factories into ComponentBindingExpressions.
     this.bindingExpressionFactory =
         new BindingExpression.Factory(
             compilerOptions,
-            name,
             bindingExpressions,
             componentRequirementFields,
-            this,
+            membersInjectionMethods,
+            referenceReleasingManagerFields,
+            generatedComponentModel,
             subcomponentNames,
             graph,
             types,
             elements,
             optionalFactories);
     this.componentRequirementFieldFactory =
-        new ComponentRequirementField.Factory(this, name, builderFields);
+        new ComponentRequirementField.Factory(generatedComponentModel, builderFields);
   }
 
   protected AbstractComponentWriter(
@@ -157,59 +133,20 @@ protected AbstractComponentWriter(
         parent.types,
         parent.elements,
         parent.compilerOptions,
-        name,
         graph,
+        GeneratedComponentModel.forSubcomponent(name),
         parent.subcomponentNames,
         parent.optionalFactories,
         parent.bindingExpressions.forChildComponent(),
-        parent.componentRequirementFields.forChildComponent());
+        parent.componentRequirementFields.forChildComponent(),
+        parent.referenceReleasingManagerFields);
   }
 
   /**
    * Creates a {@link FieldSpec.Builder} with a unique name based off of {@code name}.
    */
   protected final FieldSpec.Builder componentField(TypeName type, String name) {
-    return FieldSpec.builder(type, getUniqueFieldName(name));
-  }
-
-  @Override
-  public void addInitialization(CodeBlock codeBlock) {
-    initializations.add(codeBlock);
-  }
-
-  @Override
-  public void addField(FieldSpec fieldSpec) {
-    component.addField(fieldSpec);
-  }
-
-  @Override
-  public void addMethod(MethodSpec methodSpec) {
-    component.addMethod(methodSpec);
-  }
-
-  @Override
-  public String getUniqueFieldName(String name) {
-    return componentFieldNames.getUniqueName(name);
-  }
-
-  @Override
-  public String getUniqueMethodName(String name) {
-    return componentMethodNames.getUniqueName(name);
-  }
-
-  @Override
-  public void addType(TypeSpec typeSpec) {
-    component.addType(typeSpec);
-  }
-
-  @Override
-  public String getSubcomponentName(ComponentDescriptor subcomponentDescriptor) {
-    return checkNotNull(subcomponentNames.get(subcomponentDescriptor));
-  }
-
-  @Override
-  public CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
-    return referenceReleasingProviderManagerFields.get(scope).getExpressionFor(name);
+    return FieldSpec.builder(type, generatedComponentModel.getUniqueFieldName(name));
   }
 
   /**
@@ -219,39 +156,31 @@ public CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
    */
   final TypeSpec.Builder write() {
     checkState(!done, "ComponentWriter has already been generated.");
-    decorateComponent();
-    addSupertype(component, graph.componentType());
+    addSupertype(generatedComponentModel.component, graph.componentType());
     if (hasBuilder(graph)) {
       addBuilder();
     }
 
     getLocalAndInheritedMethods(
             graph.componentDescriptor().componentDefinitionType(), types, elements)
-        .forEach(method -> componentMethodNames.claim(method.getSimpleName()));
+        .forEach(method -> generatedComponentModel.claimMethodName(method.getSimpleName()));
 
     addFactoryMethods();
-    addReferenceReleasingProviderManagerFields();
     createBindingExpressions();
     createComponentRequirementFields();
     implementInterfaceMethods();
     addSubcomponents();
     writeInitializeAndInterfaceMethods();
-    writeMembersInjectionMethods();
-    component.addMethod(constructor.build());
+    generatedComponentModel.addMethods(membersInjectionMethods.getAllMethods());
+    generatedComponentModel.addMethod(constructor.build());
     if (graph.componentDescriptor().kind().isTopLevel()) {
-      optionalFactories.addMembers(component);
+      // TODO(user): pass in generatedComponentModel instead of the component.
+      optionalFactories.addMembers(generatedComponentModel.component);
     }
     done = true;
-    return component;
+    return generatedComponentModel.component;
   }
 
-  // TODO(user): move this into GeneratedComponentModel
-  /**
-   * Adds Javadoc, modifiers, supertypes, and annotations to the component implementation class
-   * declaration.
-   */
-  protected abstract void decorateComponent();
-
   private static boolean hasBuilder(BindingGraph graph) {
     ComponentDescriptor component = graph.componentDescriptor();
     return component.kind().isTopLevel() || component.builderSpec().isPresent();
@@ -281,36 +210,6 @@ protected final ClassName builderName() {
    */
   protected abstract void addFactoryMethods();
 
-  /**
-   * Adds a {@link dagger.internal.ReferenceReleasingProviderManager} field for every scope for
-   * which {@linkplain BindingGraph#scopesRequiringReleasableReferenceManagers() one is required}.
-   */
-  private void addReferenceReleasingProviderManagerFields() {
-    ImmutableMap.Builder<Scope, MemberSelect> fields = ImmutableMap.builder();
-    for (Scope scope : graph.scopesRequiringReleasableReferenceManagers()) {
-      FieldSpec field = referenceReleasingProxyManagerField(scope);
-      component.addField(field);
-      fields.put(scope, localField(name, field.name));
-    }
-    referenceReleasingProviderManagerFields = fields.build();
-  }
-
-  private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
-    return componentField(
-            REFERENCE_RELEASING_PROVIDER_MANAGER,
-            UPPER_CAMEL.to(
-                LOWER_CAMEL, scope.scopeAnnotationElement().getSimpleName() + "References"))
-        .addModifiers(PRIVATE, FINAL)
-        .initializer(
-            "new $T($T.class)",
-            REFERENCE_RELEASING_PROVIDER_MANAGER,
-            scope.scopeAnnotationElement())
-        .addJavadoc(
-            "The manager that releases references for the {@link $T} scope.\n",
-            scope.scopeAnnotationElement())
-        .build();
-  }
-
   private void createBindingExpressions() {
     graph.resolvedBindings().values().forEach(this::createBindingExpression);
   }
@@ -372,17 +271,18 @@ private void implementInterfaceMethods() {
             if (requestType.getReturnType().getKind().equals(VOID)) {
               if (!binding.injectionSites().isEmpty()) {
                 interfaceMethod.addStatement(
-                    "$N($N)", getMembersInjectionMethod(binding.key()), parameter);
+                    "$N($N)", membersInjectionMethods.getOrCreate(binding.key()), parameter);
               }
             } else if (binding.injectionSites().isEmpty()) {
               interfaceMethod.addStatement("return $N", parameter);
             } else {
               interfaceMethod.addStatement(
-                  "return $N($N)", getMembersInjectionMethod(binding.key()), parameter);
+                  "return $N($N)", membersInjectionMethods.getOrCreate(binding.key()), parameter);
             }
           } else {
             interfaceMethod.addCode(
-                bindingExpressions.getComponentMethodImplementation(interfaceRequest, name));
+                bindingExpressions.getComponentMethodImplementation(
+                    interfaceRequest, generatedComponentModel.name()));
           }
           interfaceMethods.add(interfaceMethod.build());
         }
@@ -399,7 +299,7 @@ private void addSubcomponents() {
               .get(subgraph.componentDescriptor());
       SubcomponentWriter subcomponent =
           new SubcomponentWriter(this, Optional.ofNullable(componentMethodDescriptor), subgraph);
-      component.addType(subcomponent.write().build());
+      generatedComponentModel.addType(subcomponent.write().build());
     }
   }
 
@@ -407,7 +307,8 @@ private void addSubcomponents() {
 
   private void writeInitializeAndInterfaceMethods() {
     List<List<CodeBlock>> partitions =
-        Lists.partition(initializations, INITIALIZATIONS_PER_INITIALIZE_METHOD);
+        Lists.partition(
+            generatedComponentModel.getInitializations(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
 
     UniqueNameSet methodNames = new UniqueNameSet();
     for (List<CodeBlock> partition : partitions) {
@@ -427,91 +328,9 @@ private void writeInitializeAndInterfaceMethods() {
       } else {
         constructor.addStatement("$L()", methodName);
       }
-      component.addMethod(initializeMethod.build());
+      generatedComponentModel.addMethod(initializeMethod.build());
     }
 
-    component.addMethods(interfaceMethods);
-  }
-
-  private void writeMembersInjectionMethods() {
-    component.addMethods(membersInjectionMethods.values());
-  }
-
-  @Override
-  public MethodSpec getMembersInjectionMethod(Key key) {
-    return reentrantComputeIfAbsent(
-        membersInjectionMethods, key, this::membersInjectionMethod);
-  }
-
-  private MethodSpec membersInjectionMethod(Key key) {
-    Binding binding =
-        MoreObjects.firstNonNull(
-                graph.resolvedBindings().get(BindingKey.membersInjection(key)),
-                graph.resolvedBindings().get(BindingKey.contribution(key)))
-            .binding();
-    TypeMirror keyType = binding.key().type();
-    TypeMirror membersInjectedType =
-        isTypeAccessibleFrom(keyType, name.packageName())
-            ? keyType
-            : elements.getTypeElement("java.lang.Object").asType();
-    TypeName membersInjectedTypeName = TypeName.get(membersInjectedType);
-    Name bindingTypeName = binding.bindingTypeElement().get().getSimpleName();
-    // TODO(ronshapiro): include type parameters in this name e.g. injectFooOfT, and outer class
-    // simple names Foo.Builder -> injectFooBuilder
-    String methodName = componentMethodNames.getUniqueName("inject" + bindingTypeName);
-    ParameterSpec parameter = ParameterSpec.builder(membersInjectedTypeName, "instance").build();
-    MethodSpec.Builder method =
-        methodBuilder(methodName)
-            .addModifiers(PRIVATE)
-            .returns(membersInjectedTypeName)
-            .addParameter(parameter);
-    TypeElement canIgnoreReturnValue =
-        elements.getTypeElement("com.google.errorprone.annotations.CanIgnoreReturnValue");
-    if (canIgnoreReturnValue != null) {
-      method.addAnnotation(ClassName.get(canIgnoreReturnValue));
-    }
-    CodeBlock instance = CodeBlock.of("$N", parameter);
-    method.addCode(
-        InjectionSiteMethod.invokeAll(
-            injectionSites(binding),
-            name,
-            instance,
-            membersInjectedType,
-            types,
-            request ->
-                bindingExpressions.getDependencyArgumentExpression(request, name).codeBlock()));
-    method.addStatement("return $L", instance);
-
-    return method.build();
-  }
-
-  static ImmutableSet<InjectionSite> injectionSites(Binding binding) {
-    if (binding instanceof ProvisionBinding) {
-      return ((ProvisionBinding) binding).injectionSites();
-    } else if (binding instanceof MembersInjectionBinding) {
-      return ((MembersInjectionBinding) binding).injectionSites();
-    }
-    throw new IllegalArgumentException(binding.key().toString());
-  }
-
-  // TODO(user): Pull this out into a separate Scoper object or move to field initializer?
-  @Override
-  public CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope) {
-    if (!maybeScope.isPresent()) {
-      return factoryCreate;
-    }
-    Scope scope = maybeScope.get();
-    if (requiresReleasableReferences(scope)) {
-      return CodeBlock.of(
-          "$T.create($L, $L)",
-          REFERENCE_RELEASING_PROVIDER,
-          factoryCreate,
-          getReferenceReleasingProviderManagerExpression(scope));
-    } else {
-      return CodeBlock.of(
-          "$T.provider($L)",
-          scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK,
-          factoryCreate);
-    }
+    generatedComponentModel.addMethods(interfaceMethods);
   }
 }
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index c5db474c8..8950e61b2 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -204,6 +204,7 @@ java_library(
         "InjectionMethods.java",
         "MapBindingExpression.java",
         "MemberSelect.java",
+        "MembersInjectionMethods.java",
         "MembersInjectorGenerator.java",
         "MonitoringModuleGenerator.java",
         "MonitoringModuleProcessingStep.java",
@@ -213,6 +214,7 @@ java_library(
         "ProducerFactoryGenerator.java",
         "ProductionExecutorModuleGenerator.java",
         "ProviderOrProducerBindingExpression.java",
+        "ReferenceReleasingManagerFields.java",
         "SetBindingExpression.java",
         "SimpleInvocationBindingExpression.java",
         "SimpleMethodBindingExpression.java",
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 5e4891ee6..745a713e7 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -74,9 +74,10 @@ CodeBlock getComponentMethodImplementation(DependencyRequest request, ClassName
             EnumSet.of(SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP, INJECTION, PROVISION));
 
     private final CompilerOptions compilerOptions;
-    private final ClassName componentName;
     private final ComponentBindingExpressions componentBindingExpressions;
     private final ComponentRequirementFields componentRequirementFields;
+    private final MembersInjectionMethods membersInjectionMethods;
+    private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
     private final GeneratedComponentModel generatedComponentModel;
     private final SubcomponentNames subcomponentNames;
     private final BindingGraph graph;
@@ -86,9 +87,10 @@ CodeBlock getComponentMethodImplementation(DependencyRequest request, ClassName
 
     Factory(
         CompilerOptions compilerOptions,
-        ClassName componentName,
         ComponentBindingExpressions componentBindingExpressions,
         ComponentRequirementFields componentRequirementFields,
+        MembersInjectionMethods membersInjectionMethods,
+        ReferenceReleasingManagerFields referenceReleasingManagerFields,
         GeneratedComponentModel generatedComponentModel,
         SubcomponentNames subcomponentNames,
         BindingGraph graph,
@@ -96,9 +98,10 @@ CodeBlock getComponentMethodImplementation(DependencyRequest request, ClassName
         Elements elements,
         OptionalFactories optionalFactories) {
       this.compilerOptions = checkNotNull(compilerOptions);
-      this.componentName = checkNotNull(componentName);
       this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
       this.componentRequirementFields = checkNotNull(componentRequirementFields);
+      this.membersInjectionMethods = checkNotNull(membersInjectionMethods);
+      this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
       this.generatedComponentModel = checkNotNull(generatedComponentModel);
       this.subcomponentNames = checkNotNull(subcomponentNames);
       this.graph = checkNotNull(graph);
@@ -112,7 +115,7 @@ BindingExpression forField(ResolvedBindings resolvedBindings) {
       FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.empty());
       return create(
           resolvedBindings,
-          MemberSelect.localField(componentName, fieldSpec.name),
+          MemberSelect.localField(generatedComponentModel.name(), fieldSpec.name),
           Optional.of(newFrameworkFieldInitializer(fieldSpec, resolvedBindings)));
     }
 
@@ -129,7 +132,8 @@ BindingExpression forField(ResolvedBindings resolvedBindings) {
     private FieldSpec generateFrameworkField(
         ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
       boolean useRawType =
-          !isTypeAccessibleFrom(resolvedBindings.key().type(), componentName.packageName());
+          !isTypeAccessibleFrom(
+              resolvedBindings.key().type(), generatedComponentModel.name().packageName());
 
       FrameworkField contributionBindingField =
           FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);
@@ -152,13 +156,14 @@ private FrameworkFieldInitializer newFrameworkFieldInitializer(
       return new FrameworkFieldInitializer(
           fieldSpec,
           resolvedBindings,
+          subcomponentNames,
           generatedComponentModel,
           componentBindingExpressions,
           componentRequirementFields,
+          referenceReleasingManagerFields,
           compilerOptions,
           graph,
-          optionalFactories,
-          componentName);
+          optionalFactories);
     }
 
     private BindingExpression create(
@@ -184,9 +189,9 @@ private BindingExpression create(
       if (usePrivateMethod(resolvedBindings.contributionBinding())) {
         return new PrivateMethodBindingExpression(
             resolvedBindings,
-            componentName,
             generatedComponentModel,
             inlineBindingExpression,
+            referenceReleasingManagerFields,
             compilerOptions,
             types,
             elements);
@@ -201,7 +206,7 @@ private FrameworkInstanceBindingExpression producerFromProviderBindingExpression
       FieldSpec producerField =
           generateFrameworkField(resolvedBindings, Optional.of(TypeNames.PRODUCER));
       return providerBindingExpression.producerFromProvider(
-          MemberSelect.localField(componentName, producerField.name),
+          MemberSelect.localField(generatedComponentModel.name(), producerField.name),
           newFrameworkFieldInitializer(producerField, resolvedBindings).forProducerFromProvider());
     }
 
@@ -212,7 +217,7 @@ private BindingExpression inlineProvisionBindingExpression(
       switch (provisionBinding.bindingKind()) {
         case COMPONENT:
           return new ComponentInstanceBindingExpression(
-              bindingExpression, provisionBinding, componentName, types);
+              bindingExpression, provisionBinding, generatedComponentModel.name(), types);
 
         case COMPONENT_DEPENDENCY:
           return new BoundInstanceBindingExpression(
@@ -278,7 +283,7 @@ private BindingExpression inlineProvisionBindingExpression(
                 provisionBinding,
                 bindingExpression,
                 componentBindingExpressions,
-                generatedComponentModel,
+                membersInjectionMethods,
                 componentRequirementFields,
                 types,
                 elements);
@@ -301,7 +306,8 @@ private boolean canUseSimpleMethod(ContributionBinding binding) {
       // TODO(user): Also inline releasable references in experimentalAndroidMode
       return !binding.scope().isPresent()
           || (compilerOptions.experimentalAndroidMode()
-              && !generatedComponentModel.requiresReleasableReferences(binding.scope().get()));
+              && !referenceReleasingManagerFields.requiresReleasableReferences(
+                  binding.scope().get()));
     }
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentGenerator.java b/java/dagger/internal/codegen/ComponentGenerator.java
index bd29ab14c..2f1885a1b 100644
--- a/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/java/dagger/internal/codegen/ComponentGenerator.java
@@ -70,7 +70,6 @@ static ClassName componentName(TypeElement componentDefinitionType) {
   @Override
   Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
     return Optional.of(
-        new ComponentWriter(types, elements, keyFactory, compilerOptions, componentName, input)
-            .write());
+        ComponentWriter.write(types, elements, keyFactory, compilerOptions, componentName, input));
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentRequirementField.java b/java/dagger/internal/codegen/ComponentRequirementField.java
index 0f1c6d974..1cb964be1 100644
--- a/java/dagger/internal/codegen/ComponentRequirementField.java
+++ b/java/dagger/internal/codegen/ComponentRequirementField.java
@@ -146,10 +146,9 @@ CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
 
     Factory(
         GeneratedComponentModel generatedComponentModel,
-        ClassName owningComponent,
         ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
       this.generatedComponentModel = checkNotNull(generatedComponentModel);
-      this.owningComponent = checkNotNull(owningComponent);
+      this.owningComponent = checkNotNull(generatedComponentModel.name());
       this.builderFields = checkNotNull(builderFields);
     }
 
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index 5e99c7f0a..38b8dc7f1 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -31,29 +30,37 @@
  * Creates the implementation class for a component.
  */
 final class ComponentWriter extends AbstractComponentWriter {
-
-  ComponentWriter(
+  static TypeSpec.Builder write(
       DaggerTypes types,
       Elements elements,
       KeyFactory keyFactory,
       CompilerOptions compilerOptions,
       ClassName name,
       BindingGraph graph) {
+    GeneratedComponentModel generatedComponentModel = GeneratedComponentModel.forComponent(name);
+    return new ComponentWriter(
+            types, elements, keyFactory, compilerOptions, graph, generatedComponentModel)
+        .write();
+  }
+
+  private ComponentWriter(
+      DaggerTypes types,
+      Elements elements,
+      KeyFactory keyFactory,
+      CompilerOptions compilerOptions,
+      BindingGraph graph,
+      GeneratedComponentModel generatedComponentModel) {
     super(
         types,
         elements,
         compilerOptions,
-        name,
         graph,
+        generatedComponentModel,
         new SubcomponentNames(graph, keyFactory),
         new OptionalFactories(),
         new ComponentBindingExpressions(types),
-        new ComponentRequirementFields());
-  }
-
-  @Override
-  protected void decorateComponent() {
-    component.addModifiers(PUBLIC, FINAL);
+        new ComponentRequirementFields(),
+        new ReferenceReleasingManagerFields(graph, generatedComponentModel));
   }
 
   private void addBuilderFactoryMethod() {
@@ -69,12 +76,12 @@ private void addBuilderFactoryMethod() {
                     : builderName())
             .addStatement("return new $T()", builderName())
             .build();
-    component.addMethod(builderFactoryMethod);
+    generatedComponentModel.addMethod(builderFactoryMethod);
   }
 
   @Override
   protected void addBuilderClass(TypeSpec builder) {
-    component.addType(builder);
+    generatedComponentModel.addType(builder);
   }
 
   @Override
@@ -85,7 +92,7 @@ protected void addFactoryMethods() {
           graph.componentDescriptor().builderSpec().isPresent()
               ? graph.componentDescriptor().builderSpec().get().buildMethod().getSimpleName()
               : "build";
-      component.addMethod(
+      generatedComponentModel.addMethod(
           methodBuilder("create")
               .returns(ClassName.get(graph.componentType()))
               .addModifiers(PUBLIC, STATIC)
@@ -100,9 +107,4 @@ private boolean canInstantiateAllRequirements() {
         graph.componentRequirements(),
         dependency -> dependency.requiresAPassedInstance(elements, types));
   }
-
-  @Override
-  public boolean requiresReleasableReferences(Scope scope) {
-    return graph.scopesRequiringReleasableReferenceManagers().contains(scope);
-  }
 }
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index 88bb1fe17..2eed0a960 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -36,7 +36,10 @@
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
 import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
+import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
+import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
 import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.producerOf;
@@ -80,6 +83,7 @@
  */
 final class FrameworkFieldInitializer {
   private final FieldSpec fieldSpec;
+  private final SubcomponentNames subcomponentNames;
   private final GeneratedComponentModel generatedComponentModel;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final ComponentRequirementFields componentRequirementFields;
@@ -89,51 +93,55 @@
   private final BindingGraph graph;
   private final boolean isProducerFromProvider;
   private final OptionalFactories optionalFactories;
-  private final ClassName componentName;
+  private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
   private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
   FrameworkFieldInitializer(
       FieldSpec fieldSpec,
       ResolvedBindings resolvedBindings,
+      SubcomponentNames subcomponentNames,
       GeneratedComponentModel generatedComponentModel,
       ComponentBindingExpressions componentBindingExpressions,
       ComponentRequirementFields componentRequirementFields,
+      ReferenceReleasingManagerFields referenceReleasingManagerFields,
       CompilerOptions compilerOptions,
       BindingGraph graph,
-      OptionalFactories optionalFactories,
-      ClassName componentName) {
+      OptionalFactories optionalFactories) {
     this(
         fieldSpec,
         resolvedBindings,
+        subcomponentNames,
         generatedComponentModel,
         componentBindingExpressions,
         componentRequirementFields,
+        referenceReleasingManagerFields,
         compilerOptions,
         graph,
         false,
-        optionalFactories,
-        componentName);
+        optionalFactories);
   }
 
   private FrameworkFieldInitializer(
       FieldSpec fieldSpec,
       ResolvedBindings resolvedBindings,
+      SubcomponentNames subcomponentNames,
       GeneratedComponentModel generatedComponentModel,
       ComponentBindingExpressions componentBindingExpressions,
       ComponentRequirementFields componentRequirementFields,
+      ReferenceReleasingManagerFields referenceReleasingManagerFields,
       CompilerOptions compilerOptions,
       BindingGraph graph,
       boolean isProducerFromProvider,
-      OptionalFactories optionalFactories,
-      ClassName componentName) {
+      OptionalFactories optionalFactories) {
+    this.subcomponentNames = checkNotNull(subcomponentNames);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.componentRequirementFields = checkNotNull(componentRequirementFields);
+    this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
     this.resolvedBindings = checkNotNull(resolvedBindings);
     this.compilerOptions = checkNotNull(compilerOptions);
     this.graph = checkNotNull(graph);
     this.optionalFactories = checkNotNull(optionalFactories);
-    this.componentName = checkNotNull(componentName);
     this.isProducerFromProvider = isProducerFromProvider;
     this.fieldSpec = checkNotNull(fieldSpec);
   }
@@ -188,7 +196,7 @@ private CodeBlock getFieldInitialization() {
           componentBindingExpressions
               .getDependencyExpression(
                   FrameworkDependency.create(resolvedBindings.bindingKey(), PROVISION),
-                  componentName)
+                  generatedComponentModel.name())
               .codeBlock());
     }
 
@@ -212,8 +220,7 @@ private CodeBlock contributionBindingInitialization() {
                 contributionBinding.bindingType().frameworkClass(),
                 getDependencyExpression(
                     getOnlyElement(contributionBinding.frameworkDependencies())));
-        return generatedComponentModel.decorateForScope(
-            delegatingCodeBlock, contributionBinding.scope());
+        return decorateForScope(delegatingCodeBlock, contributionBinding.scope());
       case SINGLETON_INSTANCE:
         checkState(contributionBinding.scope().isPresent());
         // fall through
@@ -246,7 +253,8 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
             "$T.create($L)",
             INSTANCE_FACTORY,
             componentRequirementFields.getExpressionDuringInitialization(
-                ComponentRequirement.forDependency(binding.key().type()), componentName));
+                ComponentRequirement.forDependency(binding.key().type()),
+                generatedComponentModel.name()));
 
       case COMPONENT_PROVISION:
         {
@@ -293,12 +301,13 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
               "new $L($L)",
               factoryName,
               componentRequirementFields.getExpressionDuringInitialization(
-                  ComponentRequirement.forDependency(dependencyType.asType()), componentName));
+                  ComponentRequirement.forDependency(dependencyType.asType()),
+                  generatedComponentModel.name()));
         }
 
       case SUBCOMPONENT_BUILDER:
         String subcomponentName =
-            generatedComponentModel.getSubcomponentName(
+            subcomponentNames.get(
                 graph
                     .componentDescriptor()
                     .subcomponentsByBuilderType()
@@ -322,7 +331,7 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
             InstanceFactory.class,
             binding.nullableType().isPresent() ? "createNullable" : "create",
             componentRequirementFields.getExpressionDuringInitialization(
-                ComponentRequirement.forBinding(binding), componentName));
+                ComponentRequirement.forBinding(binding), generatedComponentModel.name()));
 
       case INJECTION:
       case PROVISION:
@@ -333,7 +342,7 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
             arguments.add(
                 componentRequirementFields.getExpressionDuringInitialization(
                     ComponentRequirement.forModule(binding.contributingModule().get().asType()),
-                    componentName));
+                    generatedComponentModel.name()));
           }
           arguments.addAll(getBindingDependencyExpressions(binding));
 
@@ -351,7 +360,7 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
             factoryCreate =
                 CodeBlock.of("($T) $L", binding.bindingType().frameworkClass(), factoryCreate);
           }
-          return generatedComponentModel.decorateForScope(factoryCreate, binding.scope());
+          return decorateForScope(factoryCreate, binding.scope());
         }
 
       case COMPONENT_PRODUCTION:
@@ -366,7 +375,7 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
                   .initializer(
                       componentRequirementFields.getExpressionDuringInitialization(
                           ComponentRequirement.forDependency(dependencyType.asType()),
-                          componentName))
+                          generatedComponentModel.name()))
                   .build();
           return CodeBlock.of(
               "$L",
@@ -394,7 +403,7 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
             arguments.add(
                 componentRequirementFields.getExpressionDuringInitialization(
                     ComponentRequirement.forModule(binding.contributingModule().get().asType()),
-                    componentName));
+                    generatedComponentModel.name()));
           }
           arguments.addAll(getBindingDependencyExpressions(binding));
 
@@ -424,6 +433,27 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
     }
   }
 
+  /**
+   * Maybe wraps the given creation code block in single/double check or reference releasing
+   * providers.
+   */
+  private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope) {
+    if (!maybeScope.isPresent()) {
+      return factoryCreate;
+    }
+    Scope scope = maybeScope.get();
+    if (referenceReleasingManagerFields.requiresReleasableReferences(scope)) {
+      return CodeBlock.of(
+          "$T.create($L, $L)",
+          REFERENCE_RELEASING_PROVIDER,
+          factoryCreate,
+          referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name()));
+    } else {
+      return CodeBlock.of(
+          "$T.provider($L)", scope.isReusable() ? SINGLE_CHECK : DOUBLE_CHECK, factoryCreate);
+    }
+  }
+
   private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
     return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
   }
@@ -512,7 +542,9 @@ private CodeBlock factoryForMapMultibindingInitialization(ContributionBinding bi
               getDependencyExpression(frameworkDependency));
       codeBlocks.add(
           CodeBlock.of(
-              ".put($L, $L)", getMapKeyExpression(contributionBinding, componentName), value));
+              ".put($L, $L)",
+              getMapKeyExpression(contributionBinding, generatedComponentModel.name()),
+              value));
     }
     codeBlocks.add(CodeBlock.of(".build()"));
 
@@ -528,7 +560,9 @@ private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, Code
   }
 
   private boolean useRawType() {
-    return !isTypeAccessibleFrom(resolvedBindings.key().type(), componentName.packageName());
+
+    return !isTypeAccessibleFrom(
+        resolvedBindings.key().type(), generatedComponentModel.name().packageName());
   }
 
   /**
@@ -551,12 +585,12 @@ private CodeBlock factoryForSyntheticReleasableReferenceManagerBindingInitializa
           MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
       managerExpression =
           typedReleasableReferenceManagerDecoratorExpression(
-              generatedComponentModel.getReferenceReleasingProviderManagerExpression(scope),
+              referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name()),
               scope.releasableReferencesMetadata(metadataType).get());
     } else {
       // The key's type is ReleasableReferenceManager, so return the field as is.
       managerExpression =
-          generatedComponentModel.getReferenceReleasingProviderManagerExpression(scope);
+          referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name());
     }
 
     TypeName keyType = TypeName.get(binding.key().type());
@@ -589,7 +623,7 @@ private CodeBlock factoryForSyntheticSetOfReleasableReferenceManagersInitializat
     ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
     for (Scope scope : graph.scopesRequiringReleasableReferenceManagers()) {
       CodeBlock releasableReferenceManagerExpression =
-          generatedComponentModel.getReferenceReleasingProviderManagerExpression(scope);
+          referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name());
 
       if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
         managerExpressions.add(releasableReferenceManagerExpression);
@@ -672,7 +706,7 @@ private CodeBlock factoryForSyntheticOptionalBindingInitialization(ContributionB
   /** Returns a code block referencing the given dependency. */
   private CodeBlock getDependencyExpression(FrameworkDependency frameworkDependency) {
     return componentBindingExpressions
-        .getDependencyExpression(frameworkDependency, componentName)
+        .getDependencyExpression(frameworkDependency, generatedComponentModel.name())
         .codeBlock();
   }
 
@@ -680,14 +714,15 @@ FrameworkFieldInitializer forProducerFromProvider() {
     return new FrameworkFieldInitializer(
         fieldSpec,
         resolvedBindings,
+        subcomponentNames,
         generatedComponentModel,
         componentBindingExpressions,
         componentRequirementFields,
+        referenceReleasingManagerFields,
         compilerOptions,
         graph,
         true,
-        optionalFactories,
-        componentName);
+        optionalFactories);
   }
 
   /** Initialization state for a factory field. */
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 6ce591a2c..8d8faa946 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -16,56 +16,93 @@
 
 package dagger.internal.codegen;
 
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
-import java.util.Optional;
+import java.util.ArrayList;
+import java.util.List;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
 
 /** The model of the component being generated. */
-interface GeneratedComponentModel {
+final class GeneratedComponentModel {
+  private final ClassName name;
+  // TODO(user): This is only non-private to ease migration with AbstractComponentWriter!
+  final TypeSpec.Builder component;
+  private final UniqueNameSet componentFieldNames = new UniqueNameSet();
+  private final UniqueNameSet componentMethodNames = new UniqueNameSet();
+  private final List<CodeBlock> initializations = new ArrayList<>();
+
+  private GeneratedComponentModel(ClassName name, Modifier... modifiers) {
+    this.name = name;
+    this.component = classBuilder(name).addModifiers(modifiers);
+  }
+
+  static GeneratedComponentModel forComponent(ClassName name) {
+    return new GeneratedComponentModel(name, PUBLIC, FINAL);
+  }
+
+  static GeneratedComponentModel forSubcomponent(ClassName name) {
+    return new GeneratedComponentModel(name, PRIVATE, FINAL);
+  }
+
+  /** Returns the name of the component. */
+  ClassName name() {
+    return name;
+  }
 
   /** Adds the given field to the component. */
-  void addField(FieldSpec fieldSpec);
+  // TODO(user): Add a enum for field order/type so that we can control the order of fields.
+  void addField(FieldSpec fieldSpec) {
+    component.addField(fieldSpec);
+  }
 
   /** Adds the given method to the component. */
-  void addMethod(MethodSpec methodSpec);
+  // TODO(user): Add a enum for method order/type so that we can control the order of methods.
+  void addMethod(MethodSpec methodSpec) {
+    component.addMethod(methodSpec);
+  }
+
+  /** Adds the given methods to the component. */
+  void addMethods(Iterable<MethodSpec> methodSpecs) {
+    component.addMethods(methodSpecs);
+  }
 
   /** Adds the given code block to the initialize methods of the component. */
-  void addInitialization(CodeBlock codeBlock);
+  void addInitialization(CodeBlock codeBlock) {
+    initializations.add(codeBlock);
+  }
 
   /** Adds the given type to the component. */
-  void addType(TypeSpec typeSpec);
+  void addType(TypeSpec typeSpec) {
+    component.addType(typeSpec);
+  }
 
   /** Returns a new, unique field name for the component based on the given name. */
-  String getUniqueFieldName(String name);
+  String getUniqueFieldName(String name) {
+    return componentFieldNames.getUniqueName(name);
+  }
 
   /** Returns a new, unique method name for the component based on the given name. */
-  String getUniqueMethodName(String name);
-
-  /** Returns the corresponding subcomponent name for the given subcomponent descriptor. */
-  String getSubcomponentName(ComponentDescriptor subcomponentDescriptor);
-
-  /**
-   * Returns the {@code private} members injection method that injects objects with the {@code key}.
-   */
-  MethodSpec getMembersInjectionMethod(Key key);
-
-  /**
-   * Maybe wraps the given creation code block in single/double check or reference releasing
-   * providers.
-   */
-  CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope);
-
-  /**
-   * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
-   * object for a scope.
-   */
-  CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope);
-
-  /**
-   * Returns {@code true} if {@code scope} is in {@link
-   * BindingGraph#scopesRequiringReleasableReferenceManagers()} for the root graph.
-   */
-  boolean requiresReleasableReferences(Scope scope);
+  String getUniqueMethodName(String name) {
+    return componentMethodNames.getUniqueName(name);
+  }
+
+  /** Claims a new method name for the component. Does nothing if method name already exists. */
+  void claimMethodName(Name name) {
+    componentMethodNames.claim(name);
+  }
+
+  /** Returns the list of {@link CodeBlock}s that need to go in the initialize method. */
+  ImmutableList<CodeBlock> getInitializations() {
+    return ImmutableList.copyOf(initializations);
+  }
 }
diff --git a/java/dagger/internal/codegen/MembersInjectionMethods.java b/java/dagger/internal/codegen/MembersInjectionMethods.java
new file mode 100644
index 000000000..335ac4842
--- /dev/null
+++ b/java/dagger/internal/codegen/MembersInjectionMethods.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.MoreObjects.firstNonNull;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import dagger.internal.codegen.InjectionMethods.InjectionSiteMethod;
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/** Manages the member injection methods for a component. */
+final class MembersInjectionMethods {
+  private final Map<Key, MethodSpec> membersInjectionMethods = new LinkedHashMap<>();
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentBindingExpressions bindingExpressions;
+  private final BindingGraph graph;
+  private final Elements elements;
+  private final DaggerTypes types;
+
+  MembersInjectionMethods(
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions bindingExpressions,
+      BindingGraph graph,
+      Elements elements,
+      DaggerTypes types) {
+    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.bindingExpressions = checkNotNull(bindingExpressions);
+    this.graph = checkNotNull(graph);
+    this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
+  }
+
+  /**
+   * Returns the members injection {@link MethodSpec} for the given {@link Key}, creating it if
+   * necessary.
+   *
+   * <p>To get a list of all members injection {@link MethodSpec}s, call {@link #getAllMethods()}
+   */
+  MethodSpec getOrCreate(Key key) {
+    return reentrantComputeIfAbsent(membersInjectionMethods, key, this::membersInjectionMethod);
+  }
+
+  /** Returns the list of all members injection {@link MethodSpec}s for this component. */
+  ImmutableList<MethodSpec> getAllMethods() {
+    return ImmutableList.copyOf(membersInjectionMethods.values());
+  }
+
+  private MethodSpec membersInjectionMethod(Key key) {
+    Binding binding =
+        firstNonNull(
+                graph.resolvedBindings().get(BindingKey.membersInjection(key)),
+                graph.resolvedBindings().get(BindingKey.contribution(key)))
+            .binding();
+    TypeMirror keyType = binding.key().type();
+    TypeMirror membersInjectedType =
+        isTypeAccessibleFrom(keyType, generatedComponentModel.name().packageName())
+            ? keyType
+            : elements.getTypeElement("java.lang.Object").asType();
+    TypeName membersInjectedTypeName = TypeName.get(membersInjectedType);
+    Name bindingTypeName = binding.bindingTypeElement().get().getSimpleName();
+    // TODO(ronshapiro): include type parameters in this name e.g. injectFooOfT, and outer class
+    // simple names Foo.Builder -> injectFooBuilder
+    String methodName = generatedComponentModel.getUniqueMethodName("inject" + bindingTypeName);
+    ParameterSpec parameter = ParameterSpec.builder(membersInjectedTypeName, "instance").build();
+    MethodSpec.Builder method =
+        methodBuilder(methodName)
+            .addModifiers(PRIVATE)
+            .returns(membersInjectedTypeName)
+            .addParameter(parameter);
+    TypeElement canIgnoreReturnValue =
+        elements.getTypeElement("com.google.errorprone.annotations.CanIgnoreReturnValue");
+    if (canIgnoreReturnValue != null) {
+      method.addAnnotation(ClassName.get(canIgnoreReturnValue));
+    }
+    CodeBlock instance = CodeBlock.of("$N", parameter);
+    method.addCode(
+        InjectionSiteMethod.invokeAll(
+            injectionSites(binding),
+            generatedComponentModel.name(),
+            instance,
+            membersInjectedType,
+            types,
+            request ->
+                bindingExpressions
+                    .getDependencyArgumentExpression(request, generatedComponentModel.name())
+                    .codeBlock()));
+    method.addStatement("return $L", instance);
+
+    return method.build();
+  }
+
+  private static ImmutableSet<InjectionSite> injectionSites(Binding binding) {
+    if (binding instanceof ProvisionBinding) {
+      return ((ProvisionBinding) binding).injectionSites();
+    } else if (binding instanceof MembersInjectionBinding) {
+      return ((MembersInjectionBinding) binding).injectionSites();
+    }
+    throw new IllegalArgumentException(binding.key().toString());
+  }
+}
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 730e0b522..aa221dcb4 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -49,7 +49,6 @@
  * <p>Dependents of this binding expression will just called the no-arg method.
  */
 final class PrivateMethodBindingExpression extends BindingExpression {
-  private final ClassName componentName;
   private final GeneratedComponentModel generatedComponentModel;
   private final BindingExpression delegate;
   private final Map<DependencyRequest.Kind, String> methodNames =
@@ -58,22 +57,23 @@
       new EnumMap<>(DependencyRequest.Kind.class);
   private final ContributionBinding binding;
   private final CompilerOptions compilerOptions;
+  private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
   private final DaggerTypes types;
   private final Elements elements;
 
   PrivateMethodBindingExpression(
       ResolvedBindings resolvedBindings,
-      ClassName componentName,
       GeneratedComponentModel generatedComponentModel,
       BindingExpression delegate,
+      ReferenceReleasingManagerFields referenceReleasingManagerFields,
       CompilerOptions compilerOptions,
       DaggerTypes types,
       Elements elements) {
     super(resolvedBindings);
-    this.componentName = componentName;
     this.generatedComponentModel = generatedComponentModel;
     this.delegate = delegate;
     binding = resolvedBindings.contributionBinding();
+    this.referenceReleasingManagerFields = referenceReleasingManagerFields;
     this.compilerOptions = compilerOptions;
     this.types = types;
     this.elements = elements;
@@ -114,12 +114,16 @@ Expression getDependencyExpression(
     }
 
     CodeBlock invocation =
-        componentName.equals(requestingClass)
+        componentName().equals(requestingClass)
             ? CodeBlock.of("$N()", methodNames.get(requestKind))
-            : CodeBlock.of("$T.this.$N()", componentName, methodNames.get(requestKind));
+            : CodeBlock.of("$T.this.$N()", componentName(), methodNames.get(requestKind));
     return Expression.create(returnType(requestKind), invocation);
   }
 
+  private ClassName componentName() {
+    return generatedComponentModel.name();
+  }
+
   // TODO(user): Invert this method to return true if we are using the private method strategy.
   private boolean ignorePrivateMethodStrategy(DependencyRequest.Kind requestKind) {
     switch (requestKind) {
@@ -147,7 +151,7 @@ private boolean canInlineScope() {
     // TODO(user): Enable for releasable references
     return compilerOptions.experimentalAndroidMode()
         && binding.scope().isPresent()
-        && !generatedComponentModel.requiresReleasableReferences(binding.scope().get());
+        && !referenceReleasingManagerFields.requiresReleasableReferences(binding.scope().get());
   }
 
   /** Returns the first component method associated with this request kind, if one exists. */
@@ -207,7 +211,7 @@ private CodeBlock methodBody(DependencyRequest.Kind requestKind) {
         // dependency instead of delegating to the private method. To use the private method,
         // recursively call this.getDependencyExpression().
         CodeBlock asProvider =
-            getDependencyExpression(DependencyRequest.Kind.PROVIDER, componentName).codeBlock();
+            getDependencyExpression(DependencyRequest.Kind.PROVIDER, componentName()).codeBlock();
         return CodeBlock.of("return $L;", FrameworkType.PROVIDER.to(requestKind, asProvider));
       case INSTANCE:
         if (canInlineScope()) {
@@ -219,7 +223,8 @@ private CodeBlock methodBody(DependencyRequest.Kind requestKind) {
       case PRODUCER:
       case FUTURE:
         return CodeBlock.of(
-            "return $L;", delegate.getDependencyExpression(requestKind, componentName).codeBlock());
+            "return $L;",
+            delegate.getDependencyExpression(requestKind, componentName()).codeBlock());
       default:
         throw new AssertionError("Unhandled DependencyRequest: " + requestKind);
     }
@@ -232,7 +237,7 @@ private CodeBlock singleCheck(DependencyRequest.Kind requestKind) {
         .addStatement(
             "$N = $L",
             fieldName,
-            delegate.getDependencyExpression(requestKind, componentName).codeBlock())
+            delegate.getDependencyExpression(requestKind, componentName()).codeBlock())
         .endControlFlow()
         .addStatement("return ($T) $N", returnType(requestKind), fieldName)
         .build();
@@ -251,7 +256,7 @@ private CodeBlock doubleCheck(DependencyRequest.Kind requestKind) {
         .addStatement(
             "$L = $L",
             fieldName,
-            delegate.getDependencyExpression(requestKind, componentName).codeBlock())
+            delegate.getDependencyExpression(requestKind, componentName()).codeBlock())
         .endControlFlow()
         .addStatement("local = $L", fieldName)
         .endControlFlow()
@@ -284,7 +289,7 @@ private TypeSpec providerTypeSpec() {
                 .returns(TypeName.get(accessibleType(binding.contributedType())))
                 .addStatement(
                     "return $L",
-                    getDependencyExpression(DependencyRequest.Kind.INSTANCE, componentName)
+                    getDependencyExpression(DependencyRequest.Kind.INSTANCE, componentName())
                         .codeBlock())
                 .build())
         .build();
@@ -312,9 +317,9 @@ private static String dependencyKindName(DependencyRequest.Kind kind) {
 
   /** Returns a {@link TypeName} for the binding that is accessible to the component. */
   private TypeMirror accessibleType(TypeMirror typeMirror) {
-    if (Accessibility.isTypeAccessibleFrom(typeMirror, componentName.packageName())) {
+    if (Accessibility.isTypeAccessibleFrom(typeMirror, componentName().packageName())) {
       return typeMirror;
-    } else if (Accessibility.isRawTypeAccessible(typeMirror, componentName.packageName())
+    } else if (Accessibility.isRawTypeAccessible(typeMirror, componentName().packageName())
         && typeMirror.getKind().equals(TypeKind.DECLARED)) {
       return types.getDeclaredType(MoreTypes.asTypeElement(typeMirror));
     } else {
diff --git a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
new file mode 100644
index 000000000..5f169d818
--- /dev/null
+++ b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.MemberSelect.localField;
+import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER_MANAGER;
+import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Manages the {@link dagger.internal.ReferenceReleasingProviderManager} fields and the logic for
+ * releasable bindings in the graph.
+ *
+ * <p>This class should only be created once at the root component and reused by all subcomponents.
+ * This is because, currently, all {@link dagger.internal.ReferenceReleasingProviderManager} fields
+ * are stored in the root component.
+ */
+public class ReferenceReleasingManagerFields {
+  /**
+   * The member-selects for {@link dagger.internal.ReferenceReleasingProviderManager} fields,
+   * indexed by their {@code CanReleaseReferences @CanReleaseReferences} scope.
+   */
+  private final Map<Scope, MemberSelect> referenceReleasingManagerFields = new HashMap<>();
+
+  private final BindingGraph graph;
+  private final GeneratedComponentModel generatedComponentModel;
+
+  ReferenceReleasingManagerFields(
+      BindingGraph graph, GeneratedComponentModel generatedComponentModel) {
+    this.graph = checkNotNull(graph);
+    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    checkArgument(graph.componentDescriptor().kind().isTopLevel());
+  }
+
+  /**
+   * Returns {@code true} if {@code scope} is in {@link
+   * BindingGraph#scopesRequiringReleasableReferenceManagers()} for the root graph.
+   */
+  boolean requiresReleasableReferences(Scope scope) {
+    return graph.scopesRequiringReleasableReferenceManagers().contains(scope);
+  }
+
+  /**
+   * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
+   * object for a scope.
+   */
+  CodeBlock getExpression(Scope scope, ClassName requestingClass) {
+    return reentrantComputeIfAbsent(
+            referenceReleasingManagerFields, scope, this::createReferenceReleasingManagerField)
+        .getExpressionFor(requestingClass);
+  }
+
+  private MemberSelect createReferenceReleasingManagerField(Scope scope) {
+    FieldSpec field = referenceReleasingProxyManagerField(scope);
+    generatedComponentModel.addField(field);
+    return localField(generatedComponentModel.name(), field.name);
+  }
+
+  private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
+    String fieldName =
+        UPPER_CAMEL.to(LOWER_CAMEL, scope.scopeAnnotationElement().getSimpleName() + "References");
+    return FieldSpec.builder(
+            REFERENCE_RELEASING_PROVIDER_MANAGER,
+            generatedComponentModel.getUniqueFieldName(fieldName))
+        .addModifiers(PRIVATE, FINAL)
+        .initializer(
+            "new $T($T.class)",
+            REFERENCE_RELEASING_PROVIDER_MANAGER,
+            scope.scopeAnnotationElement())
+        .addJavadoc(
+            "The manager that releases references for the {@link $T} scope.\n",
+            scope.scopeAnnotationElement())
+        .build();
+  }
+}
diff --git a/java/dagger/internal/codegen/Scope.java b/java/dagger/internal/codegen/Scope.java
index 77fff76e1..9b5e797e3 100644
--- a/java/dagger/internal/codegen/Scope.java
+++ b/java/dagger/internal/codegen/Scope.java
@@ -118,6 +118,11 @@ static Scope reusableScope(Elements elements) {
     return scope(elements, Reusable.class);
   }
 
+  /** Returns {@code true} if this scope is the {@link Reusable @Reusable} scope. */
+  boolean isReusable() {
+    return getQualifiedName().contentEquals(Reusable.class.getName());
+  }
+
   /**
    * Returns {@code true} for scopes that are annotated with {@link CanReleaseReferences} or some
    * other annotation that is itself annotated with {@link CanReleaseReferences}.
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index f2857a374..9f5c44fb0 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -46,7 +46,7 @@
   private final CompilerOptions compilerOptions;
   private final ProvisionBinding provisionBinding;
   private final ComponentBindingExpressions componentBindingExpressions;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final MembersInjectionMethods membersInjectionMethods;
   private final ComponentRequirementFields componentRequirementFields;
   private final Elements elements;
 
@@ -55,7 +55,7 @@
       ProvisionBinding provisionBinding,
       BindingExpression delegate,
       ComponentBindingExpressions componentBindingExpressions,
-      GeneratedComponentModel generatedComponentModel,
+      MembersInjectionMethods membersInjectionMethods,
       ComponentRequirementFields componentRequirementFields,
       DaggerTypes types,
       Elements elements) {
@@ -67,7 +67,7 @@
     this.compilerOptions = compilerOptions;
     this.provisionBinding = provisionBinding;
     this.componentBindingExpressions = componentBindingExpressions;
-    this.generatedComponentModel = generatedComponentModel;
+    this.membersInjectionMethods = membersInjectionMethods;
     this.componentRequirementFields = componentRequirementFields;
     this.elements = elements;
   }
@@ -153,8 +153,7 @@ private Expression injectMembers(CodeBlock instance) {
       instance = CodeBlock.of("($T) ($T) $L", keyType, rawTypeName(keyType), instance);
     }
 
-    MethodSpec membersInjectionMethod =
-        generatedComponentModel.getMembersInjectionMethod(provisionBinding.key());
+    MethodSpec membersInjectionMethod = membersInjectionMethods.getOrCreate(provisionBinding.key());
     TypeMirror returnType =
         membersInjectionMethod.returnType.equals(TypeName.OBJECT)
             ? elements.getTypeElement(Object.class.getCanonicalName()).asType()
diff --git a/java/dagger/internal/codegen/SubcomponentWriter.java b/java/dagger/internal/codegen/SubcomponentWriter.java
index a9619dffa..4f9ccf239 100644
--- a/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -68,18 +68,10 @@
   }
 
   private static ClassName subcomponentName(AbstractComponentWriter parent, BindingGraph subgraph) {
-    return parent.name.nestedClass(
-        parent.subcomponentNames.get(subgraph.componentDescriptor()) + "Impl");
-  }
-
-  @Override
-  public CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
-    return parent.getReferenceReleasingProviderManagerExpression(scope);
-  }
-
-  @Override
-  public boolean requiresReleasableReferences(Scope scope) {
-    return parent.requiresReleasableReferences(scope);
+    return parent
+        .generatedComponentModel
+        .name()
+        .nestedClass(parent.subcomponentNames.get(subgraph.componentDescriptor()) + "Impl");
   }
 
   private ExecutableType resolvedSubcomponentFactoryMethod() {
@@ -94,14 +86,9 @@ private ExecutableType resolvedSubcomponentFactoryMethod() {
             subcomponentFactoryMethod.get().methodElement()));
   }
 
-  @Override
-  protected void decorateComponent() {
-    component.addModifiers(PRIVATE, FINAL);
-  }
-
   @Override
   protected void addBuilderClass(TypeSpec builder) {
-    parent.component.addType(builder);
+    parent.generatedComponentModel.addType(builder);
   }
 
   @Override
@@ -142,7 +129,7 @@ private void writeSubcomponentWithoutBuilder(
             componentField(ClassName.get(moduleTypeElement), preferredModuleName)
                 .addModifiers(PRIVATE, FINAL)
                 .build();
-        component.addField(contributionField);
+        generatedComponentModel.addField(contributionField);
 
         constructor
             .addParameter(moduleType, contributionField.name)
@@ -151,7 +138,7 @@ private void writeSubcomponentWithoutBuilder(
 
         componentRequirementFields.add(
             ComponentRequirementField.componentField(
-                componentRequirement, contributionField, name));
+                componentRequirement, contributionField, generatedComponentModel.name()));
         subcomponentConstructorParameters.add(
             CodeBlock.of("$L", moduleVariable.getSimpleName()));
       }
@@ -171,14 +158,16 @@ private void writeSubcomponentWithoutBuilder(
           componentField(ClassName.get(moduleType), preferredModuleName)
               .addModifiers(PRIVATE, FINAL)
               .build();
-      component.addField(contributionField);
+      generatedComponentModel.addField(contributionField);
       constructor.addStatement("this.$N = new $T()", contributionField, ClassName.get(moduleType));
       componentRequirementFields.add(
           ComponentRequirementField.componentField(
-              componentRequirement, contributionField, name));
+              componentRequirement, contributionField, generatedComponentModel.name()));
     }
 
-    componentMethod.addStatement("return new $T($L)",
-        name, makeParametersCodeBlock(subcomponentConstructorParameters.build()));
+    componentMethod.addStatement(
+        "return new $T($L)",
+        generatedComponentModel.name(),
+        makeParametersCodeBlock(subcomponentConstructorParameters.build()));
   }
 }
diff --git a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
index 91d009302..8bef97f00 100644
--- a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
@@ -190,10 +190,7 @@ public void toDoubleCheck() {
                     "import javax.inject.Provider;",
                     "",
                     GENERATED_ANNOTATION,
-                    "public final class DaggerTestComponent implements TestComponent {",
-                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
-                    "      new ReferenceReleasingProviderManager(",
-                    "          ReleasableScoped.CustomScope.class);")
+                    "public final class DaggerTestComponent implements TestComponent {")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
                     "  private volatile Object regularScoped = new MemoizedSentinel();",
@@ -204,6 +201,9 @@ public void toDoubleCheck() {
                     "  private Provider<ReusableScoped> reusableScopedProvider;")
                 .addLines(
                     "  private Provider<Object> reusableProvider;",
+                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
+                    "      new ReferenceReleasingProviderManager(",
+                    "          ReleasableScoped.CustomScope.class);",
                     "  private Provider<ReleasableScoped> releasableScopedProvider;",
                     "  private Provider<Object> releasableProvider;",
                     "  private Provider<Object> unscopedProvider;",
@@ -376,10 +376,7 @@ public void toSingleCheck() {
                     "import javax.inject.Provider;",
                     "",
                     GENERATED_ANNOTATION,
-                    "public final class DaggerTestComponent implements TestComponent {",
-                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
-                    "      new ReferenceReleasingProviderManager(",
-                    "          ReleasableScoped.CustomScope.class);")
+                    "public final class DaggerTestComponent implements TestComponent {")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
                     "  private volatile Object regularScoped = new MemoizedSentinel();",
@@ -389,6 +386,9 @@ public void toSingleCheck() {
                     "  private Provider<RegularScoped> regularScopedProvider;",
                     "  private Provider<ReusableScoped> reusableScopedProvider;")
                 .addLines(
+                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
+                    "      new ReferenceReleasingProviderManager(",
+                    "          ReleasableScoped.CustomScope.class);",
                     "  private Provider<ReleasableScoped> releasableScopedProvider;",
                     "  private Provider<Object> releasableProvider;",
                     "  private Provider<Object> unscopedProvider;",
@@ -554,10 +554,7 @@ public void toReleasableCheck() {
                     "import javax.inject.Provider;",
                     "",
                     GENERATED_ANNOTATION,
-                    "public final class DaggerTestComponent implements TestComponent {",
-                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
-                    "      new ReferenceReleasingProviderManager(",
-                    "          ReleasableScoped.CustomScope.class);")
+                    "public final class DaggerTestComponent implements TestComponent {")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
                     "  private volatile Object regularScoped = new MemoizedSentinel();",
@@ -567,6 +564,9 @@ public void toReleasableCheck() {
                     "  private Provider<RegularScoped> regularScopedProvider;",
                     "  private Provider<ReusableScoped> reusableScopedProvider;")
                 .addLines(
+                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
+                    "      new ReferenceReleasingProviderManager(",
+                    "          ReleasableScoped.CustomScope.class);",
                     "  private Provider<ReleasableScoped> releasableScopedProvider;",
                     "  private Provider<Object> unscopedProvider;",
                     "  private Provider<ReleasableReferenceManager>",
@@ -730,10 +730,7 @@ public void toUnscoped() {
                     "import javax.inject.Provider;",
                     "",
                     GENERATED_ANNOTATION,
-                    "public final class DaggerTestComponent implements TestComponent {",
-                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
-                    "      new ReferenceReleasingProviderManager(",
-                    "          ReleasableScoped.CustomScope.class);")
+                    "public final class DaggerTestComponent implements TestComponent {")
                 .addLinesIn(
                     EXPERIMENTAL_ANDROID_MODE,
                     "  private volatile Object regularScoped = new MemoizedSentinel();",
@@ -743,6 +740,9 @@ public void toUnscoped() {
                     "  private Provider<RegularScoped> regularScopedProvider;",
                     "  private Provider<ReusableScoped> reusableScopedProvider;")
                 .addLines(
+                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
+                    "      new ReferenceReleasingProviderManager(",
+                    "          ReleasableScoped.CustomScope.class);",
                     "  private Provider<ReleasableScoped> releasableScopedProvider;",
                     "  private Provider<ReleasableReferenceManager>",
                     "      forReleasableReferencesReleasableReferenceManagerProvider;",
