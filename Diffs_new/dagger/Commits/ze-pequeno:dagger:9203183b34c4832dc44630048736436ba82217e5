diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 350a3da47..709badff9 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -40,6 +40,7 @@
 import com.squareup.javapoet.MethodSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.model.DependencyRequest;
 import dagger.model.RequestKind;
 import java.util.HashMap;
@@ -675,6 +676,8 @@ BindingExpression wrapInMethod(
         methodImplementation(resolvedBindings, request, bindingExpression);
     Optional<ComponentMethodDescriptor> matchingComponentMethod =
         graph.componentDescriptor().findMatchingComponentMethod(request);
+    Optional<ModifiableBindingMethod> matchingModifiableBindingMethod =
+        generatedComponentModel.getModifiableBindingMethod(request);
 
     Optional<BindingExpression> modifiableBindingExpression =
         modifiableBindingExpressions.maybeWrapInModifiableMethodBindingExpression(
@@ -682,7 +685,8 @@ BindingExpression wrapInMethod(
             request,
             bindingExpression,
             methodImplementation,
-            matchingComponentMethod);
+            matchingComponentMethod,
+            matchingModifiableBindingMethod);
     if (modifiableBindingExpression.isPresent()) {
       return modifiableBindingExpression.get();
     }
@@ -691,11 +695,18 @@ BindingExpression wrapInMethod(
         .<BindingExpression>map(
             componentMethod ->
                 new ComponentMethodBindingExpression(
-                    methodImplementation, generatedComponentModel, componentMethod))
+                    methodImplementation,
+                    generatedComponentModel,
+                    componentMethod,
+                    matchingModifiableBindingMethod))
         .orElseGet(
             () ->
                 new PrivateMethodBindingExpression(
-                    resolvedBindings, request, methodImplementation, generatedComponentModel));
+                    resolvedBindings,
+                    request,
+                    methodImplementation,
+                    generatedComponentModel,
+                    matchingModifiableBindingMethod));
   }
 
   private BindingMethodImplementation methodImplementation(
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index 760c73523..c678e2904 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -21,6 +21,8 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import java.util.Optional;
 import javax.lang.model.type.TypeMirror;
 
 /**
@@ -36,8 +38,9 @@
   ComponentMethodBindingExpression(
       BindingMethodImplementation methodImplementation,
       GeneratedComponentModel generatedComponentModel,
-      ComponentMethodDescriptor componentMethod) {
-    super(methodImplementation, generatedComponentModel);
+      ComponentMethodDescriptor componentMethod,
+      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod) {
+    super(methodImplementation, generatedComponentModel, matchingModifiableBindingMethod);
     this.methodImplementation = checkNotNull(methodImplementation);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.componentMethod = checkNotNull(componentMethod);
diff --git a/java/dagger/internal/codegen/MethodBindingExpression.java b/java/dagger/internal/codegen/MethodBindingExpression.java
index 3d8520a3e..1f564ba3f 100644
--- a/java/dagger/internal/codegen/MethodBindingExpression.java
+++ b/java/dagger/internal/codegen/MethodBindingExpression.java
@@ -17,21 +17,27 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import java.util.Optional;
 
 /** A binding expression that wraps another in a nullary method on the component. */
 abstract class MethodBindingExpression extends BindingExpression {
 
   private final BindingMethodImplementation methodImplementation;
   private final GeneratedComponentModel generatedComponentModel;
+  private final Optional<ModifiableBindingMethod> matchingModifiableBindingMethod;
 
   protected MethodBindingExpression(
       BindingMethodImplementation methodImplementation,
-      GeneratedComponentModel generatedComponentModel) {
+      GeneratedComponentModel generatedComponentModel,
+      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod) {
     this.methodImplementation = checkNotNull(methodImplementation);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.matchingModifiableBindingMethod = checkNotNull(matchingModifiableBindingMethod);
   }
 
   @Override
@@ -44,6 +50,21 @@ Expression getDependencyExpression(ClassName requestingClass) {
             : CodeBlock.of("$T.this.$N()", generatedComponentModel.name(), methodName()));
   }
 
+  @Override
+  final CodeBlock getModifiableBindingMethodImplementation(
+      ModifiableBindingMethod modifiableBindingMethod, GeneratedComponentModel component) {
+    // A matching modifiable binding method means that we have previously created the binding method
+    // and we are now implementing it. If there is no matching method we need to first create the
+    // method. We create the method by deferring to getDependencyExpression (defined above) via a
+    // call to super.getModifiableBindingMethodImplementation().
+    if (matchingModifiableBindingMethod.isPresent()) {
+      checkState(
+          matchingModifiableBindingMethod.get().fulfillsSameRequestAs(modifiableBindingMethod));
+      return methodImplementation.body();
+    }
+    return super.getModifiableBindingMethodImplementation(modifiableBindingMethod, component);
+  }
+
   /** Adds the method to the component (if necessary) the first time it's called. */
   protected abstract void addMethod();
 
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index c5916f729..b4ee8678a 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -367,7 +367,8 @@ private boolean resolvedInThisComponent(BindingRequest request) {
       BindingRequest request,
       BindingExpression bindingExpression,
       BindingMethodImplementation methodImplementation,
-      Optional<ComponentMethodDescriptor> matchingComponentMethod) {
+      Optional<ComponentMethodDescriptor> matchingComponentMethod,
+      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod) {
     ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
     if (shouldUseAModifiableConcreteMethodBindingExpression(
         modifiableBindingType, matchingComponentMethod)) {
@@ -378,7 +379,7 @@ private boolean resolvedInThisComponent(BindingRequest request) {
               modifiableBindingType,
               methodImplementation,
               generatedComponentModel,
-              generatedComponentModel.getModifiableBindingMethod(request),
+              matchingModifiableBindingMethod,
               newModifiableBindingWillBeFinalized(modifiableBindingType, request)));
     }
     return Optional.empty();
diff --git a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
index fb2c1fdc2..114ddbd37 100644
--- a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
@@ -22,7 +22,6 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
-import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.TypeName;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import java.util.Optional;
@@ -39,7 +38,6 @@
   private final BindingMethodImplementation methodImplementation;
   private final GeneratedComponentModel generatedComponentModel;
   private final boolean bindingFinalized;
-  private final Optional<ModifiableBindingMethod> matchingModifiableBindingMethod;
   private Optional<String> methodName;
 
   ModifiableConcreteMethodBindingExpression(
@@ -50,32 +48,17 @@
       GeneratedComponentModel generatedComponentModel,
       Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
       boolean bindingFinalized) {
-    super(methodImplementation, generatedComponentModel);
+    super(methodImplementation, generatedComponentModel, matchingModifiableBindingMethod);
     this.binding = resolvedBindings.contributionBinding();
     this.request = checkNotNull(request);
     this.modifiableBindingType = checkNotNull(modifiableBindingType);
     this.methodImplementation = checkNotNull(methodImplementation);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.bindingFinalized = bindingFinalized;
-    this.matchingModifiableBindingMethod = matchingModifiableBindingMethod;
     this.methodName =
         matchingModifiableBindingMethod.map(modifiableMethod -> modifiableMethod.methodSpec().name);
   }
 
-  @Override
-  CodeBlock getModifiableBindingMethodImplementation(
-      ModifiableBindingMethod modifiableBindingMethod, GeneratedComponentModel component) {
-    // Only emit the method implementation if the binding was known when the expression was created
-    // (and not registered when calling 'getDependencyExpression'), and we're generating a
-    // modifiable binding method for the original component (and not an ancestor component).
-    if (matchingModifiableBindingMethod.isPresent() && generatedComponentModel.equals(component)) {
-      checkState(
-          matchingModifiableBindingMethod.get().fulfillsSameRequestAs(modifiableBindingMethod));
-      return methodImplementation.body();
-    }
-    return super.getModifiableBindingMethodImplementation(modifiableBindingMethod, component);
-  }
-
   @Override
   protected void addMethod() {
     // Add the modifiable binding method to the component model if we haven't already.
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 88893fd8a..d80adb82a 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -23,6 +23,8 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.squareup.javapoet.TypeName;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import java.util.Optional;
 
 /**
  * A binding expression that wraps the dependency expressions in a private, no-arg method.
@@ -40,8 +42,9 @@
       ResolvedBindings resolvedBindings,
       BindingRequest request,
       BindingMethodImplementation methodImplementation,
-      GeneratedComponentModel generatedComponentModel) {
-    super(methodImplementation, generatedComponentModel);
+      GeneratedComponentModel generatedComponentModel,
+      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod) {
+    super(methodImplementation, generatedComponentModel, matchingModifiableBindingMethod);
     this.binding = resolvedBindings.contributionBinding();
     this.request = checkNotNull(request);
     this.methodImplementation = checkNotNull(methodImplementation);
diff --git a/javatests/dagger/functional/BUILD b/javatests/dagger/functional/BUILD
index 6d5f0d5d9..43b2fc2a3 100644
--- a/javatests/dagger/functional/BUILD
+++ b/javatests/dagger/functional/BUILD
@@ -58,8 +58,6 @@ GenJavaTests(
             "HjarTest.java",
             # TODO(b/72748365): Remove these exclusions
             "ReleasableReferencesComponentsTest.java",
-            "ReusableTest.java",
-            "ComponentWithReusableBindings.java",
         ],
     ),
     javacopts = DOCLINT_HTML_AND_SYNTAX,
diff --git a/javatests/dagger/functional/guava/BUILD b/javatests/dagger/functional/guava/BUILD
index 6c74837d7..3dacd5494 100644
--- a/javatests/dagger/functional/guava/BUILD
+++ b/javatests/dagger/functional/guava/BUILD
@@ -35,4 +35,18 @@ GenJavaTests(
     ],
 )
 
-# TODO(b/72748365): Add "with aot" tests, once they pass.
+GenJavaTests(
+    name = "guava_tests_with_aot",
+    srcs = glob(["**/*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    with_aot = True,
+    deps = [
+        "//:dagger_with_compiler",
+        "@google_bazel_common//third_party/java/auto:value",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/jsr305_annotations",
+        "@google_bazel_common//third_party/java/jsr330_inject",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/truth",
+    ],
+)
diff --git a/javatests/dagger/functional/producers/BUILD b/javatests/dagger/functional/producers/BUILD
index 5d595a3f4..a2c8dec65 100644
--- a/javatests/dagger/functional/producers/BUILD
+++ b/javatests/dagger/functional/producers/BUILD
@@ -48,8 +48,9 @@ GenJavaTests(
         # TODO(b/72748365): Remove these exclusions
         exclude = [
             "subcomponent/*.java",
-            "subcomponent/pruning/*.java",
-            "cancellation/*.java",
+            "subcomponent/pruning/ProductionSubcomponentOnlyRequestedBySiblingTest.java",
+            "cancellation/ProducerSubcomponentCancellationTest.java",
+            "cancellation/CancellationPolicyTest.java",
         ],
     ),
     javacopts = SOURCE_7_TARGET_7 + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 538d160b8..631de512b 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -1412,6 +1412,140 @@ public void optionalBindings_boundInAncestorAndSatisfiedInGrandAncestor() {
         .hasSourceEquivalentTo(generatedGrandAncestor);
   }
 
+  @Test
+  public void optionalBindings_boundInComponentAndSatisfiedInSubcomponent() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "MissingInLeaf", "DependencyOfMissingInLeaf");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  MissingInLeaf missingFromComponentMethod();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  static DependencyOfMissingInLeaf dependency() {",
+            "    return new DependencyOfMissingInLeaf();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.RootModule",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class RootModule {",
+            "  @BindsOptionalOf",
+            "  abstract DependencyOfMissingInLeaf dependency();",
+            "",
+            "  @Provides",
+            "  static MissingInLeaf satisfiedInRoot(",
+            "      Optional<DependencyOfMissingInLeaf> dependency) {",
+            "    return new MissingInLeaf();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = RootModule.class)",
+            "interface Root {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Leaf leaf() {",
+            "    return new LeafImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "  }",
+            "",
+            "  public final class LeafImpl extends DaggerLeaf {",
+            "    private LeafImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    private Optional<DependencyOfMissingInLeaf>",
+            "        getOptionalOfDependencyOfMissingInLeaf() {",
+            "      return Optional.of(LeafModule_DependencyFactory.proxyDependency());",
+            "    }",
+            "",
+            "    @Override",
+            "    public MissingInLeaf missingFromComponentMethod() {",
+            "      return RootModule_SatisfiedInRootFactory.proxySatisfiedInRoot(",
+            "          getOptionalOfDependencyOfMissingInLeaf());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
   @Test
   public void setMultibindings_contributionsInLeaf() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
