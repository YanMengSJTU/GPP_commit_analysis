diff --git a/java/dagger/internal/MapBuilder.java b/java/dagger/internal/MapBuilder.java
new file mode 100644
index 000000000..1560491b1
--- /dev/null
+++ b/java/dagger/internal/MapBuilder.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+
+import java.util.Collections;
+import java.util.Map;
+
+/**
+ * A fluent builder class that returns a {@link Map}. Used in component implementations where a map
+ * must be created in one fluent statement for inlined request fulfillments.
+ */
+public final class MapBuilder<K, V> {
+  private final Map<K, V> contributions;
+
+  private MapBuilder(int size) {
+    contributions = newLinkedHashMapWithExpectedSize(size);
+  }
+
+  /**
+   * Creates a new {@link MapBuilder} with {@code size} elements.
+   */
+  public static <K, V> MapBuilder<K, V> newMapBuilder(int size) {
+    return new MapBuilder<>(size);
+  }
+
+  public MapBuilder<K, V> put(K key, V value) {
+    contributions.put(key, value);
+    return this;
+  }
+
+  public Map<K, V> build() {
+    switch (contributions.size()) {
+      case 0:
+        return Collections.emptyMap();
+      default:
+        return Collections.unmodifiableMap(contributions);
+    }
+  }
+}
diff --git a/java/dagger/internal/MapFactory.java b/java/dagger/internal/MapFactory.java
index d4b918924..b6f925a98 100644
--- a/java/dagger/internal/MapFactory.java
+++ b/java/dagger/internal/MapFactory.java
@@ -17,8 +17,11 @@
 package dagger.internal;
 
 import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.Preconditions.checkNotNull;
 import static java.util.Collections.unmodifiableMap;
 
+import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.inject.Provider;
@@ -32,18 +35,28 @@
  *
  */
 public final class MapFactory<K, V> implements Factory<Map<K, V>> {
+  private static final Provider<Map<Object, Object>> EMPTY =
+      InstanceFactory.create(Collections.emptyMap());
+
   private final Map<K, Provider<V>> contributingMap;
 
-  private MapFactory(Map<K, Provider<V>> map) {
-    this.contributingMap = unmodifiableMap(map);
+  /**
+   * Returns a new {@link Builder}
+   */
+  public static <K, V> Builder<K, V> builder(int size) {
+    return new Builder<>(size);
   }
 
   /**
-   * Returns a new MapFactory.
+   * Returns a factory of an empty map.
    */
-  public static <K, V> MapFactory<K, V> create(Provider<Map<K, Provider<V>>> mapProviderFactory) {
-    Map<K, Provider<V>> map = mapProviderFactory.get();
-    return new MapFactory<K, V>(map);
+  @SuppressWarnings("unchecked") // safe contravariant cast
+  public static <K, V> Provider<Map<K, V>> emptyMapProvider() {
+    return (Provider<Map<K, V>>) (Provider) EMPTY;
+  }
+
+  private MapFactory(Map<K, Provider<V>> map) {
+    this.contributingMap = unmodifiableMap(map);
   }
 
   /**
@@ -58,4 +71,25 @@ private MapFactory(Map<K, Provider<V>> map) {
     }
     return unmodifiableMap(result);
   }
+
+  // TODO(ronshapiro): can we merge the builders? Or maybe just use a (Immutable)MapBuilder?
+  /** A builder for {@link MapFactory}. */
+  public static final class Builder<K, V> {
+    private final LinkedHashMap<K, Provider<V>> map;
+
+    private Builder(int size) {
+      this.map = newLinkedHashMapWithExpectedSize(size);
+    }
+
+    /** Associates {@code key} with {@code providerOfValue}. */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      map.put(checkNotNull(key, "key"), checkNotNull(providerOfValue, "provider"));
+      return this;
+    }
+
+    /** Returns a new {@link MapProviderFactory}. */
+    public MapFactory<K, V> build() {
+      return new MapFactory<>(map);
+    }
+  }
 }
diff --git a/java/dagger/internal/MapProviderFactory.java b/java/dagger/internal/MapProviderFactory.java
index c27beb222..2458a3c05 100644
--- a/java/dagger/internal/MapProviderFactory.java
+++ b/java/dagger/internal/MapProviderFactory.java
@@ -17,10 +17,10 @@
 package dagger.internal;
 
 import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.Preconditions.checkNotNull;
 import static java.util.Collections.unmodifiableMap;
 
 import dagger.Lazy;
-import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import javax.inject.Provider;
@@ -34,24 +34,13 @@
  */
 public final class MapProviderFactory<K, V>
     implements Factory<Map<K, Provider<V>>>, Lazy<Map<K, Provider<V>>> {
-  private static final MapProviderFactory<Object, Object> EMPTY =
-      new MapProviderFactory<Object, Object>(Collections.<Object, Provider<Object>>emptyMap());
-
   private final Map<K, Provider<V>> contributingMap;
 
   /**
    * Returns a new {@link Builder}
    */
   public static <K, V> Builder<K, V> builder(int size) {
-    return new Builder<K, V>(size);
-  }
-
-  /**
-   * Returns a factory of an empty map.
-   */
-  @SuppressWarnings("unchecked") // safe contravariant cast
-  public static <K, V> MapProviderFactory<K, V> empty() {
-    return (MapProviderFactory<K, V>) EMPTY;
+    return new Builder<>(size);
   }
 
   private MapProviderFactory(Map<K, Provider<V>> contributingMap) {
@@ -68,37 +57,23 @@ private MapProviderFactory(Map<K, Provider<V>> contributingMap) {
     return this.contributingMap;
   }
 
-  /**
-   * A builder to help build the {@link MapProviderFactory}
-   */
+  /** A builder for {@link MapProviderFactory}. */
   public static final class Builder<K, V> {
-    private final LinkedHashMap<K, Provider<V>> mapBuilder;
+    private final LinkedHashMap<K, Provider<V>> map;
 
     private Builder(int size) {
-      // TODO(user): consider which way to initialize mapBuilder is better
-      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
+      this.map = newLinkedHashMapWithExpectedSize(size);
     }
 
-    /**
-     * Returns a new {@link MapProviderFactory}
-     */
-    public MapProviderFactory<K, V> build() {
-      return new MapProviderFactory<K, V>(this.mapBuilder);
-    }
-
-    /**
-     * Associate k with providerOfValue in {@code Builder}
-     */
+    /** Associates {@code key} with {@code providerOfValue}. */
     public Builder<K, V> put(K key, Provider<V> providerOfValue) {
-      if (key == null) {
-        throw new NullPointerException("The key is null");
-      }
-      if (providerOfValue == null) {
-        throw new NullPointerException("The provider of the value is null");
-      }
-
-      this.mapBuilder.put(key, providerOfValue);
+      map.put(checkNotNull(key, "key"), checkNotNull(providerOfValue, "provider"));
       return this;
     }
+
+    /** Returns a new {@link MapProviderFactory}. */
+    public MapProviderFactory<K, V> build() {
+      return new MapProviderFactory<>(map);
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 093e5c573..06c8e6483 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -198,6 +198,9 @@ private BindingExpression create(
         case SYNTHETIC_MULTIBOUND_SET:
           return new SetBindingExpression(
               provisionBinding, graph, componentBindingExpressions, bindingExpression, elements);
+        case SYNTHETIC_MULTIBOUND_MAP:
+          return new MapBindingExpression(
+              provisionBinding, graph, componentBindingExpressions, bindingExpression, elements);
         case SYNTHETIC_OPTIONAL_BINDING:
           return new OptionalBindingExpression(
               provisionBinding, bindingExpression, componentBindingExpressions);
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 110d08ea0..14b9c7d07 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -35,7 +35,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
-import com.google.common.base.VerifyException;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -519,7 +518,6 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
 
             ImmutableSet.Builder<Optional<ContributionBinding>> maybeContributionBindings =
                 ImmutableSet.builder();
-            maybeContributionBindings.add(syntheticMapOfValuesBinding(requestKey));
             maybeContributionBindings.add(
                 syntheticMultibinding(
                     requestKey, multibindingContributions, multibindingDeclarations));
@@ -585,70 +583,16 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
             owningResolver.componentDescriptor.subcomponentsByBuilderType().get(builderType));
       }
 
-      private Iterable<Key> keysMatchingRequest(Key requestKey) {
+      private ImmutableSet<Key> keysMatchingRequest(Key requestKey) {
         ImmutableSet.Builder<Key> keys = ImmutableSet.builder();
         keys.add(requestKey);
         keyFactory.unwrapSetKey(requestKey, Produced.class).ifPresent(keys::add);
         keyFactory.rewrapMapKey(requestKey, Producer.class, Provider.class).ifPresent(keys::add);
         keyFactory.rewrapMapKey(requestKey, Provider.class, Producer.class).ifPresent(keys::add);
+        keys.addAll(keyFactory.implicitFrameworkMapKeys(requestKey));
         return keys.build();
       }
 
-      /**
-       * If {@code key} is a {@code Map<K, V>} or {@code Map<K, Produced<V>>}, and there are any
-       * multibinding contributions or declarations that apply to that map, returns a synthetic
-       * binding for the {@code key} that depends on an {@linkplain #syntheticMultibinding(Key,
-       * Iterable, Iterable) underlying synthetic multibinding}.
-       *
-       * <p>The returned binding has the same {@link BindingType} as the underlying synthetic
-       * multibinding.
-       */
-      private Optional<ContributionBinding> syntheticMapOfValuesBinding(final Key key) {
-        return syntheticMultibinding(
-                key,
-                multibindingContributionsForValueMap(key),
-                multibindingDeclarationsForValueMap(key))
-            .map(
-                syntheticMultibinding -> {
-                  switch (syntheticMultibinding.bindingType()) {
-                    case PROVISION:
-                      return provisionBindingFactory.syntheticMapOfValuesBinding(key);
-
-                    case PRODUCTION:
-                      return productionBindingFactory.syntheticMapOfValuesOrProducedBinding(key);
-
-                    default:
-                      throw new VerifyException(syntheticMultibinding.toString());
-                  }
-                });
-      }
-
-      /**
-       * If {@code key} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
-       * multibinding contributions whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
-       * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
-       */
-      private ImmutableSet<ContributionBinding> multibindingContributionsForValueMap(Key key) {
-        return keyFactory
-            .implicitFrameworkMapKeys(key)
-            .stream()
-            .flatMap(mapKey -> getExplicitMultibindings(mapKey).stream())
-            .collect(toImmutableSet());
-      }
-
-      /**
-       * If {@code key} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
-       * multibinding declarations whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
-       * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
-       */
-      private ImmutableSet<MultibindingDeclaration> multibindingDeclarationsForValueMap(Key key) {
-        return keyFactory
-            .implicitFrameworkMapKeys(key)
-            .stream()
-            .flatMap(mapKey -> getMultibindingDeclarations(mapKey).stream())
-            .collect(toImmutableSet());
-      }
-
       /**
        * Returns a synthetic binding that depends on individual multibinding contributions.
        *
@@ -1165,7 +1109,9 @@ private boolean hasLocalMultibindingContributions(ResolvedBindings resolvedBindi
                   .stream()
                   .map(ContributionBinding::bindingKind)
                   .anyMatch(SYNTHETIC_MULTIBOUND_KINDS::contains)
-              && !getLocalExplicitMultibindings(resolvedBindings.key()).isEmpty();
+              && keysMatchingRequest(resolvedBindings.key())
+                  .stream()
+                  .anyMatch(key -> !getLocalExplicitMultibindings(key).isEmpty());
         }
 
         /**
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index 1bbcbdc55..32143d089 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -30,7 +30,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
@@ -994,8 +993,7 @@ private void reportDuplicateBindings() {
             .stream()
             .map(ContributionBinding::bindingKind)
             // TODO(dpb): Kill with fire.
-            .anyMatch(
-                kind -> SYNTHETIC_MULTIBOUND_KINDS.contains(kind) || SYNTHETIC_MAP.equals(kind))) {
+            .anyMatch(SYNTHETIC_MULTIBOUND_KINDS::contains)) {
           reportMultipleContributionTypes();
           return;
         }
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index 8891e67d1..670675768 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -72,12 +72,6 @@
    * of contribution.
    */
   enum Kind {
-    /**
-     * The synthetic binding for {@code Map<K, V>} that depends on either
-     * {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}.
-     */
-    SYNTHETIC_MAP,
-
     /**
      * A synthetic binding for a multibound set that depends on the individual multibinding
      * {@link Provides @Provides} or {@link Produces @Produces} methods.
diff --git a/java/dagger/internal/codegen/DependencyRequest.java b/java/dagger/internal/codegen/DependencyRequest.java
index bbd899acd..06ab062ae 100644
--- a/java/dagger/internal/codegen/DependencyRequest.java
+++ b/java/dagger/internal/codegen/DependencyRequest.java
@@ -340,27 +340,49 @@ DependencyRequest producerForImplicitMapBinding(Key mapOfFactoryKey) {
       return DependencyRequest.builder().kind(Kind.PRODUCER).key(mapOfFactoryKey).build();
     }
 
+    /**
+     * Creates synthetic dependency requests for each individual multibinding contribution in {@code
+     * multibindingContributions}.
+     */
+    ImmutableSet<DependencyRequest> forMultibindingContributions(
+        Key multibindingKey, Iterable<ContributionBinding> multibindingContributions) {
+      ImmutableSet.Builder<DependencyRequest> requests = ImmutableSet.builder();
+      for (ContributionBinding multibindingContribution : multibindingContributions) {
+        requests.add(forMultibindingContribution(multibindingKey, multibindingContribution));
+      }
+      return requests.build();
+    }
+
     /**
      * Creates a synthetic dependency request for one individual {@code multibindingContribution}.
      */
     private DependencyRequest forMultibindingContribution(
-        ContributionBinding multibindingContribution) {
+        Key multibindingKey, ContributionBinding multibindingContribution) {
       checkArgument(
           multibindingContribution.key().multibindingContributionIdentifier().isPresent(),
           "multibindingContribution's key must have a multibinding contribution identifier: %s",
           multibindingContribution);
       return DependencyRequest.builder()
-          .kind(multibindingContributionRequestKind(multibindingContribution))
+          .kind(multibindingContributionRequestKind(multibindingKey, multibindingContribution))
           .key(multibindingContribution.key())
           .build();
     }
 
-    private Kind multibindingContributionRequestKind(ContributionBinding multibindingContribution) {
+    // TODO(b/28555349): support PROVIDER_OF_LAZY here too
+    private static final ImmutableSet<Kind> WRAPPING_MAP_VALUE_FRAMEWORK_TYPES =
+        ImmutableSet.of(Kind.PROVIDER, Kind.PRODUCER);
+
+    private Kind multibindingContributionRequestKind(
+        Key multibindingKey, ContributionBinding multibindingContribution) {
       switch (multibindingContribution.contributionType()) {
         case MAP:
-          return multibindingContribution.bindingType().equals(BindingType.PRODUCTION)
-              ? Kind.PRODUCER
-              : Kind.PROVIDER;
+          MapType mapType = MapType.from(multibindingKey);
+          for (Kind kind : WRAPPING_MAP_VALUE_FRAMEWORK_TYPES) {
+            if (mapType.valuesAreTypeOf(kind.frameworkClass.get())) {
+              return kind;
+            }
+          }
+          // fall through
         case SET:
         case SET_VALUES:
           return Kind.INSTANCE;
@@ -372,19 +394,6 @@ private Kind multibindingContributionRequestKind(ContributionBinding multibindin
       }
     }
 
-    /**
-     * Creates synthetic dependency requests for each individual multibinding contribution in {@code
-     * multibindingContributions}.
-     */
-    ImmutableSet<DependencyRequest> forMultibindingContributions(
-        Iterable<ContributionBinding> multibindingContributions) {
-      ImmutableSet.Builder<DependencyRequest> requests = ImmutableSet.builder();
-      for (ContributionBinding multibindingContribution : multibindingContributions) {
-        requests.add(forMultibindingContribution(multibindingContribution));
-      }
-      return requests.build();
-    }
-
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
       return forRequiredVariable(variableElement, Optional.empty());
     }
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index a8b5b164c..0b22230d0 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -29,7 +29,6 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
-import static dagger.internal.codegen.SourceFiles.frameworkMapFactoryClassName;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
@@ -48,6 +47,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -328,14 +328,6 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
               makeParametersCodeBlock(arguments));
         }
 
-      case SYNTHETIC_MAP:
-        FrameworkDependency frameworkDependency = getOnlyElement(binding.frameworkDependencies());
-        return CodeBlock.of(
-            "$T.create($L)",
-            mapFactoryClassName(binding),
-            componentBindingExpressions.getDependencyExpression(
-                frameworkDependency, componentName));
-
       case SYNTHETIC_MULTIBOUND_SET:
         return factoryForSetMultibindingInitialization(binding);
 
@@ -410,16 +402,27 @@ private CodeBlock factoryForMapMultibindingInitialization(ContributionBinding bi
 
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     MapType mapType = MapType.from(binding.key().type());
-    CodeBlock.Builder builderCall =
-        CodeBlock.builder().add("$T.", frameworkMapFactoryClassName(binding.bindingType()));
+    CodeBlock.Builder builderCall = CodeBlock.builder().add("$T.", mapFactoryClassName(binding));
     boolean useRawTypes = useRawType();
     if (!useRawTypes) {
-      builderCall.add(
-          "<$T, $T>",
-          mapType.keyType(),
-          mapType.unwrappedValueType(binding.bindingType().frameworkClass()));
+      // TODO(ronshapiro): either inline this into mapFactoryClassName, or add a
+      // mapType.unwrappedValueType() method that doesn't require a framework type
+      TypeMirror valueType = mapType.valueType();
+      for (Class<?> frameworkClass :
+          ImmutableSet.of(Provider.class, Producer.class, Produced.class)) {
+        if (mapType.valuesAreTypeOf(frameworkClass)) {
+          valueType = mapType.unwrappedValueType(frameworkClass);
+          break;
+        }
+      }
+      builderCall.add("<$T, $T>", mapType.keyType(), valueType);
+    }
+
+    if (binding.bindingType().equals(BindingType.PROVISION)) {
+      builderCall.add("builder($L)", frameworkDependencies.size());
+    } else {
+      builderCall.add("builder()");
     }
-    builderCall.add("builder($L)", frameworkDependencies.size());
     codeBlocks.add(builderCall.build());
 
     for (FrameworkDependency frameworkDependency : frameworkDependencies) {
diff --git a/java/dagger/internal/codegen/Key.java b/java/dagger/internal/codegen/Key.java
index 3c4cecc06..4871e4b30 100644
--- a/java/dagger/internal/codegen/Key.java
+++ b/java/dagger/internal/codegen/Key.java
@@ -546,12 +546,15 @@ Key forProductionComponentMonitor() {
     }
 
     /**
-     * Optionally extract a {@link Key} for the underlying provision binding(s) if such a
-     * valid key can be inferred from the given key.  Specifically, if the key represents a
-     * {@link Map}{@code <K, V>}, a key of {@code Map<K, Provider<V>>} will be returned.
+     * Optionally extract a {@link Key} for the underlying provision binding(s) if such a valid key
+     * can be inferred from the given key. Specifically, if the key represents a {@link Map}{@code
+     * <K, V>} or {@code Map<K, Producer<V>>}, a key of {@code Map<K, Provider<V>>} will be
+     * returned.
      */
     Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
-      return wrapMapKey(possibleMapKey, Provider.class);
+      return firstPresent(
+          rewrapMapKey(possibleMapKey, Produced.class, Provider.class),
+          wrapMapKey(possibleMapKey, Provider.class));
     }
 
     /**
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
new file mode 100644
index 000000000..8e5746c19
--- /dev/null
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
+import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.MapBuilder;
+import java.util.Collections;
+import java.util.Map;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/** A {@link BindingExpression} for multibound maps. */
+final class MapBindingExpression extends SimpleInvocationBindingExpression {
+  /** Maximum number of key-value pairs that can be passed to ImmutableMap.of(K, V, K, V, ...). */
+  private static final int MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS = 5;
+
+  private final ProvisionBinding binding;
+  private final ImmutableMap<DependencyRequest, ContributionBinding> dependencies;
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final Elements elements;
+
+  MapBindingExpression(
+      ProvisionBinding binding,
+      BindingGraph graph,
+      ComponentBindingExpressions componentBindingExpressions,
+      BindingExpression delegate,
+      Elements elements) {
+    super(delegate);
+    ContributionBinding.Kind bindingKind = binding.bindingKind();
+    checkArgument(bindingKind.equals(SYNTHETIC_MULTIBOUND_MAP), bindingKind);
+    this.binding = binding;
+    this.componentBindingExpressions = componentBindingExpressions;
+    this.elements = elements;
+    this.dependencies =
+        Maps.toMap(
+            binding.dependencies(),
+            dep -> graph.resolvedBindings().get(dep.bindingKey()).contributionBinding());
+  }
+
+  @Override
+  CodeBlock getInstanceDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    // TODO(ronshapiro): We should also make an ImmutableMap version of MapFactory
+    boolean isImmutableMapAvailable = isImmutableMapAvailable();
+    // TODO(ronshapiro, gak): Use Maps.immutableEnumMap() if it's available?
+    if (isImmutableMapAvailable && dependencies.size() <= MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS) {
+      return CodeBlock.builder()
+          .add("$T.", ImmutableMap.class)
+          .add(maybeTypeParameters(requestingClass))
+          .add(
+              "of($L)",
+              dependencies
+                  .keySet()
+                  .stream()
+                  .map(dependency -> keyAndValueExpression(dependency, requestingClass))
+                  .collect(toParametersCodeBlock()))
+          .build();
+    }
+    switch (dependencies.size()) {
+      case 0:
+        return collectionsStaticFactoryInvocation(requestingClass, CodeBlock.of("emptyMap()"));
+      case 1:
+        return collectionsStaticFactoryInvocation(
+            requestingClass,
+            CodeBlock.of(
+                "singletonMap($L)",
+                keyAndValueExpression(getOnlyElement(dependencies.keySet()), requestingClass)));
+      default:
+        CodeBlock.Builder instantiation = CodeBlock.builder();
+        instantiation
+            .add("$T.", isImmutableMapAvailable ? ImmutableMap.class : MapBuilder.class)
+            .add(maybeTypeParameters(requestingClass));
+        if (isImmutableMapAvailable) {
+          // TODO(ronshapiro): builderWithExpectedSize
+          instantiation.add("builder()");
+        } else {
+          instantiation.add("newMapBuilder($L)", dependencies.size());
+        }
+        for (DependencyRequest dependency : dependencies.keySet()) {
+          instantiation.add(".put($L)", keyAndValueExpression(dependency, requestingClass));
+        }
+        return instantiation.add(".build()").build();
+    }
+  }
+
+  private CodeBlock keyAndValueExpression(DependencyRequest dependency, ClassName requestingClass) {
+    return CodeBlock.of(
+        "$L, $L",
+        getMapKeyExpression(dependencies.get(dependency).mapKey().get()),
+        componentBindingExpressions.getDependencyExpression(dependency, requestingClass));
+  }
+
+  private CodeBlock collectionsStaticFactoryInvocation(
+      ClassName requestingClass, CodeBlock methodInvocation) {
+    return CodeBlock.builder()
+        .add("$T.", Collections.class)
+        .add(maybeTypeParameters(requestingClass))
+        .add(methodInvocation)
+        .build();
+  }
+
+  private CodeBlock maybeTypeParameters(ClassName requestingClass) {
+    TypeMirror bindingKeyType = binding.key().type();
+    MapType mapType = MapType.from(binding.key());
+    return isTypeAccessibleFrom(bindingKeyType, requestingClass.packageName())
+        ? CodeBlock.of("<$T, $T>", mapType.keyType(), mapType.valueType())
+        : CodeBlock.of("");
+  }
+
+  private boolean isImmutableMapAvailable() {
+    return elements.getTypeElement(ImmutableMap.class.getCanonicalName()) != null;
+  }
+
+  @Override
+  protected CodeBlock explicitTypeParameter(ClassName requestingClass) {
+    if (isImmutableMapAvailable()) {
+      TypeMirror keyType = binding.key().type();
+      return CodeBlock.of(
+          "<$T>",
+          isTypeAccessibleFrom(keyType, requestingClass.packageName()) ? keyType : Map.class);
+    }
+    return CodeBlock.of("");
+  }
+}
diff --git a/java/dagger/internal/codegen/MemberSelect.java b/java/dagger/internal/codegen/MemberSelect.java
index 54662921f..fc0217a39 100644
--- a/java/dagger/internal/codegen/MemberSelect.java
+++ b/java/dagger/internal/codegen/MemberSelect.java
@@ -20,17 +20,19 @@
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.toTypeNamesCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
-import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
-import static dagger.internal.codegen.SourceFiles.frameworkMapFactoryClassName;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
 import static dagger.internal.codegen.TypeNames.FACTORY;
+import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
+import static dagger.internal.codegen.TypeNames.PRODUCER;
+import static dagger.internal.codegen.TypeNames.PRODUCERS;
+import static dagger.internal.codegen.TypeNames.PROVIDER;
 import static javax.lang.model.type.TypeKind.DECLARED;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -88,7 +90,7 @@ CodeBlock getExpressionFor(ClassName usingClass) {
             && !contributionBinding.scope().isPresent()) {
           switch (contributionBinding.bindingKind()) {
             case SYNTHETIC_MULTIBOUND_MAP:
-              return Optional.of(emptyFrameworkMapFactory(contributionBinding));
+              return Optional.of(emptyMapFactory(contributionBinding));
 
             case SYNTHETIC_MULTIBOUND_SET:
               return Optional.of(emptySetFactory(contributionBinding));
@@ -166,20 +168,19 @@ private static MemberSelect noOpMembersInjector(TypeMirror type) {
         MEMBERS_INJECTOR);
   }
 
-  /**
-   * A {@link MemberSelect} for a factory of an empty map of factory types, where a factory can be
-   * either a {@link javax.inject.Provider} or {@link dagger.producers.Producer}.
-   */
-  private static MemberSelect emptyFrameworkMapFactory(ContributionBinding contributionBinding) {
+  /** A {@link MemberSelect} for a factory of an empty map. */
+  private static MemberSelect emptyMapFactory(ContributionBinding contributionBinding) {
     BindingType bindingType = contributionBinding.bindingType();
-    MapType mapType = MapType.from(contributionBinding.key());
-
-    return new ParameterizedStaticMethod(
-        frameworkMapFactoryClassName(bindingType),
-        ImmutableList.of(
-            mapType.keyType(), mapType.unwrappedValueType(bindingType.frameworkClass())),
-        CodeBlock.of("empty()"),
-        ClassName.get(bindingType.frameworkClass()));
+    ImmutableList<TypeMirror> typeParameters =
+        ImmutableList.copyOf(
+            MoreTypes.asDeclared(contributionBinding.key().type()).getTypeArguments());
+    if (bindingType.equals(BindingType.PRODUCTION)) {
+      return new ParameterizedStaticMethod(
+          PRODUCERS, typeParameters, CodeBlock.of("emptyMapProducer()"), PRODUCER);
+    } else {
+      return new ParameterizedStaticMethod(
+          MAP_FACTORY, typeParameters, CodeBlock.of("emptyMapProvider()"), PROVIDER);
+    }
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ProductionBinding.java b/java/dagger/internal/codegen/ProductionBinding.java
index 4a71dea84..441fb5c1e 100644
--- a/java/dagger/internal/codegen/ProductionBinding.java
+++ b/java/dagger/internal/codegen/ProductionBinding.java
@@ -178,28 +178,6 @@ ProductionBinding forProducesMethod(
           .build();
     }
 
-    /**
-     * A synthetic binding of {@code Map<K, V>} or {@code Map<K, Produced<V>>} that depends on
-     * {@code Map<K, Producer<V>>}.
-     */
-    ProductionBinding syntheticMapOfValuesOrProducedBinding(Key mapOfValuesOrProducedKey) {
-      checkNotNull(mapOfValuesOrProducedKey);
-      Optional<Key> mapOfProducersKey =
-          keyFactory.implicitMapProducerKeyFrom(mapOfValuesOrProducedKey);
-      checkArgument(
-          mapOfProducersKey.isPresent(),
-          "%s is not a key for of Map<K, V> or Map<K, Produced<V>>",
-          mapOfValuesOrProducedKey);
-      DependencyRequest requestForMapOfProducers =
-          dependencyRequestFactory.producerForImplicitMapBinding(mapOfProducersKey.get());
-      return ProductionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(mapOfValuesOrProducedKey)
-          .explicitDependencies(requestForMapOfProducers)
-          .bindingKind(Kind.SYNTHETIC_MAP)
-          .build();
-    }
-
     /**
      * A synthetic binding that depends explicitly on a set of individual provision or production
      * multibinding contribution methods.
@@ -212,7 +190,7 @@ ProductionBinding syntheticMultibinding(
           .contributionType(ContributionType.UNIQUE)
           .key(key)
           .explicitDependencies(
-              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
+              dependencyRequestFactory.forMultibindingContributions(key, multibindingContributions))
           .bindingKind(Kind.forMultibindingKey(key))
           .build();
     }
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index 6d40e97ec..67168ce5a 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -235,21 +235,6 @@ ProvisionBinding forProvidesMethod(
           .build();
     }
 
-    /** A synthetic binding of {@code Map<K, V>} that depends on {@code Map<K, Provider<V>>}. */
-    ProvisionBinding syntheticMapOfValuesBinding(Key mapOfValuesKey) {
-      checkNotNull(mapOfValuesKey);
-      Optional<Key> mapOfProvidersKey = keyFactory.implicitMapProviderKeyFrom(mapOfValuesKey);
-      checkArgument(mapOfProvidersKey.isPresent(), "%s is not a key for Map<K, V>", mapOfValuesKey);
-      DependencyRequest requestForMapOfProviders =
-          dependencyRequestFactory.providerForImplicitMapBinding(mapOfProvidersKey.get());
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(mapOfValuesKey)
-          .provisionDependencies(requestForMapOfProviders)
-          .bindingKind(Kind.SYNTHETIC_MAP)
-          .build();
-    }
-
     /**
      * A synthetic binding that depends explicitly on a set of individual provision multibinding
      * contribution methods.
@@ -262,7 +247,7 @@ ProvisionBinding syntheticMultibinding(
           .contributionType(ContributionType.UNIQUE)
           .key(key)
           .provisionDependencies(
-              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
+              dependencyRequestFactory.forMultibindingContributions(key, multibindingContributions))
           .bindingKind(Kind.forMultibindingKey(key))
           .build();
     }
diff --git a/java/dagger/internal/codegen/SourceFiles.java b/java/dagger/internal/codegen/SourceFiles.java
index ded5f6f67..858f18445 100644
--- a/java/dagger/internal/codegen/SourceFiles.java
+++ b/java/dagger/internal/codegen/SourceFiles.java
@@ -19,8 +19,10 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_SET;
 import static dagger.internal.codegen.Optionals.optionalComparator;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
@@ -51,17 +53,15 @@
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
-import dagger.internal.MapFactory;
-import dagger.internal.MapProviderFactory;
 import dagger.internal.SetFactory;
 import dagger.producers.Produced;
-import dagger.producers.internal.MapOfProducerProducer;
-import dagger.producers.internal.MapProducer;
+import dagger.producers.Producer;
 import dagger.producers.internal.SetOfProducedProducer;
 import dagger.producers.internal.SetProducer;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
+import javax.inject.Provider;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -264,41 +264,24 @@ static ClassName setFactoryClassName(ContributionBinding binding) {
     }
   }
 
-  /**
-   * The {@link java.util.Map}-of-value factory class name appropriate for map bindings.
-   *
-   * <ul>
-   * <li>{@link MapFactory} for provision bindings.
-   * <li>{@link MapProducer} for production bindings.
-   * </ul>
-   */
+  /** The {@link java.util.Map} factory class name appropriate for map bindings. */
   static ClassName mapFactoryClassName(ContributionBinding binding) {
+    checkState(binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP), binding.bindingKind());
+    MapType mapType = MapType.from(binding.key());
     switch (binding.bindingType()) {
-      case PRODUCTION:
-        return MapType.from(binding.key()).valuesAreTypeOf(Produced.class)
-            ? MAP_OF_PRODUCED_PRODUCER : MAP_PRODUCER;
-
       case PROVISION:
-        return MAP_FACTORY;
-
+        return mapType.valuesAreTypeOf(Provider.class) ? MAP_PROVIDER_FACTORY : MAP_FACTORY;
+      case PRODUCTION:
+        return mapType.valuesAreFrameworkType()
+            ? mapType.valuesAreTypeOf(Producer.class)
+                ? MAP_OF_PRODUCER_PRODUCER
+                : MAP_OF_PRODUCED_PRODUCER
+            : MAP_PRODUCER;
       default:
-        throw new AssertionError(binding.toString());
+        throw new IllegalArgumentException(binding.bindingType().toString());
     }
   }
 
-  /**
-   * The {@link java.util.Map}-of-framework factory class name appropriate for map bindings.
-   *
-   * <ul>
-   * <li>{@link MapProviderFactory} for provision bindings.
-   * <li>{@link MapOfProducerProducer} for production bindings.
-   * </ul>
-   */
-  static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
-    return bindingType.equals(BindingType.PRODUCTION)
-        ? MAP_OF_PRODUCER_PRODUCER : MAP_PROVIDER_FACTORY;
-  }
-
   private static String factoryPrefix(ContributionBinding binding) {
     switch (binding.bindingKind()) {
       case INJECTION:
diff --git a/java/dagger/producers/internal/MapOfProducedProducer.java b/java/dagger/producers/internal/MapOfProducedProducer.java
index 7fe2ce488..6a50b22a9 100644
--- a/java/dagger/producers/internal/MapOfProducedProducer.java
+++ b/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -16,20 +16,22 @@
 
 package dagger.producers.internal;
 
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Futures.transform;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static dagger.producers.internal.Producers.producerFromProvider;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.List;
 import java.util.Map;
+import javax.inject.Provider;
 
 /**
  * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a
@@ -39,48 +41,22 @@
  * @author Jesse Beder
  */
 public final class MapOfProducedProducer<K, V> extends AbstractProducer<Map<K, Produced<V>>> {
-  private final Producer<Map<K, Producer<V>>> mapProducerProducer;
+  private final Map<K, Producer<V>> mapOfProducers;
 
-  private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
-    this.mapProducerProducer = mapProducerProducer;
-  }
-
-  /**
-   * Returns a producer of {@code Map<K, Produced<V>>}, where the map is derived from the given map
-   * of producers by waiting for those producers' resulting futures. The iteration order mirrors the
-   * order of the input map.
-   *
-   * <p>If any of the delegate producers, or their resulting values, are null, then this producer's
-   * future will succeed and the corresponding {@code Produced<V>} will fail with a
-   * {@link NullPointerException}.
-   *
-   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
-   * component futures fails or is canceled, this one is, too.
-   */
-  public static <K, V> MapOfProducedProducer<K, V> create(
-      Producer<Map<K, Producer<V>>> mapProducerProducer) {
-    return new MapOfProducedProducer<K, V>(mapProducerProducer);
+  private MapOfProducedProducer(Map<K, Producer<V>> mapOfProducers) {
+    this.mapOfProducers = mapOfProducers;
   }
 
   @Override
   public ListenableFuture<Map<K, Produced<V>>> compute() {
-    return Futures.transformAsync(
-        mapProducerProducer.get(),
-        new AsyncFunction<Map<K, Producer<V>>, Map<K, Produced<V>>>() {
+    return Futures.transform(
+        Futures.allAsList(
+            Iterables.transform(
+                mapOfProducers.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
+        new Function<List<Map.Entry<K, Produced<V>>>, Map<K, Produced<V>>>() {
           @Override
-          public ListenableFuture<Map<K, Produced<V>>> apply(final Map<K, Producer<V>> map) {
-            // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
-            return transform(
-                Futures.allAsList(
-                    Iterables.transform(
-                        map.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
-                new Function<List<Map.Entry<K, Produced<V>>>, Map<K, Produced<V>>>() {
-                  @Override
-                  public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
-                    return ImmutableMap.copyOf(entries);
-                  }
-                },
-                directExecutor());
+          public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
+            return ImmutableMap.copyOf(entries);
           }
         },
         directExecutor());
@@ -114,4 +90,35 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
           entryUnwrapper() {
     return (Function) ENTRY_UNWRAPPER;
   }
+
+  /** Returns a new {@link Builder}. */
+  public static <K, V> Builder<K, V> builder() {
+    return new Builder<>();
+  }
+
+  /** A builder for {@link MapOfProducedProducer}. */
+  public static final class Builder<K, V> {
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder = ImmutableMap.builder();
+
+    /** Returns a new {@link MapOfProducedProducer}. */
+    public MapOfProducedProducer<K, V> build() {
+      return new MapOfProducedProducer<>(mapBuilder.build());
+    }
+
+    /** Associates {@code key} with {@code producerOfValue}. */
+    public Builder<K, V> put(K key, Producer<V> producerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(producerOfValue, "producer of value");
+      mapBuilder.put(key, producerOfValue);
+      return this;
+    }
+
+    /** Associates {@code key} with {@code providerOfValue}. */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(providerOfValue, "provider of value");
+      mapBuilder.put(key, producerFromProvider(providerOfValue));
+      return this;
+    }
+  }
 }
diff --git a/java/dagger/producers/internal/MapOfProducerProducer.java b/java/dagger/producers/internal/MapOfProducerProducer.java
index 5eef863c3..282cf86a1 100644
--- a/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -17,7 +17,6 @@
 package dagger.producers.internal;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize;
 import static dagger.producers.internal.Producers.producerFromProvider;
 
 import com.google.common.collect.ImmutableMap;
@@ -34,20 +33,11 @@
  * @author Jesse Beder
  */
 public final class MapOfProducerProducer<K, V> extends AbstractProducer<Map<K, Producer<V>>> {
-  private static final MapOfProducerProducer<Object, Object> EMPTY =
-      new MapOfProducerProducer<Object, Object>(ImmutableMap.<Object, Producer<Object>>of());
-
   private final ImmutableMap<K, Producer<V>> contributingMap;
 
   /** Returns a new {@link Builder}. */
-  public static <K, V> Builder<K, V> builder(int size) {
-    return new Builder<K, V>(size);
-  }
-
-  /** Returns a producer of an empty map. */
-  @SuppressWarnings("unchecked") // safe contravariant cast
-  public static <K, V> MapOfProducerProducer<K, V> empty() {
-    return (MapOfProducerProducer<K, V>) EMPTY;
+  public static <K, V> Builder<K, V> builder() {
+    return new Builder<>();
   }
 
   private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
@@ -59,22 +49,11 @@ private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
     return Futures.<Map<K, Producer<V>>>immediateFuture(contributingMap);
   }
 
-  /**
-   * A builder to help build the {@link MapOfProducerProducer}
-   */
+  /** A builder for {@link MapOfProducerProducer} */
   public static final class Builder<K, V> {
-    private final Map<K, Producer<V>> mapBuilder;
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder = ImmutableMap.builder();
 
-    private Builder(int size) {
-      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
-    }
-
-    /** Returns a new {@link MapOfProducerProducer}. */
-    public MapOfProducerProducer<K, V> build() {
-      return new MapOfProducerProducer<K, V>(ImmutableMap.copyOf(mapBuilder));
-    }
-
-    /** Associates key with producerOfValue in {@code Builder}. */
+    /** Associates {@code key} with {@code producerOfValue}. */
     public Builder<K, V> put(K key, Producer<V> producerOfValue) {
       checkNotNull(key, "key");
       checkNotNull(producerOfValue, "producer of value");
@@ -82,12 +61,17 @@ private Builder(int size) {
       return this;
     }
 
-    /** Associates key with providerOfValue in {@code Builder}. */
+    /** Associates {@code key} with {@code providerOfValue}. */
     public Builder<K, V> put(K key, Provider<V> providerOfValue) {
       checkNotNull(key, "key");
       checkNotNull(providerOfValue, "provider of value");
       mapBuilder.put(key, producerFromProvider(providerOfValue));
       return this;
     }
+
+    /** Returns a new {@link MapOfProducerProducer}. */
+    public MapOfProducerProducer<K, V> build() {
+      return new MapOfProducerProducer<>(mapBuilder.build());
+    }
   }
 }
diff --git a/java/dagger/producers/internal/MapProducer.java b/java/dagger/producers/internal/MapProducer.java
index 1a13b9d53..ca1650e08 100644
--- a/java/dagger/producers/internal/MapProducer.java
+++ b/java/dagger/producers/internal/MapProducer.java
@@ -16,19 +16,21 @@
 
 package dagger.producers.internal;
 
-import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static dagger.producers.internal.Producers.producerFromProvider;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
+import javax.inject.Provider;
 
 /**
  * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a
@@ -37,73 +39,64 @@
  * @author Jesse Beder
  */
 public final class MapProducer<K, V> extends AbstractProducer<Map<K, V>> {
-  private final Producer<Map<K, Producer<V>>> mapProducerProducer;
+  private final ImmutableMap<K, Producer<V>> mapOfProducers;
 
-  private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
-    this.mapProducerProducer = mapProducerProducer;
+  private MapProducer(ImmutableMap<K, Producer<V>> mapOfProducers) {
+    this.mapOfProducers = mapOfProducers;
   }
 
-  /**
-   * Returns a producer of {@code Map<K, V>}, where the map is derived from the given map of
-   * producers by waiting for those producers' resulting futures. The iteration order mirrors the
-   * order of the input map.
-   *
-   * <p>If any of the delegate producers, or their resulting values, are null, then this producer's
-   * future will fail with a {@link NullPointerException}.
-   *
-   * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
-   * component futures fails or is canceled, this one is, too.
-   */
-  public static <K, V> MapProducer<K, V> create(Producer<Map<K, Producer<V>>> mapProducerProducer) {
-    return new MapProducer<K, V>(mapProducerProducer);
+  /** Returns a new {@link Builder}. */
+  public static <K, V> Builder<K, V> builder() {
+    return new Builder<>();
   }
 
-  @Override
-  public ListenableFuture<Map<K, V>> compute() {
-    return Futures.transformAsync(
-        mapProducerProducer.get(),
-        new AsyncFunction<Map<K, Producer<V>>, Map<K, V>>() {
-          @Override
-          public ListenableFuture<Map<K, V>> apply(final Map<K, Producer<V>> map) {
-            // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
-            return transform(
-                Futures.allAsList(
-                    Iterables.transform(map.entrySet(), MapProducer.<K, V>entryUnwrapper())),
-                new Function<List<Map.Entry<K, V>>, Map<K, V>>() {
-                  @Override
-                  public Map<K, V> apply(List<Map.Entry<K, V>> entries) {
-                    return ImmutableMap.copyOf(entries);
-                  }
-                },
-                directExecutor());
-          }
-        },
-        directExecutor());
+  /** A builder for {@link MapProducer} */
+  public static final class Builder<K, V> {
+    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder = ImmutableMap.builder();
+
+    /** Associates {@code key} with {@code producerOfValue}. */
+    public Builder<K, V> put(K key, Producer<V> producerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(producerOfValue, "producer of value");
+      mapBuilder.put(key, producerOfValue);
+      return this;
+    }
+
+    /** Associates {@code key} with {@code providerOfValue}. */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(providerOfValue, "provider of value");
+      mapBuilder.put(key, producerFromProvider(providerOfValue));
+      return this;
+    }
+
+    /** Returns a new {@link MapProducer}. */
+    public MapProducer<K, V> build() {
+      return new MapProducer<>(mapBuilder.build());
+    }
   }
 
-  private static final Function<
-          Map.Entry<Object, Producer<Object>>, ListenableFuture<Map.Entry<Object, Object>>>
-      ENTRY_UNWRAPPER =
-          new Function<
-              Map.Entry<Object, Producer<Object>>, ListenableFuture<Map.Entry<Object, Object>>>() {
+  @Override
+  protected ListenableFuture<Map<K, V>> compute() {
+    final List<ListenableFuture<Map.Entry<K, V>>> listOfEntries = new ArrayList<>();
+    for (final Entry<K, Producer<V>> entry : mapOfProducers.entrySet()) {
+      listOfEntries.add(
+          Futures.transform(entry.getValue().get(), new Function<V, Entry<K, V>>() {
             @Override
-            public ListenableFuture<Map.Entry<Object, Object>> apply(
-                final Map.Entry<Object, Producer<Object>> entry) {
-              return transform(
-                  entry.getValue().get(),
-                  new Function<Object, Map.Entry<Object, Object>>() {
-                    @Override
-                    public Map.Entry<Object, Object> apply(Object value) {
-                      return Maps.immutableEntry(entry.getKey(), value);
-                    }
-                  },
-                  directExecutor());
+            public Entry<K, V> apply(V computedValue) {
+              return Maps.immutableEntry(entry.getKey(), computedValue);
             }
-          };
+          }, directExecutor()));
+    }
 
-  @SuppressWarnings({"unchecked", "rawtypes"}) // bivariate implementation
-  private static <K, V>
-      Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, V>>> entryUnwrapper() {
-    return (Function) ENTRY_UNWRAPPER;
+    return Futures.transform(
+        Futures.allAsList(listOfEntries),
+        new Function<List<Map.Entry<K, V>>, Map<K, V>>() {
+          @Override
+          public Map<K, V> apply(List<Map.Entry<K, V>> entries) {
+            return ImmutableMap.copyOf(entries);
+          }
+        },
+        directExecutor());
   }
 }
diff --git a/java/dagger/producers/internal/Producers.java b/java/dagger/producers/internal/Producers.java
index 2f3a68c4a..3a603bebe 100644
--- a/java/dagger/producers/internal/Producers.java
+++ b/java/dagger/producers/internal/Producers.java
@@ -22,6 +22,7 @@
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
 import com.google.common.base.Function;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
@@ -29,6 +30,7 @@
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
 
@@ -151,5 +153,13 @@
     };
   }
 
+  private static final Producer<Map<Object, Object>> EMPTY_MAP_PRODUCER =
+      Producers.<Map<Object, Object>>immediateProducer(ImmutableMap.of());
+
+  @SuppressWarnings("unchecked") // safe contravariant cast
+  public static <K, V> Producer<Map<K, V>> emptyMapProducer() {
+    return (Producer<Map<K, V>>) (Producer) EMPTY_MAP_PRODUCER;
+  }
+
   private Producers() {}
 }
diff --git a/javatests/dagger/functional/LazyMaps.java b/javatests/dagger/functional/LazyMaps.java
new file mode 100644
index 000000000..eeb136849
--- /dev/null
+++ b/javatests/dagger/functional/LazyMaps.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.StringKey;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Provider;
+import javax.inject.Singleton;
+
+/**
+ * Bindings that use {@code Lazy<T>} as the value in a multibound map. A regression was uncovered
+ * when using {@code MapType.valuesAreFrameworkType()}, which treats {@link Lazy} as a framework
+ * type and incorrectly suggested {@link dagger.internal.MapProviderFactory} for a {@code Map<K,
+ * Lazy<V>>} instead of a plain {@link dagger.internal.MapFactory}. See b/65084589.
+ */
+class LazyMaps {
+  @Module
+  abstract static class TestModule {
+    @Provides
+    @Singleton
+    static AtomicInteger provideAtomicInteger() {
+      return new AtomicInteger();
+    }
+
+    @Provides
+    static String provideString(AtomicInteger atomicInteger) {
+      return "value-" + atomicInteger.incrementAndGet();
+    }
+
+    @Provides
+    @IntoMap
+    @StringKey("key")
+    static Lazy<String> mapContribution(Lazy<String> lazy) {
+      return lazy;
+    }
+
+    /* TODO(b/65118638) Replace once @Binds @IntoMap Lazy<T> methods work properly.
+    @Binds
+    @IntoMap
+    @StringKey("binds-key")
+    abstract Lazy<String> mapContributionAsBinds(Lazy<String> lazy);
+    */
+  }
+
+  @Singleton
+  @Component(modules = TestModule.class)
+  interface TestComponent {
+    Map<String, Lazy<String>> mapOfLazy();
+
+    Map<String, Provider<Lazy<String>>> mapOfProviderOfLazy();
+
+    Provider<Map<String, Lazy<String>>> providerForMapOfLazy();
+
+    Provider<Map<String, Provider<Lazy<String>>>> providerForMapOfProviderOfLazy();
+  }
+}
diff --git a/javatests/dagger/functional/LazyMapsTest.java b/javatests/dagger/functional/LazyMapsTest.java
new file mode 100644
index 000000000..a3e289a4c
--- /dev/null
+++ b/javatests/dagger/functional/LazyMapsTest.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Lazy;
+import dagger.functional.LazyMaps.TestComponent;
+import java.util.Map;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link LazyMaps}. */
+@RunWith(JUnit4.class)
+public class LazyMapsTest {
+  @Test
+  public void mapOfLazies() {
+    TestComponent component = DaggerLazyMaps_TestComponent.create();
+    Map<String, Lazy<String>> laziesMap = component.mapOfLazy();
+
+    String firstGet = laziesMap.get("key").get();
+    assertThat(firstGet).isEqualTo("value-1");
+    assertThat(firstGet).isSameAs(laziesMap.get("key").get());
+
+    assertThat(component.mapOfLazy().get("key").get()).isEqualTo("value-2");
+  }
+
+  @Test
+  public void mapOfProviderOfLaziesReturnsDifferentLazy() {
+    TestComponent component = DaggerLazyMaps_TestComponent.create();
+    Map<String, Provider<Lazy<String>>> providersOfLaziesMap = component.mapOfProviderOfLazy();
+
+    assertThat(providersOfLaziesMap.get("key").get().get())
+        .isNotEqualTo(providersOfLaziesMap.get("key").get().get());
+  }
+}
diff --git a/javatests/dagger/internal/codegen/Compilers.java b/javatests/dagger/internal/codegen/Compilers.java
index a42d1a2ff..3eee251f3 100644
--- a/javatests/dagger/internal/codegen/Compilers.java
+++ b/javatests/dagger/internal/codegen/Compilers.java
@@ -16,8 +16,12 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
+import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;
 import static com.google.testing.compile.Compiler.javac;
+import static java.util.stream.Collectors.joining;
 
+import com.google.common.base.Splitter;
 import com.google.testing.compile.Compiler;
 
 /** {@link Compiler} instances for testing Dagger. */
@@ -27,4 +31,18 @@
   static Compiler daggerCompiler() {
     return javac().withProcessors(new ComponentProcessor());
   }
+
+  static Compiler daggerCompilerWithoutGuava() {
+    return daggerCompiler().withOptions("-classpath", classpathWithoutGuava());
+  }
+
+  private static final String GUAVA = "guava";
+
+  private static String classpathWithoutGuava() {
+    return Splitter.on(PATH_SEPARATOR.value())
+        .splitToList(JAVA_CLASS_PATH.value())
+        .stream()
+        .filter(jar -> !jar.contains(GUAVA))
+        .collect(joining(PATH_SEPARATOR.value()));
+  }
 }
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 6aba380dc..cc22bae84 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -107,7 +107,7 @@ public void mapBindingsWithEnumKey() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<PathEnum, Provider<Handler>> dispatcher();",
+        "  Provider<Map<PathEnum, Provider<Handler>>> dispatcher();",
         "}");
     JavaFileObject generatedComponent =
         JavaFileObjects.forSourceLines(
@@ -153,8 +153,8 @@ public void mapBindingsWithEnumKey() {
             "  }",
             "",
             "  @Override",
-            "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
-            "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
+            "  public Provider<Map<PathEnum, Provider<Handler>>> dispatcher() {",
+            "    return mapOfPathEnumAndProviderOfHandlerProvider;",
             "  }",
             "",
             "  public static final class Builder {",
@@ -259,7 +259,7 @@ public void mapBindingsWithStringKey() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<String, Provider<Handler>> dispatcher();",
+        "  Provider<Map<String, Provider<Handler>>> dispatcher();",
         "}");
     JavaFileObject generatedComponent =
         JavaFileObjects.forSourceLines(
@@ -305,8 +305,8 @@ public void mapBindingsWithStringKey() {
             "  }",
             "",
             "  @Override",
-            "  public Map<String, Provider<Handler>> dispatcher() {",
-            "    return mapOfStringAndProviderOfHandlerProvider.get();",
+            "  public Provider<Map<String, Provider<Handler>>> dispatcher() {",
+            "    return mapOfStringAndProviderOfHandlerProvider;",
             "  }",
             "",
             "  public static final class Builder {",
@@ -420,7 +420,7 @@ public void mapBindingsWithWrappedKey() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<WrappedClassKey, Provider<Handler>> dispatcher();",
+        "  Provider<Map<WrappedClassKey, Provider<Handler>>> dispatcher();",
         "}");
     JavaFileObject generatedComponent =
         JavaFileObjects.forSourceLines(
@@ -468,8 +468,8 @@ public void mapBindingsWithWrappedKey() {
             "  }",
             "",
             "  @Override",
-            "  public Map<WrappedClassKey, Provider<Handler>> dispatcher() {",
-            "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider.get();",
+            "  public Provider<Map<WrappedClassKey, Provider<Handler>>> dispatcher() {",
+            "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
             "  }",
             "",
             "  public static final class Builder {",
@@ -585,7 +585,7 @@ public void mapBindingsWithNonProviderValue() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<PathEnum, Handler> dispatcher();",
+        "  Provider<Map<PathEnum, Handler>> dispatcher();",
         "}");
     JavaFileObject generatedComponent =
         JavaFileObjects.forSourceLines(
@@ -593,7 +593,6 @@ public void mapBindingsWithNonProviderValue() {
             "package test;",
             "",
             "import dagger.internal.MapFactory;",
-            "import dagger.internal.MapProviderFactory;",
             "import dagger.internal.Preconditions;",
             "import java.util.Map;",
             "import javax.annotation.Generated;",
@@ -603,8 +602,6 @@ public void mapBindingsWithNonProviderValue() {
             "public final class DaggerTestComponent implements TestComponent {",
             "  private Provider<Handler> provideAdminHandlerProvider;",
             "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathEnum, Provider<Handler>>>",
-            "      mapOfPathEnumAndProviderOfHandlerProvider;",
             "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
@@ -625,18 +622,16 @@ public void mapBindingsWithNonProviderValue() {
             "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
             "    this.provideLoginHandlerProvider =",
             "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+            "    this.mapOfPathEnumAndHandlerProvider =",
+            "        MapFactory.<PathEnum, Handler>builder(2)",
             "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
             "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
             "            .build();",
-            "    this.mapOfPathEnumAndHandlerProvider =",
-            "        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);",
             "  }",
             "",
             "  @Override",
-            "  public Map<PathEnum, Handler> dispatcher() {",
-            "    return mapOfPathEnumAndHandlerProvider.get();",
+            "  public Provider<Map<PathEnum, Handler>> dispatcher() {",
+            "    return mapOfPathEnumAndHandlerProvider;",
             "  }",
             "",
             "  public static final class Builder {",
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
new file mode 100644
index 000000000..77594192e
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompilerWithoutGuava;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import com.squareup.javapoet.CodeBlock;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MapBindingExpressionTest {
+  public static final CodeBlock NPE_FROM_PROVIDES =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
+  @Test
+  public void mapBindings() {
+    JavaFileObject mapModuleFile = JavaFileObjects.forSourceLines("test.MapModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.IntKey;",
+        "import dagger.multibindings.IntoMap;",
+        "import dagger.multibindings.LongKey;",
+        "import dagger.multibindings.Multibinds;",
+        "import java.util.Map;",
+        "",
+        "@Module",
+        "interface MapModule {",
+        "  @Multibinds Map<String, String> stringMap();",
+        "  @Provides @IntoMap @IntKey(0) static int provideInt() { return 0; }",
+        "  @Provides @IntoMap @LongKey(0) static long provideLong0() { return 0; }",
+        "  @Provides @IntoMap @LongKey(1) static long provideLong1() { return 1; }",
+        "  @Provides @IntoMap @LongKey(2) static long provideLong2() { return 2; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = MapModule.class)",
+        "interface TestComponent {",
+        "  Map<String, String> strings();",
+        "  Map<String, Provider<String>> providerStrings();",
+        "",
+        "  Map<Integer, Integer> ints();",
+        "  Map<Integer, Provider<Integer>> providerInts();",
+        "  Map<Long, Long> longs();",
+        "  Map<Long, Provider<Long>> providerLongs();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapBuilder;",
+            "import java.util.Collections;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private DaggerTestComponent(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<String, String> strings() {",
+            "    return Collections.<String, String>emptyMap();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<String, Provider<String>> providerStrings() {",
+            "    return Collections.<String, Provider<String>>emptyMap();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Integer, Integer> ints() {",
+            "    return Collections.<Integer, Integer>singletonMap(0, MapModule.provideInt());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Integer, Provider<Integer>> providerInts() {",
+            "    return Collections.<Integer, Provider<Integer>>singletonMap(",
+            "        0, MapModule_ProvideIntFactory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Long, Long> longs() {",
+            "    return MapBuilder.<Long, Long>newMapBuilder(3)",
+            "      .put(0L, MapModule.provideLong0())",
+            "      .put(1L, MapModule.provideLong1())",
+            "      .put(2L, MapModule.provideLong2())",
+            "      .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Long, Provider<Long>> providerLongs() {",
+            "    return MapBuilder.<Long, Provider<Long>>newMapBuilder(3)",
+            "      .put(0L, MapModule_ProvideLong0Factory.create())",
+            "      .put(1L, MapModule_ProvideLong1Factory.create())",
+            "      .put(2L, MapModule_ProvideLong2Factory.create())",
+            "      .build();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompilerWithoutGuava().compile(mapModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void inaccessible() {
+    JavaFileObject inaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible",
+            "package other;",
+            "",
+            "class Inaccessible {}");
+    JavaFileObject usesInaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.UsesInaccessible",
+            "package other;",
+            "",
+            "import java.util.Map;",
+            "import javax.inject.Inject;",
+            "",
+            "public class UsesInaccessible {",
+            "  @Inject UsesInaccessible(Map<Integer, Inaccessible> map) {}",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "other.TestModule",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "public abstract class TestModule {",
+            "  @Multibinds abstract Map<Integer, Inaccessible> ints();",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "import other.TestModule;",
+            "import other.UsesInaccessible;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  UsesInaccessible usesInaccessible();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import java.util.Collections;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import other.UsesInaccessible;",
+            "import other.UsesInaccessible_Factory;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private DaggerTestComponent(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public UsesInaccessible usesInaccessible() {",
+            "    return UsesInaccessible_Factory.newUsesInaccessible(",
+            "        (Map) Collections.emptyMap());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompilerWithoutGuava().compile(module, inaccessible, usesInaccessible, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void subcomponentOmitsInheritedBindings() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
+            "    return \"parent value\";",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Map<String, Object> objectMap();",
+            "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Collections;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private ParentModule parentModule;",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.parentModule = builder.parentModule;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return new ChildImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private ParentModule parentModule;",
+            "",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      if (parentModule == null) {",
+            "        this.parentModule = new ParentModule();",
+            "      }",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    public Builder parentModule(ParentModule parentModule) {",
+            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildImpl implements Child {",
+            "    private ChildImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<String, Object> objectMap() {",
+            "      return Collections.<String, Object>singletonMap(",
+            "          \"parent key\",",
+            "          Preconditions.checkNotNull(",
+            "              DaggerParent.this.parentModule.parentKeyObject(),",
+            "              " + NPE_FROM_PROVIDES_METHOD + ");",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompilerWithoutGuava().compile(parent, parentModule, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(expected);
+  }
+
+}
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
new file mode 100644
index 000000000..0b10fa4b8
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
@@ -0,0 +1,502 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MapBindingExpressionWithGuavaTest {
+  @Test
+  public void mapBindings() {
+    JavaFileObject mapModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.LongKey;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface MapModule {",
+            "  @Multibinds Map<String, String> stringMap();",
+            "  @Provides @IntoMap @IntKey(0) static int provideInt() { return 0; }",
+            "  @Provides @IntoMap @LongKey(0) static long provideLong0() { return 0; }",
+            "  @Provides @IntoMap @LongKey(1) static long provideLong1() { return 1; }",
+            "  @Provides @IntoMap @LongKey(2) static long provideLong2() { return 2; }",
+            "}");
+    JavaFileObject subcomponentModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.SubcomponentMapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.LongKey;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface SubcomponentMapModule {",
+            "  @Provides @IntoMap @LongKey(3) static long provideLong3() { return 3; }",
+            "  @Provides @IntoMap @LongKey(4) static long provideLong4() { return 4; }",
+            "  @Provides @IntoMap @LongKey(5) static long provideLong5() { return 5; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = MapModule.class)",
+            "interface TestComponent {",
+            "  Map<String, String> strings();",
+            "  Map<String, Provider<String>> providerStrings();",
+            "",
+            "  Map<Integer, Integer> ints();",
+            "  Map<Integer, Provider<Integer>> providerInts();",
+            "  Map<Long, Long> longs();",
+            "  Map<Long, Provider<Long>> providerLongs();",
+            "",
+            "  Sub sub();",
+            "}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = SubcomponentMapModule.class)",
+            "interface Sub {",
+            "  Map<Long, Long> longs();",
+            "  Map<Long, Provider<Long>> providerLongs();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private DaggerTestComponent(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<String, String> strings() {",
+            "    return ImmutableMap.<String, String>of();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<String, Provider<String>> providerStrings() {",
+            "    return ImmutableMap.<String, Provider<String>>of();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Integer, Integer> ints() {",
+            "    return ImmutableMap.<Integer, Integer>of(0, MapModule.provideInt());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Integer, Provider<Integer>> providerInts() {",
+            "    return ImmutableMap.<Integer, Provider<Integer>>of(",
+            "        0, MapModule_ProvideIntFactory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Long, Long> longs() {",
+            "    return ImmutableMap.<Long, Long>of(",
+            "      0L, MapModule.provideLong0(),",
+            "      1L, MapModule.provideLong1(),",
+            "      2L, MapModule.provideLong2());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<Long, Provider<Long>> providerLongs() {",
+            "    return ImmutableMap.<Long, Provider<Long>>of(",
+            "      0L, MapModule_ProvideLong0Factory.create(),",
+            "      1L, MapModule_ProvideLong1Factory.create(),",
+            "      2L, MapModule_ProvideLong2Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Sub sub() {",
+            "    return new SubImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "  private final class SubImpl implements Sub {",
+            "    private SubImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<Long, Long> longs() {",
+            "      return ImmutableMap.<Long, Long>builder()",
+            "          .put(0L, MapModule.provideLong0())",
+            "          .put(1L, MapModule.provideLong1())",
+            "          .put(2L, MapModule.provideLong2())",
+            "          .put(3L, SubcomponentMapModule.provideLong3())",
+            "          .put(4L, SubcomponentMapModule.provideLong4())",
+            "          .put(5L, SubcomponentMapModule.provideLong5())",
+            "          .build();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Map<Long, Provider<Long>> providerLongs() {",
+            "      return ImmutableMap.<Long, Provider<Long>>builder()",
+            "          .put(0L, MapModule_ProvideLong0Factory.create())",
+            "          .put(1L, MapModule_ProvideLong1Factory.create())",
+            "          .put(2L, MapModule_ProvideLong2Factory.create())",
+            "          .put(3L, SubcomponentMapModule_ProvideLong3Factory.create())",
+            "          .put(4L, SubcomponentMapModule_ProvideLong4Factory.create())",
+            "          .put(5L, SubcomponentMapModule_ProvideLong5Factory.create())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(mapModuleFile, componentFile, subcomponentModuleFile, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void inaccessible() {
+    JavaFileObject inaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.Inaccessible", "package other;", "", "class Inaccessible {}");
+    JavaFileObject usesInaccessible =
+        JavaFileObjects.forSourceLines(
+            "other.UsesInaccessible",
+            "package other;",
+            "",
+            "import java.util.Map;",
+            "import javax.inject.Inject;",
+            "",
+            "public class UsesInaccessible {",
+            "  @Inject UsesInaccessible(Map<Integer, Inaccessible> map) {}",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "other.TestModule",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "public abstract class TestModule {",
+            "  @Multibinds abstract Map<Integer, Inaccessible> ints();",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "import other.TestModule;",
+            "import other.UsesInaccessible;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  UsesInaccessible usesInaccessible();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import other.UsesInaccessible;",
+            "import other.UsesInaccessible_Factory;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private DaggerTestComponent(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public UsesInaccessible usesInaccessible() {",
+            "    return UsesInaccessible_Factory.newUsesInaccessible((Map) ImmutableMap.of());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(module, inaccessible, usesInaccessible, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void subcomponentOmitsInheritedBindings() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
+            "    return \"parent value\";",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Map<String, Object> objectMap();",
+            "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private ParentModule parentModule;",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.parentModule = builder.parentModule;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return new ChildImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private ParentModule parentModule;",
+            "",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      if (parentModule == null) {",
+            "        this.parentModule = new ParentModule();",
+            "      }",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    public Builder parentModule(ParentModule parentModule) {",
+            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildImpl implements Child {",
+            "    private ChildImpl() {}",
+            "",
+            "    @Override",
+            "    public Map<String, Object> objectMap() {",
+            "      return ImmutableMap.<String, Object>of(",
+            "          \"parent key\",",
+            "          Preconditions.checkNotNull(",
+            "              DaggerParent.this.parentModule.parentKeyObject(),",
+            "              " + NPE_FROM_PROVIDES_METHOD + ");",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(parent, parentModule, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(expected);
+  }
+
+  @Test
+  public void productionComponents() {
+    JavaFileObject mapModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "interface MapModule {",
+            "  @Multibinds Map<String, String> stringMap();",
+            "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProductionComponent;",
+        "import java.util.Map;",
+        "",
+        "@ProductionComponent(modules = MapModule.class)",
+        "interface TestComponent {",
+        "  ListenableFuture<Map<String, String>> stringMap();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private DaggerTestComponent(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public ListenableFuture<Map<String, String>> stringMap() {",
+            "    return Futures.<Map<String, String>>immediateFuture(",
+            "        ImmutableMap.<String, String>of());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder testComponent_ProductionExecutorModule(",
+            "        TestComponent_ProductionExecutorModule",
+            "            testComponent_ProductionExecutorModule) {",
+            "      Preconditions.checkNotNull(testComponent_ProductionExecutorModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(mapModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MapKeyProcessorTest.java b/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
index 4a72a5f01..11d9db41c 100644
--- a/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -212,7 +212,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
             "test.DaggerTestComponent",
             "package test;",
             "",
-            "import dagger.internal.MapProviderFactory;",
+            "import com.google.common.collect.ImmutableMap;",
             "import dagger.internal.Preconditions;",
             "import java.util.Map;",
             "import javax.annotation.Generated;",
@@ -222,8 +222,6 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
             "public final class DaggerTestComponent implements TestComponent {",
             "  private Provider<Handler> provideAdminHandlerProvider;",
             "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathKey, Provider<Handler>>>",
-            "      mapOfPathKeyAndProviderOfHandlerProvider;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
             "    initialize(builder);",
@@ -243,18 +241,15 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
             "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
             "    this.provideLoginHandlerProvider =",
             "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathKey, Handler>builder(2)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
-            "                provideAdminHandlerProvider)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-            "                provideLoginHandlerProvider)",
-            "            .build();",
             "  }",
             "",
             "  @Override",
             "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+            "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
+            "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
+            "        provideAdminHandlerProvider,",
+            "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+            "        provideLoginHandlerProvider);",
             "  }",
             "",
             "  public static final class Builder {",
@@ -386,7 +381,7 @@ public void mapKeyComponentFileWithDefaultField() {
             "test.DaggerTestComponent",
             "package test;",
             "",
-            "import dagger.internal.MapProviderFactory;",
+            "import com.google.common.collect.ImmutableMap;",
             "import dagger.internal.Preconditions;",
             "import java.util.Map;",
             "import javax.annotation.Generated;",
@@ -396,8 +391,6 @@ public void mapKeyComponentFileWithDefaultField() {
             "public final class DaggerTestComponent implements TestComponent {",
             "  private Provider<Handler> provideAdminHandlerProvider;",
             "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathKey, Provider<Handler>>>",
-            "      mapOfPathKeyAndProviderOfHandlerProvider;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
             "    initialize(builder);",
@@ -417,18 +410,15 @@ public void mapKeyComponentFileWithDefaultField() {
             "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
             "    this.provideLoginHandlerProvider =",
             "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathKey, Handler>builder(2)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
-            "                provideAdminHandlerProvider)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-            "                provideLoginHandlerProvider)",
-            "            .build();",
             "  }",
             "",
             "  @Override",
             "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+            "    return ImmutableMap.<PathKey, Provider<Handler>>of(",
+            "        PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
+            "        provideAdminHandlerProvider,",
+            "        PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+            "        provideLoginHandlerProvider);",
             "  }",
             "",
             "  public static final class Builder {",
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
index 1cadddbd7..226972c21 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
@@ -16,16 +16,11 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
-import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.Compilers.daggerCompilerWithoutGuava;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static java.util.stream.Collectors.joining;
 
-import com.google.common.base.Splitter;
 import com.google.testing.compile.Compilation;
-import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
 import com.squareup.javapoet.CodeBlock;
 import javax.tools.JavaFileObject;
@@ -136,7 +131,8 @@ public void setBindings() {
             "    }",
             "  }",
             "}");
-    Compilation compilation = compiler().compile(emptySetModuleFile, setModuleFile, componentFile);
+    Compilation compilation =
+        daggerCompilerWithoutGuava().compile(emptySetModuleFile, setModuleFile, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -251,7 +247,8 @@ public void inaccessible() {
             "  }",
             "}");
     Compilation compilation =
-        compiler().compile(module, inaccessible, inaccessible2, usesInaccessible, componentFile);
+        daggerCompilerWithoutGuava()
+            .compile(module, inaccessible, inaccessible2, usesInaccessible, componentFile);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerTestComponent")
@@ -279,7 +276,6 @@ public void subcomponentOmitsInheritedBindings() {
             "import dagger.Module;",
             "import dagger.Provides;",
             "import dagger.multibindings.IntoSet;",
-            "import dagger.multibindings.IntoMap;",
             "import dagger.multibindings.StringKey;",
             "",
             "@Module",
@@ -287,10 +283,6 @@ public void subcomponentOmitsInheritedBindings() {
             "  @Provides @IntoSet static Object parentObject() {",
             "    return \"parent object\";",
             "  }",
-            "",
-            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
-            "    return \"parent value\";",
-            "  }",
             "}");
     JavaFileObject child =
         JavaFileObjects.forSourceLines(
@@ -298,35 +290,25 @@ public void subcomponentOmitsInheritedBindings() {
             "package test;",
             "",
             "import dagger.Subcomponent;",
-            "import java.util.Map;",
             "import java.util.Set;",
             "",
             "@Subcomponent",
             "interface Child {",
             "  Set<Object> objectSet();",
-            "  Map<String, Object> objectMap();",
             "}");
     JavaFileObject expected =
         JavaFileObjects.forSourceLines(
             "test.DaggerParent",
             "package test;",
             "",
-            "import dagger.internal.MapFactory;",
-            "import dagger.internal.MapProviderFactory;",
             "import dagger.internal.Preconditions;",
             "import java.util.Collections;",
-            "import java.util.Map;",
             "import java.util.Set;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParent implements Parent {",
-            "  private Provider<Object> parentKeyObjectProvider;",
-            "",
-            "  private DaggerParent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerParent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -336,84 +318,40 @@ public void subcomponentOmitsInheritedBindings() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.parentKeyObjectProvider =",
-            "        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);",
-            "  }",
-            "",
             "  @Override",
             "  public Child child() {",
             "    return new ChildImpl();",
             "  }",
             "",
             "  public static final class Builder {",
-            "    private ParentModule parentModule;",
-            "",
             "    private Builder() {}",
             "",
             "    public Parent build() {",
-            "      if (parentModule == null) {",
-            "        this.parentModule = new ParentModule();",
-            "      }",
             "      return new DaggerParent(this);",
             "    }",
             "",
+            "    @Deprecated",
             "    public Builder parentModule(ParentModule parentModule) {",
-            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+            "      Preconditions.checkNotNull(parentModule);",
             "      return this;",
             "    }",
             "  }",
             "",
             "  private final class ChildImpl implements Child {",
-            "    private Provider<Map<String, Provider<Object>>>",
-            "        mapOfStringAndProviderOfObjectProvider;",
-            "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
-            "",
-            "    private ChildImpl() {",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      this.mapOfStringAndProviderOfObjectProvider =",
-            "          MapProviderFactory.<String, Object>builder(1)",
-            "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
-            "              .build();",
-            "      this.mapOfStringAndObjectProvider = MapFactory.create(",
-            "          mapOfStringAndProviderOfObjectProvider);",
-            "    }",
+            "    private ChildImpl() {}",
             "",
             "    @Override",
             "    public Set<Object> objectSet() {",
             "      return Collections.<Object>singleton(Preconditions.checkNotNull(",
             "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + "));",
             "    }",
-            "",
-            "    @Override",
-            "    public Map<String, Object> objectMap() {",
-            "      return mapOfStringAndObjectProvider.get();",
-            "    }",
             "  }",
             "}");
-    Compilation compilation = compiler().compile(parent, parentModule, child);
+    Compilation compilation = daggerCompilerWithoutGuava().compile(parent, parentModule, child);
     assertThat(compilation).succeeded();
     assertThat(compilation)
         .generatedSourceFile("test.DaggerParent")
         .hasSourceEquivalentTo(expected);
   }
 
-  private Compiler compiler() {
-    return daggerCompiler().withOptions("-classpath", classpathWithoutGuava());
-  }
-
-  private static final String GUAVA = "guava";
-
-  private String classpathWithoutGuava() {
-    return Splitter.on(PATH_SEPARATOR.value())
-        .splitToList(JAVA_CLASS_PATH.value())
-        .stream()
-        .filter(jar -> !jar.contains(GUAVA))
-        .collect(joining(":"));
-  }
 }
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index 1312e096e..8de07ec85 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -286,7 +286,6 @@ public void subcomponentOmitsInheritedBindings() {
             "import dagger.Module;",
             "import dagger.Provides;",
             "import dagger.multibindings.IntoSet;",
-            "import dagger.multibindings.IntoMap;",
             "import dagger.multibindings.StringKey;",
             "",
             "@Module",
@@ -294,10 +293,6 @@ public void subcomponentOmitsInheritedBindings() {
             "  @Provides @IntoSet static Object parentObject() {",
             "    return \"parent object\";",
             "  }",
-            "",
-            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
-            "    return \"parent value\";",
-            "  }",
             "}");
     JavaFileObject child =
         JavaFileObjects.forSourceLines(
@@ -305,13 +300,11 @@ public void subcomponentOmitsInheritedBindings() {
             "package test;",
             "",
             "import dagger.Subcomponent;",
-            "import java.util.Map;",
             "import java.util.Set;",
             "",
             "@Subcomponent",
             "interface Child {",
             "  Set<Object> objectSet();",
-            "  Map<String, Object> objectMap();",
             "}");
     JavaFileObject expected =
         JavaFileObjects.forSourceLines(
@@ -319,21 +312,13 @@ public void subcomponentOmitsInheritedBindings() {
             "package test;",
             "",
             "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.MapFactory;",
-            "import dagger.internal.MapProviderFactory;",
             "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
             "import java.util.Set;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParent implements Parent {",
-            "  private Provider<Object> parentKeyObjectProvider;",
-            "",
-            "  private DaggerParent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerParent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -343,64 +328,33 @@ public void subcomponentOmitsInheritedBindings() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.parentKeyObjectProvider =",
-            "        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);",
-            "  }",
-            "",
             "  @Override",
             "  public Child child() {",
             "    return new ChildImpl();",
             "  }",
             "",
             "  public static final class Builder {",
-            "    private ParentModule parentModule;",
-            "",
             "    private Builder() {}",
             "",
             "    public Parent build() {",
-            "      if (parentModule == null) {",
-            "        this.parentModule = new ParentModule();",
-            "      }",
             "      return new DaggerParent(this);",
             "    }",
             "",
+            "    @Deprecated",
             "    public Builder parentModule(ParentModule parentModule) {",
-            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+            "      Preconditions.checkNotNull(parentModule);",
             "      return this;",
             "    }",
             "  }",
             "",
             "  private final class ChildImpl implements Child {",
-            "    private Provider<Map<String, Provider<Object>>>",
-            "        mapOfStringAndProviderOfObjectProvider;",
-            "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
-            "",
-            "    private ChildImpl() {",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      this.mapOfStringAndProviderOfObjectProvider =",
-            "          MapProviderFactory.<String, Object>builder(1)",
-            "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
-            "              .build();",
-            "      this.mapOfStringAndObjectProvider = MapFactory.create(",
-            "          mapOfStringAndProviderOfObjectProvider);",
-            "    }",
+            "    private ChildImpl() {}",
             "",
             "    @Override",
             "    public Set<Object> objectSet() {",
             "      return ImmutableSet.<Object>of(Preconditions.checkNotNull(",
             "          ParentModule.parentObject(), " + NPE_FROM_PROVIDES + "));",
             "    }",
-            "",
-            "    @Override",
-            "    public Map<String, Object> objectMap() {",
-            "      return mapOfStringAndObjectProvider.get();",
-            "    }",
             "  }",
             "}");
     Compilation compilation = daggerCompiler().compile(parent, parentModule, child);
diff --git a/javatests/dagger/producers/internal/MapOfProducerProducerTest.java b/javatests/dagger/producers/internal/MapOfProducerProducerTest.java
index fe285ed5c..645a016b5 100644
--- a/javatests/dagger/producers/internal/MapOfProducerProducerTest.java
+++ b/javatests/dagger/producers/internal/MapOfProducerProducerTest.java
@@ -31,7 +31,7 @@
   @Test
   public void success() throws Exception {
     MapOfProducerProducer<Integer, String> mapOfProducerProducer =
-        MapOfProducerProducer.<Integer, String>builder(2)
+        MapOfProducerProducer.<Integer, String>builder()
             .put(15, Producers.<String>immediateProducer("fifteen"))
             .put(42, Producers.<String>immediateProducer("forty two"))
             .build();
@@ -47,7 +47,7 @@ public void success() throws Exception {
   public void failingContributionDoesNotFailMap() throws Exception {
     RuntimeException cause = new RuntimeException("monkey");
     MapOfProducerProducer<Integer, String> mapOfProducerProducer =
-        MapOfProducerProducer.<Integer, String>builder(2)
+        MapOfProducerProducer.<Integer, String>builder()
             .put(15, Producers.<String>immediateProducer("fifteen"))
             .put(42, Producers.<String>immediateFailedProducer(cause))
             .build();
diff --git a/javatests/dagger/producers/internal/MapProducerTest.java b/javatests/dagger/producers/internal/MapProducerTest.java
index 3a8f19ddc..ee7978b7b 100644
--- a/javatests/dagger/producers/internal/MapProducerTest.java
+++ b/javatests/dagger/producers/internal/MapProducerTest.java
@@ -19,7 +19,6 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
-import com.google.common.collect.ImmutableMap;
 import dagger.producers.Producer;
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
@@ -32,13 +31,10 @@
   @Test
   public void success() throws Exception {
     Producer<Map<Integer, String>> mapProducer =
-        MapProducer.create(
-            Producers.<Map<Integer, Producer<String>>>immediateProducer(
-                ImmutableMap.<Integer, Producer<String>>of(
-                    15,
-                    Producers.<String>immediateProducer("fifteen"),
-                    42,
-                    Producers.<String>immediateProducer("forty two"))));
+        MapProducer.<Integer, String>builder()
+            .put(15, Producers.immediateProducer("fifteen"))
+            .put(42, Producers.immediateProducer("forty two"))
+            .build();
     Map<Integer, String> map = mapProducer.get().get();
     assertThat(map).hasSize(2);
     assertThat(map).containsEntry(15, "fifteen");
@@ -49,27 +45,11 @@ public void success() throws Exception {
   public void failingContribution() throws Exception {
     RuntimeException cause = new RuntimeException("monkey");
     Producer<Map<Integer, String>> mapProducer =
-        MapProducer.create(
-            Producers.<Map<Integer, Producer<String>>>immediateProducer(
-                ImmutableMap.<Integer, Producer<String>>of(
-                    15,
-                    Producers.<String>immediateProducer("fifteen"),
-                    42,
-                    Producers.<String>immediateFailedProducer(cause))));
-    try {
-      mapProducer.get().get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isSameAs(cause);
-    }
-  }
-
-  @Test
-  public void failingInput() throws Exception {
-    RuntimeException cause = new RuntimeException("monkey");
-    Producer<Map<Integer, String>> mapProducer =
-        MapProducer.create(
-            Producers.<Map<Integer, Producer<String>>>immediateFailedProducer(cause));
+        MapProducer.<Integer, String>builder()
+            .put(15, Producers.immediateProducer("fifteen"))
+            // TODO(ronshapiro): remove the type parameter when we drop java7 support
+            .put(42, Producers.<String>immediateFailedProducer(cause))
+            .build();
     try {
       mapProducer.get().get();
       fail();
