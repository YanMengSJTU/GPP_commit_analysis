diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 632bf3e78..ec0e38a96 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -136,6 +136,7 @@ java_library(
         "BindingVariableNamer.java",  # needs KeyVariableNamer
         "BindsTypeChecker.java",
         "ChildFactoryMethodEdgeImpl.java",
+        "ComponentCreatorDescriptor.java",
         "ComponentDescriptor.java",
         "ComponentKind.java",
         "ComponentNodeImpl.java",
@@ -187,7 +188,7 @@ java_library(
         "BindsInstanceProcessingStep.java",
         "BindsMethodValidator.java",
         "BindsOptionalOfMethodValidator.java",
-        "BuilderValidator.java",
+        "ComponentCreatorValidator.java",
         "ComponentDescriptorValidator.java",
         "ComponentHierarchyValidator.java",
         "ComponentValidator.java",
@@ -243,7 +244,7 @@ java_library(
         "BindingExpression.java",
         "BindingMethodImplementation.java",
         "ComponentBindingExpressions.java",
-        "ComponentBuilderImplementation.java",
+        "ComponentCreatorImplementation.java",
         "ComponentImplementation.java",
         "ComponentInstanceBindingExpression.java",
         "ComponentMethodBindingExpression.java",
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
index 57891d21c..65bcfb9dc 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -57,7 +57,6 @@
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.SetMultimap;
 import dagger.Module;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import dagger.internal.codegen.ProductionBinding.ProductionKind;
 import dagger.model.DependencyRequest;
@@ -324,14 +323,15 @@ ContributionBinding componentDependencyMethodBinding(
    * Returns a {@link dagger.model.BindingKind#BOUND_INSTANCE} binding for a
    * {@code @BindsInstance}-annotated builder method.
    */
-  ProvisionBinding boundInstanceBinding(BuilderRequirementMethod bindsInstanceMethod) {
-    checkArgument(bindsInstanceMethod.method().getKind().equals(METHOD));
-    checkArgument(bindsInstanceMethod.method().getParameters().size() == 1);
+  ProvisionBinding boundInstanceBinding(
+      ComponentRequirement requirement, ExecutableElement method) {
+    checkArgument(method.getKind().equals(METHOD));
+    checkArgument(method.getParameters().size() == 1);
     return ProvisionBinding.builder()
         .contributionType(ContributionType.UNIQUE)
-        .bindingElement(bindsInstanceMethod.method())
-        .key(bindsInstanceMethod.requirement().key().get())
-        .nullableType(getNullableType(getOnlyElement(bindsInstanceMethod.method().getParameters())))
+        .bindingElement(method)
+        .key(requirement.key().get())
+        .nullableType(getNullableType(getOnlyElement(method.getParameters())))
         .kind(BOUND_INSTANCE)
         .build();
   }
@@ -339,21 +339,21 @@ ProvisionBinding boundInstanceBinding(BuilderRequirementMethod bindsInstanceMeth
   /**
    * Returns a {@link dagger.model.BindingKind#SUBCOMPONENT_BUILDER} binding declared by a component
    * method that returns a subcomponent builder. Use {{@link
-   * #subcomponentBuilderBinding(ImmutableSet)}} for bindings declared using {@link
+   * #subcomponentCreatorBinding(ImmutableSet)}} for bindings declared using {@link
    * Module#subcomponents()}.
    *
    * @param component the component that declares or inherits the method
    */
-  ProvisionBinding subcomponentBuilderBinding(
-      ExecutableElement subcomponentBuilderMethod, TypeElement component) {
-    checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
-    checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
+  ProvisionBinding subcomponentCreatorBinding(
+      ExecutableElement subcomponentCreatorMethod, TypeElement component) {
+    checkArgument(subcomponentCreatorMethod.getKind().equals(METHOD));
+    checkArgument(subcomponentCreatorMethod.getParameters().isEmpty());
     Key key =
-        keyFactory.forSubcomponentBuilderMethod(
-            subcomponentBuilderMethod, asDeclared(component.asType()));
+        keyFactory.forSubcomponentCreatorMethod(
+            subcomponentCreatorMethod, asDeclared(component.asType()));
     return ProvisionBinding.builder()
         .contributionType(ContributionType.UNIQUE)
-        .bindingElement(subcomponentBuilderMethod)
+        .bindingElement(subcomponentCreatorMethod)
         .key(key)
         .kind(SUBCOMPONENT_BUILDER)
         .build();
@@ -363,7 +363,7 @@ ProvisionBinding subcomponentBuilderBinding(
    * Returns a {@link dagger.model.BindingKind#SUBCOMPONENT_BUILDER} binding declared using {@link
    * Module#subcomponents()}.
    */
-  ProvisionBinding subcomponentBuilderBinding(
+  ProvisionBinding subcomponentCreatorBinding(
       ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
     SubcomponentDeclaration subcomponentDeclaration = subcomponentDeclarations.iterator().next();
     return ProvisionBinding.builder()
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 4f1b63f73..26ee0dc83 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
 import static dagger.internal.codegen.DaggerStreams.presentValues;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
@@ -28,7 +27,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.graph.Traverser;
 import dagger.Subcomponent;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.model.Key;
 import dagger.model.RequestKind;
 import java.util.Optional;
@@ -202,16 +200,11 @@ TypeElement componentTypeElement() {
       factoryMethodParameters().keySet().forEach(requirements::add);
     }
     requirements.addAll(componentDescriptor().dependencies());
-    if (componentDescriptor().builderSpec().isPresent()) {
-      componentDescriptor()
-          .builderSpec()
-          .get()
-          .requirementMethods()
-          .stream()
-          .map(BuilderRequirementMethod::requirement)
-          .filter(req -> req.kind().equals(BOUND_INSTANCE))
-          .forEach(requirements::add);
-    }
+    componentDescriptor()
+        .creatorDescriptor()
+        .ifPresent(
+            creatorDescriptor ->
+                creatorDescriptor.boundInstanceRequirements().forEach(requirements::add));
     return requirements.build();
   }
 
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 01f5e2452..4855671a6 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -23,7 +23,6 @@
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.isEmpty;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
-import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
 import static dagger.internal.codegen.SourceFiles.generatedMonitoringModuleName;
@@ -46,7 +45,6 @@
 import com.google.common.collect.Sets;
 import dagger.MembersInjector;
 import dagger.Reusable;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
@@ -130,15 +128,17 @@ private BindingGraph create(
       }
     }
 
-    // Collect bindings on the builder.
-    if (componentDescriptor.builderSpec().isPresent()) {
-      for (BuilderRequirementMethod method :
-          componentDescriptor.builderSpec().get().requirementMethods()) {
-        if (method.requirement().kind().equals(BOUND_INSTANCE)) {
-          explicitBindingsBuilder.add(bindingFactory.boundInstanceBinding(method));
-        }
-      }
-    }
+    // Collect bindings on the creator.
+    componentDescriptor
+        .creatorDescriptor()
+        .ifPresent(
+            creatorDescriptor ->
+                creatorDescriptor.boundInstanceRequirements().stream()
+                    .map(
+                        requirement ->
+                            bindingFactory.boundInstanceBinding(
+                                requirement, creatorDescriptor.elementForRequirement(requirement)))
+                    .forEach(explicitBindingsBuilder::add));
 
     componentDescriptor
         .childComponentsDeclaredByBuilderEntryPoints()
@@ -148,7 +148,7 @@ private BindingGraph create(
                   .childComponentsDeclaredByModules()
                   .contains(childComponent)) {
                 explicitBindingsBuilder.add(
-                    bindingFactory.subcomponentBuilderBinding(
+                    bindingFactory.subcomponentCreatorBinding(
                         builderEntryPoint.methodElement(), componentDescriptor.typeElement()));
               }
             });
@@ -399,11 +399,11 @@ ResolvedBindings lookUpMembersInjectionBinding(Key requestKey) {
      * ComponentDescriptor subcomponent} to a queue in the owning component's resolver. The queue
      * will be used to detect which subcomponents need to be resolved.
      */
-    private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilderBinding) {
-      checkArgument(subcomponentBuilderBinding.kind().equals(SUBCOMPONENT_BUILDER));
-      Resolver owningResolver = getOwningResolver(subcomponentBuilderBinding).get();
+    private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentCreatorBinding) {
+      checkArgument(subcomponentCreatorBinding.kind().equals(SUBCOMPONENT_BUILDER));
+      Resolver owningResolver = getOwningResolver(subcomponentCreatorBinding).get();
 
-      TypeElement builderType = MoreTypes.asTypeElement(subcomponentBuilderBinding.key().type());
+      TypeElement builderType = MoreTypes.asTypeElement(subcomponentCreatorBinding.key().type());
       owningResolver.subcomponentsToResolve.add(
           owningResolver.componentDescriptor.getChildComponentWithBuilderType(builderType));
     }
@@ -448,7 +448,7 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
         ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
       return subcomponentDeclarations.isEmpty()
           ? Optional.empty()
-          : Optional.of(bindingFactory.subcomponentBuilderBinding(subcomponentDeclarations));
+          : Optional.of(bindingFactory.subcomponentCreatorBinding(subcomponentDeclarations));
     }
 
     /**
diff --git a/java/dagger/internal/codegen/ComponentCreatorDescriptor.java b/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
new file mode 100644
index 000000000..cd7c7780e
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asTypeElement;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import dagger.BindsInstance;
+import dagger.model.DependencyRequest;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * A descriptor for a component <i>creator</i> type: that is, a type annotated with
+ * {@code @Component.Builder} (or one of the corresponding production or subcomponent versions).
+ */
+@AutoValue
+abstract class ComponentCreatorDescriptor {
+
+  /** The annotated creator type. */
+  abstract TypeElement typeElement();
+
+  /** The method that creates and returns a component instance. */
+  abstract ExecutableElement factoryMethod();
+
+  /**
+   * Multimap of component requirements to the element that sets that requirements.
+   *
+   * <p>Validation must ensure that no more than one element exists that sets a given requirement.
+   */
+  abstract ImmutableSetMultimap<ComponentRequirement, ExecutableElement> requirementElements();
+
+  /** Returns the set of component requirements for this creator. */
+  final ImmutableSet<ComponentRequirement> requirements() {
+    return requirementElements().keySet();
+  }
+
+  /** Returns the set of requirements for modules and component dependencies for this creator. */
+  final ImmutableSet<ComponentRequirement> moduleAndDependencyRequirements() {
+    return requirements().stream()
+        .filter(requirement -> !requirement.isBoundInstance())
+        .collect(toImmutableSet());
+  }
+
+  /** Returns the set of bound instance requirements for this creator. */
+  final ImmutableSet<ComponentRequirement> boundInstanceRequirements() {
+    return requirements().stream()
+        .filter(requirement -> requirement.isBoundInstance())
+        .collect(toImmutableSet());
+  }
+
+  /** Returns the element in this creator that sets the given {@code requirement}. */
+  final ExecutableElement elementForRequirement(ComponentRequirement requirement) {
+    return getOnlyElement(requirementElements().get(requirement));
+  }
+
+  /** Creates a new {@link ComponentCreatorDescriptor} for the given creator {@code type}. */
+  static ComponentCreatorDescriptor create(
+      DeclaredType type,
+      DaggerElements elements,
+      DaggerTypes types,
+      DependencyRequestFactory dependencyRequestFactory) {
+    TypeElement typeElement = asTypeElement(type);
+    TypeMirror componentType = typeElement.getEnclosingElement().asType();
+
+    ImmutableSetMultimap.Builder<ComponentRequirement, ExecutableElement> requirementElements =
+        ImmutableSetMultimap.builder();
+
+    ExecutableElement factoryMethod = null;
+    for (ExecutableElement method : elements.getUnimplementedMethods(typeElement)) {
+      ExecutableType resolvedMethodType = MoreTypes.asExecutable(types.asMemberOf(type, method));
+
+      if (types.isSubtype(componentType, resolvedMethodType.getReturnType())) {
+        factoryMethod = method;
+      } else {
+        VariableElement parameter = getOnlyElement(method.getParameters());
+        TypeMirror parameterType = getOnlyElement(resolvedMethodType.getParameterTypes());
+        requirementElements.put(
+            requirement(method, parameter, parameterType, dependencyRequestFactory), method);
+      }
+    }
+    verify(factoryMethod != null); // validation should have ensured this.
+
+    return new AutoValue_ComponentCreatorDescriptor(
+        typeElement, factoryMethod, requirementElements.build());
+  }
+
+  private static ComponentRequirement requirement(
+      ExecutableElement method,
+      VariableElement parameter,
+      TypeMirror type,
+      DependencyRequestFactory dependencyRequestFactory) {
+    if (isAnnotationPresent(method, BindsInstance.class)) {
+      DependencyRequest request =
+          dependencyRequestFactory.forRequiredResolvedVariable(parameter, type);
+      return ComponentRequirement.forBoundInstance(
+          request.key(), request.isNullable(), method.getSimpleName().toString());
+    }
+
+    return ConfigurationAnnotations.getModuleAnnotation(asTypeElement(type)).isPresent()
+        ? ComponentRequirement.forModule(type)
+        : ComponentRequirement.forDependency(type);
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentBuilderImplementation.java b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
similarity index 72%
rename from java/dagger/internal/codegen/ComponentBuilderImplementation.java
rename to java/dagger/internal/codegen/ComponentCreatorImplementation.java
index ea5f18d42..74badf8fb 100644
--- a/java/dagger/internal/codegen/ComponentBuilderImplementation.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
@@ -31,7 +32,6 @@
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -40,8 +40,6 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.Preconditions;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
-import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import java.util.Optional;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -50,23 +48,23 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-/** The implementation of a component builder type. */
-final class ComponentBuilderImplementation {
-  private final TypeSpec componentBuilderClass;
+/** The implementation of a component creator type. */
+final class ComponentCreatorImplementation {
+  private final TypeSpec componentCreatorClass;
   private final ClassName name;
   private final ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
 
-  private ComponentBuilderImplementation(
-      TypeSpec componentBuilderClass,
+  private ComponentCreatorImplementation(
+      TypeSpec componentCreatorClass,
       ClassName name,
       ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
-    this.componentBuilderClass = componentBuilderClass;
+    this.componentCreatorClass = componentCreatorClass;
     this.name = name;
     this.builderFields = builderFields;
   }
 
-  TypeSpec componentBuilderClass() {
-    return componentBuilderClass;
+  TypeSpec componentCreatorClass() {
+    return componentCreatorClass;
   }
 
   ClassName name() {
@@ -77,7 +75,7 @@ ClassName name() {
     return builderFields;
   }
 
-  static Optional<ComponentBuilderImplementation> create(
+  static Optional<ComponentCreatorImplementation> create(
       ComponentImplementation componentImplementation,
       BindingGraph graph,
       Elements elements,
@@ -91,50 +89,58 @@ ClassName name() {
       // to the builder, can ignore generating a builder implementation.
       return Optional.empty();
     }
-    return graph.componentDescriptor().hasBuilder()
-        ? Optional.of(new Creator(componentImplementation, graph, elements, types).create())
+    return graph.componentDescriptor().hasCreator()
+        ? Optional.of(
+            new CreatorImplementationFactory(componentImplementation, graph, elements, types)
+                .create())
         : Optional.empty();
   }
 
-  private static final class Creator {
+  /** Factory for creating a {@link ComponentCreatorImplementation} instance. */
+  private static final class CreatorImplementationFactory {
+    // TODO(cgdecker): Possibly extract this to another top-level type,
+    // ComponentCreatorImplementationFactory, to match the separation between
+    // ComponentImplementation and ComponentImplementationFactory
+
     static final String NOOP_BUILDER_METHOD_JAVADOC =
         "This module is declared, but an instance is not used in the component. This method is a "
             + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
+
     final BindingGraph graph;
-    final TypeSpec.Builder componentBuilderClass;
+    final TypeSpec.Builder componentCreatorClass;
     final ComponentImplementation componentImplementation;
     final Elements elements;
     final Types types;
 
-    Creator(
+    CreatorImplementationFactory(
         ComponentImplementation componentImplementation,
         BindingGraph graph,
         Elements elements,
         Types types) {
       this.componentImplementation = componentImplementation;
-      this.componentBuilderClass = classBuilder(componentImplementation.getBuilderName());
+      this.componentCreatorClass = classBuilder(componentImplementation.getCreatorName());
       this.graph = graph;
       this.elements = elements;
       this.types = types;
     }
 
-    ComponentBuilderImplementation create() {
+    ComponentCreatorImplementation create() {
       if (!componentImplementation.isNested()) {
-        componentBuilderClass.addModifiers(STATIC);
+        componentCreatorClass.addModifiers(STATIC);
       }
-      if (builderSpec().isPresent()) {
+      if (creatorDescriptor().isPresent()) {
         if (componentImplementation.isAbstract()) {
-          // The component builder class of a top-level component implementation in ahead-of-tim
-          // subcomponents mode must be public, not protected, because the builder's subclass will
+          // The component creator class of a top-level component implementation in ahead-of-time
+          // subcomponents mode must be public, not protected, because the creator's subclass will
           // be a sibling of the component subclass implementation, not nested.
-          componentBuilderClass.addModifiers(
+          componentCreatorClass.addModifiers(
               componentImplementation.isNested() ? PROTECTED : PUBLIC);
         } else {
-          componentBuilderClass.addModifiers(PRIVATE);
+          componentCreatorClass.addModifiers(PRIVATE);
         }
         setSupertype();
       } else {
-        componentBuilderClass
+        componentCreatorClass
             .addModifiers(PUBLIC)
             .addMethod(constructorBuilder().addModifiers(PRIVATE).build());
       }
@@ -142,40 +148,40 @@ ComponentBuilderImplementation create() {
       ImmutableMap<ComponentRequirement, FieldSpec> builderFields = builderFields();
 
       if (componentImplementation.isAbstract()) {
-        componentBuilderClass.addModifiers(ABSTRACT);
+        componentCreatorClass.addModifiers(ABSTRACT);
       } else {
-        componentBuilderClass.addModifiers(FINAL);
-        componentBuilderClass.addMethod(buildMethod(builderFields));
+        componentCreatorClass.addModifiers(FINAL);
+        componentCreatorClass.addMethod(factoryMethod(builderFields));
       }
 
       if (!componentImplementation.baseImplementation().isPresent()) {
-        componentBuilderClass.addFields(builderFields.values());
+        componentCreatorClass.addFields(builderFields.values());
       }
 
-      // TODO(ronshapiro): this should be switched with buildMethod(), but that currently breaks
+      // TODO(ronshapiro): this should be switched with factoryMethod(), but that currently breaks
       // compile-testing tests that rely on the order of the methods
-      componentBuilderClass.addMethods(builderMethods(builderFields));
+      componentCreatorClass.addMethods(builderMethods(builderFields));
 
-      return new ComponentBuilderImplementation(
-          componentBuilderClass.build(), componentImplementation.getBuilderName(), builderFields);
+      return new ComponentCreatorImplementation(
+          componentCreatorClass.build(), componentImplementation.getCreatorName(), builderFields);
     }
 
-    /** Set the superclass being extended or interface being implemented for this builder. */
+    /** Set the superclass being extended or interface being implemented for this creator. */
     void setSupertype() {
       if (componentImplementation.baseImplementation().isPresent()) {
-        // If there's a superclass, extend the Builder defined there.
-        componentBuilderClass.superclass(
-            componentImplementation.baseImplementation().get().getBuilderName());
+        // If there's a superclass, extend the creator defined there.
+        componentCreatorClass.superclass(
+            componentImplementation.baseImplementation().get().getCreatorName());
       } else {
-        addSupertype(componentBuilderClass, builderSpec().get().builderDefinitionType());
+        addSupertype(componentCreatorClass, creatorDescriptor().get().typeElement());
       }
     }
 
     /**
-     * Computes fields for each of the {@link ComponentRequirement}s}. Regardless of builder spec,
+     * Computes fields for each of the {@link ComponentRequirement}s}. Regardless of creator spec,
      * there is always one field per requirement.
      *
-     * <p>If the base implementation's builder is being generated in ahead-of-time-subcomponents
+     * <p>If the base implementation's creator is being generated in ahead-of-time-subcomponents
      * mode, this uses {@link BindingGraph#possiblyNecessaryRequirements()} since Dagger doesn't
      * know what modules may end up being unused. Otherwise, we use the {@link
      * BindingGraph#componentRequirements() necessary component requirements}.
@@ -193,25 +199,26 @@ void setSupertype() {
       return builderFields.build();
     }
 
-    MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
-      MethodSpec.Builder buildMethod;
-      if (builderSpec().isPresent()) {
-        ExecutableElement specBuildMethod = builderSpec().get().buildMethod();
-        // Note: we don't use the specBuildMethod.getReturnType() as the return type
+    MethodSpec factoryMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
+      MethodSpec.Builder factoryMethod;
+      if (creatorDescriptor().isPresent()) {
+        ExecutableElement factoryMethodElement = creatorDescriptor().get().factoryMethod();
+        // Note: we don't use the factoryMethodElement.getReturnType() as the return type
         // because it might be a type variable.  We make use of covariant returns to allow
         // us to return the component type, which will always be valid.
-        buildMethod =
-            methodBuilder(specBuildMethod.getSimpleName().toString()).addAnnotation(Override.class);
+        factoryMethod =
+            methodBuilder(factoryMethodElement.getSimpleName().toString())
+                .addAnnotation(Override.class);
       } else {
-        buildMethod = methodBuilder("build");
+        factoryMethod = methodBuilder("build");
       }
-      buildMethod.returns(ClassName.get(graph.componentTypeElement())).addModifiers(PUBLIC);
+      factoryMethod.returns(ClassName.get(graph.componentTypeElement())).addModifiers(PUBLIC);
 
       builderFields.forEach(
           (requirement, field) -> {
             switch (requirement.nullPolicy(elements, types)) {
               case NEW:
-                buildMethod
+                factoryMethod
                     .beginControlFlow("if ($N == null)", field)
                     .addStatement("this.$N = new $T()", field, field.type)
                     .endControlFlow();
@@ -219,7 +226,7 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
               case THROW:
                 // TODO(cgdecker,ronshapiro): ideally this should use the key instead of a class for
                 // @BindsInstance requirements, but that's not easily proguardable.
-                buildMethod.addStatement(
+                factoryMethod.addStatement(
                     "$T.checkBuilderRequirement($N, $T.class)",
                     Preconditions.class,
                     field,
@@ -231,13 +238,13 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
                 throw new AssertionError(requirement);
             }
           });
-      buildMethod.addStatement("return new $T(this)", componentImplementation.name());
-      return buildMethod.build();
+      factoryMethod.addStatement("return new $T(this)", componentImplementation.name());
+      return factoryMethod.build();
     }
 
     /**
-     * Computes the methods that set each of parameters on the builder. If the {@link BuilderSpec}
-     * is present, it will tailor the methods to match the spec.
+     * Computes the methods that set each of parameters on the builder. If the {@link
+     * ComponentCreatorDescriptor} is present, it will tailor the methods to match the descriptor.
      */
     ImmutableSet<MethodSpec> builderMethods(
         ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
@@ -245,24 +252,23 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
       ImmutableSet.Builder<MethodSpec> methods = ImmutableSet.builder();
       // TODO(ronshapiro): extract two separate methods: builderMethodsForBuilderSpec and
       // builderMethodsForGeneratedTopLevelComponentBuilder()
-      if (builderSpec().isPresent()) {
+      if (creatorDescriptor().isPresent()) {
         // In ahead-of-time subcomponents mode, all builder methods are defined at the base
         // implementation. The only case where a method needs to be overridden is for a repeated
         // module, which is unknown at the point when a base implementation is generated. We do this
         // at the root for simplicity (and as an aside, repeated modules are never used in google
         // as of 11/28/18, and thus the additional cost of including these methods at the root is
         // negligible).
-        boolean hasBaseBuilderImplementation =
+        boolean hasBaseCreatorImplementation =
             !componentImplementation.isAbstract()
                 && componentImplementation.baseImplementation().isPresent();
 
         UniqueNameSet parameterNames = new UniqueNameSet();
-        for (BuilderRequirementMethod requirementMethod :
-            builderSpec().get().requirementMethods()) {
-          ComponentRequirement builderRequirement = requirementMethod.requirement();
-          ExecutableElement specMethod = requirementMethod.method();
-          MethodSpec.Builder builderMethod = addBuilderMethodFromSpec(specMethod);
-          VariableElement parameterElement = Iterables.getOnlyElement(specMethod.getParameters());
+        ComponentCreatorDescriptor creatorDescriptor = creatorDescriptor().get();
+        for (ComponentRequirement requirement : creatorDescriptor.requirements()) {
+          ExecutableElement method = creatorDescriptor.elementForRequirement(requirement);
+          MethodSpec.Builder builderMethod = addBuilderMethodFromSpec(method);
+          VariableElement parameterElement = getOnlyElement(method.getParameters());
           String parameterName = parameterNames.getUniqueName(parameterElement.getSimpleName());
 
           TypeName argType =
@@ -270,31 +276,31 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
                   // Primitives need to use the original (unresolved) type to avoid boxing.
                   ? TypeName.get(parameterElement.asType())
                   // Otherwise we use the full resolved type.
-                  : TypeName.get(builderRequirement.type());
+                  : TypeName.get(requirement.type());
 
           builderMethod.addParameter(argType, parameterName);
 
-          if (componentRequirements.contains(builderRequirement)) {
-            if (hasBaseBuilderImplementation) {
+          if (componentRequirements.contains(requirement)) {
+            if (hasBaseCreatorImplementation) {
               continue;
             }
             // required type
             builderMethod.addStatement(
                 "this.$N = $L",
-                builderFields.get(builderRequirement),
-                builderRequirement
+                builderFields.get(requirement),
+                requirement
                         .nullPolicy(elements, types)
                         .equals(ComponentRequirement.NullPolicy.ALLOW)
                     ? parameterName
                     : CodeBlock.of("$T.checkNotNull($L)", Preconditions.class, parameterName));
-            addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
-          } else if (graph.ownedModuleTypes().contains(builderRequirement.typeElement())) {
-            if (hasBaseBuilderImplementation) {
+            addBuilderMethodReturnStatementForSpec(method, builderMethod);
+          } else if (graph.ownedModuleTypes().contains(requirement.typeElement())) {
+            if (hasBaseCreatorImplementation) {
               continue;
             }
             // owned, but not required
             builderMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);
-            addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
+            addBuilderMethodReturnStatementForSpec(method, builderMethod);
           } else {
             // neither owned nor required, so it must be an inherited module
             builderMethod.addStatement(
@@ -302,7 +308,7 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
                 UnsupportedOperationException.class,
                 String.class,
                 "%s cannot be set because it is inherited from the enclosing component",
-                TypeNames.rawTypeName(TypeName.get(builderRequirement.type())));
+                TypeNames.rawTypeName(TypeName.get(requirement.type())));
           }
 
           methods.add(builderMethod.build());
@@ -313,7 +319,7 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
           String componentRequirementName = simpleVariableName(requirement.typeElement());
           MethodSpec.Builder builderMethod =
               methodBuilder(componentRequirementName)
-                  .returns(componentImplementation.getBuilderName())
+                  .returns(componentImplementation.getCreatorName())
                   .addModifiers(PUBLIC)
                   .addParameter(TypeName.get(requirement.type()), componentRequirementName);
           if (componentRequirements.contains(requirement)) {
@@ -352,7 +358,7 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
       // Otherwise we use the generated builder name and take advantage of covariant returns
       // (so that we don't have to worry about setter methods that return type variables).
       if (!returnType.getKind().equals(VOID)) {
-        builderMethod.returns(componentImplementation.getBuilderName());
+        builderMethod.returns(componentImplementation.getCreatorName());
       }
       return builderMethod;
     }
@@ -364,8 +370,8 @@ static void addBuilderMethodReturnStatementForSpec(
       }
     }
 
-    Optional<BuilderSpec> builderSpec() {
-      return graph.componentDescriptor().builderSpec();
+    Optional<ComponentCreatorDescriptor> creatorDescriptor() {
+      return graph.componentDescriptor().creatorDescriptor();
     }
   }
 }
diff --git a/java/dagger/internal/codegen/BuilderValidator.java b/java/dagger/internal/codegen/ComponentCreatorValidator.java
similarity index 92%
rename from java/dagger/internal/codegen/BuilderValidator.java
rename to java/dagger/internal/codegen/ComponentCreatorValidator.java
index f4691846e..d939c9fd7 100644
--- a/java/dagger/internal/codegen/BuilderValidator.java
+++ b/java/dagger/internal/codegen/ComponentCreatorValidator.java
@@ -29,7 +29,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import dagger.BindsInstance;
-import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
+import dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
@@ -44,16 +44,14 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Types;
 
-/**
- * Validates {@link dagger.Component.Builder} annotations.
- */
-class BuilderValidator {
+/** Validates {@link dagger.Component.Builder} annotations. */
+class ComponentCreatorValidator {
 
   private final DaggerElements elements;
   private final Types types;
 
   @Inject
-  BuilderValidator(DaggerElements elements, Types types) {
+  ComponentCreatorValidator(DaggerElements elements, Types types) {
     this.elements = elements;
     this.types = types;
   }
@@ -64,7 +62,7 @@
     ComponentKind componentKind = ComponentKind.forAnnotatedBuilderElement(subject).get();
 
     Element componentElement = subject.getEnclosingElement();
-    ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentKind);
+    ErrorMessages.ComponentCreatorMessages msgs = ErrorMessages.creatorMessagesFor(componentKind);
     checkArgument(isAnnotationPresent(subject, componentKind.builderAnnotation().get()));
 
     if (!isAnnotationPresent(componentElement, componentKind.annotation())) {
@@ -103,7 +101,7 @@
       builder.addError(msgs.mustBeAbstract(), subject);
     }
 
-    ExecutableElement buildMethod = null;
+    ExecutableElement factoryMethod = null;
     for (ExecutableElement method : elements.getUnimplementedMethods(subject)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
@@ -111,21 +109,21 @@
       switch (method.getParameters().size()) {
         case 0: // If this is potentially a build() method, validate it returns the correct type.
           if (types.isSubtype(componentElement.asType(), returnType)) {
-            validateBuildMethodReturnType(
+            validateFactoryMethodReturnType(
                 builder,
                 // since types.isSubtype() passed, componentElement cannot be a PackageElement
                 MoreElements.asType(componentElement),
                 msgs,
                 method,
                 returnType);
-            if (buildMethod != null) {
+            if (factoryMethod != null) {
               // If we found more than one build-like method, fail.
               error(
                   builder,
                   method,
                   msgs.twoBuildMethods(),
                   msgs.inheritedTwoBuildMethods(),
-                  buildMethod);
+                  factoryMethod);
             }
           } else {
             error(
@@ -134,8 +132,8 @@
                 msgs.buildMustReturnComponentType(),
                 msgs.inheritedBuildMustReturnComponentType());
           }
-          // We set the buildMethod regardless of the return type to reduce error spam.
-          buildMethod = method;
+          // We set the factoryMethod regardless of the return type to reduce error spam.
+          factoryMethod = method;
           break;
 
         case 1: // If this correctly had one parameter, make sure the return types are valid.
@@ -171,7 +169,7 @@
       }
     }
 
-    if (buildMethod == null) {
+    if (factoryMethod == null) {
       builder.addError(msgs.missingBuildMethod(), subject);
     }
 
@@ -182,10 +180,10 @@
     return builder.build();
   }
 
-  private void validateBuildMethodReturnType(
+  private void validateFactoryMethodReturnType(
       ValidationReport.Builder<TypeElement> builder,
       TypeElement componentElement,
-      ComponentBuilderMessages msgs,
+      ComponentCreatorMessages msgs,
       ExecutableElement method,
       TypeMirror returnType) {
     if (types.isSameType(componentElement.asType(), returnType)) {
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 4c82c1208..9d405e377 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -17,17 +17,15 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.auto.common.MoreTypes.asTypeElement;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
+import static dagger.internal.codegen.ConfigurationAnnotations.enclosedAnnotatedTypes;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;
-import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
+import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentCreator;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerStreams.toImmutableMap;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
@@ -49,7 +47,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import dagger.BindsInstance;
 import dagger.Component;
 import dagger.Lazy;
 import dagger.Module;
@@ -71,7 +68,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /**
  * A component declaration.
@@ -191,10 +187,10 @@ final ComponentRequirement getDependencyThatDefinesMethod(Element method) {
           Suppliers.memoize(
               () ->
                   childComponents().stream()
-                      .filter(child -> child.builderSpec().isPresent())
+                      .filter(child -> child.creatorDescriptor().isPresent())
                       .collect(
                           toImmutableMap(
-                              child -> child.builderSpec().get().builderDefinitionType(),
+                              child -> child.creatorDescriptor().get().typeElement(),
                               child -> child)));
 
   /** Returns the child component with the given builder type. */
@@ -269,14 +265,16 @@ private static boolean doesComponentMethodMatch(
 
   // TODO(gak): Consider making this non-optional and revising the
   // interaction between the spec & generation
-  abstract Optional<BuilderSpec> builderSpec();
+  /** Returns a descriptor for the creator type for this component type, if the user defined one. */
+  abstract Optional<ComponentCreatorDescriptor> creatorDescriptor();
 
   /**
-   * Returns {@code true} for components that have a builder, either because the user {@linkplain
-   * #builderSpec() specified one} or because it's a top-level component.
+   * Returns {@code true} for components that have a creator, either because the user {@linkplain
+   * #creatorDescriptor() specified one} or because it's a top-level component with an implicit
+   * builder.
    */
-  final boolean hasBuilder() {
-    return kind().isTopLevel() || builderSpec().isPresent();
+  final boolean hasCreator() {
+    return kind().isTopLevel() || creatorDescriptor().isPresent();
   }
 
   /**
@@ -320,7 +318,7 @@ static ComponentMethodDescriptor forSubcomponent(
       return create(kind, Optional.empty(), methodElement);
     }
 
-    static ComponentMethodDescriptor forSubcomponentBuilder(
+    static ComponentMethodDescriptor forSubcomponentCreator(
         ComponentMethodKind kind,
         DependencyRequest dependencyRequestForBuilder,
         ExecutableElement methodElement) {
@@ -353,10 +351,6 @@ TypeMirror resolvedReturnType(DaggerTypes types) {
     PRODUCTION_SUBCOMPONENT,
     PRODUCTION_SUBCOMPONENT_BUILDER;
 
-    boolean isSubcomponentKind() {
-      return this == SUBCOMPONENT || this == PRODUCTION_SUBCOMPONENT;
-    }
-
     /**
      * Returns the component kind associated with this component method, if it exists. Otherwise,
      * throws.
@@ -375,23 +369,9 @@ ComponentKind componentKind() {
     }
   }
 
-  @AutoValue
-  abstract static class BuilderRequirementMethod {
-    abstract ExecutableElement method();
-
-    abstract ComponentRequirement requirement();
-  }
-
-  @AutoValue
-  abstract static class BuilderSpec {
-    abstract TypeElement builderDefinitionType();
-    abstract ImmutableSet<BuilderRequirementMethod> requirementMethods();
-    abstract ExecutableElement buildMethod();
-  }
-
   static final class Factory {
     private final DaggerElements elements;
-    private final Types types;
+    private final DaggerTypes types;
     private final DependencyRequestFactory dependencyRequestFactory;
     private final ModuleDescriptor.Factory moduleDescriptorFactory;
     private final CompilerOptions compilerOptions;
@@ -399,7 +379,7 @@ ComponentKind componentKind() {
     @Inject
     Factory(
         DaggerElements elements,
-        Types types,
+        DaggerTypes types,
         DependencyRequestFactory dependencyRequestFactory,
         ModuleDescriptor.Factory moduleDescriptorFactory,
         CompilerOptions compilerOptions) {
@@ -512,13 +492,16 @@ private ComponentDescriptor create(TypeElement typeElement, ComponentKind kind)
         }
       }
 
-      ImmutableList<DeclaredType> enclosedBuilders =
+      ImmutableList<DeclaredType> enclosedCreators =
           kind.builderAnnotation()
-              .map(builderAnnotation -> enclosedBuilders(typeElement, builderAnnotation))
+              .map(builderAnnotation -> enclosedAnnotatedTypes(typeElement, builderAnnotation))
               .orElse(ImmutableList.of());
-      Optional<DeclaredType> builderType =
-          Optional.ofNullable(getOnlyElement(enclosedBuilders, null));
-      Optional<BuilderSpec> builderSpec = createBuilderSpec(builderType);
+      Optional<ComponentCreatorDescriptor> creatorDescriptor =
+          enclosedCreators.isEmpty()
+              ? Optional.empty()
+              : Optional.of(
+                  ComponentCreatorDescriptor.create(
+                      getOnlyElement(enclosedCreators), elements, types, dependencyRequestFactory));
 
       ImmutableSet<Scope> scopes = scopesOf(typeElement);
       if (kind.isProducer()) {
@@ -538,7 +521,7 @@ private ComponentDescriptor create(TypeElement typeElement, ComponentKind kind)
           subcomponentsByFactoryMethod.build(),
           subcomponentsByBuilderMethod.build(),
           componentMethodsBuilder.build(),
-          builderSpec);
+          creatorDescriptor);
     }
 
     private ComponentMethodDescriptor getDescriptorForComponentMethod(
@@ -564,11 +547,11 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
                     ? ComponentMethodKind.SUBCOMPONENT
                     : ComponentMethodKind.PRODUCTION_SUBCOMPONENT,
                 componentMethod);
-          } else if (isSubcomponentBuilder(returnTypeElement)) {
+          } else if (isSubcomponentCreator(returnTypeElement)) {
             DependencyRequest dependencyRequest =
                 dependencyRequestFactory.forComponentProvisionMethod(
                     componentMethod, resolvedComponentMethod);
-            return ComponentMethodDescriptor.forSubcomponentBuilder(
+            return ComponentMethodDescriptor.forSubcomponentCreator(
                 isAnnotationPresent(returnTypeElement, Subcomponent.Builder.class)
                     ? ComponentMethodKind.SUBCOMPONENT_BUILDER
                     : ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER,
@@ -611,49 +594,6 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
 
       throw new IllegalArgumentException("not a valid component method: " + componentMethod);
     }
-
-    private Optional<BuilderSpec> createBuilderSpec(Optional<DeclaredType> builderType) {
-      if (!builderType.isPresent()) {
-        return Optional.empty();
-      }
-      TypeElement element = asTypeElement(builderType.get());
-      ImmutableSet<ExecutableElement> methods = elements.getUnimplementedMethods(element);
-      ImmutableSet.Builder<BuilderRequirementMethod> requirementMethods = ImmutableSet.builder();
-      ExecutableElement buildMethod = null;
-      for (ExecutableElement method : methods) {
-        if (method.getParameters().isEmpty()) {
-          buildMethod = method;
-        } else {
-          ExecutableType resolved =
-              MoreTypes.asExecutable(types.asMemberOf(builderType.get(), method));
-          requirementMethods.add(
-              new AutoValue_ComponentDescriptor_BuilderRequirementMethod(
-                  method, requirementForBuilderMethod(method, resolved)));
-        }
-      }
-      verify(buildMethod != null); // validation should have ensured this.
-      return Optional.of(
-          new AutoValue_ComponentDescriptor_BuilderSpec(
-              element, requirementMethods.build(), buildMethod));
-    }
-
-    private ComponentRequirement requirementForBuilderMethod(
-        ExecutableElement method, ExecutableType resolvedType) {
-      checkArgument(method.getParameters().size() == 1);
-      if (isAnnotationPresent(method, BindsInstance.class)) {
-        DependencyRequest request =
-            dependencyRequestFactory.forRequiredResolvedVariable(
-                getOnlyElement(method.getParameters()),
-                getOnlyElement(resolvedType.getParameterTypes()));
-        return ComponentRequirement.forBoundInstance(
-            request.key(), request.isNullable(), method.getSimpleName().toString());
-      }
-
-      TypeMirror type = getOnlyElement(resolvedType.getParameterTypes());
-      return ConfigurationAnnotations.getModuleAnnotation(asTypeElement(type)).isPresent()
-          ? ComponentRequirement.forModule(type)
-          : ComponentRequirement.forDependency(type);
-    }
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentDescriptorValidator.java b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
index d8ce67961..780c21d2f 100644
--- a/java/dagger/internal/codegen/ComponentDescriptorValidator.java
+++ b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
@@ -16,39 +16,40 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Predicates.in;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSetMultimap;
 import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.internal.codegen.Scopes.getReadableSource;
 import static dagger.internal.codegen.Scopes.scopesOf;
 import static dagger.internal.codegen.Scopes.singletonScope;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
-import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.joining;
-import static java.util.stream.Collectors.mapping;
 import static java.util.stream.Collectors.toList;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
+import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
-import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentRequirement.NullPolicy;
-import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
+import dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages;
 import dagger.model.Scope;
 import java.util.ArrayDeque;
+import java.util.Collection;
 import java.util.Deque;
 import java.util.LinkedHashMap;
-import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
@@ -127,7 +128,7 @@ void visitComponent(ComponentDescriptor component) {
       validateDependencyScopes(component);
       validateComponentDependencyHierarchy(component);
       validateModules(component);
-      validateBuilders(component);
+      validateCreators(component);
       component.childComponents().forEach(this::visitComponent);
     }
 
@@ -217,10 +218,7 @@ private void validateDependencyScopes(ComponentDescriptor component) {
           // Dagger 1.x scope compatibility requires this be suppress-able.
           if (!compilerOptions.scopeCycleValidationType().equals(ValidationType.NONE)) {
             validateDependencyScopeHierarchy(
-                component,
-                component.typeElement(),
-                new ArrayDeque<ImmutableSet<Scope>>(),
-                new ArrayDeque<TypeElement>());
+                component, component.typeElement(), new ArrayDeque<>(), new ArrayDeque<>());
           }
         }
       } else {
@@ -267,79 +265,84 @@ private String abstractModuleHasInstanceBindingMethodsError(ModuleDescriptor mod
           module.moduleElement(), methodAnnotations);
     }
 
-    private void validateBuilders(ComponentDescriptor component) {
-      ComponentDescriptor componentDesc = component;
-      if (!componentDesc.builderSpec().isPresent()) {
+    private void validateCreators(ComponentDescriptor component) {
+      if (!component.creatorDescriptor().isPresent()) {
         // If no builder, nothing to validate.
         return;
       }
 
-      Set<ComponentRequirement> requirements = component.dependenciesAndConcreteModules();
-      final BuilderSpec spec = componentDesc.builderSpec().get();
-      ImmutableSet<BuilderRequirementMethod> declaredSetters =
-          spec.requirementMethods()
-              .stream()
-              .filter(method -> !method.requirement().kind().equals(BOUND_INSTANCE))
-              .collect(toImmutableSet());
-      ImmutableSet<ComponentRequirement> declaredRequirements =
-          declaredSetters
-              .stream()
-              .map(BuilderRequirementMethod::requirement)
-              .collect(toImmutableSet());
-
-      ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(component.kind());
-      Set<ComponentRequirement> extraSetters = Sets.difference(declaredRequirements, requirements);
-      if (!extraSetters.isEmpty()) {
-        List<ExecutableElement> excessMethods =
-            declaredSetters
-                .stream()
-                .filter(method -> extraSetters.contains(method.requirement()))
-                .map(BuilderRequirementMethod::method)
-                .collect(toList());
-        Optional<DeclaredType> container =
-            Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType()));
+      ComponentCreatorDescriptor creator = component.creatorDescriptor().get();
+      ComponentCreatorMessages msgs = ErrorMessages.creatorMessagesFor(component.kind());
+
+      // Requirements for modules and dependencies that the creator can set
+      Set<ComponentRequirement> creatorModuleAndDependencyRequirements =
+          creator.moduleAndDependencyRequirements();
+      // Modules and dependencies the component requires
+      Set<ComponentRequirement> componentModuleAndDependencyRequirements =
+          component.dependenciesAndConcreteModules();
+
+      // Requirements that the creator can set that don't match any requirements that the component
+      // actually has.
+      Set<ComponentRequirement> inapplicableRequirementsOnCreator =
+          Sets.difference(
+              creatorModuleAndDependencyRequirements, componentModuleAndDependencyRequirements);
+
+      if (!inapplicableRequirementsOnCreator.isEmpty()) {
+        Collection<ExecutableElement> excessElements =
+            Multimaps.filterKeys(
+                    creator.requirementElements(), in(inapplicableRequirementsOnCreator))
+                .values();
+        Optional<DeclaredType> container = Optional.of(asDeclared(creator.typeElement().asType()));
         String formatted =
-            excessMethods
-                .stream()
+            excessElements.stream()
                 .map(method -> methodSignatureFormatter.format(method, container))
                 .collect(joining(", ", "[", "]"));
         report(component)
-            .addError(String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
+            .addError(String.format(msgs.extraSetters(), formatted), creator.typeElement());
       }
 
+      // Component requirements that the creator must be able to set
       Set<ComponentRequirement> mustBePassed =
           Sets.filter(
-              requirements, input -> input.nullPolicy(elements, types).equals(NullPolicy.THROW));
-      Set<ComponentRequirement> missingSetters =
-          Sets.difference(mustBePassed, declaredRequirements);
-      if (!missingSetters.isEmpty()) {
+              componentModuleAndDependencyRequirements,
+              input -> input.nullPolicy(elements, types).equals(NullPolicy.THROW));
+      // Component requirements that the creator must be able to set, but can't
+      Set<ComponentRequirement> missingRequirements =
+          Sets.difference(mustBePassed, creatorModuleAndDependencyRequirements);
+
+      if (!missingRequirements.isEmpty()) {
         report(component)
             .addError(
                 String.format(
                     msgs.missingSetters(),
-                    missingSetters.stream().map(ComponentRequirement::type).collect(toList())),
-                spec.builderDefinitionType());
+                    missingRequirements.stream().map(ComponentRequirement::type).collect(toList())),
+                creator.typeElement());
       }
 
       // Validate that declared builder requirements (modules, dependencies) have unique types.
-      Map<Equivalence.Wrapper<TypeMirror>, List<ExecutableElement>> declaredRequirementsByType =
-          spec.requirementMethods()
+      ImmutableSetMultimap<Wrapper<TypeMirror>, ExecutableElement> declaredRequirementsByType =
+          Multimaps.filterKeys(
+                  creator.requirementElements(), in(creatorModuleAndDependencyRequirements))
+              .entries()
               .stream()
-              .filter(method -> !method.requirement().kind().equals(BOUND_INSTANCE))
               .collect(
-                  groupingBy(
-                      method -> method.requirement().wrappedType(),
-                      mapping(method -> method.method(), toList())));
-      for (Map.Entry<Equivalence.Wrapper<TypeMirror>, List<ExecutableElement>> entry :
-          declaredRequirementsByType.entrySet()) {
-        if (entry.getValue().size() > 1) {
-          TypeMirror type = entry.getKey().get();
-          report(component)
-              .addError(
-                  String.format(msgs.manyMethodsForType(), type, entry.getValue()),
-                  spec.builderDefinitionType());
-        }
-      }
+                  toImmutableSetMultimap(entry -> entry.getKey().wrappedType(), Entry::getValue));
+      declaredRequirementsByType
+          .asMap()
+          .forEach(
+              (typeWrapper, elementsForType) -> {
+                if (elementsForType.size() > 1) {
+                  TypeMirror type = typeWrapper.get();
+                  report(component)
+                      .addError(
+                          String.format(msgs.manyMethodsForType(), type, elementsForType),
+                          creator.typeElement());
+                }
+              });
+
+      // TODO(cgdecker): Duplicate binding validation should handle the case of multiple elements
+      // that set the same bound-instance Key, but validating that here would make it fail faster
+      // for subcomponents.
     }
 
     /**
diff --git a/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index a502e451f..22c657e91 100644
--- a/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -69,7 +69,7 @@ private void validateSubcomponentMethods(
         .childComponentsDeclaredByFactoryMethods()
         .forEach(
             (method, childComponent) -> {
-              if (childComponent.hasBuilder()) {
+              if (childComponent.hasCreator()) {
                 report.addError(
                     "Components may not have factory methods for subcomponents that define a "
                         + "builder.",
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index b425a6933..5e8566d39 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -146,9 +146,9 @@ Element originatingElement(ComponentDescriptor input) {
       addSupertype(generatedComponent, componentElement);
 
       TypeName builderMethodReturnType;
-      if (componentDescriptor.builderSpec().isPresent()) {
+      if (componentDescriptor.creatorDescriptor().isPresent()) {
         builderMethodReturnType =
-            ClassName.get(componentDescriptor.builderSpec().get().builderDefinitionType());
+            ClassName.get(componentDescriptor.creatorDescriptor().get().typeElement());
       } else {
         TypeSpec.Builder builder =
             TypeSpec.classBuilder("Builder")
@@ -203,7 +203,7 @@ private MethodSpec privateConstructor() {
 
   /**
    * Returns the {@link ComponentRequirement}s for a component that does not have a {@link
-   * ComponentDescriptor#builderSpec()}.
+   * ComponentDescriptor#creatorDescriptor()}.
    */
   private Stream<ComponentRequirement> componentRequirements(ComponentDescriptor component) {
     checkArgument(component.kind().isTopLevel());
@@ -215,10 +215,9 @@ private MethodSpec privateConstructor() {
   }
 
   private boolean hasBindsInstanceMethods(ComponentDescriptor componentDescriptor) {
-    return componentDescriptor.builderSpec().isPresent()
+    return componentDescriptor.creatorDescriptor().isPresent()
         && methodsIn(
-                elements.getAllMembers(
-                    componentDescriptor.builderSpec().get().builderDefinitionType()))
+                elements.getAllMembers(componentDescriptor.creatorDescriptor().get().typeElement()))
             .stream()
             .anyMatch(method -> isAnnotationPresent(method, BindsInstance.class));
   }
diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index 8c84ee32a..22a4fc4b6 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -132,8 +132,8 @@
     /** A factory class for a present optional binding. */
     PRESENT_FACTORY,
 
-    /** A class for the component builder (Only used by the root component.) */
-    COMPONENT_BUILDER,
+    /** A class for the component creator (only used by the root component.) */
+    COMPONENT_CREATOR,
 
     /** A provider class for a component provision. */
     COMPONENT_PROVISION_FACTORY,
@@ -147,7 +147,7 @@
   private final NestingKind nestingKind;
   private final boolean isAbstract;
   private final Optional<ComponentImplementation> superclassImplementation;
-  private Optional<ComponentBuilderImplementation> builderImplementation;
+  private Optional<ComponentCreatorImplementation> creatorImplementation;
   private final Map<TypeElement, ComponentImplementation> childImplementations = new HashMap<>();
   private final TypeSpec.Builder component;
   private final SubcomponentNames subcomponentNames;
@@ -289,22 +289,22 @@ void setConfigureInitializationMethod(MethodSpec method) {
     addMethod(MethodSpecKind.CONFIGURE_INITIALIZATION_METHOD, method);
   }
 
-  void setBuilderImplementation(Optional<ComponentBuilderImplementation> builderImplementation) {
+  void setCreatorImplementation(Optional<ComponentCreatorImplementation> creatorImplementation) {
     checkState(
-        this.builderImplementation == null, "setBuilderImplementation has already been called");
-    this.builderImplementation = builderImplementation;
+        this.creatorImplementation == null, "setCreatorImplementation has already been called");
+    this.creatorImplementation = creatorImplementation;
   }
 
-  Optional<ComponentBuilderImplementation> builderImplementation() {
-    checkState(builderImplementation != null, "setBuilderImplementation has not been called yet");
-    return builderImplementation;
+  Optional<ComponentCreatorImplementation> creatorImplementation() {
+    checkState(creatorImplementation != null, "setCreatorImplementation has not been called yet");
+    return creatorImplementation;
   }
 
   /**
-   * Returns the name of the builder class for this component. It will be a sibling of this
+   * Returns the name of the creator class for this component. It will be a sibling of this
    * generated class unless this is a top-level component, in which case it will be nested.
    */
-  ClassName getBuilderName() {
+  ClassName getCreatorName() {
     return isNested()
         ? name.peerClass(subcomponentNames.get(componentDescriptor) + "Builder")
         : name.nestedClass("Builder");
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
index 381d7ec09..c6095e907 100644
--- a/java/dagger/internal/codegen/ComponentImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -31,7 +31,7 @@
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.COMPONENT_METHOD;
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.CONSTRUCTOR;
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.INITIALIZE_METHOD;
-import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.COMPONENT_BUILDER;
+import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.COMPONENT_CREATOR;
 import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.SUBCOMPONENT;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 import static dagger.producers.CancellationPolicy.Propagation.PROPAGATE;
@@ -107,10 +107,10 @@ ComponentImplementation createComponentImplementation(BindingGraph bindingGraph)
     ComponentImplementation componentImplementation =
         topLevelImplementation(componentName(bindingGraph.componentTypeElement()), bindingGraph);
     OptionalFactories optionalFactories = new OptionalFactories(componentImplementation);
-    Optional<ComponentBuilderImplementation> componentBuilderImplementation =
-        ComponentBuilderImplementation.create(
+    Optional<ComponentCreatorImplementation> componentCreatorImplementation =
+        ComponentCreatorImplementation.create(
             componentImplementation, bindingGraph, elements, types);
-    componentImplementation.setBuilderImplementation(componentBuilderImplementation);
+    componentImplementation.setCreatorImplementation(componentCreatorImplementation);
     ComponentRequirementFields componentRequirementFields =
         new ComponentRequirementFields(bindingGraph, componentImplementation);
     ComponentBindingExpressions bindingExpressions =
@@ -192,9 +192,9 @@ final ComponentImplementation build() {
           componentImplementation.name());
       setSupertype();
       componentImplementation
-          .builderImplementation()
-          .map(ComponentBuilderImplementation::componentBuilderClass)
-          .ifPresent(this::addBuilderClass);
+          .creatorImplementation()
+          .map(ComponentCreatorImplementation::componentCreatorClass)
+          .ifPresent(this::addCreatorClass);
 
       getLocalAndInheritedMethods(graph.componentTypeElement(), types, elements)
           .forEach(method -> componentImplementation.claimMethodName(method.getSimpleName()));
@@ -231,10 +231,10 @@ final void setSupertype() {
     }
 
     /**
-     * Adds {@code builder} as a nested builder class. Root components and subcomponents will nest
+     * Adds {@code creator} as a nested creator class. Root components and subcomponents will nest
      * this in different classes.
      */
-    abstract void addBuilderClass(TypeSpec builder);
+    abstract void addCreatorClass(TypeSpec creator);
 
     /** Adds component factory methods. */
     abstract void addFactoryMethods();
@@ -392,9 +392,9 @@ final ComponentImplementation buildChildImplementation(BindingGraph childGraph)
           compilerOptions.aheadOfTimeSubcomponents()
               ? abstractInnerSubcomponent(childGraph.componentDescriptor())
               : concreteSubcomponent(childGraph.componentDescriptor());
-      Optional<ComponentBuilderImplementation> childBuilderImplementation =
-          ComponentBuilderImplementation.create(childImplementation, childGraph, elements, types);
-      childImplementation.setBuilderImplementation(childBuilderImplementation);
+      Optional<ComponentCreatorImplementation> childCreatorImplementation =
+          ComponentCreatorImplementation.create(childImplementation, childGraph, elements, types);
+      childImplementation.setCreatorImplementation(childCreatorImplementation);
       ComponentRequirementFields childComponentRequirementFields =
           componentRequirementFields.forChildComponent(childGraph, childImplementation);
       ComponentBindingExpressions childBindingExpressions =
@@ -530,21 +530,21 @@ final void addConstructor() {
 
     /** Returns the list of {@link ParameterSpec}s for the constructor. */
     final ImmutableList<ParameterSpec> constructorParameters() {
-      Optional<ClassName> componentBuilderName;
-      if (componentImplementation.builderImplementation().isPresent()) {
-        componentBuilderName =
-            componentImplementation.builderImplementation().map(builder -> builder.name());
+      Optional<ClassName> componentCreatorName;
+      if (componentImplementation.creatorImplementation().isPresent()) {
+        componentCreatorName =
+            componentImplementation.creatorImplementation().map(creator -> creator.name());
       } else {
-        componentBuilderName =
+        componentCreatorName =
             componentImplementation
                 .baseImplementation()
-                .filter(component -> component.componentDescriptor().hasBuilder())
-                .map(ComponentImplementation::getBuilderName);
+                .filter(component -> component.componentDescriptor().hasCreator())
+                .map(ComponentImplementation::getCreatorName);
       }
 
-      if (componentBuilderName.isPresent()) {
+      if (componentCreatorName.isPresent()) {
         return ImmutableList.of(
-            ParameterSpec.builder(componentBuilderName.get(), "builder").build());
+            ParameterSpec.builder(componentCreatorName.get(), "builder").build());
       } else if (componentImplementation.isAbstract() && componentImplementation.isNested()) {
         // If we're generating an abstract inner subcomponent, then we are not implementing module
         // instance bindings and have no need for factory method parameters.
@@ -553,18 +553,18 @@ final void addConstructor() {
         return getFactoryMethodParameterSpecs(graph);
       } else if (componentImplementation.isAbstract()) {
         // If we're generating an abstract base implementation of a subcomponent it's acceptable to
-        // have neither a builder nor factory method.
+        // have neither a creator nor factory method.
         return ImmutableList.of();
       } else {
         throw new AssertionError(
-            "Expected either a component builder or factory method but found neither.");
+            "Expected either a component creator or factory method but found neither.");
       }
     }
   }
 
   /** Builds a root component implementation. */
   private final class RootComponentImplementationBuilder extends ComponentImplementationBuilder {
-    private final ClassName componentBuilderName;
+    private final ClassName componentCreatorName;
 
     RootComponentImplementationBuilder(
         BindingGraph graph,
@@ -578,31 +578,33 @@ final void addConstructor() {
           optionalFactories,
           bindingExpressions,
           componentRequirementFields);
-      this.componentBuilderName = componentImplementation.builderImplementation().get().name();
+      this.componentCreatorName = componentImplementation.creatorImplementation().get().name();
     }
 
     @Override
-    void addBuilderClass(TypeSpec builder) {
-      componentImplementation.addType(COMPONENT_BUILDER, builder);
+    void addCreatorClass(TypeSpec creator) {
+      componentImplementation.addType(COMPONENT_CREATOR, creator);
     }
 
     @Override
     void addFactoryMethods() {
       // Only top-level components have the factory builder() method.
-      // Mirror the user's builder API type if they had one.
-      MethodSpec builderFactoryMethod =
+      // Mirror the user's creator API type if they had one.
+      MethodSpec creatorFactoryMethod =
           methodBuilder("builder")
               .addModifiers(PUBLIC, STATIC)
               .returns(
-                  builderSpec()
-                      .map(builderSpec -> ClassName.get(builderSpec.builderDefinitionType()))
-                      .orElse(componentBuilderName))
-              .addStatement("return new $T()", componentBuilderName)
+                  creatorDescriptor()
+                      .map(creatorDescriptor -> ClassName.get(creatorDescriptor.typeElement()))
+                      .orElse(componentCreatorName))
+              .addStatement("return new $T()", componentCreatorName)
               .build();
-      componentImplementation.addMethod(BUILDER_METHOD, builderFactoryMethod);
+      componentImplementation.addMethod(BUILDER_METHOD, creatorFactoryMethod);
       if (canInstantiateAllRequirements()) {
         CharSequence buildMethodName =
-            builderSpec().isPresent() ? builderSpec().get().buildMethod().getSimpleName() : "build";
+            creatorDescriptor().isPresent()
+                ? creatorDescriptor().get().factoryMethod().getSimpleName()
+                : "build";
         componentImplementation.addMethod(
             BUILDER_METHOD,
             methodBuilder("create")
@@ -613,8 +615,8 @@ void addFactoryMethods() {
       }
     }
 
-    Optional<ComponentDescriptor.BuilderSpec> builderSpec() {
-      return graph.componentDescriptor().builderSpec();
+    private Optional<ComponentCreatorDescriptor> creatorDescriptor() {
+      return graph.componentDescriptor().creatorDescriptor();
     }
 
     /** {@code true} if all of the graph's required dependencies can be automatically constructed */
@@ -651,12 +653,12 @@ boolean canInstantiateAllRequirements() {
     }
 
     @Override
-    void addBuilderClass(TypeSpec builder) {
+    void addCreatorClass(TypeSpec creator) {
       if (parent.isPresent()) {
-        // In an inner implementation of a subcomponent the builder is a peer class.
-        parent.get().componentImplementation.addType(SUBCOMPONENT, builder);
+        // In an inner implementation of a subcomponent the creator is a peer class.
+        parent.get().componentImplementation.addType(SUBCOMPONENT, creator);
       } else {
-        componentImplementation.addType(SUBCOMPONENT, builder);
+        componentImplementation.addType(SUBCOMPONENT, creator);
       }
     }
 
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 4d262d7c5..4d10b3ab5 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -47,7 +47,7 @@
 final class ComponentProcessingStep extends TypeCheckingProcessingStep<TypeElement> {
   private final Messager messager;
   private final ComponentValidator componentValidator;
-  private final BuilderValidator builderValidator;
+  private final ComponentCreatorValidator creatorValidator;
   private final ComponentDescriptorValidator componentDescriptorValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraphFactory bindingGraphFactory;
@@ -66,7 +66,7 @@
   ComponentProcessingStep(
       Messager messager,
       ComponentValidator componentValidator,
-      BuilderValidator builderValidator,
+      ComponentCreatorValidator creatorValidator,
       ComponentDescriptorValidator componentDescriptorValidator,
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraphFactory bindingGraphFactory,
@@ -78,7 +78,7 @@
     super(MoreElements::asType);
     this.messager = messager;
     this.componentValidator = componentValidator;
-    this.builderValidator = builderValidator;
+    this.creatorValidator = creatorValidator;
     this.componentDescriptorValidator = componentDescriptorValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
@@ -176,7 +176,7 @@ private void generateComponent(BindingGraph bindingGraph) {
     for (Element element : builderElements) {
       try {
         ValidationReport<TypeElement> report =
-            builderValidator.validate(MoreElements.asType(element));
+            creatorValidator.validate(MoreElements.asType(element));
         report.printMessagesTo(messager);
         reports.put(element.getEnclosingElement(), report);
       } catch (TypeNotPresentException e) {
diff --git a/java/dagger/internal/codegen/ComponentRequirement.java b/java/dagger/internal/codegen/ComponentRequirement.java
index 38104faa6..9ba30ec74 100644
--- a/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/java/dagger/internal/codegen/ComponentRequirement.java
@@ -62,6 +62,11 @@
   /** The kind of requirement. */
   abstract Kind kind();
 
+  /** Returns true if this is a {@link Kind#BOUND_INSTANCE} requirement. */
+  final boolean isBoundInstance() {
+    return kind().equals(Kind.BOUND_INSTANCE);
+  }
+
   /**
    * The type of the instance the component must have, wrapped so that requirements can be used as
    * value types.
diff --git a/java/dagger/internal/codegen/ComponentRequirementFields.java b/java/dagger/internal/codegen/ComponentRequirementFields.java
index 312fd86e8..86587a592 100644
--- a/java/dagger/internal/codegen/ComponentRequirementFields.java
+++ b/java/dagger/internal/codegen/ComponentRequirementFields.java
@@ -58,8 +58,7 @@ private ComponentRequirementFields(
   }
 
   // TODO(ronshapiro): give ComponentImplementation a graph() method
-  ComponentRequirementFields(
-      BindingGraph graph, ComponentImplementation componentImplementation) {
+  ComponentRequirementFields(BindingGraph graph, ComponentImplementation componentImplementation) {
     this(Optional.empty(), graph, componentImplementation);
   }
 
@@ -103,12 +102,12 @@ ComponentRequirementField getField(ComponentRequirement componentRequirement) {
 
   /** Returns a {@link ComponentRequirementField} for a {@link ComponentRequirement}. */
   private ComponentRequirementField create(ComponentRequirement requirement) {
-    Optional<ComponentBuilderImplementation> builderImplementation =
+    Optional<ComponentCreatorImplementation> creatorImplementation =
         Optionals.firstPresent(
-            componentImplementation.baseImplementation().flatMap(c -> c.builderImplementation()),
-            componentImplementation.builderImplementation());
-    if (builderImplementation.isPresent()) {
-      FieldSpec builderField = builderImplementation.get().builderFields().get(requirement);
+            componentImplementation.baseImplementation().flatMap(c -> c.creatorImplementation()),
+            componentImplementation.creatorImplementation());
+    if (creatorImplementation.isPresent()) {
+      FieldSpec builderField = creatorImplementation.get().builderFields().get(requirement);
       return new BuilderField(requirement, componentImplementation, builderField);
     } else if (graph.factoryMethod().isPresent()
         && graph.factoryMethodParameters().containsKey(requirement)) {
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index d6550ffb3..88799dfea 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -23,7 +23,7 @@
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Multimaps.asMap;
-import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
+import static dagger.internal.codegen.ConfigurationAnnotations.enclosedAnnotatedTypes;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
@@ -51,7 +51,7 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Reusable;
-import dagger.internal.codegen.ErrorMessages.SubcomponentBuilderMessages;
+import dagger.internal.codegen.ErrorMessages.SubcomponentCreatorMessages;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.producers.CancellationPolicy;
@@ -82,7 +82,7 @@
   private final DaggerElements elements;
   private final Types types;
   private final ModuleValidator moduleValidator;
-  private final BuilderValidator builderValidator;
+  private final ComponentCreatorValidator creatorValidator;
   private final DependencyRequestValidator dependencyRequestValidator;
   private final MembersInjectionValidator membersInjectionValidator;
   private final MethodSignatureFormatter methodSignatureFormatter;
@@ -93,7 +93,7 @@
       DaggerElements elements,
       Types types,
       ModuleValidator moduleValidator,
-      BuilderValidator builderValidator,
+      ComponentCreatorValidator creatorValidator,
       DependencyRequestValidator dependencyRequestValidator,
       MembersInjectionValidator membersInjectionValidator,
       MethodSignatureFormatter methodSignatureFormatter,
@@ -101,7 +101,7 @@
     this.elements = elements;
     this.types = types;
     this.moduleValidator = moduleValidator;
-    this.builderValidator = builderValidator;
+    this.creatorValidator = creatorValidator;
     this.dependencyRequestValidator = dependencyRequestValidator;
     this.membersInjectionValidator = membersInjectionValidator;
     this.methodSignatureFormatter = methodSignatureFormatter;
@@ -122,7 +122,7 @@
   public ComponentValidationReport validate(
       final TypeElement subject,
       Set<? extends Element> validatedSubcomponents,
-      Set<? extends Element> validatedSubcomponentBuilders) {
+      Set<? extends Element> validatedSubcomponentCreators) {
     ValidationReport.Builder<TypeElement> report = ValidationReport.about(subject);
 
     ComponentKind componentKind = ComponentKind.forAnnotatedElement(subject).get();
@@ -145,11 +145,11 @@ public ComponentValidationReport validate(
     ImmutableList<DeclaredType> builders =
         componentKind
             .builderAnnotation()
-            .map(builderAnnotation -> enclosedBuilders(subject, builderAnnotation))
+            .map(builderAnnotation -> enclosedAnnotatedTypes(subject, builderAnnotation))
             .orElse(ImmutableList.of());
     if (builders.size() > 1) {
       report.addError(
-          String.format(ErrorMessages.builderMsgsFor(componentKind).moreThanOne(), builders),
+          String.format(ErrorMessages.creatorMessagesFor(componentKind).moreThanOne(), builders),
           subject);
     }
 
@@ -205,8 +205,8 @@ public ComponentValidationReport validate(
               } else if (subcomponentBuilderAnnotation.isPresent()) {
                 referencedSubcomponents.put(
                     MoreTypes.asElement(returnType).getEnclosingElement(), method);
-                validateSubcomponentBuilderMethod(
-                    report, method, parameters, returnType, validatedSubcomponentBuilders);
+                validateSubcomponentCreatorMethod(
+                    report, method, parameters, returnType, validatedSubcomponentCreators);
               } else {
                 // if it's not a subcomponent...
                 switch (parameters.size()) {
@@ -246,7 +246,7 @@ public ComponentValidationReport validate(
             (subcomponent, methods) ->
                 report.addError(
                     String.format(
-                        SubcomponentBuilderMessages.INSTANCE.moreThanOneRefToSubcomponent(),
+                        SubcomponentCreatorMessages.INSTANCE.moreThanOneRefToSubcomponent(),
                         subcomponent,
                         methods),
                     subject));
@@ -270,7 +270,7 @@ public ComponentValidationReport validate(
     for (Element subcomponent :
         Sets.difference(referencedSubcomponents.keySet(), validatedSubcomponents)) {
       ComponentValidationReport subreport =
-          validate(asType(subcomponent), validatedSubcomponents, validatedSubcomponentBuilders);
+          validate(asType(subcomponent), validatedSubcomponents, validatedSubcomponentCreators);
       report.addItems(subreport.report().items());
       allSubcomponents.addAll(subreport.referencedSubcomponents());
     }
@@ -432,24 +432,24 @@ private void validateSubcomponentMethod(
     }
   }
 
-  private void validateSubcomponentBuilderMethod(
+  private void validateSubcomponentCreatorMethod(
       ValidationReport.Builder<TypeElement> report,
       ExecutableElement method,
       List<? extends VariableElement> parameters,
       TypeMirror returnType,
-      Set<? extends Element> validatedSubcomponentBuilders) {
+      Set<? extends Element> validatedSubcomponentCreators) {
 
     if (!parameters.isEmpty()) {
-      report.addError(SubcomponentBuilderMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
+      report.addError(SubcomponentCreatorMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
     }
 
-    // If we haven't already validated the subcomponent builder itself, validate it now.
-    TypeElement builderElement = MoreTypes.asTypeElement(returnType);
-    if (!validatedSubcomponentBuilders.contains(builderElement)) {
-      // TODO(sameb): The builder validator right now assumes the element is being compiled
+    // If we haven't already validated the subcomponent creator itself, validate it now.
+    TypeElement creatorElement = MoreTypes.asTypeElement(returnType);
+    if (!validatedSubcomponentCreators.contains(creatorElement)) {
+      // TODO(sameb): The creator validator right now assumes the element is being compiled
       // in this pass, which isn't true here.  We should change error messages to spit out
       // this method as the subject and add the original subject to the message output.
-      report.addItems(builderValidator.validate(builderElement).items());
+      report.addItems(creatorValidator.validate(creatorElement).items());
     }
   }
 
diff --git a/java/dagger/internal/codegen/ConfigurationAnnotations.java b/java/dagger/internal/codegen/ConfigurationAnnotations.java
index ef618b0de..275f52e9f 100644
--- a/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -19,6 +19,9 @@
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ComponentKind.annotationsFor;
+import static dagger.internal.codegen.ComponentKind.builderAnnotationsFor;
+import static dagger.internal.codegen.ComponentKind.subcomponentKinds;
 import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeListValue;
@@ -75,22 +78,21 @@
   }
 
   static boolean isSubcomponent(Element element) {
-    return isAnyAnnotationPresent(element, Subcomponent.class, ProductionSubcomponent.class);
+    return isAnyAnnotationPresent(element, annotationsFor(subcomponentKinds()));
   }
 
-  static Optional<TypeElement> getSubcomponentBuilder(TypeElement subcomponent) {
+  static Optional<TypeElement> getSubcomponentCreator(TypeElement subcomponent) {
     checkArgument(isSubcomponent(subcomponent));
     for (TypeElement nestedType : typesIn(subcomponent.getEnclosedElements())) {
-      if (isSubcomponentBuilder(nestedType)) {
+      if (isSubcomponentCreator(nestedType)) {
         return Optional.of(nestedType);
       }
     }
     return Optional.empty();
   }
 
-  static boolean isSubcomponentBuilder(Element element) {
-    return isAnyAnnotationPresent(
-        element, Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);
+  static boolean isSubcomponentCreator(Element element) {
+    return isAnyAnnotationPresent(element, builderAnnotationsFor(subcomponentKinds()));
   }
 
   /**
@@ -201,9 +203,9 @@ static boolean isSubcomponentBuilder(Element element) {
     return ImmutableSet.copyOf(moduleElements);
   }
 
-  /** Returns the enclosed elements annotated with the given annotation type. */
-  static ImmutableList<DeclaredType> enclosedBuilders(TypeElement typeElement,
-      final Class<? extends Annotation> annotation) {
+  /** Returns the enclosed types annotated with the given annotation. */
+  static ImmutableList<DeclaredType> enclosedAnnotatedTypes(
+      TypeElement typeElement, Class<? extends Annotation> annotation) {
     final ImmutableList.Builder<DeclaredType> builders = ImmutableList.builder();
     for (TypeElement element : typesIn(typeElement.getEnclosedElements())) {
       if (MoreElements.isAnnotationPresent(element, annotation)) {
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 35eaa1f9b..76c9e58bb 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -27,23 +27,23 @@
  */
 final class ErrorMessages {
 
-  static ComponentBuilderMessages builderMsgsFor(ComponentKind kind) {
+  static ComponentCreatorMessages creatorMessagesFor(ComponentKind kind) {
     switch(kind) {
       case COMPONENT:
-        return ComponentBuilderMessages.INSTANCE;
+        return ComponentCreatorMessages.INSTANCE;
       case SUBCOMPONENT:
-        return SubcomponentBuilderMessages.INSTANCE;
+        return SubcomponentCreatorMessages.INSTANCE;
       case PRODUCTION_COMPONENT:
-        return ProductionComponentBuilderMessages.INSTANCE;
+        return ProductionComponentCreatorMessages.INSTANCE;
       case PRODUCTION_SUBCOMPONENT:
-        return ProductionSubcomponentBuilderMessages.INSTANCE;
+        return ProductionSubcomponentCreatorMessages.INSTANCE;
       default:
         throw new IllegalStateException(kind.toString());
     }
   }
 
-  static class ComponentBuilderMessages {
-    static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
+  static class ComponentCreatorMessages {
+    static final ComponentCreatorMessages INSTANCE = new ComponentCreatorMessages();
 
     protected String process(String s) { return s; }
 
@@ -161,7 +161,7 @@ final String inheritedNonBindsInstanceMethodsMayNotTakePrimitives() {
 
     final String buildMethodReturnsSupertypeWithMissingMethods(
         TypeElement component,
-        TypeElement componentBuilder,
+        TypeElement componentCreator,
         TypeMirror returnType,
         ExecutableElement buildMethod,
         Set<ExecutableElement> additionalMethods) {
@@ -169,7 +169,7 @@ final String buildMethodReturnsSupertypeWithMissingMethods(
           "%1$s.%2$s() returns %3$s, but %4$s declares additional component method(s): %5$s. In "
               + "order to provide type-safe access to these methods, override %2$s() to return "
               + "%4$s",
-          componentBuilder.getQualifiedName(),
+          componentCreator.getQualifiedName(),
           buildMethod.getSimpleName(),
           returnType,
           component.getQualifiedName(),
@@ -177,9 +177,9 @@ final String buildMethodReturnsSupertypeWithMissingMethods(
     }
   }
 
-  static final class SubcomponentBuilderMessages extends ComponentBuilderMessages {
+  static final class SubcomponentCreatorMessages extends ComponentCreatorMessages {
     @SuppressWarnings("hiding")
-    static final SubcomponentBuilderMessages INSTANCE = new SubcomponentBuilderMessages();
+    static final SubcomponentCreatorMessages INSTANCE = new SubcomponentCreatorMessages();
 
     @Override protected String process(String s) {
       return s.replaceAll("component", "subcomponent").replaceAll("Component", "Subcomponent");
@@ -194,10 +194,10 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
-  private static final class ProductionComponentBuilderMessages extends ComponentBuilderMessages {
+  private static final class ProductionComponentCreatorMessages extends ComponentCreatorMessages {
     @SuppressWarnings("hiding")
-    static final ProductionComponentBuilderMessages INSTANCE =
-        new ProductionComponentBuilderMessages();
+    static final ProductionComponentCreatorMessages INSTANCE =
+        new ProductionComponentCreatorMessages();
 
     @Override protected String process(String s) {
       return s.replaceAll("component", "production component")
@@ -205,11 +205,11 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
-  private static final class ProductionSubcomponentBuilderMessages
-      extends ComponentBuilderMessages {
+  private static final class ProductionSubcomponentCreatorMessages
+      extends ComponentCreatorMessages {
     @SuppressWarnings("hiding")
-    static final ProductionSubcomponentBuilderMessages INSTANCE =
-        new ProductionSubcomponentBuilderMessages();
+    static final ProductionSubcomponentCreatorMessages INSTANCE =
+        new ProductionSubcomponentCreatorMessages();
 
     @Override
     protected String process(String s) {
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
index edbd62935..2ff8957e2 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -110,16 +110,16 @@ Key forProductionComponentMethod(ExecutableElement componentMethod) {
     return forMethod(componentMethod, keyType);
   }
 
-  Key forSubcomponentBuilderMethod(
-      ExecutableElement subcomponentBuilderMethod, DeclaredType declaredContainer) {
-    checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
+  Key forSubcomponentCreatorMethod(
+      ExecutableElement subcomponentCreatorMethod, DeclaredType declaredContainer) {
+    checkArgument(subcomponentCreatorMethod.getKind().equals(METHOD));
     ExecutableType resolvedMethod =
-        asExecutable(types.asMemberOf(declaredContainer, subcomponentBuilderMethod));
+        asExecutable(types.asMemberOf(declaredContainer, subcomponentCreatorMethod));
     return Key.builder(resolvedMethod.getReturnType()).build();
   }
 
-  Key forSubcomponentBuilder(TypeMirror builderType) {
-    return Key.builder(builderType).build();
+  Key forSubcomponentCreator(TypeMirror creatorType) {
+    return Key.builder(creatorType).build();
   }
 
   Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
diff --git a/java/dagger/internal/codegen/KeyVariableNamer.java b/java/dagger/internal/codegen/KeyVariableNamer.java
index 0f087fa60..675498424 100644
--- a/java/dagger/internal/codegen/KeyVariableNamer.java
+++ b/java/dagger/internal/codegen/KeyVariableNamer.java
@@ -18,7 +18,7 @@
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
+import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentCreator;
 import static dagger.internal.codegen.SourceFiles.protectAgainstKeywords;
 
 import dagger.model.DependencyRequest;
@@ -43,7 +43,7 @@
         @Override
         public Void visitDeclared(DeclaredType declaredType, StringBuilder builder) {
           Element element = declaredType.asElement();
-          if (isSubcomponentBuilder(element)) {
+          if (isSubcomponentCreator(element)) {
             // Most Subcomponent builders are named "Builder", so add their associated
             // Subcomponent type so that they're not all "builderProvider{N}"
             builder.append(element.getEnclosingElement().getSimpleName());
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index 229cf3c59..6f115656d 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -27,7 +27,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
-import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;
+import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentCreator;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
@@ -301,7 +301,7 @@ private static void validateSubcomponentHasBuilder(
       TypeElement subcomponentAttribute,
       AnnotationMirror moduleAnnotation,
       ValidationReport.Builder<TypeElement> builder) {
-    if (getSubcomponentBuilder(subcomponentAttribute).isPresent()) {
+    if (getSubcomponentCreator(subcomponentAttribute).isPresent()) {
       return;
     }
     builder.addError(
diff --git a/java/dagger/internal/codegen/SubcomponentDeclaration.java b/java/dagger/internal/codegen/SubcomponentDeclaration.java
index e2bee5c8a..ed741b063 100644
--- a/java/dagger/internal/codegen/SubcomponentDeclaration.java
+++ b/java/dagger/internal/codegen/SubcomponentDeclaration.java
@@ -19,7 +19,7 @@
 import static com.google.auto.common.AnnotationMirrors.getAnnotationElementAndValue;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
-import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;
+import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentCreator;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -71,8 +71,8 @@
             new AutoValue_SubcomponentDeclaration(
                 Optional.of(subcomponentAttribute),
                 Optional.of(module),
-                keyFactory.forSubcomponentBuilder(
-                    getSubcomponentBuilder(subcomponent).get().asType()),
+                keyFactory.forSubcomponentCreator(
+                    getSubcomponentCreator(subcomponent).get().asType()),
                 subcomponent,
                 moduleAnnotation));
       }
diff --git a/java/dagger/internal/codegen/SubcomponentNames.java b/java/dagger/internal/codegen/SubcomponentNames.java
index 756424f7b..494a9686e 100644
--- a/java/dagger/internal/codegen/SubcomponentNames.java
+++ b/java/dagger/internal/codegen/SubcomponentNames.java
@@ -81,12 +81,14 @@ String get(Key key) {
       KeyFactory keyFactory, ImmutableMap<ComponentDescriptor, String> subcomponentNames) {
     ImmutableMap.Builder<Key, String> builder = ImmutableMap.builder();
     subcomponentNames.forEach(
-        (component, name) -> {
-          if (component.builderSpec().isPresent()) {
-            TypeMirror builderType = component.builderSpec().get().builderDefinitionType().asType();
-            builder.put(keyFactory.forSubcomponentBuilder(builderType), name);
-          }
-        });
+        (component, name) ->
+            component
+                .creatorDescriptor()
+                .ifPresent(
+                    creatorDescriptor -> {
+                      TypeMirror creatorType = creatorDescriptor.typeElement().asType();
+                      builder.put(keyFactory.forSubcomponentCreator(creatorType), name);
+                    }));
     return builder.build();
   }
 
diff --git a/javatests/dagger/internal/codegen/ComponentBuilderTest.java b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
index e66d2a66b..ca90f84d3 100644
--- a/javatests/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
@@ -44,8 +44,8 @@ public ComponentBuilderTest(CompilerMode compilerMode) {
     this.compilerMode = compilerMode;
   }
 
-  private static final ErrorMessages.ComponentBuilderMessages MSGS =
-      ErrorMessages.ComponentBuilderMessages.INSTANCE;
+  private static final ErrorMessages.ComponentCreatorMessages MSGS =
+      ErrorMessages.ComponentCreatorMessages.INSTANCE;
 
   @Test
   public void testEmptyBuilder() {
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index 3cfed6971..e6fe41026 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -31,8 +31,8 @@
 @RunWith(JUnit4.class)
 public class SubcomponentBuilderValidationTest {
 
-  private static final ErrorMessages.SubcomponentBuilderMessages MSGS =
-      new ErrorMessages.SubcomponentBuilderMessages();
+  private static final ErrorMessages.SubcomponentCreatorMessages MSGS =
+      new ErrorMessages.SubcomponentCreatorMessages();
 
   @Test
   public void testRefSubcomponentAndSubBuilderFails() {
