diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 14b9c7d07..66ce3017a 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -874,7 +874,9 @@ private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding bi
       private ImmutableSet<ContributionBinding> getLocalExplicitMultibindings(Key key) {
         ImmutableSet.Builder<ContributionBinding> multibindings = ImmutableSet.builder();
         multibindings.addAll(explicitMultibindings.get(key));
-        if (!MapType.isMap(key) || MapType.from(key).valuesAreFrameworkType()) {
+        if (!MapType.isMap(key)
+            || MapType.from(key).isRawType()
+            || MapType.from(key).valuesAreFrameworkType()) {
           // There are no @Binds @IntoMap delegate declarations for Map<K, V> requests. All
           // @IntoMap requests must be for Map<K, Framework<V>>.
           multibindings.addAll(
diff --git a/java/dagger/internal/codegen/Key.java b/java/dagger/internal/codegen/Key.java
index 9deac5626..2ad88beeb 100644
--- a/java/dagger/internal/codegen/Key.java
+++ b/java/dagger/internal/codegen/Key.java
@@ -575,7 +575,9 @@ Key convertToDelegateKey(Key possibleMapKey) {
       }
       MapType mapType = MapType.from(possibleMapKey);
       TypeMirror wrappedValueType;
-      if (mapType.valuesAreTypeOf(Provider.class)) {
+      if (mapType.isRawType()) {
+        return possibleMapKey;
+      } else if (mapType.valuesAreTypeOf(Provider.class)) {
         wrappedValueType = mapType.unwrappedValueType(Provider.class);
       } else if (mapType.valuesAreTypeOf(Producer.class)) {
         wrappedValueType = mapType.unwrappedValueType(Producer.class);
@@ -610,7 +612,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
       checkArgument(!currentWrappingClass.equals(newWrappingClass));
       if (MapType.isMap(possibleMapKey)) {
         MapType mapType = MapType.from(possibleMapKey);
-        if (mapType.valuesAreTypeOf(currentWrappingClass)) {
+        if (!mapType.isRawType() && mapType.valuesAreTypeOf(currentWrappingClass)) {
           TypeElement wrappingElement = getClassElement(newWrappingClass);
           if (wrappingElement == null) {
             // This target might not be compiled with Producers, so wrappingClass might not have an
@@ -637,7 +639,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
     private Optional<Key> wrapMapKey(Key possibleMapKey, Class<?> wrappingClass) {
       if (MapType.isMap(possibleMapKey)) {
         MapType mapType = MapType.from(possibleMapKey);
-        if (!mapType.valuesAreTypeOf(wrappingClass)) {
+        if (!mapType.isRawType() && !mapType.valuesAreTypeOf(wrappingClass)) {
           TypeElement wrappingElement = getClassElement(wrappingClass);
           if (wrappingElement == null) {
             // This target might not be compiled with Producers, so wrappingClass might not have an
@@ -660,7 +662,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
     Optional<Key> unwrapSetKey(Key key, Class<?> wrappingClass) {
       if (SetType.isSet(key)) {
         SetType setType = SetType.from(key);
-        if (setType.elementsAreTypeOf(wrappingClass)) {
+        if (!setType.isRawType() && setType.elementsAreTypeOf(wrappingClass)) {
           return Optional.of(
               key.toBuilder().type(setOf(setType.unwrappedElementType(wrappingClass))).build());
         }
diff --git a/javatests/dagger/functional/rawtypes/RawTypesComponent.java b/javatests/dagger/functional/rawtypes/RawTypesComponent.java
new file mode 100644
index 000000000..e2c69c22c
--- /dev/null
+++ b/javatests/dagger/functional/rawtypes/RawTypesComponent.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.rawtypes;
+
+import dagger.Component;
+import java.util.Map;
+import java.util.Set;
+
+@SuppressWarnings("rawtypes")
+@Component(modules = RawtypesModule.class)
+interface RawTypesComponent {
+  Set rawSet();
+  Map rawMap();
+}
diff --git a/javatests/dagger/functional/rawtypes/RawtypesModule.java b/javatests/dagger/functional/rawtypes/RawtypesModule.java
new file mode 100644
index 000000000..3bf5f5998
--- /dev/null
+++ b/javatests/dagger/functional/rawtypes/RawtypesModule.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.rawtypes;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+@SuppressWarnings("rawtypes")
+@Module
+abstract class RawtypesModule {
+  @Provides
+  static Map rawMap() {
+    return new HashMap();
+  }
+
+  @Provides
+  static Set rawSet() {
+    return new HashSet();
+  }
+}
