diff --git a/java/dagger/internal/codegen/Expression.java b/java/dagger/internal/codegen/Expression.java
index c38fd5795..b6d215c4e 100644
--- a/java/dagger/internal/codegen/Expression.java
+++ b/java/dagger/internal/codegen/Expression.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.squareup.javapoet.CodeBlock;
 import javax.lang.model.type.TypeMirror;
 
@@ -62,6 +63,16 @@ Expression castTo(TypeMirror newType) {
     return create(newType, "($T) $L", newType, codeBlock);
   }
 
+  /**
+   * Returns a new expression that {@link #castTo(TypeMirror)} casts the current expression to its
+   * boxed type if this expression has a primitive type.
+   */
+  Expression box(DaggerTypes types) {
+    return type.getKind().isPrimitive()
+        ? castTo(types.boxedClass(MoreTypes.asPrimitiveType(type)).asType())
+        : this;
+  }
+
   /** The {@link TypeMirror type} to which the expression evaluates. */
   TypeMirror type() {
     return type;
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index 9e615c9db..47cba7540 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -98,7 +98,12 @@ private Expression invokeMethod(ClassName requestingClass) {
       default:
         throw new IllegalStateException();
     }
-    return Expression.create(provisionBinding.key().type(), invocation);
+
+    return Expression.create(
+        method.getReturnType().getKind().isPrimitive()
+            ? method.getReturnType()
+            : provisionBinding.key().type(),
+        invocation);
   }
 
   private TypeName constructorTypeName(ClassName requestingClass) {
diff --git a/java/dagger/internal/codegen/SwitchingProviders.java b/java/dagger/internal/codegen/SwitchingProviders.java
index 441cd620f..29eac3f5a 100644
--- a/java/dagger/internal/codegen/SwitchingProviders.java
+++ b/java/dagger/internal/codegen/SwitchingProviders.java
@@ -101,20 +101,11 @@ Expression getDependencyExpression(ClassName requestingClass) {
   }
 
   private CodeBlock createSwitchCaseCodeBlock(Key key) {
-    Expression instanceExpression =
-        componentBindingExpressions.getDependencyExpression(key, INSTANCE, owningComponent);
-
-    CodeBlock instanceCodeBlock = instanceExpression.codeBlock();
-
-    // Primitives cannot be cast directly to the method's parameterized type, T. We have to first
-    // cast them to their boxed type.
-    // TODO(user): Shouldn't we be able to rely soley on the instance expression type? However,
-    // that currently fails. Does that indicate that those dependency expression types are wrong?
-    if (binding(key).contributedPrimitiveType().isPresent()
-        || instanceExpression.type().getKind().isPrimitive()) {
-      TypeName boxedType = TypeName.get(binding(key).contributedType()).box();
-      instanceCodeBlock = CodeBlock.of("($T) $L", boxedType, instanceCodeBlock);
-    }
+    CodeBlock instanceCodeBlock =
+        componentBindingExpressions
+            .getDependencyExpression(key, INSTANCE, owningComponent)
+            .box(types)
+            .codeBlock();
 
     return CodeBlock.builder()
         // TODO(user): Is there something else more useful than the key?
@@ -147,8 +138,4 @@ private TypeSpec createSwitchingProviderType() {
                 .build())
         .build();
   }
-
-  private ContributionBinding binding(Key key) {
-    return graph.contributionBindings().get(key).contributionBinding();
-  }
 }
