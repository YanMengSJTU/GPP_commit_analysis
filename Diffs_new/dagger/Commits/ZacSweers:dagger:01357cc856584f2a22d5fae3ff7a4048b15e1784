diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index b1cc46a4a..2e257d519 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -279,6 +279,7 @@ java_library(
         "MonitoringModuleGenerator.java",
         "MonitoringModuleProcessingStep.java",
         "MultibindingExpression.java",
+        "MultibindingFactoryCreationExpression.java",
         "OptionalBindingExpression.java",
         "OptionalFactories.java",
         "OptionalFactoryInstanceCreationExpression.java",
diff --git a/java/dagger/internal/codegen/MapFactoryCreationExpression.java b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
index 0240c6974..387c5ec6f 100644
--- a/java/dagger/internal/codegen/MapFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
@@ -17,25 +17,21 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.CodeBlock;
-import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
 
 /** A factory creation expression for a multibound map. */
-// TODO(dpb): Resolve with SetFactoryCreationExpression.
-final class MapFactoryCreationExpression implements FrameworkInstanceCreationExpression {
+final class MapFactoryCreationExpression extends MultibindingFactoryCreationExpression {
 
   private final GeneratedComponentModel generatedComponentModel;
-  private final ComponentBindingExpressions componentBindingExpressions;
   private final BindingGraph graph;
   private final ContributionBinding binding;
   private final DaggerElements elements;
@@ -46,9 +42,9 @@
       ComponentBindingExpressions componentBindingExpressions,
       BindingGraph graph,
       DaggerElements elements) {
+    super(binding, generatedComponentModel, componentBindingExpressions);
     this.binding = checkNotNull(binding);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.graph = checkNotNull(graph);
     this.elements = checkNotNull(elements);
   }
@@ -56,8 +52,7 @@
   @Override
   public CodeBlock creationExpression() {
     CodeBlock.Builder builder = CodeBlock.builder().add("$T.", mapFactoryClassName(binding));
-    boolean useRawType = !generatedComponentModel.isTypeAccessible(binding.key().type());
-    if (!useRawType) {
+    if (!useRawType()) {
       MapType mapType = MapType.from(binding.key().type());
       // TODO(ronshapiro): either inline this into mapFactoryClassName, or add a
       // mapType.unwrappedValueType() method that doesn't require a framework type
@@ -78,23 +73,13 @@ public CodeBlock creationExpression() {
     for (FrameworkDependency frameworkDependency : frameworkDependencies) {
       ContributionBinding contributionBinding =
           graph.contributionBindings().get(frameworkDependency.key()).contributionBinding();
-      CodeBlock value =
-          componentBindingExpressions
-              .getDependencyExpression(
-                  bindingRequest(frameworkDependency), generatedComponentModel.name())
-              .codeBlock();
       builder.add(
           ".put($L, $L)",
           getMapKeyExpression(contributionBinding, generatedComponentModel.name(), elements),
-          useRawType ? CodeBlocks.cast(value, frameworkDependency.frameworkClass()) : value);
+          multibindingDependencyExpression(frameworkDependency));
     }
     builder.add(".build()");
 
     return builder.build();
   }
-
-  @Override
-  public boolean useInnerSwitchingProvider() {
-    return !binding.dependencies().isEmpty();
-  }
 }
diff --git a/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java b/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
new file mode 100644
index 000000000..b9f6ef9a6
--- /dev/null
+++ b/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+
+/** An abstract factory creation expression for multibindings. */
+abstract class MultibindingFactoryCreationExpression
+    implements FrameworkInstanceCreationExpression {
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final ContributionBinding binding;
+
+  MultibindingFactoryCreationExpression(
+      ContributionBinding binding,
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions) {
+    this.binding = checkNotNull(binding);
+    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+  }
+
+  /** Returns the expression for a dependency of this multibinding. */
+  protected final CodeBlock multibindingDependencyExpression(
+      FrameworkDependency frameworkDependency) {
+    CodeBlock expression =
+        componentBindingExpressions
+            .getDependencyExpression(
+                BindingRequest.bindingRequest(frameworkDependency), generatedComponentModel.name())
+            .codeBlock();
+    return useRawType()
+        ? CodeBlocks.cast(expression, frameworkDependency.frameworkClass())
+        : expression;
+  }
+
+  /** The binding request for this framework instance. */
+  protected final BindingRequest bindingRequest() {
+    return BindingRequest.bindingRequest(
+        binding.key(),
+        binding instanceof ProvisionBinding ? FrameworkType.PROVIDER : FrameworkType.PRODUCER_NODE);
+  }
+
+  /**
+   * Returns true if the {@linkplain ContributionBinding#key() key type} is inaccessible from the
+   * component, and therefore a raw type must be used.
+   */
+  protected final boolean useRawType() {
+    return !generatedComponentModel.isTypeAccessible(binding.key().type());
+  }
+
+  @Override
+  public final boolean useInnerSwitchingProvider() {
+    return !binding.dependencies().isEmpty();
+  }
+}
diff --git a/java/dagger/internal/codegen/SetFactoryCreationExpression.java b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
index 302a41097..1e85bd928 100644
--- a/java/dagger/internal/codegen/SetFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
@@ -17,19 +17,14 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
 
 import com.squareup.javapoet.CodeBlock;
-import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
 import dagger.producers.Produced;
 
 /** A factory creation expression for a multibound set. */
-// TODO(dpb): Resolve with MapFactoryCreationExpression.
-final class SetFactoryCreationExpression implements FrameworkInstanceCreationExpression {
+final class SetFactoryCreationExpression extends MultibindingFactoryCreationExpression {
 
-  private final GeneratedComponentModel generatedComponentModel;
-  private final ComponentBindingExpressions componentBindingExpressions;
   private final BindingGraph graph;
   private final ContributionBinding binding;
 
@@ -38,17 +33,15 @@
       GeneratedComponentModel generatedComponentModel,
       ComponentBindingExpressions componentBindingExpressions,
       BindingGraph graph) {
+    super(binding, generatedComponentModel, componentBindingExpressions);
     this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.graph = checkNotNull(graph);
   }
 
   @Override
   public CodeBlock creationExpression() {
     CodeBlock.Builder builder = CodeBlock.builder().add("$T.", setFactoryClassName(binding));
-    boolean useRawType = !generatedComponentModel.isTypeAccessible(binding.key().type());
-    if (!useRawType) {
+    if (!useRawType()) {
       SetType setType = SetType.from(binding.key());
       builder.add(
           "<$T>",
@@ -77,23 +70,11 @@ public CodeBlock creationExpression() {
           throw new AssertionError(frameworkDependency + " is not a set multibinding");
       }
 
-      CodeBlock argument =
-          componentBindingExpressions
-              .getDependencyExpression(
-                  bindingRequest(frameworkDependency), generatedComponentModel.name())
-              .codeBlock();
       builderMethodCalls.add(
-          ".$L($L)",
-          methodName,
-          useRawType ? CodeBlocks.cast(argument, frameworkDependency.frameworkClass()) : argument);
+          ".$L($L)", methodName, multibindingDependencyExpression(frameworkDependency));
     }
     builder.add("builder($L, $L)", individualProviders, setProviders);
     builder.add(builderMethodCalls.build());
     return builder.add(".build()").build();
   }
-
-  @Override
-  public boolean useInnerSwitchingProvider() {
-    return !binding.dependencies().isEmpty();
-  }
 }
