diff --git a/semantics/advanced.md b/semantics/advanced.md
new file mode 100644
index 000000000..faffab296
--- /dev/null
+++ b/semantics/advanced.md
@@ -0,0 +1,543 @@
+# Advanced Dagger Semantics
+
+This series of documents describes the semantics of Dagger. It's not intended
+for learning *how* to use Dagger, but rather for *what* Dagger is.
+
+
+-   [Core Dagger](index.md)
+-   Advanced Dagger (this document)
+-   [Dagger Producers](producers.md)
+
+
+## Members-injection
+
+In some environments, you may not have control over the construction of an
+object (for example, Android activities), but you'd like to inject data into the
+object nevertheless. Dagger provides a way to directly "inject into" fields and
+methods after an object is constructed.
+
+A field annotated with `@Inject` is an **injectible field**; these fields must
+be non-final and non-private; a method annotated with `@Inject` is an
+**injectible method**; these methods must non-private.
+
+A **members-injectible class** is a class with any injectible fields or methods
+in it *or* any classes in its superclass chain. Its injectible fields and
+methods are all of the injectible fields and methods in it or any superclass,
+with one exception: if a superclass has an injectible method, and it is
+overridden in a subclass *without* an `@Inject` annotation, then it is not an
+injectible method of the subclass.
+
+For any members-injectible class, Dagger generates a synthetic binding with key
+signature as follows:
+
+For each injectible field, the **declared key** of the field is the Dagger key
+consisting of an optional qualifier on the field, and the type of the field.
+
+The **declared key signature** of a members-injectible class `T`'s synthetic
+binding has *inputs* as the declared keys of its injectible fields, together
+with the declared dependency keys of its injectible methods, and *output*
+`MembersInjector<T>`. The order of input keys in the signature is unspecified.
+
+The **key signature** is derived from the declared key signature as usual (by
+"unwrapping" `Provider` and `Lazy`).
+
+Note the API for `MembersInjector<T>` is:
+
+```java
+interface MembersInjector<T> {
+  void injectMembers(T instance);
+}
+```
+
+Therefore, the binding logic of this synthetic binding returns a function; this
+function has the following behavior:
+
+-   For each injectible field, assign the field the value of the corresponding
+    input key;
+-   For each injectible method, call the method with the arguments from the
+    corresponding input keys.
+
+Warning: this members-injection binding is not allowed to be injected by user
+code; it is only a figment of Dagger's imagination.
+
+### Members-injection from entry points
+
+Members-injection introduces a new type of entry point: If a class `T` is
+members-injectible, then a component may have a method with signature `T ->
+void`, e.g.
+
+```
+void injectT(T t);
+```
+
+This is a **members-injection entry point** with key `MembersInjector<T>`.
+
+Note: an entry point may, as per usual rules, just return a
+`MembersInjector<T>`, in which case it also is an entry point with key
+`MembersInjector<T>`, but just a normal entry point, not a members-injection
+entry point.
+
+### Resolution and Runtime
+
+Given a members-injection entry point with key `MembersInjector<T>`, Dagger
+generates an implementation that computes the `MembersInjector<T>` by usual
+rules, and then calls `MembersInjector#injectMembers()`.
+
+Here is a complete example of a members-injection entry point.
+
+```java
+final class Foo {
+  @Inject Foo() {}
+}
+
+final class Bar {
+  @Inject Bar() {}
+}
+
+abstract class Base {
+  @Inject Foo foo;
+}
+
+final class Derived extends Base {
+  @Inject void bar(Bar bar);
+}
+
+@Component
+interface C {
+  void injectDerived(Derived d);
+}
+```
+
+The generated implementation of `C` might look like:
+
+```
+final class DaggerC implements C {
+  void injectDerived(Derived d) {
+    d.foo = new Foo();
+    d.bar(new Bar());
+  }
+}
+```
+
+### Members-injection from `@Inject` constructors
+
+If a members-injectible class `T` also has an `@Inject` constructor, then Dagger
+*replaces* the binding from that `@Inject` constructor with a synthetic binding
+as follows.
+
+Suppose the declared key signature of the `@Inject` binding was
+
+```
+@Q1 S1, ..., @Qn Sn -> T.
+```
+
+Then the synthetic binding's signature is
+
+```
+MembersInjector<T>, @Q1 S1, ..., @Qn Sn -> T
+```
+
+Its binding logic is:
+
+-   call the constructor to construct a `T`
+-   call `MembersInjector#injectMembers()` on the resulting `T`
+
+Here is a complete example of a members-injection with an`@Inject` constructor.
+
+```java
+final class Foo {
+  @Inject Foo() {}
+}
+
+final class Bar {
+  @Inject Bar() {}
+}
+
+final class Baz {
+  @Inject Baz() {}
+}
+
+abstract class Base {
+  @Inject Foo foo;
+}
+
+final class Derived extends Base {
+  @Inject Derived(Baz baz) {}
+  @Inject void bar(Bar bar);
+}
+
+@Component
+interface C {
+  Derived derived();
+}
+```
+
+The generated implementation of `C` might look like:
+
+```
+final class DaggerC implements C {
+  Derived derived() {
+    Derived d = new Derived(new Baz());
+    d.foo = new Foo();
+    d.bar(new Bar());
+    return d;
+  }
+}
+```
+
+Warning: using members-injection with an `@Inject` constructor is discouraged.
+In general, members-injection makes it more difficult to test an object, since
+just calling the constructor does not "fully" initialize the object. As long as
+you're allowed to define the constructor of an object, it's usually better to
+add the appropriate arguments to the constructor rather than relying on
+members-injection.
+
+## Subcomponents
+
+A **subcomponent** is an interface or abstract class annotated `@Subcomponent`.
+
+We often refer to both components and subcomponents as components, and when we
+want to make a distinction, we'll refer to components (as defined previously) as
+**top-level components**.
+
+The **modules**, **entry points**, and **bindings** of a subcomponent analogous
+to modules, entry points, and bindings of a component.
+
+Note: subcomponents may not have component dependencies, because they do not
+have the appropriate field in their annotations. There's no technical reason why
+they couldn't; they just don't.
+
+The **builder** of a subcomponent is an interface or abstract class annotated
+`@Subcomponent.Builder`, that's nested inside a subcomponent. Subcomponent
+builders must follow the same rules as component builders.
+
+The **subcomponents** of a component are:
+
+-   the subcomponents specified by the `Module#subcomponents` field on any
+    module in its transitive closure
+-   the subcomponents that are the return types of any entry points
+-   the subcomponents whose builders are the return types of any entry points
+
+For example:
+
+```java
+@Component(modules = M.class)
+interface C {
+  S1 s1();
+  S2.Builder s2Builder();
+}
+
+@Module(subcomponents = S3.class)
+final class M { ... }
+
+@Subcomponent
+interface S1 { ... }
+
+@Subcomponent
+interface S2 {
+  @Subcomponent.Builder
+  interface Builder { ... }
+}
+
+@Subcomponent
+interface S3 { ... }
+```
+
+In the above example, the subcomponents of the top-level component `C` are `S1,
+S2`, and `S3`.
+
+Note: Subcomponents do not specify the component they are children of; the
+dependency goes in the reverse direction. Because of this, subcomponents can be
+children of multiple components.
+
+A top-level component forms a **component tree**, and it's possible for
+subcomponents to appear multiple times in this tree; these instances of
+subcomponents are treated as distinct subcomponents, even though they're
+represented by the same class. For example, top-level component `A` might have
+subcomponents `B` and `C`, both of which have subcomponent `D`; we view `A` as
+having two copies of `D` in its component tree.
+
+The **component path** of a subcomponent, in the context of a top-level
+component, is the path from the root to the subcomponent in that tree.
+
+In addition to the bindings described earlier, components and subcomponents also
+have a synthetic binding for each of the component's subcomponent's builders,
+whose
+
+-   signature is `component -> subcomponent builder`; and
+-   binding logic constructs a new subcomponent builder from the component.
+
+Because subcomponents have access to all bindings in their parent components,
+constructing a subcomponent builder consists of creating a new object with a
+pointer to the parent component object.
+
+### Resolution and Runtime
+
+When subcomponents are in the mix, Dagger amends the resolved graph as follows.
+Dagger constructs a graph for each *top-level component*, not for each
+subcomponent:
+
+The *nodes* of the graph are:
+
+-   bindings and entry points of the component and all of its subcomponents,
+    *tagged by the component path*;
+-   binding keys and dependency keys of those bindings, and all entry point
+    keys, *tagged by the component path* of the binding or entry point.
+
+Note: Because the same subcomponent class can appear multiple times in a
+component tree, bindings and entry points can as well, but they will be tagged
+differently, based on the component path.
+
+The *edges* of the graph are directed edges consisting of:
+
+-   for each tagged binding, an edge from its tagged dependency keys to the
+    tagged binding; this models **dependencies of bindings**;
+-   for each tagged entry point, an edge from the tagged entry point's key to
+    the tagged entry point; this models **dependencies of entry points**;
+-   for each tagged key `(K, P)`, where `K` is the key and `P` is the component
+    path, an edge from any tagged binding `(B, Q)`, where `K` is the binding key
+    for `B` and `Q` is a prefix of `P`; this models **resolution of keys**.
+
+Note: This last condition describes the lexical scoping of Dagger subcomponents.
+To resolve a key in a subcomponent, we not only look for bindings in that
+subcomponent, but also in any of its ancestor components.
+
+This graph can be thought of as a series of graphs layered on top of each other.
+First, the top-level component's graph; then, the graph of its subcomponents;
+then, the graph of the subcomponents of *those* subcomponents, and so on. Most
+edges are within a single level of this graph, but lexical scoping adds edges
+from lower levels to higher levels.
+
+## Multibindings
+
+Multibindings introduce a new kind of collection that allows multiple
+user-defined binding methods to contribute to the same collection.
+
+Multibinding methods are either **declarations** or **contributions**.
+Multibinding declarations declare that a particular key is a multibinding:
+
+-   An **optional binding declaration** is an abstract method in a module
+    annotated `@BindsOptionalOf`. Its binding key is `@Q Optional<T>`, assuming
+    its declared binding key is `@Q T`.
+-   A **multibinding declaration** is an abstract method in a module annotated
+    `@Multibinds`. Its binding key is its declared binding key, which must be
+    one of `@Q Set<T>` or `@Q Map<K, V>`.
+
+Contribution methods contribute elements into a multibinding collection:
+
+-   A **set contribution binding** is a `@Provides` or `@Binds` binding method
+    that is annotated either `@IntoSet` or `@ElementsIntoSet`. Suppose its
+    declared binding key is `@Q T`:
+    -   If a method is annotated `@IntoSet`, then its binding key is `@Q
+        Set<T>`.
+    -   If a method is annotated `@ElementsIntoSet`, then `T` must be `Set<U>`
+        for some `U`.
+-   A **map contribution binding** is a `@Provides` or `@Binds` binding method
+    that is annotated `@IntoMap` and has a **map key annotation**, which is an
+    annotation which itself is annotated `@MapKey`. Suppose the contribution
+    binding's declared binding key is `@Q T`. Then its binding key is `@Q Map<K,
+    T>`, where `K` is computed from the map key contribution as follows:
+
+A **simple map key annotation** is an annotation with just a `value` field, and
+specifies a map key of the type of its `value` field. Dagger provides several of
+these, for example:
+
+```java
+@MapKey
+public @interface IntKey {
+  int value();
+}
+
+@MapKey
+public @interface ClassKey {
+  Class<?> value();
+}
+```
+
+A **complex map key annotation** is an annotation with `@MapKey(unwrapValue =
+false)`, and specifies a map key of the type of the map key annotation itself.
+For example:
+
+```java
+@MapKey(unwrapValue = false)
+@interface MyKey {
+  String name();
+  Class<?> someClass();
+  int[] indices();
+}
+```
+
+Here are some examples of multibinding methods and their binding keys:
+
+```java
+// binding key = Map<Integer, String>
+@Multibinds abstract Map<Integer, String> m();
+
+// binding key = Optional<Foo>
+@BindsOptionalOf abstract Foo foo();
+
+// binding key = @Blue Set<Foo>
+@Provides @IntoSet @Blue Foo blueFoo() { ... }
+
+// binding key = Map<String, Foo>
+@Binds abstract @IntoMap @StringKey("foo") Foo sfoo(FooImpl impl);
+```
+
+If a binding does not have a multibinding annotation, then it is called a
+**unique binding**.
+
+### Resolution and Runtime
+
+A node in the resolution graph that represents a key is a **multibinding
+node** if either
+
+- there is a multibinding declaration with that key;
+- there is a multibinding contribution whose edge terminates in that key's node.
+
+Multibindings relax the restriction that every key node has exactly one inbound
+edge.
+
+#### Optional bindings
+
+If a node with key `@Q Optional<T>` is a multibinding node, and there is a
+binding with binding key `@Q T`, then a synthetic binding is generated from `@Q
+T` to `@Q Optional<T>`, with binding logic `Optional.of(t)`.
+
+A node representing an optional multibinding `@Q Optional<T>` may have zero or
+one inbound edges.
+
+At runtime, to fulfill the request for `Optional<T>`, if the node has zero
+inbound edges, its value is `Optional.empty()`, and otherwise (like normally,
+using the synthetic binding above), it is an optional consisting of the single
+inbound edge's value.
+
+#### Set or map multibindings
+
+If any of the edges to a key node are set or map multibinding methods, then
+*all* inbound edges must be multibindings methods. If a map binding has several
+entries with the same map key, the graph is ill-formed.
+
+At runtime, all multibinding methods' logic is executed. For set bindings, the
+results of each binding method are collected into a set, that is, throwing away
+duplicates (using `#equals()` on the resulting objects). For map bindings, the
+results are paired with keys and collected into a map.
+
+Map bindings are also allowed to be requested as `Map<K, Provider<V>>` or
+`Map<K, Lazy<V>>`. In this case, the logic in the map binding contribution
+methods is not executed when building this object, but rather deferred until
+`get()` is called on a value, similar to when `Provider` or `Lazy` are injected
+normally.
+
+#### Note about multibindings with subcomponents
+
+Multibindings are *accumulated* across subcomponents. Since subcomponents
+describe increasing lexical scopes, both multibinding contributions in a parent
+component, as well as with multibinding contributions in a child component, are
+available in the child component's multibinding. Therefore, for example, if you
+inject a `Set<T>` multibinding in a child component, you might get a larger set
+than if you inject the same set in a parent component.
+
+## Scopes
+
+Scopes are Dagger's way of caching the results of particular bindings; they
+declare that a binding's logic may not be executed more than once within the
+context of a particular component.
+
+A **scope** is a Java annotation that's annotated `@Scope`. For example,
+
+```java
+@Scope
+@interface RequestScope {}
+```
+
+defines a scope.
+
+Bindings and components may be annotated with a scope:
+
+The **scope of a user-defined binding** is an optional scope annotation applied
+to the binding method. It is an error to apply more than one scope to a binding.
+
+The **scopes of a component** are zero or more scope annotations applied to the
+component.
+
+There are two ways that Dagger validates scopes:
+
+1.  The scope on a binding must also be applied to the component that includes
+    that binding.
+
+2.  Subcomponents may not have the same scope as any of their ancestor
+    components.
+
+### Resolution and Runtime
+
+Recall that a binding of a component corresponds to a node in the resolution
+graph, and it has an outgoing edge to its binding key. When a binding is scoped
+in a particular component, then that binding's logic is executed at most once;
+the component object will cache the resulting value (that is, the output of the
+binding's logic) and use the cached value whenever the binding's key is
+subsequently requested.
+
+This cache is thread-safe; that is, Dagger guarantees that the binding logic is
+executed at most once, even if two threads simultaneously request the binding's
+key.
+
+#### Interaction with `Provider` and `Lazy`
+
+If a binding is scoped, and its key `@Q T` is requested by `@Q Provider<T>`,
+then each call to `Provider#get` will return the same, scoped instance; Dagger
+will always maintain the guarantee that the binding logic is executed at most
+once.
+
+If a binding is scoped, and its key `@Q T` is requested by `@Q Lazy<T>`, then
+similarly, each call to `Lazy#get` will return the same, scoped instance. (In
+this case, of course, there's no potential conflict in semantics, since both
+`Lazy` and scoping enforce a single execution of the binding logic.)
+
+### Reusable scope
+
+Dagger defines a special scope called `@Reusable`. This scope may be applied to
+a binding, and it may *not* be applied to any component.
+
+When a binding is `@Reusable` scoped, Dagger will treat it as though it is
+scoped in the least common ancestor of all components that use it.
+
+For example, suppose the component hierarchy is (where `->` means "has a
+subcomponent", and the following describes a tree):
+
+<!-- TODO(beder): Clarify this example. -->
+
+```
+A -> B -> C -> D
+            -> E
+       -> F -> G
+     H -> I
+```
+
+and suppose that a `@Reusable` binding is used in `D` and `G`. Then the binding
+is treated as being scoped in `B`.
+
+### Releasable scope
+
+Sometimes, you might only use a scope for performance reasons, not correctness.
+That is, you want some expensive objects to be optimistically cached, but you
+don't require this for the correctness of the application. In this case, in low
+memory environments, it can be useful to "release" those scoped objects (and
+allow them to be re-constructed), trading some CPU for memory.
+
+Dagger allows a scope to be annotated `@CanReleaseReferences`, which declares
+all scoped objects in this scope "releasable". When a scope is so annotated, a
+qualified `ReleasableReferenceManager` is available for injection:
+
+```java
+@ForReleasableReferences(MyScope.class) ReleasableReferenceManager
+```
+
+When the application would like to release some memory (e.g., it detects somehow
+that is in a low-memory situation), it may call
+`ReleasableReferenceManager#releaseStrongReferences()`, which changes all
+references from the component to scoped objects from strong to weak. This allows
+the garbage collector to collect these objects, if it chooses.
+
+If, later, the application decides it no longer is so memory constrained, it may
+call `ReleasableReferenceManager#restoreStrongReferences()` to revert the
+remaining (uncollected) weak references to strong references.
diff --git a/semantics/index.md b/semantics/index.md
new file mode 100644
index 000000000..7182a5f8f
--- /dev/null
+++ b/semantics/index.md
@@ -0,0 +1,768 @@
+# Dagger Core Semantics
+
+This series of documents describes the semantics of Dagger. It's not intended
+for learning *how* to use Dagger, but rather for *what* Dagger is.
+
+
+-   Core Dagger (this document)
+-   [Advanced Dagger](advanced.md)
+-   [Dagger Producers](producers.md)
+
+Dagger is roughly divided into a "core", plus several extensions. This document
+describes the core, and subsequent documents describe the extensions.
+
+Topics are presented incrementally; initially, we present a simplified view of
+Dagger, and as we introduce new topics, we'll note where previous statements
+must be amended.
+
+[TOC]
+
+## Keys
+
+A **qualifier** is a Java annotation that's annotated `@Qualifier`. For example,
+
+```java
+@Qualifier
+@interface Blue {}
+
+@Qualifier
+@interface Name {
+  String value();
+}
+```
+
+define qualifiers.
+
+We also use the term qualifier for the concrete use of the qualifier in code.
+For example:
+
+```
+@Name("Aaron")
+@Name("Brett")
+```
+
+are two different instantiations of the qualifier `@Name`. It is usually clear
+from context whether "qualifier" means the annotation definition or
+instantiation.
+
+A **key** is a pair of a Java type and an optional qualifier instantiation. For
+example,
+
+```java
+int
+@Blue Foo
+@Name("Giannis") Map<Integer, String>
+```
+
+are all keys.
+
+We often refer to a key as `@Q T`; by this, we mean that `Q` is a qualifier and
+`T` is a type.
+
+Two keys are the **same** if their types are the same, up to unboxing, and their
+qualifiers are the same. For example,
+
+```java
+@Blue int
+@Blue Integer
+```
+
+are the same, but
+
+```java
+@Green int
+```
+
+is different from both.
+
+It is always an error to apply multiple qualifiers to the same type.
+
+## Bindings
+
+A **binding** is a function that tells Dagger how to compute an instance of a
+binding key (which is essentially the return type of the method; see below). It
+can be either **user-defined** or **synthetic**:
+
+A **user-defined** binding is a Java method that is:
+
+-   A non-abstract method annotated `@Provides`
+-   An abstract method annotated `@Binds`, which has exactly one argument, and
+    the argument is convertible to the return type
+-   A constructor annotated `@Inject`
+
+These are the basic user-defined bindings; other Dagger features like
+[multibindings](advanced.md#multibindings) and [producers](producers.md)
+introduce new kinds of user-defined bindings.
+
+A **synthetic** binding is a binding that Dagger generates, subject to
+constraints that will be discussed later.
+
+### Signatures
+
+Recall that the signature of a Java method describes the inputs and outputs of
+that methods; these inputs and outputs are, of course, Java types. Sometimes
+this signature is considered to include annotations, and sometimes it's not; in
+our case, we want to consider the annotations on method parameters, and on the
+method itself, as part of the Java signature. For example,
+
+```java
+// Java signature = (@Blue Set<Bar>, @Nullable Provider<Integer>) -> @Nullable Foo
+@Nullable Foo foo(@Blue Set<Bar> setOfBar, @Nullable Provider<Integer> i);
+```
+
+This signature induces a **key signature**, that is, a signature where the
+inputs and outputs are Dagger keys, as follows.
+
+First, we compute the **declared key signature** by simply dropping all
+annotations that are not qualifiers. For example:
+
+```java
+// declared key signature = (@Blue Set<Bar>, Provider<Integer>) -> Foo
+@Nullable Foo foo(@Blue Set<Bar> setOfBar, @Nullable Provider<Integer> i);
+```
+
+Then, we form the key signature by unwrapping arguments that are `Provider<T>`,
+`Lazy<T>`, or `Provider<Lazy<T>>`. For example:
+
+```java
+// key signature = (@Blue Set<Bar>, int) -> Foo
+@Nullable Foo foo(@Blue Set<Bar> setOfBar, @Nullable Provider<Integer> i);
+```
+
+The output key is called the **binding key** and the input keys are called
+**dependency keys**; we'll sometimes refer to the **declared binding key** or
+**declared dependency keys**, which are the output and inputs keys of the
+declared key signature.
+
+Note: For `@Inject` constructors, we treat the return type of the Java signature
+as the type of the constructor's class. Unlike the other binding methods,
+`@Inject` constructors' binding keys cannot have qualifiers.
+
+Here are some more examples of key signatures:
+
+```java
+// key signature = (int) -> Foo
+@Provides Foo foo(int x) { ... }
+
+// key signature = (FooImpl) -> @Green Foo
+@Binds @Green abstract Foo greenFoo(FooImpl impl);
+
+// key signature = () -> int
+@Provides int count() { return 5; }
+
+// key signature = (Bar) -> Foo
+class Foo {
+  @Inject
+  Foo(Bar bar) { ... }
+}
+
+// key signature = (Bar, @Blue Baz, @Green int) -> Foo
+@Provides Foo foo(
+    Bar bar, @Blue Baz baz, @Green Provider<Integer> greenIntProvider) { ... }
+```
+
+### Binding Logic
+
+The **binding logic** of a binding is the function that the binding represents.
+It is a (possibly fictitious) Java function with the same signature as the
+binding, except ignoring qualifiers.
+
+Of the bindings discussed so far:
+
+-   the binding logic of a `@Provides` method is the method itself;
+-   the binding logic of a `@Binds` method is the identity function;
+-   the binding logic of an `@Inject` constructor is the constructor itself,
+    thinking of it as a function from its arguments to the class type;
+
+## Modules
+
+A **module** is a class annotated `@Module`, which contains zero or more
+`@Provides` or `@Binds` methods; these methods are the **bindings** of the
+module.
+
+For the purposes of this initial exposition, modules may not have instance
+methods or fields. In the
+[Parameterization](#parameterization-component-builders) section, they will be
+allowed to have instance methods or fields, but this is generally discouraged.
+
+Modules may **include** other modules via the `includes` field on their
+annotation. The **transitive closure** of a module is the transitive set of
+modules that are included by that module, and the **transitive bindings** of a
+module is the union of all bindings in modules in the transitive closure.
+
+## Components
+
+A **component** is an interface or abstract class annotated `@Component`.
+
+**Dagger will generate implementations of components.**
+
+The **modules** of a component are the transitive closure of the list of modules
+specified in the `modules` field on its annotation.
+
+The **entry points** of the component are the abstract, zero-arg, non-void
+methods on the interface or abstract class. It is an error to have any abstract
+methods that have arguments or are void. The **entry point key** is defined
+analogously to a binding key, that is, the key associated with its return type.
+
+The **bindings** of a component are the union of the set of bindings in all of
+the component's modules.
+
+Here is a complete example with all of the features described so far:
+
+```java
+@Qualifier @interface Blue {}
+
+@Module(includes = N.class)
+abstract class M {
+  @Provides static int v() { ... }
+  @Provides static Foo foo(X x, int v) { ... }
+  @Binds abstract Bar bar(BarImpl impl);
+}
+
+@Module
+final class N {
+  @Provides @Blue static Y y(X x) { ... }
+}
+
+class X {
+  @Inject
+  X() { ... }
+}
+
+class BarImpl {
+  @Inject
+  BarImpl(@Blue Y y, int v) { ... }
+}
+
+@Component(modules = M.class)
+interface C {
+  Foo foo();
+  Bar bar();
+}
+```
+
+In the above example:
+
+- The component `C` has modules `{M, N}`;
+- Its bindings are:
+  - `M#v` (signature = `() -> int`)
+  - `M#foo` (signature = `X, int -> Foo`)
+  - `M#bar` (signature = `BarImpl -> Bar`)
+  - `N#y` (signature = `X -> @Blue Y`)
+  - `BarImpl` (signature = `@Blue Y, int -> BarImpl`)
+- Its entry points are:
+  - `C#foo` (key = `Foo`)
+  - `C#bar` (key = `Bar`)
+
+## Resolution: Construction of the Graph
+
+Dagger constructs a bipartite graph for each component.
+
+The *nodes* of the graph are:
+
+-   bindings and entry points of the component
+-   binding keys and dependency keys of those bindings, and all entry point
+    keys.
+
+The *edges* of the graph are directed edges consisting of:
+
+-   for each binding, an edge from its dependency keys to the binding; this
+    models **dependencies of bindings**;
+-   for each entry point, an edge from the entry point's key to the entry point;
+    this models **dependencies of entry points**;
+-   for each key, an edge to the key from any binding that has this key as its
+    binding key; this models **resolution of keys**.
+
+The graph is **well-formed** if:
+
+-   every key node has exactly one inbound edge;
+-   there are no cycles, with the following exception: if a cycle contains an
+    edge representing a dependency key whose type was wrapped in `Provider` or
+    `Lazy`, then it is permitted.
+
+If a key node has zero inbound edges, it is a **missing binding**; if it has
+more than one inbound edge, it is a **duplicate binding**.
+
+The above example component generates the following graph. The key nodes are
+light red, the binding nodes are light blue, and the entry point nodes are light
+green.
+
+```dot
+digraph d_front_back {
+  rankdir="LR";
+  graph [size="9;9", style=invis, ranksep=2]
+  node [ style=filled, nodesep=0.2 ]
+  edge [ weight=1.2 ]
+
+  subgraph cluster_bindings {
+    rank=same;
+    "M\#v()" [ color="lightblue" ];
+    "M\#foo()" [ color="lightblue" ];
+    "M\#bar()" [ color="lightblue" ];
+    "N\#y()" [ color="lightblue" ];
+    "BarImpl()" [ color="lightblue" ];
+    "X()" [ color="lightblue" ];
+    "C#foo" [ color="lightgreen" ];
+    "C#bar" [ color="lightgreen" ];
+  }
+  subgraph cluster_keys {
+    rank=same;
+    X [ color="mistyrose" ];
+    "@Blue Y" [ color="mistyrose" ];
+    int [ color="mistyrose" ];
+    Foo [ color="mistyrose" ];
+    Bar [ color="mistyrose" ];
+    BarImpl [ color="mistyrose" ];
+  }
+  X -> "M\#foo()"
+  int -> "M\#foo()"
+  BarImpl -> "M\#bar()"
+  X -> "N\#y()"
+  "@Blue Y" -> "BarImpl()"
+  int -> "BarImpl()"
+  Foo -> "C#foo"
+  Bar -> "C#bar"
+  "X()" -> X
+  "N\#y()" -> "@Blue Y"
+  "M\#v()" -> int
+  "M\#foo()" -> Foo
+  "M\#bar()" -> Bar
+  "BarImpl()" -> BarImpl
+}
+```
+
+## Code Generation and Runtime
+
+Given a well-formed graph of a component, Dagger generates an implementation for
+that component interface, which has the following runtime behavior.
+
+### Implementing the Component
+
+Dagger generates an implementation of the component in the same package as the
+component, whose name is prefixed with `Dagger`. If the component was a nested
+class, named `C1.C2...Cn`, then the generated implementation replaces dots with
+underscores: `DaggerC1_C2_..._Cn`.
+
+The generated component class has a private zero-arg constructor, and Dagger
+will generate a special public method `#create()` that constructs the component.
+
+For each entry point, Dagger will resolve it by following the graph along
+reverse edges, which will produce a subset of the graph.
+
+Assume first that this is an acyclic graph with no binding methods that take
+`Provider` or `Lazy`. Beginning with the roots of this subgraph, Dagger will
+execute the **binding logic** for each binding, passing the result of each
+computation into the subsequent binding. If one binding is used by several
+others, its binding logic will be re-evaluated *each time* it is needed. When
+Dagger reaches the terminal point of this process (the entry point), Dagger
+returns the value it has computed.
+
+In the earlier example, Dagger will generate code that roughly looks like
+
+```java
+public final class DaggerC implements C {
+  private DaggerC() {}
+
+  public static C create() {
+    return new DaggerC();
+  }
+
+  @Override
+  public Foo foo() {
+    return new Foo(new X(), M.v());
+  }
+
+  @Override
+  public Bar bar() {
+    return new BarImpl(N.y(new X()), M.v());
+  }
+}
+```
+
+Note that `M.v()` is called twice, once for each place it's used.
+
+### Provider and Lazy
+
+If a binding method has an argument of `Provider`, then instead of actually
+*executing* the binding logic, Dagger will generate a class that defers the
+computation of that logic and all of its dependencies. For example, suppose in
+the earlier example that the constructor for `BarImpl` was:
+
+```java
+class BarImpl {
+  @Inject
+  BarImpl(@Blue Provider<Y> y, int v) { ... }
+}
+```
+
+Dagger might generate code looking like:
+
+```java
+public final class DaggerC implements C {
+  ... // as before
+
+  @Override
+  public Bar bar() {
+    return new BarImpl(() -> N.y(new X()), M.v());
+  }
+}
+```
+
+If a binding method has an argument of `Lazy`, then similarly, Dagger will
+generate a class that defers the computation of that logic and all of its
+dependencies, and caches the result. For example, suppose in the example that
+the constructor for `BarImpl` was:
+
+```java
+class BarImpl {
+  @Inject
+  BarImpl(@Blue Lazy<Y> y) { ... }
+}
+```
+
+Dagger might generate code looking like:
+
+```java
+public final class DaggerC implements C {
+  ... // as before
+
+  @Override
+  public Bar bar() {
+    return new BarImpl(DoubleCheck.provider(() -> N.y(new X())), M.v());
+  }
+}
+```
+
+where [DoubleCheck][double check] is a Dagger utility class that caches the
+result of a provider call.
+
+Note: Dagger will construct a new `Lazy` instance every time it is requested; so
+although `Lazy` itself caches its contents, if multiple bindings request a
+`Lazy` of the same type, they'll get different instances.
+
+[double check]: https://github.com/google/dagger/blob/bbb4bfd2bd0c27b884d0c01795b588f2bf1cb685/java/dagger/internal/DoubleCheck.java
+
+### Cycles
+
+If a well-formed graph has a cycle, then necessarily the cycle contains an
+argument to a binding that is a `Provider` or `Lazy`. In this case, the
+implementation of this cycle can be broken with an extra layer of indirection:
+Dagger starts by constructing a dummy version of that `Provider` or `Lazy`,
+continuing around the cycle by making providers (never actually executing any
+binding logic), until it reaches the end of the cycle and it fills in the
+original `Provider`.
+
+For example:
+
+```java
+@Module
+final class M {
+  @Provides static A a(Provider<C> c) { return new A(); }
+  @Provides static B b(A a) { return new B(); }
+  @Provides static C c(B b) { return new C(); }
+}
+
+@Component(modules = M.class)
+interface X {
+  A a();
+}
+```
+
+Dagger might generate code that looks like:
+
+```java
+public final class DaggerX implements X {
+  @Override
+  public A a() {
+    DelegateProvider<A> a = new DelegateProvider<>();
+    Provider<B> b = () -> M.b(a.get());
+    Provider<C> c = () -> M.c(b.get());
+    a.setDelegate(() -> M.a(c));
+    return a.get();
+  }
+}
+```
+
+### Exceptions
+
+Exceptions are not caught by Dagger. Since Dagger generates code that is
+essentially composition of functions, if any binding's logic throws an
+exception, then it will propagate out to the caller of the entry point.
+
+The one exception to this behavior is with `Provider` or `Lazy`; since both of
+these types defer computation, if a binding's logic throws an exception in some
+ancestor dependency of a `Provider` or `Lazy` injection, then the `get()` method
+will throw that exception, and the user could catch it there. However, it's
+often considered a code smell to catch exceptions this way, since binding
+methods should rarely throw exeptions.
+
+## Parameterization: Component Builders
+
+So far, a component is self-contained: it can be constructed at runtime with no
+arguments.
+
+Dagger allows components to be **parameterized**: new bindings can be added to
+the component whose logic is passed at runtime, to a "component builder", before
+constructing the component.
+
+The **builder** of a component is an interface or abstract class annotated
+`@Component.Builder`, that's nested inside a component.
+
+Component builders must have a **build method**, which is an abstract zero-arg
+method returning the component.
+
+All other abstract methods on the builder must be **setter methods**, that is,
+single-arg methods returning the builder class itself. There are three kinds of
+setter methods, which will be discussed separately.
+
+### Bound instances
+
+A **bound instance** is the argument of a builder setter method annotated with
+`@BindsInstance`. This binds the value of the instance passed at runtime to the
+declared key of the argument; that is, it generates a binding.
+
+A **bound instance binding** is a user-defined binding for each of the
+`@BindsInstance` methods on the component builder; with
+
+-   key signature is `component -> declared key of the single argument`
+-   binding logic returning the bound instance from the component;
+
+When bound instance bindings are present, we need a special synthetic binding to
+represent the component, whose
+
+-   key signature is `() -> component`; and
+-   binding logic returns the `this` of the generated implementation of the
+    component.
+
+Here is a complete example with bound instances:
+
+```java
+@Qualifier @interface Blue {}
+
+@Module(includes = N.class)
+abstract class M {
+  @Provides static Foo foo(X x, int v) { ... }
+  @Binds abstract Bar bar(BarImpl impl);
+}
+
+@Module
+final class N {
+  @Provides @Blue static Y y(X x) { ... }
+}
+
+class BarImpl {
+  @Inject
+  BarImpl(@Blue Y y, int v) { ... }
+}
+
+@Component(modules = M.class)
+interface C {
+  Foo foo();
+  Bar bar();
+
+  @Component.Builder
+  interface B {
+    @BindsInstance B x(X x);
+    @BindsInstance B v(int v);
+    C build();
+  }
+}
+```
+
+In the above example:
+
+- The component `C` has modules `{M, N}`;
+- Its bindings are:
+  - synthetic binding for bound instance `B#x` (signature = `C -> X`)
+  - synthetic binding for bound instance `B#v` (signature = `C -> int`)
+  - user-defined `M#foo` (signature = `X, int -> Foo`)
+  - user-defined `M#bar` (signature = `BarImpl -> Bar`)
+  - user-defined `N#y` (signature = `X -> @Blue Y`)
+  - user-defined `BarImpl` (signature = `@Blue Y, int -> BarImpl`)
+  - synthetic binding for `C` (signature = `() -> C`)
+- Its entry points are:
+  - `C#foo` (key = `Foo`)
+  - `C#bar` (key = `Bar`)
+
+### Resolution and Runtime
+
+Dagger generates a builder class that is a standard Java builder: it collects
+all of the bound instances passed to it; and then constructs a component object,
+which passes references to all of those instances to the constructor of the
+component.
+
+Dagger generates a component class that maintains references to all of these
+instances passed by the builder. These references describe the bound instance
+bindings on the component; i.e., the binding for a bound instance, which has
+signature `component -> some bound instance key`, is just a field lookup on the
+component for that instance.
+
+Moreover, note that all generated code below is inside the component itself;
+therefore, every method has access to the component instance itself (via the
+`this` parameter).
+
+Finally, Dagger generates a public static method `#builder()` that constructs
+the component builder.
+
+For the earlier example, Dagger would generate code that roughly looks like:
+
+```java
+public final class DaggerC implements C {
+  private final X x;
+  private final int v;
+
+  private DaggerC(X x, int v) {
+    this.x = x;
+    this.v = v;
+  }
+
+  @Override
+  public Foo foo() {
+    return new Foo(x, v);
+  }
+
+  @Override
+  public Bar bar() {
+    return new BarImpl(N.y(x), v);
+  }
+
+  public static B builder() {
+    return new Builder();
+  }
+
+  static final class Builder implements B {
+    private X x;
+    private int v;
+
+    @Override
+    public B x(X x) {
+      this.x = checkNotNull(x);
+      return this;
+    }
+
+    @Override
+    public B v(int v) {
+      this.v = v;
+      return this;
+    }
+
+    @Override
+    public C build() {
+      return new DaggerC(checkNotNull(x), v);
+    }
+  }
+}
+```
+
+### Component dependencies
+
+The **dependencies** of a component are the classes listed in the component's
+`dependencies` field of its annotation. These classes may be arbitrary classes,
+but what Dagger cares about is the zero-arg non-void instance methods, whose
+return types will be bound.
+
+When a component dependency is listed in the component annotation, it must have
+a corresponding setter method in the component builder.
+
+Component dependencies add two new kinds of bindings:
+
+-   A **component dependency method binding** is a non-void, zero-arg method on
+    component dependency; with
+    -   key signature `component dependency -> declared key of the return type
+        of the method`
+    -   binding logic is the method itself
+-   A **component dependency binding** is a synthetic binding for a component
+    dependency; with
+    -   key signature `component -> component dependency`; and
+    -   binding logic returning a component dependency instance from the
+        component;
+
+Component dependencies are simply syntactic sugar for a certain use case for
+bound instances. Suppose that we have the following interface:
+
+```java
+interface D {
+  @Q1 T1 t1();
+  ...
+  @Qn Tn tn();
+  // possibly other, non-void or non-zero-arg methods
+}
+```
+
+Then specifying `D` as a component dependency as follows:
+
+```java
+@Component(dependencies = D.class, modules = ...)
+interface C {
+  ...
+
+  @Component.Builder
+  interface B {
+    B d(D d);
+    ...
+    C build();
+  }
+}
+```
+
+is equivalent to writing a module:
+
+```java
+@Module
+final class DModule {
+  @Provides @Q1 static T1 t1(D d) { return d.t1(); }
+  ...
+  @Provides @Qn static Tn tn(D d) { return d.tn(); }
+}
+```
+
+and binding `D` as an instance:
+
+```java
+@Component(dependencies = D.class, modules = {DModule.class, ...})
+interface C {
+  ...
+
+  @Component.Builder
+  interface B {
+    @BindsInstance B d(D d);
+    ...
+    C build();
+  }
+}
+```
+
+This is really truly equivalent: not only does it produce the same graph of
+bindings, but it also provides clients with the same runtime API for the
+component and its builder.
+
+### Module instances
+
+When modules were presented earlier, they were not allowed instance methods or
+fields. We now describe a way that Dagger does allow modules to have instance
+methods or fields.
+
+Warning: it's discouraged for modules to have state; this can lead to
+unpredictable behavior. Moreover, module instances in general are rarely useful.
+We have considered removing them.
+
+If a builder setter method specifies a module, then Dagger generates a new
+binding:
+
+A **module binding** is a synthetic binding for a module; with
+
+-   key signature `component -> module`; and
+-   binding logic returning a module instance from the component;
+
+Then, given a binding in that module that is an instance method, Dagger treats
+its signature's first argument as the module itself (i.e., the `this` parameter
+of the module).
+
+Warning: module bindings are not allowed to be injected by user code; it is only
+a figment of Dagger's imagination.
+
+Module instances are also redundant with bound instances. Any instance fields of
+a module can be bound directly as instances, so that instance methods that refer
+to them can inject those types directly, and hence can be static methods.
+
+<!-- TODO(beder): Add example of this redundancy. -->
diff --git a/semantics/producers.md b/semantics/producers.md
new file mode 100644
index 000000000..82d260a74
--- /dev/null
+++ b/semantics/producers.md
@@ -0,0 +1,322 @@
+# Dagger Producers Semantics
+
+This series of documents describes the semantics of Dagger. It's not intended
+for learning *how* to use Dagger, but rather for *what* Dagger is.
+
+
+-   [Core Dagger](index.md)
+-   [Advanced Dagger](advanced.md)
+-   Dagger Producers (this document)
+
+[TOC]
+
+## Overview
+
+Dagger has an extension called Dagger Producers, which allows bindings to
+represent asynchronous operations that can be executed concurrently.
+
+Dagger, up until now, doesn't make any mention of threads. It *allows* code to
+be safely executed in parallel (e.g., with scoped bindings, Dagger will ensure
+the binding is only executed once even if multiple threads request the same
+binding), but all Dagger-generated code is synchronous.
+
+Moreover, traditional dependency injection is all about an "object graph", that
+is, a graph of object dependencies; `@Inject` constructors are the primary
+focus, and Dagger only introduced the other binding kinds (`@Provides` methods,
+etc.) as a more flexible way of accommodating related use cases.
+
+Dagger Producers changes both of these assumptions: it lets you (a) run binding
+method logic on an [executor][Executor] of your choice, and (b) return a future
+from binding methods, so they can represent asynchronous computations.
+
+A **future** is a type representing some work to compute a value. The JDK has a
+[Future][Future] type, but Dagger Producers doesn't use that directly; instead,
+Dagger supports [ListenableFuture][ListenableFuture] or
+[FluentFuture][FluentFuture], both Guava types that offer better APIs than the
+JDK's `Future` itself. Throughout this document, whenever we say "future" or
+refer to a type `Future<T>`, we mean any of the supported future types.
+
+This enables asynchronous computation (since you can run binding method logic in
+parallel, if you supply the right executor), and it focuses on a "computation
+graph", that is, a graph of computation dependencies. What the latter means is
+that it focuses more on the logic in each binding method, rather than the
+internal state of the objects produced. In fact, with producers, it's typically
+better to only produce immutable value types.
+
+[Executor]: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html
+[Future]: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html
+[ListenableFuture]: https://google.github.io/guava/releases/23.6-jre/api/docs/com/google/common/util/concurrent/ListenableFuture.html
+[FluentFuture]: https://google.github.io/guava/releases/23.6-jre/api/docs/com/google/common/util/concurrent/FluentFuture.html
+
+Dagger Producers introduces new annotations as follows.
+
+-   A new **module** annotation, `@ProducerModule`; that is, classes annotated
+    with this are modules.
+-   A new **binding** annotation, `@Produces`; that is, methods annotated with
+    this are bindings.
+-   Two new **component** annotations, `@ProductionComponent` and
+    `@ProductionSubcomponent`; that is, methods annotated with these are
+    components and subcomponents, respectively.
+-   Two new **Component builder** annotations corresponding to the new
+    components, `@ProductionComponent.Builder` and
+    `@ProductionSubcomponent.Builder`.
+-   Two new types `Producer<T>` and `Produced<T>`
+
+We disambiguate these types as follows:
+
+|            | Producer-related      | Non-producer         |
+| ---------- |:---------------------:| --------------------:|
+| Bindings   | production bindings   | provision bindings   |
+| Modules    | producer modules      | provider modules     |
+| Components | production components | provision components |
+
+Note: There's no reason behind the provider/provision or producer/production
+nomenclature distinctions.
+
+Provision bindings may not depend on production bindings because that would
+violate the semantics of provision bindings: they must be able to be executed
+inline, and cannot wait for asynchronous production dependencies to be ready.
+
+In particular, provision component entry points may not depend transitively on
+production bindings. This means that provision components cannot ever *use*
+production bindings; and so to avoid confusion, we forbid provision components
+from even referencing production bindings. We do this by:
+
+-   forbidding provider modules from having production bindings;
+-   forbidding provision components from using producer modules (and hence
+    containing production bindings);
+-   forbidding provision components from being subcomponents of (and hence
+    inheriting production bindings from) production components.
+
+## Signatures
+
+The **production executor** of a production component is a Java
+[executor][Executor] that is bound to the key `@Production Executor`. A
+production component must have a production executor bound via provision binding
+(not a production binding); because bindings are inherited in subcomponents,
+this binding must reside in the top-level production component, or even an
+provision component that is an ancestor of that. See [scope][#scope] for
+discussion of this binding's scope.
+
+The **signature** of a `@Produces` method is defined as follows:
+
+Suppose the declared key signature of the method is `(@R1 S1, ..., @Rn Sn) -> @Q
+T`.
+
+In addition to the normal unwrapping rules for `Provider` and `Lazy`, if `Si =
+Producer<Ti>` or `Si = Produced<Ti>` for some type `Ti`, then the `i`th argument
+in the signature is `@Ri Ti`; otherwise it's `@Ri Si`.
+
+Finally, the first argument in the signature is always `@Production Executor`,
+followed by the normal (transformed) arguments.
+
+The rules for the binding key are determined by whether the produces method is a
+multibinding or not:
+
+-   If it is a unique binding, with declared binding key `T = Future<U>`, for
+    some type `U`, then the binding key is `@Q U`; otherwise, it is `@Q T`.
+-   If it is a set binding with `@IntoSet`, with declared binding key `T =
+    Future<U>`, for some type `U`, then the binding key is `@Q Set<U>`;
+    otherwise, it is `@Q Set<T>`.
+-   If it is a set binding with `@ElementsIntoSet` with declared binding key
+    `T = Future<Set<U>>` or `T = Set<U>`, for some type `U`, then the binding
+    key is `@Q Set<U>`; otherwise, it is an error.
+-   If it is a set binding with `@IntoMap`, with declared binding key `T =
+    Future<U>`, for some type `U`, then the binding key is `@Q Map<K, U>`, where
+    `K` is computed as before; otherwise, it is `@Q Map<K, T>`.
+
+Here are some examples of signatures of `@Produces` methods:
+
+```java
+// signature = (@Production Executor, @Blue int, double) -> Foo
+@Produces Bar foo(@Blue Producer<Integer> i, double d) { ... }
+
+// signature = (@Production Executor, int, String) -> @Green Foo
+@Produces @Green Future<Foo> futureFoo(Produced<Integer> i, Lazy<String> s) { ... }
+
+// signature = (@Production Executor, Stub) -> Set<Bar>
+@Produces @IntoSet Future<Bar> bar(Stub stub) { ... }
+// signature = (@Production Executor) -> Set<Baz>
+@Produces @ElementsIntoSet Set<Future<Baz>> setOfFutureBaz() { ... }
+```
+
+Component dependencies for `@ProductionComponent` are treated similarly: if a
+component dependency `D` has a method that returns `@Q T`, and `T = Future<U>`
+for some type `U`, then its signature is `(D) -> @Q U`; otherwise, it is `(D) ->
+@Q T`.
+
+## Scope
+
+All production components and producer methods implicitly have
+`@ProductionScope` attached; that scope can be applied to any provision binding
+in a production component like any normal scope would. This scope is exempt from
+the rule that subcomponents may not have the same scope as their ancestor
+component.
+
+The `@Production Executor` is always treated like it has `@ProductionScope`
+applied, even if it does not.
+
+## Resolution and Runtime
+
+There are no changes to construction of the graph. However, there is one extra
+requirement: no provision binding may depend on a production binding; that is,
+there may not be a directed path from a production binding to a provision
+binding.
+
+At runtime, provision bindings are executed normally (that is, immediately when
+the graph traversal requires it). Production bindings, however, are submitted to
+the production executor rather than being executed inline.
+
+To do so, all of the production binding's inputs are collected (this process
+only happens when the binding's logic is ready to be executed, and hence all of
+its inputs have been computed) and partially applied to the binding's method.
+The resulting zero-arg function either has the signature `() -> T` or `() ->
+Future<T>`, depending on whether the original binding method returned a future
+or value. We unify these cases by composing the former signature with
+`immediateFuture: T -> Future<T>`.
+
+Now, this function `() -> Future<T>` is submitted to the executor. When the
+function is completed *and* the resulting future is done, graph execution
+proceeds with subsequent bindings that depend on this one.
+
+### Exceptions and `Produced`
+
+There are two ways a production binding method can throw an exception: either
+the method itself can throw, or it can return a future that fails with an
+exception. Dagger does not distinguish between these two ways of throwing an
+exception.
+
+If a production binding method throws an exception, it propagates to the entry
+point just like exceptions in provision binding methods do, subject to
+`Produced` injection (see below). Since production entry points are described by
+returning futures, the caller won't see an exception when calling the entry
+point; instead, the entry point's future will fail with the exception as its
+cause.
+
+Unlike with provision bindings, it is common for production binding methods to
+throw exceptions, since these often model error-prone tasks like network or disk
+reads.
+
+To support this programming model, Dagger provides the type `Produced`. If a
+binding method injects `@Q Produced<T>`, then Dagger will catch an exception
+thrown during the production of `@Q T` and save it. The method then can call
+`Produced#get()`, which either returns a successful `T` or throws an
+`ExecutionException` with the original exception as its cause (just like a
+failed future would).
+
+Note: Implementations of `Produced#get()` are expected not to block, and it
+leads to unspecified behavior if they do. This distinguishes it from
+`Future#get()`, which has the same return/throw semantics, but may block. Dagger
+ensures that the value or exception is available before constructing the
+`Produced` object, and hence `Produced#get()` can return or throw immediately.
+
+### Producer
+
+`Producer<T>` is the producers-analogue of `Provider<T>`; it defers all
+computation of the underlying binding until `Producer#get()` is called. There
+are three important things to note about this:
+
+1.  Because it defers all computation, the `Producer<T>` object itself is always
+    available immediately. Hence, it doesn't block submission of the binding
+    method to the executor.
+2.  Because `Producer<T>` represents an asynchronous computation, its `#get()`
+    method returns `Future<T>`, and hence does not block. However, calling
+    `Future#get()` on the resulting future *may* block! It's usually not a good
+    idea to ever block inside a producer method, and so typically client code
+    would just return this resulting future and let Dagger handle further
+    computation.
+3.  Unlike with `Provider` (see the [cycles section](#cycles)), Dagger does not
+    allow cycles to be broken by `Producer`.
+
+### Monitoring
+
+Recall that producers are intended to represent dependency graphs of
+computations; this means that a substantial portion of a program's execution
+might be in producer methods. These can be hard to profile using ordinary tools
+because of the asynchronous nature of producers: producer methods don't have
+their dependencies in the call stack, and time spent waiting for futures is hard
+to tie to the producer methods that depend on those futures.
+
+Dagger Producers provides a monitoring API to allow hooks into various aspects
+of producer execution.
+
+The core monitor type is `ProducerMonitor`, which monitors individual production
+binding methods. This class looks like:
+
+```java
+public abstract class ProducerMonitor {
+  public void requested() {}
+  public void ready() {}
+  public void methodStarting() {}
+  public void methodFinished() {}
+  public void succeeded(Object value) {}
+  public void failed(Throwable t) {}
+}
+```
+
+Clients may extend this class to perform actions at various places relating to
+the execution of an individual method. To do so, clients should implement the
+following related classes:
+
+```java
+public abstract class ProductionComponentMonitor {
+  public abstract ProducerMonitor producerMonitorFor(ProducerToken token);
+
+  public abstract static class Factory {
+    public abstract ProductionComponentMonitor create(Object component);
+  }
+}
+```
+
+For monitoring, Dagger treats the most ancestral production component as special
+(that is, a production component which is either top-level, or whose parent is a
+provision component). If, in this component, the multibinding key
+`Set<ProductionComponentMonitor.Factory>` is bound by provision bindings, then:
+
+-   these multibindings are treated as scoped to that component;
+-   a synthetic binding with signature
+
+    ```java
+    component, Set<ProductionComponentMonitor.Factory> -> @Production Set<ProductionComponentMonitor>
+    ```
+
+    is generated with the following behavior: each `Factory#create()` method is
+    called, passing the component instance; and the resulting
+    `ProductionComponentMonitor`s are collected into a set (ignoring null return
+    values). This binding is treated as scoped to the component;
+
+-   each production binding's signature is updated to have `@Production
+    Set<ProductionComponentMonitor>` as its first argument.
+
+Then, at the first point in the producer method's lifecycle (when the producer
+is "requested" - see below), each
+`ProductionComponentMonitor#producerMonitorFor()` method is called, and the
+resulting `ProducerMonitor`s are collected into a list (ignoring null return
+values; and of unspecified order). The `ProducerToken` passed to
+`#producerMonitorFor` is an opaque token that will be unique (w.r.t. `#equals()`
+and `#hashCode()`) per producer method, and hence could e.g. be used in a hash
+map.
+
+Finally, these `ProducerMonitor`s' methods will be called, either in order or in
+reverse order, at the various points of the producer method's lifecycle:
+
+-   `#requested`: called in order, the first time Dagger deduces that this
+    producer method needs to be run in order to satisfy a dependent binding
+    that's already been requested;
+-   `#ready`: called in order, when all inputs to the producer method are
+    available, right before scheduling the method on the executor;
+-   `#methodStarting`: called in order, right before the method is executed, on
+    the same thread as the method will be executed;
+-   `#methodFinished`: called in reverse order, right after the method is
+    executed, on the same thread as the method was executed;
+-   `#succeeded`: called in reverse order, when either the method (returning a
+    value) has finished executing without exception, or the method's future (if
+    it returned one) has finished successfully;
+-   `#failed`: called in reverse order, when either the method (returning a
+    value) has failed with exception, or the method's future (if it returned
+    one) has failed with exception.
+
+See the [javadoc][ProducerMonitor] for details, including more threading
+guarantees.
+
+[ProducerMonitor]: https://google.github.io/dagger/api/latest/dagger/producers/monitoring/ProducerMonitor.html
