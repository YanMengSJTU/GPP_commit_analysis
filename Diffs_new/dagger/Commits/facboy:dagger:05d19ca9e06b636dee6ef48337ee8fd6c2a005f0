diff --git a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
index b0a2df9c0..2ad1cd646 100644
--- a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
@@ -50,7 +50,8 @@ Expression getDependencyExpression(ClassName requestingClass) {
             componentRequirementFields.getExpression(componentRequirement(), requestingClass),
             binding.bindingElement().get().getSimpleName());
     return Expression.create(
-        binding.key().type(), maybeCheckForNull(binding, compilerOptions, invocation));
+        binding.contributedPrimitiveType().orElse(binding.key().type()),
+        maybeCheckForNull(binding, compilerOptions, invocation));
   }
 
   private ComponentRequirement componentRequirement() {
diff --git a/java/dagger/internal/codegen/Expression.java b/java/dagger/internal/codegen/Expression.java
index c38fd5795..b6d215c4e 100644
--- a/java/dagger/internal/codegen/Expression.java
+++ b/java/dagger/internal/codegen/Expression.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.squareup.javapoet.CodeBlock;
 import javax.lang.model.type.TypeMirror;
 
@@ -62,6 +63,16 @@ Expression castTo(TypeMirror newType) {
     return create(newType, "($T) $L", newType, codeBlock);
   }
 
+  /**
+   * Returns a new expression that {@link #castTo(TypeMirror)} casts the current expression to its
+   * boxed type if this expression has a primitive type.
+   */
+  Expression box(DaggerTypes types) {
+    return type.getKind().isPrimitive()
+        ? castTo(types.boxedClass(MoreTypes.asPrimitiveType(type)).asType())
+        : this;
+  }
+
   /** The {@link TypeMirror type} to which the expression evaluates. */
   TypeMirror type() {
     return type;
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index 9e615c9db..6c884fa75 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -98,7 +98,10 @@ private Expression invokeMethod(ClassName requestingClass) {
       default:
         throw new IllegalStateException();
     }
-    return Expression.create(provisionBinding.key().type(), invocation);
+
+    return Expression.create(
+        provisionBinding.contributedPrimitiveType().orElse(provisionBinding.key().type()),
+        invocation);
   }
 
   private TypeName constructorTypeName(ClassName requestingClass) {
diff --git a/java/dagger/internal/codegen/SwitchingProviders.java b/java/dagger/internal/codegen/SwitchingProviders.java
index fd706532c..4cb08f601 100644
--- a/java/dagger/internal/codegen/SwitchingProviders.java
+++ b/java/dagger/internal/codegen/SwitchingProviders.java
@@ -141,21 +141,11 @@ private Expression getExpression(ContributionBinding binding) {
     }
 
     private CodeBlock createSwitchCaseCodeBlock(ContributionBinding binding) {
-      Expression instanceExpression =
+      CodeBlock instanceCodeBlock =
           componentBindingExpressions
-              .getDependencyExpression(binding.key(), INSTANCE, owningComponent);
-
-      CodeBlock instanceCodeBlock = instanceExpression.codeBlock();
-
-      // Primitives cannot be cast directly to the method's parameterized type, T. We have to first
-      // cast them to their boxed type.
-      // TODO(user): Shouldn't we be able to rely soley on the instance expression type? However,
-      // that currently fails. Does that indicate that those dependency expression types are wrong?
-      if (binding.contributedPrimitiveType().isPresent()
-          || instanceExpression.type().getKind().isPrimitive()) {
-        TypeName boxedType = TypeName.get(binding.contributedType()).box();
-        instanceCodeBlock = CodeBlock.of("($T) $L", boxedType, instanceCodeBlock);
-      }
+              .getDependencyExpression(binding.key(), INSTANCE, owningComponent)
+              .box(types)
+              .codeBlock();
 
       return CodeBlock.builder()
           // TODO(user): Is there something else more useful than the key?
diff --git a/javatests/dagger/functional/BoxedPrimitives.java b/javatests/dagger/functional/BoxedPrimitives.java
new file mode 100644
index 000000000..adb61f22c
--- /dev/null
+++ b/javatests/dagger/functional/BoxedPrimitives.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Provider;
+
+interface BoxedPrimitives {
+  interface Dependency {
+    int primitive();
+  }
+
+  @Component(dependencies = Dependency.class)
+  interface ConsumesPrimitiveThroughDependency {
+    Provider<Integer> providerOfBoxedPrimitive();
+  }
+
+  @Module
+  class PrimitiveModule {
+    @Provides
+    static int providePrimitive() {
+      return 1;
+    }
+  }
+
+  @Component(modules = PrimitiveModule.class)
+  interface ConsumesPrimitiveFromProvidesMethod {
+    Provider<Integer> providerOfBoxedPrimitive();
+  }
+
+}
diff --git a/javatests/dagger/internal/codegen/ExpressionTest.java b/javatests/dagger/internal/codegen/ExpressionTest.java
index a8203796d..e6fe0d115 100644
--- a/javatests/dagger/internal/codegen/ExpressionTest.java
+++ b/javatests/dagger/internal/codegen/ExpressionTest.java
@@ -18,8 +18,12 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.google.auto.common.MoreTypes;
 import com.google.testing.compile.CompilationRule;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -28,11 +32,19 @@
 @RunWith(JUnit4.class)
 public class ExpressionTest {
   @Rule public CompilationRule compilationRule = new CompilationRule();
+  private DaggerElements elements;
+  private DaggerTypes types;
 
   interface Supertype {}
 
   interface Subtype extends Supertype {}
 
+  @Before
+  public void setUp() {
+    elements = new DaggerElements(compilationRule.getElements(), compilationRule.getTypes());
+    types = new DaggerTypes(compilationRule.getTypes(), elements);
+  }
+
   @Test
   public void castTo() {
     TypeMirror subtype = type(Subtype.class);
@@ -48,7 +60,19 @@ public void castTo() {
                 + "new dagger.internal.codegen.ExpressionTest.Subtype() {}");
   }
 
+  @Test
+  public void box() {
+    PrimitiveType primitiveInt = types.getPrimitiveType(TypeKind.INT);
+
+    Expression primitiveExpression = Expression.create(primitiveInt, "5");
+    Expression boxedExpression = primitiveExpression.box(types);
+
+    assertThat(boxedExpression.codeBlock().toString()).isEqualTo("(java.lang.Integer) 5");
+    assertThat(MoreTypes.equivalence().equivalent(boxedExpression.type(), type(Integer.class)))
+        .isTrue();
+  }
+
   private TypeMirror type(Class<?> clazz) {
-    return compilationRule.getElements().getTypeElement(clazz.getCanonicalName()).asType();
+    return elements.getTypeElement(clazz).asType();
   }
 }
