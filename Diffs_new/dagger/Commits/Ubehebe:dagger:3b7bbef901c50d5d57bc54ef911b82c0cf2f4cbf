diff --git a/java/dagger/internal/codegen/CodeBlocks.java b/java/dagger/internal/codegen/CodeBlocks.java
index ab4d90ffa..bc8fccd90 100644
--- a/java/dagger/internal/codegen/CodeBlocks.java
+++ b/java/dagger/internal/codegen/CodeBlocks.java
@@ -25,57 +25,29 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.CodeBlock.Builder;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import java.util.stream.Collector;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 
 final class CodeBlocks {
-  /**
-   * A {@link Collector} implementation that joins {@link CodeBlock} instances together into one
-   * separated by {@code delimiter}. For example, joining {@code String s}, {@code Object o} and
-   * {@code int i} using {@code ", "} would produce {@code String s, Object o, int i}.
-   */
-  static Collector<CodeBlock, ?, CodeBlock> joiningCodeBlocks(String delimiter) {
-    return Collector.of(
-        () -> new CodeBlockJoiner(delimiter, CodeBlock.builder()),
-        CodeBlockJoiner::add,
-        CodeBlockJoiner::merge,
-        CodeBlockJoiner::join);
-  }
-
   /**
    * Joins {@link CodeBlock} instances in a manner suitable for use as method parameters (or
-   * arguments). This is equivalent to {@code joiningCodeBlocks(", ")}.
+   * arguments).
    */
   static Collector<CodeBlock, ?, CodeBlock> toParametersCodeBlock() {
-    return joiningCodeBlocks(", ");
-  }
-
-  /**
-   * Joins {@link TypeName} instances into a {@link CodeBlock} that is a comma-separated list for
-   * use as type parameters or javadoc method arguments.
-   */
-  static Collector<TypeName, ?, CodeBlock> toTypeNamesCodeBlock() {
-    return Collector.of(
-        () -> new CodeBlockJoiner(", ", CodeBlock.builder()),
-        CodeBlockJoiner::addTypeName,
-        CodeBlockJoiner::merge,
-        CodeBlockJoiner::join);
+    // TODO(ronshapiro,jakew): consider adding zero-width spaces to help line breaking when the
+    // formatter is off. If not, inline this
+    return CodeBlock.joining(", ");
   }
 
-  /**
-   * Concatenates {@link CodeBlock} instances separated by newlines for readability. This is
-   * equivalent to {@code joiningCodeBlocks("\n")}.
-   */
+  /** Concatenates {@link CodeBlock} instances separated by newlines for readability. */
   static Collector<CodeBlock, ?, CodeBlock> toConcatenatedCodeBlock() {
-    return joiningCodeBlocks("\n");
+    return CodeBlock.joining("\n", "", "\n");
   }
 
   /** Returns a comma-separated version of {@code codeBlocks} as one unified {@link CodeBlock}. */
@@ -83,6 +55,14 @@ static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
     return stream(codeBlocks.spliterator(), false).collect(toParametersCodeBlock());
   }
 
+  /**
+   * Returns one unified {@link CodeBlock} which joins each item in {@code codeBlocks} with a
+   * newline.
+   */
+  static CodeBlock concat(Iterable<CodeBlock> codeBlocks) {
+    return stream(codeBlocks.spliterator(), false).collect(toConcatenatedCodeBlock());
+  }
+
   /** Adds an annotation to a method. */
   static void addAnnotation(MethodSpec.Builder method, DeclaredType nullableType) {
     method.addAnnotation(ClassName.get(MoreTypes.asTypeElement(nullableType)));
@@ -111,57 +91,8 @@ static CodeBlock cast(CodeBlock expression, Class<?> castTo) {
     return CodeBlock.of("($T) $L", castTo, expression);
   }
 
-  private static final class CodeBlockJoiner {
-    private final String delimiter;
-    private final CodeBlock.Builder builder;
-    private boolean first = true;
-
-    CodeBlockJoiner(String delimiter, Builder builder) {
-      this.delimiter = delimiter;
-      this.builder = builder;
-    }
-
-    @CanIgnoreReturnValue
-    CodeBlockJoiner add(CodeBlock codeBlock) {
-      maybeAddDelimiter();
-      builder.add(codeBlock);
-      return this;
-    }
-
-    @CanIgnoreReturnValue
-    CodeBlockJoiner addTypeName(TypeName typeName) {
-      maybeAddDelimiter();
-      builder.add("$T", typeName);
-      return this;
-    }
-
-    private void maybeAddDelimiter() {
-      if (!first) {
-        builder.add(delimiter);
-      }
-      first = false;
-    }
-
-    @CanIgnoreReturnValue
-    CodeBlockJoiner merge(CodeBlockJoiner other) {
-      CodeBlock otherBlock = other.builder.build();
-      if (!otherBlock.isEmpty()) {
-        add(otherBlock);
-      }
-      return this;
-    }
-
-    CodeBlock join() {
-      return builder.build();
-    }
-  }
-
-  /**
-   * Returns one unified {@link CodeBlock} which joins each item in {@code codeBlocks} with a
-   * newline.
-   */
-  static CodeBlock concat(Iterable<CodeBlock> codeBlocks) {
-    return stream(codeBlocks.spliterator(), false).collect(toConcatenatedCodeBlock());
+  static CodeBlock type(TypeMirror type) {
+    return CodeBlock.of("$T", type);
   }
 
   static CodeBlock stringLiteral(String toWrap) {
@@ -195,10 +126,8 @@ static CodeBlock javadocLinkTo(ExecutableElement executableElement) {
         executableElement
             .getParameters()
             .stream()
-            .map(VariableElement::asType)
-            .map(TypeName::get)
-            .map(TypeNames::rawTypeName)
-            .collect(toTypeNamesCodeBlock()));
+            .map(parameter -> CodeBlock.of("$T", rawTypeName(TypeName.get(parameter.asType()))))
+            .collect(toParametersCodeBlock()));
     return builder.add(")}").build();
   }
 
diff --git a/java/dagger/internal/codegen/MemberSelect.java b/java/dagger/internal/codegen/MemberSelect.java
index 0dd9170e9..cad733c73 100644
--- a/java/dagger/internal/codegen/MemberSelect.java
+++ b/java/dagger/internal/codegen/MemberSelect.java
@@ -18,7 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.CodeBlocks.toTypeNamesCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
@@ -34,7 +34,6 @@
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
 import java.util.List;
 import java.util.Optional;
@@ -210,7 +209,7 @@ CodeBlock getExpressionFor(ClassName usingClass) {
         return CodeBlock.of(
             "$T.<$L>$L",
             owningClass(),
-            typeParameters.stream().map(TypeName::get).collect(toTypeNamesCodeBlock()),
+            typeParameters.stream().map(CodeBlocks::type).collect(toParametersCodeBlock()),
             methodCodeBlock);
       } else {
         return CodeBlock.of("(($T) $T.$L)", rawReturnType, owningClass(), methodCodeBlock);
diff --git a/javatests/dagger/internal/codegen/CodeBlocksTest.java b/javatests/dagger/internal/codegen/CodeBlocksTest.java
index 43507c9ea..ec8df912a 100644
--- a/javatests/dagger/internal/codegen/CodeBlocksTest.java
+++ b/javatests/dagger/internal/codegen/CodeBlocksTest.java
@@ -18,7 +18,6 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static dagger.internal.codegen.CodeBlocks.javadocLinkTo;
-import static dagger.internal.codegen.CodeBlocks.joiningCodeBlocks;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static javax.lang.model.element.ElementKind.METHOD;
 
@@ -64,12 +63,6 @@ public void testToParametersCodeBlock_oneElement() {
     assertThat(Stream.of(objectO).collect(toParametersCodeBlock())).isEqualTo(objectO);
   }
 
-  @Test
-  public void testJoiningCodeBlocks() {
-    assertThat(Stream.of(objectO, stringS, intI).collect(joiningCodeBlocks("!")))
-        .isEqualTo(CodeBlock.of("$T o!$T s!$T i", Object.class, String.class, int.class));
-  }
-
   @Test
   public void testJavadocLinkTo() {
     ExecutableElement equals =
