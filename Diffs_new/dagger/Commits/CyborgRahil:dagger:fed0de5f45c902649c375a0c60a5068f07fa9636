diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index 711e88856..2aaea2565 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -180,8 +180,8 @@ static ConfigureInitializationMethod create(
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
   private final List<CodeBlock> initializations = new ArrayList<>();
-  private final Map<ComponentRequirement, CodeBlock> componentRequirementInitializations =
-      new LinkedHashMap<>();
+  private final Set<ComponentRequirement> componentRequirementParameters = new HashSet<>();
+  private final List<CodeBlock> componentRequirementInitializations = new ArrayList<>();
   private final Map<ComponentRequirement, String> componentRequirementParameterNames =
       new HashMap<>();
   private final Set<Key> cancellableProducerKeys = new LinkedHashSet<>();
@@ -476,12 +476,24 @@ void addInitialization(CodeBlock codeBlock) {
   }
 
   /**
-   * Adds the given code block that initializes the given {@link ComponentRequirement} to the
-   * component implementation.
+   * Adds the given component requirement as one that should have a parameter in the component's
+   * initialization methods.
    */
-  void addComponentRequirementInitialization(
-      ComponentRequirement requirement, CodeBlock codeBlock) {
-    componentRequirementInitializations.put(requirement, codeBlock);
+  void addComponentRequirementParameter(ComponentRequirement requirement) {
+    componentRequirementParameters.add(requirement);
+  }
+
+  /**
+   * The set of component requirements that have parameters in the component's initialization
+   * methods.
+   */
+  ImmutableSet<ComponentRequirement> getComponentRequirementParameters() {
+    return ImmutableSet.copyOf(componentRequirementParameters);
+  }
+
+  /** Adds the given code block that initializes a {@link ComponentRequirement}. */
+  void addComponentRequirementInitialization(CodeBlock codeBlock) {
+    componentRequirementInitializations.add(codeBlock);
   }
 
   /**
@@ -542,7 +554,7 @@ void claimMethodName(CharSequence name) {
   }
 
   /**
-   * Returns the map of {@link ComponentRequirement}s to {@link CodeBlock}s that initialize them.
+   * Returns a list of {@link CodeBlock}s for initializing {@link ComponentRequirement}s.
    *
    * <p>These initializations are kept separate from {@link #getInitializations()} because they must
    * be executed before the initializations of any framework instance initializations in a
@@ -551,8 +563,8 @@ void claimMethodName(CharSequence name) {
    * {@link dagger.producers.internal.DelegateProducer} since the types of these initialized fields
    * have no interface type that we can write a proxy for.
    */
-  ImmutableMap<ComponentRequirement, CodeBlock> getComponentRequirementInitializations() {
-    return ImmutableMap.copyOf(componentRequirementInitializations);
+  ImmutableList<CodeBlock> getComponentRequirementInitializations() {
+    return ImmutableList.copyOf(componentRequirementInitializations);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index 678637528..63d1758cb 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -388,8 +388,7 @@ private void implementInitializationMethod(
       ImmutableMap<ComponentRequirement, ParameterSpec> initializationParameters) {
     initializationMethod.addParameters(initializationParameters.values());
     initializationMethod.addCode(
-        CodeBlocks.concat(
-            componentImplementation.getComponentRequirementInitializations().values()));
+        CodeBlocks.concat(componentImplementation.getComponentRequirementInitializations()));
     componentImplementation
         .superConfigureInitializationMethod()
         .ifPresent(
@@ -587,14 +586,14 @@ private void addInitializeMethods(
    * {@code configureInitialization} method.
    */
   private ImmutableSet<ComponentRequirement> configureInitializationRequirements() {
-    ImmutableSet<ComponentRequirement> initializationRequirements =
-        componentImplementation.getComponentRequirementInitializations().keySet();
+    ImmutableSet<ComponentRequirement> initializationParameters =
+        componentImplementation.getComponentRequirementParameters();
     ImmutableSet<ComponentRequirement> superConfigureInitializationRequirements =
         componentImplementation
             .superConfigureInitializationMethod()
             .map(ConfigureInitializationMethod::parameters)
             .orElse(ImmutableSet.of());
-    return Sets.union(initializationRequirements, superConfigureInitializationRequirements)
+    return Sets.union(initializationParameters, superConfigureInitializationRequirements)
         .immutableCopy();
   }
 
diff --git a/java/dagger/internal/codegen/ComponentRequirementExpressions.java b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
index df2ef39c7..dc75be84d 100644
--- a/java/dagger/internal/codegen/ComponentRequirementExpressions.java
+++ b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
@@ -149,9 +149,9 @@ private ComponentRequirementExpression createField(ComponentRequirement requirem
   }
 
   private abstract static class AbstractField implements ComponentRequirementExpression {
-    private final ComponentRequirement componentRequirement;
-    protected final ComponentImplementation componentImplementation;
-    protected final String fieldName;
+    final ComponentRequirement componentRequirement;
+    final ComponentImplementation componentImplementation;
+    final String fieldName;
     private final Supplier<MemberSelect> field = memoize(this::addField);
 
     private AbstractField(
@@ -179,8 +179,7 @@ public CodeBlock getExpression(ClassName requestingClass) {
     private MemberSelect addField() {
       FieldSpec field = createField();
       componentImplementation.addField(COMPONENT_REQUIREMENT_FIELD, field);
-      componentImplementation.addComponentRequirementInitialization(
-          componentRequirement, fieldInitialization(field));
+      componentImplementation.addComponentRequirementInitialization(fieldInitialization(field));
       return MemberSelect.localField(componentImplementation.name(), fieldName);
     }
 
@@ -232,6 +231,7 @@ private ComponentParameterField(
         ComponentImplementation componentImplementation,
         String name) {
       super(componentRequirement, componentImplementation);
+      componentImplementation.addComponentRequirementParameter(componentRequirement);
       // Get the name that the component implementation will use for its parameter for the
       // requirement. If the given name is different than the name of the field created for the
       // requirement (as may be the case when the parameter name is derived from a user-written
@@ -242,8 +242,7 @@ private ComponentParameterField(
       // weird where the component actually has fields named, say, "foo" and "fooParam".
       this.name =
           componentImplementation.getParameterName(
-              componentRequirement,
-              name.equals(fieldName) ? name + "Param" : name);
+              componentRequirement, name.equals(fieldName) ? name + "Param" : name);
     }
 
     @Override
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 0581ddeac..14ecc2bb1 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -4974,6 +4974,67 @@ public void multipleComponentMethodsForSameBindingRequest() {
         .containsElementsIn(generatedRoot);
   }
 
+  @Test
+  public void boundInstanceUsedOnlyInInitialize() {
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Subcomponent;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent",
+            "interface Sub {",
+            "  Provider<String> stringProvider();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    @BindsInstance",
+            "    Builder string(String string);",
+            "    Sub build();",
+            "  }",
+            "}");
+
+    JavaFileObject generated  =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.Preconditions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerSub implements Sub {",
+            "  private Provider<String> stringProvider;",
+            "",
+            "  protected DaggerSub() {}",
+            "",
+            "  protected void configureInitialization(String stringParam) {",
+            "    initialize(stringParam);",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final String stringParam) {",
+            "    this.stringProvider = InstanceFactory.create(stringParam);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<String> stringProvider() {",
+            "    return stringProvider;",
+            "  }",
+            "}");
+
+    Compilation compilation = compile(ImmutableList.of(subcomponent));
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSub")
+        .containsElementsIn(generated);
+  }
+
   // TODO(ronshapiro): remove copies from AheadOfTimeSubcomponents*Test classes
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
