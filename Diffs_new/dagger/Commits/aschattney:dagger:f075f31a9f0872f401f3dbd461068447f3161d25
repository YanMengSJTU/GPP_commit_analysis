diff --git a/android-testcase/pom.xml b/android-testcase/pom.xml
index 05f9937d3..d1e570fd8 100644
--- a/android-testcase/pom.xml
+++ b/android-testcase/pom.xml
@@ -67,6 +67,10 @@
             <version>24.2.0</version>
             <scope>provided</scope>
         </dependency>
+        <dependency>
+            <groupId>javax.inject</groupId>
+            <artifactId>javax.inject</artifactId>
+        </dependency>
     </dependencies>
 
     <build>
diff --git a/android-testcase/src/main/java/dagger/android/testcase/Apply.java b/android-testcase/src/main/java/dagger/android/testcase/Apply.java
new file mode 100644
index 000000000..c21df58aa
--- /dev/null
+++ b/android-testcase/src/main/java/dagger/android/testcase/Apply.java
@@ -0,0 +1,190 @@
+package dagger.android.testcase;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+
+import javax.inject.Qualifier;
+
+public class Apply {
+
+    public static void decorationsOf(final Object obj, Object app) {
+        final Field[] declaredFields = obj.getClass().getDeclaredFields();
+        for (final Field declaredField : declaredFields) {
+            if (declaredField.isAnnotationPresent(Replace.class) || hasMockAnnotation(declaredField)) {
+                declaredField.setAccessible(true);
+                final Annotation[] annotations = declaredField.getAnnotations();
+                String component = "";
+                for (Annotation a : annotations) {
+                    if (a.annotationType().getSimpleName().startsWith("In")) {
+                        component = a.annotationType().getSimpleName().substring(2);
+                        break;
+                    }
+                }
+                if (component.equals("")) {
+                    continue;
+                }
+                String name = String.valueOf(component.charAt(0)).toLowerCase() +
+                        component.substring(1);
+                final String field = name + "DecoratorImpl";
+                final Field decoratorImplField = getDeclaredField(app, field);
+                if (decoratorImplField != null) {
+                    decoratorImplField.setAccessible(true);
+                    final Class<?> declaredFieldClass = declaredField.getType();
+                    if (declaredFieldClass != null) {
+                        String methodName = getWithMethodName(declaredField);
+                        final Class<?> clazz = classForName(getDelegateType(declaredField));
+                        final Class<?> decoratorImplClass = decoratorImplField.getType();
+                        final Method declaredMethod = getDeclaredMethod(decoratorImplClass, methodName, clazz);
+                        if (declaredMethod != null) {
+                            final ClassLoader cl = obj.getClass().getClassLoader();
+                            final Object o = Proxy.newProxyInstance(cl, new Class<?>[]{clazz}, new InvocationHandler() {
+                                @Override
+                                public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
+                                    if (method.getName().equals("get")) {
+                                        return declaredField.get(obj);
+                                    }else {
+                                        return method.invoke(o, objects);
+                                    }
+                                }
+                            });
+                            try
+                            {
+                                invoke(decoratorImplField.get(app), declaredMethod, o);
+                            } catch (IllegalAccessException e) {
+                                e.printStackTrace();
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private static boolean hasMockAnnotation(Field declaredField) {
+        final Annotation[] annotations = declaredField.getAnnotations();
+        for (Annotation annotation : annotations) {
+            if (annotation.annotationType().getName().equals("org.mockito.Mock")) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static String getDelegateType(Field declaredField) {
+        final StringBuilder sb = new StringBuilder("delegates.");
+        final Annotation qualifier = findQualifier(declaredField);
+        if (qualifier != null) {
+            try
+            {
+                final Method[] methods = qualifier.annotationType().getDeclaredMethods();
+                if (methods.length > 0 && methods[0].getName().equals("value")) {
+                    String identifier = String.valueOf(methods[0].invoke(qualifier));
+                    identifier = String.valueOf(identifier.charAt(0)).toUpperCase() +  identifier.substring(1);
+                    sb.append(qualifier.annotationType().getSimpleName());
+                    sb.append(identifier);
+                }
+            } catch (IllegalAccessException e)
+            {
+                e.printStackTrace();
+            } catch (InvocationTargetException e)
+            {
+                e.printStackTrace();
+            }
+        }else {
+            sb.append(declaredField.getType().getSimpleName()).toString();
+        }
+        return sb.append("Delegate").toString();
+    }
+
+    private static String  getWithMethodName(Field declaredField) {
+        final StringBuilder sb = new StringBuilder("with");
+        final Annotation qualifier = findQualifier(declaredField);
+        if (qualifier != null) {
+            try
+            {
+                final Method[] methods = qualifier.annotationType().getDeclaredMethods();
+                if (methods.length > 0 && methods[0].getName().equals("value")) {
+                    String identifier = String.valueOf(methods[0].invoke(qualifier));
+                    identifier = String.valueOf(identifier.charAt(0)).toUpperCase() +  identifier.substring(1);
+                    sb.append(qualifier.annotationType().getSimpleName());
+                    sb.append(identifier);
+                }
+            } catch (IllegalAccessException e)
+            {
+                e.printStackTrace();
+            } catch (InvocationTargetException e)
+            {
+                e.printStackTrace();
+            }
+        }else {
+            sb.append(declaredField.getType().getSimpleName());
+        }
+        return sb.toString();
+    }
+
+    private static Annotation findQualifier(Field declaredField) {
+        final Annotation[] declaredAnnotations = declaredField.getDeclaredAnnotations();
+        for (Annotation declaredAnnotation : declaredAnnotations)
+        {
+            for (Annotation annotation : declaredAnnotation.annotationType()
+                                                           .getDeclaredAnnotations()) {
+                if (annotation.annotationType().equals(Qualifier.class)) {
+                    return declaredAnnotation;
+                }
+            }
+        }
+        return null;
+    }
+
+    private static Object invoke(Object instance, Method declaredMethod, Object o) {
+        try
+        {
+            return declaredMethod.invoke(instance, o);
+        } catch (IllegalAccessException e)
+        {
+            e.printStackTrace();
+        } catch (InvocationTargetException e)
+        {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    private static Method getDeclaredMethod(Class<?> aClass, String methodName, Class<?>... params) {
+
+        try
+        {
+            return aClass.getDeclaredMethod(methodName, params);
+        } catch (NoSuchMethodException e)
+        {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    private static Class<?> classForName(String name){
+        try
+        {
+            return Class.forName(name);
+        } catch (ClassNotFoundException e)
+        {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    private static Field getDeclaredField(Object app, String field) {
+        try
+        {
+            return app.getClass().getDeclaredField(field);
+        } catch (NoSuchFieldException e)
+        {
+            e.printStackTrace();
+        }
+        return null;
+    }
+}
diff --git a/android-testcase/src/main/java/dagger/android/testcase/Replace.java b/android-testcase/src/main/java/dagger/android/testcase/Replace.java
new file mode 100644
index 000000000..b45daba15
--- /dev/null
+++ b/android-testcase/src/main/java/dagger/android/testcase/Replace.java
@@ -0,0 +1,16 @@
+package dagger.android.testcase;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.CONSTRUCTOR;
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target({FIELD})
+@Documented
+public @interface Replace {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationGenerator.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationGenerator.java
new file mode 100644
index 000000000..2699fb88c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationGenerator.java
@@ -0,0 +1,63 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.util.Elements;
+import java.io.IOException;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.List;
+import java.util.Optional;
+
+public class AnnotationGenerator extends SourceFileGenerator<BindingGraph> {
+
+    private final TestRegistry testRegistry;
+
+    AnnotationGenerator(Filer filer, Elements elements, TestRegistry testRegistry) {
+        super(filer, elements);
+        this.testRegistry = testRegistry;
+    }
+
+    @Override
+    ClassName nameGeneratedType(BindingGraph input) {
+        final String componentName = input.componentDescriptor().componentDefinitionType().getSimpleName().toString();
+        return ClassName.bestGuess("dagger.annotation.In" + componentName);
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(BindingGraph input) {
+        return Optional.empty();
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, BindingGraph input) {
+        final TypeSpec.Builder builder = TypeSpec.annotationBuilder(generatedTypeName)
+                .addModifiers(Modifier.PUBLIC)
+                .addAnnotation(Documented.class)
+                .addAnnotation(AnnotationSpec.builder(Retention.class)
+                        .addMember("value", "$T.$L", RetentionPolicy.class, RetentionPolicy.RUNTIME)
+                        .build());
+        return Optional.of(builder);
+    }
+
+    @Override
+    void generate(BindingGraph input) throws SourceFileGenerationException {
+        ClassName generatedTypeName = nameGeneratedType(input);
+        Optional<TypeSpec.Builder> type = write(generatedTypeName, input);
+        if (!type.isPresent()) {
+            return;
+        }
+        final ClassName className = nameGeneratedType(input);
+        try {
+            testRegistry.addEncodedClass(className, buildJavaFile(className, type.get()));
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index e6071baf9..2416313e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -261,7 +261,8 @@ public SourceVersion getSupportedSourceVersion() {
                 new DependencySpecGenerator(filer, elements, componentDescriptorFactory, bindingGraphFactory),
                 provisionBindingFactory,
                 new ApplicationGenerator(filer, types, elements, bindingGraphFactory, componentDescriptorFactory),
-                stubGenerator
+                stubGenerator,
+                new AnnotationGenerator(filer, elements, testRegistry)
         )
     );
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
index d405383b7..f0c0e7f85 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
@@ -30,6 +30,7 @@
     private StubGenerator stubGenerator;
     private HashSet<TypeElement> components = new HashSet<>();
     private DecoratorGenerator decoratorGenerator;
+    private AnnotationGenerator annotationGenerator;
 
     public InjectorProcessingStep(Types types, Messager messager,
                                   AppConfig.Provider appConfigProvider,
@@ -42,7 +43,8 @@ public InjectorProcessingStep(Types types, Messager messager,
                                   DependencySpecGenerator dependencySpecGenerator,
                                   ProvisionBinding.Factory provisionBindingFactory,
                                   ApplicationGenerator applicationGenerator,
-                                  StubGenerator stubGenerator) {
+                                  StubGenerator stubGenerator,
+                                  AnnotationGenerator annotationGenerator) {
         this.types = types;
         this.messager = messager;
         this.appConfigProvider = appConfigProvider;
@@ -57,6 +59,7 @@ public InjectorProcessingStep(Types types, Messager messager,
         this.applicationGenerator = applicationGenerator;
         this.stubGenerator = stubGenerator;
         this.decoratorGenerator = decoratorGenerator;
+        this.annotationGenerator = annotationGenerator;
     }
 
     @Override
@@ -90,6 +93,7 @@ public InjectorProcessingStep(Types types, Messager messager,
             for (TypeElement component : components) {
                 final ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(component);
                 final BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+                this.createAnnotations(bindingGraph);
                 final ImmutableSet<ComponentDescriptor> componentDescriptors = bindingGraph.componentDescriptors();
                 componentDescriptors
                         .stream()
@@ -120,4 +124,11 @@ public InjectorProcessingStep(Types types, Messager messager,
         return rejectedElements;
     }
 
+    private void createAnnotations(BindingGraph bindingGraph) {
+        annotationGenerator.generate(bindingGraph, messager);
+        for (BindingGraph graph : bindingGraph.subgraphs()) {
+            this.createAnnotations(graph);
+        }
+    }
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorType.java b/compiler/src/main/java/dagger/internal/codegen/InjectorType.java
index 860a96420..5dee83f30 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorType.java
@@ -2,9 +2,6 @@
 
 import javax.lang.model.element.TypeElement;
 
-/**
- * Created by Andy on 05.05.2017.
- */
 public class InjectorType {
 
     private TypeElement element;
diff --git a/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java b/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
index 4397f32d9..b4ffa15cd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
@@ -14,13 +14,9 @@
 
 import static com.google.common.io.ByteStreams.toByteArray;
 
-/**
- * Created by Andy on 07.05.2017.
- */
 public class TestRegistry {
 
     private List<EncodedClass> encodedClasses = new ArrayList<>();
-    private boolean debug = false;
 
     public void addEncodedClass(ClassName className, JavaFile javaFile) throws IOException {
         final JavaFileObject javaFileObject = javaFile.toJavaFileObject();
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 294cebbd5..318a523ca 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -842,7 +842,7 @@ public static ClassName getDaggerComponentClassName(Element component) {
 
     public static final String METHOD_NAME_GET_INJECTOR = "getInjector";
     public static final ClassName TYPENAME_INJECTOR = ClassName.bestGuess("injector.Injector");
-    public static final String SIMPLE_NAME_INJECTOR_APPLICATION = "DaggerHookApplication";
+    public static final String SIMPLE_NAME_INJECTOR_APPLICATION = "DecoratorApplication";
     public static final String FIELDNAME_INJECTOR = "injector";
     public static final ClassName TYPENAME_INJECTOR_SPEC = ClassName.bestGuess("injector.InjectorSpec");
     public static final ClassName TYPENAME_ANDROID_APPLICATION = ClassName.bestGuess("android.app.Application");
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java b/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java
index 9a03e132a..46b36562f 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java
@@ -5,9 +5,6 @@
 
 import javax.inject.Named;
 
-/**
- * Created by Andy on 04.05.2017.
- */
 @Module
 public abstract class SingletonModule {
 
diff --git a/examples/simple/src/main/java/coffee/AModule.java b/examples/simple/src/main/java/coffee/AModule.java
index af10c2a89..2b99c3ebc 100644
--- a/examples/simple/src/main/java/coffee/AModule.java
+++ b/examples/simple/src/main/java/coffee/AModule.java
@@ -3,9 +3,7 @@
 import dagger.Module;
 import dagger.Provides;
 
-/**
- * Created by Andy on 06.05.2017.
- */
+
 @Module(subcomponents = CoffeeApp.Bleu2.class)
 public class AModule {
 
diff --git a/examples/simple/src/main/java/coffee/BModule.java b/examples/simple/src/main/java/coffee/BModule.java
index 4973ccea3..b5577e5d9 100644
--- a/examples/simple/src/main/java/coffee/BModule.java
+++ b/examples/simple/src/main/java/coffee/BModule.java
@@ -3,9 +3,6 @@
 import dagger.Module;
 import dagger.Provides;
 
-/**
- * Created by Andy on 06.05.2017.
- */
 @Module
 public class BModule {
 
