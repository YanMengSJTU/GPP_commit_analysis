diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 914fb2426..0354caf45 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -198,6 +198,7 @@ java_library(
     srcs = [
         "BindingGraphValidationModule.java",
         "DuplicateBindingsValidation.java",
+        "IncompatiblyScopedBindingsValidation.java",
         "InjectBindingValidation.java",
         "MapMultibindingValidation.java",
         "MembersInjectionBindingValidation.java",
diff --git a/java/dagger/internal/codegen/BindingGraphValidationModule.java b/java/dagger/internal/codegen/BindingGraphValidationModule.java
index fc231522b..54c245a1f 100644
--- a/java/dagger/internal/codegen/BindingGraphValidationModule.java
+++ b/java/dagger/internal/codegen/BindingGraphValidationModule.java
@@ -30,6 +30,11 @@
   @Validation
   BindingGraphPlugin duplicateBindings(DuplicateBindingsValidation validation);
 
+  @Binds
+  @IntoSet
+  @Validation
+  BindingGraphPlugin incompatiblyScopedBindings(IncompatiblyScopedBindingsValidation validation);
+
   @Binds
   @IntoSet
   @Validation
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index 95eb167a2..2727da473 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -41,13 +41,10 @@
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toSet;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import dagger.BindsOptionalOf;
 import dagger.Component;
@@ -111,10 +108,6 @@
     final Map<ComponentDescriptor, ValidationReport.Builder<TypeElement>> reports =
         new LinkedHashMap<>();
 
-    /** Bindings whose scopes are not compatible with the component that owns them. */
-    private final SetMultimap<ComponentDescriptor, ContributionBinding> incompatiblyScopedBindings =
-        LinkedHashMultimap.create();
-
     ComponentValidation(BindingGraph rootGraph) {
       super(rootGraph);
       this.rootGraph = rootGraph;
@@ -149,7 +142,6 @@ protected void visitComponent(BindingGraph graph) {
       validateModules(graph);
       validateBuilders(graph);
       super.visitComponent(graph);
-      checkScopedBindings(graph);
     }
 
     @Override
@@ -470,71 +462,6 @@ private void validateDependencyScopeHierarchy(
       return false;
     }
 
-    /**
-     * Collects scoped bindings that are not compatible with their owning component for later
-     * reporting by {@link #checkScopedBindings(BindingGraph)}.
-     */
-    private void checkBindingScope(
-        ContributionBinding binding, ComponentDescriptor owningComponent) {
-      if (binding.scope().isPresent()
-          && !binding.scope().get().isReusable()
-          && !owningComponent.scopes().contains(binding.scope().get())) {
-        incompatiblyScopedBindings.put(owningComponent, binding);
-      }
-    }
-
-    /**
-     * Reports an error if any of the scoped bindings owned by a given component are incompatible
-     * with the component. Must be called after all bindings owned by the given component have been
-     * {@linkplain #checkBindingScope(ContributionBinding, ComponentDescriptor) visited}.
-     */
-    private void checkScopedBindings(BindingGraph graph) {
-      if (!incompatiblyScopedBindings.containsKey(graph.componentDescriptor())) {
-        return;
-      }
-
-      StringBuilder message = new StringBuilder(graph.componentType().getQualifiedName());
-      if (!graph.componentDescriptor().scopes().isEmpty()) {
-        message.append(" scoped with ");
-        for (Scope scope : graph.componentDescriptor().scopes()) {
-          message.append(getReadableSource(scope)).append(' ');
-        }
-        message.append("may not reference bindings with different scopes:\n");
-      } else {
-        message.append(" (unscoped) may not reference scoped bindings:\n");
-      }
-      for (ContributionBinding binding :
-          incompatiblyScopedBindings.get(graph.componentDescriptor())) {
-        message.append(INDENT);
-
-        switch (binding.kind()) {
-          case DELEGATE:
-          case PROVISION:
-            message.append(
-                methodSignatureFormatter.format(
-                    MoreElements.asExecutable(binding.bindingElement().get())));
-            break;
-
-          case INJECTION:
-            message
-                .append(getReadableSource(binding.scope().get()))
-                .append(" class ")
-                .append(binding.bindingTypeElement().get().getQualifiedName());
-            break;
-
-          default:
-            throw new AssertionError(binding);
-        }
-
-        message.append("\n");
-      }
-      report(graph)
-          .addError(
-              message.toString(),
-              graph.componentType(),
-              graph.componentDescriptor().componentAnnotation());
-    }
-
     final class BindingGraphValidation extends BindingGraphTraverser {
 
       BindingGraphValidation(
@@ -569,7 +496,6 @@ protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
       @Override
       protected void visitContributionBinding(
           ContributionBinding binding, ComponentDescriptor owningComponent) {
-        checkBindingScope(binding, owningComponent);
         if (compilerOptions.usesProducers()) {
           // TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
           // Only the Dagger-specific binding may depend on the production executor.
diff --git a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidation.java b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidation.java
new file mode 100644
index 000000000..0a1c708ff
--- /dev/null
+++ b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidation.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.DaggerElements.closestEnclosingTypeElement;
+import static dagger.internal.codegen.Formatter.INDENT;
+import static dagger.internal.codegen.Scopes.getReadableSource;
+import static java.util.stream.Collectors.joining;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Multimaps;
+import dagger.model.Binding;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.ComponentNode;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.Set;
+import javax.inject.Inject;
+
+/**
+ * Reports an error for any component that uses bindings with scopes that are not assigned to the
+ * component.
+ */
+final class IncompatiblyScopedBindingsValidation implements BindingGraphPlugin {
+
+  private final MethodSignatureFormatter methodSignatureFormatter;
+
+  @Inject
+  IncompatiblyScopedBindingsValidation(MethodSignatureFormatter methodSignatureFormatter) {
+    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/IncompatiblyScopedBindings";
+  }
+
+  @Override
+  public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    ImmutableSetMultimap.Builder<ComponentNode, BindingNode> incompatibleBindingNodes =
+        ImmutableSetMultimap.builder();
+    for (BindingNode bindingNode : bindingGraph.bindingNodes()) {
+      bindingNode
+          .binding()
+          .scope()
+          .ifPresent(
+              scope -> {
+                if (scope.isReusable()) {
+                  return;
+                }
+                ComponentNode componentNode =
+                    bindingGraph.componentNode(bindingNode.componentPath()).get();
+                if (!componentNode.scopes().contains(scope)) {
+                  incompatibleBindingNodes.put(componentNode, bindingNode);
+                }
+              });
+    }
+    Multimaps.asMap(incompatibleBindingNodes.build())
+        .forEach(
+            (componentNode, bindingNodes) ->
+                diagnosticReporter.reportComponent(
+                    ERROR,
+                    componentNode,
+                    incompatibleBindingScopesError(componentNode, bindingNodes)));
+  }
+
+  private String incompatibleBindingScopesError(
+      ComponentNode componentNode, Set<BindingNode> bindingNodes) {
+    StringBuilder message =
+        new StringBuilder(componentNode.componentPath().currentComponent().getQualifiedName());
+    if (!componentNode.scopes().isEmpty()) {
+      message
+          .append(" scoped with ")
+          .append(
+              componentNode.scopes().stream().map(Scopes::getReadableSource).collect(joining(" ")))
+          .append(" may not reference bindings with different scopes:\n");
+    } else {
+      message.append(" (unscoped) may not reference scoped bindings:\n");
+    }
+    // TODO(ronshapiro): Should we group by scope?
+    for (BindingNode bindingNode : bindingNodes) {
+      message.append(INDENT);
+
+      Binding binding = bindingNode.binding();
+      switch (binding.kind()) {
+        case DELEGATE:
+        case PROVISION:
+          message.append(
+              methodSignatureFormatter.format(
+                  MoreElements.asExecutable(binding.bindingElement().get())));
+          break;
+
+        case INJECTION:
+          message
+              .append(getReadableSource(binding.scope().get()))
+              .append(" class ")
+              .append(
+                  closestEnclosingTypeElement(binding.bindingElement().get()).getQualifiedName());
+          break;
+
+        default:
+          throw new AssertionError(bindingNode);
+      }
+
+      message.append("\n");
+    }
+    return message.toString();
+  }
+}
