diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index a13c98164..ad1d288b3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen.writer;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.BiMap;
@@ -36,6 +37,9 @@
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
 import javax.tools.JavaFileObject;
 
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -97,7 +101,7 @@ public InterfaceWriter addInterface(String simpleName) {
     return writer;
   }
 
-  public Appendable write(Appendable appendable) throws IOException {
+  public Appendable write(Appendable appendable, Iterable<? extends Element> originatingElements) throws IOException {
     if (!packageName.isEmpty()) {
       appendable.append("package ").append(packageName).append(";\n\n");
     }
@@ -135,6 +139,13 @@ public Appendable write(Appendable appendable) throws IOException {
     ImmutableSet<String> declaredSimpleNames = declaredSimpleNamesBuilder.build();
 
     BiMap<String, ClassName> importedClassIndex = HashBiMap.create();
+
+    for (ClassName className : enclosedTypes(originatingElements)) {
+      if (!declaredSimpleNames.contains(className.simpleName())) {
+        importedClassIndex.put(className.simpleName(), className);
+      }
+    }
+
     for (ClassName className : importCandidates) {
       if (!(className.packageName().equals(packageName)
               && !className.enclosingClassName().isPresent())
@@ -166,6 +177,23 @@ public Appendable write(Appendable appendable) throws IOException {
     return appendable;
   }
 
+  /**
+   * This extracts any types enclosed by any originating element for the
+   * purpose of namespace collision avoidance.
+   */
+  static Iterable<ClassName> enclosedTypes(Iterable<? extends Element> originatingElements) {
+    ImmutableSet.Builder<ClassName> enclosedTypes = ImmutableSet.builder();
+    for (TypeElement originatingElement : ElementFilter.typesIn(originatingElements)) {
+      for (TypeElement enclosedType : ElementFilter.typesIn(originatingElement.getEnclosedElements())) {
+        enclosedTypes.add(ClassName.fromTypeElement(enclosedType));
+      }
+      for (TypeMirror interfaceMirror : originatingElement.getInterfaces()) {
+        enclosedTypes.addAll(enclosedTypes(MoreTypes.referencedTypes(interfaceMirror)));
+      }
+    }
+    return enclosedTypes.build();
+  }
+
   public void file(Filer filer, Iterable<? extends Element> originatingElements)
       throws IOException {
     file(filer, Iterables.getOnlyElement(typeWriters).name.canonicalName(), originatingElements);
@@ -177,7 +205,7 @@ public void file(Filer filer, CharSequence name,  Iterable<? extends Element> or
         Iterables.toArray(originatingElements, Element.class));
     Closer closer = Closer.create();
     try {
-      write(closer.register(sourceFile.openWriter()));
+      write(closer.register(sourceFile.openWriter()), originatingElements);
     } catch (Exception e) {
       try {
         sourceFile.delete();
@@ -193,7 +221,7 @@ public void file(Filer filer, CharSequence name,  Iterable<? extends Element> or
   @Override
   public String toString() {
     try {
-      return write(new StringBuilder()).toString();
+      return write(new StringBuilder(), ImmutableSet.<Element>of()).toString();
     } catch (IOException e) {
       throw new AssertionError();
     }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index c5841c8db..7fea23b04 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -1838,4 +1838,274 @@ public void genericTestToLetMeDebugInEclipse() {
          .compilesWithoutError()
          .and().generatesSources(generatedComponent);
    }
+
+  @Test public void nameCollision_componentReturnTypeWithEnclosedTypeInSuper() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "final class SomeInjectableType {",
+        "  @javax.inject.Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject superType = JavaFileObjects.forSourceLines("test.Supertype",
+        "package test;",
+        "",
+        "interface Supertype {",
+        "  interface SomeInjectableType{}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "@dagger.Component",
+        "interface SimpleComponent extends Supertype {",
+        "  test.SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "",
+        "  private void initialize(final Builder builder) {}",
+        "",
+        "  @Override",
+        "  public test.SomeInjectableType someInjectableType() {", // Return type is qualified!
+        "    return SomeInjectableType_Factory.create().get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(
+        injectableTypeFile, superType, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void nameCollision_componentEnclosedTypeWithReturnTypeInSuper() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "final class SomeInjectableType {",
+        "  @javax.inject.Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject superType = JavaFileObjects.forSourceLines("test.Supertype",
+        "package test;",
+        "",
+        "interface Supertype {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    // Generated code should see the name conflict and fully-qualify the component's return type.
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "@dagger.Component",
+        "interface SimpleComponent extends Supertype {",
+        "  interface SomeInjectableType{}",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {}",
+        "",
+        "  @Override",
+        "  public test.SomeInjectableType someInjectableType() {", // Return type is qualified!
+        "    return SomeInjectableType_Factory.create().get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(
+        injectableTypeFile, superType, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void nameCollision_componentEnclosedTypeWithProvidedType() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Module",
+        "package test;",
+        "",
+        "@dagger.Module class Module {",
+        "  @dagger.Provides java.nio.Buffer internal() {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ComponentWithEnclosedType",
+        "package test;",
+        "",
+        "@dagger.Component(modules = Module.class)",
+        "interface ComponentWithEnclosedType { ",
+        "",
+        "  class Buffer {",
+        "    @javax.inject.Inject Buffer(java.nio.Buffer b) {}",
+        "  }",
+        "",
+        "  Buffer buffer(); ",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerComponentWithEnclosedType",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.ComponentWithEnclosedType;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerComponentWithEnclosedType implements ComponentWithEnclosedType {",
+        "  private Provider<java.nio.Buffer> internalProvider;", // Qualified to avoid ambiguity.
+        "  private Provider<Buffer> bufferProvider;",
+        "",
+        "  private DaggerComponentWithEnclosedType(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static ComponentWithEnclosedType create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.internalProvider = Module_InternalFactory.create(builder.module);",
+        "    this.bufferProvider = ComponentWithEnclosedType$Buffer_Factory.create(internalProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public Buffer buffer() {",
+        "    return bufferProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Module module;",
+        "  ",
+        "    private Builder() {",
+        "    }",
+        "  ",
+        "    public ComponentWithEnclosedType build() {",
+        "      if (module == null) {",
+        "        this.module = new Module();",
+        "      }",
+        "      return new DaggerComponentWithEnclosedType(this);",
+        "    }",
+        "  ",
+        "    public Builder module(Module module) {",
+        "      if (module == null) {",
+        "        throw new NullPointerException(\"module\");",
+        "      }",
+        "      this.module = module;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    JavaFileObject generatedInternalTypeFactory = JavaFileObjects.forSourceLines("test.Module_InternalFactory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import java.nio.Buffer;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Module_InternalFactory implements Factory<Buffer> {",
+        "  private final Module module;",
+        "",
+        "  public Module_InternalFactory(Module module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override",
+        "  public Buffer get() {", // No ambiguity in this file.
+        "    Buffer provided = module.internal();",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(\"Cannot return null from a non-@Nullable @Provides method\");",
+        "    }",
+        "    return provided;",
+        "  }",
+        "",
+        "  public static Factory<Buffer> create(Module module) {",
+        "    return new Module_InternalFactory(module);",
+        "  }",
+        "}");
+    JavaFileObject generatedEnclosedTypeFactory = JavaFileObjects.forSourceLines("test.ComponentWithEnclosedType$Buffer_Factory",
+        "package test;",
+        "",
+        "import dagger.internal.Factory;",
+        "import java.nio.Buffer;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.ComponentWithEnclosedType;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class ComponentWithEnclosedType$Buffer_Factory implements Factory<ComponentWithEnclosedType.Buffer> {",
+        "  private final Provider<Buffer> bProvider;",
+        "",
+        "  public ComponentWithEnclosedType$Buffer_Factory(Provider<Buffer> bProvider) {",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public ComponentWithEnclosedType.Buffer get() {", // Qualified to avoid ambiguity.
+        "    return new ComponentWithEnclosedType.Buffer(bProvider.get());",
+        "  }",
+        "",
+        "  public static Factory<ComponentWithEnclosedType.Buffer> create(Provider<Buffer> bProvider) {",
+        "    return new ComponentWithEnclosedType$Buffer_Factory(bProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent, generatedInternalTypeFactory, generatedEnclosedTypeFactory);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java
index e775f7487..b314ef277 100644
--- a/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java
@@ -15,19 +15,64 @@
  */
 package dagger.internal.codegen.writer;
 
+import com.google.testing.compile.CompilationRule;
+import java.io.IOException;
+import java.util.Collections;
+import javax.lang.model.element.Element;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assert_;
 
 @RunWith(JUnit4.class)
 public class JavaWriterTest {
-  @Test public void referencedAndDeclaredSimpleName() {
+
+  @Test public void referencedAndDeclaredSimpleName() throws IOException {
     JavaWriter javaWriter = JavaWriter.inPackage("test");
     ClassWriter topClass = javaWriter.addClass("Top");
     topClass.addNestedClass("Middle").addNestedClass("Bottom");
     topClass.addField(ClassName.create("some.other.pkg", "Bottom"), "field");
-    assertThat(topClass.toString()).doesNotContain("import some.other.pkg.Bottom;");
+
+    String source = javaWriter.write(new StringBuilder(), Collections.<Element>emptySet()).toString();
+
+    assert_().that(source).contains("some.other.pkg.Bottom field;");
+  }
+
+  @Rule public final CompilationRule compilation = new CompilationRule();
+
+  interface Top {
+    interface Foo {
+    }
+  }
+
+  interface Middle extends Top {
+    interface Foo {
+    }
+  }
+
+  interface Bottom extends Middle {
+    interface Foo {
+    }
+  }
+
+  @Test public void enclosedTypes() {
+    assert_().that(JavaWriter.enclosedTypes(originatingElements(Top.class)))
+        .containsExactly(className(Top.Foo.class));
+
+    assert_().that(JavaWriter.enclosedTypes(originatingElements(Middle.class)))
+        .containsExactly(className(Middle.Foo.class), className(Top.Foo.class));
+
+    assert_().that(JavaWriter.enclosedTypes(originatingElements(Bottom.class)))
+        .containsExactly(className(Bottom.Foo.class), className(Middle.Foo.class), className(Top.Foo.class));
+  }
+
+  private Iterable<? extends Element> originatingElements(Class<?> clazz) {
+    return Collections.singleton(compilation.getElements().getTypeElement(clazz.getCanonicalName()));
+  }
+
+  private ClassName className(Class clazz) {
+    return ClassName.bestGuessFromString(clazz.getCanonicalName());
   }
 }
