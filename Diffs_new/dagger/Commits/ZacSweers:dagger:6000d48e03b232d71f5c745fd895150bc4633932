diff --git a/java/dagger/internal/codegen/ComponentCreatorDescriptor.java b/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
index cd7c7780e..f5ac8c214 100644
--- a/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
@@ -55,21 +55,21 @@
    */
   abstract ImmutableSetMultimap<ComponentRequirement, ExecutableElement> requirementElements();
 
-  /** Returns the set of component requirements for this creator. */
-  final ImmutableSet<ComponentRequirement> requirements() {
+  /** Returns the set of component requirements this creator can set. */
+  final ImmutableSet<ComponentRequirement> settableRequirements() {
     return requirementElements().keySet();
   }
 
   /** Returns the set of requirements for modules and component dependencies for this creator. */
   final ImmutableSet<ComponentRequirement> moduleAndDependencyRequirements() {
-    return requirements().stream()
+    return settableRequirements().stream()
         .filter(requirement -> !requirement.isBoundInstance())
         .collect(toImmutableSet());
   }
 
   /** Returns the set of bound instance requirements for this creator. */
   final ImmutableSet<ComponentRequirement> boundInstanceRequirements() {
-    return requirements().stream()
+    return settableRequirements().stream()
         .filter(requirement -> requirement.isBoundInstance())
         .collect(toImmutableSet());
   }
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementation.java b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
index 45340ca89..4a5d218ba 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementation.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
@@ -18,7 +18,9 @@
 
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.TypeSpec;
 
 /** The implementation of a component creator type. */
@@ -27,22 +29,34 @@
 
   /** Creates a new {@link ComponentCreatorImplementation}. */
   static ComponentCreatorImplementation create(
-      TypeSpec componentCreatorClass,
+      TypeSpec spec,
       ClassName name,
-      ImmutableMap<ComponentRequirement, String> requirementNames) {
-    return new AutoValue_ComponentCreatorImplementation(
-        componentCreatorClass, name, requirementNames);
+      ImmutableSet<ComponentRequirement> providedRequirements,
+      ImmutableMap<ComponentRequirement, FieldSpec> fields) {
+    return new AutoValue_ComponentCreatorImplementation(spec, name, providedRequirements, fields);
   }
 
-  /** The type for the creator implementation. */
-  abstract TypeSpec componentCreatorClass();
+  /** The type spec for the creator implementation. */
+  abstract TypeSpec spec();
 
   /** The name of the creator implementation class. */
   abstract ClassName name();
 
   /**
-   * The names to use for fields or parameters for the requirements this creator implementation
-   * provides.
+   * The component requirements this creator provides instances for when calling the component's
+   * constructor.
+   *
+   * <p>Instances will be passed to the  constructor in the same order the requirements are returned
+   * here.
    */
-  abstract ImmutableMap<ComponentRequirement, String> requirementNames();
+  abstract ImmutableSet<ComponentRequirement> providedRequirements();
+
+  /**
+   * All fields that are present in this implementation or its supertype.
+   *
+   * <p>In the case of ahead-of-time subcomponents, not all fields will necessarily be passed to
+   * the component's constructor (because, for example, it turns out that a particular module that
+   * the creator can set is actually inherited from an ancestor module).
+   */
+  abstract ImmutableMap<ComponentRequirement, FieldSpec> fields();
 }
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
index 542ece6d8..ad1b70c23 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
@@ -87,58 +87,30 @@
     return Optional.of(builder.build());
   }
 
-  private static ImmutableMap<ComponentRequirement, String> requirementNames(
-      ComponentImplementation componentImplementation) {
-    // If the base implementation's creator is being generated in ahead-of-time-subcomponents
-    // mode, this uses possiblyNecessaryRequirements() since Dagger doesn't know what modules may
-    // end up being unused. Otherwise, we use the necessary component requirements.
-    ImmutableSet<ComponentRequirement> requirements =
-        componentImplementation.isAbstract()
-                && !componentImplementation.superclassImplementation().isPresent()
-            ? componentImplementation.graph().possiblyNecessaryRequirements()
-            : componentImplementation.graph().componentRequirements();
-
-    if (componentImplementation.baseImplementation().isPresent()) {
-      // If there's a base implementation, retain the same names for the requirements, but filter
-      // for currently used component requirements.
-      ComponentCreatorImplementation baseCreatorImplementation =
-          componentImplementation.baseImplementation().get().creatorImplementation().get();
-      return ImmutableMap.copyOf(
-          Maps.filterKeys(baseCreatorImplementation.requirementNames(), requirements::contains));
-    }
-
-    UniqueNameSet names = new UniqueNameSet();
-    return Maps.toMap(requirements, requirement -> names.getUniqueName(requirement.variableName()));
-  }
-
+  /** Base class for building a creator implementation. */
   private abstract class Builder {
     final ComponentImplementation componentImplementation;
-    final TypeSpec.Builder componentCreatorClass;
-    private final ImmutableMap<ComponentRequirement, String> requirementNames;
+    final ClassName className;
+    final TypeSpec.Builder classBuilder;
+
+    private ImmutableMap<ComponentRequirement, FieldSpec> fields;
 
     Builder(ComponentImplementation componentImplementation) {
       this.componentImplementation = componentImplementation;
-      this.componentCreatorClass = classBuilder(componentImplementation.getCreatorName());
-      this.requirementNames = requirementNames(componentImplementation);
+      this.className = componentImplementation.getCreatorName();
+      this.classBuilder = classBuilder(className);
     }
 
     /** Builds the {@link ComponentCreatorImplementation}. */
     ComponentCreatorImplementation build() {
       setModifiers();
       setSupertype();
-      addFields();
+      this.fields = getOrAddFields();
       addConstructor();
       addSetterMethods();
       addFactoryMethod();
       return ComponentCreatorImplementation.create(
-          componentCreatorClass.build(),
-          componentImplementation.getCreatorName(),
-          requirementNames);
-    }
-
-    /** Returns the name of the creator class being generated. */
-    final ClassName className() {
-      return componentImplementation.getCreatorName();
+          classBuilder.build(), className, providedRequirements(), fields);
     }
 
     /** Returns the binding graph for the component. */
@@ -146,24 +118,24 @@ final BindingGraph graph() {
       return componentImplementation.graph();
     }
 
-    /** Returns the {@link ComponentRequirement}s that are actually required by the component. */
-    final ImmutableSet<ComponentRequirement> componentRequirements() {
-      return requirementNames.keySet();
-    }
-
     /**
-     * Returns whether the given {@code requirement} is for a module type owned by the component.
+     * The component requirements that this creator will actually provide when constructing a
+     * component.
      */
-    final boolean isOwnedModule(ComponentRequirement requirement) {
-      return graph().ownedModuleTypes().contains(requirement.typeElement());
+    final ImmutableSet<ComponentRequirement> providedRequirements() {
+      return Sets.intersection(fields.keySet(), componentImplementation.requirements())
+          .immutableCopy();
     }
 
-    private final void setModifiers() {
-      componentCreatorClass.addModifiers(visibility());
+    /** The {@link ComponentRequirement}s that this creator can set. */
+    abstract ImmutableMap<ComponentRequirement, RequirementStatus> settableRequirements();
+
+    private void setModifiers() {
+      classBuilder.addModifiers(visibility());
       if (!componentImplementation.isNested()) {
-        componentCreatorClass.addModifiers(STATIC);
+        classBuilder.addModifiers(STATIC);
       }
-      componentCreatorClass.addModifiers(componentImplementation.isAbstract() ? ABSTRACT : FINAL);
+      classBuilder.addModifiers(componentImplementation.isAbstract() ? ABSTRACT : FINAL);
     }
 
     /** Returns the visibility modifier the generated class should have. */
@@ -175,43 +147,55 @@ private final void setModifiers() {
     /** Adds a constructor for the creator type, if needed. */
     protected abstract void addConstructor();
 
-    private void addFields() {
-      if (!componentImplementation.baseImplementation().isPresent()) {
-        componentRequirements().stream()
-            .map(this::toFieldSpec)
-            .forEach(componentCreatorClass::addField);
-      }
+    private ImmutableMap<ComponentRequirement, FieldSpec> getOrAddFields() {
+      // If a base implementation is present, any fields are already defined there and don't need to
+      // be created in this implementation.
+      return componentImplementation
+        .baseCreatorImplementation()
+        .map(ComponentCreatorImplementation::fields)
+        .orElseGet(() -> addFields());
     }
 
-    private FieldSpec toFieldSpec(ComponentRequirement requirement) {
+    private ImmutableMap<ComponentRequirement, FieldSpec> addFields() {
       // Fields in an abstract creator class need to be visible from subclasses.
       Modifier modifier = componentImplementation.isAbstract() ? PROTECTED : PRIVATE;
-      return FieldSpec.builder(
-              TypeName.get(requirement.type()), requirementNames.get(requirement), modifier)
-          .build();
+      UniqueNameSet fieldNames = new UniqueNameSet();
+      ImmutableMap<ComponentRequirement, FieldSpec> result =
+          Maps.toMap(
+              componentImplementation.requirements(),
+              requirement ->
+                  FieldSpec.builder(
+                          TypeName.get(requirement.type()),
+                          fieldNames.getUniqueName(requirement.variableName()),
+                          modifier)
+                      .build());
+      classBuilder.addFields(result.values());
+      return result;
     }
 
     private void addSetterMethods() {
-      setterMethodRequirements().stream()
-          .map(this::createSetterMethod)
-          .forEach(componentCreatorClass::addMethod);
+      settableRequirements()
+          .forEach(
+              (requirement, status) ->
+                  createSetterMethod(requirement, status).ifPresent(classBuilder::addMethod));
     }
 
-    /** The set of requirements that need a setter method. */
-    protected abstract ImmutableSet<ComponentRequirement> setterMethodRequirements();
-
     /** Creates a new setter method builder, with no method body, for the given requirement. */
-    protected abstract MethodSpec.Builder setterMethodBuilder(
-        ComponentRequirement requirement);
-
-    private MethodSpec createSetterMethod(ComponentRequirement requirement) {
-      if (componentRequirements().contains(requirement)) {
-        return normalSetterMethod(requirement);
-      } else if (isOwnedModule(requirement)) {
-        return noopSetterMethod(requirement);
-      } else {
-        return inheritedModuleSetterMethod(requirement);
+    protected abstract MethodSpec.Builder setterMethodBuilder(ComponentRequirement requirement);
+
+    private Optional<MethodSpec> createSetterMethod(
+        ComponentRequirement requirement, RequirementStatus status) {
+      switch (status) {
+        case NEEDED:
+          return Optional.of(normalSetterMethod(requirement));
+        case UNNEEDED:
+          return Optional.of(noopSetterMethod(requirement));
+        case UNSETTABLE_REPEATED_MODULE:
+          return Optional.of(repeatedModuleSetterMethod(requirement));
+        case IMPLEMENTED_IN_SUPERTYPE:
+          return Optional.empty();
       }
+      throw new AssertionError();
     }
 
     private MethodSpec normalSetterMethod(ComponentRequirement requirement) {
@@ -219,7 +203,7 @@ private MethodSpec normalSetterMethod(ComponentRequirement requirement) {
       ParameterSpec parameter = parameter(method.build());
       method.addStatement(
           "this.$N = $L",
-          requirementNames.get(requirement),
+          fields.get(requirement),
           requirement.nullPolicy(elements, types).equals(NullPolicy.ALLOW)
               ? CodeBlock.of("$N", parameter)
               : CodeBlock.of("$T.checkNotNull($N)", Preconditions.class, parameter));
@@ -238,7 +222,7 @@ private MethodSpec noopSetterMethod(ComponentRequirement requirement) {
       return maybeReturnThis(method);
     }
 
-    private MethodSpec inheritedModuleSetterMethod(ComponentRequirement requirement) {
+    private MethodSpec repeatedModuleSetterMethod(ComponentRequirement requirement) {
       return setterMethodBuilder(requirement)
           .addStatement(
               "throw new $T($T.format($S, $T.class.getCanonicalName()))",
@@ -262,7 +246,7 @@ private MethodSpec maybeReturnThis(MethodSpec.Builder method) {
 
     private void addFactoryMethod() {
       if (!componentImplementation.isAbstract()) {
-        componentCreatorClass.addMethod(factoryMethod());
+        classBuilder.addMethod(factoryMethod());
       }
     }
 
@@ -270,9 +254,9 @@ MethodSpec factoryMethod() {
       MethodSpec.Builder factoryMethod = factoryMethodBuilder();
       factoryMethod.returns(ClassName.get(graph().componentTypeElement())).addModifiers(PUBLIC);
 
-      componentRequirements().forEach(
+      providedRequirements().forEach(
           requirement -> {
-            FieldSpec field = toFieldSpec(requirement);
+            FieldSpec field = fields.get(requirement);
             switch (requirement.nullPolicy(elements, types)) {
               case NEW:
                 checkState(requirement.kind().isModule());
@@ -307,8 +291,9 @@ MethodSpec factoryMethod() {
     protected abstract MethodSpec.Builder factoryMethodBuilder();
 
     private CodeBlock componentConstructorArgs() {
-      return componentRequirements().stream()
-          .map(requirement -> CodeBlock.of("$L", requirementNames.get(requirement)))
+      return providedRequirements().stream()
+          .map(fields::get)
+          .map(field -> CodeBlock.of("$N", field))
           .collect(toParametersCodeBlock());
     }
   }
@@ -323,6 +308,11 @@ private CodeBlock componentConstructorArgs() {
           componentImplementation.componentDescriptor().creatorDescriptor().get();
     }
 
+    @Override
+    protected ImmutableMap<ComponentRequirement, RequirementStatus> settableRequirements() {
+      return Maps.toMap(creatorDescriptor.settableRequirements(), this::requirementStatus);
+    }
+
     @Override
     protected Modifier visibility() {
       if (componentImplementation.isAbstract()) {
@@ -338,10 +328,10 @@ protected Modifier visibility() {
     protected void setSupertype() {
       if (componentImplementation.baseImplementation().isPresent()) {
         // If there's a superclass, extend the creator defined there.
-        componentCreatorClass.superclass(
+        classBuilder.superclass(
             componentImplementation.baseImplementation().get().getCreatorName());
       } else {
-        addSupertype(componentCreatorClass, creatorDescriptor.typeElement());
+        addSupertype(classBuilder, creatorDescriptor.typeElement());
       }
     }
 
@@ -360,31 +350,43 @@ protected void addConstructor() {
           .addAnnotation(Override.class);
     }
 
-    @Override
-    protected ImmutableSet<ComponentRequirement> setterMethodRequirements() {
-      return ImmutableSet.copyOf(
-          Sets.filter(creatorDescriptor.requirements(), this::requiresSetterMethod));
+    private RequirementStatus requirementStatus(ComponentRequirement requirement) {
+      // In ahead-of-time subcomponents mode, all builder methods are defined at the base
+      // implementation. The only case where a method needs to be overridden is for a repeated
+      // module, which is unknown at the point when a base implementation is generated. We do this
+      // at the root for simplicity (and as an aside, repeated modules are never used in google
+      // as of 11/28/18, and thus the additional cost of including these methods at the root is
+      // negligible).
+      if (isRepeatedModule(requirement)) {
+        return RequirementStatus.UNSETTABLE_REPEATED_MODULE;
+      }
+
+      if (hasBaseCreatorImplementation()) {
+        return RequirementStatus.IMPLEMENTED_IN_SUPERTYPE;
+      }
+
+      return componentImplementation.requirements().contains(requirement)
+          ? RequirementStatus.NEEDED
+          : RequirementStatus.UNNEEDED;
     }
 
-    private boolean requiresSetterMethod(ComponentRequirement requirement) {
-      // TODO(cgdecker): Document this better; it does what was being done before, but this
-      // explanation is lacking.
-      // We generate a method that throws UOE for an inherited module regardless of whether there's
-      // a base creator implementation or not.
-      return !hasBaseCreatorImplementation() || isInheritedModule(requirement);
+    /**
+     * Returns whether the given requirement is for a repeat of a module inherited from an ancestor
+     * component. This creator is not allowed to set such a module.
+     */
+    final boolean isRepeatedModule(ComponentRequirement requirement) {
+      return !componentImplementation.requirements().contains(requirement)
+          && !isOwnedModule(requirement);
     }
 
-    private boolean isInheritedModule(ComponentRequirement requirement) {
-      return !componentRequirements().contains(requirement) && !isOwnedModule(requirement);
+    /**
+     * Returns whether the given {@code requirement} is for a module type owned by the component.
+     */
+    private boolean isOwnedModule(ComponentRequirement requirement) {
+      return graph().ownedModuleTypes().contains(requirement.typeElement());
     }
 
     private boolean hasBaseCreatorImplementation() {
-      // In ahead-of-time subcomponents mode, all builder methods are defined at the base
-      // implementation. The only case where a method needs to be overridden is for a repeated
-      // module, which is unknown at the point when a base implementation is generated. We do this
-      // at the root for simplicity (and as an aside, repeated modules are never used in google
-      // as of 11/28/18, and thus the additional cost of including these methods at the root is
-      // negligible).
       return !componentImplementation.isAbstract()
           && componentImplementation.baseImplementation().isPresent();
     }
@@ -398,7 +400,7 @@ private boolean hasBaseCreatorImplementation() {
       if (!supertypeMethod.getReturnType().getKind().equals(TypeKind.VOID)) {
         // Take advantage of covariant returns so that we don't have to worry about setter methods
         // that return type variables.
-        method.returns(className());
+        method.returns(className);
       }
       return method;
     }
@@ -413,6 +415,15 @@ private boolean hasBaseCreatorImplementation() {
       super(componentImplementation);
     }
 
+    @Override
+    protected ImmutableMap<ComponentRequirement, RequirementStatus> settableRequirements() {
+      return Maps.toMap(
+          graph().componentDescriptor().dependenciesAndConcreteModules(),
+          requirement -> componentImplementation.requirements().contains(requirement)
+              ? RequirementStatus.NEEDED
+              : RequirementStatus.UNNEEDED);
+    }
+
     @Override
     protected Modifier visibility() {
       return PUBLIC;
@@ -425,7 +436,7 @@ protected void setSupertype() {
 
     @Override
     protected void addConstructor() {
-      componentCreatorClass.addMethod(constructorBuilder().addModifiers(PRIVATE).build());
+      classBuilder.addMethod(constructorBuilder().addModifiers(PRIVATE).build());
     }
 
     @Override
@@ -433,18 +444,39 @@ protected void addConstructor() {
       return methodBuilder("build");
     }
 
-    @Override
-    protected ImmutableSet<ComponentRequirement> setterMethodRequirements() {
-      return graph().componentDescriptor().dependenciesAndConcreteModules();
-    }
-
     @Override
     protected MethodSpec.Builder setterMethodBuilder(ComponentRequirement requirement) {
       String name = simpleVariableName(requirement.typeElement());
       return methodBuilder(name)
           .addModifiers(PUBLIC)
           .addParameter(TypeName.get(requirement.type()), name)
-          .returns(className());
+          .returns(className);
     }
   }
+
+  /** Enumeration of statuses a component requirement may have in a creator. */
+  enum RequirementStatus {
+    /** An instance is needed to create the component. */
+    NEEDED,
+
+    /**
+     * An instance is not needed to create the component, but the requirement is for a module owned
+     * by the component. Setting the requirement is a no-op and any setter method should be marked
+     * deprecated on the generated type as a warning to the user.
+     */
+    UNNEEDED,
+
+    /**
+     * The requirement may not be set in this creator because the module it is for is already
+     * inherited from an ancestor component. Any setter method for it should throw an exception.
+     */
+    UNSETTABLE_REPEATED_MODULE,
+
+    /**
+     * The requirement is settable by the creator, but the setter method implementation already
+     * exists in a supertype.
+     */
+    IMPLEMENTED_IN_SUPERTYPE,
+    ;
+  }
 }
diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index 2aaea2565..05307919b 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -306,6 +306,21 @@ boolean isAbstract() {
     return Optional.empty();
   }
 
+  /**
+   * The possible requirements for creating an instance of this component implementation type.
+   *
+   * <p>If this component implementation is concrete, these requirements will be in the order that
+   * the implementation's constructor takes them as parameters.
+   */
+  ImmutableSet<ComponentRequirement> requirements() {
+    // If the base implementation's creator is being generated in ahead-of-time-subcomponents
+    // mode, this uses possiblyNecessaryRequirements() since Dagger doesn't know what modules may
+    // end up being unused. Otherwise, we use the necessary component requirements.
+    return isAbstract() && !superclassImplementation().isPresent()
+        ? graph().possiblyNecessaryRequirements()
+        : graph().componentRequirements();
+  }
+
   /**
    * Returns the {@link MethodSpecKind#CONFIGURE_INITIALIZATION_METHOD} of this implementation if
    * there is one.
@@ -336,6 +351,14 @@ void setCreatorImplementation(Optional<ComponentCreatorImplementation> creatorIm
     return creatorImplementation;
   }
 
+  /**
+   * Returns the {@link ComponentCreatorImplementation} defined in the base implementation for this
+   * component, if one exists.
+   */
+  Optional<ComponentCreatorImplementation> baseCreatorImplementation() {
+    return baseImplementation().flatMap(baseImpl -> baseImpl.creatorImplementation());
+  }
+
   /**
    * Returns the name of the creator class for this component. It will be a sibling of this
    * generated class unless this is a top-level component, in which case it will be nested.
diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index 63d1758cb..1532c2c8a 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -117,7 +117,7 @@ final ComponentImplementation build() {
         componentCreatorImplementationFactory.create(componentImplementation));
     componentImplementation
         .creatorImplementation()
-        .map(ComponentCreatorImplementation::componentCreatorClass)
+        .map(ComponentCreatorImplementation::spec)
         .ifPresent(this::addCreatorClass);
 
     getLocalAndInheritedMethods(graph.componentTypeElement(), types, elements)
@@ -551,14 +551,14 @@ private void addInitializeMethods(
     Optional<ComponentCreatorImplementation> creatorImplementation =
         Optionals.firstPresent(
             componentImplementation.creatorImplementation(),
-            componentImplementation.baseImplementation().flatMap(c -> c.creatorImplementation()));
+            componentImplementation.baseCreatorImplementation());
 
     Map<ComponentRequirement, ParameterSpec> parameters;
     if (creatorImplementation.isPresent()) {
       parameters =
-          Maps.transformEntries(
-              creatorImplementation.get().requirementNames(),
-              (requirement, name) -> requirement.toParameterSpec(name));
+          Maps.toMap(
+              creatorImplementation.get().providedRequirements(),
+              ComponentRequirement::toParameterSpec);
     } else if (componentImplementation.isAbstract() && componentImplementation.isNested()) {
       // If we're generating an abstract inner subcomponent, then we are not implementing module
       // instance bindings and have no need for factory method parameters.
diff --git a/java/dagger/internal/codegen/ComponentRequirement.java b/java/dagger/internal/codegen/ComponentRequirement.java
index 12d5620cc..c3d3b7119 100644
--- a/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/java/dagger/internal/codegen/ComponentRequirement.java
@@ -171,9 +171,9 @@ boolean requiresAPassedInstance(DaggerElements elements, DaggerTypes types) {
   /** Returns the name for this requirement that could be used as a variable. */
   abstract String variableName();
 
-  /** Returns a parameter spec for this requirement with the given parameter name. */
-  ParameterSpec toParameterSpec(String name) {
-    return ParameterSpec.builder(TypeName.get(type()), name).build();
+  /** Returns a parameter spec for this requirement. */
+  ParameterSpec toParameterSpec() {
+    return ParameterSpec.builder(TypeName.get(type()), variableName()).build();
   }
 
   static ComponentRequirement forDependency(TypeMirror type) {
diff --git a/java/dagger/internal/codegen/ComponentRequirementExpressions.java b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
index dc75be84d..03bdb36f3 100644
--- a/java/dagger/internal/codegen/ComponentRequirementExpressions.java
+++ b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
@@ -35,7 +35,6 @@
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeName;
 import java.util.HashMap;
 import java.util.Map;
@@ -133,13 +132,13 @@ private ComponentRequirementExpression createField(ComponentRequirement requirem
             componentImplementation.baseImplementation().flatMap(c -> c.creatorImplementation()),
             componentImplementation.creatorImplementation());
     if (creatorImplementation.isPresent()) {
-      String name =
-          creatorImplementation.get().requirementNames().get(requirement);
-      return new ComponentParameterField(requirement, componentImplementation, name);
+      return new ComponentParameterField(requirement, componentImplementation, Optional.empty());
     } else if (graph.factoryMethod().isPresent()
         && graph.factoryMethodParameters().containsKey(requirement)) {
-      ParameterSpec parameter = ParameterSpec.get(graph.factoryMethodParameters().get(requirement));
-      return new ComponentParameterField(requirement, componentImplementation, parameter.name);
+      String parameterName =
+          graph.factoryMethodParameters().get(requirement).getSimpleName().toString();
+      return new ComponentParameterField(
+          requirement, componentImplementation, Optional.of(parameterName));
     } else if (requirement.kind().isModule()) {
       return new InstantiableModuleField(requirement, componentImplementation);
     } else {
@@ -224,12 +223,12 @@ CodeBlock fieldInitialization(FieldSpec componentField) {
    * as parameters to the component's constructor.
    */
   private static final class ComponentParameterField extends AbstractField {
-    private final String name;
+    private final String parameterName;
 
     private ComponentParameterField(
         ComponentRequirement componentRequirement,
         ComponentImplementation componentImplementation,
-        String name) {
+        Optional<String> name) {
       super(componentRequirement, componentImplementation);
       componentImplementation.addComponentRequirementParameter(componentRequirement);
       // Get the name that the component implementation will use for its parameter for the
@@ -240,15 +239,14 @@ private ComponentParameterField(
       // In either case, componentImplementation.getParameterName() will ensure that the final name
       // that is used is not the same name as any field in the component even if there's something
       // weird where the component actually has fields named, say, "foo" and "fooParam".
-      this.name =
-          componentImplementation.getParameterName(
-              componentRequirement, name.equals(fieldName) ? name + "Param" : name);
+      String baseName = name.filter(n -> !n.equals(fieldName)).orElse(fieldName + "Param");
+      this.parameterName = componentImplementation.getParameterName(componentRequirement, baseName);
     }
 
     @Override
     public CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
       if (componentImplementation.name().equals(requestingClass)) {
-        return CodeBlock.of("$L", name);
+        return CodeBlock.of("$L", parameterName);
       } else {
         // requesting this component requirement during initialization of a child component requires
         // it to be accessed from a field and not the parameter (since it is no longer available)
@@ -260,7 +258,7 @@ public CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
     CodeBlock fieldInitialization(FieldSpec componentField) {
       // Don't checkNotNull here because the parameter may be nullable; if it isn't, the caller
       // should handle checking that before passing the parameter.
-      return CodeBlock.of("this.$N = $L;", componentField, name);
+      return CodeBlock.of("this.$N = $L;", componentField, parameterName);
     }
   }
 
