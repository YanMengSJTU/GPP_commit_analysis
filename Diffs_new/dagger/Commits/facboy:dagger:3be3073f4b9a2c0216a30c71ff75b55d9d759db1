diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index 0ba4ecc4a..51adcbe53 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -209,11 +209,12 @@ public ComponentValidationReport validate(
                     break;
                   case 1:
                     // one parameter means that it's a members injection method
-                    TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
-                    membersInjectionValidator.validateMembersInjectionRequest(
-                        report, method, onlyParameter);
+                    TypeMirror parameterType = Iterables.getOnlyElement(parameterTypes);
+                    report.addSubreport(
+                        membersInjectionValidator.validateMembersInjectionMethod(
+                            method, parameterType));
                     if (!(returnType.getKind().equals(VOID)
-                        || types.isSameType(returnType, onlyParameter))) {
+                        || types.isSameType(returnType, parameterType))) {
                       report.addError(
                           "Members injection methods may only return the injected type or void.",
                           method);
diff --git a/java/dagger/internal/codegen/DependencyRequestValidator.java b/java/dagger/internal/codegen/DependencyRequestValidator.java
index c546fb214..1a9981852 100644
--- a/java/dagger/internal/codegen/DependencyRequestValidator.java
+++ b/java/dagger/internal/codegen/DependencyRequestValidator.java
@@ -70,8 +70,9 @@ void validateDependencyRequest(
       if (membersInjectorType.getTypeArguments().isEmpty()) {
         report.addError("Cannot inject a raw MembersInjector", requestElement);
       } else {
-        membersInjectionValidator.validateMembersInjectionRequest(
-            report, requestElement, membersInjectorType.getTypeArguments().get(0));
+        report.addSubreport(
+            membersInjectionValidator.validateMembersInjectionRequest(
+                requestElement, membersInjectorType.getTypeArguments().get(0)));
       }
     }
   }
diff --git a/java/dagger/internal/codegen/MembersInjectionValidator.java b/java/dagger/internal/codegen/MembersInjectionValidator.java
index 6ecd1d431..036315ea9 100644
--- a/java/dagger/internal/codegen/MembersInjectionValidator.java
+++ b/java/dagger/internal/codegen/MembersInjectionValidator.java
@@ -16,9 +16,14 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+
 import com.google.auto.common.MoreElements;
 import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.PrimitiveType;
@@ -35,48 +40,73 @@
   @Inject
   MembersInjectionValidator() {}
 
+  /** Reports errors if a request for a {@code MembersInjector<Foo>}) is invalid. */
+  ValidationReport<Element> validateMembersInjectionRequest(
+      Element requestElement, TypeMirror membersInjectedType) {
+    ValidationReport.Builder<Element> report = ValidationReport.about(requestElement);
+    checkQualifiers(report, requestElement);
+    membersInjectedType.accept(VALIDATE_MEMBERS_INJECTED_TYPE, report);
+    return report.build();
+  }
+
   /**
-   * Reports errors if a members injection dependency request (an injection method on a component or
-   * a request for a {@code MembersInjector<Foo>}) is invalid.
+   * Reports errors if a members injection method on a component is invalid.
+   *
+   * @throws IllegalArgumentException if the method doesn't have exactly one parameter
    */
-  void validateMembersInjectionRequest(
-      ValidationReport.Builder<?> report, Element requestElement, TypeMirror membersInjectedType) {
-    membersInjectedType.accept(
-        new SimpleTypeVisitor8<Void, Void>() {
-          @Override
-          protected Void defaultAction(TypeMirror type, Void v) {
+  ValidationReport<ExecutableElement> validateMembersInjectionMethod(
+      ExecutableElement method, TypeMirror membersInjectedType) {
+    checkArgument(
+        method.getParameters().size() == 1, "expected a method with one parameter: %s", method);
+
+    ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(method);
+    checkQualifiers(report, method);
+    checkQualifiers(report, method.getParameters().get(0));
+    membersInjectedType.accept(VALIDATE_MEMBERS_INJECTED_TYPE, report);
+    return report.build();
+  }
+
+  private void checkQualifiers(ValidationReport.Builder<?> report, Element element) {
+    for (AnnotationMirror qualifier : getQualifiers(element)) {
+      report.addError("Cannot inject members into qualified types", element, qualifier);
+      break; // just report on the first qualifier, in case there is more than one
+    }
+  }
+
+  private static final TypeVisitor<Void, ValidationReport.Builder<?>>
+      VALIDATE_MEMBERS_INJECTED_TYPE =
+          new SimpleTypeVisitor8<Void, ValidationReport.Builder<?>>() {
             // Only declared types can be members-injected.
-            report.addError("Cannot inject members into " + type, requestElement);
-            return null;
-          }
+            @Override
+            protected Void defaultAction(TypeMirror type, ValidationReport.Builder<?> report) {
+              report.addError("Cannot inject members into " + type);
+              return null;
+            }
 
-          @Override
-          public Void visitDeclared(DeclaredType type, Void v) {
-            if (type.getTypeArguments().isEmpty()) {
-              // If the type is the erasure of a generic type, that means the user referred to
-              // Foo<T> as just 'Foo', which we don't allow.  (This is a judgement call; we
-              // *could* allow it and instantiate the type bounds, but we don't.)
-              if (!MoreElements.asType(type.asElement()).getTypeParameters().isEmpty()) {
-                report.addError("Cannot inject members into raw type " + type, requestElement);
-              }
-            } else {
-              // If the type has arguments, validate that each type argument is declared.
-              // Otherwise the type argument may be a wildcard (or other type), and we can't
-              // resolve that to actual types.  For array type arguments, validate the type of
-              // the array.
-              for (TypeMirror arg : type.getTypeArguments()) {
-                if (!arg.accept(DECLARED_OR_ARRAY, null)) {
-                  report.addError(
-                      "Cannot inject members into types with unbounded type arguments: " + type,
-                      requestElement);
+            @Override
+            public Void visitDeclared(DeclaredType type, ValidationReport.Builder<?> report) {
+              if (type.getTypeArguments().isEmpty()) {
+                // If the type is the erasure of a generic type, that means the user referred to
+                // Foo<T> as just 'Foo', which we don't allow.  (This is a judgement call; we
+                // *could* allow it and instantiate the type bounds, but we don't.)
+                if (!MoreElements.asType(type.asElement()).getTypeParameters().isEmpty()) {
+                  report.addError("Cannot inject members into raw type " + type);
+                }
+              } else {
+                // If the type has arguments, validate that each type argument is declared.
+                // Otherwise the type argument may be a wildcard (or other type), and we can't
+                // resolve that to actual types.  For array type arguments, validate the type of the
+                // array.
+                for (TypeMirror arg : type.getTypeArguments()) {
+                  if (!arg.accept(DECLARED_OR_ARRAY, null)) {
+                    report.addError(
+                        "Cannot inject members into types with unbounded type arguments: " + type);
+                  }
                 }
               }
+              return null;
             }
-            return null;
-          }
-        },
-        null);
-  }
+          };
 
   // TODO(dpb): Can this be inverted so it explicitly rejects wildcards or type variables?
   // This logic is hard to describe.
diff --git a/javatests/dagger/internal/codegen/MembersInjectionValidationTest.java b/javatests/dagger/internal/codegen/MembersInjectionValidationTest.java
index 3af651d6c..68d5daaa7 100644
--- a/javatests/dagger/internal/codegen/MembersInjectionValidationTest.java
+++ b/javatests/dagger/internal/codegen/MembersInjectionValidationTest.java
@@ -140,6 +140,75 @@ public void membersInjectRawType() {
     assertThat(compilation).hadErrorContaining("Cannot inject members into raw type java.util.Set");
   }
 
+  @Test
+  public void qualifiedMembersInjector() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MembersInjector;",
+            "import javax.inject.Named;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  @Named(\"foo\") MembersInjector<Object> objectInjector();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into qualified types")
+        .inFile(component)
+        .onLineContaining("objectInjector();");
+  }
+
+  @Test
+  public void qualifiedMembersInjectionMethod() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MembersInjector;",
+            "import javax.inject.Named;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  @Named(\"foo\") void injectObject(Object object);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into qualified types")
+        .inFile(component)
+        .onLineContaining("injectObject(Object object);");
+  }
+
+  @Test
+  public void qualifiedMembersInjectionMethodParameter() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MembersInjector;",
+            "import javax.inject.Named;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void injectObject(@Named(\"foo\") Object object);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into qualified types")
+        .inFile(component)
+        .onLineContaining("injectObject(@Named(\"foo\") Object object);");
+  }
+
   @Test
   public void staticFieldInjection() {
     JavaFileObject injected =
