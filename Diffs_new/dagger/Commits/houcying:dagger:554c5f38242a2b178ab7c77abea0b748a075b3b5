diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcesssingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcesssingStep.java
index 4404fee2a..cc0f97848 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcesssingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcesssingStep.java
@@ -56,7 +56,6 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
       ValidationReport<TypeElement> report =
           componentValidator.validate(componentTypeElement);
       report.printMessagesTo(messager);
-
       if (report.isClean()) {
         try {
           componentGenerator.generate(componentDescriptorFactory.create(componentTypeElement));
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index a0ef9e502..7792d3540 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -121,7 +121,6 @@ private TypeElement getSetElement() {
     
     private TypeElement getMapElement() {
       return elements.getTypeElement(Map.class.getCanonicalName());
-      //return elements.getTypeElement(Map.class.getCanonicalName());
     }
     
     private TypeElement getProviderElement() {
@@ -145,7 +144,7 @@ Key forProvidesMethod(ExecutableElement e) {
         case MAP:
           ImmutableSet<? extends AnnotationMirror> annotationmirrors = getMapKey(e);
           Map<? extends ExecutableElement, ? extends AnnotationValue> map = annotationmirrors.iterator().next().getElementValues();
-          //Support String and Enum map key type
+          //Only support String and Enum map key type
           AnnotationValueVisitor<Object, Void> mapKeyVisitor = 
               new SimpleAnnotationValueVisitor6<Object, Void>() {
             @Override public TypeElement visitEnumConstant(VariableElement c, Void p) {
@@ -156,6 +155,9 @@ Key forProvidesMethod(ExecutableElement e) {
             }
           };
           TypeElement keyTypeElement = (TypeElement) map.entrySet().iterator().next().getValue().accept(mapKeyVisitor, null);
+          if (keyTypeElement == null) {
+            throw new NullPointerException("Not supported key type of MAP");
+          }
           TypeMirror valueType = types.getDeclaredType(getProviderElement(), returnType);
           TypeMirror mapType = types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
           return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(mapType));
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 8046ba280..2c3fe3c36 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -21,6 +21,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -29,6 +30,7 @@
 
 @RunWith(JUnit4.class)
 public class MapBindingComponentProcessorTest {
+
    @Test public void mapBindingsWithEnumKey() {
     JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
         "package test;",
@@ -149,7 +151,7 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
- 
+
   @Test public void mapBindingsWithStringKey() {
     JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
         "package test;",
@@ -265,4 +267,119 @@
         .and().generatesSources(generatedComponent);
   }
   
+  @Ignore
+  @Test public void mapBindingsWithIntegerKey() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @IntegerKey(1) Handler provideAdminHandler() { return new AdminHandler(); }",
+        "}");
+    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @IntegerKey(2) Handler provideLoginHandler() { return new LoginHandler(); }",
+        "}");
+    JavaFileObject integerKeyFile = JavaFileObjects.forSourceLines("test.IntegerKey", 
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey",
+        "@Retention(RUNTIME)",
+        "public @interface IntegerKey {",
+        "  int value();",  // Or Enum value(); using annotationMirror to obtain the concrete value, compile reflection
+        "}");
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler", 
+        "package test;",
+        "",
+        "interface Handler {",
+        "}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {",
+        "  }",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<Integer, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent",
+        "    implements TestComponent {",
+        "  private final MapModuleOne mapModuleOne;",
+        "  private final MapModuleTwo mapModuleTwo;",
+        "  /**",
+        "   * Key{type=java.util.Map<java.lang.String,javax.inject.Provider<test.Handler>>}",
+        "   */",
+        "  private final Provider<Map<String, Provider<Handler>>> mapOfStringAndProviderOfHandlerProvider;",
+        "",
+        "",
+        "  public Dagger_TestComponent(MapModuleOne mapModuleOne, MapModuleTwo mapModuleTwo) {",
+        "    if (mapModuleOne == null) {",
+        "      throw new NullPointerException(\"mapModuleOne\");",
+        "    }",
+        "    this.mapModuleOne = mapModuleOne;",
+        "    if (mapModuleTwo == null) {",
+        "      throw new NullPointerException(\"mapModuleTwo\");",
+        "    }",
+        "    this.mapModuleTwo = mapModuleTwo;",
+        "    this.mapOfStringAndProviderOfHandlerProvider = MapProviderFactory.<java.lang.String, test.Handler>builder(2)",
+        "        .put(\"Admin\", new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "        .put(\"Login\", new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "        .build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<String, Provider<Handler>> dispatcher() {",
+        "    return mapOfStringAndProviderOfHandlerProvider.get();",
+        "  }",
+        "}");
+    
+    
+    ASSERT.about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile, mapModuleTwoFile, integerKeyFile,HandlerFile, LoginHandlerFile, AdminHandlerFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+    //    .and().generatesSources(generatedComponent);
+  }
 }
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
index 431c52f36..0a17ce7f7 100644
--- a/core/src/main/java/dagger/internal/MapProviderFactory.java
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -1,9 +1,25 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package dagger.internal;
 
 import dagger.Factory;
 
 import java.util.Collections;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
@@ -30,7 +46,9 @@
     private final LinkedHashMap<K, Provider<V>> mapBuilder;
     
     public Builder(int size) {
-      this.mapBuilder = new LinkedHashMap<K, Provider<V>>(size);
+      //TODO(houcy): consider which way to initialize mapBuilder is better
+     // this.mapBuilder = new LinkedHashMap<K, Provider<V>>(size);
+      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
     }
     /**
      * Returns a new {@link MapProviderFactory} 
@@ -42,6 +60,13 @@ public Builder(int size) {
      * Associate k with providerOfValue in {@link Builder}
      */
     public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      if (key == null) {
+        throw new NullPointerException("The key is null");
+      }
+      if (providerOfValue == null) {
+        throw new NullPointerException("The provider of the value is null");
+      }
+
       this.mapBuilder.put(key, providerOfValue);
       return this;
     }
@@ -65,6 +90,20 @@ private MapProviderFactory(LinkedHashMap<K, Provider<V>> contributingMap) {
    */
   @Override
   public Map<K, Provider<V>> get() {
-    return Collections.unmodifiableMap(contributingMap);
+    if (this.contributingMap.isEmpty()) {
+      throw new IllegalStateException("An empty map was provided");
+    }
+    return Collections.unmodifiableMap(this.contributingMap);
   }
+  
+//TODO(gak): consider whether (expectedSize, 1.0f) is better for this use case since callers are
+ // typically only going to iterate
+ private static <K, V> LinkedHashMap<K,  Provider<V>> newLinkedHashMapWithExpectedSize(int expectedSize) {
+   int initialCapacity = (expectedSize < 3)
+       ? expectedSize + 1
+       : (expectedSize < (1 << (Integer.SIZE - 2)))
+           ? expectedSize + expectedSize / 3
+           : Integer.MAX_VALUE;
+   return new LinkedHashMap<K, Provider<V>>(initialCapacity);
+ }
 }
diff --git a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
new file mode 100644
index 000000000..99ecfa4f0
--- /dev/null
+++ b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import static org.truth0.Truth.ASSERT;
+
+import dagger.Factory;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import javax.inject.Provider;
+
+@RunWith(JUnit4.class)
+@SuppressWarnings("unchecked")
+public class MapProviderFactoryTest {
+  @Rule public ExpectedException thrown = ExpectedException.none();
+
+  @Test
+  public void nullKey() {
+    thrown.expect(NullPointerException.class);
+    MapProviderFactory.<String, Integer>builder(1)
+    .put(null, incrementingIntegerProvider(1));
+  }
+
+  @Test
+  public void nullValue() {
+    thrown.expect(NullPointerException.class);
+    MapProviderFactory.<String, Integer>builder(1)
+    .put("Hello", null);
+  }
+  
+  @Test
+  public void emptyMap() {
+    thrown.expect(IllegalStateException.class);
+    MapProviderFactory.<String, Integer>builder(0).build().get();
+  }
+  
+  @Test
+  public void invokesProvidersEverytTime() {
+    Provider<Integer> p1 = incrementingIntegerProvider(10);
+    Provider<Integer> p2 = incrementingIntegerProvider(20);
+    Provider<Integer> p3 = incrementingIntegerProvider(30);
+    
+    Factory<Map<String, Provider<Integer>>> factory = MapProviderFactory.<String, Integer>builder(3)
+        .put("one", p1)
+        .put("two", p2)
+        .put("three", p3)
+        .build();
+    
+    int base = 10;
+    for (int i = 0; i < 3; i++) {
+      Iterator<Entry<String, Provider<Integer>>> iterator = factory.get().entrySet().iterator();
+      while (iterator.hasNext()) {
+        Map.Entry<String, Provider<Integer>> entry = iterator.next();  
+        ASSERT.that(entry.getValue().get()).is(base);
+        base += 10;
+      }
+      base = 11 + i;
+    }
+    
+  }
+  
+  @Test
+  public void iterationOrder() {
+    Provider<Integer> p1 = incrementingIntegerProvider(10);
+    Provider<Integer> p2 = incrementingIntegerProvider(20);
+    Provider<Integer> p3 = incrementingIntegerProvider(30);
+    Provider<Integer> p4 = incrementingIntegerProvider(40);
+    Provider<Integer> p5 = incrementingIntegerProvider(50);
+    
+    Factory<Map<String, Provider<Integer>>> factory = MapProviderFactory.<String, Integer>builder(4)
+        .put("two", p2)
+        .put("one", p1)
+        .put("three", p3)
+        .put("one", p5)
+        .put("four", p4)
+        .build();
+
+    Map<String, Provider<Integer>> expectedMap = new LinkedHashMap<String, Provider<Integer>>();
+    expectedMap.put("two", p2);
+    expectedMap.put("one", p1);
+    expectedMap.put("three", p3);
+    expectedMap.put("one", p5);
+    expectedMap.put("four", p4);
+    ASSERT.that(factory.get().entrySet()).iteratesAs(expectedMap.entrySet());
+   /* ASSERT.that(factory.get().entrySet()).iteratesAs(new AbstractMap.SimpleEntry<String, Provider<Integer>>("two", p2), 
+        new AbstractMap.SimpleEntry<String, Provider<Integer>>("one", p1),
+        new AbstractMap.SimpleEntry<String, Provider<Integer>>("three", p3),
+        new AbstractMap.SimpleEntry<String, Provider<Integer>>("four", p4));*/
+  }
+  
+  
+  private static Provider<Integer> incrementingIntegerProvider(int seed) {
+    final AtomicInteger value = new AtomicInteger(seed);
+    return new Provider<Integer>() {
+      @Override
+      public Integer get() {
+        return value.getAndIncrement();
+      }
+    };
+  }
+}
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index aedf1aa57..b24bc56ee 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -1,9 +1,14 @@
 package coffee;
 
 import javax.inject.Inject;
+import javax.inject.Provider;
 
+import dagger.Lazy;
 import dagger.ObjectGraph;
 
+import java.util.HashMap;
+import java.util.Map;
+
 public class CoffeeApp {
   public static void main(String[] args) {
     CoffeeMain coffee = new Dagger_CoffeeMain(new DripCoffeeModule(), new PumpModule(), new MilkFlavorModule());
diff --git a/examples/simple/src/main/java/coffee/DripCoffeeModule.java b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
index aa6819e09..0948eb24f 100644
--- a/examples/simple/src/main/java/coffee/DripCoffeeModule.java
+++ b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
@@ -6,7 +6,7 @@
 
 @Module(
     injects = CoffeeApp.class,
-    includes = PumpModule.class //?
+    includes = PumpModule.class 
 )
 
 class DripCoffeeModule {
