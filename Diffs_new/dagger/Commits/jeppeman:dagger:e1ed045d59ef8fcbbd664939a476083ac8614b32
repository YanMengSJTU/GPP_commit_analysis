diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index ce29e49c5..7161fbc79 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -307,6 +307,7 @@ java_library(
         "InjectProcessingStep.java",
         "MapKeyProcessingStep.java",
         "ModuleProcessingStep.java",
+        "ProcessingEnvironmentModule.java",
         "ProcessingOptions.java",
         "ProductionExecutorModuleProcessingStep.java",
     ],
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index 0614a7873..a77509fc5 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -23,7 +23,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.CheckReturnValue;
-import com.google.googlejavaformat.java.filer.FormattingFiler;
 import dagger.Binds;
 import dagger.BindsInstance;
 import dagger.Component;
@@ -32,18 +31,13 @@
 import dagger.internal.codegen.BindingGraphPlugins.TestingPlugins;
 import dagger.spi.BindingGraphPlugin;
 import java.util.Arrays;
-import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
-import javax.annotation.processing.Filer;
-import javax.annotation.processing.Messager;
 import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.inject.Inject;
 import javax.inject.Singleton;
 import javax.lang.model.SourceVersion;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
@@ -104,28 +98,12 @@ public SourceVersion getSupportedSourceVersion() {
 
   @Override
   protected Iterable<? extends ProcessingStep> initSteps() {
-    Messager messager = processingEnv.getMessager();
-    DaggerElements elements = new DaggerElements(processingEnv);
-    CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
-    ProcessorComponent.Builder builder =
-        DaggerComponentProcessor_ProcessorComponent.builder()
-            .types(processingEnv.getTypeUtils())
-            .elements(elements)
-            .sourceVersion(processingEnv.getSourceVersion())
-            .messager(messager)
-            .processingOptions(processingEnv.getOptions())
-            .compilerOptions(compilerOptions)
-            .testingPlugins(testingPlugins);
-
-    Filer filer;
-    if (compilerOptions.headerCompilation()) {
-      builder.filer(processingEnv.getFiler());
-    } else {
-      builder.filer(new FormattingFiler(processingEnv.getFiler()));
-    }
+    ProcessorComponent.builder()
+        .processingEnvironmentModule(new ProcessingEnvironmentModule(processingEnv))
+        .testingPlugins(testingPlugins)
+        .build()
+        .inject(this);
 
-    ProcessorComponent component = builder.build();
-    component.inject(this);
     spiPlugins.initializePlugins();
     validationPlugins.initializePlugins();
     return processingSteps;
@@ -133,29 +111,24 @@ public SourceVersion getSupportedSourceVersion() {
 
   @Singleton
   @Component(
-    modules = {
-      BindingGraphPluginsModule.class,
-      BindingGraphValidationModule.class,
-      BindingMethodValidatorsModule.class,
-      ProcessingStepsModule.class,
-    }
-  )
+      modules = {
+        ProcessingEnvironmentModule.class,
+        BindingGraphPluginsModule.class,
+        BindingGraphValidationModule.class,
+        BindingMethodValidatorsModule.class,
+        ProcessingStepsModule.class,
+      })
   interface ProcessorComponent {
     void inject(ComponentProcessor processor);
 
+    static Builder builder() {
+      return DaggerComponentProcessor_ProcessorComponent.builder();
+    }
+
     @CanIgnoreReturnValue
     @Component.Builder
     interface Builder {
-      @BindsInstance Builder messager(Messager messager);
-      @BindsInstance Builder filer(Filer filer);
-      @BindsInstance Builder types(Types types);
-      @BindsInstance Builder elements(Elements elements);
-
-      @BindsInstance
-      Builder sourceVersion(SourceVersion sourceVersion);
-
-      @BindsInstance Builder compilerOptions(CompilerOptions compilerOptions);
-      @BindsInstance Builder processingOptions(@ProcessingOptions Map<String, String> options);
+      Builder processingEnvironmentModule(ProcessingEnvironmentModule module);
 
       @BindsInstance
       Builder testingPlugins(
diff --git a/java/dagger/internal/codegen/DaggerElements.java b/java/dagger/internal/codegen/DaggerElements.java
index 0e9d330ef..6aacc5437 100644
--- a/java/dagger/internal/codegen/DaggerElements.java
+++ b/java/dagger/internal/codegen/DaggerElements.java
@@ -26,8 +26,10 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import dagger.Reusable;
 import java.io.Writer;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
@@ -37,7 +39,6 @@
 import java.util.Set;
 import java.util.function.Predicate;
 import javax.annotation.processing.ProcessingEnvironment;
-import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
@@ -52,12 +53,13 @@
 import javax.lang.model.util.Types;
 
 /** Extension of {@link Elements} that adds Dagger-specific methods. */
+@Reusable
 final class DaggerElements implements Elements {
 
   private final Elements elements;
   private final Types types;
 
-  @Inject
+  @VisibleForTesting
   DaggerElements(Elements elements, Types types) {
     this.elements = checkNotNull(elements);
     this.types = checkNotNull(types);
diff --git a/java/dagger/internal/codegen/ProcessingEnvironmentModule.java b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
new file mode 100644
index 000000000..786955570
--- /dev/null
+++ b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.googlejavaformat.java.filer.FormattingFiler;
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Reusable;
+import dagger.internal.codegen.ProcessingEnvironmentModule.ElementsModule;
+import java.util.Map;
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/** Bindings that depend on the {@link ProcessingEnvironment}. */
+@Module(includes = ElementsModule.class)
+final class ProcessingEnvironmentModule {
+
+  private final ProcessingEnvironment processingEnvironment;
+
+  ProcessingEnvironmentModule(ProcessingEnvironment processingEnvironment) {
+    this.processingEnvironment = checkNotNull(processingEnvironment);
+  }
+
+  @Provides
+  @ProcessingOptions
+  Map<String, String> processingOptions() {
+    return processingEnvironment.getOptions();
+  }
+
+  @Provides
+  Messager messager() {
+    return processingEnvironment.getMessager();
+  }
+
+  @Provides
+  @Reusable // to avoid noting about disabling the formatter more than once
+  Filer filer(CompilerOptions compilerOptions, Messager messager) {
+    if (compilerOptions.headerCompilation()) {
+      return processingEnvironment.getFiler();
+    } else {
+      return new FormattingFiler(processingEnvironment.getFiler());
+    }
+  }
+
+  @Provides
+  Types types() {
+    return processingEnvironment.getTypeUtils();
+  }
+
+  @Provides
+  SourceVersion sourceVersion() {
+    return processingEnvironment.getSourceVersion();
+  }
+
+  @Provides
+  DaggerElements daggerElements() {
+    return new DaggerElements(processingEnvironment);
+  }
+
+  @Provides
+  @Reusable // to avoid parsing options more than once
+  CompilerOptions compilerOptions(DaggerElements elements) {
+    return CompilerOptions.create(processingEnvironment, elements);
+  }
+
+  @Module
+  interface ElementsModule {
+    @Binds
+    Elements elements(DaggerElements daggerElements);
+  }
+}
