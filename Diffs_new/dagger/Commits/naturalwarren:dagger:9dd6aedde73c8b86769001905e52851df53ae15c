diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index cc9c806aa..87783e133 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -26,25 +26,20 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
-import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
-import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
+import static dagger.internal.codegen.BindingExpression.InitializationState.DELEGATED;
+import static dagger.internal.codegen.BindingExpression.InitializationState.INITIALIZED;
+import static dagger.internal.codegen.BindingExpression.InitializationState.UNINITIALIZED;
 import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
-import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
-import static dagger.internal.codegen.MemberSelect.emptySetFactory;
 import static dagger.internal.codegen.MemberSelect.localField;
-import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
-import static dagger.internal.codegen.MemberSelect.staticMethod;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.Scope.reusableScope;
-import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkMapFactoryClassName;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
@@ -67,7 +62,6 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
 import com.google.auto.common.MoreElements;
@@ -87,8 +81,6 @@
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
-import com.squareup.javapoet.TypeVariableName;
-import dagger.internal.DelegateFactory;
 import dagger.internal.InstanceFactory;
 import dagger.internal.Preconditions;
 import dagger.internal.TypedReleasableReferenceManagerDecorator;
@@ -103,6 +95,7 @@
 import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -114,7 +107,6 @@
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
@@ -122,7 +114,7 @@
 import javax.tools.Diagnostic;
 
 /** Creates the implementation class for a component or subcomponent. */
-abstract class AbstractComponentWriter implements HasBindingMembers {
+abstract class AbstractComponentWriter implements HasBindingExpressions {
   // TODO(dpb): Make all these fields private after refactoring is complete.
   protected final Elements elements;
   protected final Types types;
@@ -131,12 +123,11 @@
   protected final ClassName name;
   protected final BindingGraph graph;
   protected final ImmutableMap<ComponentDescriptor, String> subcomponentNames;
-  private final Map<BindingKey, InitializationState> initializationStates = new HashMap<>();
   protected final TypeSpec.Builder component;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
-  private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
+  private final Map<BindingKey, BindingExpression> bindingExpressions = new LinkedHashMap<>();
   private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
-  private final RequestFulfillmentRegistry requestFulfillmentRegistry;
+  private final BindingExpression.Factory bindingExpressionFactory;
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   private final OptionalFactories optionalFactories;
   private ComponentBuilder builder;
@@ -181,9 +172,9 @@
     this.graph = graph;
     this.subcomponentNames = subcomponentNames;
     this.optionalFactories = optionalFactories;
-    this.requestFulfillmentRegistry =
-        new RequestFulfillmentRegistry(
-            graph.resolvedBindings(), this, childComponentNames(keyFactory, subcomponentNames));
+    this.bindingExpressionFactory =
+        new BindingExpression.Factory(
+            name, this, childComponentNames(keyFactory, subcomponentNames), graph);
   }
 
   private static ImmutableMap<BindingKey, String> childComponentNames(
@@ -266,26 +257,9 @@ private CodeBlock getComponentContributionExpression(ComponentRequirement compon
     return FieldSpec.builder(type, componentFieldNames.getUniqueName(name));
   }
 
-  private CodeBlock getMemberSelectExpression(BindingKey key) {
-    return getMemberSelect(key).getExpressionFor(name);
-  }
-
   @Override
-  public MemberSelect getMemberSelect(BindingKey key) {
-    return memberSelects.get(key);
-  }
-
-  /**
-   * Returns the initialization state of the factory field for a binding key in this component.
-   */
-  protected InitializationState getInitializationState(BindingKey bindingKey) {
-    return initializationStates.containsKey(bindingKey)
-        ? initializationStates.get(bindingKey)
-        : UNINITIALIZED;
-  }
-
-  private void setInitializationState(BindingKey bindingKey, InitializationState state) {
-    initializationStates.put(bindingKey, state);
+  public BindingExpression getBindingExpression(BindingKey key) {
+    return bindingExpressions.get(key);
   }
 
   /**
@@ -309,8 +283,9 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
     }
     addFactoryMethods();
     addReferenceReleasingProviderManagerFields();
-    addFrameworkFields();
-    initializeFrameworkTypes();
+    createBindingExpressions();
+    initializeFrameworkFields();
+    writeFieldsAndInitializeMethods();
     implementInterfaceMethods();
     addSubcomponents();
     component.addMethod(constructor.build());
@@ -432,18 +407,18 @@ private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
         .build();
   }
 
-  private void addFrameworkFields() {
-    graph.resolvedBindings().values().forEach(this::addField);
+  private void createBindingExpressions() {
+    graph.resolvedBindings().values().forEach(this::createBindingExpression);
   }
 
-  private void addField(ResolvedBindings resolvedBindings) {
-    BindingKey bindingKey = resolvedBindings.bindingKey();
-
+  private void createBindingExpression(ResolvedBindings resolvedBindings) {
     // If the binding can be satisfied with a static method call without dependencies or state,
     // no field is necessary.
-    Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
-    if (staticMemberSelect.isPresent()) {
-      memberSelects.put(bindingKey, staticMemberSelect.get());
+    // TODO(ronshapiro): can these be merged into bindingExpressionFactory.forResolvedBindings()?
+    Optional<BindingExpression> staticBindingExpression =
+        bindingExpressionFactory.forStaticMethod(resolvedBindings);
+    if (staticBindingExpression.isPresent()) {
+      bindingExpressions.put(resolvedBindings.bindingKey(), staticBindingExpression.get());
       return;
     }
 
@@ -453,16 +428,17 @@ private void addField(ResolvedBindings resolvedBindings) {
     }
 
     // TODO(gak): get rid of the field for unscoped delegated bindings
-
-    FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.empty());
-    memberSelects.put(bindingKey, localField(name, frameworkField.name));
+    bindingExpressions.put(
+        resolvedBindings.bindingKey(),
+        bindingExpressionFactory.forField(
+            resolvedBindings, generateFrameworkField(resolvedBindings, Optional.empty())));
   }
 
   /**
    * Adds a field representing the resolved bindings, optionally forcing it to use a particular
    * framework class (instead of the class the resolved bindings would typically use).
    */
-  private FieldSpec addFrameworkField(
+  private FieldSpec generateFrameworkField(
       ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
     boolean useRawType = useRawType(resolvedBindings);
 
@@ -479,9 +455,7 @@ private FieldSpec addFrameworkField(
       contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
     }
 
-    FieldSpec field = contributionField.build();
-    component.addField(field);
-    return field;
+    return contributionField.build();
   }
 
   private boolean useRawType(ResolvedBindings resolvedBindings) {
@@ -496,63 +470,6 @@ private boolean useRawType(Optional<String> bindingPackage) {
     return bindingPackage.isPresent() && !bindingPackage.get().equals(name.packageName());
   }
 
-  /**
-   * If {@code resolvedBindings} is an unscoped provision binding with no factory arguments or a
-   * no-op members injection binding, then we don't need a field to hold its factory. In that case,
-   * this method returns the static member select that returns the factory or no-op members
-   * injector.
-   */
-  private static Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
-    BindingKey bindingKey = resolvedBindings.bindingKey();
-    switch (bindingKey.kind()) {
-      case CONTRIBUTION:
-        ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
-        if (contributionBinding.factoryCreationStrategy().equals(SINGLETON_INSTANCE)
-            && !contributionBinding.scope().isPresent()) {
-          switch (contributionBinding.bindingKind()) {
-            case SYNTHETIC_MULTIBOUND_MAP:
-              return Optional.of(emptyFrameworkMapFactory(contributionBinding));
-
-            case SYNTHETIC_MULTIBOUND_SET:
-              return Optional.of(emptySetFactory(contributionBinding));
-
-            case INJECTION:
-            case PROVISION:
-              if (bindingKey.key().type().getKind().equals(DECLARED)) {
-                ImmutableList<TypeVariableName> typeVariables =
-                    bindingTypeElementTypeVariableNames(contributionBinding);
-                if (!typeVariables.isEmpty()) {
-                  List<? extends TypeMirror> typeArguments =
-                      ((DeclaredType) bindingKey.key().type()).getTypeArguments();
-                  return Optional.of(MemberSelect.parameterizedFactoryCreateMethod(
-                      generatedClassNameForBinding(contributionBinding), typeArguments));
-                }
-              }
-              // fall through
-
-            default:
-              return Optional.of(
-                  staticMethod(
-                      generatedClassNameForBinding(contributionBinding), CodeBlock.of("create()")));
-          }
-        }
-        break;
-
-      case MEMBERS_INJECTION:
-        Optional<MembersInjectionBinding> membersInjectionBinding =
-            resolvedBindings.membersInjectionBinding();
-        if (membersInjectionBinding.isPresent()
-            && membersInjectionBinding.get().injectionSites().isEmpty()) {
-          return Optional.of(noOpMembersInjector(membersInjectionBinding.get().key().type()));
-        }
-        break;
-
-      default:
-        throw new AssertionError();
-    }
-    return Optional.empty();
-  }
-
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
     for (ComponentMethodDescriptor componentMethod :
@@ -637,11 +554,20 @@ private void addSubcomponents() {
 
   private static final int INITIALIZATIONS_PER_INITIALIZE_METHOD = 100;
 
-  private void initializeFrameworkTypes() {
+  private void initializeFrameworkFields() {
+    bindingExpressions.values().forEach(this::initializeFrameworkType);
+  }
+
+  private void writeFieldsAndInitializeMethods() {
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
-      initializeFrameworkType(bindingKey).ifPresent(codeBlocks::add);
+    for (BindingExpression bindingExpression : bindingExpressions.values()) {
+      bindingExpression.initializeField(
+          (field, initialization) -> {
+            component.addField(field);
+            codeBlocks.add(initialization);
+          });
     }
+
     List<List<CodeBlock>> partitions =
         Lists.partition(codeBlocks.build(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
 
@@ -667,35 +593,34 @@ private void initializeFrameworkTypes() {
     }
   }
 
-  /**
-   * Returns a single code block representing the initialization of the framework type.
-   *
-   * <p>Note that this must be a single code block because initialization code blocks can be invoked
-   * from any place in any order.  By requiring a single code block (often of concatenated code
-   * blocks) we ensure that things like local variables always behave as expected by the
-   * initialization logic.
-   */
-  private Optional<CodeBlock> initializeFrameworkType(BindingKey bindingKey) {
-    // If the field is inherited or the member select is static, don't initialize.
-    MemberSelect memberSelect = getMemberSelect(bindingKey);
-    if (memberSelect.staticMember() || !memberSelect.owningClass().equals(name)) {
-      return Optional.empty();
+  /** Adds code to the given binding expression to initialize it, if necessary. */
+  private void initializeFrameworkType(BindingExpression bindingExpression) {
+    // If there is no field, don't initialize it.
+    if (!bindingExpression.hasFieldSpec()) {
+      return;
     }
 
-    switch (bindingKey.kind()) {
+    // We don't have to check whether we own the field because this method is called only for
+    // the bindingExpressions map values). That map is only populated for bindings we own, while
+    // getBindingExpression(BindingKey) may return those owned by parents.
+
+    switch (bindingExpression.bindingKey().kind()) {
       case CONTRIBUTION:
-        return initializeContributionBinding(bindingKey);
+        initializeContributionBinding(bindingExpression);
+        break;
 
       case MEMBERS_INJECTION:
-        return initializeMembersInjectionBinding(bindingKey);
+        initializeMembersInjectionBinding(bindingExpression);
+        break;
 
       default:
         throw new AssertionError();
     }
   }
 
-  private Optional<CodeBlock> initializeContributionBinding(BindingKey bindingKey) {
-    ContributionBinding binding = graph.resolvedBindings().get(bindingKey).contributionBinding();
+  private void initializeContributionBinding(BindingExpression bindingExpression) {
+    ContributionBinding binding =
+        graph.resolvedBindings().get(bindingExpression.bindingKey()).contributionBinding();
     /* We have some duplication in the branches below b/c initializeDeferredDependencies must be
      * called before we get the code block that initializes the member. */
     switch (binding.factoryCreationStrategy()) {
@@ -705,42 +630,38 @@ private void initializeFrameworkTypes() {
                 "($T) $L",
                 binding.bindingType().frameworkClass(),
                 getRequestFulfillment(getOnlyElement(binding.frameworkDependencies())));
-        return Optional.of(
-            CodeBlocks.concat(
-                ImmutableList.of(
-                    initializeDeferredDependencies(binding),
-                    initializeMember(
-                        bindingKey, decorateForScope(delegatingCodeBlock, binding.scope())))));
+        bindingExpression.setInitializationCode(
+            initializeDeferredDependencies(binding),
+            initializeMember(
+                bindingExpression, decorateForScope(delegatingCodeBlock, binding.scope())));
+        break;
       case SINGLETON_INSTANCE:
         if (!binding.scope().isPresent()) {
-          return Optional.empty();
+          break;
         }
         // fall through
       case CLASS_CONSTRUCTOR:
-        return Optional.of(
-            CodeBlocks.concat(
-                ImmutableList.of(
-                    initializeDeferredDependencies(binding),
-                    initializeMember(
-                        bindingKey, initializeFactoryForContributionBinding(binding)))));
+        bindingExpression.setInitializationCode(
+            initializeDeferredDependencies(binding),
+            initializeMember(bindingExpression, initializeFactoryForContributionBinding(binding)));
+        break;
       default:
         throw new AssertionError();
     }
   }
 
-  private Optional<CodeBlock> initializeMembersInjectionBinding(BindingKey bindingKey) {
+  private void initializeMembersInjectionBinding(BindingExpression bindingExpression) {
+    BindingKey bindingKey = bindingExpression.bindingKey();
     MembersInjectionBinding binding =
         graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();
 
     if (binding.injectionSites().isEmpty()) {
-      return Optional.empty();
+      return;
     }
 
-    return Optional.of(
-        CodeBlocks.concat(
-            ImmutableList.of(
-                initializeDeferredDependencies(binding),
-                initializeMember(bindingKey, initializeMembersInjectorForBinding(binding)))));
+    bindingExpression.setInitializationCode(
+        initializeDeferredDependencies(binding),
+        initializeMember(bindingExpression, initializeMembersInjectorForBinding(binding)));
   }
 
   /**
@@ -765,12 +686,13 @@ private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Bindin
         FluentIterable.from(binding.dependencies())
             .transform(DependencyRequest::bindingKey)
             .toSet()) {
-      if (!getMemberSelect(dependencyKey).staticMember()
-          && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
+      BindingExpression dependencyExpression = getBindingExpression(dependencyKey);
+      if (dependencyExpression.hasFieldSpec()
+          && dependencyExpression.fieldInitializationState().equals(UNINITIALIZED)) {
         initializations.add(
             CodeBlock.of(
-                "this.$L = new $T();", getMemberSelectExpression(dependencyKey), DELEGATE_FACTORY));
-        setInitializationState(dependencyKey, DELEGATED);
+                "this.$L = new $T();", dependencyExpression.fieldName(), DELEGATE_FACTORY));
+        dependencyExpression.setFieldInitializationState(DELEGATED);
       }
     }
 
@@ -786,7 +708,8 @@ private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {
           continue;
         }
         ResolvedBindings resolvedBindings = graph.resolvedBindings().get(dependencyKey);
-        FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.of(PRODUCER));
+        FieldSpec frameworkField = generateFrameworkField(resolvedBindings, Optional.of(PRODUCER));
+        component.addField(frameworkField);
         MemberSelect memberSelect = localField(name, frameworkField.name);
         producerFromProviderMemberSelects.put(dependencyKey, memberSelect);
         initializations.add(
@@ -806,29 +729,29 @@ private boolean isProducerFromProvider(FrameworkDependency frameworkDependency)
         && frameworkDependency.frameworkClass().equals(Producer.class);
   }
 
-  private CodeBlock initializeMember(BindingKey bindingKey, CodeBlock initializationCodeBlock) {
+  private CodeBlock initializeMember(
+      BindingExpression bindingExpression, CodeBlock initializationCodeBlock) {
     ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
+    String fieldName = bindingExpression.fieldName();
+    CodeBlock delegateFactoryVariable = delegateFactoryVariableName(bindingExpression);
 
-    CodeBlock memberSelect = getMemberSelectExpression(bindingKey);
-    CodeBlock delegateFactoryVariable = delegateFactoryVariableExpression(bindingKey);
-    if (getInitializationState(bindingKey).equals(DELEGATED)) {
+    if (bindingExpression.fieldInitializationState().equals(DELEGATED)) {
       initializations.add(
           CodeBlock.of(
-              "$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, memberSelect));
+              "$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, fieldName));
     }
-    initializations.add(
-        CodeBlock.of("this.$L = $L;", memberSelect, initializationCodeBlock));
-    if (getInitializationState(bindingKey).equals(DELEGATED)) {
+    initializations.add(CodeBlock.of("this.$L = $L;", fieldName, initializationCodeBlock));
+    if (bindingExpression.fieldInitializationState().equals(DELEGATED)) {
       initializations.add(
-          CodeBlock.of("$L.setDelegatedProvider($L);", delegateFactoryVariable, memberSelect));
+          CodeBlock.of("$L.setDelegatedProvider($L);", delegateFactoryVariable, fieldName));
     }
-    setInitializationState(bindingKey, INITIALIZED);
+    bindingExpression.setFieldInitializationState(INITIALIZED);
 
     return CodeBlocks.concat(initializations.build());
   }
 
-  private CodeBlock delegateFactoryVariableExpression(BindingKey key) {
-    return CodeBlock.of("$LDelegate", getMemberSelectExpression(key).toString().replace('.', '_'));
+  private CodeBlock delegateFactoryVariableName(BindingExpression bindingExpression) {
+    return CodeBlock.of("$LDelegate", bindingExpression.fieldName().replace('.', '_'));
   }
 
   private CodeBlock initializeFactoryForContributionBinding(ContributionBinding binding) {
@@ -1287,28 +1210,14 @@ private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBindi
   }
 
   private CodeBlock getRequestFulfillment(FrameworkDependency frameworkDependency) {
-    return requestFulfillmentRegistry
-        .getRequestFulfillment(frameworkDependency.bindingKey())
+    return getBindingExpression(frameworkDependency.bindingKey())
+        .requestFulfillment()
         .getSnippetForFrameworkDependency(frameworkDependency, name);
   }
 
   private CodeBlock getRequestFulfillment(DependencyRequest dependencyRequest) {
-    return requestFulfillmentRegistry
-        .getRequestFulfillment(dependencyRequest.bindingKey())
+    return getBindingExpression(dependencyRequest.bindingKey())
+        .requestFulfillment()
         .getSnippetForDependencyRequest(dependencyRequest, name);
   }
-
-  /**
-   * Initialization state for a factory field.
-   */
-  enum InitializationState {
-    /** The field is {@code null}. */
-    UNINITIALIZED,
-
-    /** The field is set to a {@link DelegateFactory}. */
-    DELEGATED,
-
-    /** The field is set to an undelegated factory. */
-    INITIALIZED;
-  }
 }
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
new file mode 100644
index 000000000..39d44078a
--- /dev/null
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Verify.verify;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import dagger.internal.DelegateFactory;
+import java.util.Optional;
+import java.util.function.BiConsumer;
+
+/** The code expressions to declare, initialize, and/or access a binding in a component. */
+final class BindingExpression {
+  private final BindingKey bindingKey;
+  private final Optional<FieldSpec> fieldSpec;
+  private final RequestFulfillment requestFulfillment;
+  private Optional<CodeBlock> initializeDeferredBindingFields = Optional.empty();
+  private Optional<CodeBlock> initializeField = Optional.empty();
+  private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
+
+  /** Initialization state for a factory field. */
+  enum InitializationState {
+    /** The field is {@code null}. */
+    UNINITIALIZED,
+
+    /** The field is set to a {@link DelegateFactory}. */
+    DELEGATED,
+
+    /** The field is set to an undelegated factory. */
+    INITIALIZED;
+  }
+
+  /** Factory for building a {@link BindingExpression}. */
+  static final class Factory {
+    private final ClassName componentName;
+    private final HasBindingExpressions hasBindingExpressions;
+    private final ImmutableMap<BindingKey, String> subcomponentNames;
+    private final BindingGraph graph;
+
+    Factory(
+        ClassName componentName,
+        HasBindingExpressions hasBindingExpressions,
+        ImmutableMap<BindingKey, String> subcomponentNames,
+        BindingGraph graph) {
+      this.componentName = checkNotNull(componentName);
+      this.hasBindingExpressions = checkNotNull(hasBindingExpressions);
+      this.subcomponentNames = checkNotNull(subcomponentNames);
+      this.graph = checkNotNull(graph);
+    }
+
+    /** Creates a binding expression for a field. */
+    BindingExpression forField(ResolvedBindings resolvedBindings, FieldSpec fieldSpec) {
+      MemberSelect memberSelect = MemberSelect.localField(componentName, fieldSpec.name);
+      return new BindingExpression(
+          resolvedBindings.bindingKey(),
+          createRequestFulfillment(resolvedBindings, memberSelect),
+          Optional.of(fieldSpec));
+    }
+
+    /** Creates a binding expression for a static method call. */
+    Optional<BindingExpression> forStaticMethod(ResolvedBindings resolvedBindings) {
+      Optional<MemberSelect> memberSelect = staticMemberSelect(resolvedBindings);
+      return memberSelect.map(
+          value ->
+              new BindingExpression(
+                  resolvedBindings.bindingKey(),
+                  createRequestFulfillment(resolvedBindings, value),
+                  Optional.empty()));
+    }
+
+    private RequestFulfillment createRequestFulfillment(
+        ResolvedBindings resolvedBindings, MemberSelect memberSelect) {
+      BindingKey bindingKey = resolvedBindings.bindingKey();
+      switch (resolvedBindings.bindingType()) {
+        case MEMBERS_INJECTION:
+          return new MembersInjectorRequestFulfillment(bindingKey, memberSelect);
+        case PRODUCTION:
+          return new ProducerFieldRequestFulfillment(bindingKey, memberSelect);
+        case PROVISION:
+          ProvisionBinding provisionBinding =
+              (ProvisionBinding) resolvedBindings.contributionBinding();
+
+          ProviderFieldRequestFulfillment providerFieldRequestFulfillment =
+              new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
+
+          switch (provisionBinding.bindingKind()) {
+            case SUBCOMPONENT_BUILDER:
+              return new SubcomponentBuilderRequestFulfillment(
+                  bindingKey, providerFieldRequestFulfillment, subcomponentNames.get(bindingKey));
+            case SYNTHETIC_MULTIBOUND_SET:
+              return new SetBindingRequestFulfillment(
+                  bindingKey,
+                  provisionBinding,
+                  graph,
+                  hasBindingExpressions,
+                  providerFieldRequestFulfillment);
+            case INJECTION:
+            case PROVISION:
+              if (provisionBinding.implicitDependencies().isEmpty()
+                  && !provisionBinding.scope().isPresent()
+                  && !provisionBinding.requiresModuleInstance()
+                  && provisionBinding.bindingElement().isPresent()) {
+                return new SimpleMethodRequestFulfillment(
+                    bindingKey,
+                    provisionBinding,
+                    providerFieldRequestFulfillment,
+                    hasBindingExpressions);
+              }
+              // fall through
+            default:
+              return providerFieldRequestFulfillment;
+          }
+        default:
+          throw new AssertionError();
+      }
+    }
+  }
+
+  private BindingExpression(
+      BindingKey bindingKey, RequestFulfillment requestFulfillment, Optional<FieldSpec> fieldSpec) {
+    this.bindingKey = bindingKey;
+    this.requestFulfillment = requestFulfillment;
+    this.fieldSpec = fieldSpec;
+  }
+
+  /** Returns the binding key associated with this binding expression. */
+  BindingKey bindingKey() {
+    return bindingKey;
+  }
+
+  /** Returns true if this binding expression has a field spec. */
+  boolean hasFieldSpec() {
+    return fieldSpec.isPresent();
+  }
+
+  /** Returns the name of this binding's underlying field. Only valid for field types. */
+  String fieldName() {
+    checkState(hasFieldSpec());
+    return fieldSpec.get().name;
+  }
+
+  /** Returns a request fulfillment for satisfying dependency requests for this expression. */
+  RequestFulfillment requestFulfillment() {
+    return requestFulfillment;
+  }
+
+  /** Returns this field's field spec, if it has one. */
+  Optional<FieldSpec> fieldSpec() {
+    return fieldSpec;
+  }
+
+  /** Sets the code for initializing this field. */
+  void setInitializationCode(CodeBlock initializeDeferredBindingFields, CodeBlock initializeField) {
+    this.initializeDeferredBindingFields = Optional.of(initializeDeferredBindingFields);
+    this.initializeField = Optional.of(initializeField);
+  }
+
+  /** Returns the initialization code for this field. */
+  Optional<CodeBlock> getInitializationCode() {
+    verify(initializeDeferredBindingFields.isPresent() == initializeField.isPresent());
+    return initializeDeferredBindingFields.map(
+        value -> CodeBlocks.concat(ImmutableList.of(value, initializeField.get())));
+  }
+
+  /** Returns the initialization state for this field. Only valid for field types. */
+  InitializationState fieldInitializationState() {
+    checkState(hasFieldSpec());
+    return fieldInitializationState;
+  }
+
+  /** Sets the initialization state for this field. Only valid for field types. */
+  void setFieldInitializationState(InitializationState fieldInitializationState) {
+    checkState(hasFieldSpec());
+    checkArgument(this.fieldInitializationState.compareTo(fieldInitializationState) < 0);
+    this.fieldInitializationState = fieldInitializationState;
+  }
+
+  /** Calls the consumer to initialize a field if this field/initialization is present. */
+  void initializeField(BiConsumer<FieldSpec, CodeBlock> initializationConsumer) {
+    if (hasFieldSpec()) {
+      Optional<CodeBlock> initCode = getInitializationCode();
+      checkState(initCode.isPresent());
+      initializationConsumer.accept(fieldSpec.get(), initCode.get());
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/HasBindingMembers.java b/java/dagger/internal/codegen/HasBindingExpressions.java
similarity index 62%
rename from java/dagger/internal/codegen/HasBindingMembers.java
rename to java/dagger/internal/codegen/HasBindingExpressions.java
index bc260d65d..207658813 100644
--- a/java/dagger/internal/codegen/HasBindingMembers.java
+++ b/java/dagger/internal/codegen/HasBindingExpressions.java
@@ -18,14 +18,16 @@
 
 import javax.annotation.Nullable;
 
-/** An object which associates a {@link MemberSelect} instance with a {@link BindingKey}. */
+/** An object which associates a {@link BindingExpression} instance with a {@link BindingKey}. */
 // TODO(gak): this isn't a particularly good abstraction. This should go away when MS is reworked.
-interface HasBindingMembers {
+interface HasBindingExpressions {
 
   /**
-   * Returns the {@link MemberSelect} associated with the given {@link BindingKey} or {@code null}
-   * if no association exists.
+   * Returns the {@link BindingExpression} associated with the given {@link BindingKey} or {@code
+   * null} if no association exists.
    */
+  // TODO(dpb): Move the hierarchical map of binding expressions out into a separate class.
+  // This should remove the need for HasBindingExpressions
   @Nullable
-  MemberSelect getMemberSelect(BindingKey bindingKey);
+  BindingExpression getBindingExpression(BindingKey bindingKey);
 }
diff --git a/java/dagger/internal/codegen/MemberSelect.java b/java/dagger/internal/codegen/MemberSelect.java
index a99a4709a..54662921f 100644
--- a/java/dagger/internal/codegen/MemberSelect.java
+++ b/java/dagger/internal/codegen/MemberSelect.java
@@ -19,18 +19,27 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.toTypeNamesCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkMapFactoryClassName;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
 import static dagger.internal.codegen.TypeNames.FACTORY;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
+import static javax.lang.model.type.TypeKind.DECLARED;
 
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeVariableName;
 import dagger.MembersInjector;
 import java.util.List;
+import java.util.Optional;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /**
@@ -65,18 +74,68 @@ CodeBlock getExpressionFor(ClassName usingClass) {
   }
 
   /**
-   * Returns a {@link MemberSelect} for the invocation of a static method (given by
-   * {@code methodInvocationCodeBlock}) on the {@code owningClass}.
+   * If {@code resolvedBindings} is an unscoped provision binding with no factory arguments or a
+   * no-op members injection binding, then we don't need a field to hold its factory. In that case,
+   * this method returns the static member select that returns the factory or no-op members
+   * injector.
    */
-  static MemberSelect staticMethod(ClassName owningClass, CodeBlock methodInvocationCodeBlock) {
-    return new StaticMethod(owningClass, methodInvocationCodeBlock);
+  static Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
+    BindingKey bindingKey = resolvedBindings.bindingKey();
+    switch (bindingKey.kind()) {
+      case CONTRIBUTION:
+        ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
+        if (contributionBinding.factoryCreationStrategy().equals(SINGLETON_INSTANCE)
+            && !contributionBinding.scope().isPresent()) {
+          switch (contributionBinding.bindingKind()) {
+            case SYNTHETIC_MULTIBOUND_MAP:
+              return Optional.of(emptyFrameworkMapFactory(contributionBinding));
+
+            case SYNTHETIC_MULTIBOUND_SET:
+              return Optional.of(emptySetFactory(contributionBinding));
+
+            case INJECTION:
+            case PROVISION:
+              if (bindingKey.key().type().getKind().equals(DECLARED)) {
+                ImmutableList<TypeVariableName> typeVariables =
+                    bindingTypeElementTypeVariableNames(contributionBinding);
+                if (!typeVariables.isEmpty()) {
+                  List<? extends TypeMirror> typeArguments =
+                      ((DeclaredType) bindingKey.key().type()).getTypeArguments();
+                  return Optional.of(
+                      MemberSelect.parameterizedFactoryCreateMethod(
+                          generatedClassNameForBinding(contributionBinding), typeArguments));
+                }
+              }
+              // fall through
+
+            default:
+              return Optional.of(
+                  new StaticMethod(
+                      generatedClassNameForBinding(contributionBinding), CodeBlock.of("create()")));
+          }
+        }
+        break;
+
+      case MEMBERS_INJECTION:
+        Optional<MembersInjectionBinding> membersInjectionBinding =
+            resolvedBindings.membersInjectionBinding();
+        if (membersInjectionBinding.isPresent()
+            && membersInjectionBinding.get().injectionSites().isEmpty()) {
+          return Optional.of(noOpMembersInjector(membersInjectionBinding.get().key().type()));
+        }
+        break;
+
+      default:
+        throw new AssertionError();
+    }
+    return Optional.empty();
   }
 
   /**
-   * Returns a {@link MemberSelect} for the instance of a {@code create()} method on a factory.
-   * This only applies for factories that do not have any dependencies.
+   * Returns a {@link MemberSelect} for the instance of a {@code create()} method on a factory. This
+   * only applies for factories that do not have any dependencies.
    */
-  static MemberSelect parameterizedFactoryCreateMethod(
+  private static MemberSelect parameterizedFactoryCreateMethod(
       ClassName owningClass, List<? extends TypeMirror> parameters) {
     return new ParameterizedStaticMethod(
         owningClass, ImmutableList.copyOf(parameters), CodeBlock.of("create()"), FACTORY);
@@ -98,10 +157,8 @@ CodeBlock getExpressionFor(ClassName usingClass) {
     }
   }
 
-  /**
-   * Returns the {@link MemberSelect} for a no-op {@link MembersInjector} for the given type.
-   */
-  static MemberSelect noOpMembersInjector(TypeMirror type) {
+  /** Returns the {@link MemberSelect} for a no-op {@link MembersInjector} for the given type. */
+  private static MemberSelect noOpMembersInjector(TypeMirror type) {
     return new ParameterizedStaticMethod(
         MEMBERS_INJECTORS,
         ImmutableList.of(type),
@@ -113,7 +170,7 @@ static MemberSelect noOpMembersInjector(TypeMirror type) {
    * A {@link MemberSelect} for a factory of an empty map of factory types, where a factory can be
    * either a {@link javax.inject.Provider} or {@link dagger.producers.Producer}.
    */
-  static MemberSelect emptyFrameworkMapFactory(ContributionBinding contributionBinding) {
+  private static MemberSelect emptyFrameworkMapFactory(ContributionBinding contributionBinding) {
     BindingType bindingType = contributionBinding.bindingType();
     MapType mapType = MapType.from(contributionBinding.key());
 
@@ -130,7 +187,7 @@ static MemberSelect emptyFrameworkMapFactory(ContributionBinding contributionBin
    * dagger.internal.SetFactory#empty()}, {@link dagger.producers.internal.SetProducer#empty()}, or
    * {@link dagger.producers.internal.SetOfProducedProducer#empty()}, depending on the set bindings.
    */
-  static MemberSelect emptySetFactory(ContributionBinding binding) {
+  private static MemberSelect emptySetFactory(ContributionBinding binding) {
     return new ParameterizedStaticMethod(
         setFactoryClassName(binding),
         ImmutableList.of(SetType.from(binding.key()).elementType()),
diff --git a/java/dagger/internal/codegen/RequestFulfillmentRegistry.java b/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
deleted file mode 100644
index 3d9b61aa1..000000000
--- a/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize;
-import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
-
-import com.google.common.collect.ImmutableMap;
-import java.util.Map;
-
-/**
- * A registry that associates a {@link BindingKey} with a {@link RequestFulfillment}. The registry
- * is responsible for choosing the most appropriate {@link RequestFulfillment} implementation based
- * on the properties of the binding and how it is used throughout the component.
- */
-final class RequestFulfillmentRegistry {
-  private final ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap;
-  private final HasBindingMembers hasBindingMembers;
-  /** This map is mutated as {@link #getRequestFulfillment} is invoked. */
-  private final Map<BindingKey, RequestFulfillment> requestFulfillments;
-  private final ImmutableMap<BindingKey, String> subcomponentNames;
-
-  RequestFulfillmentRegistry(
-      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap,
-      HasBindingMembers hasBindingMembers,
-      ImmutableMap<BindingKey, String> subcomponentNames) {
-    this.resolvedBindingsMap = resolvedBindingsMap;
-    this.hasBindingMembers = hasBindingMembers;
-    this.requestFulfillments = newLinkedHashMapWithExpectedSize(resolvedBindingsMap.size());
-    this.subcomponentNames = subcomponentNames;
-  }
-
-  /** Returns a {@link RequestFulfillment} implementation for the given {@link BindingKey} */
-  RequestFulfillment getRequestFulfillment(BindingKey bindingKey) {
-    return requestFulfillments.computeIfAbsent(bindingKey, this::createRequestFulfillment);
-  }
-
-  private RequestFulfillment createRequestFulfillment(BindingKey bindingKey) {
-    /* TODO(gak): it is super convoluted that we create the member selects separately and then
-     * look them up again this way. Now that we have RequestFulfillment, the next step is to
-     * create it and the MemberSelect and the field on demand rather than in a first pass. */
-    MemberSelect memberSelect = hasBindingMembers.getMemberSelect(bindingKey);
-    ResolvedBindings resolvedBindings = resolvedBindingsMap.get(bindingKey);
-    switch (resolvedBindings.bindingType()) {
-      case MEMBERS_INJECTION:
-        return new MembersInjectorRequestFulfillment(bindingKey, memberSelect);
-      case PRODUCTION:
-        return new ProducerFieldRequestFulfillment(bindingKey, memberSelect);
-      case PROVISION:
-        ProvisionBinding provisionBinding =
-            (ProvisionBinding) resolvedBindings.contributionBinding();
-
-        ProviderFieldRequestFulfillment providerFieldRequestFulfillment =
-            new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
-
-        switch (provisionBinding.bindingKind()) {
-          case SUBCOMPONENT_BUILDER:
-            return new SubcomponentBuilderRequestFulfillment(
-                bindingKey, providerFieldRequestFulfillment, subcomponentNames.get(bindingKey));
-          case SYNTHETIC_MULTIBOUND_SET:
-            return new SetBindingRequestFulfillment(
-                bindingKey,
-                provisionBinding,
-                resolvedBindingsMap,
-                this,
-                providerFieldRequestFulfillment);
-          case INJECTION:
-          case PROVISION:
-            if (provisionBinding.implicitDependencies().isEmpty()
-                && !provisionBinding.scope().isPresent()
-                && !provisionBinding.requiresModuleInstance()
-                && provisionBinding.bindingElement().isPresent()) {
-              return new SimpleMethodRequestFulfillment(
-                  bindingKey, provisionBinding, providerFieldRequestFulfillment, this);
-            }
-            // fall through
-          default:
-            return providerFieldRequestFulfillment;
-        }
-      default:
-        throw new AssertionError();
-    }
-  }
-}
diff --git a/java/dagger/internal/codegen/SetBindingRequestFulfillment.java b/java/dagger/internal/codegen/SetBindingRequestFulfillment.java
index 9740e05de..9fe7c7962 100644
--- a/java/dagger/internal/codegen/SetBindingRequestFulfillment.java
+++ b/java/dagger/internal/codegen/SetBindingRequestFulfillment.java
@@ -20,7 +20,6 @@
 import static com.squareup.javapoet.CodeBlock.of;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 
-import com.google.common.collect.ImmutableMap;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.SetBuilder;
@@ -33,19 +32,19 @@
  */
 final class SetBindingRequestFulfillment extends SimpleInvocationRequestFulfillment {
   private final ProvisionBinding binding;
-  private final ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap;
-  private final RequestFulfillmentRegistry registry;
+  private final BindingGraph graph;
+  private final HasBindingExpressions hasBindingExpressions;
 
   SetBindingRequestFulfillment(
       BindingKey bindingKey,
       ProvisionBinding binding,
-      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap,
-      RequestFulfillmentRegistry registry,
+      BindingGraph graph,
+      HasBindingExpressions hasBindingExpressions,
       RequestFulfillment delegate) {
     super(bindingKey, delegate);
     this.binding = binding;
-    this.resolvedBindingsMap = resolvedBindingsMap;
-    this.registry = registry;
+    this.graph = graph;
+    this.hasBindingExpressions = hasBindingExpressions;
   }
 
   @Override
@@ -89,8 +88,9 @@ CodeBlock getSimpleInvocation(DependencyRequest request, ClassName requestingCla
 
   private CodeBlock getRequestFulfillmentForDependency(
       DependencyRequest dependency, ClassName requestingClass) {
-    return registry
-        .getRequestFulfillment(dependency.bindingKey())
+    return hasBindingExpressions
+        .getBindingExpression(dependency.bindingKey())
+        .requestFulfillment()
         .getSnippetForDependencyRequest(dependency, requestingClass);
   }
 
@@ -112,7 +112,8 @@ private static CodeBlock maybeTypeParameter(
   }
 
   private boolean isSingleValue(DependencyRequest dependency) {
-    return resolvedBindingsMap
+    return graph
+        .resolvedBindings()
         .get(dependency.bindingKey())
         .contributionBinding()
         .contributionType()
diff --git a/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java b/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
index 791af2ce3..f5187bef9 100644
--- a/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
+++ b/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
@@ -43,13 +43,13 @@
 final class SimpleMethodRequestFulfillment extends SimpleInvocationRequestFulfillment {
 
   private final ProvisionBinding provisionBinding;
-  private final RequestFulfillmentRegistry registry;
+  private final HasBindingExpressions hasBindingExpressions;
 
   SimpleMethodRequestFulfillment(
       BindingKey bindingKey,
       ProvisionBinding provisionBinding,
       RequestFulfillment providerDelegate,
-      RequestFulfillmentRegistry registry) {
+      HasBindingExpressions hasBindingExpressions) {
     super(bindingKey, providerDelegate);
     checkArgument(
         provisionBinding.implicitDependencies().isEmpty(),
@@ -58,7 +58,7 @@
     checkArgument(!provisionBinding.requiresModuleInstance());
     checkArgument(provisionBinding.bindingElement().isPresent());
     this.provisionBinding = provisionBinding;
-    this.registry = registry;
+    this.hasBindingExpressions = hasBindingExpressions;
   }
 
   @Override
@@ -116,8 +116,9 @@ private CodeBlock invokeProxyMethod(ClassName requestingClass) {
   }
 
   private CodeBlock getDependencySnippet(ClassName requestingClass, DependencyRequest request) {
-    return registry
-        .getRequestFulfillment(request.bindingKey())
+    return hasBindingExpressions
+        .getBindingExpression(request.bindingKey())
+        .requestFulfillment()
         .getSnippetForDependencyRequest(request, requestingClass);
   }
 }
diff --git a/java/dagger/internal/codegen/SubcomponentWriter.java b/java/dagger/internal/codegen/SubcomponentWriter.java
index 4bfdb72ec..3a059f0d0 100644
--- a/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -20,7 +20,6 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Sets.difference;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.MemberSelect.localField;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
@@ -74,14 +73,6 @@ private static ClassName subcomponentName(AbstractComponentWriter parent, Bindin
         parent.subcomponentNames.get(subgraph.componentDescriptor()) + "Impl");
   }
 
-  @Override
-  protected InitializationState getInitializationState(BindingKey bindingKey) {
-    InitializationState initializationState = super.getInitializationState(bindingKey);
-    return initializationState.equals(UNINITIALIZED)
-        ? parent.getInitializationState(bindingKey)
-        : initializationState;
-  }
-
   @Override
   protected Optional<CodeBlock> getOrCreateComponentRequirementFieldExpression(
       ComponentRequirement componentRequirement) {
@@ -93,9 +84,9 @@ protected InitializationState getInitializationState(BindingKey bindingKey) {
   }
 
   @Override
-  public MemberSelect getMemberSelect(BindingKey key) {
-    MemberSelect memberSelect = super.getMemberSelect(key);
-    return memberSelect == null ? parent.getMemberSelect(key) : memberSelect;
+  public BindingExpression getBindingExpression(BindingKey key) {
+    BindingExpression bindingExpression = super.getBindingExpression(key);
+    return bindingExpression == null ? parent.getBindingExpression(key) : bindingExpression;
   }
 
   @Override
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 561795632..ac82d83a4 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -218,13 +218,13 @@ public void simpleComponent() {
             GENERATED_ANNOTATION,
             "public final class DaggerTestClass_SimpleComponent",
             "    implements TestClass.SimpleComponent {",
+            "  private Producer<TestClass.B> bProducer;",
             "  private Provider<Executor> executorProvider;",
             "  private Provider<Executor> executorProvider2;",
             "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
             "  private Provider<ProductionComponentMonitor> monitorProvider;",
             "  private Provider<TestClass.B> bProvider;",
             "  private Producer<TestClass.A> aProducer;",
-            "  private Producer<TestClass.B> bProducer;",
             "",
             "  private DaggerTestClass_SimpleComponent(Builder builder) {",
             "    assert builder != null;",
