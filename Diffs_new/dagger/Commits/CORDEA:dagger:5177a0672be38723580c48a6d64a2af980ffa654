diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 5afa9c3d3..632bf3e78 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -137,6 +137,7 @@ java_library(
         "BindsTypeChecker.java",
         "ChildFactoryMethodEdgeImpl.java",
         "ComponentDescriptor.java",
+        "ComponentKind.java",
         "ComponentNodeImpl.java",
         "ComponentRequirement.java",
         "ComponentTreeTraverser.java",
@@ -160,6 +161,7 @@ java_library(
         "MethodSignature.java",
         "MethodSignatureFormatter.java",
         "ModuleDescriptor.java",
+        "ModuleKind.java",
         "MultibindingDeclaration.java",
         "OptionalBindingDeclaration.java",
         "ProductionBinding.java",
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
index 42ef6ff64..57891d21c 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -23,7 +23,6 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Binding.hasNonDefaultTypeParameters;
-import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
 import static dagger.internal.codegen.ContributionBinding.bindingKindForMultibindingKey;
@@ -300,7 +299,7 @@ ContributionBinding componentDependencyMethodBinding(
     checkArgument(dependencyMethod.getKind().equals(METHOD));
     checkArgument(dependencyMethod.getParameters().isEmpty());
     ContributionBinding.Builder<?, ?> builder;
-    if (componentDescriptor.kind().equals(PRODUCTION_COMPONENT)
+    if (componentDescriptor.kind().isProducer()
         && isComponentProductionMethod(elements, dependencyMethod)) {
       builder =
           ProductionBinding.builder()
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 82d63a2d3..01f5e2452 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -47,7 +47,6 @@
 import dagger.MembersInjector;
 import dagger.Reusable;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
-import dagger.internal.codegen.ComponentDescriptor.Kind;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
@@ -224,17 +223,22 @@ private BindingGraph create(
    */
   private ImmutableSet<ModuleDescriptor> modules(
       ComponentDescriptor componentDescriptor, Optional<Resolver> parentResolver) {
-    if (componentDescriptor.kind().equals(Kind.PRODUCTION_COMPONENT)
-        || (componentDescriptor.kind().equals(Kind.PRODUCTION_SUBCOMPONENT)
-            && parentResolver.isPresent()
-            && !parentResolver.get().componentDescriptor.kind().isProducer())) {
-      ImmutableSet.Builder<ModuleDescriptor> modules = new ImmutableSet.Builder<>();
-      modules.addAll(componentDescriptor.modules());
-      modules.add(descriptorForMonitoringModule(componentDescriptor.typeElement()));
-      modules.add(descriptorForProductionExecutorModule());
-      return modules.build();
-    }
-    return componentDescriptor.modules();
+    return shouldIncludeImplicitProductionModules(componentDescriptor, parentResolver)
+        ? new ImmutableSet.Builder<ModuleDescriptor>()
+            .addAll(componentDescriptor.modules())
+            .add(descriptorForMonitoringModule(componentDescriptor.typeElement()))
+            .add(descriptorForProductionExecutorModule())
+            .build()
+        : componentDescriptor.modules();
+  }
+
+  private boolean shouldIncludeImplicitProductionModules(
+      ComponentDescriptor componentDescriptor, Optional<Resolver> parentResolver) {
+    ComponentKind kind = componentDescriptor.kind();
+    return kind.isProducer()
+        && ((kind.isTopLevel() && !kind.isForModuleValidation())
+            || (parentResolver.isPresent()
+                && !parentResolver.get().componentDescriptor.kind().isProducer()));
   }
 
   /**
diff --git a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index 055e6acea..c9d3cca50 100644
--- a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -22,6 +22,7 @@
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
+import static java.util.Arrays.stream;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
 import com.google.auto.common.MoreElements;
@@ -29,7 +30,6 @@
 import dagger.BindsInstance;
 import java.lang.annotation.Annotation;
 import java.util.Set;
-import java.util.stream.Stream;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
@@ -44,14 +44,13 @@
 final class BindsInstanceProcessingStep extends TypeCheckingProcessingStep<ExecutableElement> {
 
   private static final ImmutableSet<Class<? extends Annotation>> COMPONENT_ANNOTATIONS =
-      Stream.of(ComponentDescriptor.Kind.values())
+      stream(ComponentKind.values())
           .filter(kind -> !kind.isForModuleValidation())
-          .map(ComponentDescriptor.Kind::annotationType)
+          .map(ComponentKind::annotation)
           .collect(toImmutableSet());
+
   private static final ImmutableSet<Class<? extends Annotation>> MODULE_ANNOTATIONS =
-      Stream.of(ModuleDescriptor.Kind.values())
-          .map(ModuleDescriptor.Kind::moduleAnnotation)
-          .collect(toImmutableSet());
+      stream(ModuleKind.values()).map(ModuleKind::annotation).collect(toImmutableSet());
 
   private final Messager messager;
 
diff --git a/java/dagger/internal/codegen/BuilderValidator.java b/java/dagger/internal/codegen/BuilderValidator.java
index f69637e25..f4691846e 100644
--- a/java/dagger/internal/codegen/BuilderValidator.java
+++ b/java/dagger/internal/codegen/BuilderValidator.java
@@ -30,7 +30,6 @@
 import com.google.common.collect.ImmutableSet;
 import dagger.BindsInstance;
 import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
-import java.lang.annotation.Annotation;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
@@ -62,16 +61,13 @@
   public ValidationReport<TypeElement> validate(TypeElement subject) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
-    ComponentDescriptor.Kind componentKind =
-        ComponentDescriptor.Kind.forAnnotatedBuilderElement(subject).get();
+    ComponentKind componentKind = ComponentKind.forAnnotatedBuilderElement(subject).get();
 
     Element componentElement = subject.getEnclosingElement();
     ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentKind);
-    Class<? extends Annotation> componentAnnotation = componentKind.annotationType();
-    Class<? extends Annotation> builderAnnotation = componentKind.builderAnnotationType().get();
-    checkArgument(subject.getAnnotation(builderAnnotation) != null);
+    checkArgument(isAnnotationPresent(subject, componentKind.builderAnnotation().get()));
 
-    if (!isAnnotationPresent(componentElement, componentAnnotation)) {
+    if (!isAnnotationPresent(componentElement, componentKind.annotation())) {
       builder.addError(msgs.mustBeInComponent(), subject);
     }
 
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 7422149cd..4c82c1208 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -23,7 +23,6 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.common.collect.Sets.immutableEnumSet;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
@@ -36,7 +35,6 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.Scopes.productionScope;
 import static dagger.internal.codegen.Scopes.scopesOf;
-import static java.util.EnumSet.allOf;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -60,14 +58,9 @@
 import dagger.model.RequestKind;
 import dagger.model.Scope;
 import dagger.producers.CancellationPolicy;
-import dagger.producers.ProducerModule;
 import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
-import java.lang.annotation.Annotation;
-import java.util.EnumSet;
 import java.util.List;
 import java.util.Optional;
-import java.util.Set;
 import java.util.stream.Stream;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -92,153 +85,8 @@
  */
 @AutoValue
 abstract class ComponentDescriptor {
-  enum Kind {
-    COMPONENT(Component.class, Component.Builder.class, true),
-    SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class, false),
-    PRODUCTION_COMPONENT(ProductionComponent.class, ProductionComponent.Builder.class, true),
-    PRODUCTION_SUBCOMPONENT(
-        ProductionSubcomponent.class, ProductionSubcomponent.Builder.class, false),
-
-    /**
-     * This descriptor was generated from a {@link Module} instead of a component type in order to
-     * validate the module's bindings.
-     */
-    MODULE(Module.class, Optional.empty(), true),
-
-    /**
-     * This descriptor was generated from a {@link ProducerModule} instead of a component type in
-     * order to validate the module's bindings.
-     */
-    PRODUCER_MODULE(ProducerModule.class, Optional.empty(), true),
-    ;
-
-    private final Class<? extends Annotation> annotationType;
-    private final Optional<Class<? extends Annotation>> builderType;
-    private final boolean isTopLevel;
-
-    /**
-     * Returns the kind of an annotated element if it is annotated with one of the
-     * {@linkplain #annotationType() annotation types}.
-     *
-     * @throws IllegalArgumentException if the element is annotated with more than one of the
-     *     annotation types
-     */
-    static Optional<Kind> forAnnotatedElement(TypeElement element) {
-      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
-      for (Kind kind : values()) {
-        if (isAnnotationPresent(element, kind.annotationType())) {
-          kinds.add(kind);
-        }
-      }
-      checkArgument(
-          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return Optional.ofNullable(getOnlyElement(kinds, null));
-    }
-
-    /**
-     * Returns the kind of an annotated element if it is annotated with one of the
-     * {@linkplain #builderAnnotationType() annotation types}.
-     *
-     * @throws IllegalArgumentException if the element is annotated with more than one of the
-     *     annotation types
-     */
-    static Optional<Kind> forAnnotatedBuilderElement(TypeElement element) {
-      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
-      for (Kind kind : values()) {
-        if (kind.builderAnnotationType()
-            .filter(builderAnnotation -> isAnnotationPresent(element, builderAnnotation))
-            .isPresent()) {
-          kinds.add(kind);
-        }
-      }
-      checkArgument(
-          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return Optional.ofNullable(getOnlyElement(kinds, null));
-    }
-
-    Kind(
-        Class<? extends Annotation> annotationType,
-        Class<? extends Annotation> builderType,
-        boolean isTopLevel) {
-      this(annotationType, Optional.of(builderType), isTopLevel);
-    }
-
-    Kind(
-        Class<? extends Annotation> annotationType,
-        Optional<Class<? extends Annotation>> builderType,
-        boolean isTopLevel) {
-      this.annotationType = annotationType;
-      this.builderType = builderType;
-      this.isTopLevel = isTopLevel;
-    }
-
-    Class<? extends Annotation> annotationType() {
-      return annotationType;
-    }
-
-    /**
-     * Returns the {@code @Builder} annotation type for this kind of component, or empty if the
-     * descriptor is {@linkplain #isForModuleValidation() for a module} in order to validate its
-     * bindings.
-     */
-    Optional<Class<? extends Annotation>> builderAnnotationType() {
-      return builderType;
-    }
-
-    ImmutableSet<ModuleDescriptor.Kind> moduleKinds() {
-      return isProducer()
-          ? immutableEnumSet(allOf(ModuleDescriptor.Kind.class))
-          : immutableEnumSet(ModuleDescriptor.Kind.MODULE);
-    }
-
-    ImmutableSet<Kind> subcomponentKinds() {
-      return isProducer()
-          ? immutableEnumSet(PRODUCTION_SUBCOMPONENT)
-          : immutableEnumSet(SUBCOMPONENT, PRODUCTION_SUBCOMPONENT);
-    }
-
-    /**
-     * Returns {@code true} if the descriptor is for a top-level (not a child) component or is for
-     * {@linkplain #isForModuleValidation() module-validation}.
-     */
-    boolean isTopLevel() {
-      return isTopLevel;
-    }
-
-    /** Returns {@code true} if the descriptor is for a production component or module. */
-    boolean isProducer() {
-      switch (this) {
-        case COMPONENT:
-        case SUBCOMPONENT:
-        case MODULE:
-          return false;
-
-        case PRODUCTION_COMPONENT:
-        case PRODUCTION_SUBCOMPONENT:
-        case PRODUCER_MODULE:
-          return true;
-      }
-      throw new AssertionError(this);
-    }
-
-    /** Returns {@code true} if the descriptor is for a module in order to validate its bindings. */
-    boolean isForModuleValidation() {
-      switch (this) {
-        case MODULE:
-        case PRODUCER_MODULE:
-          return true;
-
-        case COMPONENT:
-        case SUBCOMPONENT:
-        case PRODUCTION_COMPONENT:
-        case PRODUCTION_SUBCOMPONENT:
-          return false;
-      }
-      throw new AssertionError(this);
-    }
-  }
-
-  abstract Kind kind();
+  /** The kind of the component. */
+  abstract ComponentKind kind();
 
   /** The annotation that specifies that {@link #typeElement()} is a component. */
   abstract AnnotationMirror annotation();
@@ -513,14 +361,14 @@ boolean isSubcomponentKind() {
      * Returns the component kind associated with this component method, if it exists. Otherwise,
      * throws.
      */
-    Kind componentKind() {
+    ComponentKind componentKind() {
       switch (this) {
         case SUBCOMPONENT:
         case SUBCOMPONENT_BUILDER:
-          return Kind.SUBCOMPONENT;
+          return ComponentKind.SUBCOMPONENT;
         case PRODUCTION_SUBCOMPONENT:
         case PRODUCTION_SUBCOMPONENT_BUILDER:
-          return Kind.PRODUCTION_SUBCOMPONENT;
+          return ComponentKind.PRODUCTION_SUBCOMPONENT;
         default:
           throw new IllegalStateException("no component associated with method " + this);
       }
@@ -570,7 +418,7 @@ Kind componentKind() {
      * validate its bindings.
      */
     ComponentDescriptor forTypeElement(TypeElement typeElement) {
-      Optional<Kind> kind = Kind.forAnnotatedElement(typeElement);
+      Optional<ComponentKind> kind = ComponentKind.forAnnotatedElement(typeElement);
       checkArgument(
           kind.isPresent(),
           "%s must have a component or subcomponent or module annotation",
@@ -581,9 +429,9 @@ ComponentDescriptor forTypeElement(TypeElement typeElement) {
       return create(typeElement, kind.get());
     }
 
-    private ComponentDescriptor create(TypeElement typeElement, Kind kind) {
+    private ComponentDescriptor create(TypeElement typeElement, ComponentKind kind) {
       AnnotationMirror componentAnnotation =
-          getAnnotationMirror(typeElement, kind.annotationType()).get();
+          getAnnotationMirror(typeElement, kind.annotation()).get();
       DeclaredType declaredComponentType = MoreTypes.asDeclared(typeElement.asType());
       ImmutableSet<ComponentRequirement> componentDependencies =
           kind.isTopLevel() && !kind.isForModuleValidation()
@@ -619,7 +467,7 @@ private ComponentDescriptor create(TypeElement typeElement, Kind kind) {
         for (SubcomponentDeclaration subcomponentDeclaration : module.subcomponentDeclarations()) {
           TypeElement subcomponent = subcomponentDeclaration.subcomponentType();
           subcomponentsFromModules.add(
-              create(subcomponent, Kind.forAnnotatedElement(subcomponent).get()));
+              create(subcomponent, ComponentKind.forAnnotatedElement(subcomponent).get()));
         }
       }
 
@@ -665,8 +513,8 @@ private ComponentDescriptor create(TypeElement typeElement, Kind kind) {
       }
 
       ImmutableList<DeclaredType> enclosedBuilders =
-          kind.builderAnnotationType()
-              .map(builderAnnotationType -> enclosedBuilders(typeElement, builderAnnotationType))
+          kind.builderAnnotation()
+              .map(builderAnnotation -> enclosedBuilders(typeElement, builderAnnotation))
               .orElse(ImmutableList.of());
       Optional<DeclaredType> builderType =
           Optional.ofNullable(getOnlyElement(enclosedBuilders, null));
@@ -694,7 +542,9 @@ private ComponentDescriptor create(TypeElement typeElement, Kind kind) {
     }
 
     private ComponentMethodDescriptor getDescriptorForComponentMethod(
-        TypeElement componentElement, Kind componentKind, ExecutableElement componentMethod) {
+        TypeElement componentElement,
+        ComponentKind componentKind,
+        ExecutableElement componentMethod) {
       ExecutableType resolvedComponentMethod =
           MoreTypes.asExecutable(
               types.asMemberOf(MoreTypes.asDeclared(componentElement.asType()), componentMethod));
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index 6685cc460..b425a6933 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -22,6 +22,8 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static dagger.internal.codegen.ComponentGenerator.componentName;
+import static dagger.internal.codegen.ComponentKind.annotationsFor;
+import static dagger.internal.codegen.ComponentKind.topLevelComponentKinds;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -39,10 +41,8 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.BindsInstance;
-import dagger.Component;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
-import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Optional;
 import java.util.Set;
@@ -101,7 +101,7 @@
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(Component.class, ProductionComponent.class);
+    return annotationsFor(topLevelComponentKinds());
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/ComponentKind.java b/java/dagger/internal/codegen/ComponentKind.java
new file mode 100644
index 000000000..74d94f731
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentKind.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.internal.codegen.DaggerStreams.presentValues;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static java.util.Arrays.stream;
+import static java.util.EnumSet.allOf;
+
+import com.google.common.collect.ImmutableSet;
+import dagger.Component;
+import dagger.Module;
+import dagger.Subcomponent;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.lang.annotation.Annotation;
+import java.util.EnumSet;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Stream;
+import javax.lang.model.element.TypeElement;
+
+/** Enumeration of the different kinds of components. */
+enum ComponentKind {
+  /** {@code @Component} */
+  COMPONENT(Component.class, Optional.of(Component.Builder.class), true, false),
+
+  /** {@code @Subcomponent} */
+  SUBCOMPONENT(Subcomponent.class, Optional.of(Subcomponent.Builder.class), false, false),
+
+  /** {@code @ProductionComponent} */
+  PRODUCTION_COMPONENT(
+      ProductionComponent.class, Optional.of(ProductionComponent.Builder.class), true, true),
+
+  /** {@code @ProductionSubcomponent} */
+  PRODUCTION_SUBCOMPONENT(
+      ProductionSubcomponent.class, Optional.of(ProductionSubcomponent.Builder.class), false, true),
+
+  /**
+   * Kind for a descriptor that was generated from a {@link Module} instead of a component type in
+   * order to validate the module's bindings.
+   */
+  MODULE(Module.class, Optional.empty(), true, false),
+
+  /**
+   * Kind for a descriptor was generated from a {@link ProducerModule} instead of a component type
+   * in order to validate the module's bindings.
+   */
+  PRODUCER_MODULE(ProducerModule.class, Optional.empty(), true, true),
+  ;
+
+  private static final ImmutableSet<ComponentKind> TOP_LEVEL_COMPONENT_KINDS =
+      stream(values())
+          .filter(kind -> !kind.isForModuleValidation())
+          .filter(kind -> kind.isTopLevel())
+          .collect(toImmutableSet());
+
+  private static final ImmutableSet<ComponentKind> SUBCOMPONENT_KINDS =
+      stream(values())
+          .filter(kind -> !kind.isForModuleValidation())
+          .filter(kind -> !kind.isTopLevel())
+          .collect(toImmutableSet());
+
+  /** Returns the set of kinds for top-level components. */
+  static ImmutableSet<ComponentKind> topLevelComponentKinds() {
+    return TOP_LEVEL_COMPONENT_KINDS;
+  }
+
+  /** Returns the set of kinds for subcomponents. */
+  static ImmutableSet<ComponentKind> subcomponentKinds() {
+    return SUBCOMPONENT_KINDS;
+  }
+
+  /** Returns the set of all annotations that mark components and their builders. */
+  static ImmutableSet<Class<? extends Annotation>> allComponentAndBuilderAnnotations() {
+    return stream(values())
+        .filter(kind -> !kind.isForModuleValidation())
+        .flatMap(kind -> Stream.of(kind.annotation(), kind.builderAnnotation().get()))
+        .collect(toImmutableSet());
+  }
+
+  /** Returns the annotations for components of the given kinds. */
+  static ImmutableSet<Class<? extends Annotation>> annotationsFor(Set<ComponentKind> kinds) {
+    return annotationsFor(kinds, kind -> Optional.of(kind.annotation()));
+  }
+
+  private static ImmutableSet<Class<? extends Annotation>> annotationsFor(
+      Set<ComponentKind> kinds,
+      Function<ComponentKind, Optional<Class<? extends Annotation>>> annotationFunction) {
+    return kinds.stream()
+        .map(annotationFunction)
+        .flatMap(presentValues())
+        .collect(toImmutableSet());
+  }
+  
+  /** Returns the annotations for builders for components of the given kinds. */
+  static ImmutableSet<Class<? extends Annotation>> builderAnnotationsFor(Set<ComponentKind> kinds) {
+    return annotationsFor(kinds, ComponentKind::builderAnnotation);
+  }
+
+  /**
+   * Returns the kind of an annotated element if it is annotated with one of the {@linkplain
+   * #annotation() annotations}.
+   *
+   * @throws IllegalArgumentException if the element is annotated with more than one of the
+   *     annotations
+   */
+  static Optional<ComponentKind> forAnnotatedElement(TypeElement element) {
+    return forAnnotatedElement(element, kind -> Optional.of(kind.annotation()));
+  }
+
+  private static Optional<ComponentKind> forAnnotatedElement(
+      TypeElement element,
+      Function<ComponentKind, Optional<Class<? extends Annotation>>> annotationFunction) {
+    Set<ComponentKind> kinds = EnumSet.noneOf(ComponentKind.class);
+    for (ComponentKind kind : values()) {
+      if (annotationFunction
+          .apply(kind)
+          .filter(annotation -> isAnnotationPresent(element, annotation))
+          .isPresent()) {
+        kinds.add(kind);
+      }
+    }
+
+    if (kinds.size() > 1) {
+      throw new IllegalArgumentException(
+          element
+              + " cannot be annotated with more than one of "
+              + annotationsFor(kinds, annotationFunction));
+    }
+    return kinds.stream().findAny();
+  }
+  
+  /**
+   * Returns the kind of an annotated element if it is annotated with one of the {@linkplain
+   * #builderAnnotation() builder annotations}.
+   *
+   * @throws IllegalArgumentException if the element is annotated with more than one of the builder
+   *     annotations
+   */
+  static Optional<ComponentKind> forAnnotatedBuilderElement(TypeElement element) {
+    return forAnnotatedElement(element, ComponentKind::builderAnnotation);
+  }
+
+  private final Class<? extends Annotation> annotation;
+  private final Optional<Class<? extends Annotation>> builderAnnotation;
+  private final boolean topLevel;
+  private final boolean production;
+
+  ComponentKind(
+      Class<? extends Annotation> annotation,
+      Optional<Class<? extends Annotation>> builderAnnotation,
+      boolean topLevel,
+      boolean production) {
+    this.annotation = annotation;
+    this.builderAnnotation = builderAnnotation;
+    this.topLevel = topLevel;
+    this.production = production;
+  }
+
+  /** Returns the annotation that marks a component of this kind. */
+  Class<? extends Annotation> annotation() {
+    return annotation;
+  }
+
+  /**
+   * Returns the {@code @Builder} annotation type for this kind of component, or empty if the
+   * descriptor is {@linkplain #isForModuleValidation() for a module} in order to validate its
+   * bindings.
+   */
+  Optional<Class<? extends Annotation>> builderAnnotation() {
+    return builderAnnotation;
+  }
+
+  /** Returns the kinds of modules that can be used with a component of this kind. */
+  ImmutableSet<ModuleKind> legalModuleKinds() {
+    return isProducer()
+        ? immutableEnumSet(allOf(ModuleKind.class))
+        : immutableEnumSet(ModuleKind.MODULE);
+  }
+
+  /** Returns the kinds of subcomponents a component of this kind can have. */
+  ImmutableSet<ComponentKind> legalSubcomponentKinds() {
+    return isProducer()
+        ? immutableEnumSet(PRODUCTION_SUBCOMPONENT)
+        : immutableEnumSet(SUBCOMPONENT, PRODUCTION_SUBCOMPONENT);
+  }
+
+  /**
+   * Returns {@code true} if the descriptor is for a top-level (not a child) component or is for
+   * {@linkplain #isForModuleValidation() module-validation}.
+   */
+  boolean isTopLevel() {
+    return topLevel;
+  }
+
+  /** Returns true if this is a production component. */
+  boolean isProducer() {
+    return production;
+  }
+
+  /** Returns {@code true} if the descriptor is for a module in order to validate its bindings. */
+  boolean isForModuleValidation() {
+    switch (this) {
+      case MODULE:
+      case PRODUCER_MODULE:
+        return true;
+      default:
+        // fall through
+    }
+    return false;
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 47d140bfa..4d262d7c5 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -16,6 +16,13 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.ComponentKind.allComponentAndBuilderAnnotations;
+import static dagger.internal.codegen.ComponentKind.annotationsFor;
+import static dagger.internal.codegen.ComponentKind.builderAnnotationsFor;
+import static dagger.internal.codegen.ComponentKind.subcomponentKinds;
+import static dagger.internal.codegen.ComponentKind.topLevelComponentKinds;
+import static java.util.Collections.disjoint;
+
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Predicates;
@@ -23,11 +30,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
-import dagger.Component;
-import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
-import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.HashMap;
 import java.util.Map;
@@ -88,33 +91,24 @@
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(
-        Component.class,
-        Component.Builder.class,
-        ProductionComponent.class,
-        ProductionComponent.Builder.class,
-        Subcomponent.class,
-        Subcomponent.Builder.class,
-        ProductionSubcomponent.class,
-        ProductionSubcomponent.Builder.class);
+    return allComponentAndBuilderAnnotations();
   }
 
   @Override
   public ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     subcomponentElements =
-        getElementsFromAnnotations(
-            elementsByAnnotation, Subcomponent.class, ProductionSubcomponent.class);
+        getElementsFromAnnotations(elementsByAnnotation, annotationsFor(subcomponentKinds()));
     subcomponentBuilderElements =
         getElementsFromAnnotations(
-            elementsByAnnotation, Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);
+            elementsByAnnotation, builderAnnotationsFor(subcomponentKinds()));
 
     ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
 
     builderReportsByComponent =
         processBuilders(
             getElementsFromAnnotations(
-                elementsByAnnotation, Component.Builder.class, ProductionComponent.Builder.class),
+                elementsByAnnotation, builderAnnotationsFor(topLevelComponentKinds())),
             rejectedElements);
     builderReportsBySubcomponent = processBuilders(subcomponentBuilderElements, rejectedElements);
     reportsBySubcomponent =
@@ -126,7 +120,7 @@
   @Override
   protected void process(
       TypeElement element, ImmutableSet<Class<? extends Annotation>> annotations) {
-    if (annotations.contains(Component.class) || annotations.contains(ProductionComponent.class)) {
+    if (!disjoint(annotations, annotationsFor(topLevelComponentKinds()))) {
       ComponentValidationReport validationReport =
           componentValidator.validate(element, subcomponentElements, subcomponentBuilderElements);
       validationReport.report().printMessagesTo(messager);
@@ -146,8 +140,7 @@ protected void process(
       }
     }
     if (compilerOptions.aheadOfTimeSubcomponents()
-        && (annotations.contains(Subcomponent.class)
-            || annotations.contains(ProductionSubcomponent.class))) {
+        && !disjoint(annotations, annotationsFor(subcomponentKinds()))) {
       if (!subcomponentIsClean(element)) {
         return;
       }
@@ -170,10 +163,9 @@ private void generateComponent(BindingGraph bindingGraph) {
 
   static ImmutableSet<Element> getElementsFromAnnotations(
       final SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation,
-      Class<? extends Annotation>... annotations) {
+      Set<Class<? extends Annotation>> annotations) {
     return ImmutableSet.copyOf(
-        Multimaps.filterKeys(elementsByAnnotation, Predicates.in(ImmutableSet.copyOf(annotations)))
-            .values());
+        Multimaps.filterKeys(elementsByAnnotation, Predicates.in(annotations)).values());
   }
 
   private ImmutableMap<Element, ValidationReport<TypeElement>> processBuilders(
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index c904bf7a4..d6550ffb3 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -51,7 +51,6 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Reusable;
-import dagger.internal.codegen.ComponentDescriptor.Kind;
 import dagger.internal.codegen.ErrorMessages.SubcomponentBuilderMessages;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
@@ -126,8 +125,7 @@ public ComponentValidationReport validate(
       Set<? extends Element> validatedSubcomponentBuilders) {
     ValidationReport.Builder<TypeElement> report = ValidationReport.about(subject);
 
-    ComponentDescriptor.Kind componentKind =
-        ComponentDescriptor.Kind.forAnnotatedElement(subject).get();
+    ComponentKind componentKind = ComponentKind.forAnnotatedElement(subject).get();
 
     if (isAnnotationPresent(subject, CancellationPolicy.class) && !componentKind.isProducer()) {
       report.addError(
@@ -140,14 +138,14 @@ public ComponentValidationReport validate(
       report.addError(
           String.format(
               "@%s may only be applied to an interface or abstract class",
-              componentKind.annotationType().getSimpleName()),
+              componentKind.annotation().getSimpleName()),
           subject);
     }
 
     ImmutableList<DeclaredType> builders =
         componentKind
-            .builderAnnotationType()
-            .map(builderAnnotationType -> enclosedBuilders(subject, builderAnnotationType))
+            .builderAnnotation()
+            .map(builderAnnotation -> enclosedBuilders(subject, builderAnnotation))
             .orElse(ImmutableList.of());
     if (builders.size() > 1) {
       report.addError(
@@ -184,23 +182,21 @@ public ComponentValidationReport validate(
               Optional<AnnotationMirror> subcomponentAnnotation =
                   checkForAnnotations(
                       returnType,
-                      componentKind.subcomponentKinds().stream()
-                          .map(Kind::annotationType)
+                      componentKind.legalSubcomponentKinds().stream()
+                          .map(ComponentKind::annotation)
                           .collect(toImmutableSet()));
               Optional<AnnotationMirror> subcomponentBuilderAnnotation =
                   checkForAnnotations(
                       returnType,
-                      componentKind.subcomponentKinds().stream()
-                          .map(kind -> kind.builderAnnotationType())
+                      componentKind.legalSubcomponentKinds().stream()
+                          .map(ComponentKind::builderAnnotation)
                           .flatMap(presentValues())
                           .collect(toImmutableSet()));
               if (subcomponentAnnotation.isPresent()) {
                 referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
                 validateSubcomponentMethod(
                     report,
-                    ComponentDescriptor.Kind.forAnnotatedElement(
-                            MoreTypes.asTypeElement(returnType))
-                        .get(),
+                    ComponentKind.forAnnotatedElement(MoreTypes.asTypeElement(returnType)).get(),
                     method,
                     parameters,
                     parameterTypes,
@@ -256,13 +252,13 @@ public ComponentValidationReport validate(
                     subject));
 
     AnnotationMirror componentMirror =
-        getAnnotationMirror(subject, componentKind.annotationType()).get();
+        getAnnotationMirror(subject, componentKind.annotation()).get();
     if (componentKind.isTopLevel()) {
       validateComponentDependencies(report, getComponentDependencies(componentMirror));
     }
     report.addSubreport(
         moduleValidator.validateReferencedModules(
-            subject, componentMirror, componentKind.moduleKinds(), new HashSet<>()));
+            subject, componentMirror, componentKind.legalModuleKinds(), new HashSet<>()));
 
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
@@ -324,7 +320,7 @@ private boolean isEntryPoint(ExecutableElement method, ExecutableType methodType
   private DependencyRequest dependencyRequest(ExecutableElement method, TypeElement component) {
     ExecutableType methodType =
         asExecutable(types.asMemberOf(asDeclared(component.asType()), method));
-    return ComponentDescriptor.Kind.forAnnotatedElement(component).get().isProducer()
+    return ComponentKind.forAnnotatedElement(component).get().isProducer()
         ? dependencyRequestFactory.forComponentProductionMethod(method, methodType)
         : dependencyRequestFactory.forComponentProvisionMethod(method, methodType);
   }
@@ -367,7 +363,7 @@ private void reportConflictingEntryPoints(
 
   private void validateSubcomponentMethod(
       final ValidationReport.Builder<TypeElement> report,
-      final ComponentDescriptor.Kind subcomponentKind,
+      final ComponentKind subcomponentKind,
       ExecutableElement method,
       List<? extends VariableElement> parameters,
       List<? extends TypeMirror> parameterTypes,
@@ -398,8 +394,8 @@ private void validateSubcomponentMethod(
 
                 @Override
                 public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
-                  for (ModuleDescriptor.Kind moduleKind : subcomponentKind.moduleKinds()) {
-                    if (isAnnotationPresent(t.asElement(), moduleKind.moduleAnnotation())) {
+                  for (ModuleKind moduleKind : subcomponentKind.legalModuleKinds()) {
+                    if (isAnnotationPresent(t.asElement(), moduleKind.annotation())) {
                       return Optional.of(MoreTypes.asTypeElement(t));
                     }
                   }
diff --git a/java/dagger/internal/codegen/ConfigurationAnnotations.java b/java/dagger/internal/codegen/ConfigurationAnnotations.java
index dbfcdbc32..ef618b0de 100644
--- a/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -102,12 +102,12 @@ static boolean isSubcomponentBuilder(Element element) {
    */
   static ImmutableList<AnnotationValue> getModules(
       TypeElement annotatedType, AnnotationMirror annotation) {
-    if (ComponentDescriptor.Kind.forAnnotatedElement(annotatedType)
+    if (ComponentKind.forAnnotatedElement(annotatedType)
         .filter(kind -> !kind.isForModuleValidation())
         .isPresent()) {
       return asAnnotationValues(getAnnotationValue(annotation, MODULES_ATTRIBUTE));
     }
-    if (ModuleDescriptor.Kind.forAnnotatedElement(annotatedType).isPresent()) {
+    if (ModuleKind.forAnnotatedElement(annotatedType).isPresent()) {
       return asAnnotationValues(getAnnotationValue(annotation, INCLUDES_ATTRIBUTE));
     }
     throw new IllegalArgumentException(String.format("unsupported annotation: %s", annotation));
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index f7b143eb5..35eaa1f9b 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -27,7 +27,7 @@
  */
 final class ErrorMessages {
 
-  static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
+  static ComponentBuilderMessages builderMsgsFor(ComponentKind kind) {
     switch(kind) {
       case COMPONENT:
         return ComponentBuilderMessages.INSTANCE;
diff --git a/java/dagger/internal/codegen/ModuleDescriptor.java b/java/dagger/internal/codegen/ModuleDescriptor.java
index 8ac4e22d5..c34c0ef1c 100644
--- a/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -20,12 +20,10 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.transform;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
-import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.SourceFiles.classFileName;
@@ -37,7 +35,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
 import com.google.common.graph.Traverser;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
@@ -47,11 +44,8 @@
 import dagger.Provides;
 import dagger.model.Key;
 import dagger.multibindings.Multibinds;
-import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
-import java.lang.annotation.Annotation;
 import java.util.Collection;
-import java.util.EnumSet;
 import java.util.LinkedHashSet;
 import java.util.Optional;
 import java.util.Set;
@@ -83,7 +77,8 @@
   /** The {@link BindsOptionalOf} method declarations that define optional bindings. */
   abstract ImmutableSet<OptionalBindingDeclaration> optionalDeclarations();
 
-  abstract Kind kind();
+  /** The kind of the module. */
+  abstract ModuleKind kind();
 
   /** Returns the keys of all bindings declared by this module. */
   ImmutableSet<Key> allBindingKeys() {
@@ -98,63 +93,6 @@
         .collect(toImmutableSet());
   }
 
-  enum Kind {
-    MODULE(Module.class, Provides.class),
-    PRODUCER_MODULE(ProducerModule.class, Produces.class);
-
-    private final Class<? extends Annotation> moduleAnnotation;
-    private final Class<? extends Annotation> methodAnnotation;
-
-    /**
-     * Returns the kind of an annotated element if it is annotated with one of the {@linkplain
-     * #moduleAnnotation() annotation types}.
-     *
-     * @throws IllegalArgumentException if the element is annotated with more than one of the
-     *     annotation types
-     */
-    static Optional<Kind> forAnnotatedElement(TypeElement element) {
-      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
-      for (Kind kind : values()) {
-        if (MoreElements.isAnnotationPresent(element, kind.moduleAnnotation())) {
-          kinds.add(kind);
-        }
-      }
-      checkArgument(
-          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return kinds.stream().findFirst();
-    }
-
-    Kind(
-        Class<? extends Annotation> moduleAnnotation,
-        Class<? extends Annotation> methodAnnotation) {
-      this.moduleAnnotation = moduleAnnotation;
-      this.methodAnnotation = methodAnnotation;
-    }
-
-    Optional<AnnotationMirror> getModuleAnnotationMirror(TypeElement element) {
-      return getAnnotationMirror(element, moduleAnnotation);
-    }
-
-    Class<? extends Annotation> moduleAnnotation() {
-      return moduleAnnotation;
-    }
-
-    Class<? extends Annotation> methodAnnotation() {
-      return methodAnnotation;
-    }
-
-    ImmutableSet<Kind> includesKinds() {
-      switch (this) {
-        case MODULE:
-          return Sets.immutableEnumSet(MODULE);
-        case PRODUCER_MODULE:
-          return Sets.immutableEnumSet(MODULE, PRODUCER_MODULE);
-        default:
-          throw new AssertionError(this);
-      }
-    }
-  }
-
   static final class Factory {
     private final DaggerElements elements;
     private final BindingFactory bindingFactory;
@@ -215,7 +153,7 @@ ModuleDescriptor create(TypeElement moduleElement) {
           subcomponentDeclarationFactory.forModule(moduleElement),
           delegates.build(),
           optionalDeclarations.build(),
-          Kind.forAnnotatedElement(moduleElement).get());
+          ModuleKind.forAnnotatedElement(moduleElement).get());
     }
 
     /** Returns all the modules transitively included by given modules, including the arguments. */
diff --git a/java/dagger/internal/codegen/ModuleKind.java b/java/dagger/internal/codegen/ModuleKind.java
new file mode 100644
index 000000000..7087f882a
--- /dev/null
+++ b/java/dagger/internal/codegen/ModuleKind.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import java.util.EnumSet;
+import java.util.Optional;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+
+/** Enumeration of the kinds of modules. */
+enum ModuleKind {
+  /** {@code @Module} */
+  MODULE(Module.class, Provides.class),
+
+  /** {@code @ProducerModule} */
+  PRODUCER_MODULE(ProducerModule.class, Produces.class);
+
+  /** Returns the annotations for modules of the given kinds. */
+  static ImmutableSet<Class<? extends Annotation>> annotationsFor(Set<ModuleKind> kinds) {
+    return kinds.stream().map(ModuleKind::annotation).collect(toImmutableSet());
+  }
+
+  /**
+   * Returns the kind of an annotated element if it is annotated with one of the module {@linkplain
+   * #annotation() annotations}.
+   *
+   * @throws IllegalArgumentException if the element is annotated with more than one of the module
+   *     annotations
+   */
+  static Optional<ModuleKind> forAnnotatedElement(TypeElement element) {
+    Set<ModuleKind> kinds = EnumSet.noneOf(ModuleKind.class);
+    for (ModuleKind kind : values()) {
+      if (MoreElements.isAnnotationPresent(element, kind.annotation())) {
+        kinds.add(kind);
+      }
+    }
+
+    if (kinds.size() > 1) {
+      throw new IllegalArgumentException(
+          element + " cannot be annotated with more than one of " + annotationsFor(kinds));
+    }
+    return kinds.stream().findAny();
+  }
+
+  private final Class<? extends Annotation> moduleAnnotation;
+  private final Class<? extends Annotation> methodAnnotation;
+
+  ModuleKind(
+      Class<? extends Annotation> moduleAnnotation, Class<? extends Annotation> methodAnnotation) {
+    this.moduleAnnotation = moduleAnnotation;
+    this.methodAnnotation = methodAnnotation;
+  }
+
+  /**
+   * Returns the annotation mirror for this module kind on the given type.
+   *
+   * @throws IllegalArgumentException if the annotation is not present on the type
+   */
+  AnnotationMirror getModuleAnnotation(TypeElement element) {
+    Optional<AnnotationMirror> result = getAnnotationMirror(element, moduleAnnotation);
+    checkArgument(
+        result.isPresent(), "annotation %s is not present on type %s", moduleAnnotation, element);
+    return result.get();
+  }
+
+  /** Returns the annotation that marks a module of this kind. */
+  Class<? extends Annotation> annotation() {
+    return moduleAnnotation;
+  }
+
+  /** Returns the annotation for binding methods on this type of module. */
+  // TODO(cgdecker): Validate how this is used... is it really correct? Producer modules can also
+  // have @Provides methods.
+  Class<? extends Annotation> methodAnnotation() {
+    return methodAnnotation;
+  }
+
+  /** Returns the kinds of modules that a module of this kind is allowed to include. */
+  ImmutableSet<ModuleKind> legalIncludedModuleKinds() {
+    switch (this) {
+      case MODULE:
+        return Sets.immutableEnumSet(MODULE);
+      case PRODUCER_MODULE:
+        return Sets.immutableEnumSet(MODULE, PRODUCER_MODULE);
+    }
+    throw new AssertionError(this);
+  }
+}
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index d15dd43c6..b93033a96 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -172,7 +172,7 @@ void addKnownModules(Collection<TypeElement> modules) {
   private ValidationReport<TypeElement> validateUncached(
       TypeElement module, Set<TypeElement> visitedModules) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(module);
-    ModuleDescriptor.Kind moduleKind = ModuleDescriptor.Kind.forAnnotatedElement(module).get();
+    ModuleKind moduleKind = ModuleKind.forAnnotatedElement(module).get();
 
     ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
     ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
@@ -218,7 +218,7 @@ void addKnownModules(Collection<TypeElement> modules) {
           String.format(
               "A @%s may not contain both non-static @%s methods and "
                   + "abstract @Binds or @Multibinds declarations",
-              moduleKind.moduleAnnotation().getSimpleName(),
+              moduleKind.annotation().getSimpleName(),
               moduleKind.methodAnnotation().getSimpleName()));
     }
 
@@ -244,9 +244,9 @@ void addKnownModules(Collection<TypeElement> modules) {
 
   private void validateReferencedSubcomponents(
       final TypeElement subject,
-      ModuleDescriptor.Kind moduleKind,
+      ModuleKind moduleKind,
       final ValidationReport.Builder<TypeElement> builder) {
-    final AnnotationMirror moduleAnnotation = moduleKind.getModuleAnnotationMirror(subject).get();
+    final AnnotationMirror moduleAnnotation = moduleKind.getModuleAnnotation(subject);
     // TODO(ronshapiro): use validateTypesAreDeclared when it is checked in
     for (TypeMirror subcomponentAttribute : getModuleSubcomponents(moduleAnnotation)) {
       subcomponentAttribute.accept(
@@ -343,7 +343,7 @@ private void validateModifiers(
   }
 
   private void validateMethodsWithSameName(
-      ModuleDescriptor.Kind moduleKind,
+      ModuleKind moduleKind,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     for (Entry<String, Collection<ExecutableElement>> entry :
@@ -362,13 +362,14 @@ private void validateMethodsWithSameName(
 
   private void validateReferencedModules(
       TypeElement subject,
-      ModuleDescriptor.Kind moduleKind,
+      ModuleKind moduleKind,
       Set<TypeElement> visitedModules,
       ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
-    AnnotationMirror mirror = moduleKind.getModuleAnnotationMirror(subject).get();
+    AnnotationMirror mirror = moduleKind.getModuleAnnotation(subject);
     builder.addSubreport(
-        validateReferencedModules(subject, mirror, moduleKind.includesKinds(), visitedModules));
+        validateReferencedModules(
+            subject, mirror, moduleKind.legalIncludedModuleKinds(), visitedModules));
   }
 
   /**
@@ -389,14 +390,11 @@ private void validateReferencedModules(
   ValidationReport<TypeElement> validateReferencedModules(
       TypeElement annotatedType,
       AnnotationMirror annotation,
-      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds,
+      ImmutableSet<ModuleKind> validModuleKinds,
       Set<TypeElement> visitedModules) {
     ValidationReport.Builder<TypeElement> subreport = ValidationReport.about(annotatedType);
     ImmutableSet<? extends Class<? extends Annotation>> validModuleAnnotations =
-        validModuleKinds
-            .stream()
-            .map(ModuleDescriptor.Kind::moduleAnnotation)
-            .collect(toImmutableSet());
+        validModuleKinds.stream().map(ModuleKind::annotation).collect(toImmutableSet());
 
     for (AnnotationValue includedModule : getModules(annotatedType, annotation)) {
       asType(includedModule)
@@ -444,7 +442,7 @@ private void reportError(String format, Object... args) {
 
   private void validateProvidesOverrides(
       TypeElement subject,
-      ModuleDescriptor.Kind moduleKind,
+      ModuleKind moduleKind,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> allMethodsByName,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
@@ -508,7 +506,7 @@ private void validateProvidesOverrides(
 
   private void validateModuleVisibility(
       final TypeElement moduleElement,
-      ModuleDescriptor.Kind moduleKind,
+      ModuleKind moduleKind,
       final ValidationReport.Builder<?> reportBuilder) {
     Visibility moduleVisibility = Visibility.ofElement(moduleElement);
     if (moduleVisibility.equals(PRIVATE)) {
@@ -528,7 +526,7 @@ private void validateModuleVisibility(
           ImmutableSet<Element> nonPublicModules =
               FluentIterable.from(
                       getModuleIncludes(
-                          getAnnotationMirror(moduleElement, moduleKind.moduleAnnotation()).get()))
+                          getAnnotationMirror(moduleElement, moduleKind.annotation()).get()))
                   .transform(types::asElement)
                   .filter(element -> effectiveVisibilityOfElement(element).compareTo(PUBLIC) < 0)
                   .toSet();
@@ -549,14 +547,12 @@ private void validateModuleVisibility(
   }
 
   private void validateNoScopeAnnotationsOnModuleElement(
-      TypeElement module,
-      ModuleDescriptor.Kind moduleKind,
-      ValidationReport.Builder<TypeElement> report) {
+      TypeElement module, ModuleKind moduleKind, ValidationReport.Builder<TypeElement> report) {
     for (AnnotationMirror scope : getAnnotatedAnnotations(module, Scope.class)) {
       report.addError(
           String.format(
               "@%ss cannot be scoped. Did you mean to scope a method instead?",
-              moduleKind.moduleAnnotation().getSimpleName()),
+              moduleKind.annotation().getSimpleName()),
           module,
           scope);
     }
