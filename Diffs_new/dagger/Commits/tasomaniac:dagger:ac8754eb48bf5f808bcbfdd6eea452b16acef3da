diff --git a/producers.md b/producers.md
index 2abeb3eaa..04e06bdc7 100644
--- a/producers.md
+++ b/producers.md
@@ -77,7 +77,7 @@ interface UserResponseComponent {
 
 // ...
 
-UserResponseComponent component = Dagger_UserResponseComponent.create();
+UserResponseComponent component = DaggerUserResponseComponent.create();
 
 ListenableFuture<Html> htmlFuture = component.html();
 ```
@@ -89,15 +89,11 @@ whose method `html()` does exactly what we described above: first it calls
 Both producer methods are scheduled on the provided executor, so the execution
 model is entirely user-specified.
 
-## Features
+Note that, as in the above example, producer modules can be used seamlessly with
+ordinary modules, subject to the restriction that provided types cannot depend
+on produced types.
 
-### Works with ordinary Dagger
-
-As in the above example, producer modules can be used seamlessly with ordinary
-modules, subject to the restriction that provided types cannot depend on
-produced types.
-
-### Exception handling
+## Exception handling
 
 By default, if a producer method throws an exception, or the future that it
 returns failed, then any dependent producer methods will be skipped - this
@@ -128,7 +124,7 @@ If an exception propagates all the way up to the componentâ€™s entry point
 without any producer method catching it, then the future returned from the
 component will fail with an exception.
 
-### Lazy execution
+## Lazy execution
 
 Producer methods can request a [`Producer<T>`][Producer], which is analogous to
 a [`Provider<T>`][Provider]: it delays the computation of the associated binding
@@ -153,7 +149,7 @@ user data is never computed. Note that the `Flags` may be a request-time flag,
 or even the result of an RPC, which lets users build very flexible conditional
 graphs.
 
-### Multibindings
+## Multibindings
 
 Several bindings of the same type can be collected into a set or map, just like
 in [ordinary Dagger](multibindings.md). For example:
@@ -174,7 +170,7 @@ In this example, when all the producer methods that contribute to this set have
 completed futures, the `Set<Data>` is constructed and the collect() method is
 called.
 
-#### Map multibindings
+### Map multibindings
 
 Map multibindings are similar to set multibindings:
 
@@ -203,19 +199,25 @@ Note that here, `dispatch()` is requesting
 `Map<DispatchPath, Producer<Html>>`; this ensures that only the dispatch
 handler that was requested will be executed.
 
-### Caching
+## Scoping
+
+Producer methods and production components are implicitly scoped
+`@ProductionScope`. Like ordinary scoped bindings, each method will only be
+executed once within the context of a given component, and its result will be
+cached. This gives complete control over the lifetime of each binding &mdash; it
+is the same as the lifetime of its enclosing component instance.
 
-Each producer method will only be executed once within the context of a given
-component, and its result will be cached. This gives complete control over the
-lifetime of each binding &mdash; it is the same as the lifetime of its enclosing
-component instance.
+`@ProductionScope` may also be applied to ordinary provisions; they will then be
+scoped to the production component that they're bound in. Production components
+may also *additionally* have other scopes, like ordinary components can.
 
-### Executor
+## Executor
 
 The primary way to supply the executor is to bind `@Production Executor` in a
-`ProductionComponent` or `ProductionSubcomponent`. For subcomponents, the
-executor may be bound in any parent component, and its binding will be inherited
-in the subcomponent (like all bindings are).
+`ProductionComponent` or `ProductionSubcomponent`. This binding will be
+implicitly scoped `@ProductionScope`. For subcomponents, the executor may be
+bound in any parent component, and its binding will be inherited in the
+subcomponent (like all bindings are).
 
 **This following alternative is deprecated and will be removed soon!**
 
@@ -232,7 +234,7 @@ with a duplicate binding error.
 Note that this means that a `ProductionComponent` that does not specify its
 builder must use this alternative method for supplying the executor.
 
-### Component dependencies
+## Component dependencies
 
 Like ordinary `Component`s, `ProductionComponent`s may depend on other
 interfaces:
@@ -261,14 +263,13 @@ require that an instance of the `RequestComponent` be provided when building the
 of the getter methods that it offers:
 
 ```java
-ListenableFuture<UserData> userData = Dagger_UserDataComponent.builder()
-    .executor(executor)
+ListenableFuture<UserData> userData = DaggerUserDataComponent.builder()
     .requestComponent(/* a particular RequestComponent */)
     .build()
     .userData();
 ```
 
-### Subcomponents
+## Subcomponents
 
 Dagger Producers introduces a new annotation
 [@ProductionSubcomponent][ProductionSubcomponent] as an analogue to
@@ -279,7 +280,7 @@ A subcomponent inherits all bindings from its parent component, and so it is
 often a simpler way of building nested scopes; see
 [subcomponents](subcomponents) for more details.
 
-### Monitoring
+## Monitoring
 
 [ProducerMonitor][ProducerMonitor] can be used to monitor the execution of
 producer methods; its methods correspond to various places in a producer's
@@ -310,7 +311,7 @@ be asked to create a monitor for the component. The resulting (single) instance
 will be held for the lifetime of the component, and will be used to create
 individual monitors for each producer method.
 
-### Timing, Logging and Debugging
+## Timing, Logging and Debugging
 
 **As of March 2016, not implemented yet**
 
