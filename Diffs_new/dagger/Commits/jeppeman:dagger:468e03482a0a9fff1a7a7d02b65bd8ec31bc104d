diff --git a/BUILD b/BUILD
index 180cb6ac9..cd0e40c54 100644
--- a/BUILD
+++ b/BUILD
@@ -58,7 +58,7 @@ jarjar_library(
     jars = [
         "//java/dagger/internal/codegen:base",
         "//java/dagger/internal/codegen:binding",
-        "//java/dagger/internal/codegen:internal_validation",
+        "//java/dagger/internal/codegen:binding_graph_validation",
         "//java/dagger/internal/codegen:processor",
         "//java/dagger/internal/codegen:shared-with-spi",
         "//java/dagger/internal/codegen:validation",
@@ -74,7 +74,7 @@ jarjar_library(
     jars = [
         "//java/dagger/internal/codegen:libbase-src.jar",
         "//java/dagger/internal/codegen:libbinding-src.jar",
-        "//java/dagger/internal/codegen:libinternal_validation-src.jar",
+        "//java/dagger/internal/codegen:libbinding_graph_validation-src.jar",
         "//java/dagger/internal/codegen:libprocessor-src.jar",
         "//java/dagger/internal/codegen:libshared-with-spi-src.jar",
         "//java/dagger/internal/codegen:libvalidation-src.jar",
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 3dd5c1d51..2006fb3b9 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -172,6 +172,7 @@ java_library(
         "BindsOptionalOfMethodValidator.java",
         "BuilderValidator.java",
         "CanReleaseReferencesValidator.java",
+        "ComponentDescriptorValidator.java",
         "ComponentHierarchyValidator.java",
         "ComponentValidator.java",
         "DependencyRequestFormatter.java",
@@ -195,7 +196,7 @@ java_library(
 )
 
 java_library(
-    name = "internal_validation",
+    name = "binding_graph_validation",
     srcs = [
         "BindingCycleValidation.java",
         "BindingGraphValidationModule.java",
@@ -321,7 +322,7 @@ java_library(
     deps = CODEGEN_DEPS + [
         ":base",
         ":binding",
-        ":internal_validation",
+        ":binding_graph_validation",
         ":writing",
         ":validation",
     ],
@@ -335,7 +336,7 @@ pom_file(
         ":processor",
         ":base",
         ":binding",
-        ":internal_validation",
+        ":binding_graph_validation",
         ":writing",
         ":validation",
     ],
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index a76a1fb68..ad6f080dc 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -19,7 +19,6 @@
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static javax.lang.model.element.Modifier.ABSTRACT;
 
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
@@ -36,7 +35,6 @@
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ReleasableReferenceManager;
 import java.util.Optional;
-import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -222,17 +220,6 @@ TypeElement componentType() {
         .toSet();
   }
 
-  ImmutableSet<ComponentRequirement> availableDependencies() {
-    return Stream.concat(
-            componentDescriptor()
-                .transitiveModuleTypes()
-                .stream()
-                .filter(dep -> !dep.getModifiers().contains(ABSTRACT))
-                .map(module -> ComponentRequirement.forModule(module.asType())),
-            componentDescriptor().dependencies().stream())
-        .collect(toImmutableSet());
-  }
-
   @Memoized
   @Override
   public abstract int hashCode();
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index e6d351752..3881439ff 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -19,71 +19,36 @@
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.asTypeElements;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
 import static dagger.internal.codegen.ComponentRequirement.Kind.MODULE;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
-import static dagger.internal.codegen.Formatter.INDENT;
-import static dagger.internal.codegen.Scopes.getReadableSource;
-import static dagger.internal.codegen.Scopes.scopesOf;
-import static dagger.internal.codegen.Scopes.singletonScope;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
-import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.joining;
-import static java.util.stream.Collectors.mapping;
-import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toSet;
 
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
-import dagger.Component;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
-import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import dagger.internal.codegen.ComponentRequirement.NullPolicy;
-import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
-import dagger.model.Scope;
-import java.util.ArrayDeque;
-import java.util.Deque;
 import java.util.LinkedHashMap;
-import java.util.List;
 import java.util.Map;
-import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 
 /** Reports errors in the shape of the binding graph. */
 final class BindingGraphValidator {
 
-  private final Elements elements;
   private final DaggerTypes types;
-  private final CompilerOptions compilerOptions;
-  private final MethodSignatureFormatter methodSignatureFormatter;
 
   @Inject
-  BindingGraphValidator(
-      Elements elements,
-      DaggerTypes types,
-      CompilerOptions compilerOptions,
-      MethodSignatureFormatter methodSignatureFormatter) {
-    this.elements = elements;
+  BindingGraphValidator(DaggerTypes types) {
     this.types = types;
-    this.compilerOptions = compilerOptions;
-    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
+
+  ValidationReport<TypeElement> validate(BindingGraph graph) {
+    ComponentValidation validation = new ComponentValidation(graph);
+    validation.traverseComponents();
+    return validation.buildReport();
   }
 
   private final class ComponentValidation extends ComponentTreeTraverser {
@@ -105,22 +70,13 @@
     }
 
     /** Returns the report builder for a (sub)component. */
-    private ValidationReport.Builder<TypeElement> report(BindingGraph graph) {
+    private ValidationReport.Builder<TypeElement> report(ComponentDescriptor component) {
       return reentrantComputeIfAbsent(
           reports,
-          graph.componentDescriptor(),
+          component,
           descriptor -> ValidationReport.about(descriptor.componentDefinitionType()));
     }
 
-    @Override
-    protected void visitComponent(BindingGraph graph) {
-      validateDependencyScopes(graph);
-      validateComponentDependencyHierarchy(graph);
-      validateModules(graph);
-      validateBuilders(graph);
-      super.visitComponent(graph);
-    }
-
     @Override
     protected void visitSubcomponentFactoryMethod(
         BindingGraph graph, BindingGraph parent, ExecutableElement factoryMethod) {
@@ -136,7 +92,7 @@ protected void visitSubcomponentFactoryMethod(
               .filter(moduleType -> !componentCanMakeNewInstances(moduleType))
               .collect(toSet());
       if (!missingModules.isEmpty()) {
-        report(parent)
+        report(parent.componentDescriptor())
             .addError(
                 String.format(
                     "%s requires modules which have no visible default constructors. "
@@ -154,317 +110,5 @@ protected void visitSubcomponentFactoryMethod(
           asExecutable(types.asMemberOf(componentType, childFactoryMethod));
       return asTypeElements(factoryMethodType.getParameterTypes());
     }
-
-    /** Validates that component dependencies do not form a cycle. */
-    private void validateComponentDependencyHierarchy(BindingGraph graph) {
-      validateComponentDependencyHierarchy(graph, graph.componentType(), new ArrayDeque<>());
-    }
-
-    /** Recursive method to validate that component dependencies do not form a cycle. */
-    private void validateComponentDependencyHierarchy(
-        BindingGraph graph, TypeElement dependency, Deque<TypeElement> dependencyStack) {
-      if (dependencyStack.contains(dependency)) {
-        // Current component has already appeared in the component chain.
-        StringBuilder message = new StringBuilder();
-        message.append(graph.componentType().getQualifiedName());
-        message.append(" contains a cycle in its component dependencies:\n");
-        dependencyStack.push(dependency);
-        appendIndentedComponentsList(message, dependencyStack);
-        dependencyStack.pop();
-        report(graph)
-            .addItem(
-                message.toString(),
-                compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                graph.componentType(),
-                getComponentAnnotation(graph.componentType()).get());
-      } else {
-        Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(dependency);
-        if (componentAnnotation.isPresent()) {
-          dependencyStack.push(dependency);
-
-          ImmutableSet<TypeElement> dependencies =
-              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get()));
-          for (TypeElement nextDependency : dependencies) {
-            validateComponentDependencyHierarchy(graph, nextDependency, dependencyStack);
-          }
-
-          dependencyStack.pop();
-        }
-      }
-    }
-
-    /**
-     * Validates that among the dependencies are at most one scoped dependency, that there are no
-     * cycles within the scoping chain, and that singleton components have no scoped dependencies.
-     */
-    private void validateDependencyScopes(BindingGraph graph) {
-      ComponentDescriptor descriptor = graph.componentDescriptor();
-      ImmutableSet<Scope> scopes = descriptor.scopes();
-      ImmutableSet<TypeElement> scopedDependencies =
-          scopedTypesIn(
-              descriptor
-                  .dependencies()
-                  .stream()
-                  .map(ComponentRequirement::typeElement)
-                  .collect(toImmutableSet()));
-      if (!scopes.isEmpty()) {
-        Scope singletonScope = singletonScope(elements);
-        // Dagger 1.x scope compatibility requires this be suppress-able.
-        if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()
-            && scopes.contains(singletonScope)) {
-          // Singleton is a special-case representing the longest lifetime, and therefore
-          // @Singleton components may not depend on scoped components
-          if (!scopedDependencies.isEmpty()) {
-            StringBuilder message = new StringBuilder(
-                "This @Singleton component cannot depend on scoped components:\n");
-            appendIndentedComponentsList(message, scopedDependencies);
-            report(graph)
-                .addItem(
-                    message.toString(),
-                    compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                    descriptor.componentDefinitionType(),
-                    descriptor.componentAnnotation());
-          }
-        } else if (scopedDependencies.size() > 1) {
-          // Scoped components may depend on at most one scoped component.
-          StringBuilder message = new StringBuilder();
-          for (Scope scope : scopes) {
-            message.append(getReadableSource(scope)).append(' ');
-          }
-          message
-              .append(descriptor.componentDefinitionType().getQualifiedName())
-              .append(" depends on more than one scoped component:\n");
-          appendIndentedComponentsList(message, scopedDependencies);
-          report(graph)
-              .addError(
-                  message.toString(),
-                  descriptor.componentDefinitionType(),
-                  descriptor.componentAnnotation());
-        } else {
-          // Dagger 1.x scope compatibility requires this be suppress-able.
-          if (!compilerOptions.scopeCycleValidationType().equals(ValidationType.NONE)) {
-            validateDependencyScopeHierarchy(
-                graph,
-                descriptor.componentDefinitionType(),
-                new ArrayDeque<ImmutableSet<Scope>>(),
-                new ArrayDeque<TypeElement>());
-          }
-        }
-      } else {
-        // Scopeless components may not depend on scoped components.
-        if (!scopedDependencies.isEmpty()) {
-          StringBuilder message =
-              new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())
-                  .append(" (unscoped) cannot depend on scoped components:\n");
-          appendIndentedComponentsList(message, scopedDependencies);
-          report(graph)
-              .addError(
-                  message.toString(),
-                  descriptor.componentDefinitionType(),
-                  descriptor.componentAnnotation());
-        }
-      }
-    }
-
-    private void validateModules(BindingGraph graph) {
-      for (ModuleDescriptor module : graph.componentDescriptor().transitiveModules()) {
-        if (module.moduleElement().getModifiers().contains(Modifier.ABSTRACT)) {
-          for (ContributionBinding binding : module.bindings()) {
-            if (binding.requiresModuleInstance()) {
-              report(graph).addError(abstractModuleHasInstanceBindingMethodsError(module));
-              break;
-            }
-          }
-        }
-      }
-    }
-
-    private String abstractModuleHasInstanceBindingMethodsError(ModuleDescriptor module) {
-      String methodAnnotations;
-      switch (module.kind()) {
-        case MODULE:
-          methodAnnotations = "@Provides";
-          break;
-        case PRODUCER_MODULE:
-          methodAnnotations = "@Provides or @Produces";
-          break;
-        default:
-          throw new AssertionError(module.kind());
-      }
-      return String.format(
-          "%s is abstract and has instance %s methods. Consider making the methods static or "
-              + "including a non-abstract subclass of the module instead.",
-          module.moduleElement(), methodAnnotations);
-    }
-
-    private void validateBuilders(BindingGraph graph) {
-      ComponentDescriptor componentDesc = graph.componentDescriptor();
-      if (!componentDesc.builderSpec().isPresent()) {
-        // If no builder, nothing to validate.
-        return;
-      }
-
-      Set<ComponentRequirement> availableDependencies = graph.availableDependencies();
-      Set<ComponentRequirement> requiredDependencies =
-          Sets.filter(
-              availableDependencies,
-              input -> input.nullPolicy(elements, types).equals(NullPolicy.THROW));
-      final BuilderSpec spec = componentDesc.builderSpec().get();
-      ImmutableSet<BuilderRequirementMethod> declaredSetters =
-          spec.requirementMethods()
-              .stream()
-              .filter(method -> !method.requirement().kind().equals(BOUND_INSTANCE))
-              .collect(toImmutableSet());
-      ImmutableSet<ComponentRequirement> declaredRequirements =
-          declaredSetters
-              .stream()
-              .map(BuilderRequirementMethod::requirement)
-              .collect(toImmutableSet());
-
-      ComponentBuilderMessages msgs =
-          ErrorMessages.builderMsgsFor(graph.componentDescriptor().kind());
-      Set<ComponentRequirement> extraSetters =
-          Sets.difference(declaredRequirements, availableDependencies);
-      if (!extraSetters.isEmpty()) {
-        List<ExecutableElement> excessMethods =
-            declaredSetters
-                .stream()
-                .filter(method -> extraSetters.contains(method.requirement()))
-                .map(BuilderRequirementMethod::method)
-                .collect(toList());
-        Optional<DeclaredType> container =
-            Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType()));
-        String formatted =
-            excessMethods
-                .stream()
-                .map(method -> methodSignatureFormatter.format(method, container))
-                .collect(joining(", ", "[", "]"));
-        report(graph)
-            .addError(String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
-      }
-
-      Set<ComponentRequirement> missingSetters =
-          Sets.difference(requiredDependencies, declaredRequirements);
-      if (!missingSetters.isEmpty()) {
-        report(graph)
-            .addError(
-                String.format(
-                    msgs.missingSetters(),
-                    missingSetters.stream().map(ComponentRequirement::type).collect(toList())),
-                spec.builderDefinitionType());
-      }
-
-      // Validate that declared builder requirements (modules, dependencies) have unique types.
-      Map<Equivalence.Wrapper<TypeMirror>, List<ExecutableElement>> declaredRequirementsByType =
-          spec.requirementMethods()
-              .stream()
-              .filter(method -> !method.requirement().kind().equals(BOUND_INSTANCE))
-              .collect(
-                  groupingBy(
-                      method -> method.requirement().wrappedType(),
-                      mapping(method -> method.method(), toList())));
-      for (Map.Entry<Equivalence.Wrapper<TypeMirror>, List<ExecutableElement>> entry :
-          declaredRequirementsByType.entrySet()) {
-        if (entry.getValue().size() > 1) {
-          TypeMirror type = entry.getKey().get();
-          report(graph)
-              .addError(
-                  String.format(msgs.manyMethodsForType(), type, entry.getValue()),
-                  spec.builderDefinitionType());
-        }
-      }
-    }
-
-    /**
-     * Validates that scopes do not participate in a scoping cycle - that is to say, scoped
-     * components are in a hierarchical relationship terminating with Singleton.
-     *
-     * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
-     * themselves, since a component's presence within its own dependency path implies a cyclical
-     * relationship between scopes. However, cycles in component dependencies are explicitly checked
-     * in {@link #validateComponentDependencyHierarchy(BindingGraph)}.
-     */
-    private void validateDependencyScopeHierarchy(
-        BindingGraph graph,
-        TypeElement dependency,
-        Deque<ImmutableSet<Scope>> scopeStack,
-        Deque<TypeElement> scopedDependencyStack) {
-      ImmutableSet<Scope> scopes = scopesOf(dependency);
-      if (stackOverlaps(scopeStack, scopes)) {
-        scopedDependencyStack.push(dependency);
-        // Current scope has already appeared in the component chain.
-        StringBuilder message = new StringBuilder();
-        message.append(graph.componentType().getQualifiedName());
-        message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
-        appendIndentedComponentsList(message, scopedDependencyStack);
-        if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
-          report(graph)
-              .addItem(
-                  message.toString(),
-                  compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                  graph.componentType(),
-                  getComponentAnnotation(graph.componentType()).get());
-        }
-        scopedDependencyStack.pop();
-      } else {
-        // TODO(beder): transitively check scopes of production components too.
-        getAnnotationMirror(dependency, Component.class)
-            .ifPresent(
-                componentAnnotation -> {
-                  ImmutableSet<TypeElement> scopedDependencies =
-                      scopedTypesIn(
-                          MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation)));
-                  if (scopedDependencies.size() == 1) {
-                    // empty can be ignored (base-case), and > 1 is a separately-reported error.
-                    scopeStack.push(scopes);
-                    scopedDependencyStack.push(dependency);
-                    validateDependencyScopeHierarchy(
-                        graph,
-                        getOnlyElement(scopedDependencies),
-                        scopeStack,
-                        scopedDependencyStack);
-                    scopedDependencyStack.pop();
-                    scopeStack.pop();
-                  }
-                }); // else: we skip component dependencies which are not components
-      }
-    }
-
-    private <T> boolean stackOverlaps(Deque<ImmutableSet<T>> stack, ImmutableSet<T> set) {
-      for (ImmutableSet<T> entry : stack) {
-        if (!Sets.intersection(entry, set).isEmpty()) {
-          return true;
-        }
-      }
-      return false;
-    }
-  }
-
-  ValidationReport<TypeElement> validate(BindingGraph graph) {
-    ComponentValidation validation = new ComponentValidation(graph);
-    validation.traverseComponents();
-    return validation.buildReport();
-  }
-
-  /**
-   * Append and format a list of indented component types (with their scope annotations)
-   */
-  private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeElement> types) {
-    for (TypeElement scopedComponent : types) {
-      message.append(INDENT);
-      for (Scope scope : scopesOf(scopedComponent)) {
-        message.append(getReadableSource(scope)).append(' ');
-      }
-      message.append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))
-          .append('\n');
-    }
-  }
-
-  /**
-   * Returns a set of type elements containing only those found in the input set that have
-   * a scoping annotation.
-   */
-  private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
-    return types.stream().filter(type -> !scopesOf(type).isEmpty()).collect(toImmutableSet());
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentBuilder.java b/java/dagger/internal/codegen/ComponentBuilder.java
index 519fd3742..4b89ebe4c 100644
--- a/java/dagger/internal/codegen/ComponentBuilder.java
+++ b/java/dagger/internal/codegen/ComponentBuilder.java
@@ -251,7 +251,8 @@ private MethodSpec buildMethod() {
           methods.add(builderMethod.build());
         }
       } else {
-        for (ComponentRequirement componentRequirement : graph.availableDependencies()) {
+        for (ComponentRequirement componentRequirement :
+            graph.componentDescriptor().availableDependencies()) {
           String componentRequirementName = simpleVariableName(componentRequirement.typeElement());
           MethodSpec.Builder builderMethod =
               methodBuilder(componentRequirementName)
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 1ce30aefb..dea137fc8 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -31,6 +31,7 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.Scopes.productionScope;
 import static dagger.internal.codegen.Scopes.scopesOf;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 import static javax.lang.model.util.ElementFilter.methodsIn;
@@ -63,6 +64,7 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
+import java.util.stream.Stream;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -206,6 +208,17 @@ boolean isProducer() {
    */
   abstract ImmutableSet<ComponentRequirement> dependencies();
 
+  /** The non-abstract {@link #transitiveModules()} and the {@link #dependencies()}. */
+  ImmutableSet<ComponentRequirement> availableDependencies() {
+    return Stream.concat(
+            transitiveModuleTypes()
+                .stream()
+                .filter(dep -> !dep.getModifiers().contains(ABSTRACT))
+                .map(module -> ComponentRequirement.forModule(module.asType())),
+            dependencies().stream())
+        .collect(toImmutableSet());
+  }
+
   /**
    * The set of {@link ModuleDescriptor modules} declared directly in {@link Component#modules}.
    * Use {@link #transitiveModules} to get the full set of modules available upon traversing
diff --git a/java/dagger/internal/codegen/ComponentDescriptorValidator.java b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
new file mode 100644
index 000000000..8cc8b7c64
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
@@ -0,0 +1,441 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
+import static dagger.internal.codegen.Formatter.INDENT;
+import static dagger.internal.codegen.Scopes.getReadableSource;
+import static dagger.internal.codegen.Scopes.scopesOf;
+import static dagger.internal.codegen.Scopes.singletonScope;
+import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
+import static java.util.stream.Collectors.groupingBy;
+import static java.util.stream.Collectors.joining;
+import static java.util.stream.Collectors.mapping;
+import static java.util.stream.Collectors.toList;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Equivalence;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import dagger.Component;
+import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentRequirement.NullPolicy;
+import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
+import dagger.model.Scope;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+/**
+ * Reports errors in the component hierarchy.
+ *
+ * <ul>
+ *   <li>Validates scope hierarchy of component dependencies and subcompoennts.
+ *   <li>Reports errors if there are component dependency cycles.
+ *   <li>Reports errors if any abstract modules have non-abstract instance binding methods.
+ *   <li>Validates component builder types.
+ * </ul>
+ */
+// TODO(dpb): Combine with ComponentHierarchyValidator.
+final class ComponentDescriptorValidator {
+
+  private final Elements elements;
+  private final DaggerTypes types;
+  private final CompilerOptions compilerOptions;
+  private final MethodSignatureFormatter methodSignatureFormatter;
+  private final ComponentHierarchyValidator componentHierarchyValidator;
+
+  @Inject
+  ComponentDescriptorValidator(
+      Elements elements,
+      DaggerTypes types,
+      CompilerOptions compilerOptions,
+      MethodSignatureFormatter methodSignatureFormatter,
+      ComponentHierarchyValidator componentHierarchyValidator) {
+    this.elements = elements;
+    this.types = types;
+    this.compilerOptions = compilerOptions;
+    this.methodSignatureFormatter = methodSignatureFormatter;
+    this.componentHierarchyValidator = componentHierarchyValidator;
+  }
+
+  ValidationReport<TypeElement> validate(ComponentDescriptor component) {
+    ComponentValidation validation = new ComponentValidation(component);
+    validation.visitComponent(component);
+    validation.report(component).addSubreport(componentHierarchyValidator.validate(component));
+    return validation.buildReport();
+  }
+
+  private final class ComponentValidation {
+    final ComponentDescriptor rootComponent;
+    final Map<ComponentDescriptor, ValidationReport.Builder<TypeElement>> reports =
+        new LinkedHashMap<>();
+
+    ComponentValidation(ComponentDescriptor rootComponent) {
+      this.rootComponent = checkNotNull(rootComponent);
+    }
+
+    /** Returns a report that contains all validation messages found during traversal. */
+    ValidationReport<TypeElement> buildReport() {
+      ValidationReport.Builder<TypeElement> report =
+          ValidationReport.about(rootComponent.componentDefinitionType());
+      reports.values().forEach(subreport -> report.addSubreport(subreport.build()));
+      return report.build();
+    }
+
+    /** Returns the report builder for a (sub)component. */
+    private ValidationReport.Builder<TypeElement> report(ComponentDescriptor component) {
+      return reentrantComputeIfAbsent(
+          reports,
+          component,
+          descriptor -> ValidationReport.about(descriptor.componentDefinitionType()));
+    }
+
+    void visitComponent(ComponentDescriptor component) {
+      validateDependencyScopes(component);
+      validateComponentDependencyHierarchy(component);
+      validateModules(component);
+      validateBuilders(component);
+      component.subcomponents().forEach(this::visitComponent);
+    }
+
+    /** Validates that component dependencies do not form a cycle. */
+    private void validateComponentDependencyHierarchy(ComponentDescriptor component) {
+      validateComponentDependencyHierarchy(
+          component, component.componentDefinitionType(), new ArrayDeque<>());
+    }
+
+    /** Recursive method to validate that component dependencies do not form a cycle. */
+    private void validateComponentDependencyHierarchy(
+        ComponentDescriptor component, TypeElement dependency, Deque<TypeElement> dependencyStack) {
+      if (dependencyStack.contains(dependency)) {
+        // Current component has already appeared in the component chain.
+        StringBuilder message = new StringBuilder();
+        message.append(component.componentDefinitionType().getQualifiedName());
+        message.append(" contains a cycle in its component dependencies:\n");
+        dependencyStack.push(dependency);
+        appendIndentedComponentsList(message, dependencyStack);
+        dependencyStack.pop();
+        report(component)
+            .addItem(
+                message.toString(),
+                compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+                component.componentDefinitionType(),
+                getComponentAnnotation(component.componentDefinitionType()).get());
+      } else {
+        Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(dependency);
+        if (componentAnnotation.isPresent()) {
+          dependencyStack.push(dependency);
+
+          ImmutableSet<TypeElement> dependencies =
+              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get()));
+          for (TypeElement nextDependency : dependencies) {
+            validateComponentDependencyHierarchy(component, nextDependency, dependencyStack);
+          }
+
+          dependencyStack.pop();
+        }
+      }
+    }
+
+    /**
+     * Validates that among the dependencies are at most one scoped dependency, that there are no
+     * cycles within the scoping chain, and that singleton components have no scoped dependencies.
+     */
+    private void validateDependencyScopes(ComponentDescriptor component) {
+      ImmutableSet<Scope> scopes = component.scopes();
+      ImmutableSet<TypeElement> scopedDependencies =
+          scopedTypesIn(
+              component
+                  .dependencies()
+                  .stream()
+                  .map(ComponentRequirement::typeElement)
+                  .collect(toImmutableSet()));
+      if (!scopes.isEmpty()) {
+        Scope singletonScope = singletonScope(elements);
+        // Dagger 1.x scope compatibility requires this be suppress-able.
+        if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()
+            && scopes.contains(singletonScope)) {
+          // Singleton is a special-case representing the longest lifetime, and therefore
+          // @Singleton components may not depend on scoped components
+          if (!scopedDependencies.isEmpty()) {
+            StringBuilder message =
+                new StringBuilder(
+                    "This @Singleton component cannot depend on scoped components:\n");
+            appendIndentedComponentsList(message, scopedDependencies);
+            report(component)
+                .addItem(
+                    message.toString(),
+                    compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+                    component.componentDefinitionType(),
+                    component.componentAnnotation());
+          }
+        } else if (scopedDependencies.size() > 1) {
+          // Scoped components may depend on at most one scoped component.
+          StringBuilder message = new StringBuilder();
+          for (Scope scope : scopes) {
+            message.append(getReadableSource(scope)).append(' ');
+          }
+          message
+              .append(component.componentDefinitionType().getQualifiedName())
+              .append(" depends on more than one scoped component:\n");
+          appendIndentedComponentsList(message, scopedDependencies);
+          report(component)
+              .addError(
+                  message.toString(),
+                  component.componentDefinitionType(),
+                  component.componentAnnotation());
+        } else {
+          // Dagger 1.x scope compatibility requires this be suppress-able.
+          if (!compilerOptions.scopeCycleValidationType().equals(ValidationType.NONE)) {
+            validateDependencyScopeHierarchy(
+                component,
+                component.componentDefinitionType(),
+                new ArrayDeque<ImmutableSet<Scope>>(),
+                new ArrayDeque<TypeElement>());
+          }
+        }
+      } else {
+        // Scopeless components may not depend on scoped components.
+        if (!scopedDependencies.isEmpty()) {
+          StringBuilder message =
+              new StringBuilder(component.componentDefinitionType().getQualifiedName())
+                  .append(" (unscoped) cannot depend on scoped components:\n");
+          appendIndentedComponentsList(message, scopedDependencies);
+          report(component)
+              .addError(
+                  message.toString(),
+                  component.componentDefinitionType(),
+                  component.componentAnnotation());
+        }
+      }
+    }
+
+    private void validateModules(ComponentDescriptor component) {
+      for (ModuleDescriptor module : component.transitiveModules()) {
+        if (module.moduleElement().getModifiers().contains(Modifier.ABSTRACT)) {
+          for (ContributionBinding binding : module.bindings()) {
+            if (binding.requiresModuleInstance()) {
+              report(component).addError(abstractModuleHasInstanceBindingMethodsError(module));
+              break;
+            }
+          }
+        }
+      }
+    }
+
+    private String abstractModuleHasInstanceBindingMethodsError(ModuleDescriptor module) {
+      String methodAnnotations;
+      switch (module.kind()) {
+        case MODULE:
+          methodAnnotations = "@Provides";
+          break;
+        case PRODUCER_MODULE:
+          methodAnnotations = "@Provides or @Produces";
+          break;
+        default:
+          throw new AssertionError(module.kind());
+      }
+      return String.format(
+          "%s is abstract and has instance %s methods. Consider making the methods static or "
+              + "including a non-abstract subclass of the module instead.",
+          module.moduleElement(), methodAnnotations);
+    }
+
+    private void validateBuilders(ComponentDescriptor component) {
+      ComponentDescriptor componentDesc = component;
+      if (!componentDesc.builderSpec().isPresent()) {
+        // If no builder, nothing to validate.
+        return;
+      }
+
+      Set<ComponentRequirement> availableDependencies = component.availableDependencies();
+      Set<ComponentRequirement> requiredDependencies =
+          Sets.filter(
+              availableDependencies,
+              input -> input.nullPolicy(elements, types).equals(NullPolicy.THROW));
+      final BuilderSpec spec = componentDesc.builderSpec().get();
+      ImmutableSet<BuilderRequirementMethod> declaredSetters =
+          spec.requirementMethods()
+              .stream()
+              .filter(method -> !method.requirement().kind().equals(BOUND_INSTANCE))
+              .collect(toImmutableSet());
+      ImmutableSet<ComponentRequirement> declaredRequirements =
+          declaredSetters
+              .stream()
+              .map(BuilderRequirementMethod::requirement)
+              .collect(toImmutableSet());
+
+      ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(component.kind());
+      Set<ComponentRequirement> extraSetters =
+          Sets.difference(declaredRequirements, availableDependencies);
+      if (!extraSetters.isEmpty()) {
+        List<ExecutableElement> excessMethods =
+            declaredSetters
+                .stream()
+                .filter(method -> extraSetters.contains(method.requirement()))
+                .map(BuilderRequirementMethod::method)
+                .collect(toList());
+        Optional<DeclaredType> container =
+            Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType()));
+        String formatted =
+            excessMethods
+                .stream()
+                .map(method -> methodSignatureFormatter.format(method, container))
+                .collect(joining(", ", "[", "]"));
+        report(component)
+            .addError(String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
+      }
+
+      Set<ComponentRequirement> missingSetters =
+          Sets.difference(requiredDependencies, declaredRequirements);
+      if (!missingSetters.isEmpty()) {
+        report(component)
+            .addError(
+                String.format(
+                    msgs.missingSetters(),
+                    missingSetters.stream().map(ComponentRequirement::type).collect(toList())),
+                spec.builderDefinitionType());
+      }
+
+      // Validate that declared builder requirements (modules, dependencies) have unique types.
+      Map<Equivalence.Wrapper<TypeMirror>, List<ExecutableElement>> declaredRequirementsByType =
+          spec.requirementMethods()
+              .stream()
+              .filter(method -> !method.requirement().kind().equals(BOUND_INSTANCE))
+              .collect(
+                  groupingBy(
+                      method -> method.requirement().wrappedType(),
+                      mapping(method -> method.method(), toList())));
+      for (Map.Entry<Equivalence.Wrapper<TypeMirror>, List<ExecutableElement>> entry :
+          declaredRequirementsByType.entrySet()) {
+        if (entry.getValue().size() > 1) {
+          TypeMirror type = entry.getKey().get();
+          report(component)
+              .addError(
+                  String.format(msgs.manyMethodsForType(), type, entry.getValue()),
+                  spec.builderDefinitionType());
+        }
+      }
+    }
+
+    /**
+     * Validates that scopes do not participate in a scoping cycle - that is to say, scoped
+     * components are in a hierarchical relationship terminating with Singleton.
+     *
+     * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
+     * themselves, since a component's presence within its own dependency path implies a cyclical
+     * relationship between scopes. However, cycles in component dependencies are explicitly checked
+     * in {@link #validateComponentDependencyHierarchy(ComponentDescriptor)}.
+     */
+    private void validateDependencyScopeHierarchy(
+        ComponentDescriptor component,
+        TypeElement dependency,
+        Deque<ImmutableSet<Scope>> scopeStack,
+        Deque<TypeElement> scopedDependencyStack) {
+      ImmutableSet<Scope> scopes = scopesOf(dependency);
+      if (stackOverlaps(scopeStack, scopes)) {
+        scopedDependencyStack.push(dependency);
+        // Current scope has already appeared in the component chain.
+        StringBuilder message = new StringBuilder();
+        message.append(component.componentDefinitionType().getQualifiedName());
+        message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
+        appendIndentedComponentsList(message, scopedDependencyStack);
+        if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
+          report(component)
+              .addItem(
+                  message.toString(),
+                  compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+                  component.componentDefinitionType(),
+                  getComponentAnnotation(component.componentDefinitionType()).get());
+        }
+        scopedDependencyStack.pop();
+      } else {
+        // TODO(beder): transitively check scopes of production components too.
+        getAnnotationMirror(dependency, Component.class)
+            .ifPresent(
+                componentAnnotation -> {
+                  ImmutableSet<TypeElement> scopedDependencies =
+                      scopedTypesIn(
+                          MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation)));
+                  if (scopedDependencies.size() == 1) {
+                    // empty can be ignored (base-case), and > 1 is a separately-reported error.
+                    scopeStack.push(scopes);
+                    scopedDependencyStack.push(dependency);
+                    validateDependencyScopeHierarchy(
+                        component,
+                        getOnlyElement(scopedDependencies),
+                        scopeStack,
+                        scopedDependencyStack);
+                    scopedDependencyStack.pop();
+                    scopeStack.pop();
+                  }
+                }); // else: we skip component dependencies which are not components
+      }
+    }
+
+    private <T> boolean stackOverlaps(Deque<ImmutableSet<T>> stack, ImmutableSet<T> set) {
+      for (ImmutableSet<T> entry : stack) {
+        if (!Sets.intersection(entry, set).isEmpty()) {
+          return true;
+        }
+      }
+      return false;
+    }
+
+    /** Appends and formats a list of indented component types (with their scope annotations). */
+    private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeElement> types) {
+      for (TypeElement scopedComponent : types) {
+        message.append(INDENT);
+        for (Scope scope : scopesOf(scopedComponent)) {
+          message.append(getReadableSource(scope)).append(' ');
+        }
+        message
+            .append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))
+            .append('\n');
+      }
+    }
+
+    /**
+     * Returns a set of type elements containing only those found in the input set that have a
+     * scoping annotation.
+     */
+    private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
+      return types.stream().filter(type -> !scopesOf(type).isEmpty()).collect(toImmutableSet());
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 17d06dc7c..9c744d92c 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -47,7 +47,7 @@
   private final Messager messager;
   private final ComponentValidator componentValidator;
   private final BuilderValidator builderValidator;
-  private final ComponentHierarchyValidator componentHierarchyValidator;
+  private final ComponentDescriptorValidator componentDescriptorValidator;
   private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraphFactory bindingGraphFactory;
@@ -61,7 +61,7 @@
       Messager messager,
       ComponentValidator componentValidator,
       BuilderValidator builderValidator,
-      ComponentHierarchyValidator componentHierarchyValidator,
+      ComponentDescriptorValidator componentDescriptorValidator,
       BindingGraphValidator bindingGraphValidator,
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraphFactory bindingGraphFactory,
@@ -72,7 +72,7 @@
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.builderValidator = builderValidator;
-    this.componentHierarchyValidator = componentHierarchyValidator;
+    this.componentDescriptorValidator = componentDescriptorValidator;
     this.bindingGraphValidator = bindingGraphValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
@@ -136,10 +136,10 @@
         }
         ComponentDescriptor componentDescriptor =
             componentDescriptorFactory.forComponent(componentTypeElement);
-        ValidationReport<TypeElement> hierarchyReport =
-            componentHierarchyValidator.validate(componentDescriptor);
-        hierarchyReport.printMessagesTo(messager);
-        if (!hierarchyReport.isClean()) {
+        ValidationReport<TypeElement> componentDescriptorReport =
+            componentDescriptorValidator.validate(componentDescriptor);
+        componentDescriptorReport.printMessagesTo(messager);
+        if (!componentDescriptorReport.isClean()) {
           continue;
         }
         BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
diff --git a/javatests/dagger/internal/codegen/BUILD b/javatests/dagger/internal/codegen/BUILD
index 14634f6df..dd7598e96 100644
--- a/javatests/dagger/internal/codegen/BUILD
+++ b/javatests/dagger/internal/codegen/BUILD
@@ -29,7 +29,7 @@ GenJavaTests(
         "//java/dagger:core",
         "//java/dagger/internal/codegen:base",
         "//java/dagger/internal/codegen:binding",
-        "//java/dagger/internal/codegen:internal_validation",
+        "//java/dagger/internal/codegen:binding_graph_validation",
         "//java/dagger/internal/codegen:processor",
         "//java/dagger/internal/codegen:validation",
         "//java/dagger/internal/codegen:writing",
