diff --git a/index.md b/index.md
index 76b7cf44a..b9ee70808 100644
--- a/index.md
+++ b/index.md
@@ -51,7 +51,7 @@ class CoffeeMaker {
 
 If your class has `@Inject`-annotated fields but no `@Inject`-annotated constructor, Dagger will inject those fields if requested, but will not create new instances. Add a no-argument constructor with the `@Inject` annotation to indicate that Dagger may create instances as well.
 
-Dagger also supports method injection, though it should rarely be used.
+Dagger also supports method injection, though constructor or field injecton are typically preferred.
 
 Classes that lack `@Inject` annotations cannot be constructed by Dagger.
 
@@ -254,7 +254,7 @@ Dependencies may not have multiple qualifier annotations.
 
 ### Compile-time Validation
 
-The Dagger [annotation processor](http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html) is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for `Executor`:
+The Dagger [annotation processor](http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html) is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is installed in a component, which is missing a binding for `Executor`:
 
 ```java
 @Module
@@ -272,18 +272,7 @@ When compiling it, `javac` rejects the missing binding:
 [ERROR] error: java.util.concurrent.Executor cannot be provided without an @Provides-annotated method.
 ```
 
-Fix the problem by adding an `@Provides`-annotated method for `Executor`.
-
-```java
-@Module
-class DripCoffeeModule {
-  @Provides Heater provideHeater(Executor executor) {
-    return new CpuHeater(executor);
-  }
-}
-```
-
-Note that while `@Inject`, `@Module` and `@Provides` annotations are validated individually, all validation of the relationship between bindings happens at the `@Component` level.  While Dagger 1 relied strictly on `@Module`-level validation (which may or may not have reflected runtime behavior), Dagger 2 elides such validation (and the accompanying configuration parameters on `@Module`) in favor of full graph validation.
+Fix the problem by adding an `@Provides`-annotated method for `Executor` to _any_ of the modules in the component.  While `@Inject`, `@Module` and `@Provides` annotations are validated individually, all validation of the relationship between bindings happens at the `@Component` level.  Dagger 1 relied strictly on `@Module`-level validation (which may or may not have reflected runtime behavior), but Dagger 2 elides such validation (and the accompanying configuration parameters on `@Module`) in favor of full graph validation.
 
 ### Compile-time Code Generation
 
@@ -322,6 +311,7 @@ In a Maven project, one would include the runtime in the dependencies section of
 ## License
 
 ```
+Copyright 2014 Google, Inc.
 Copyright 2012 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
