diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 07b3e5b6f..908bb9905 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -808,7 +808,6 @@ private void implementInterfaceMethods() {
               CodeBlock.Builder builder = CodeBlock.builder();
               final boolean supportsTestDelegate = !componentMethod.methodElement().getReturnType().toString().equals(void.class.getName());
               if (supportsTestDelegate) {
-                final ClassName delegateTypeName = Util.getDelegateTypeName(interfaceRequest.key());
                 final String fieldName = Util.getDelegateFieldName(interfaceRequest.key());
                 builder.beginControlFlow("if ($L != null)", CodeBlock.of(fieldName))
                         .add("return $L.get($L)", CodeBlock.of(fieldName), codeBlock)
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 25936ad8d..60e1b70d6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -210,12 +210,12 @@ FactoryCreationStrategy factoryCreationStrategy() {
         return DELEGATE;
       case PROVISION:
         return dependencies().isEmpty() && !requiresModuleInstance()
-            ? SINGLETON_INSTANCE
+            ? CLASS_CONSTRUCTOR
             : CLASS_CONSTRUCTOR;
       case INJECTION:
       case SYNTHETIC_MULTIBOUND_SET:
       case SYNTHETIC_MULTIBOUND_MAP:
-        return dependencies().isEmpty() ? SINGLETON_INSTANCE : CLASS_CONSTRUCTOR;
+        return dependencies().isEmpty() ? CLASS_CONSTRUCTOR : CLASS_CONSTRUCTOR;
       default:
         return CLASS_CONSTRUCTOR;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java b/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java
index 216dbb9d2..8d518dea7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java
@@ -41,8 +41,8 @@ public CodeBlock get() {
 
                 ContributionBinding binding = resolvedBindings.contributionBinding();
                 if (bindingSupportsTestDelegate(binding) && shouldCreateDelegate(binding)) {
-                    final String delegateFieldName = Util.getDelegateFieldName(resolvedBindings.binding().key());
-                    final ClassName delegateType = getDelegateTypeName(resolvedBindings.binding().key());
+                    final String delegateFieldName = Util.getDelegateFieldName(resolvedBindings.key());
+                    final ClassName delegateType = getDelegateTypeName(resolvedBindings.key());
                     final String methodName = "with" + delegateType.simpleName();
                     codeBuilder.add(".$L($L)\n", methodName, delegateFieldName);
                 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index d7535662f..15068dcab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.asPackage;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.isType;
@@ -45,10 +46,12 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
 import dagger.Binds;
 import dagger.BindsOptionalOf;
+import dagger.MapKey;
 import dagger.Multibindings;
-import dagger.multibindings.Multibinds;
+import dagger.multibindings.*;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.Production;
@@ -62,13 +65,10 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Executor;
+import javax.inject.Named;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.*;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
@@ -176,9 +176,13 @@ abstract Builder multibindingContributionIdentifier(
    */
   static final class MultibindingContributionIdentifier {
     private final String identifierString;
+    private final ExecutableElement bindingMethod;
+    private final TypeElement contributingModule;
 
     MultibindingContributionIdentifier(
         ExecutableElement bindingMethod, TypeElement contributingModule) {
+      this.bindingMethod = bindingMethod;
+      this.contributingModule = contributingModule;
       this.identifierString =
           String.format(
               "%s#%s", contributingModule.getQualifiedName(), bindingMethod.getSimpleName());
@@ -195,6 +199,76 @@ public String toString() {
       return identifierString;
     }
 
+    public ClassName getDelegateTypeName() {
+      final TypeMirror returnType = bindingMethod.getReturnType();
+      final Named annotation = bindingMethod.getAnnotation(Named.class);
+      final ClassName name = ClassName.bestGuess(Util.typeToString(returnType));
+      final String packageName = name.packageName();
+      if (annotation != null) {
+          return ClassName.bestGuess(packageName + "." + capitalizeFirstLetter(annotation.value()) + "Delegate");
+      }else {
+        final java.util.Optional<? extends AnnotationMirror> annotationMirror = getAnnotationMirror(bindingMethod);
+        if(annotationMirror.isPresent()) {
+          return ClassName.bestGuess(packageName + "." + getCapitalizedAnnotationValue(annotationMirror.get()) + "In" + contributingModule.getSimpleName().toString() + "Delegate");
+        }else {
+          return ClassName.bestGuess(packageName + "." + capitalizeFirstLetter(bindingMethod.getSimpleName().toString()) + "For" + contributingModule.getSimpleName().toString() + "Delegate");
+        }
+      }
+    }
+
+    public String getDelegateFieldName() {
+      final TypeMirror returnType = bindingMethod.getReturnType();
+      final Named annotation = bindingMethod.getAnnotation(Named.class);
+      if (annotation != null) {
+        return Util.lowerCaseFirstLetter(annotation.value())  + "Delegate";
+      }else {
+        final java.util.Optional<? extends AnnotationMirror> annotationMirror = getAnnotationMirror(returnType);
+        if(annotationMirror.isPresent()) {
+          return Util.lowerCaseFirstLetter(getCapitalizedAnnotationValue(annotationMirror.get())) + "Delegate";
+        }else {
+          return bindingMethod.getSimpleName().toString() + "For" + contributingModule.getSimpleName().toString() + "Delegate";
+        }
+      }
+    }
+
+    private static String getCapitalizedAnnotationValue(AnnotationMirror annotation) {
+      final Map<? extends ExecutableElement, ? extends AnnotationValue> elementValues = annotation.getElementValues();
+      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : elementValues.entrySet()) {
+        if (entry.getKey().getSimpleName().toString().equals("value")) {
+          final String original = entry.getValue().getValue().toString();
+          if (!original.isEmpty()) {
+            return capitalizeFirstLetter(original);
+          }
+        }
+      }
+      throw new IllegalStateException("value not found");
+    }
+
+    private static String capitalizeFirstLetter(String original) {
+      if (original == null || original.length() == 0) {
+        return original;
+      }
+      return original.substring(0, 1).toUpperCase() + original.substring(1);
+    }
+
+    private static java.util.Optional<? extends AnnotationMirror> getAnnotationMirror(TypeMirror typeMirror) {
+      final ImmutableList<String> annotations =
+              ImmutableList.of(Named.class.getName(), StringKey.class.getName(), IntKey.class.getName(), LongKey.class.getName(), MapKey.class.getName(), ClassKey.class.getName());
+
+      return typeMirror.getAnnotationMirrors().stream()
+              .filter(e -> Util.isAnnotationPresent(MoreTypes.asElement(typeMirror), e.getAnnotationType()))
+              .findFirst();
+    }
+
+    private static java.util.Optional<? extends AnnotationMirror> getAnnotationMirror(ExecutableElement method) {
+      final ImmutableList<String> annotations =
+              ImmutableList.of(Named.class.getName(), StringKey.class.getName(), IntKey.class.getName(), LongKey.class.getName(), MapKey.class.getName(), ClassKey.class.getName());
+
+      return method.getAnnotationMirrors().stream()
+              .filter(e -> annotations.contains(e.getAnnotationType().toString()))
+              .findFirst();
+    }
+
     @Override
     public boolean equals(Object obj) {
       return obj instanceof MultibindingContributionIdentifier
diff --git a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
index 7a23b068b..a0d4bf6b7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
@@ -28,7 +28,7 @@
 
     @Override
     ClassName nameGeneratedType(ProvisionBinding input) {
-        return Util.getDelegateTypeName(input);
+        return Util.getDelegateTypeName(input.key());
     }
 
     @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index df0ade229..861e00a26 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -36,456 +36,602 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.*;
-import dagger.Binds;
-import dagger.Provides;
-import dagger.ProvidesComponent;
-import dagger.ProvidesModule;
+import dagger.*;
+import dagger.multibindings.ClassKey;
+import dagger.multibindings.IntKey;
+import dagger.multibindings.LongKey;
+import dagger.multibindings.StringKey;
 import dagger.producers.Produces;
+
 import java.lang.annotation.Annotation;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.function.Predicate;
 import java.util.stream.Collector;
 import javax.inject.Named;
 import javax.lang.model.element.*;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.*;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 /**
  * Utilities for handling types in annotation processors
  */
 final class Util {
-  /**
-   * Returns true if the passed {@link TypeElement} requires a passed instance in order to be used
-   * within a component.
-   */
-  static boolean requiresAPassedInstance(Elements elements, Types types, TypeElement typeElement) {
-    ImmutableSet<ExecutableElement> methods =
-        getLocalAndInheritedMethods(typeElement, types, elements);
-    boolean foundInstanceMethod = false;
-    for (ExecutableElement method : methods) {
-      if (method.getModifiers().contains(ABSTRACT)
-          && !MoreElements.isAnnotationPresent(method, Binds.class)) {
+    /**
+     * Returns true if the passed {@link TypeElement} requires a passed instance in order to be used
+     * within a component.
+     */
+    static boolean requiresAPassedInstance(Elements elements, Types types, TypeElement typeElement) {
+        ImmutableSet<ExecutableElement> methods =
+                getLocalAndInheritedMethods(typeElement, types, elements);
+        boolean foundInstanceMethod = false;
+        for (ExecutableElement method : methods) {
+            if (method.getModifiers().contains(ABSTRACT)
+                    && !MoreElements.isAnnotationPresent(method, Binds.class)) {
         /* We found an abstract method that isn't a @Binds method.  That automatically means that
          * a user will have to provide an instance because we don't know which subclass to use. */
-        return true;
-      } else if (!method.getModifiers().contains(STATIC)
-          && isAnyAnnotationPresent(method, Provides.class, Produces.class)) {
-        foundInstanceMethod = true;
-      }
-    }
-
-    if (foundInstanceMethod) {
-      return !componentCanMakeNewInstances(typeElement);
-    }
-
-    return false;
-  }
-
-  /**
-   * Returns true if and only if a component can instantiate new instances (typically of a module)
-   * rather than requiring that they be passed.
-   */
-  static boolean componentCanMakeNewInstances(TypeElement typeElement) {
-    switch (typeElement.getKind()) {
-      case CLASS:
-        break;
-      case ENUM:
-      case ANNOTATION_TYPE:
-      case INTERFACE:
+                return true;
+            } else if (!method.getModifiers().contains(STATIC)
+                    && isAnyAnnotationPresent(method, Provides.class, Produces.class)) {
+                foundInstanceMethod = true;
+            }
+        }
+
+        if (foundInstanceMethod) {
+            return !componentCanMakeNewInstances(typeElement);
+        }
+
         return false;
-      default:
-        throw new AssertionError("TypeElement cannot have kind: " + typeElement.getKind());
     }
 
-    if (typeElement.getModifiers().contains(ABSTRACT)) {
-      return false;
+    /**
+     * Returns true if and only if a component can instantiate new instances (typically of a module)
+     * rather than requiring that they be passed.
+     */
+    static boolean componentCanMakeNewInstances(TypeElement typeElement) {
+        switch (typeElement.getKind()) {
+            case CLASS:
+                break;
+            case ENUM:
+            case ANNOTATION_TYPE:
+            case INTERFACE:
+                return false;
+            default:
+                throw new AssertionError("TypeElement cannot have kind: " + typeElement.getKind());
+        }
+
+        if (typeElement.getModifiers().contains(ABSTRACT)) {
+            return false;
+        }
+
+        if (requiresEnclosingInstance(typeElement)) {
+            return false;
+        }
+
+        for (Element enclosed : typeElement.getEnclosedElements()) {
+            if (enclosed.getKind().equals(CONSTRUCTOR)
+                    && ((ExecutableElement) enclosed).getParameters().isEmpty()
+                    && !enclosed.getModifiers().contains(PRIVATE)) {
+                return true;
+            }
+        }
+
+        // TODO(gak): still need checks for visibility
+
+        return false;
     }
 
-    if (requiresEnclosingInstance(typeElement)) {
-      return false;
+    private static boolean requiresEnclosingInstance(TypeElement typeElement) {
+        switch (typeElement.getNestingKind()) {
+            case TOP_LEVEL:
+                return false;
+            case MEMBER:
+                return !typeElement.getModifiers().contains(STATIC);
+            case ANONYMOUS:
+            case LOCAL:
+                return true;
+            default:
+                throw new AssertionError(
+                        "TypeElement cannot have nesting kind: " + typeElement.getNestingKind());
+        }
     }
 
-    for (Element enclosed : typeElement.getEnclosedElements()) {
-      if (enclosed.getKind().equals(CONSTRUCTOR)
-          && ((ExecutableElement) enclosed).getParameters().isEmpty()
-          && !enclosed.getModifiers().contains(PRIVATE)) {
-        return true;
-      }
+    static ImmutableSet<ExecutableElement> getUnimplementedMethods(
+            Elements elements, Types types, TypeElement type) {
+        return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
+                .filter(hasModifiers(ABSTRACT))
+                .toSet();
     }
 
-    // TODO(gak): still need checks for visibility
+    /**
+     * A function that returns the input as a {@link DeclaredType}.
+     */
+    static final Function<TypeElement, DeclaredType> AS_DECLARED_TYPE =
+            typeElement -> asDeclared(typeElement.asType());
+
+    /**
+     * A visitor that returns the input or the closest enclosing element that is a
+     * {@link TypeElement}.
+     */
+    static final ElementVisitor<TypeElement, Void> ENCLOSING_TYPE_ELEMENT =
+            new SimpleElementVisitor6<TypeElement, Void>() {
+                @Override
+                protected TypeElement defaultAction(Element e, Void p) {
+                    return visit(e.getEnclosingElement());
+                }
+
+                @Override
+                public TypeElement visitType(TypeElement e, Void p) {
+                    return e;
+                }
+            };
+
+    /**
+     * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
+     * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
+     * as any of that of {@code annotationClasses}.
+     */
+    // TODO(dpb): Move to MoreElements.
+    static boolean isAnyAnnotationPresent(
+            Element element, Iterable<? extends Class<? extends Annotation>> annotationClasses) {
+        for (Class<? extends Annotation> annotation : annotationClasses) {
+            if (MoreElements.isAnnotationPresent(element, annotation)) {
+                return true;
+            }
+        }
+        return false;
+    }
 
-    return false;
-  }
+    @SafeVarargs
+    static boolean isAnyAnnotationPresent(
+            Element element,
+            Class<? extends Annotation> first,
+            Class<? extends Annotation>... otherAnnotations) {
+        return isAnyAnnotationPresent(element, asList(first, otherAnnotations));
+    }
 
-  private static boolean requiresEnclosingInstance(TypeElement typeElement) {
-    switch (typeElement.getNestingKind()) {
-      case TOP_LEVEL:
-        return false;
-      case MEMBER:
-        return !typeElement.getModifiers().contains(STATIC);
-      case ANONYMOUS:
-      case LOCAL:
-        return true;
-      default:
-        throw new AssertionError(
-            "TypeElement cannot have nesting kind: " + typeElement.getNestingKind());
-    }
-  }
-
-  static ImmutableSet<ExecutableElement> getUnimplementedMethods(
-      Elements elements, Types types, TypeElement type) {
-    return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
-        .filter(hasModifiers(ABSTRACT))
-        .toSet();
-  }
-
-  /** A function that returns the input as a {@link DeclaredType}. */
-  static final Function<TypeElement, DeclaredType> AS_DECLARED_TYPE =
-      typeElement -> asDeclared(typeElement.asType());
-
-  /**
-   * A visitor that returns the input or the closest enclosing element that is a
-   * {@link TypeElement}.
-   */
-  static final ElementVisitor<TypeElement, Void> ENCLOSING_TYPE_ELEMENT =
-      new SimpleElementVisitor6<TypeElement, Void>() {
-        @Override
-        protected TypeElement defaultAction(Element e, Void p) {
-          return visit(e.getEnclosingElement());
+    /**
+     * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose {@linkplain
+     * AnnotationMirror#getAnnotationType() annotation type} is equivalent to {@code annotationType}.
+     */
+    // TODO(dpb): Move to MoreElements.
+    static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
+        return element
+                .getAnnotationMirrors()
+                .stream()
+                .map(AnnotationMirror::getAnnotationType)
+                .anyMatch(candidate -> MoreTypes.equivalence().equivalent(candidate, annotationType));
+    }
+
+    /**
+     * The elements in {@code elements} that are annotated with an annotation of type
+     * {@code annotation}.
+     */
+    static <E extends Element> FluentIterable<E> elementsWithAnnotation(
+            Iterable<E> elements, final Class<? extends Annotation> annotation) {
+        return FluentIterable.from(elements)
+                .filter(element -> MoreElements.isAnnotationPresent(element, annotation));
+    }
+
+    /**
+     * A function that returns the simple name of an element.
+     */
+    static final Function<Element, String> ELEMENT_SIMPLE_NAME =
+            element -> element.getSimpleName().toString();
+
+    /**
+     * A {@link Comparator} that puts absent {@link Optional}s before present ones, and compares
+     * present {@link Optional}s by their values.
+     */
+    static <C extends Comparable<C>> Comparator<Optional<C>> optionalComparator() {
+        return Comparator.comparing((Optional<C> optional) -> optional.isPresent())
+                .thenComparing(Optional::get);
+    }
+
+    /**
+     * Returns a {@link Collector} that accumulates the input elements into a new {@link
+     * ImmutableList}, in encounter order.
+     */
+    static <T> Collector<T, ?, ImmutableList<T>> toImmutableList() {
+        return collectingAndThen(toList(), ImmutableList::copyOf);
+    }
+
+    /**
+     * Returns a {@link Collector} that accumulates the input elements into a new {@link
+     * ImmutableSet}, in encounter order.
+     */
+    static <T> Collector<T, ?, ImmutableSet<T>> toImmutableSet() {
+        return collectingAndThen(toList(), ImmutableSet::copyOf);
+    }
+
+    public static String toParameterName(String simpleName) {
+        return Character.toLowerCase(simpleName.charAt(0)) + simpleName.substring(1);
+    }
+
+    public static String extractPackage(TypeMirror classType) {
+        return classType.toString().replaceAll("." + convertDataClassToString(classType), "");
+    }
+
+    public static String extractClassName(TypeMirror classType) {
+        return convertDataClassToString(classType);
+    }
+
+    public static String extractClassName(String s) {
+        int index = s.lastIndexOf(".");
+        return s.substring(index + 1);
+    }
+
+    public static String convertDataClassToString(TypeMirror dataClass) {
+        String s = dataClass.toString();
+        int index = s.lastIndexOf(".");
+        return s.substring(index + 1);
+    }
+
+    static ClassName getDelegateTypeName(Key key) {
+        if (!key.multibindingContributionIdentifier().isPresent()) {
+            if (key.qualifier().isPresent()) {
+                final java.util.Optional<String> qualifier = key.qualifier().get().getElementValues().values().stream()
+                        .map((java.util.function.Function<AnnotationValue, String>) annotationValue -> annotationValue.getValue().toString())
+                        .findFirst();
+                if (qualifier.isPresent()) {
+                    final PackageElement packageElement = getPackage(MoreTypes.asElement(key.type()));
+                    final String classNameString = packageElement.getQualifiedName().toString() + "." + capitalizeFirstLetter(qualifier.get()) + "Delegate";
+                    return ClassName.bestGuess(classNameString);
+                }
+            }
+            return ClassName.bestGuess(typeToString(key.type()) + "Delegate");
+        }
+        return key.multibindingContributionIdentifier().get().getDelegateTypeName();
+    }
+
+    static String getDelegateFieldName(Key key) {
+        if (!key.multibindingContributionIdentifier().isPresent()) {
+            if (key.qualifier().isPresent()) {
+                final java.util.Optional<String> qualifier = key.qualifier().get().getElementValues().values().stream()
+                        .map((java.util.function.Function<AnnotationValue, String>) annotationValue -> annotationValue.getValue().toString())
+                        .findFirst();
+                if (qualifier.isPresent()) {
+                    return lowerCaseFirstLetter(qualifier.get()) + "Delegate";
+                }
+            }
+            return toParameterName(extractClassName(typeToString(key.type()))) + "Delegate";
+        }
+        return key.multibindingContributionIdentifier().get().getDelegateFieldName();
+    }
+
+    /**
+     * Returns a string for {@code type}. Primitive types are always boxed.
+     */
+    public static String typeToString(TypeMirror type) {
+        StringBuilder result = new StringBuilder();
+        typeToString(type, result, '.', false);
+        return result.toString();
+    }
+
+    /**
+     * Returns a string for the raw type of {@code type}. Primitive types are always boxed.
+     */
+    public static String rawTypeToString(TypeMirror type, char innerClassSeparator) {
+        if (!(type instanceof DeclaredType)) {
+            throw new IllegalArgumentException("Unexpected type: " + type);
+        }
+        StringBuilder result = new StringBuilder();
+        DeclaredType declaredType = (DeclaredType) type;
+        rawTypeToString(result, (TypeElement) declaredType.asElement(), innerClassSeparator, false);
+        return result.toString();
+    }
+
+    public static PackageElement getPackage(Element type) {
+        while (type.getKind() != ElementKind.PACKAGE) {
+            type = type.getEnclosingElement();
         }
+        return (PackageElement) type;
+    }
 
-        @Override
-        public TypeElement visitType(TypeElement e, Void p) {
-          return e;
+    static void rawTypeToString(StringBuilder result, TypeElement type, char innerClassSeparator, boolean typeParam) {
+        if (typeParam) {
+            final String s = MoreElements.asType(type).getSimpleName().toString();
+            result.append(s);
+            return;
         }
-      };
-
-  /**
-   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
-   * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
-   * as any of that of {@code annotationClasses}.
-   */
-  // TODO(dpb): Move to MoreElements.
-  static boolean isAnyAnnotationPresent(
-      Element element, Iterable<? extends Class<? extends Annotation>> annotationClasses) {
-    for (Class<? extends Annotation> annotation : annotationClasses) {
-      if (MoreElements.isAnnotationPresent(element, annotation)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  @SafeVarargs
-  static boolean isAnyAnnotationPresent(
-      Element element,
-      Class<? extends Annotation> first,
-      Class<? extends Annotation>... otherAnnotations) {
-    return isAnyAnnotationPresent(element, asList(first, otherAnnotations));
-  }
-
-  /**
-   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose {@linkplain
-   * AnnotationMirror#getAnnotationType() annotation type} is equivalent to {@code annotationType}.
-   */
-  // TODO(dpb): Move to MoreElements.
-  static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
-    return element
-        .getAnnotationMirrors()
-        .stream()
-        .map(AnnotationMirror::getAnnotationType)
-        .anyMatch(candidate -> MoreTypes.equivalence().equivalent(candidate, annotationType));
-  }
-
-  /**
-   * The elements in {@code elements} that are annotated with an annotation of type
-   * {@code annotation}.
-   */
-  static <E extends Element> FluentIterable<E> elementsWithAnnotation(
-      Iterable<E> elements, final Class<? extends Annotation> annotation) {
-    return FluentIterable.from(elements)
-        .filter(element -> MoreElements.isAnnotationPresent(element, annotation));
-  }
-
-  /** A function that returns the simple name of an element. */
-  static final Function<Element, String> ELEMENT_SIMPLE_NAME =
-      element -> element.getSimpleName().toString();
-
-  /**
-   * A {@link Comparator} that puts absent {@link Optional}s before present ones, and compares
-   * present {@link Optional}s by their values.
-   */
-  static <C extends Comparable<C>> Comparator<Optional<C>> optionalComparator() {
-    return Comparator.comparing((Optional<C> optional) -> optional.isPresent())
-        .thenComparing(Optional::get);
-  }
-
-  /**
-   * Returns a {@link Collector} that accumulates the input elements into a new {@link
-   * ImmutableList}, in encounter order.
-   */
-  static <T> Collector<T, ?, ImmutableList<T>> toImmutableList() {
-    return collectingAndThen(toList(), ImmutableList::copyOf);
-  }
-
-  /**
-   * Returns a {@link Collector} that accumulates the input elements into a new {@link
-   * ImmutableSet}, in encounter order.
-   */
-  static <T> Collector<T, ?, ImmutableSet<T>> toImmutableSet() {
-    return collectingAndThen(toList(), ImmutableSet::copyOf);
-  }
-
-  static ClassName getDelegateTypeName(Key key) {
-    final ClassName topLevelClassName = getTopLevelClassName(key.type());
-    if (key.qualifier().isPresent() && key.qualifier().get().getAnnotationType().asElement().asType().toString().equals(Named.class.getName())) {
-      final AnnotationMirror annotationMirror = key.qualifier().get();
-      String value = "";
-      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationMirror.getElementValues().entrySet()) {
-        if (entry.getKey().getSimpleName().toString().equals("value")) {
-          value = entry.getValue().getValue().toString();
-          break;
+
+        String packageName = getPackage(type).getQualifiedName().toString();
+        String qualifiedName = type.getQualifiedName().toString();
+        if (packageName.isEmpty()) {
+            result.append(qualifiedName.replace('.', innerClassSeparator));
+        } else {
+            result.append(packageName);
+            result.append('.');
+            result.append(
+                    qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
         }
-      }
-      return ClassName.bestGuess(topLevelClassName.packageName() + "." + capitalizeFirstLetter(value) + "Delegate");
-    }else {
-      return ClassName.bestGuess(getBaseDelegateClassName(key.type()) + "Delegate");
-    }
-  }
-
-  static String getDelegateFieldName(Key key) {
-
-    if (key.qualifier().isPresent() && key.qualifier().get().getAnnotationType().asElement().asType().toString().equals(Named.class.getName())) {
-      final AnnotationMirror annotationMirror = key.qualifier().get();
-      String value = "";
-      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationMirror.getElementValues().entrySet()) {
-        if (entry.getKey().getSimpleName().toString().equals("value")) {
-          value = entry.getValue().getValue().toString();
-          break;
+    }
+
+    /**
+     * Appends a string for {@code type} to {@code result}. Primitive types are
+     * always boxed.
+     *
+     * @param innerClassSeparator either '.' or '$', which will appear in a
+     *                            class name like "java.lang.Map.Entry" or "java.lang.Map$Entry".
+     *                            Use '.' for references to existing types in code. Use '$' to define new
+     *                            class names and for strings that will be used by runtime reflection.
+     */
+    public static void typeToString(final TypeMirror type, final StringBuilder result, final char innerClassSeparator, boolean typeParam) {
+        type.accept(new SimpleTypeVisitor6<Void, Void>() {
+            @Override
+            public Void visitDeclared(DeclaredType declaredType, Void v) {
+                TypeElement typeElement = (TypeElement) declaredType.asElement();
+                rawTypeToString(result, typeElement, innerClassSeparator, typeParam);
+                List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+                if (!typeArguments.isEmpty()) {
+                    result.append("Of");
+                    for (int i = 0; i < typeArguments.size(); i++) {
+                        if (i != 0) {
+                            result.append(", ");
+                        }
+                        typeToString(typeArguments.get(i), result, '\0', true);
+                    }
+                }
+                return null;
+            }
+
+            @Override
+            public Void visitPrimitive(PrimitiveType primitiveType, Void v) {
+                result.append(box((PrimitiveType) type));
+                return null;
+            }
+
+            @Override
+            public Void visitArray(ArrayType arrayType, Void v) {
+                TypeMirror type = arrayType.getComponentType();
+                if (type instanceof PrimitiveType) {
+                    result.append("ArrayOf" + extractClassName(type)); // Don't box, since this is an array.
+                } else {
+                    typeToString(arrayType.getComponentType(), result, innerClassSeparator, true);
+                }
+                result.append("_");
+                return null;
+            }
+
+            @Override
+            public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
+                result.append(typeVariable.asElement().getSimpleName());
+                return null;
+            }
+
+            @Override
+            public Void visitError(ErrorType errorType, Void v) {
+                // Error type found, a type may not yet have been generated, but we need the type
+                // so we can generate the correct code in anticipation of the type being available
+                // to the compiler.
+
+                // Paramterized types which don't exist are returned as an error type whose name is "<any>"
+                if ("<any>".equals(errorType.toString())) {
+                    throw new IllegalStateException(
+                            "Type reported as <any> is likely a not-yet generated parameterized type.");
+                }
+                // TODO(cgruber): Figure out a strategy for non-FQCN cases.
+                result.append(errorType.toString());
+                return null;
+            }
+
+            @Override
+            protected Void defaultAction(TypeMirror typeMirror, Void v) {
+                throw new UnsupportedOperationException(
+                        "Unexpected TypeKind " + typeMirror.getKind() + " for " + typeMirror);
+            }
+        }, null);
+    }
+
+    static TypeName box(PrimitiveType primitiveType) {
+        switch (primitiveType.getKind()) {
+            case BYTE:
+                return ClassName.get(Byte.class);
+            case SHORT:
+                return ClassName.get(Short.class);
+            case INT:
+                return ClassName.get(Integer.class);
+            case LONG:
+                return ClassName.get(Long.class);
+            case FLOAT:
+                return ClassName.get(Float.class);
+            case DOUBLE:
+                return ClassName.get(Double.class);
+            case BOOLEAN:
+                return ClassName.get(Boolean.class);
+            case CHAR:
+                return ClassName.get(Character.class);
+            case VOID:
+                return ClassName.get(Void.class);
+            default:
+                throw new AssertionError();
+        }
+    }
+
+    private static java.util.Optional<? extends AnnotationMirror> getAnnotationMirror(Element element) {
+        final ImmutableList<String> annotations =
+                ImmutableList.of(Named.class.getName(), StringKey.class.getName(), IntKey.class.getName(), LongKey.class.getName(), MapKey.class.getName(), ClassKey.class.getName());
+
+        return element.getAnnotationMirrors().stream()
+                .filter(e -> annotations.contains(e.getAnnotationType().asElement().asType().toString()))
+                .findFirst();
+    }
+
+    private static java.util.Optional<? extends AnnotationMirror> getAnnotationMirror(TypeMirror typeMirror) {
+        final ImmutableList<String> annotations =
+                ImmutableList.of(Named.class.getName(), StringKey.class.getName(), IntKey.class.getName(), LongKey.class.getName(), MapKey.class.getName(), ClassKey.class.getName());
+
+        return typeMirror.getAnnotationMirrors().stream()
+                .filter(e -> annotations.contains(e.getAnnotationType().asElement().asType().toString()))
+                .findFirst();
+    }
+
+    private static String getCapitalizedAnnotationValue(AnnotationMirror annotation) {
+        final Map<? extends ExecutableElement, ? extends AnnotationValue> elementValues = annotation.getElementValues();
+        for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : elementValues.entrySet()) {
+            if (entry.getKey().getSimpleName().toString().equals("value")) {
+                final String original = entry.getValue().getValue().toString();
+                if (!original.isEmpty()) {
+                    return capitalizeFirstLetter(original);
+                }
+            }
+        }
+        throw new IllegalStateException("value not found");
+    }
+
+    private static String capitalizeFirstLetter(String original) {
+        if (original == null || original.length() == 0) {
+            return original;
         }
-      }
-      return lowerCaseFirstLetter(value) + "Delegate";
-    }else {
-      return lowerCaseFirstLetter(ClassName.bestGuess(key.type().toString()).simpleName()) + "Delegate";
-    }
-  }
-
-  static ClassName getDelegateTypeName(ProvisionBinding binding) {
-    String baseClassName;
-    if (binding.requiresModuleInstance()) {
-      ExecutableElement element = (ExecutableElement) binding.bindingElement().get();
-      baseClassName = getBaseDelegateClassName(binding.contributedType(), element);
-      return ClassName.bestGuess(baseClassName + "Delegate");
-    }else {
-      baseClassName = getBaseDelegateClassName(binding.key().type());
-      return ClassName.bestGuess(baseClassName + "Delegate");
-    }
-  }
-
-  private static String getBaseDelegateClassName(TypeMirror typeMirror, Element element) {
-    String baseClassName;
-    ClassName bestGuess = getTopLevelClassName(typeMirror);
-    if (element.getAnnotation(Named.class) != null) {
-      baseClassName = bestGuess.packageName() + "." + getCapitalizedAnnotationValue(element);
-    }else if (typeMirror.getAnnotation(Named.class) != null) {
-      baseClassName = bestGuess.packageName() + "." + getCapitalizedAnnotationValue(typeMirror);
-    }else {
-      baseClassName = typeMirror.toString();
-    }
-    return baseClassName;
-  }
-
-  private static String getCapitalizedAnnotationValue(Element element) {
-    return capitalizeFirstLetter(element.getAnnotation(Named.class).value());
-  }
-
-  private static ClassName getTopLevelClassName(TypeMirror typeMirror) {
-    return ClassName.bestGuess(typeMirror.toString()).topLevelClassName();
-  }
-
-  private static String getBaseDelegateClassName(TypeMirror typeMirror) {
-    String baseClassName;
-    ClassName bestGuess = getTopLevelClassName(typeMirror);
-    if (typeMirror.getAnnotation(Named.class) != null) {
-      baseClassName = bestGuess.packageName() + "." + getCapitalizedAnnotationValue(typeMirror);
-    }else {
-      baseClassName = typeMirror.toString();
-    }
-    return baseClassName;
-  }
-
-  private static String getCapitalizedAnnotationValue(TypeMirror typeMirror) {
-    return capitalizeFirstLetter(typeMirror.getAnnotation(Named.class).value());
-  }
-
-  private static String capitalizeFirstLetter(String original) {
-    if (original == null || original.length() == 0) {
-      return original;
-    }
-    return original.substring(0, 1).toUpperCase() + original.substring(1);
-  }
-
-  public static String lowerCaseFirstLetter(String original) {
-    if (original == null || original.length() == 0) {
-      return original;
-    }
-    return original.substring(0, 1).toLowerCase() + original.substring(1);
-  }
-
-  public static boolean bindingSupportsTestDelegate(ContributionBinding binding) {
-    final ImmutableList<ContributionBinding.Kind> kinds = ImmutableList.of(
-            ContributionBinding.Kind.PROVISION,
-            ContributionBinding.Kind.COMPONENT_PROVISION,
-            ContributionBinding.Kind.INJECTION
-    );
-    final ContributionBinding.Kind kind = binding.bindingKind();
-    return kinds.contains(kind);
-  }
-
-  private Util() {}
-
-  public static void createDelegateFieldAndMethod(ClassName generatedTypeName, TypeSpec.Builder classBuilder, ResolvedBindings resolvedBindings, Map<Key, String> delegateFieldNames) {
-      try {
-          ContributionBinding binding = resolvedBindings.contributionBinding();
-          if (bindingSupportsTestDelegate(binding)) {
-              final String delegateFieldName = Util.getDelegateFieldName(resolvedBindings.binding().key());
-              final ClassName delegateType = getDelegateTypeName(resolvedBindings.binding().key());
-              final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
-              delegateFieldNames.put(resolvedBindings.key(), delegateFieldName);
-              final FieldSpec fieldSpec = builder.build();
-              classBuilder.addField(fieldSpec);
-            final String methodName = "with" + delegateType.simpleName();
-              classBuilder.addMethod(MethodSpec.methodBuilder(methodName)
-                      .addModifiers(Modifier.PUBLIC)
-                      .returns(generatedTypeName)
-                      .addParameter(delegateType, delegateFieldName)
-                      .addStatement("this.$N = $L", fieldSpec, CodeBlock.of(delegateFieldName))
-                      .addStatement("return this")
-                      .build());
-          }
-      }catch(Exception e) {}
-  }
-
-  public static String getFieldName(Key key) {
-    if (key.qualifier().isPresent()) {
-      final AnnotationMirror annotationMirror = key.qualifier().get();
-      String value = "";
-      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationMirror.getElementValues().entrySet()) {
-        if (entry.getKey().getSimpleName().toString().equals("value")) {
-          value = entry.getValue().getValue().toString();
-          break;
+        return original.substring(0, 1).toUpperCase() + original.substring(1);
+    }
+
+    public static String lowerCaseFirstLetter(String original) {
+        if (original == null || original.length() == 0) {
+            return original;
         }
-      }
-      return  capitalizeFirstLetter(value);
-    }else {
-      return capitalizeFirstLetter(ClassName.bestGuess(key.type().toString()).simpleName());
-    }
-  }
-
-  public static ClassName getDaggerComponentClassName(ClassName componentDefinitionClassName) {
-      String componentName =
-        "Dagger" + Joiner.on('_').join(componentDefinitionClassName.simpleNames());
-      return componentDefinitionClassName.topLevelClassName().peerClass(componentName);
-  }
-
-  public static ClassName getDaggerComponentClassName(Element component) {
-      return getDaggerComponentClassName(ClassName.bestGuess(component.asType().toString()));
-  }
-
-  public static HashMap<String, ExecutableElement> findProvidingMethodsOfModules(Types typeUtils, Element componentProvider){
-    HashMap<String, ExecutableElement> providingMethods = new HashMap<>();
-    if (componentProvider.getKind() == ElementKind.CLASS){
-      TypeElement typeElement = (TypeElement) componentProvider;
-      for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
-        if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
-      }
-      typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
-      while (!typeElement.toString().equals(Object.class.getName())) {
-        for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
-          if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+        return original.substring(0, 1).toLowerCase() + original.substring(1);
+    }
+
+    public static boolean bindingSupportsTestDelegate(ContributionBinding binding) {
+        final ImmutableList<ContributionBinding.Kind> kinds = ImmutableList.of(
+                ContributionBinding.Kind.PROVISION,
+                ContributionBinding.Kind.COMPONENT_PROVISION,
+                ContributionBinding.Kind.INJECTION
+        );
+        final ContributionBinding.Kind kind = binding.bindingKind();
+        return kinds.contains(kind);
+    }
+
+    private Util() {
+    }
+
+    public static void createDelegateFieldAndMethod(ClassName generatedTypeName, TypeSpec.Builder classBuilder, ResolvedBindings resolvedBindings, Map<Key, String> delegateFieldNames) {
+        try {
+            ContributionBinding binding = resolvedBindings.contributionBinding();
+            if (bindingSupportsTestDelegate(binding)) {
+                final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+                final ClassName delegateType = getDelegateTypeName(binding.key());
+                final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
+                delegateFieldNames.put(binding.key(), delegateFieldName);
+                final FieldSpec fieldSpec = builder.build();
+                classBuilder.addField(fieldSpec);
+                final String methodName = "with" + delegateType.simpleName();
+                classBuilder.addMethod(MethodSpec.methodBuilder(methodName)
+                        .addModifiers(Modifier.PUBLIC)
+                        .returns(generatedTypeName)
+                        .addParameter(delegateType, delegateFieldName)
+                        .addStatement("this.$N = $L", fieldSpec, CodeBlock.of(delegateFieldName))
+                        .addStatement("return this")
+                        .build());
+            }
+        } catch (Exception e) {
         }
-        typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
-      }
-    }
-    return providingMethods;
-  }
-
-  public static HashMap<String, ExecutableElement> findProvidingMethodsOfComponents(Types typeUtils, Element componentProvider){
-    HashMap<String, ExecutableElement> providingMethods = new HashMap<>();
-    if (componentProvider.getKind() == ElementKind.CLASS){
-      TypeElement typeElement = (TypeElement) componentProvider;
-      for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
-        if (!providingMethods.containsKey(e.getKey()))
-          providingMethods.put(e.getKey(), e.getValue());
-      }
-      typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
-      while (!typeElement.toString().equals(Object.class.getName())) {
-        for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
-          if (!providingMethods.containsKey(e.getKey()))
-            providingMethods.put(e.getKey(), e.getValue());
+    }
+
+    public static ClassName getDaggerComponentClassName(ClassName componentDefinitionClassName) {
+        String componentName =
+                "Dagger" + Joiner.on('_').join(componentDefinitionClassName.simpleNames());
+        return componentDefinitionClassName.topLevelClassName().peerClass(componentName);
+    }
+
+    public static ClassName getDaggerComponentClassName(Element component) {
+        return getDaggerComponentClassName(ClassName.bestGuess(typeToString(component.asType())));
+    }
+
+    public static HashMap<String, ExecutableElement> findProvidingMethodsOfModules(Types typeUtils, Element componentProvider) {
+        HashMap<String, ExecutableElement> providingMethods = new HashMap<>();
+        if (componentProvider.getKind() == ElementKind.CLASS) {
+            TypeElement typeElement = (TypeElement) componentProvider;
+            for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
+                if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+            }
+            typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+            while (!typeElement.toString().equals(Object.class.getName())) {
+                for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
+                    if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+                }
+                typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+            }
         }
-        typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
-      }
-    }
-    return providingMethods;
-  }
-
-  public static HashMap<String, ExecutableElement> findProvidingMethods(Types typeUtils, Element componentProvider){
-    HashMap<String, ExecutableElement> providingMethods = new HashMap<>();
-    if (componentProvider.getKind() == ElementKind.CLASS){
-      TypeElement typeElement = (TypeElement) componentProvider;
-      for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
-        if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
-      }
-      for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
-        if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
-      }
-      typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
-      while (!typeElement.toString().equals(Object.class.getName())) {
-        for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
-          if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+        return providingMethods;
+    }
+
+    public static HashMap<String, ExecutableElement> findProvidingMethodsOfComponents(Types typeUtils, Element componentProvider) {
+        HashMap<String, ExecutableElement> providingMethods = new HashMap<>();
+        if (componentProvider.getKind() == ElementKind.CLASS) {
+            TypeElement typeElement = (TypeElement) componentProvider;
+            for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
+                if (!providingMethods.containsKey(e.getKey()))
+                    providingMethods.put(e.getKey(), e.getValue());
+            }
+            typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+            while (!typeElement.toString().equals(Object.class.getName())) {
+                for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
+                    if (!providingMethods.containsKey(e.getKey()))
+                        providingMethods.put(e.getKey(), e.getValue());
+                }
+                typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+            }
         }
-        for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
-          if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+        return providingMethods;
+    }
+
+    public static HashMap<String, ExecutableElement> findProvidingMethods(Types typeUtils, Element componentProvider) {
+        HashMap<String, ExecutableElement> providingMethods = new HashMap<>();
+        if (componentProvider.getKind() == ElementKind.CLASS) {
+            TypeElement typeElement = (TypeElement) componentProvider;
+            for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
+                if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+            }
+            for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
+                if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+            }
+            typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+            while (!typeElement.toString().equals(Object.class.getName())) {
+                for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
+                    if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+                }
+                for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
+                    if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+                }
+                typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+            }
         }
-        typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
-      }
-    }
-    return providingMethods;
-  }
-
-  private static HashMap<String, ExecutableElement> findProvidingModuleMethodsInternal(TypeElement element, HashMap<String, ExecutableElement> providingMethods) {
-    List<? extends Element> enclosedElements = element.getEnclosedElements();
-    for (Element enclosedElement : enclosedElements) {
-      if (enclosedElement.getKind() == ElementKind.METHOD){
-        ProvidesModule providesModule = enclosedElement.getAnnotation(ProvidesModule.class);
-        if (providesModule != null){
-          ExecutableElement executableElement = (ExecutableElement) enclosedElement;
-          providingMethods.put(executableElement.getReturnType().toString(), executableElement);
+        return providingMethods;
+    }
+
+    private static HashMap<String, ExecutableElement> findProvidingModuleMethodsInternal(TypeElement element, HashMap<String, ExecutableElement> providingMethods) {
+        List<? extends Element> enclosedElements = element.getEnclosedElements();
+        for (Element enclosedElement : enclosedElements) {
+            if (enclosedElement.getKind() == ElementKind.METHOD) {
+                ProvidesModule providesModule = enclosedElement.getAnnotation(ProvidesModule.class);
+                if (providesModule != null) {
+                    ExecutableElement executableElement = (ExecutableElement) enclosedElement;
+                    providingMethods.put(executableElement.getReturnType().toString(), executableElement);
+                }
+            }
         }
-      }
-    }
-    return providingMethods;
-  }
-
-  private static HashMap<String, ExecutableElement> findProvidingComponentMethodsInternal(TypeElement element, HashMap<String, ExecutableElement> providingMethods) {
-    List<? extends Element> enclosedElements = element.getEnclosedElements();
-    for (Element enclosedElement : enclosedElements) {
-      if (enclosedElement.getKind() == ElementKind.METHOD){
-        ProvidesComponent providesComponent = enclosedElement.getAnnotation(ProvidesComponent.class);
-        if (providesComponent != null){
-          ExecutableElement executableElement = (ExecutableElement) enclosedElement;
-          providingMethods.put(executableElement.getReturnType().toString(), executableElement);
+        return providingMethods;
+    }
+
+    private static HashMap<String, ExecutableElement> findProvidingComponentMethodsInternal(TypeElement element, HashMap<String, ExecutableElement> providingMethods) {
+        List<? extends Element> enclosedElements = element.getEnclosedElements();
+        for (Element enclosedElement : enclosedElements) {
+            if (enclosedElement.getKind() == ElementKind.METHOD) {
+                ProvidesComponent providesComponent = enclosedElement.getAnnotation(ProvidesComponent.class);
+                if (providesComponent != null) {
+                    ExecutableElement executableElement = (ExecutableElement) enclosedElement;
+                    providingMethods.put(executableElement.getReturnType().toString(), executableElement);
+                }
+            }
         }
-      }
+        return providingMethods;
     }
-    return providingMethods;
-  }
 
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
index 1a2a5945e..72b901137 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
@@ -19,6 +19,13 @@
 import android.app.Activity;
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.multibindings.StringKey;
+
+import javax.inject.Named;
+import java.util.Arrays;
+import java.util.List;
 
 /**
  * A module to wrap the Activity state and expose it to the graph.
@@ -37,4 +44,30 @@ public ActivityModule(Activity activity) {
   @Provides @PerActivity Activity activity() {
     return activity;
   }
+
+  @Provides
+  @StringKey("AAA")
+  @IntoMap
+  public String aString() {
+    return "A";
+  }
+
+  @Provides
+  @StringKey("BBB")
+  @IntoMap
+  public String bString() {
+    return "B";
+  }
+
+  @Provides
+  @Named("AnyString")
+  public String cString() {
+    return "B";
+  }
+
+  @Provides
+  public List<String> list() {
+    return Arrays.asList("A", "B", "C");
+  }
+
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
index f7cccd484..5e746dc6d 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
@@ -19,6 +19,8 @@
 import android.app.Activity;
 import android.app.Application;
 import android.location.LocationManager;
+import com.example.dagger.activitygraphs.ui.DaggerHomeComponent;
+import com.example.dagger.activitygraphs.ui.HomeComponent;
 import dagger.Injector;
 import dagger.Provides;
 import dagger.ProvidesComponent;
@@ -58,4 +60,12 @@ public FragmentComponent fragmentComponent(AbstractActivityComponent component)
       return null;
   }
 
+  @ProvidesComponent
+  public HomeComponent homeComponent(Activity activity) {
+    return DaggerHomeComponent.builder()
+            .activityModule(new ActivityModule(activity))
+            .applicationComponent(this.component())
+            .build();
+  }
+
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
index dcdb1b885..08c88df79 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
@@ -21,12 +21,28 @@
 import android.support.v4.app.FragmentActivity;
 import com.example.dagger.activitygraphs.ActivityModule;
 import com.example.dagger.activitygraphs.DemoApplication;
+import com.example.dagger.activitygraphs.SomeClass;
+
 import javax.inject.Inject;
+import javax.inject.Named;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 public class HomeActivity extends FragmentActivity {
+
   @Inject LocationManager locationManager;
   private HomeComponent component;
 
+  @Inject
+  SomeClass someClass;
+
+  @Inject
+  List<String> list;
+
+  @Inject
+  Map<String, String> map;
+
   HomeComponent component() {
     if (component == null) {
       component = DaggerHomeComponent.builder()
