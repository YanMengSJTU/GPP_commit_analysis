diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 1f2ecb6b5..d07ad2105 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -18,7 +18,7 @@
 package(default_visibility = ["//:src"])
 
 load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
-load("//tools:maven.bzl", "pom_file", "POM_VERSION")
+load("//tools:maven.bzl", "POM_VERSION", "pom_file")
 load("//tools:simple_jar.bzl", "simple_jar")
 
 EXPERIMENTAL_VISUALIZER_SRCS = ["BindingNetworkVisualizer.java"]
@@ -257,6 +257,7 @@ java_library(
         "GeneratedComponentModel.java",
         "GeneratedInstanceBindingExpression.java",
         "GwtCompatibility.java",
+        "HjarSourceFileGenerator.java",
         "ImmediateFutureBindingExpression.java",
         "InaccessibleMapKeyProxyGenerator.java",
         "InjectionMethods.java",
@@ -341,6 +342,7 @@ java_library(
         "ProcessingEnvironmentModule.java",
         "ProcessingOptions.java",
         "ProductionExecutorModuleProcessingStep.java",
+        "SourceFileGeneratorsModule.java",
         "SystemComponentsModule.java",
     ],
     plugins = CODEGEN_PLUGINS,
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 62881c3d3..0337702b6 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -49,7 +49,7 @@
   private final ComponentDescriptorValidator componentDescriptorValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraphFactory bindingGraphFactory;
-  private final ComponentGenerator componentGenerator;
+  private final SourceFileGenerator<BindingGraph> componentGenerator;
   private final BindingGraphConverter bindingGraphConverter;
   private final BindingGraphPlugins validationPlugins;
   private final BindingGraphPlugins spiPlugins;
@@ -63,7 +63,7 @@
       ComponentDescriptorValidator componentDescriptorValidator,
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraphFactory bindingGraphFactory,
-      ComponentGenerator componentGenerator,
+      SourceFileGenerator<BindingGraph> componentGenerator,
       BindingGraphConverter bindingGraphConverter,
       @Validation BindingGraphPlugins validationPlugins,
       BindingGraphPlugins spiPlugins,
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index 7505c4ce3..0a48df17f 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -50,8 +50,8 @@
   private final Optional<ImmutableSet<BindingGraphPlugin>> testingPlugins;
 
   @Inject InjectBindingRegistry injectBindingRegistry;
-  @Inject FactoryGenerator factoryGenerator;
-  @Inject MembersInjectorGenerator membersInjectorGenerator;
+  @Inject SourceFileGenerator<ProvisionBinding> factoryGenerator;
+  @Inject SourceFileGenerator<MembersInjectionBinding> membersInjectorGenerator;
   @Inject ImmutableList<ProcessingStep> processingSteps;
   @Inject BindingGraphPlugins spiPlugins;
   @Inject CompilerOptions compilerOptions;
@@ -124,6 +124,7 @@ public SourceVersion getSupportedSourceVersion() {
         BindingMethodValidatorsModule.class,
         IncorrectlyInstalledBindsMethodsValidator.Module.class,
         ProcessingStepsModule.class,
+        SourceFileGeneratorsModule.class,
         SystemComponentsModule.class
       })
   interface ProcessorComponent {
@@ -174,7 +175,9 @@ Builder testingPlugins(
           bindsInstanceProcessingStep,
           moduleProcessingStep,
           compilerOptions.headerCompilation()
-                  // TODO(b/72748365): Support hjars for ahead-of-time subcomponents.
+                  // Ahead Of Time subcomponents use the regular hjar filtering in
+                  // HjarSourceFileGenerator since they must retain protected implementation methods
+                  // between subcomponents
                   && !compilerOptions.aheadOfTimeSubcomponents()
               ? componentHjarProcessingStep
               : componentProcessingStep,
diff --git a/java/dagger/internal/codegen/HjarSourceFileGenerator.java b/java/dagger/internal/codegen/HjarSourceFileGenerator.java
new file mode 100644
index 000000000..1e98b5117
--- /dev/null
+++ b/java/dagger/internal/codegen/HjarSourceFileGenerator.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+import java.util.Optional;
+import javax.lang.model.element.Element;
+
+/**
+ * A source file generator that only writes the relevant code necessary for Bazel to create a
+ * correct header (ABI) jar.
+ */
+final class HjarSourceFileGenerator<T> extends SourceFileGenerator<T> {
+  private final SourceFileGenerator<T> delegate;
+
+  private HjarSourceFileGenerator(SourceFileGenerator<T> delegate) {
+    super(delegate);
+    this.delegate = delegate;
+  }
+
+  static <T> SourceFileGenerator<T> wrap(SourceFileGenerator<T> delegate) {
+    return new HjarSourceFileGenerator<>(delegate);
+  }
+
+  @Override
+  ClassName nameGeneratedType(T input) {
+    return delegate.nameGeneratedType(input);
+  }
+
+  @Override
+  Element originatingElement(T input) {
+    return delegate.originatingElement(input);
+  }
+
+  @Override
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, T input) {
+    return delegate
+        .write(generatedTypeName, input)
+        .map(completeType -> skeletonType(completeType.build()));
+  }
+
+  private TypeSpec.Builder skeletonType(TypeSpec completeType) {
+    TypeSpec.Builder skeleton =
+        classBuilder(completeType.name)
+            .addSuperinterfaces(completeType.superinterfaces)
+            .addTypeVariables(completeType.typeVariables);
+
+    if (!completeType.superclass.equals(ClassName.OBJECT)) {
+      skeleton.superclass(completeType.superclass);
+    }
+
+    completeType.modifiers.forEach(skeleton::addModifiers);
+
+    completeType.methodSpecs.stream()
+        .filter(method -> !method.modifiers.contains(PRIVATE) || method.isConstructor())
+        .map(this::skeletonMethod)
+        .forEach(skeleton::addMethod);
+
+    completeType.typeSpecs.stream()
+        .filter(type -> !type.modifiers.contains(PRIVATE))
+        .map(type -> skeletonType(type).build())
+        .forEach(skeleton::addType);
+
+    // Dagger has no fields that are exposed in its APIs, but if we add some, we need to implement
+    // skeleton fields here.
+
+    return skeleton;
+  }
+
+  private MethodSpec skeletonMethod(MethodSpec completeMethod) {
+    MethodSpec.Builder skeleton =
+        completeMethod.isConstructor()
+            ? constructorBuilder()
+            : methodBuilder(completeMethod.name).returns(completeMethod.returnType);
+
+    if (completeMethod.isConstructor()) {
+      // Code in Turbine must (for technical reasons in javac) have a valid super() call for
+      // constructors, otherwise javac will bark, and Turbine has no way to avoid this. So we retain
+      // constructor method bodies if they do exist
+      skeleton.addCode(completeMethod.code);
+    }
+
+    return skeleton
+        .addModifiers(completeMethod.modifiers)
+        .addTypeVariables(completeMethod.typeVariables)
+        .addParameters(completeMethod.parameters)
+        .addExceptions(completeMethod.exceptions)
+        .varargs(completeMethod.varargs)
+        .build();
+  }
+}
diff --git a/java/dagger/internal/codegen/ModuleProcessingStep.java b/java/dagger/internal/codegen/ModuleProcessingStep.java
index 5e6609bfe..63fe008db 100644
--- a/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -47,8 +47,8 @@
   private final Messager messager;
   private final ModuleValidator moduleValidator;
   private final BindingFactory bindingFactory;
-  private final FactoryGenerator factoryGenerator;
-  private final ProducerFactoryGenerator producerFactoryGenerator;
+  private final SourceFileGenerator<ProvisionBinding> factoryGenerator;
+  private final SourceFileGenerator<ProductionBinding> producerFactoryGenerator;
   private final InaccessibleMapKeyProxyGenerator inaccessibleMapKeyProxyGenerator;
   private final DelegateDeclaration.Factory delegateDeclarationFactory;
   private final Set<TypeElement> processedModuleElements = Sets.newLinkedHashSet();
@@ -58,8 +58,8 @@
       Messager messager,
       ModuleValidator moduleValidator,
       BindingFactory bindingFactory,
-      FactoryGenerator factoryGenerator,
-      ProducerFactoryGenerator producerFactoryGenerator,
+      SourceFileGenerator<ProvisionBinding> factoryGenerator,
+      SourceFileGenerator<ProductionBinding> producerFactoryGenerator,
       InaccessibleMapKeyProxyGenerator inaccessibleMapKeyProxyGenerator,
       Factory delegateDeclarationFactory) {
     this.messager = messager;
diff --git a/java/dagger/internal/codegen/SourceFileGenerator.java b/java/dagger/internal/codegen/SourceFileGenerator.java
index 8c663c9c4..2409987a2 100644
--- a/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -51,6 +51,10 @@
     this.sourceVersion = checkNotNull(sourceVersion);
   }
 
+  SourceFileGenerator(SourceFileGenerator<T> delegate) {
+    this(delegate.filer, delegate.elements, delegate.sourceVersion);
+  }
+
   /**
    * Generates a source file to be compiled for {@code T}. Writes any generation exception to {@code
    * messager} and does not throw.
diff --git a/java/dagger/internal/codegen/SourceFileGeneratorsModule.java b/java/dagger/internal/codegen/SourceFileGeneratorsModule.java
new file mode 100644
index 000000000..2fe2a2f9b
--- /dev/null
+++ b/java/dagger/internal/codegen/SourceFileGeneratorsModule.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.codegen.SourceFileGeneratorsModule.ComponentModule;
+import dagger.internal.codegen.SourceFileGeneratorsModule.MembersInjectionModule;
+import dagger.internal.codegen.SourceFileGeneratorsModule.ProductionModule;
+import dagger.internal.codegen.SourceFileGeneratorsModule.ProvisionModule;
+
+@Module(
+    includes = {
+      ProvisionModule.class,
+      ProductionModule.class,
+      MembersInjectionModule.class,
+      ComponentModule.class
+    })
+interface SourceFileGeneratorsModule {
+  @Module
+  abstract class GeneratorModule<T, G extends SourceFileGenerator<T>> {
+    @Provides
+    SourceFileGenerator<T> generator(G generator, CompilerOptions compilerOptions) {
+      return compilerOptions.headerCompilation()
+          ? HjarSourceFileGenerator.wrap(generator)
+          : generator;
+    }
+  }
+
+  @Module
+  class ProvisionModule extends GeneratorModule<ProvisionBinding, FactoryGenerator> {}
+
+  @Module
+  class ProductionModule extends GeneratorModule<ProductionBinding, ProducerFactoryGenerator> {}
+
+  @Module
+  class MembersInjectionModule
+      extends GeneratorModule<MembersInjectionBinding, MembersInjectorGenerator> {}
+
+  @Module
+  class ComponentModule extends GeneratorModule<BindingGraph, ComponentGenerator> {}
+}
