diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
index 17f1800b5..2ebf1745a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
@@ -18,6 +18,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
@@ -115,4 +116,21 @@ private static AnnotationMirror getQualifier(
     }
     return qualifier;
   }
+
+  /**
+   * @param providerMethod
+   * @return
+   */
+  public static String getMapKey(ExecutableElement method) {
+    // TODO(houcy): Auto-generated method stub
+    StringBuilder result = new StringBuilder();
+    AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors());
+    if (qualifier != null) {
+      qualifierToString(qualifier, result);
+    }
+    result.append(SET_PREFIX);
+    typeToString(method.getReturnType(), result, '$');
+    result.append(">");
+    return result.toString();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index 1c9af42fe..44c8c43d1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -21,10 +21,12 @@
 import dagger.internal.Binding.InvalidBindingException;
 import dagger.internal.BindingsGroup;
 import dagger.internal.Linker;
+import dagger.internal.MapBinding;
 import dagger.internal.ProblemDetector;
 import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
 import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
+
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -39,6 +41,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
@@ -58,6 +61,8 @@
 
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
+import static dagger.Provides.Type.MAP;
+import static dagger.Provides.Type.MAP_VALUES;
 import static dagger.internal.codegen.Util.className;
 import static dagger.internal.codegen.Util.getAnnotation;
 import static dagger.internal.codegen.Util.getPackage;
@@ -181,11 +186,23 @@ private void error(String message, Element element) {
         @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
           return super.put(key, value);
         }
+
+        @Override
+        public Binding<?> contributeMapBinding(String key, MapBinding<?> value) {
+          // TODO(houcy): Auto-generated method stub
+          return super.put(key, value);
+        }
       };
       BindingsGroup overrideBindings = new BindingsGroup() {
         @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
           throw new IllegalStateException("Module overrides cannot contribute set bindings.");
         }
+
+        @Override
+        public Binding<?> contributeMapBinding(String key, MapBinding<?> value) {
+          // TODO(houcy): Auto-generated method stub
+          throw new IllegalStateException("Module overrides cannot contribute map bindings.");
+        }
       };
       for (TypeElement module : allModules.values()) {
         Map<String, Object> annotation = getAnnotation(Module.class, module);
@@ -237,6 +254,20 @@ private void error(String message, Element element) {
               error(message, providerMethod);
             }
           }
+          
+          if (previous != null) {
+            if ((provides.type() == MAP || provides.type() == MAP_VALUES)
+                && previous instanceof MapBinding) {
+              // No duplicate bindings error if both bindings are set bindings.
+            } else {
+              String message = "Duplicate bindings for " + key;
+              if (overrides) {
+                message += " in override module(s) - cannot override an override";
+              }
+              message += ":\n    " + previous.requiredBy + "\n    " + binding.requiredBy;
+              error(message, providerMethod);
+            }
+          }
 
           switch (provides.type()) {
             case UNIQUE:
@@ -259,6 +290,14 @@ private void error(String message, Element element) {
               SetBinding.add(addTo, key, binding);
               break;
 
+            case MAP:
+              String mapKey = GeneratorKeys.getMapKey(providerMethod);
+              SetBinding.add(addTo, mapKey, binding);
+              break;
+
+            case MAP_VALUES:
+              MapBinding.add(addTo, key, binding);
+              break;
             default:
               throw new AssertionError("Unknown @Provides type " + provides.type());
           }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 870fb87d6..b9a5e58ac 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -25,6 +25,7 @@
 import dagger.internal.ModuleAdapter;
 import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
+import dagger.internal.MapBinding;
 import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
 import java.io.StringWriter;
@@ -61,6 +62,8 @@
 
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
+import static dagger.Provides.Type.MAP;
+import static dagger.Provides.Type.MAP_VALUES;
 import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
 import static dagger.internal.codegen.Util.adapterName;
 import static dagger.internal.codegen.Util.elementToString;
@@ -361,6 +364,20 @@ private void generateModuleAdapter(Writer ioWriter, String adapterName, TypeElem
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
             break;
           }
+          case MAP: {
+            String key = GeneratorKeys.getMapKey(providerMethod);
+            writer.emitStatement("MapBinding.add(bindings, %s, new %s(module))",
+                JavaWriter.stringLiteral(key),
+                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
+            break;
+          }
+          case MAP_VALUES: {
+            String key = GeneratorKeys.get(providerMethod);
+            writer.emitStatement("MapBinding.add(bindings, %s, new %s(module))",
+                JavaWriter.stringLiteral(key),
+                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
+            break;
+          }
           default:
             throw new AssertionError("Unknown @Provides type " + provides.type());
         }
@@ -392,6 +409,7 @@ private void generateModuleAdapter(Writer ioWriter, String adapterName, TypeElem
     }
     if (multibindings) {
       imports.add(SetBinding.class.getCanonicalName());
+      imports.add(MapBinding.class.getCanonicalName());
     }
     return imports;
   }
@@ -405,12 +423,16 @@ private boolean checkForDependencies(List<ExecutableElement> providerMethods) {
     return false;
   }
 
+  //??? not sure whether should add map
   private boolean checkForMultibindings(List<ExecutableElement> providerMethods) {
     for (ExecutableElement element : providerMethods) {
       Provides.Type providesType = element.getAnnotation(Provides.class).type();
       if (providesType == SET || providesType == SET_VALUES) {
         return true;
       }
+      if (providesType == MAP || providesType == MAP_VALUES) {
+        return true;
+      }
     }
     return false;
   }
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 1e86b1b82..9c72ce54c 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -22,6 +22,7 @@
 import dagger.internal.Keys;
 import dagger.internal.Linker;
 import dagger.internal.Loader;
+import dagger.internal.MapBinding;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.Modules;
 import dagger.internal.Modules.ModuleWithAdapter;
@@ -29,6 +30,7 @@
 import dagger.internal.SetBinding;
 import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
+
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -143,13 +145,14 @@ static ObjectGraph createWith(Loader loader, Object... modules) {
     private final Map<Class<?>, StaticInjection> staticInjections;
     private final Map<String, Class<?>> injectableTypes;
     private final List<SetBinding<?>> setBindings;
+    private final List<MapBinding<?>> mapBindings;
 
     DaggerObjectGraph(DaggerObjectGraph base,
         Linker linker,
         Loader plugin,
         Map<Class<?>, StaticInjection> staticInjections,
         Map<String, Class<?>> injectableTypes,
-        List<SetBinding<?>> setBindings) {
+        List<SetBinding<?>> setBindings, List<MapBinding<?>> mapBindings) {
 
       this.base = base;
       this.linker = checkNotNull(linker, "linker");
@@ -157,6 +160,7 @@ static ObjectGraph createWith(Loader loader, Object... modules) {
       this.staticInjections = checkNotNull(staticInjections, "staticInjections");
       this.injectableTypes = checkNotNull(injectableTypes, "injectableTypes");
       this.setBindings = checkNotNull(setBindings, "setBindings");
+      this.mapBindings = checkNotNull(mapBindings, "mapBindings");
     }
 
     private static <T> T checkNotNull(T object, String label) {
@@ -169,7 +173,7 @@ private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Obje
       Map<Class<?>, StaticInjection> staticInjections
           = new LinkedHashMap<Class<?>, StaticInjection>();
       StandardBindings baseBindings =
-          (base == null) ? new StandardBindings() : new StandardBindings(base.setBindings);
+          (base == null) ? new StandardBindings() : new StandardBindings(base.setBindings, base.mapBindings);
       BindingsGroup overrideBindings = new OverridesBindings();
 
       ArrayList<ModuleWithAdapter> loadedModules = Modules.loadModules(plugin, modules);
@@ -201,7 +205,7 @@ private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Obje
       linker.installBindings(overrideBindings);
 
       return new DaggerObjectGraph(
-          base, linker, plugin, staticInjections, injectableTypes, baseBindings.setBindings);
+          base, linker, plugin, staticInjections, injectableTypes, baseBindings.setBindings, baseBindings.mapBindings);
     }
 
     @Override public ObjectGraph plus(Object... modules) {
@@ -326,9 +330,11 @@ private void linkInjectableTypes() {
    */
   private static final class StandardBindings extends BindingsGroup {
     private final List<SetBinding<?>> setBindings;
+    private final List<MapBinding<?>> mapBindings;
 
     public StandardBindings() {
       setBindings = new ArrayList<SetBinding<?>>();
+      mapBindings = new ArrayList<MapBinding<?>>();
     }
 
     public StandardBindings(List<SetBinding<?>> baseSetBindings) {
@@ -339,12 +345,41 @@ public StandardBindings(List<SetBinding<?>> baseSetBindings) {
         setBindings.add(child);
         put(child.provideKey, child);
       }
+      mapBindings = new ArrayList<MapBinding<?>>();
+    }
+    
+    public StandardBindings(List<SetBinding<?>> baseSetBindings, List<MapBinding<?>> baseMapBindings) {
+      setBindings = new ArrayList<SetBinding<?>>(baseSetBindings.size());
+      for (SetBinding<?> sb : baseSetBindings) {
+        @SuppressWarnings({ "rawtypes", "unchecked" })
+        SetBinding<?> child = new SetBinding(sb);
+        setBindings.add(child);
+        put(child.provideKey, child);
+      }
+      
+      mapBindings = new ArrayList<MapBinding<?>>(baseMapBindings.size());
+      for (MapBinding<?> mb : baseMapBindings) {
+        @SuppressWarnings({ "rawtypes", "unchecked" })
+        MapBinding<?> child = new MapBinding(mb);
+        mapBindings.add(child);
+        put(child.provideKey, child);
+      }
     }
 
     @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
       setBindings.add(value);
       return super.put(key, value);
     }
+
+    /* (non-Javadoc)
+     * @see dagger.internal.BindingsGroup#contributeMapBinding(java.lang.String, dagger.internal.MapBinding)
+     */
+    @Override
+    public Binding<?> contributeMapBinding(String key, MapBinding<?> value) {
+      // TODO(houcy): Auto-generated method stub
+      mapBindings.add(value);
+      return super.put(key, value);
+    }
   }
 
   /**
@@ -358,5 +393,14 @@ public StandardBindings(List<SetBinding<?>> baseSetBindings) {
     @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
       throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
     }
+
+    /* (non-Javadoc)
+     * @see dagger.internal.BindingsGroup#contributeMapBinding(java.lang.String, dagger.internal.MapBinding)
+     */
+    @Override
+    public Binding<?> contributeMapBinding(String key, MapBinding<?> value) {
+      // TODO(houcy): Auto-generated method stub
+      throw new IllegalArgumentException("Module overrides cannot contribute map bindings.");
+    }
   }
 }
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index edcb27b64..9283929fd 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -53,7 +53,9 @@
      * contributed to the set. An example use is to provide a default empty set binding, which is
      * otherwise not possible using {@link #SET}.
      */
-    SET_VALUES;
+    SET_VALUES,
+    MAP,
+    MAP_VALUES;
   }
 
   Type type() default Type.UNIQUE;
diff --git a/core/src/main/java/dagger/internal/BindingsGroup.java b/core/src/main/java/dagger/internal/BindingsGroup.java
index 861f7de86..d2052162f 100644
--- a/core/src/main/java/dagger/internal/BindingsGroup.java
+++ b/core/src/main/java/dagger/internal/BindingsGroup.java
@@ -29,6 +29,8 @@
   private final Map<String, Binding<?>> bindings = new LinkedHashMap<String, Binding<?>>();
 
   public abstract Binding<?> contributeSetBinding(String key, SetBinding<?> value);
+  
+  public abstract Binding<?> contributeMapBinding(String key, MapBinding<?> value);
 
   public Binding<?> contributeProvidesBinding(String key, ProvidesBinding<?> value) {
     return put(key, value);
diff --git a/core/src/main/java/dagger/internal/MapBinding.java b/core/src/main/java/dagger/internal/MapBinding.java
new file mode 100644
index 000000000..588fd2cef
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MapBinding.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2012 Google, Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * A {@code Binding<T>} which contains contributors (other bindings marked with
+ * {@code @Provides} {@code @OneOf}), to which it delegates provision
+ * requests on an as-needed basis.
+ */
+public final class MapBinding<T> extends Binding<Set<T>> {
+
+  public static <T> void add(BindingsGroup bindings, String setKey, Binding<?> binding) {
+    prepareMapBinding(bindings, setKey, binding).contributors.add(Linker.scope(binding));
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> MapBinding<T> prepareMapBinding(
+      BindingsGroup bindings, String setKey, Binding<?> binding) {
+    Binding<?> previous = bindings.get(setKey);
+    MapBinding<T> MapBinding;
+    if (previous instanceof MapBinding) {
+      MapBinding = (MapBinding<T>) previous;
+      MapBinding.setLibrary(MapBinding.library() && binding.library());
+      return MapBinding;
+    } else if (previous != null) {
+      throw new IllegalArgumentException("Duplicate:\n    " + previous + "\n    " + binding);
+    } else {
+      MapBinding = new MapBinding<T>(setKey, binding.requiredBy);
+      MapBinding.setLibrary(binding.library());
+      bindings.contributeMapBinding(setKey, MapBinding);
+      return (MapBinding<T>) bindings.get(setKey); // BindingMap.put() copies MapBindings.
+    }
+  }
+
+  /**
+   * A {@link MapBinding} with whose contributing bindings this set-binding provides a union
+   * view.
+   */
+  private final MapBinding<T> parent;
+
+  /**
+   * A {@link Set} of {@link Binding} instances which contribute values to the injected set.
+   */
+  private final List<Binding<?>> contributors;
+
+  /**
+   * Creates a new {@code MapBinding} with the given "provides" key, and the requiredBy object
+   * for traceability.
+   */
+  public MapBinding(String key, Object requiredBy) {
+    super(key, null, false, requiredBy);
+    parent = null;
+    contributors = new ArrayList<Binding<?>>();
+  }
+
+  /**
+   * Creates a new {@code MapBinding} with all of the contributing bindings of the provided
+   * original {@code MapBinding}.
+   */
+  public MapBinding(MapBinding<T> original) {
+    super(original.provideKey, null, false, original.requiredBy);
+    parent = original;
+    this.setLibrary(original.library());
+    this.setDependedOn(original.dependedOn());
+    contributors = new ArrayList<Binding<?>>();
+  }
+
+  @Override public void attach(Linker linker) {
+    for (Binding<?> contributor : contributors) {
+      contributor.attach(linker);
+    }
+  }
+
+  public int size() {
+    int size = 0;
+    for (MapBinding<T> binding = this; binding != null; binding = binding.parent) {
+      size += binding.contributors.size();
+    }
+    return size;
+  }
+
+  @SuppressWarnings("unchecked") // Only Binding<T> and Set<T> are added to contributors.
+  @Override public Set<T> get() {
+    List<T> result = new ArrayList<T>();
+    for (MapBinding<T> MapBinding = this; MapBinding != null; MapBinding = MapBinding.parent) {
+      for (int i = 0, size = MapBinding.contributors.size(); i < size; i++) {
+        Binding<?> contributor = MapBinding.contributors.get(i);
+        Object contribution = contributor.get(); // Let runtime exceptions through.
+        if (contributor.provideKey.equals(provideKey)) {
+          result.addAll((Set<T>) contribution);
+        } else {
+          result.add((T) contribution);
+        }
+      }
+    }
+    return Collections.unmodifiableSet(new LinkedHashSet<T>(result));
+  }
+
+  @Override public void getDependencies(
+      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
+    for (MapBinding<T> binding = this; binding != null; binding = binding.parent) {
+      getBindings.addAll(binding.contributors);
+    }
+  }
+
+  @Override public void injectMembers(Set<T> t) {
+    throw new UnsupportedOperationException("Cannot inject members on a contributed Set<T>.");
+  }
+
+  @Override public String toString() {
+    boolean first = true;
+    StringBuilder builder = new StringBuilder("MapBinding[");
+    for (MapBinding<T> MapBinding = this; MapBinding != null; MapBinding = MapBinding.parent) {
+      for (int i = 0, size = MapBinding.contributors.size(); i < size; i++) {
+        if (!first) {
+          builder.append(",");
+        }
+        builder.append(MapBinding.contributors.get(i));
+        first = false;
+      }
+    }
+    builder.append("]");
+    return builder.toString();
+  }
+}
diff --git a/examples/simple/src/main/java/coffee/CoffeeMaker.java b/examples/simple/src/main/java/coffee/CoffeeMaker.java
index a4e818012..19c199702 100644
--- a/examples/simple/src/main/java/coffee/CoffeeMaker.java
+++ b/examples/simple/src/main/java/coffee/CoffeeMaker.java
@@ -1,15 +1,20 @@
 package coffee;
 
 import dagger.Lazy;
+
+import java.util.Set;
+
 import javax.inject.Inject;
 
 class CoffeeMaker {
   @Inject Lazy<Heater> heater; // Don't want to create a possibly costly heater until we need it.
   @Inject Pump pump;
+  @Inject Set<Flavor> flavors;
 
   public void brew() {
     heater.get().on();
     pump.pump();
+    System.out.println("flavor: " + flavors);
     System.out.println(" [_]P coffee! [_]P ");
     heater.get().off();
   }
diff --git a/examples/simple/src/main/java/coffee/DripCoffeeModule.java b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
index da0bbaafa..ad84c4020 100644
--- a/examples/simple/src/main/java/coffee/DripCoffeeModule.java
+++ b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
@@ -3,6 +3,7 @@
 import dagger.Module;
 import dagger.Provides;
 import javax.inject.Singleton;
+import dagger.Provides.Type;
 
 @Module(
     injects = CoffeeApp.class,
@@ -12,4 +13,7 @@
   @Provides @Singleton Heater provideHeater() {
     return new ElectricHeater();
   }
+  @Provides(type = Type.MAP) Flavor provideFlavor() {
+    return new Flavor("Chocoloate");
+  }
 }
diff --git a/examples/simple/src/main/java/coffee/Flavor.java b/examples/simple/src/main/java/coffee/Flavor.java
new file mode 100644
index 000000000..b9805812e
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/Flavor.java
@@ -0,0 +1,15 @@
+package coffee;
+
+/**
+ * TODO: Insert description here. (generated by houcy)
+ */
+public class Flavor {
+  String name;
+  Flavor(String f) {
+    this.name = f;
+  }
+
+  @Override public String toString() {
+    return name;
+  }
+}
