diff --git a/java/dagger/internal/codegen/ComponentModelBuilder.java b/java/dagger/internal/codegen/ComponentModelBuilder.java
index 83216faa7..33cbd0e7b 100644
--- a/java/dagger/internal/codegen/ComponentModelBuilder.java
+++ b/java/dagger/internal/codegen/ComponentModelBuilder.java
@@ -400,16 +400,17 @@ private void addConstructor() {
         constructorBuilder()
             .addModifiers(generatedComponentModel.isAbstract() ? PROTECTED : PRIVATE)
             .addParameters(constructorParameters);
-
-    if (generatedComponentModel.supermodel().isPresent()) {
-      constructor.addStatement(
-          CodeBlock.of(
-              "super($L)",
-              constructorParameters
-                  .stream()
-                  .map(param -> CodeBlock.of("$N", param))
-                  .collect(toParametersCodeBlock())));
-    }
+    generatedComponentModel.setConstructorParameters(constructorParameters);
+    generatedComponentModel
+        .supermodel()
+        .ifPresent(
+            supermodel ->
+                constructor.addStatement(
+                    CodeBlock.of(
+                        "super($L)",
+                        supermodel.constructorParameters().stream()
+                            .map(param -> CodeBlock.of("$N", param))
+                            .collect(toParametersCodeBlock()))));
 
     ImmutableList<ParameterSpec> initializeParameters = initializeParameters();
     CodeBlock initializeParametersCodeBlock =
@@ -449,9 +450,15 @@ private void addConstructor() {
     if (generatedComponentBuilderModel.isPresent()) {
       return ImmutableList.of(
           ParameterSpec.builder(generatedComponentBuilderModel.get().name(), "builder").build());
+    } else if (generatedComponentModel.isAbstract() && generatedComponentModel.isNested()) {
+      // If we're generating an abstract inner subcomponent, then we are not implementing module
+      // instance bindings and have no need for factory method parameters.
+      return ImmutableList.of();
     } else if (graph.factoryMethod().isPresent()) {
       return getFactoryMethodParameterSpecs(graph);
-    } else if (generatedComponentModel.isAbstract() && !generatedComponentModel.isNested()) {
+    } else if (generatedComponentModel.isAbstract()) {
+      // If we're generating an abstract base implementation of a subcomponent it's acceptable to
+      // have neither a builder nor factory method.
       return ImmutableList.of();
     } else {
       throw new AssertionError(
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 3ee1ecb84..625edffe2 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -42,6 +42,7 @@
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.ReferenceReleasingProviderManager;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
@@ -163,6 +164,7 @@
   private final ModifiableBindingMethods modifiableBindingMethods = new ModifiableBindingMethods();
   private final SetMultimap<Key, DependencyRequest> contributionsByMultibinding =
       HashMultimap.create();
+  private ImmutableList<ParameterSpec> constructorParameters;
 
   private GeneratedComponentModel(
       ComponentDescriptor componentDescriptor,
@@ -269,6 +271,11 @@ boolean isAbstract() {
     return supermodel;
   }
 
+  /** Returns the arguments to the modeled class's constructor. */
+  ImmutableList<ParameterSpec> constructorParameters() {
+    return constructorParameters;
+  }
+
   /**
    * Returns the name of the builder class for this component. It will be a sibling of this
    * generated class unless this is a top-level component, in which case it will be nested.
@@ -405,6 +412,11 @@ void addCancellation(CodeBlock codeBlock) {
     cancellations.add(codeBlock);
   }
 
+  /** Records the constructor parameters for an instance of this component. */
+  void setConstructorParameters(ImmutableList<ParameterSpec> parameters) {
+    constructorParameters = parameters;
+  }
+
   /** Returns a new, unique field name for the component based on the given name. */
   String getUniqueFieldName(String name) {
     return componentFieldNames.getUniqueName(name);
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 9f5b513f2..4d578ae71 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -439,6 +439,99 @@ public void moduleInstanceDependency() {
         .hasSourceEquivalentTo(generatedAncestor);
   }
 
+  @Test
+  public void moduleInstanceDependency_withModuleParams() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface Leaf {",
+            "  int getInt();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  private int i = 0;",
+            "",
+            "  @Provides int provideInt() {",
+            "    return i++;",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private TestModule testModule;",
+            "",
+            "  protected DaggerLeaf() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.testModule = new TestModule();",
+            "  }",
+            "",
+            "  @Override",
+            "  public int getInt() {",
+            "    return testModule.provideInt();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf(TestModule module);",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {",
+            "      super();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
   @Test
   public void generatedInstanceBinding() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
