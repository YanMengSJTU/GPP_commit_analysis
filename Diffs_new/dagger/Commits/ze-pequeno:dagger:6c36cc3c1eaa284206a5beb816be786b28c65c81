diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 2e081f736..d75697be2 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -37,7 +38,9 @@
 import java.util.Optional;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 
 /**
  * The canonical representation of a full-resolved graph.
@@ -135,6 +138,39 @@ TypeElement componentType() {
     return FluentIterable.from(ownedModules()).transform(ModuleDescriptor::moduleElement).toSet();
   }
 
+  /**
+   * Returns the factory method for this subcomponent, if it exists.
+   *
+   * <p>This factory method is the one defined in the parent component's interface.
+   *
+   * <p>In the example below, the {@link BindingGraph#factoryMethod} for {@code ChildComponent}
+   * would return the {@link ExecutableElement}: {@code childComponent(ChildModule1)} .
+   *
+   * <pre><code>
+   *   {@literal @Component}
+   *   interface ParentComponent {
+   *     ChildComponent childComponent(ChildModule1 childModule);
+   *   }
+   * </code></pre>
+   */
+  // TODO(b/73294201): Consider returning the resolved ExecutableType for the factory method.
+  abstract Optional<ExecutableElement> factoryMethod();
+
+  /**
+   * Returns a map between the {@linkplain ComponentRequirement component requirement} and the
+   * corresponding {@link VariableElement} for each module parameter in the {@linkplain
+   * BindingGraph#factoryMethod factory method}.
+   */
+  // TODO(dpb): Consider disallowing modules if none of their bindings are used.
+  ImmutableMap<ComponentRequirement, VariableElement> factoryMethodParameters() {
+    checkState(factoryMethod().isPresent());
+    ImmutableMap.Builder<ComponentRequirement, VariableElement> builder = ImmutableMap.builder();
+    for (VariableElement parameter : factoryMethod().get().getParameters()) {
+      builder.put(ComponentRequirement.forModule(parameter.asType()), parameter);
+    }
+    return builder.build();
+  }
+
   private static final Traverser<BindingGraph> SUBGRAPH_TRAVERSER =
       Traverser.forTree(BindingGraph::subgraphs);
 
@@ -161,6 +197,9 @@ TypeElement componentType() {
         .filter(module -> ownedModuleTypes().contains(module))
         .map(module -> ComponentRequirement.forModule(module.asType()))
         .forEach(requirements::add);
+    if (factoryMethod().isPresent()) {
+      factoryMethodParameters().keySet().forEach(requirements::add);
+    }
     componentDescriptor()
         .dependencies()
         .stream()
@@ -209,13 +248,15 @@ static BindingGraph create(
       ImmutableMap<Key, ResolvedBindings> resolvedMembersInjectionBindings,
       ImmutableSet<BindingGraph> subgraphs,
       ImmutableSet<Scope> scopesRequiringReleasableReferenceManagers,
-      ImmutableSet<ModuleDescriptor> ownedModules) {
+      ImmutableSet<ModuleDescriptor> ownedModules,
+      Optional<ExecutableElement> factoryMethod) {
     return new AutoValue_BindingGraph(
         componentDescriptor,
         resolvedContributionBindingsMap,
         resolvedMembersInjectionBindings,
         subgraphs,
         scopesRequiringReleasableReferenceManagers,
-        ownedModules);
+        ownedModules,
+        factoryMethod);
   }
 }
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 62219192b..c31541cd0 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -211,7 +211,8 @@ private BindingGraph create(
         subgraphs.build(),
         getScopesRequiringReleasableReferenceManagers(
             releasableReferenceManagerBindings, resolvedContributionBindingsMap.keySet()),
-        requestResolver.getOwnedModules());
+        requestResolver.getOwnedModules(),
+        requestResolver.getFactoryMethod());
   }
 
   /**
@@ -323,6 +324,20 @@ private BindingGraph create(
       subcomponentsToResolve.addAll(componentDescriptor.subcomponentsFromEntryPoints());
     }
 
+    /** Returns the optional factory method for this component. */
+    Optional<ExecutableElement> getFactoryMethod() {
+      return parentResolver
+          .map(
+              parent -> {
+                return parent
+                    .componentDescriptor
+                    .subcomponentsByFactoryMethod()
+                    .inverse()
+                    .get(componentDescriptor);
+              })
+          .map(method -> method.methodElement());
+    }
+
     /**
      * Returns the resolved contribution bindings for the given {@link Key}:
      *
diff --git a/java/dagger/internal/codegen/ComponentBuilder.java b/java/dagger/internal/codegen/ComponentBuilder.java
index 120ae5e07..519fd3742 100644
--- a/java/dagger/internal/codegen/ComponentBuilder.java
+++ b/java/dagger/internal/codegen/ComponentBuilder.java
@@ -75,13 +75,20 @@ ClassName name() {
     return builderFields;
   }
 
-  static ComponentBuilder create(
+  static Optional<ComponentBuilder> create(
       ClassName componentName,
       BindingGraph graph,
       SubcomponentNames subcomponentNames,
       Elements elements,
       Types types) {
-    return new Creator(componentName, graph, subcomponentNames, elements, types).create();
+    return hasBuilder(graph.componentDescriptor())
+        ? Optional.of(
+            new Creator(componentName, graph, subcomponentNames, elements, types).create())
+        : Optional.empty();
+  }
+
+  private static boolean hasBuilder(ComponentDescriptor component) {
+    return component.kind().isTopLevel() || component.builderSpec().isPresent();
   }
 
   private static final class Creator {
diff --git a/java/dagger/internal/codegen/ComponentRequirementField.java b/java/dagger/internal/codegen/ComponentRequirementField.java
index eab59b926..b9c478539 100644
--- a/java/dagger/internal/codegen/ComponentRequirementField.java
+++ b/java/dagger/internal/codegen/ComponentRequirementField.java
@@ -16,15 +16,8 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.COMPONENT_REQUIREMENT_FIELD;
-import static javax.lang.model.element.Modifier.PRIVATE;
-
-import com.google.common.collect.ImmutableMap;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
-import com.squareup.javapoet.TypeName;
 
 /**
  * A factory for expressions of {@link ComponentRequirement}s in the generated component. This is
@@ -32,23 +25,13 @@
  * {@link dagger.model.Key}. See {@link ComponentRequirementBindingExpression} for binding
  * expressions that are themselves a component requirement.
  */
-abstract class ComponentRequirementField {
-  private final ComponentRequirement componentRequirement;
-
-  private ComponentRequirementField(ComponentRequirement componentRequirement) {
-    this.componentRequirement = checkNotNull(componentRequirement);
-  }
-
-  final ComponentRequirement componentRequirement() {
-    return componentRequirement;
-  }
-
+interface ComponentRequirementField {
   /**
    * Returns an expression for the {@link ComponentRequirement} to be used when implementing a
    * component method. This may add a field to the component in order to reference the component
    * requirement outside of the {@code initialize()} methods.
    */
-  abstract CodeBlock getExpression(ClassName requestingClass);
+  CodeBlock getExpression(ClassName requestingClass);
 
   /**
    * Returns an expression for the {@link ComponentRequirement} to be used only within {@code
@@ -57,123 +40,5 @@ final ComponentRequirement componentRequirement() {
    * <p>When accessing this field from a subcomponent, this may cause a field to be initialized in
    * the component that owns this {@link ComponentRequirement}.
    */
-  abstract CodeBlock getExpressionDuringInitialization(ClassName requestingClass);
-
-  /**
-   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a corresponding
-   * field on the component builder.
-   */
-  private static final class BuilderField extends ComponentRequirementField {
-    private final GeneratedComponentModel generatedComponentModel;
-    private final ClassName owningComponent;
-    private final FieldSpec builderField;
-    private MemberSelect field;
-
-    private BuilderField(
-        ComponentRequirement componentRequirement,
-        GeneratedComponentModel generatedComponentModel,
-        ClassName owningComponent,
-        FieldSpec builderField) {
-      super(componentRequirement);
-      this.generatedComponentModel = checkNotNull(generatedComponentModel);
-      this.owningComponent = checkNotNull(owningComponent);
-      this.builderField = checkNotNull(builderField);
-    }
-
-    @Override
-    CodeBlock getExpression(ClassName requestingClass) {
-      return getField().getExpressionFor(requestingClass);
-    }
-
-    @Override
-    CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
-      if (owningComponent.equals(requestingClass)) {
-        return CodeBlock.of("builder.$N", builderField);
-      } else {
-        // requesting this component requirement during initialization of a child component requires
-        // the it to be access from a field and not the builder (since it is no longer available)
-        return getExpression(requestingClass);
-      }
-    }
-
-    private MemberSelect getField() {
-      if (field == null) {
-        // TODO(dpb,ronshapiro): think about whether GeneratedComponentModel.addField should make a
-        // unique name for the field.
-        String fieldName =
-            generatedComponentModel.getUniqueFieldName(componentRequirement().variableName());
-        FieldSpec componentField =
-            FieldSpec.builder(TypeName.get(componentRequirement().type()), fieldName, PRIVATE)
-                .build();
-        generatedComponentModel.addField(COMPONENT_REQUIREMENT_FIELD, componentField);
-        generatedComponentModel.addInitialization(
-            CodeBlock.of("this.$N = builder.$N;", componentField, builderField));
-        field = MemberSelect.localField(owningComponent, fieldName);
-      }
-      return field;
-    }
-  }
-
-  /**
-   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a corresponding
-   * field already added on the component.
-   */
-  private static final class ComponentField extends ComponentRequirementField {
-    private final MemberSelect memberSelect;
-
-    private ComponentField(
-        ComponentRequirement componentRequirement,
-        FieldSpec componentField,
-        ClassName owningComponent) {
-      super(componentRequirement);
-      this.memberSelect = MemberSelect.localField(owningComponent, componentField.name);
-    }
-
-    @Override
-    CodeBlock getExpression(ClassName requestingClass) {
-      return memberSelect.getExpressionFor(requestingClass);
-    }
-
-    @Override
-    CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
-      return getExpression(requestingClass);
-    }
-  }
-
-  static final class Factory {
-    private final GeneratedComponentModel generatedComponentModel;
-    private final ClassName owningComponent;
-    private final ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
-
-    Factory(
-        GeneratedComponentModel generatedComponentModel,
-        ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
-      this.generatedComponentModel = checkNotNull(generatedComponentModel);
-      this.owningComponent = checkNotNull(generatedComponentModel.name());
-      this.builderFields = checkNotNull(builderFields);
-    }
-
-    /**
-     * Returns a {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a
-     * corresponding field on the component builder.
-     */
-    ComponentRequirementField forBuilderField(ComponentRequirement componentRequirement) {
-      return new BuilderField(
-          componentRequirement,
-          generatedComponentModel,
-          owningComponent,
-          builderFields.get(componentRequirement));
-    }
-  }
-
-  /**
-   * Returns a {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a
-   * corresponding field already added on the component.
-   */
-  static ComponentRequirementField componentField(
-      ComponentRequirement componentRequirement,
-      FieldSpec componentField,
-      ClassName owningComponent) {
-    return new ComponentField(componentRequirement, componentField, owningComponent);
-  }
+  CodeBlock getExpressionDuringInitialization(ClassName requestingClass);
 }
diff --git a/java/dagger/internal/codegen/ComponentRequirementFields.java b/java/dagger/internal/codegen/ComponentRequirementFields.java
index 1eaceda3e..f38fbdaec 100644
--- a/java/dagger/internal/codegen/ComponentRequirementFields.java
+++ b/java/dagger/internal/codegen/ComponentRequirementFields.java
@@ -16,12 +16,21 @@
 
 package dagger.internal.codegen;
 
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Suppliers.memoize;
+import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.COMPONENT_REQUIREMENT_FIELD;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.google.common.base.Supplier;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import dagger.internal.Preconditions;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Optional;
 
 /**
  * A central repository of fields used to access any {@link ComponentRequirement} available to a
@@ -33,21 +42,38 @@
   // HierarchicalComponentMap<K, V>, or perhaps this use a flattened ImmutableMap, built from its
   // parents? If so, maybe make ComponentRequirementField.Factory create it.
 
-  /**
-   * A list of component requirement field maps. The first element contains the fields on this
-   * component; the second contains the fields owned by its parent; and so on.
-   */
-  private final ImmutableList<Map<ComponentRequirement, ComponentRequirementField>>
-      componentRequirementFieldsMaps;
+  private final Optional<ComponentRequirementFields> parent;
+  private final Map<ComponentRequirement, ComponentRequirementField> componentRequirementFields =
+      new HashMap<>();
+  private final BindingGraph graph;
+  private final GeneratedComponentModel generatedComponentModel;
+  private final Optional<ComponentBuilder> componentBuilder;
 
   private ComponentRequirementFields(
-      ImmutableList<Map<ComponentRequirement, ComponentRequirementField>>
-          componentRequirementFieldsMaps) {
-    this.componentRequirementFieldsMaps = componentRequirementFieldsMaps;
+      Optional<ComponentRequirementFields> parent,
+      BindingGraph graph,
+      GeneratedComponentModel generatedComponentModel,
+      Optional<ComponentBuilder> componentBuilder) {
+    this.parent = parent;
+    this.graph = graph;
+    this.generatedComponentModel = generatedComponentModel;
+    this.componentBuilder = componentBuilder;
+  }
+
+  ComponentRequirementFields(
+      BindingGraph graph,
+      GeneratedComponentModel generatedComponentModel,
+      Optional<ComponentBuilder> componentBuilder) {
+    this(Optional.empty(), graph, generatedComponentModel, componentBuilder);
   }
 
-  ComponentRequirementFields() {
-    this(ImmutableList.of(newComponentRequirementsMap()));
+  /** Returns a new object representing the fields available from a child component of this one. */
+  ComponentRequirementFields forChildComponent(
+      BindingGraph graph,
+      GeneratedComponentModel generatedComponentModel,
+      Optional<ComponentBuilder> componentBuilder) {
+    return new ComponentRequirementFields(
+        Optional.of(this), graph, generatedComponentModel, componentBuilder);
   }
 
   /**
@@ -71,38 +97,139 @@ CodeBlock getExpressionDuringInitialization(
     return getField(componentRequirement).getExpressionDuringInitialization(requestingClass);
   }
 
-  private ComponentRequirementField getField(ComponentRequirement componentRequirement) {
-    for (Map<ComponentRequirement, ComponentRequirementField> componentRequirementFieldsMap :
-        componentRequirementFieldsMaps) {
-      ComponentRequirementField field = componentRequirementFieldsMap.get(componentRequirement);
-      if (field != null) {
-        return field;
-      }
+  ComponentRequirementField getField(ComponentRequirement componentRequirement) {
+    if (graph.componentRequirements().contains(componentRequirement)) {
+      return componentRequirementFields.computeIfAbsent(componentRequirement, this::create);
+    }
+    if (parent.isPresent()) {
+      return parent.get().getField(componentRequirement);
     }
     throw new IllegalStateException(
         "no component requirement field found for " + componentRequirement);
   }
 
+  /** Returns a {@link ComponentRequirementField} for a {@link ComponentRequirement}. */
+  private ComponentRequirementField create(ComponentRequirement requirement) {
+    if (componentBuilder.isPresent()) {
+      FieldSpec builderField = componentBuilder.get().builderFields().get(requirement);
+      return new BuilderField(requirement, generatedComponentModel, builderField);
+    } else if (graph.factoryMethodParameters().containsKey(requirement)) {
+      ParameterSpec factoryParameter =
+          ParameterSpec.get(graph.factoryMethodParameters().get(requirement));
+      return new ComponentParameterField(requirement, generatedComponentModel, factoryParameter);
+    } else if (graph.componentRequirements().contains(requirement)) {
+      return new ComponentInstantiableField(requirement, generatedComponentModel);
+    } else {
+      throw new AssertionError();
+    }
+  }
+
+  private abstract static class AbstractField implements ComponentRequirementField {
+    private final ComponentRequirement componentRequirement;
+    private final GeneratedComponentModel generatedComponentModel;
+    private final Supplier<MemberSelect> field = memoize(this::createField);
+
+    private AbstractField(
+        ComponentRequirement componentRequirement,
+        GeneratedComponentModel generatedComponentModel) {
+      this.componentRequirement = checkNotNull(componentRequirement);
+      this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    }
+
+    @Override
+    public CodeBlock getExpression(ClassName requestingClass) {
+      return field.get().getExpressionFor(requestingClass);
+    }
+
+    @Override
+    public CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
+      return getExpression(requestingClass);
+    }
+
+    private MemberSelect createField() {
+      // TODO(dpb,ronshapiro): think about whether GeneratedComponentModel.addField
+      // should make a unique name for the field.
+      String fieldName =
+          generatedComponentModel.getUniqueFieldName(componentRequirement.variableName());
+      FieldSpec field =
+          FieldSpec.builder(TypeName.get(componentRequirement.type()), fieldName, PRIVATE).build();
+      generatedComponentModel.addField(COMPONENT_REQUIREMENT_FIELD, field);
+      generatedComponentModel.addInitialization(fieldInitialization(field));
+      return MemberSelect.localField(generatedComponentModel.name(), fieldName);
+    }
+
+    /** Returns the {@link CodeBlock} that initializes the component field during construction. */
+    abstract CodeBlock fieldInitialization(FieldSpec componentField);
+  }
+
   /**
-   * Adds a component requirement field for a single component requirement owned by this component.
+   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a corresponding
+   * field on the component builder.
    */
-  // TODO(user): remove this method and create ComponentRequirementFields lazily, on demand.
-  void add(ComponentRequirementField field) {
-    componentRequirementFieldsMaps.get(0).put(field.componentRequirement(), field);
+  private static final class BuilderField extends AbstractField {
+    private final FieldSpec builderField;
+
+    private BuilderField(
+        ComponentRequirement componentRequirement,
+        GeneratedComponentModel generatedComponentModel,
+        FieldSpec builderField) {
+      super(componentRequirement, generatedComponentModel);
+      this.builderField = checkNotNull(builderField);
+    }
+
+    @Override
+    public CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
+      if (super.generatedComponentModel.name().equals(requestingClass)) {
+        return CodeBlock.of("builder.$N", builderField);
+      } else {
+        // requesting this component requirement during initialization of a child component requires
+        // the it to be access from a field and not the builder (since it is no longer available)
+        return getExpression(requestingClass);
+      }
+    }
+
+    @Override
+    CodeBlock fieldInitialization(FieldSpec componentField) {
+      return CodeBlock.of("this.$N = builder.$N;", componentField, builderField);
+    }
   }
 
-  private static Map<ComponentRequirement, ComponentRequirementField>
-      newComponentRequirementsMap() {
-    return new HashMap<>();
+  /**
+   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that can be instantiated
+   * by the component (i.e. a static class with a no-arg constructor).
+   */
+  private static final class ComponentInstantiableField extends AbstractField {
+    private ComponentInstantiableField(
+        ComponentRequirement componentRequirement,
+        GeneratedComponentModel generatedComponentModel) {
+      super(componentRequirement, generatedComponentModel);
+    }
+
+    @Override
+    CodeBlock fieldInitialization(FieldSpec componentField) {
+      return CodeBlock.of("this.$N = new $T();", componentField, componentField.type);
+    }
   }
 
   /**
-   * Returns a new object representing the fields available from a child component of this one.
+   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that are passed in
+   * as parameters to a component factory method.
    */
-  ComponentRequirementFields forChildComponent() {
-    return new ComponentRequirementFields(
-        FluentIterable.of(newComponentRequirementsMap())
-            .append(componentRequirementFieldsMaps)
-            .toList());
+  private static final class ComponentParameterField extends AbstractField {
+    private final ParameterSpec factoryParameter;
+
+    private ComponentParameterField(
+        ComponentRequirement componentRequirement,
+        GeneratedComponentModel generatedComponentModel,
+        ParameterSpec factoryParameter) {
+      super(componentRequirement, generatedComponentModel);
+      this.factoryParameter = checkNotNull(factoryParameter);
+    }
+
+    @Override
+    CodeBlock fieldInitialization(FieldSpec componentField) {
+      return CodeBlock.of(
+          "this.$N = $T.checkNotNull($N);", componentField, Preconditions.class, factoryParameter);
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index bd3246ba6..7772edb8c 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -18,17 +18,12 @@
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.auto.common.MoreTypes.asExecutable;
-import static com.google.auto.common.MoreTypes.asTypeElement;
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
-import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.COMPONENT_REQUIREMENT_FIELD;
+import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.BUILDER_METHOD;
 import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.COMPONENT_METHOD;
 import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.CONSTRUCTOR;
@@ -41,23 +36,20 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Multimaps;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeSpec;
-import dagger.internal.Preconditions;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import java.util.List;
 import java.util.Optional;
-import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.util.Elements;
 
@@ -73,7 +65,10 @@
     GeneratedComponentModel generatedComponentModel = GeneratedComponentModel.forComponent(name);
     SubcomponentNames subcomponentNames = new SubcomponentNames(graph, keyFactory);
     OptionalFactories optionalFactories = new OptionalFactories();
-    ComponentRequirementFields componentRequirementFields = new ComponentRequirementFields();
+    Optional<ComponentBuilder> builder =
+        ComponentBuilder.create(name, graph, subcomponentNames, elements, types);
+    ComponentRequirementFields componentRequirementFields =
+        new ComponentRequirementFields(graph, generatedComponentModel, builder);
     ComponentBindingExpressions bindingExpressions =
         new ComponentBindingExpressions(
             graph,
@@ -93,7 +88,8 @@
             subcomponentNames,
             optionalFactories,
             bindingExpressions,
-            componentRequirementFields)
+            componentRequirementFields,
+            builder)
         .write();
   }
 
@@ -104,8 +100,12 @@ private static TypeSpec writeSubcomponent(ComponentWriter parent, BindingGraph c
             parent.subcomponentNames.get(childGraph.componentDescriptor()) + "Impl");
     GeneratedComponentModel childGeneratedComponentModel =
         GeneratedComponentModel.forSubcomponent(childName);
+    Optional<ComponentBuilder> childBuilder =
+        ComponentBuilder.create(
+            childName, childGraph, parent.subcomponentNames, parent.elements, parent.types);
     ComponentRequirementFields childComponentRequirementFields =
-        parent.componentRequirementFields.forChildComponent();
+        parent.componentRequirementFields.forChildComponent(
+            childGraph, childGeneratedComponentModel, childBuilder);
     ComponentBindingExpressions childBindingExpressions =
         parent.bindingExpressions.forChildComponent(
             childGraph, childGeneratedComponentModel, childComponentRequirementFields);
@@ -114,7 +114,8 @@ private static TypeSpec writeSubcomponent(ComponentWriter parent, BindingGraph c
             childGraph,
             childGeneratedComponentModel,
             childBindingExpressions,
-            childComponentRequirementFields)
+            childComponentRequirementFields,
+            childBuilder)
         .write()
         .build();
   }
@@ -127,18 +128,10 @@ private static TypeSpec writeSubcomponent(ComponentWriter parent, BindingGraph c
   private final ComponentBindingExpressions bindingExpressions;
   private final ComponentRequirementFields componentRequirementFields;
   private final GeneratedComponentModel generatedComponentModel;
-  private final ComponentRequirementField.Factory componentRequirementFieldFactory;
-  private final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   private final OptionalFactories optionalFactories;
-  private ComponentBuilder builder;
+  private final Optional<ComponentBuilder> builder;
   private boolean done;
 
-  /**
-   * For each component requirement, the builder field. This map is empty for subcomponents that do
-   * not use a builder.
-   */
-  private final ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
-
   private ComponentWriter(
       DaggerTypes types,
       Elements elements,
@@ -148,7 +141,8 @@ private ComponentWriter(
       SubcomponentNames subcomponentNames,
       OptionalFactories optionalFactories,
       ComponentBindingExpressions bindingExpressions,
-      ComponentRequirementFields componentRequirementFields) {
+      ComponentRequirementFields componentRequirementFields,
+      Optional<ComponentBuilder> builder) {
     this.types = types;
     this.elements = elements;
     this.compilerOptions = compilerOptions;
@@ -157,18 +151,8 @@ private ComponentWriter(
     this.generatedComponentModel = generatedComponentModel;
     this.optionalFactories = optionalFactories;
     this.bindingExpressions = bindingExpressions;
-    // TODO(dpb): Allow ComponentBuilder.create to return a no-op object
-    if (hasBuilder(graph)) {
-      builder =
-          ComponentBuilder.create(
-              generatedComponentModel.name(), graph, subcomponentNames, elements, types);
-      builderFields = builder.builderFields();
-    } else {
-      builderFields = ImmutableMap.of();
-    }
     this.componentRequirementFields = componentRequirementFields;
-    this.componentRequirementFieldFactory =
-        new ComponentRequirementField.Factory(generatedComponentModel, builderFields);
+    this.builder = builder;
   }
 
   /**
@@ -179,20 +163,17 @@ private ComponentWriter(
   protected final TypeSpec.Builder write() {
     checkState(!done, "ComponentWriter has already been generated.");
     generatedComponentModel.addSupertype(graph.componentType());
-    if (hasBuilder(graph)) {
-      addBuilder();
-    }
+    builder.map(ComponentBuilder::typeSpec).ifPresent(this::addBuilderClass);
 
     getLocalAndInheritedMethods(
             graph.componentDescriptor().componentDefinitionType(), types, elements)
         .forEach(method -> generatedComponentModel.claimMethodName(method.getSimpleName()));
 
     addFactoryMethods();
-    createComponentRequirementFields();
     addInterfaceMethods();
     addSubcomponents();
-    addInitializeMethods();
-    generatedComponentModel.addMethod(CONSTRUCTOR, constructor.build());
+    addConstructor();
+
     if (graph.componentDescriptor().kind().isTopLevel()) {
       optionalFactories.addMembers(generatedComponentModel);
     }
@@ -200,20 +181,6 @@ private ComponentWriter(
     return generatedComponentModel.generate();
   }
 
-  private static boolean hasBuilder(BindingGraph graph) {
-    ComponentDescriptor component = graph.componentDescriptor();
-    return component.kind().isTopLevel() || component.builderSpec().isPresent();
-  }
-
-  /**
-   * Adds a builder type.
-   */
-  private void addBuilder() {
-    addBuilderClass(builder.typeSpec());
-
-    constructor.addParameter(builder.name(), "builder");
-  }
-
   /**
    * Adds {@code builder} as a nested builder class. Root components and subcomponents will nest
    * this in different classes.
@@ -223,14 +190,6 @@ private void addBuilder() {
   /** Adds component factory methods. */
   protected abstract void addFactoryMethods();
 
-  private void createComponentRequirementFields() {
-    builderFields
-        .keySet()
-        .stream()
-        .map(componentRequirementFieldFactory::forBuilderField)
-        .forEach(componentRequirementFields::add);
-  }
-
   private void addInterfaceMethods() {
     /* Each component method may have been declared by several supertypes. We want to implement only
      * one method for each distinct signature.*/
@@ -257,11 +216,22 @@ private void addSubcomponents() {
 
   private static final int INITIALIZATIONS_PER_INITIALIZE_METHOD = 100;
 
-  private void addInitializeMethods() {
+  private void addConstructor() {
     List<List<CodeBlock>> partitions =
         Lists.partition(
             generatedComponentModel.getInitializations(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
 
+    ImmutableList<ParameterSpec> constructorParameters = constructorParameters();
+    MethodSpec.Builder constructor =
+        constructorBuilder().addModifiers(PRIVATE).addParameters(constructorParameters);
+
+    ImmutableList<ParameterSpec> initializeParameters = initializeParameters();
+    CodeBlock initializeParametersCodeBlock =
+        constructorParameters
+            .stream()
+            .map(param -> CodeBlock.of("$N", param))
+            .collect(toParametersCodeBlock());
+
     UniqueNameSet methodNames = new UniqueNameSet();
     for (List<CodeBlock> partition : partitions) {
       String methodName = methodNames.getUniqueName("initialize");
@@ -274,14 +244,31 @@ private void addInitializeMethods() {
                * separate fields and initilization as we do now. */
               .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
               .addCode(CodeBlocks.concat(partition));
-      if (hasBuilder(graph)) {
-        initializeMethod.addParameter(builder.name(), "builder", FINAL);
-        constructor.addStatement("$L(builder)", methodName);
-      } else {
-        constructor.addStatement("$L()", methodName);
-      }
+      initializeMethod.addParameters(initializeParameters);
+      constructor.addStatement("$L($L)", methodName, initializeParametersCodeBlock);
       generatedComponentModel.addMethod(INITIALIZE_METHOD, initializeMethod.build());
     }
+    generatedComponentModel.addMethod(CONSTRUCTOR, constructor.build());
+  }
+
+  /** Returns the list of {@link ParameterSpec}s for the initialze methods. */
+  private ImmutableList<ParameterSpec> initializeParameters() {
+    return constructorParameters()
+        .stream()
+        .map(param -> param.toBuilder().addModifiers(FINAL).build())
+        .collect(toImmutableList());
+  }
+
+  /** Returns the list of {@link ParameterSpec}s for the constructor. */
+  private ImmutableList<ParameterSpec> constructorParameters() {
+    if (builder.isPresent()) {
+      return ImmutableList.of(ParameterSpec.builder(builder.get().name(), "builder").build());
+    } else if (graph.factoryMethod().isPresent()) {
+      return getFactoryMethodParameterSpecs(graph);
+    } else {
+      throw new AssertionError(
+          "Expected either a component builder or factory method but found neither.");
+    }
   }
 
   /**
@@ -297,7 +284,8 @@ private void addInitializeMethods() {
         SubcomponentNames subcomponentNames,
         OptionalFactories optionalFactories,
         ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields) {
+        ComponentRequirementFields componentRequirementFields,
+        Optional<ComponentBuilder> builder) {
       super(
           types,
           elements,
@@ -307,7 +295,8 @@ private void addInitializeMethods() {
           subcomponentNames,
           optionalFactories,
           bindingExpressions,
-          componentRequirementFields);
+          componentRequirementFields,
+          builder);
     }
 
     @Override
@@ -325,8 +314,8 @@ protected void addFactoryMethods() {
               .returns(
                   builderSpec().isPresent()
                       ? ClassName.get(builderSpec().get().builderDefinitionType())
-                      : super.builder.name())
-              .addStatement("return new $T()", super.builder.name())
+                      : super.builder.get().name())
+              .addStatement("return new $T()", super.builder.get().name())
               .build();
       super.generatedComponentModel.addMethod(BUILDER_METHOD, builderFactoryMethod);
       if (canInstantiateAllRequirements()) {
@@ -365,7 +354,8 @@ private boolean canInstantiateAllRequirements() {
         BindingGraph graph,
         GeneratedComponentModel generatedComponentModel,
         ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields) {
+        ComponentRequirementFields componentRequirementFields,
+        Optional<ComponentBuilder> builder) {
       super(
           parent.types,
           parent.elements,
@@ -375,7 +365,8 @@ private boolean canInstantiateAllRequirements() {
           parent.subcomponentNames,
           parent.optionalFactories,
           bindingExpressions,
-          componentRequirementFields);
+          componentRequirementFields,
+          builder);
       this.parent = parent;
     }
 
@@ -388,84 +379,35 @@ protected void addBuilderClass(TypeSpec builder) {
     protected void addFactoryMethods() {
       // The parent's factory method to create this subcomponent if the
       // subcomponent was not added via {@link dagger.Module#subcomponents()}.
-      Optional.ofNullable(
-              parent
-                  .graph
-                  .componentDescriptor()
-                  .subcomponentsByFactoryMethod()
-                  .inverse()
-                  .get(super.graph.componentDescriptor()))
-          .map(method -> method.methodElement())
-          .ifPresent(this::createSubcomponentFactoryMethod);
+      super.graph.factoryMethod().ifPresent(this::createSubcomponentFactoryMethod);
     }
 
     private void createSubcomponentFactoryMethod(ExecutableElement factoryMethod) {
       parent.generatedComponentModel.addMethod(
           COMPONENT_METHOD,
-          MethodSpec.overriding(factoryMethod, parentType(), parent.types)
+          MethodSpec.overriding(factoryMethod, parentType(), super.types)
               .addStatement(
                   "return new $T($L)",
                   super.generatedComponentModel.name(),
-                  factoryMethod
-                      .getParameters()
+                  getFactoryMethodParameterSpecs(super.graph)
                       .stream()
-                      .map(param -> CodeBlock.of("$L", param.getSimpleName()))
+                      .map(param -> CodeBlock.of("$N", param))
                       .collect(toParametersCodeBlock()))
               .build());
-
-      writeSubcomponentConstructorFor(factoryMethod);
-    }
-
-    private void writeSubcomponentConstructorFor(ExecutableElement factoryMethod) {
-      Set<ComponentRequirement> modules =
-          asExecutable(super.types.asMemberOf(parentType(), factoryMethod))
-              .getParameterTypes()
-              .stream()
-              .map(param -> ComponentRequirement.forModule(asTypeElement(param).asType()))
-              .collect(toImmutableSet());
-
-      for (ComponentRequirement module : modules) {
-        FieldSpec field = createSubcomponentModuleField(module);
-        super.constructor
-            .addParameter(field.type, field.name)
-            .addStatement("this.$1N = $2T.checkNotNull($1N)", field, Preconditions.class);
-      }
-
-      Set<ComponentRequirement> remainingModules =
-          super.graph
-              .componentRequirements()
-              .stream()
-              .filter(requirement -> requirement.kind().equals(ComponentRequirement.Kind.MODULE))
-              .filter(requirement -> !modules.contains(requirement))
-              .collect(toImmutableSet());
-
-      for (ComponentRequirement module : remainingModules) {
-        FieldSpec field = createSubcomponentModuleField(module);
-        super.constructor.addStatement("this.$N = new $T()", field, field.type);
-      }
-    }
-
-    // TODO(user): We shouldn't have to create these manually. They should be created lazily
-    // by ComponentRequirementFields, similar to how it's done for ComponentBindingExpressions.
-    private FieldSpec createSubcomponentModuleField(ComponentRequirement module) {
-      TypeElement moduleElement = module.typeElement();
-      String fieldName =
-          super.generatedComponentModel.getUniqueFieldName(
-              UPPER_CAMEL.to(LOWER_CAMEL, moduleElement.getSimpleName().toString()));
-      FieldSpec contributionField =
-          FieldSpec.builder(ClassName.get(moduleElement), fieldName)
-              .addModifiers(PRIVATE, FINAL).build();
-
-      super.generatedComponentModel.addField(COMPONENT_REQUIREMENT_FIELD, contributionField);
-      super.componentRequirementFields.add(
-          ComponentRequirementField.componentField(
-              module, contributionField, super.generatedComponentModel.name()));
-
-      return contributionField;
     }
 
     private DeclaredType parentType() {
       return asDeclared(parent.graph.componentType().asType());
     }
   }
+
+  /** Returns the list of {@link ParameterSpec}s for the corresponding graph's factory method. */
+  private static ImmutableList<ParameterSpec> getFactoryMethodParameterSpecs(BindingGraph graph) {
+    return graph
+        .factoryMethodParameters()
+        .values()
+        .stream()
+        .map(ParameterSpec::get)
+        .collect(toImmutableList());
+  }
 }
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index a8b36be32..d3f91067c 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -467,10 +467,10 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
             .addLines(
                 "",
                 "  private final class ChildComponentImpl implements ChildComponent {",
-                "    private final ChildModule childModule;",
+                "    private ChildModule childModule;",
                 "",
                 "    private ChildComponentImpl() {",
-                "      this.childModule = new ChildModule();",
+                "      initialize();",
                 "    }",
                 "")
             .addLinesIn(
@@ -497,6 +497,11 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
                 "              DaggerParentComponent.this.getDep1(),",
                 "              DaggerParentComponent.this.getDep2()));")
             .addLines(
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    private void initialize() {",
+                "      this.childModule = new ChildModule();",
                 "    }",
                 "",
                 "    @Override",
