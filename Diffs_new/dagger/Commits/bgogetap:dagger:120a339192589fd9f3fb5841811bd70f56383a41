diff --git a/BUILD b/BUILD
index 7f42e3c8c..70ec80f7f 100644
--- a/BUILD
+++ b/BUILD
@@ -19,6 +19,8 @@ package_group(
     packages = ["//..."],
 )
 
+load("//tools:javadoc.bzl", "javadoc_library")
+
 py_test(
     name = "maven_sha1_test",
     srcs = ["maven_sha1_test.py"],
@@ -70,25 +72,53 @@ jarjar_library(
     ],
 )
 
+jarjar_library(
+    name = "shaded_compiler_src",
+    rules_file = "merge_all_rules.txt",
+    deps = [
+        "//java/dagger/internal/codegen:libbase-src.jar",
+        "//java/dagger/internal/codegen:libbinding-src.jar",
+        "//java/dagger/internal/codegen:libprocessor-src.jar",
+        "//java/dagger/internal/codegen:libshared-with-spi-src.jar",
+        "//java/dagger/internal/codegen:libvalidation-src.jar",
+        "//java/dagger/internal/codegen:libwriting-src.jar",
+    ],
+)
+
 jarjar_library(
     name = "shaded_spi",
     rules_file = "shade_rules.txt",
     deps = [
         "//java/dagger/internal/codegen:shared-with-spi",
         "//java/dagger/model",
+        "//java/dagger/spi",
         "@com_google_auto_auto_common//jar",
     ],
 )
 
 jarjar_library(
-    name = "shaded_compiler_src",
+    name = "shaded_spi_src",
     rules_file = "merge_all_rules.txt",
     deps = [
-        "//java/dagger/internal/codegen:libbase-src.jar",
-        "//java/dagger/internal/codegen:libbinding-src.jar",
-        "//java/dagger/internal/codegen:libprocessor-src.jar",
-        "//java/dagger/internal/codegen:libvalidation-src.jar",
-        "//java/dagger/internal/codegen:libwriting-src.jar",
+        "//java/dagger/internal/codegen:libshared-with-spi-src.jar",
+        "//java/dagger/model:libmodel-src.jar",
+        "//java/dagger/spi:libspi-src.jar",
+    ],
+)
+
+javadoc_library(
+    name = "spi-javadoc",
+    srcs = [
+        "//java/dagger/model:model-srcs",
+        "//java/dagger/spi:spi-srcs",
+    ],
+    root_packages = [
+        "dagger.model",
+        "dagger.spi",
+    ],
+    deps = [
+        "//java/dagger/model",
+        "//java/dagger/spi",
     ],
 )
 
@@ -110,8 +140,6 @@ jarjar_library(
     ],
 )
 
-load("//tools:javadoc.bzl", "javadoc_library")
-
 # coalesced javadocs used for the gh-pages site
 javadoc_library(
     name = "user-docs",
@@ -123,6 +151,7 @@ javadoc_library(
         "//java/dagger/grpc/server/processor:javadoc-srcs",
         "//java/dagger/model:model-srcs",
         "//java/dagger/producers:producers-srcs",
+        "//java/dagger/spi:spi-srcs",
     ],
     android_api_level = 26,
     # TODO(ronshapiro): figure out how to specify the version number for release builds
@@ -141,5 +170,6 @@ javadoc_library(
         "//java/dagger/grpc/server/processor",
         "//java/dagger/model",
         "//java/dagger/producers",
+        "//java/dagger/spi",
     ],
 )
diff --git a/java/dagger/example/spi/BUILD b/java/dagger/example/spi/BUILD
new file mode 100644
index 000000000..b5edd40ad
--- /dev/null
+++ b/java/dagger/example/spi/BUILD
@@ -0,0 +1,31 @@
+# Copyright (C) 2018 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   An example of the dagger.spi.BindingGraphPlugin usage
+
+package(default_visibility = ["//:src"])
+
+java_plugin(
+    name = "binding-graph-visualizer",
+    srcs = glob(["*.java"]),
+    deps = [
+        "//java/dagger/model",
+        "//java/dagger/spi",
+        "//third_party:auto_service",
+        "//third_party:error_prone_annotations",
+        "//third_party:guava",
+        "//third_party:javapoet",
+    ],
+)
diff --git a/java/dagger/internal/codegen/BindingNetworkVisualizer.java b/java/dagger/example/spi/BindingGraphVisualizer.java
similarity index 95%
rename from java/dagger/internal/codegen/BindingNetworkVisualizer.java
rename to java/dagger/example/spi/BindingGraphVisualizer.java
index f2a724c03..bdaff2bf9 100644
--- a/java/dagger/internal/codegen/BindingNetworkVisualizer.java
+++ b/java/dagger/example/spi/BindingGraphVisualizer.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.example.spi;
 
 import static java.util.UUID.randomUUID;
 import static java.util.regex.Matcher.quoteReplacement;
@@ -37,6 +37,8 @@
 import dagger.model.BindingGraph.SubcomponentBuilderBindingEdge;
 import dagger.model.BindingKind;
 import dagger.model.ComponentPath;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.ValidationItem;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -48,6 +50,7 @@
 import java.util.Optional;
 import java.util.UUID;
 import java.util.stream.Collectors;
+import javax.annotation.processing.Filer;
 import javax.lang.model.element.TypeElement;
 import javax.tools.FileObject;
 import javax.tools.StandardLocation;
@@ -63,7 +66,13 @@
  * Foo_Bar.dot}.
  */
 @AutoService(BindingGraphPlugin.class)
-public final class BindingNetworkVisualizer extends BindingGraphPlugin {
+public final class BindingGraphVisualizer implements BindingGraphPlugin {
+  private Filer filer;
+
+  @Override
+  public void initFiler(Filer filer) {
+    this.filer = filer;
+  }
 
   /** Graphviz color names to use for binding nodes within each component. */
   private static final ImmutableList<String> COMPONENT_COLORS =
@@ -82,14 +91,14 @@
           "/set312/12");
 
   @Override
-  public void visitGraph(BindingGraph bindingGraph) {
+  public List<ValidationItem> visitGraph(BindingGraph bindingGraph) {
     TypeElement componentElement =
         bindingGraph.rootComponentNode().componentPath().currentComponent();
     DotGraph graph = new NodesGraph(bindingGraph).graph();
     ClassName componentName = ClassName.get(componentElement);
     try {
       FileObject file =
-          filer()
+          filer
               .createResource(
                   StandardLocation.CLASS_OUTPUT,
                   componentName.packageName(),
@@ -101,6 +110,7 @@ public void visitGraph(BindingGraph bindingGraph) {
     } catch (IOException e) {
       throw new RuntimeException(e);
     }
+    return ImmutableList.of();
   }
 
   private abstract static class Indented {
@@ -212,7 +222,7 @@ private static String quote(String string) {
 
     DotGraph graph() {
       if (nodeIds.isEmpty()) {
-        Iterator<String> colors = Iterators.cycle(BindingNetworkVisualizer.COMPONENT_COLORS);
+        Iterator<String> colors = Iterators.cycle(COMPONENT_COLORS);
         bindingGraph
             .nodes()
             .stream()
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 4f87ef72f..f6cb9f7bf 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -51,6 +51,7 @@ CODEGEN_SHARED_DEPS = [
     "//java/dagger:core",
     "//java/dagger/producers",
     "//java/dagger/model",
+    "//java/dagger/spi",
     "//java/dagger/model:internal-proxies",
 ]
 
@@ -123,7 +124,6 @@ java_library(
         "BindingDeclaration.java",
         "BindingFactory.java",
         "BindingGraph.java",
-        "BindingGraphPlugin.java",  # TODO(ronshapiro): this should move to its own model target
         "BindingType.java",
         "BindingTypeMapper.java",
         "BindingVariableNamer.java",  # needed by FrameworkField
@@ -283,6 +283,7 @@ java_library(
         "ModuleProcessingStep.java",
         "ProcessingOptions.java",
         "ProductionExecutorModuleProcessingStep.java",
+        "SpiDiagnosticReporter.java",
     ],
     plugins = CODEGEN_PLUGINS,
     deps = CODEGEN_DEPS + [
@@ -346,20 +347,6 @@ java_library(
     deps = CODEGEN_DEPS,
 )
 
-java_plugin(
-    name = "dagger-experimental-visualizer",
-    srcs = EXPERIMENTAL_VISUALIZER_SRCS,
-    deps = [
-        ":base",
-        ":binding",
-        "//java/dagger/model",
-        "//third_party:auto_service",
-        "//third_party:error_prone_annotations",
-        "//third_party:guava",
-        "//third_party:javapoet",
-    ],
-)
-
 java_plugin(
     name = "component-codegen",
     generates_api = 1,
diff --git a/java/dagger/internal/codegen/BindingGraphPlugin.java b/java/dagger/internal/codegen/BindingGraphPlugin.java
deleted file mode 100644
index 8ea0a6ce7..000000000
--- a/java/dagger/internal/codegen/BindingGraphPlugin.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import dagger.model.BindingGraph;
-import java.util.Collections;
-import java.util.Map;
-import java.util.Set;
-import javax.annotation.processing.Filer;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.annotation.processing.Processor;
-
-/**
- * A pluggable visitor for {@link BindingGraph}.
- *
- * <p>Note: This is still experimental and will change.
- */
-public abstract class BindingGraphPlugin {
-
-  private Filer filer;
-
-  final void setFiler(Filer filer) {
-    this.filer = filer;
-  }
-
-  /**
-   * Returns a filer that this plug-in can use to write Java or other files based on the binding
-   * graph.
-   */
-  protected final Filer filer() {
-    return filer;
-  }
-
-  /** Called once for each valid binding graph encountered by the Dagger processor. */
-  protected abstract void visitGraph(BindingGraph bindingGraph);
-
-  /**
-   * Returns the annotation-processing options that this plugin uses to configure behavior.
-   *
-   * @see Processor#getSupportedOptions()
-   */
-  protected Set<String> getSupportedOptions() {
-    return Collections.emptySet();
-  }
-
-  /**
-   * If {@link #getSupportedOptions()} returns a non-empty set, then this method will be called with
-   * matching options that were actually passed on the {@code javac} command-line.
-   *
-   * @see ProcessingEnvironment#getOptions()
-   */
-  // TODO(dpb, ronshapiro): Consider a protected method returning ProcessingEnvironment instead.
-  protected void setOptions(Map<String, String> options) {}
-}
diff --git a/java/dagger/internal/codegen/BindingGraphPluginsModule.java b/java/dagger/internal/codegen/BindingGraphPluginsModule.java
index d64643358..0caac2fa2 100644
--- a/java/dagger/internal/codegen/BindingGraphPluginsModule.java
+++ b/java/dagger/internal/codegen/BindingGraphPluginsModule.java
@@ -20,6 +20,7 @@
 import com.google.common.collect.Maps;
 import dagger.Module;
 import dagger.Provides;
+import dagger.spi.BindingGraphPlugin;
 import java.util.Map;
 import java.util.ServiceLoader;
 import java.util.Set;
@@ -40,10 +41,10 @@
     ImmutableList<BindingGraphPlugin> bindingGraphPlugins =
         ImmutableList.copyOf(ServiceLoader.load(BindingGraphPlugin.class, classLoader));
     for (BindingGraphPlugin plugin : bindingGraphPlugins) {
-      plugin.setFiler(filer);
-      Set<String> supportedOptions = plugin.getSupportedOptions();
+      plugin.initFiler(filer);
+      Set<String> supportedOptions = plugin.supportedOptions();
       if (!supportedOptions.isEmpty()) {
-        plugin.setOptions(Maps.filterKeys(processingOptions, supportedOptions::contains));
+        plugin.initOptions(Maps.filterKeys(processingOptions, supportedOptions::contains));
       }
     }
     return bindingGraphPlugins;
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index a8c37300b..56b2cc8c0 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -17,13 +17,17 @@
 package dagger.internal.codegen;
 
 import static javax.lang.model.util.ElementFilter.typesIn;
+import static javax.tools.Diagnostic.Kind.ERROR;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ListMultimap;
 import com.google.common.collect.Maps;
+import com.google.common.collect.MultimapBuilder;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
 import dagger.Component;
@@ -31,7 +35,10 @@
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.ValidationItem;
 import java.lang.annotation.Annotation;
+import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
@@ -55,6 +62,7 @@
   private final BindingGraph.Factory bindingGraphFactory;
   private final ComponentGenerator componentGenerator;
   private final ImmutableList<BindingGraphPlugin> bindingGraphPlugins;
+  private final SpiDiagnosticReporter spiDiagnosticReporter;
 
   @Inject
   ComponentProcessingStep(
@@ -66,7 +74,8 @@
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator,
-      ImmutableList<BindingGraphPlugin> bindingGraphPlugins) {
+      ImmutableList<BindingGraphPlugin> bindingGraphPlugins,
+      SpiDiagnosticReporter spiDiagnosticReporter) {
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.builderValidator = builderValidator;
@@ -76,6 +85,7 @@
     this.bindingGraphFactory = bindingGraphFactory;
     this.componentGenerator = componentGenerator;
     this.bindingGraphPlugins = bindingGraphPlugins;
+    this.spiDiagnosticReporter = spiDiagnosticReporter;
   }
 
   @Override
@@ -146,8 +156,11 @@
         }
 
         if (!bindingGraphPlugins.isEmpty()) {
-          dagger.model.BindingGraph graph = BindingGraphConverter.convert(bindingGraph);
-          bindingGraphPlugins.forEach(plugin -> plugin.visitGraph(graph));
+          Collection<ValidationItem> items =
+              executePlugins(BindingGraphConverter.convert(bindingGraph));
+          if (items.stream().anyMatch(item -> item.diagnosticKind().equals(ERROR))) {
+            continue;
+          }
         }
 
         generateComponent(bindingGraph);
@@ -158,6 +171,28 @@
     return rejectedElements.build();
   }
 
+  /**
+   * Calls {@link BindingGraphPlugin#visitGraph(dagger.model.BindingGraph)} on each of {@code
+   * bindingGraphPlugins} and reports any extra validation return from the plugins to the {@link
+   * Messager}.
+   *
+   * @return every {@link ValidationItem} returned by the plugins
+   */
+  private Collection<ValidationItem> executePlugins(dagger.model.BindingGraph graph) {
+    // TODO(ronshapiro): Should we validate the uniqueness of plugin names?
+    ListMultimap<String, ValidationItem> items =
+        MultimapBuilder.linkedHashKeys().arrayListValues().build();
+    for (BindingGraphPlugin plugin : bindingGraphPlugins) {
+      items.putAll(plugin.pluginName(), plugin.visitGraph(graph));
+    }
+
+    if (!items.isEmpty()) {
+      spiDiagnosticReporter.report(graph, ImmutableListMultimap.copyOf(items));
+    }
+
+    return items.values();
+  }
+
   private void generateComponent(BindingGraph bindingGraph) {
     componentGenerator.generate(bindingGraph, messager);
   }
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index 6bdadc1b4..47908d5c3 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -28,6 +28,7 @@
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
+import dagger.spi.BindingGraphPlugin;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Filer;
@@ -66,7 +67,7 @@ public SourceVersion getSupportedSourceVersion() {
     ImmutableSet.Builder<String> options = ImmutableSet.builder();
     options.addAll(CompilerOptions.SUPPORTED_OPTIONS);
     for (BindingGraphPlugin plugin : bindingGraphPlugins) {
-      options.addAll(plugin.getSupportedOptions());
+      options.addAll(plugin.supportedOptions());
     }
     return options.build();
   }
diff --git a/java/dagger/internal/codegen/SpiDiagnosticReporter.java b/java/dagger/internal/codegen/SpiDiagnosticReporter.java
new file mode 100644
index 000000000..32133da74
--- /dev/null
+++ b/java/dagger/internal/codegen/SpiDiagnosticReporter.java
@@ -0,0 +1,266 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
+import com.google.common.graph.SuccessorsFunction;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.ComponentNode;
+import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.Edge;
+import dagger.model.BindingGraph.Node;
+import dagger.model.DependencyRequest;
+import dagger.spi.ValidationItem;
+import java.util.ArrayDeque;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Optional;
+import java.util.Queue;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Reports the validation items from {@link
+ * dagger.spi.BindingGraphPlugin#visitGraph(dagger.model.BindingGraph) binding graph plugins} and
+ * reports them to the {@link Messager}.
+ */
+// TODO(ronshapiro): If multiple plugins print errors on the same node/edge, should we condense the
+// messages and only print the dependency trace once?
+final class SpiDiagnosticReporter {
+  private final Messager messager;
+  private final DependencyRequestFormatter dependencyRequestFormatter;
+
+  @Inject
+  SpiDiagnosticReporter(
+      Messager messager,
+      DependencyRequestFormatter dependencyRequestFormatter) {
+    this.messager = messager;
+    this.dependencyRequestFormatter = dependencyRequestFormatter;
+
+  }
+
+  /** Reports the {@link ValidationItem}s to the {@link Messager}. */
+  void report(
+      dagger.model.BindingGraph graph, ImmutableListMultimap<String, ValidationItem> items) {
+    for (Entry<String, ValidationItem> entry : items.entries()) {
+      new Worker(graph, entry.getKey(), entry.getValue()).report();
+    }
+  }
+
+  // TODO(dpb): Consider making one Worker per graph/plugin, and calling
+  // items.forEach(worker::report) instead of Worker per item
+  private class Worker {
+    private final dagger.model.BindingGraph graph;
+    private final String plugin;
+    private final ValidationItem item;
+    private final TypeElement rootComponent;
+
+    Worker(dagger.model.BindingGraph graph, String plugin, ValidationItem item) {
+      this.graph = graph;
+      this.plugin = plugin;
+      this.item = item;
+      this.rootComponent = graph.rootComponentNode().componentPath().currentComponent();
+    }
+
+    /**
+     * Reports the supplied diagnostic with extra context for users to the {@link Messager}. For
+     * example, if a {@link ValidationItem} is reported on a {@link BindingNode}, a dependency trace
+     * will be appended to the diagnostic message.
+     */
+    private void report() {
+      if (isInstance(item.node(), ComponentNode.class)) {
+        reportComponent((ComponentNode) item.node().get());
+      } else if (isInstance(item.node(), BindingNode.class)) {
+        reportBinding((BindingNode) item.node().get());
+      } else if (isInstance(item.edge(), DependencyEdge.class)) {
+        reportDependencyRequest((DependencyEdge) item.edge().get());
+      } else {
+        throw new AssertionError("Unknown ValidationItem kind: " + item);
+      }
+    }
+
+    private void reportComponent(ComponentNode node) {
+      CharSequence message = messageBuilder();
+      if (!node.componentPath().currentComponent().equals(rootComponent)) {
+        message = appendComponentPath(message, node);
+      }
+      messager.printMessage(item.diagnosticKind(), message, rootComponent);
+    }
+
+    private void reportBinding(BindingNode targetNode) {
+      // TODO(ronshapiro): should this also include the binding element?
+      reportAtEntryPointsWithDependencyTrace(targetNode, messageBuilder());
+    }
+
+    private void reportDependencyRequest(DependencyEdge edge) {
+      StringBuilder message =
+          messageBuilder()
+              .append('\n')
+              .append(dependencyRequestFormatter.format(edge.dependencyRequest()));
+
+      if (edge.isEntryPoint()) {
+        printAtEntryPoint(edge, message);
+      } else {
+        BindingNode sourceNode = (BindingNode) graph.incidentNodes(edge).source();
+        reportAtEntryPointsWithDependencyTrace(sourceNode, message);
+      }
+    }
+
+    /**
+     * For each entry point that depends on {@code targetNode}, appends the {@link
+     * #dependencyTrace(DependencyEdge, BindingNode)} to the binding onto {@code message} and prints
+     * to the messager.
+     */
+    private void reportAtEntryPointsWithDependencyTrace(
+        BindingNode targetNode, CharSequence baseMessage) {
+      for (DependencyEdge entryPoint : graph.entryPointEdgesDependingOnBindingNode(targetNode)) {
+        printAtEntryPoint(
+            entryPoint,
+            new StringBuilder(baseMessage).append(dependencyTrace(entryPoint, targetNode)));
+      }
+    }
+
+    // TODO(ronshapiro): Adding a DependencyPath type to dagger.model could be useful, i.e.
+    // bindingGraph.shortestPathFromEntryPoint(DependencyEdge, BindingNode)
+    private CharSequence dependencyTrace(DependencyEdge entryPoint, BindingNode targetNode) {
+      checkArgument(entryPoint.isEntryPoint());
+      Node entryPointBinding = graph.incidentNodes(entryPoint).target();
+      ImmutableList<Node> shortestPath =
+          shortestPath(
+              node -> Sets.filter(graph.successors(node), BindingNode.class::isInstance),
+              entryPointBinding,
+              targetNode);
+
+      StringBuilder trace = new StringBuilder(shortestPath.size() * 100 /* a guess heuristic */);
+      for (int i = shortestPath.size() - 1; i > 0; i--) {
+        Set<Edge> dependenciesBetween =
+            graph.edgesConnecting(shortestPath.get(i - 1), shortestPath.get(i));
+        DependencyRequest dependencyRequest =
+            // If a binding requests a key more than once, any of them should be fine to get to
+            // the shortest path
+            ((DependencyEdge) Iterables.get(dependenciesBetween, 0)).dependencyRequest();
+        trace.append('\n').append(dependencyRequestFormatter.format(dependencyRequest));
+      }
+      trace.append('\n').append(dependencyRequestFormatter.format(entryPoint.dependencyRequest()));
+      return trace;
+    }
+
+    /**
+     * Prints {@code message} at {@code entryPoint}'s element if it is defined in the {@code
+     * rootComponent}, otherwise at the root component.
+     */
+    private void printAtEntryPoint(DependencyEdge entryPoint, CharSequence message) {
+      checkArgument(entryPoint.isEntryPoint());
+      Element entryPointElement = entryPoint.dependencyRequest().requestElement().get();
+      Element elementToReport =
+          // TODO(ronshapiro): should we create a HashSet out of getEnclosedElements() so we don't
+          // need to do an O(n) contains() each time?
+          rootComponent.getEnclosedElements().contains(entryPointElement)
+              ? entryPointElement
+              : rootComponent;
+
+      Node component = graph.incidentNodes(entryPoint).source();
+      if (!component.equals(graph.rootComponentNode())) {
+        message = appendComponentPath(message, component);
+      }
+      messager.printMessage(item.diagnosticKind(), message, elementToReport);
+    }
+
+    private CharSequence appendComponentPath(CharSequence message, Node node) {
+      return new StringBuilder(message).append("\ncomponent path: ").append(node.componentPath());
+    }
+
+    private StringBuilder messageBuilder() {
+      return new StringBuilder(String.format("[%s] ", plugin)).append(item.message());
+    }
+  }
+
+  private static boolean isInstance(Optional<?> optional, Class<?> clazz) {
+    return optional.filter(clazz::isInstance).isPresent();
+  }
+
+  /**
+   * Returns a shortest path from {@code nodeU} to {@code nodeV} in {@code graph} as a list of the
+   * nodes visited in sequence, including both {@code nodeU} and {@code nodeV}. (Note that there may
+   * be many possible shortest paths.)
+   *
+   * <p>If {@code nodeV} is not {@link
+   * com.google.common.graph.Graphs#reachableNodes(com.google.common.graph.Graph, Object) reachable}
+   * from {@code nodeU}, the list returned is empty.
+   *
+   * @throws IllegalArgumentException if {@code nodeU} or {@code nodeV} is not present in {@code
+   *     graph}
+   */
+  // This is copied from common.graph since it is not yet open-sourced.
+  // TODO(ronshapiro): When the API is released and becomes stable, remove this copy.
+  private static <N> ImmutableList<N> shortestPath(SuccessorsFunction<N> graph, N nodeU, N nodeV) {
+    if (nodeU.equals(nodeV)) {
+      return ImmutableList.of(nodeU);
+    }
+    Set<N> successors = ImmutableSet.copyOf(graph.successors(nodeU));
+    if (successors.contains(nodeV)) {
+      return ImmutableList.of(nodeU, nodeV);
+    }
+
+    Map<N, N> visitedNodeToPathPredecessor = new HashMap<>(); // encodes shortest path tree
+    Queue<N> currentNodes = new ArrayDeque<N>();
+    Queue<N> nextNodes = new ArrayDeque<N>();
+    for (N node : successors) {
+      visitedNodeToPathPredecessor.put(node, nodeU);
+    }
+    currentNodes.addAll(successors);
+
+    // Perform a breadth-first traversal starting with the successors of nodeU.
+    while (!currentNodes.isEmpty()) {
+      while (!currentNodes.isEmpty()) {
+        N currentNode = currentNodes.remove();
+        for (N nextNode : graph.successors(currentNode)) {
+          if (visitedNodeToPathPredecessor.containsKey(nextNode)) {
+            continue; // we already have a shortest path to nextNode
+          }
+          visitedNodeToPathPredecessor.put(nextNode, currentNode);
+          if (nextNode.equals(nodeV)) {
+            ImmutableList.Builder<N> builder = ImmutableList.builder();
+            N node = nodeV;
+            builder.add(node);
+            while (!node.equals(nodeU)) {
+              node = visitedNodeToPathPredecessor.get(node);
+              builder.add(node);
+            }
+            return builder.build().reverse();
+          }
+          nextNodes.add(nextNode);
+        }
+      }
+      Queue<N> emptyQueue = currentNodes;
+      currentNodes = nextNodes;
+      nextNodes = emptyQueue; // reusing empty queue faster than allocating new one
+    }
+
+    return ImmutableList.of();
+  }
+}
diff --git a/java/dagger/model/BUILD b/java/dagger/model/BUILD
index 43f01cc37..f18d229a1 100644
--- a/java/dagger/model/BUILD
+++ b/java/dagger/model/BUILD
@@ -52,17 +52,9 @@ java_library(
 java_library(
     name = "internal-proxies",
     srcs = INTERNAL_PROXIES,
+    tags = ["maven:merged"],
     deps = [
         ":model",
         "//third_party:guava",
     ],
 )
-
-load("//tools:javadoc.bzl", "javadoc_library")
-
-javadoc_library(
-    name = "model-javadoc",
-    srcs = [":model-srcs"],
-    root_packages = ["dagger.model"],
-    deps = [":model"],
-)
diff --git a/java/dagger/spi/BUILD b/java/dagger/spi/BUILD
new file mode 100644
index 000000000..34cc7d31f
--- /dev/null
+++ b/java/dagger/spi/BUILD
@@ -0,0 +1,43 @@
+# Copyright (C) 2018 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   The Service Provider Interface for Dagger's binding graph model
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "DOCLINT_REFERENCES",
+)
+
+filegroup(
+    name = "spi-srcs",
+    srcs = glob(["*.java"]),
+)
+
+java_library(
+    name = "spi",
+    srcs = [":spi-srcs"],
+    javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    deps = [
+        "//java/dagger:core",
+        "//java/dagger/model",
+        "//third_party:auto_value",
+        "//third_party:error_prone_annotations",
+        "//third_party:guava",
+        "//third_party:jsr330_inject",
+    ],
+)
diff --git a/java/dagger/spi/BindingGraphPlugin.java b/java/dagger/spi/BindingGraphPlugin.java
new file mode 100644
index 000000000..894b0110a
--- /dev/null
+++ b/java/dagger/spi/BindingGraphPlugin.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.spi;
+
+import dagger.model.BindingGraph;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+
+/**
+ * A pluggable visitor for {@link BindingGraph}.
+ *
+ * <p>Note: This is still experimental and will change.
+ */
+public interface BindingGraphPlugin {
+  /**
+   * Called once for each valid root binding graph encountered by the Dagger processor.
+   *
+   * @return items used to print notes, warnings, and errors about the binding graph to the {@link
+   *     Messager}
+   */
+  List<ValidationItem> visitGraph(BindingGraph bindingGraph);
+
+  /**
+   * Initializes this plugin with a {@link Filer} that it can use to write Java or other files based
+   * on the binding graph. This will be called once per instance of this plugin, before any graph is
+   * {@linkplain #visitGraph(BindingGraph) visited}.
+   */
+  default void initFiler(Filer filer) {}
+
+  /**
+   * Initializes this plugin with a filtered view of the options passed on the {@code javac}
+   * command-line for all keys from {@link #supportedOptions()}. This will be called once per
+   * instance of this plugin, before any graph is {@linkplain #visitGraph(BindingGraph) visited}.
+   *
+   * @see ProcessingEnvironment#getOptions()
+   */
+  default void initOptions(Map<String, String> options) {}
+
+  /**
+   * Returns the annotation-processing options that this plugin uses to configure behavior.
+   *
+   * @see Processor#getSupportedOptions()
+   */
+  default Set<String> supportedOptions() {
+    return Collections.emptySet();
+  }
+
+  /**
+   * A distinguishing name of the plugin that will be used in diagnostics printed to the {@link
+   * Messager}. By default, the {@linkplain Class#getCanonicalName() fully qualified name} of the
+   * plugin is used.
+   */
+  default String pluginName() {
+    return getClass().getCanonicalName();
+  }
+}
diff --git a/java/dagger/spi/ValidationItem.java b/java/dagger/spi/ValidationItem.java
new file mode 100644
index 000000000..bacc8e94d
--- /dev/null
+++ b/java/dagger/spi/ValidationItem.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.spi;
+
+import com.google.auto.value.AutoValue;
+import com.google.errorprone.annotations.DoNotMock;
+import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.Edge;
+import dagger.model.BindingGraph.Node;
+import java.util.Optional;
+import javax.annotation.processing.Messager;
+import javax.tools.Diagnostic;
+
+/**
+ * A single item that is reported by {@link BindingGraphPlugin}s. Dagger will use these to print
+ * diagnostics to the {@link Messager} with any pertinent information, such as a dependency trace.
+ */
+@AutoValue
+@DoNotMock("Use ValidationItem.create() instead")
+public abstract class ValidationItem {
+  /** Creates a validation item on {@code node}. */
+  public static ValidationItem create(Diagnostic.Kind diagnosticKind, Node node, String message) {
+    return new AutoValue_ValidationItem(
+        diagnosticKind, Optional.of(node), Optional.empty(), message);
+  }
+
+  /** Creates a validation item on {@code edge}. */
+  public static ValidationItem create(
+      Diagnostic.Kind diagnosticKind, DependencyEdge edge, String message) {
+    return new AutoValue_ValidationItem(
+        diagnosticKind, Optional.empty(), Optional.of(edge), message);
+  }
+
+  public abstract Diagnostic.Kind diagnosticKind();
+
+  /**
+   * This method is only intended to be used by Dagger's implementation and may not remain part of
+   * the official API.
+   */
+  // TODO(ronshapiro): consider having a mechanism by which users can report an entire subgraph as a
+  // ValidationItem instead of a single node/edge.
+  public abstract Optional<Node> node();
+
+  /**
+   * This method is only intended to be used by Dagger's implementation and may not remain part of
+   * the official API.
+   */
+  public abstract Optional<Edge> edge();
+
+  public abstract String message();
+}
diff --git a/java/dagger/spi/package-info.java b/java/dagger/spi/package-info.java
new file mode 100644
index 000000000..87ebb33bf
--- /dev/null
+++ b/java/dagger/spi/package-info.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This package contains the Service Provider interface (SPI) to the {@link dagger.model} APIs at
+ * annotation-processing-time.
+ *
+ * <p>This package is experimental, and APIs may change at over time.
+ */
+@CheckReturnValue
+@Beta
+package dagger.spi;
+
+import com.google.errorprone.annotations.CheckReturnValue;
+import dagger.internal.Beta;
diff --git a/javatests/dagger/functional/spi/BUILD b/javatests/dagger/functional/spi/BUILD
index cbfc47825..2ee433495 100644
--- a/javatests/dagger/functional/spi/BUILD
+++ b/javatests/dagger/functional/spi/BUILD
@@ -23,8 +23,8 @@ java_plugin(
     name = "test_plugin",
     srcs = ["TestPlugin.java"],
     deps = [
-        "//java/dagger/internal/codegen:binding",
         "//java/dagger/model",
+        "//java/dagger/spi",
         "//third_party:auto_service",
         "//third_party:guava",
         "//third_party:javapoet",
diff --git a/javatests/dagger/functional/spi/TestPlugin.java b/javatests/dagger/functional/spi/TestPlugin.java
index 45c50a20b..9f1369fd4 100644
--- a/javatests/dagger/functional/spi/TestPlugin.java
+++ b/javatests/dagger/functional/spi/TestPlugin.java
@@ -20,34 +20,46 @@
 
 import com.google.auto.service.AutoService;
 import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
-import dagger.internal.codegen.BindingGraphPlugin;
 import dagger.model.BindingGraph;
 import dagger.model.BindingGraph.ComponentNode;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.ValidationItem;
 import java.io.IOException;
 import java.io.UncheckedIOException;
 import java.io.Writer;
+import java.util.List;
 import java.util.Properties;
+import javax.annotation.processing.Filer;
 
 @AutoService(BindingGraphPlugin.class)
-public final class TestPlugin extends BindingGraphPlugin {
+public final class TestPlugin implements BindingGraphPlugin {
+  private Filer filer;
 
   @Override
-  protected void visitGraph(BindingGraph bindingGraph) {
+  public void initFiler(Filer filer) {
+    this.filer = filer;
+  }
+
+  @Override
+  public List<ValidationItem> visitGraph(BindingGraph bindingGraph) {
     Properties properties = new Properties();
     int i = 0;
     for (ComponentNode node : bindingGraph.componentNodes()) {
       properties.setProperty(
           String.format("component[%s]", i++), node.componentPath().toString());
     }
+
     write(bindingGraph, properties);
+    return ImmutableList.of();
   }
 
   private void write(BindingGraph bindingGraph, Properties properties) {
     ClassName rootComponentName =
         ClassName.get(bindingGraph.rootComponentNode().componentPath().currentComponent());
     try (Writer writer =
-        filer()
+        filer
             .createResource(
                 CLASS_OUTPUT,
                 rootComponentName.packageName(),
diff --git a/javatests/dagger/spi/BUILD b/javatests/dagger/spi/BUILD
new file mode 100644
index 000000000..5be82d7a5
--- /dev/null
+++ b/javatests/dagger/spi/BUILD
@@ -0,0 +1,44 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Tests for the Dagger SPI
+
+package(default_visibility = ["//:src"])
+
+load("//:test_defs.bzl", "GenJavaTests")
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "DOCLINT_REFERENCES",
+)
+
+GenJavaTests(
+    name = "spi_tests",
+    srcs = glob(["*.java"]),
+    functional = False,
+    javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    deps = [
+        "//java/dagger:core",
+        "//java/dagger/internal/codegen:processor",
+        "//java/dagger/model",
+        "//java/dagger/spi",
+        "//third_party:auto_service",
+        "//third_party:compile_testing",
+        "//third_party:guava",
+        "//third_party:jsr330_inject",
+        "//third_party:junit",
+        "//third_party:truth",
+    ],
+)
diff --git a/javatests/dagger/spi/FailingPlugin.java b/javatests/dagger/spi/FailingPlugin.java
new file mode 100644
index 000000000..50bcf573a
--- /dev/null
+++ b/javatests/dagger/spi/FailingPlugin.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.spi;
+
+import static com.google.common.collect.ImmutableList.toImmutableList;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import dagger.model.BindingGraph;
+import java.util.Map;
+import java.util.Set;
+
+@AutoService(BindingGraphPlugin.class)
+public final class FailingPlugin implements BindingGraphPlugin {
+  private Map<String, String> options;
+
+  @Override
+  public Set<String> supportedOptions() {
+    return ImmutableSet.of(
+        "error_on_binding", "error_on_dependency", "error_on_component", "error_on_subcomponents");
+  }
+
+  @Override
+  public void initOptions(Map<String, String> options) {
+    this.options = options;
+  }
+
+  @Override
+  public ImmutableList<ValidationItem> visitGraph(BindingGraph bindingGraph) {
+    if (options.containsKey("error_on_binding")) {
+      String key = options.get("error_on_binding");
+      return bindingGraph
+          .bindingNodes()
+          .stream()
+          .filter(node -> node.binding().key().toString().equals(key))
+          .map(node -> ValidationItem.create(ERROR, node, "Bad Binding!"))
+          .collect(toImmutableList());
+    }
+
+    if (options.containsKey("error_on_component")) {
+      return ImmutableList.of(
+          ValidationItem.create(ERROR, bindingGraph.rootComponentNode(), "Bad Component!"));
+    }
+
+    if (options.containsKey("error_on_subcomponents")) {
+      return bindingGraph
+          .componentNodes()
+          .stream()
+          .filter(node -> !node.componentPath().atRoot())
+          .map(node -> ValidationItem.create(ERROR, node, "Bad Subcomponent!"))
+          .collect(toImmutableList());
+    }
+
+    if (options.containsKey("error_on_dependency")) {
+      String dependency = options.get("error_on_dependency");
+      return bindingGraph
+          .dependencyEdges()
+          .stream()
+          .filter(
+              edge ->
+                  edge.dependencyRequest()
+                      .requestElement()
+                      .get()
+                      .getSimpleName()
+                      .contentEquals(dependency))
+          .map(edge -> ValidationItem.create(ERROR, edge, "Bad Dependency!"))
+          .collect(toImmutableList());
+    }
+
+    return ImmutableList.of();
+  }
+
+  @Override
+  public String pluginName() {
+    return "FailingPlugin";
+  }
+}
diff --git a/javatests/dagger/spi/SpiPluginTest.java b/javatests/dagger/spi/SpiPluginTest.java
new file mode 100644
index 000000000..517a95976
--- /dev/null
+++ b/javatests/dagger/spi/SpiPluginTest.java
@@ -0,0 +1,496 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.spi;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ComponentProcessor;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class SpiPluginTest {
+  @Test
+  public void dependencyTraceAtBinding() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Foo foo();",
+            "}");
+
+    Compilation compilation =
+        javac()
+            .withProcessors(new ComponentProcessor())
+            .withOptions("-Aerror_on_binding=test.Foo")
+            .compile(component, foo);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            lines(
+                "[FailingPlugin] Bad Binding!",
+                "      test.Foo is provided at",
+                "          test.TestComponent.foo()"))
+        .inFile(component)
+        .onLineContaining("Foo foo();");
+  }
+
+  @Test
+  public void dependencyTraceAtDependencyRequest() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo(Duplicated inFooDep) {}",
+            "}");
+    JavaFileObject duplicated =
+        JavaFileObjects.forSourceLines(
+            "test.Duplicated",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Duplicated {",
+            "  @Inject Duplicated() {}",
+            "}");
+    JavaFileObject entryPoint =
+        JavaFileObjects.forSourceLines(
+            "test.EntryPoint",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class EntryPoint {",
+            "  @Inject EntryPoint(Foo foo, Duplicated dup1, Duplicated dup2) {}",
+            "}");
+    JavaFileObject chain1 =
+        JavaFileObjects.forSourceLines(
+            "test.Chain1",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Chain1 {",
+            "  @Inject Chain1(Chain2 chain) {}",
+            "}");
+    JavaFileObject chain2 =
+        JavaFileObjects.forSourceLines(
+            "test.Chain2",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Chain2 {",
+            "  @Inject Chain2(Chain3 chain) {}",
+            "}");
+    JavaFileObject chain3 =
+        JavaFileObjects.forSourceLines(
+            "test.Chain3",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Chain3 {",
+            "  @Inject Chain3(Foo foo) {}",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  EntryPoint entryPoint();",
+            "  Chain1 chain();",
+            "}");
+
+    CompilationFactory compilationFactory =
+        new CompilationFactory(component, foo, duplicated, entryPoint, chain1, chain2, chain3);
+
+    assertThat(compilationFactory.compilationWithErrorOnDependency("entryPoint"))
+        .hadErrorContaining(
+            lines(
+                "[FailingPlugin] Bad Dependency!",
+                "      test.EntryPoint is provided at",
+                "          test.TestComponent.entryPoint()"))
+        .inFile(component)
+        .onLineContaining("EntryPoint entryPoint();");
+    assertThat(compilationFactory.compilationWithErrorOnDependency("dup1"))
+        .hadErrorContaining(
+            lines(
+                "[FailingPlugin] Bad Dependency!",
+                "      test.Duplicated is injected at",
+                "          test.EntryPoint.<init>(…, dup1, …)",
+                "      test.EntryPoint is provided at",
+                "          test.TestComponent.entryPoint()"))
+        .inFile(component)
+        .onLineContaining("EntryPoint entryPoint();");
+    assertThat(compilationFactory.compilationWithErrorOnDependency("dup2"))
+        .hadErrorContaining(
+            lines(
+                "[FailingPlugin] Bad Dependency!",
+                "      test.Duplicated is injected at",
+                "          test.EntryPoint.<init>(…, dup2)",
+                "      test.EntryPoint is provided at",
+                "          test.TestComponent.entryPoint()"))
+        .inFile(component)
+        .onLineContaining("EntryPoint entryPoint();");
+    // Note that this compilation results in one ValidationItem being reported twice since there are
+    // two entry points that depend on test.Foo
+    Compilation inFooDepCompilation =
+        compilationFactory.compilationWithErrorOnDependency("inFooDep");
+    assertThat(inFooDepCompilation)
+        .hadErrorContaining(
+            lines(
+                "[FailingPlugin] Bad Dependency!",
+                "      test.Duplicated is injected at",
+                "          test.Foo.<init>(inFooDep)",
+                "      test.Foo is injected at",
+                "          test.EntryPoint.<init>(foo, …)",
+                "      test.EntryPoint is provided at",
+                "          test.TestComponent.entryPoint()"))
+        .inFile(component)
+        .onLineContaining("EntryPoint entryPoint();");
+    assertThat(inFooDepCompilation)
+        .hadErrorContaining(
+            lines(
+                "[FailingPlugin] Bad Dependency!",
+                "      test.Duplicated is injected at",
+                "          test.Foo.<init>(inFooDep)",
+                "      test.Foo is injected at",
+                "          test.Chain3.<init>(foo)",
+                "      test.Chain3 is injected at",
+                "          test.Chain2.<init>(chain)",
+                "      test.Chain2 is injected at",
+                "          test.Chain1.<init>(chain)",
+                "      test.Chain1 is provided at",
+                "          test.TestComponent.chain()"))
+        .inFile(component)
+        .onLineContaining("Chain1 chain();");
+  }
+
+  @Test
+  public void dependencyTraceAtDependencyRequest_subcomponents() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject entryPoint =
+        JavaFileObjects.forSourceLines(
+            "test.EntryPoint",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class EntryPoint {",
+            "  @Inject EntryPoint(Foo foo) {}",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  TestSubcomponent sub();",
+            "}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface TestSubcomponent {",
+            "  EntryPoint childEntryPoint();",
+            "}");
+
+    CompilationFactory compilationFactory =
+        new CompilationFactory(component, subcomponent, foo, entryPoint);
+    assertThat(compilationFactory.compilationWithErrorOnDependency("childEntryPoint"))
+        .hadErrorContaining(
+            lines(
+                "[FailingPlugin] Bad Dependency!",
+                "      test.EntryPoint is provided at",
+                "          test.TestSubcomponent.childEntryPoint()",
+                "  component path: test.TestComponent → test.TestSubcomponent"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+    assertThat(compilationFactory.compilationWithErrorOnDependency("foo"))
+        .hadErrorContaining(
+            lines(
+                "[FailingPlugin] Bad Dependency!",
+                "      test.Foo is injected at",
+                "          test.EntryPoint.<init>(foo)",
+                "      test.EntryPoint is provided at",
+                "          test.TestSubcomponent.childEntryPoint()",
+                // TODO(ronshapiro): Maybe make the component path resemble a stack trace:
+                //     test.TestSubcomponent is a child of
+                //         test.TestComponent
+                "  component path: test.TestComponent → test.TestSubcomponent"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void errorOnComponent() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {}");
+
+    Compilation compilation =
+        javac()
+            .withProcessors(new ComponentProcessor())
+            .withOptions("-Aerror_on_component")
+            .compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("[FailingPlugin] Bad Component!")
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void errorOnSubcomponent() {
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface TestSubcomponent {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  TestSubcomponent subcomponent();",
+            "}");
+
+    Compilation compilation =
+        javac()
+            .withProcessors(new ComponentProcessor())
+            .withOptions("-Aerror_on_subcomponents")
+            .compile(component, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            lines(
+                "[FailingPlugin] Bad Subcomponent!",
+                "  component path: test.TestComponent → test.TestSubcomponent"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  // SpiDiagnosticReporter uses a shortest path algorithm to determine a dependency trace to a
+  // binding. Without modifications, this would produce a strange error if a shorter path exists
+  // from one entrypoint, through a @Module.subcomponents builder binding edge, and to the binding
+  // usage within the subcomponent. Therefore, when scanning for the shortest path, we only consider
+  // BindingNodes so we don't cross component boundaries. This test exhibits this case.
+  @Test
+  public void shortestPathToBindingExistsThroughSubcomponentBuilder() {
+    JavaFileObject chain1 =
+        JavaFileObjects.forSourceLines(
+            "test.Chain1",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Chain1 {",
+            "  @Inject Chain1(Chain2 chain) {}",
+            "}");
+    JavaFileObject chain2 =
+        JavaFileObjects.forSourceLines(
+            "test.Chain2",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Chain2 {",
+            "  @Inject Chain2(Chain3 chain) {}",
+            "}");
+    JavaFileObject chain3 =
+        JavaFileObjects.forSourceLines(
+            "test.Chain3",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Chain3 {",
+            "  @Inject Chain3(ExposedOnSubcomponent exposedOnSubcomponent) {}",
+            "}");
+    JavaFileObject exposedOnSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.ExposedOnSubcomponent",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class ExposedOnSubcomponent {",
+            "  @Inject ExposedOnSubcomponent() {}",
+            "}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface TestSubcomponent {",
+            "  ExposedOnSubcomponent exposedOnSubcomponent();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    TestSubcomponent build();",
+            "  }",
+            "}");
+    JavaFileObject subcomponentModule =
+        JavaFileObjects.forSourceLines(
+            "test.SubcomponentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module(subcomponents = TestSubcomponent.class)",
+            "interface SubcomponentModule {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = SubcomponentModule.class)",
+            "interface TestComponent {",
+            "  Chain1 chain();",
+            "  TestSubcomponent.Builder subcomponent();",
+            "}");
+
+    Compilation compilation =
+        javac()
+            .withProcessors(new ComponentProcessor())
+            .withOptions("-Aerror_on_binding=test.ExposedOnSubcomponent")
+            .compile(
+                component,
+                subcomponent,
+                chain1,
+                chain2,
+                chain3,
+                exposedOnSubcomponent,
+                subcomponentModule);
+    assertThat(compilation)
+        .hadErrorContaining(
+            lines(
+                "[FailingPlugin] Bad Binding!",
+                "      test.ExposedOnSubcomponent is injected at",
+                "          test.Chain3.<init>(exposedOnSubcomponent)",
+                "      test.Chain3 is injected at",
+                "          test.Chain2.<init>(chain)",
+                "      test.Chain2 is injected at",
+                "          test.Chain1.<init>(chain)",
+                "      test.Chain1 is provided at",
+                "          test.TestComponent.chain()"))
+        .inFile(component)
+        .onLineContaining("Chain1 chain();");
+    assertThat(compilation)
+        .hadErrorContaining(
+            lines(
+                // TODO(ronshapiro): should this error be reported if it's already been reported at
+                // an ancestor component?
+                "[FailingPlugin] Bad Binding!",
+                "      test.ExposedOnSubcomponent is provided at",
+                "          test.TestSubcomponent.exposedOnSubcomponent()",
+                "  component path: test.TestComponent → test.TestSubcomponent"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  // This works around an issue in the opensource compile testing where only one diagnostic is
+  // recorded per line. When multiple validation items resolve to the same entry point, we can
+  // only see the first. This helper class makes it easier to compile all of the files in the test
+  // multiple times with different options to single out each error
+  private static class CompilationFactory {
+    private final ImmutableList<JavaFileObject> javaFileObjects;
+
+    CompilationFactory(JavaFileObject... javaFileObjects) {
+      this.javaFileObjects = ImmutableList.copyOf(javaFileObjects);
+    }
+
+    private Compilation compilationWithErrorOnDependency(String dependencySimpleName) {
+      return javac()
+          .withProcessors(new ComponentProcessor())
+          .withOptions("-Aerror_on_dependency=" + dependencySimpleName)
+          .compile(javaFileObjects);
+    }
+  }
+
+  private static String lines(String... lines) {
+    return Joiner.on('\n').join(lines);
+  }
+}
diff --git a/tools/javadoc.bzl b/tools/javadoc.bzl
index 9ad098714..18db4dca0 100644
--- a/tools/javadoc.bzl
+++ b/tools/javadoc.bzl
@@ -44,7 +44,7 @@ def _javadoc_libary(ctx):
 
   inputs += classpath.to_list()
 
-  include_packages = ":".join(ctx.attr.root_packages)
+  include_packages = " ".join(ctx.attr.root_packages)
   javadoc_command = [
       ctx.file._javadoc_binary.path,
       '-sourcepath $(find * -type d -name "*java" -print0 | tr "\\0" :)',
diff --git a/util/execute-deploy.sh b/util/execute-deploy.sh
index eedaef0cf..82f2c1871 100755
--- a/util/execute-deploy.sh
+++ b/util/execute-deploy.sh
@@ -76,8 +76,8 @@ deploy_library \
 
 deploy_library \
   shaded_spi.jar \
-  java/dagger/model/libmodel-src.jar \
-  java/dagger/model/model-javadoc.jar \
+  shaded_spi_src.jar \
+  spi-javadoc.jar \
   dagger-spi.pom.xml
 
 deploy_library \
diff --git a/util/maven/generate_poms.py b/util/maven/generate_poms.py
index 8b448bece..ce902537e 100644
--- a/util/maven/generate_poms.py
+++ b/util/maven/generate_poms.py
@@ -77,6 +77,10 @@ def pom_deps(label):
         'name': 'Dagger SPI',
         'artifact': 'dagger-spi',
     },
+    '//java/dagger/spi:spi': {
+        'name': 'Dagger SPI',
+        'artifact': 'dagger-spi',
+    },
     '//java/dagger/android:android': {
         'name': 'Dagger Android',
         'artifact': 'dagger-android',
@@ -163,6 +167,7 @@ def artifact_for_dep(label):
     metadata = METADATA[arg]
     with open('%s.pom.xml' % metadata['artifact'], 'w') as pom_file:
       deps = map(artifact_for_dep, pom_deps(arg))
+      deps = list(set(deps)) # remove duplicates
       deps.sort(cmp=dependencies_comparator)
       pom_file.write(generate_pom(artifacts[arg], metadata, deps, version))
 
