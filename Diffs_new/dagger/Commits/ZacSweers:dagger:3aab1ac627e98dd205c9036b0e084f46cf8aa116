diff --git a/javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java b/javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
index bdaea7ec5..00e9bb2cb 100644
--- a/javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
+++ b/javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
@@ -16,10 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
-import com.google.auto.value.processor.AutoAnnotationProcessor;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -43,12 +43,8 @@ public void annotatesSourceRetainedAnnotation() {
             "@CanReleaseReferences",
             "@Retention(RetentionPolicy.SOURCE)",
             "@interface Metadata {}");
-    assertAbout(javaSource())
-        .that(annotation)
-        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-        .failsToCompile()
-        .withErrorContaining("SOURCE")
-        .in(annotation)
-        .onLine(8);
+    Compilation compilation = daggerCompiler().compile(annotation);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("SOURCE").inFile(annotation).onLine(8);
   }
 }
diff --git a/javatests/dagger/internal/codegen/Compilers.java b/javatests/dagger/internal/codegen/Compilers.java
index fed935886..aed1572f8 100644
--- a/javatests/dagger/internal/codegen/Compilers.java
+++ b/javatests/dagger/internal/codegen/Compilers.java
@@ -25,6 +25,7 @@
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compiler;
+import javax.annotation.processing.Processor;
 
 /** {@link Compiler} instances for testing Dagger. */
 final class Compilers {
@@ -39,8 +40,14 @@
               .filter(jar -> !jar.contains(GUAVA))
               .collect(joining(PATH_SEPARATOR.value())));
 
-  /** Returns a compiler that runs the Dagger processor. */
-  static Compiler daggerCompiler() {
-    return javac().withProcessors(new ComponentProcessor(), new AutoAnnotationProcessor());
+  /**
+   * Returns a compiler that runs the Dagger and {@code @AutoAnnotation} processors, along with
+   * extras.
+   */
+  static Compiler daggerCompiler(Processor... extraProcessors) {
+    ImmutableList.Builder<Processor> processors = ImmutableList.builder();
+    processors.add(new ComponentProcessor(), new AutoAnnotationProcessor());
+    processors.add(extraProcessors);
+    return javac().withProcessors(processors.build());
   }
 }
diff --git a/javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java b/javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
index db2702f58..6fbdbd3bd 100644
--- a/javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
@@ -16,8 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -54,16 +56,16 @@ public void singletonSubcomponent() {
             "@Subcomponent",
             "interface Child {}");
 
-    assertThat(component, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("conflicting scopes")
-        .and().withErrorContaining("test.Parent also has @Singleton");
+    Compilation compilation = daggerCompiler().compile(component, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("conflicting scopes");
+    assertThat(compilation).hadErrorContaining("test.Parent also has @Singleton");
 
-    assertThat(component, subcomponent)
-        .withCompilerOptions("-Adagger.disableInterComponentScopeValidation=none")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation withoutScopeValidation =
+        daggerCompiler()
+            .withOptions("-Adagger.disableInterComponentScopeValidation=none")
+            .compile(component, subcomponent);
+    assertThat(withoutScopeValidation).succeeded();
   }
   
   @Test
@@ -117,8 +119,8 @@ public void productionComponents_productionScopeImplicitOnBoth() {
             "class ChildModule {",
             "  @Provides @ProductionScope String childScopedString() { return new String(); }",
             "}");
-    assertThat(component, subcomponent, parentModule, childModule)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation =
+        daggerCompiler().compile(component, subcomponent, parentModule, childModule);
+    assertThat(compilation).succeeded();
   }
 }
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index 851b92bd7..eb79921c2 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -21,6 +21,7 @@
 import static dagger.internal.codegen.CodeBlocks.stringLiteral;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
 import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
@@ -29,10 +30,8 @@
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.testing.compile.Compilation;
-import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
 import com.squareup.javapoet.CodeBlock;
 import dagger.MembersInjector;
@@ -2520,10 +2519,6 @@ public void componentMethodInChildCallsComponentMethodInParent() {
         .containsElementsIn(expectedPattern);
   }
 
-  private static Compiler daggerCompiler(Processor... extraProcessors) {
-    return javac().withProcessors(Lists.asList(new ComponentProcessor(), extraProcessors));
-  }
-
   /**
    * A {@link ComponentProcessor} that excludes elements using a {@link Predicate}.
    */
diff --git a/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java b/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java
index 4684db56e..18107c97a 100644
--- a/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java
+++ b/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java
@@ -17,13 +17,15 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.truth.FailureMetadata;
 import com.google.common.truth.Subject;
 import com.google.common.truth.Truth;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import dagger.Module;
 import dagger.producers.ProducerModule;
@@ -143,12 +145,12 @@ DaggerModuleMethodSubject withAdditionalSources(JavaFileObject... sources) {
   void hasError(String errorSubstring) {
     String source = moduleSource();
     JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule", source);
-    assertAbout(javaSources())
-        .that(FluentIterable.from(additionalSources).append(module))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorSubstring)
-        .in(module)
+    Compilation compilation =
+        daggerCompiler().compile(FluentIterable.from(additionalSources).append(module));
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(errorSubstring)
+        .inFile(module)
         .onLine(methodLine(source));
   }
 
diff --git a/javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java b/javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
index 05f849f21..8a529e91c 100644
--- a/javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
+++ b/javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
@@ -16,10 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
-import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -48,15 +48,14 @@ public void notAScope() {
             "interface Injects {",
             "  @ForReleasableReferences(NotAScope.class) ReleasableReferenceManager manager();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(notAScope, injects))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(notAScope, injects);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "The value of @ForReleasableReferences must be a reference-releasing scope. "
                 + "Did you mean to annotate test.NotAScope with @javax.inject.Scope and "
                 + "@dagger.releasablereferences.CanReleaseReferences?")
-        .in(injects)
+        .inFile(injects)
         .onLine(7)
         .atColumn(3);
   }
@@ -87,15 +86,14 @@ public void notAReferenceReleasingScope() {
             "interface Injects {",
             "  @ForReleasableReferences(TestScope.class) ReleasableReferenceManager manager();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(testScope, injects))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(testScope, injects);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "The value of @ForReleasableReferences must be a reference-releasing scope. "
                 + "Did you mean to annotate test.TestScope with "
                 + "@dagger.releasablereferences.CanReleaseReferences?")
-        .in(injects)
+        .inFile(injects)
         .onLine(7)
         .atColumn(3);
   }
diff --git a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
index 1bdea110a..85ca1a8fd 100644
--- a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -16,11 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static java.util.Arrays.asList;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -67,11 +66,9 @@
         "test.MyComponent (unscoped) may not reference scoped bindings:\n"
             + "      @Singleton class test.ScopedType\n"
             + "      @Provides @Singleton String test.ScopedModule.string()";
-    assertAbout(javaSources())
-        .that(asList(componentFile, typeFile, moduleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+    Compilation compilation = daggerCompiler().compile(componentFile, typeFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
@@ -120,11 +117,10 @@
             + "may not reference bindings with different scopes:\n"
             + "      @test.PerTest class test.ScopedType\n"
             + "      @Provides @test.PerTest String test.ScopedModule.string()";
-    assertAbout(javaSources())
-        .that(asList(componentFile, scopeFile, typeFile, moduleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+    Compilation compilation =
+        daggerCompiler().compile(componentFile, scopeFile, typeFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test public void componentWithScopeMayDependOnOnlyOneScopedComponent() {
@@ -191,12 +187,12 @@
         "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped component:\n"
         + "      @Singleton test.SingletonComponentA\n"
         + "      @Singleton test.SingletonComponentB";
-    assertAbout(javaSources())
-        .that(
-            asList(type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test public void componentWithoutScopeCannotDependOnScopedComponent() {
@@ -232,11 +228,9 @@
     String errorMessage =
         "test.UnscopedComponent (unscoped) cannot depend on scoped components:\n"
         + "      @Singleton test.ScopedComponent";
-    assertAbout(javaSources())
-        .that(asList(type, scopedComponent, unscopedComponent))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+    Compilation compilation = daggerCompiler().compile(type, scopedComponent, unscopedComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test public void componentWithSingletonScopeMayNotDependOnOtherScope() {
@@ -279,11 +273,10 @@
     String errorMessage =
         "This @Singleton component cannot depend on scoped components:\n"
         + "      @test.SimpleScope test.SimpleScopedComponent";
-    assertAbout(javaSources())
-        .that(asList(type, simpleScope, simpleScoped, singletonScoped))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+    Compilation compilation =
+        daggerCompiler().compile(type, simpleScope, simpleScoped, singletonScoped);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test public void componentScopeAncestryMustNotCycle() {
@@ -345,11 +338,10 @@
         + "      @test.ScopeA test.ComponentLong\n"
         + "      @test.ScopeB test.ComponentMedium\n"
         + "      @test.ScopeA test.ComponentShort";
-    assertAbout(javaSources())
-        .that(asList(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+    Compilation compilation =
+        daggerCompiler().compile(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test
@@ -365,12 +357,11 @@ public void reusableNotAllowedOnComponent() {
             "@Reusable",
             "@Component",
             "interface SomeComponent {}");
-    assertAbout(javaSource())
-        .that(someComponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Reusable cannot be applied to components or subcomponents.")
-        .in(someComponent)
+    Compilation compilation = daggerCompiler().compile(someComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents.")
+        .inFile(someComponent)
         .onLine(6);
   }
 
@@ -387,12 +378,11 @@ public void reusableNotAllowedOnSubcomponent() {
             "@Reusable",
             "@Subcomponent",
             "interface SomeSubcomponent {}");
-    assertAbout(javaSource())
-        .that(someSubcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Reusable cannot be applied to components or subcomponents.")
-        .in(someSubcomponent)
+    Compilation compilation = daggerCompiler().compile(someSubcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents.")
+        .inFile(someSubcomponent)
         .onLine(6);
   }
 }
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index 1d0d0c110..a36fd23d4 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -16,19 +16,14 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static com.google.testing.compile.Compiler.javac;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.NonNullableRequestForNullableBindingValidation.nullableToNonNullable;
 
 import com.google.common.base.Joiner;
-import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
-import java.util.Arrays;
 import javax.tools.JavaFileObject;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -68,11 +63,12 @@
         "import javax.inject.Inject;",
         "",
         "interface Bar {}");
-    assertAbout(javaSources()).that(Arrays.asList(component, injectable, nonInjectable))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
-            .in(component).onLine(7);
+    Compilation compilation = daggerCompiler().compile(component, injectable, nonInjectable);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
+        .inFile(component)
+        .onLine(7);
   }
 
   @Test public void componentProvisionWithNoDependencyChain() {
@@ -94,19 +90,18 @@
             "    @Q A qualifiedA();",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.TestClass.A cannot be provided without an @Provides-annotated method.")
-        .in(component)
-        .onLine(12)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(12);
+    assertThat(compilation)
+        .hadErrorContaining(
             "@test.TestClass.Q test.TestClass.A "
                 + "cannot be provided without an @Provides-annotated method.")
-        .in(component)
+        .inFile(component)
         .onLine(13);
   }
 
@@ -132,10 +127,9 @@
     String expectedError =
         "test.TestClass.A cannot be provided without an @Inject constructor or an "
             + "@Provides-annotated method.";
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(15);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(15);
   }
 
   @Test public void membersInjectWithoutProvision() {
@@ -165,10 +159,9 @@
         "test.TestClass.B cannot be provided without an @Inject constructor or an "
             + "@Provides-annotated method. This type supports members injection but cannot be "
             + "implicitly provided.";
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(19);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(19);
   }
 
   @Test
@@ -196,11 +189,10 @@ public void membersInjectDependsOnUnboundedType() {
             "interface TestComponent {",
             "  void injectsUnboundedType(InjectsUnboundedType injects);",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(injectsUnboundedType, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(injectsUnboundedType, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             Joiner.on('\n')
                 .join(
                     "Cannot inject members into types with unbounded type arguments: "
@@ -209,7 +201,7 @@ public void membersInjectDependsOnUnboundedType() {
                     "          test.InjectsUnboundedType.listInjector",
                     "      test.InjectsUnboundedType is injected at",
                     "          test.TestComponent.injectsUnboundedType(test.InjectsUnboundedType)"))
-        .in(component)
+        .inFile(component)
         .onLine(7);
   }
 
@@ -322,13 +314,9 @@ public void staticFieldInjection() {
             "interface TestComponent {",
             "  void inject(Injected injected);",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(injected, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("static fields")
-        .in(injected)
-        .onLine(6);
+    Compilation compilation = daggerCompiler().compile(injected, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("static fields").inFile(injected).onLine(6);
   }
 
   @Test public void cyclicDependency() {
@@ -372,10 +360,9 @@ public void staticFieldInjection() {
                 "      test.Outer.C is provided at",
                 "          test.Outer.CComponent.getC()");
 
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(23);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(23);
   }
 
   @Test public void cyclicDependencyNotIncludingEntryPoint() {
@@ -427,13 +414,9 @@ public void staticFieldInjection() {
                 "      test.Outer.D is provided at",
                 "          test.Outer.DComponent.getD()");
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(27);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(27);
   }
 
   @Test
@@ -499,13 +482,9 @@ public void cyclicDependencyNotBrokenByMapBinding() {
                 "      test.Outer.C is provided at",
                 "          test.Outer.CComponent.getC()");
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(26);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(26);
   }
 
   @Test
@@ -564,13 +543,9 @@ public void cyclicDependencyWithSetBinding() {
                 "      test.Outer.C is provided at",
                 "          test.Outer.CComponent.getC()");
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(25);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(25);
   }
 
   @Test
@@ -624,13 +599,9 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
                 "      test.Outer.D is provided at",
                 "          test.Outer.DComponent.getD()");
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(28);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(28);
   }
 
   @Test
@@ -708,13 +679,10 @@ public void cyclicDependencyInSubcomponents() {
                 "      java.lang.String is provided at",
                 "          test.Grandchild.entry()");
 
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, child, grandchild, childModule, grandchildModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(child)
-        .onLine(6);
+    Compilation compilation =
+        daggerCompiler().compile(parent, child, grandchild, childModule, grandchildModule);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(child).onLine(6);
   }
 
   @Test
@@ -753,10 +721,10 @@ public void circularBindsMethods() {
             "  @SomeQualifier Object qualified();",
             "}");
 
-    assertThat(qualifier, module, component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(qualifier, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "Found a dependency cycle:\n"
                 + "      java.lang.Object is injected at\n"
                 + "          test.TestModule.bindQualified(unqualified)\n"
@@ -764,10 +732,12 @@ public void circularBindsMethods() {
                 + "          test.TestModule.bindUnqualified(qualified)\n"
                 + "      java.lang.Object is provided at\n"
                 + "          test.TestComponent.unqualified()")
-        .in(component)
-        .onLine(7)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(7);
+    assertThat(compilation)
+        .hadErrorContaining(
+            // TODO(gak): cl/126230644 produces a better error message in this case. Here it isn't
+            // unclear what is going wrong.
             "Found a dependency cycle:\n"
                 + "      @test.SomeQualifier java.lang.Object is injected at\n"
                 + "          test.TestModule.bindUnqualified(qualified)\n"
@@ -775,7 +745,7 @@ public void circularBindsMethods() {
                 + "          test.TestModule.bindQualified(unqualified)\n"
                 + "      @test.SomeQualifier java.lang.Object is provided at\n"
                 + "          test.TestComponent.qualified()")
-        .in(component)
+        .inFile(component)
         .onLine(8);
   }
 
@@ -805,18 +775,16 @@ public void selfReferentialBinds() {
             "  Object selfReferential();",
             "}");
 
-    assertThat(module, component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            // TODO(gak): cl/126230644 produces a better error message in this case. Here it isn't
-            // unclear what is going wrong.
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "Found a dependency cycle:\n"
                 + "      java.lang.Object is injected at\n"
                 + "          test.TestModule.bindToSelf(sameKey)\n"
                 + "      java.lang.Object is provided at\n"
                 + "          test.TestComponent.selfReferential()")
-        .in(component)
+        .inFile(component)
         .onLine(7);
   }
 
@@ -949,10 +917,9 @@ public void missingBindingWithSameKeyAsMembersInjectionMethod() {
             "@Provides test.Outer.A test.Outer.AModule.provideA(String)",
             "test.Outer.A test.Outer.Parent.getA()");
 
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(30);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(30);
   }
 
   @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
@@ -988,10 +955,9 @@ public void missingBindingWithSameKeyAsMembersInjectionMethod() {
         + "      @Provides test.Outer.A test.Outer.Module1.provideA1()\n"
         + "      @Provides test.Outer.A test.Outer.Module2.provideA2(String)";
 
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(24);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(24);
   }
 
   @Test
@@ -1030,17 +996,16 @@ public void duplicateExplicitBindings_ProvidesVsBinds() {
             "  }",
             "}");
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             Joiner.on("\n      ")
                 .join(
                     "test.Outer.A is bound multiple times:",
                     "@Provides test.Outer.A test.Outer.Module1.provideA1()",
                     "@Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
-        .in(component)
+        .inFile(component)
         .onLine(28);
   }
 
@@ -1127,17 +1092,10 @@ public void duplicateExplicitBindings_ProvidesVsBinds() {
             "Unique bindings and declarations:",
             "    @Provides Map<String,String> test.Outer.TestModule2.stringMap()");
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedSetError)
-        .in(component)
-        .onLine(52)
-        .and()
-        .withErrorContaining(expectedMapError)
-        .in(component)
-        .onLine(53);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedSetError).inFile(component).onLine(52);
+    assertThat(compilation).hadErrorContaining(expectedMapError).inFile(component).onLine(53);
   }
 
   @Test
@@ -1198,17 +1156,10 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             + "      Unique bindings and declarations:\n"
             + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
 
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedSetError)
-        .in(component)
-        .onLine(32)
-        .and()
-        .withErrorContaining(expectedMapError)
-        .in(component)
-        .onLine(33);
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedSetError).inFile(component).onLine(32);
+    assertThat(compilation).hadErrorContaining(expectedMapError).inFile(component).onLine(33);
   }
 
   @Test public void duplicateBindings_TruncateAfterLimit() {
@@ -1452,11 +1403,11 @@ public void bindsMethodAppearsInTrace() {
             "interface TestModule {",
             "  @Binds abstract TestInterface bindTestInterface(TestImplementation implementation);",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(component, module, interfaceFile, implementationFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().compile(component, module, interfaceFile, implementationFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             Joiner.on("\n      ")
                 .join(
                     "java.lang.String cannot be provided without an @Inject constructor or an "
@@ -1467,7 +1418,7 @@ public void bindsMethodAppearsInTrace() {
                     "    TestModule.bindTestInterface(implementation)",
                     "TestInterface is provided at",
                     "    TestComponent.testInterface()"))
-        .in(component)
+        .inFile(component)
         .onLine(5);
   }
 
@@ -1539,16 +1490,19 @@ public void bindsMissingRightHandSide() {
 
     Compilation compilation = daggerCompiler().compile(duplicates, component);
     assertThat(compilation).failed();
+    // Some javacs report only the first error for each source line.
+    // Assert that one of the expected errors is reported.
     assertThat(compilation)
-        .hadErrorContaining(
-            error(
-                "test.Duplicates.BoundTwice is bound multiple times:",
-                "@Binds test.Duplicates.BoundTwice "
-                    + "test.Duplicates.DuplicatesModule"
-                    + ".bindWithResolvedKey(test.Duplicates.BoundImpl)",
-                "@Binds test.Duplicates.BoundTwice "
-                    + "test.Duplicates.DuplicatesModule"
-                    + ".bindWithUnresolvedKey(test.Duplicates.NotBound)"))
+        .hadErrorContainingMatch(
+            "\\Qtest.Duplicates.NotBound cannot be provided\\E|"
+                + error(
+                    "\\Qtest.Duplicates.BoundTwice is bound multiple times:",
+                    "@Binds test.Duplicates.BoundTwice "
+                        + "test.Duplicates.DuplicatesModule"
+                        + ".bindWithResolvedKey(test.Duplicates.BoundImpl)",
+                    "@Binds test.Duplicates.BoundTwice "
+                        + "test.Duplicates.DuplicatesModule"
+                        + ".bindWithUnresolvedKey(test.Duplicates.NotBound)"))
         .inFile(component)
         .onLineContaining("boundTwice();");
     assertThat(compilation)
@@ -1620,10 +1574,9 @@ public void bindsMissingRightHandSide() {
                 "          test.UsesTest.<init>(genericTestClass)",
                 "      test.UsesTest is provided at",
                 "          test.TestComponent.usesTest()");
-    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedMsg);
+    Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedMsg);
   }
 
   @Test public void resolvedVariablesInDependencyTrace() {
@@ -1675,10 +1628,9 @@ public void bindsMissingRightHandSide() {
                 "          test.UsesTest.<init>(genericTestClass)",
                 "      test.UsesTest is provided at",
                 "          test.TestComponent.usesTest()");
-    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedMsg);
+    Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedMsg);
   }
 
   @Test public void nullCheckForConstructorParameters() {
@@ -1709,19 +1661,21 @@ public void bindsMissingRightHandSide() {
         "interface TestComponent {",
         "  A a();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             nullableToNonNullable(
                 "java.lang.String",
                 "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, a, module, component);
+    assertThat(compilation2).succeeded();
   }
 
   @Test public void nullCheckForMembersInjectParam() {
@@ -1753,19 +1707,21 @@ public void bindsMissingRightHandSide() {
         "interface TestComponent {",
         "  A a();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             nullableToNonNullable(
                 "java.lang.String",
                 "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, a, module, component);
+    assertThat(compilation2).succeeded();
   }
 
   @Test public void nullCheckForVariable() {
@@ -1797,19 +1753,21 @@ public void bindsMissingRightHandSide() {
         "interface TestComponent {",
         "  A a();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             nullableToNonNullable(
                 "java.lang.String",
                 "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, a, module, component);
+    assertThat(compilation2).succeeded();
   }
 
   @Test public void nullCheckForComponentReturn() {
@@ -1832,19 +1790,21 @@ public void bindsMissingRightHandSide() {
         "interface TestComponent {",
         "  String string();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(NULLABLE, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             nullableToNonNullable(
                 "java.lang.String",
                 "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, module, component);
+    assertThat(compilation2).succeeded();
   }
 
   @Test
@@ -1885,11 +1845,10 @@ public void nullCheckForOptionalInstance() {
             "interface TestComponent {",
             "  A a();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             nullableToNonNullable(
                 "java.lang.String",
                 "@test.Nullable @Provides String test.TestModule.provideString()"));
@@ -1934,10 +1893,8 @@ public void nullCheckForOptionalProvider() {
             "interface TestComponent {",
             "  A a();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).succeeded();
   }
 
   @Test
@@ -1979,10 +1936,8 @@ public void nullCheckForOptionalLazy() {
             "interface TestComponent {",
             "  A a();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).succeeded();
   }
 
   @Test
@@ -2025,10 +1980,8 @@ public void nullCheckForOptionalProviderOfLazy() {
             "interface TestComponent {",
             "  A a();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).succeeded();
   }
 
   @Test public void componentDependencyMustNotCycle_Direct() {
@@ -2043,11 +1996,9 @@ public void nullCheckForOptionalProviderOfLazy() {
     String errorMessage =
         "test.ComponentShort contains a cycle in its component dependencies:\n"
             + "      test.ComponentShort";
-    assertAbout(javaSource())
-        .that(shortLifetime)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
+    Compilation compilation = daggerCompiler().compile(shortLifetime);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage);
   }
 
   @Test public void componentDependencyMustNotCycle_Indirect() {
@@ -2091,15 +2042,11 @@ public void nullCheckForOptionalProviderOfLazy() {
             + "      test.ComponentLong\n"
             + "      test.ComponentMedium\n"
             + "      test.ComponentShort";
-    assertAbout(javaSources())
-        .that(ImmutableList.of(longLifetime, mediumLifetime, shortLifetime))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(longErrorMessage).in(longLifetime)
-        .and()
-        .withErrorContaining(mediumErrorMessage).in(mediumLifetime)
-        .and()
-        .withErrorContaining(shortErrorMessage).in(shortLifetime);
+    Compilation compilation = daggerCompiler().compile(longLifetime, mediumLifetime, shortLifetime);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(longErrorMessage).inFile(longLifetime);
+    assertThat(compilation).hadErrorContaining(mediumErrorMessage).inFile(mediumLifetime);
+    assertThat(compilation).hadErrorContaining(shortErrorMessage).inFile(shortLifetime);
   }
 
   @Test
@@ -2335,19 +2282,21 @@ public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning()
             "    }",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parentConflictsWithChild, child))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(parentConflictsWithChild, child);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             error(
                 "[test.Child.parentChildConflictThatViolatesNullability()] "
                     + "java.lang.Object is bound multiple times:",
                 "@Provides Object test.Child.ChildModule.nonNullableParentChildConflict()",
                 "@Provides @javax.annotation.Nullable Object"
                     + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()"))
-        .in(parentConflictsWithChild)
+        .inFile(parentConflictsWithChild)
         .onLine(9);
   }
 
@@ -2396,12 +2345,11 @@ public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
             "    return \"child string\";",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, parentModule, child, childModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("[Child.needsString()] java.lang.String cannot be provided")
-        .in(parent)
+    Compilation compilation = daggerCompiler().compile(parent, parentModule, child, childModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("[Child.needsString()] java.lang.String cannot be provided")
+        .inFile(parent)
         .onLine(4);
   }
 
@@ -2470,12 +2418,12 @@ public void multibindingContributionBetweenAncestorComponentAndEntrypointCompone
             "    return \"\" + i;",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, parentModule, child, childModule, grandchild))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("[Grandchild.object()] java.lang.Double cannot be provided")
-        .in(parent)
+    Compilation compilation =
+        daggerCompiler().compile(parent, parentModule, child, childModule, grandchild);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("[Grandchild.object()] java.lang.Double cannot be provided")
+        .inFile(parent)
         .onLine(4);
   }
 
@@ -2565,13 +2513,12 @@ public void missingReleasableReferenceManager() {
             "  @ForReleasableReferences(TestScope.class)",
             "  TypedReleasableReferenceManager<BadMetadata> badManager();",
             "}");
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
-                testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .compile(testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "There is no binding for "
                 + "@dagger.releasablereferences.ForReleasableReferences(test.OtherScope.class) "
                 + "dagger.releasablereferences.ReleasableReferenceManager "
@@ -2579,24 +2526,24 @@ public void missingReleasableReferenceManager() {
                 + "with @test.OtherScope. "
                 + "The available reference-releasing scopes are "
                 + "[@test.TestScope, @test.YetAnotherScope].")
-        .in(component)
-        .onLine(13)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(13);
+    assertThat(compilation)
+        .hadErrorContaining(
             "There is no binding for "
                 + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
                 + "dagger.releasablereferences.TypedReleasableReferenceManager<test.TestMetadata> "
                 + "because test.TestScope is not annotated with @test.TestMetadata")
-        .in(component)
-        .onLine(16)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(16);
+    assertThat(compilation)
+        .hadErrorContaining(
             "There is no binding for "
                 + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
                 + "dagger.releasablereferences.TypedReleasableReferenceManager<test.BadMetadata> "
                 + "because test.BadMetadata is not annotated with "
                 + "@dagger.releasablereferences.CanReleaseReferences")
-        .in(component)
+        .inFile(component)
         .onLine(19);
   }
 
@@ -2686,11 +2633,11 @@ public void releasableReferenceManagerConflict() {
             "  Set<ReleasableReferenceManager> managers();",
             "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(testScope, testMetadata, testModule, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().compile(testScope, testMetadata, testModule, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 error(
                     "@%1$s.ForReleasableReferences(test.TestScope.class) "
@@ -2701,10 +2648,10 @@ public void releasableReferenceManagerConflict() {
                         + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
                         + "%1$s.ReleasableReferenceManager from the scope declaration"),
                 "dagger.releasablereferences"))
-        .in(component)
-        .onLine(13)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(13);
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 error(
                     "@%1$s.ForReleasableReferences(test.TestScope.class) "
@@ -2718,10 +2665,10 @@ public void releasableReferenceManagerConflict() {
                         + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
                         + "from the scope declaration"),
                 "dagger.releasablereferences"))
-        .in(component)
-        .onLine(16)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(16);
+    assertThat(compilation)
+        .hadErrorContaining(
             error(
                 "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
                     + "is bound multiple times:",
@@ -2730,10 +2677,10 @@ public void releasableReferenceManagerConflict() {
                     + "test.TestModule.rrmSet()",
                 "Dagger-generated binding for "
                     + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
-        .in(component)
-        .onLine(18)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(18);
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 error(
                     "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
@@ -2744,7 +2691,7 @@ public void releasableReferenceManagerConflict() {
                     "Dagger-generated binding for "
                         + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
                 "dagger.releasablereferences"))
-        .in(component)
+        .inFile(component)
         .onLine(19);
   }
 
diff --git a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index f8baa6059..a044d0975 100644
--- a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -17,8 +17,10 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.CHECKED_EXCEPTIONS_ON_CONSTRUCTORS;
 import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
@@ -39,6 +41,7 @@
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -86,10 +89,12 @@
         "class PrivateConstructor {",
         "  @Inject private PrivateConstructor() {}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_ON_PRIVATE_CONSTRUCTOR).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(INJECT_ON_PRIVATE_CONSTRUCTOR)
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void injectConstructorOnInnerClass() {
@@ -103,10 +108,12 @@
         "    @Inject InnerClass() {}",
         "  }",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_CONSTRUCTOR_ON_INNER_CLASS).in(file).onLine(7);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(INJECT_CONSTRUCTOR_ON_INNER_CLASS)
+        .inFile(file)
+        .onLine(7);
   }
 
   @Test public void injectConstructorOnAbstractClass() {
@@ -118,10 +125,12 @@
         "abstract class AbstractClass {",
         "  @Inject AbstractClass() {}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS)
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void injectConstructorOnGenericClass() {
@@ -544,11 +553,10 @@
         "  TooManyInjectConstructors(int i) {}",
         "  @Inject TooManyInjectConstructors(String s) {}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(6)
-        .and().withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(8);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).inFile(file).onLine(6);
+    assertThat(compilation).hadErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).inFile(file).onLine(8);
   }
 
   @Test public void multipleQualifiersOnInjectConstructorParameter() {
@@ -560,10 +568,11 @@
         "class MultipleQualifierConstructorParam {",
         "  @Inject MultipleQualifierConstructorParam(@QualifierA @QualifierB String s) {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ComponentProcessor()).failsToCompile()
-        // for whatever reason, javac only reports the error once on the constructor
-        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+
+    // for whatever reason, javac only reports the error once on the constructor
+    assertThat(compilation).hadErrorContaining(MULTIPLE_QUALIFIERS).inFile(file).onLine(6);
   }
 
   @Test public void injectConstructorOnClassWithMultipleScopes() {
@@ -575,10 +584,10 @@
         "@ScopeA @ScopeB class MultipleScopeClass {",
         "  @Inject MultipleScopeClass() {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file, SCOPE_A, SCOPE_B))
-        .processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(1)
-        .and().withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(9);
+    Compilation compilation = daggerCompiler().compile(file, SCOPE_A, SCOPE_B);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MULTIPLE_SCOPES).inFile(file).onLine(5).atColumn(1);
+    assertThat(compilation).hadErrorContaining(MULTIPLE_SCOPES).inFile(file).onLine(5).atColumn(9);
   }
 
   @Test public void injectConstructorWithQualifier() {
@@ -593,10 +602,16 @@
         "  @QualifierB",
         "  MultipleScopeClass() {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(7)
-        .and().withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(8);
+    Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR)
+        .inFile(file)
+        .onLine(7);
+    assertThat(compilation)
+        .hadErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR)
+        .inFile(file)
+        .onLine(8);
   }
 
   @Test public void injectConstructorWithCheckedExceptionsError() {
@@ -608,9 +623,12 @@
         "class CheckedExceptionClass {",
         "  @Inject CheckedExceptionClass() throws Exception {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file))
-        .processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS)
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void injectConstructorWithCheckedExceptionsWarning() {
@@ -622,11 +640,13 @@
         "class CheckedExceptionClass {",
         "  @Inject CheckedExceptionClass() throws Exception {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file))
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .withWarningContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS).in(file).onLine(6);
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.privateMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS)
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void privateInjectClassError() {
@@ -640,11 +660,9 @@
         "    @Inject InnerClass() {}",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(file))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(7);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(INJECT_INTO_PRIVATE_CLASS).inFile(file).onLine(7);
   }
 
   @Test public void privateInjectClassWarning() {
@@ -658,12 +676,10 @@
         "    @Inject InnerClass() {}",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(file))
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(7);
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.privateMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningContaining(INJECT_INTO_PRIVATE_CLASS).inFile(file).onLine(7);
   }
 
   @Test public void nestedInPrivateInjectClassError() {
@@ -679,11 +695,9 @@
         "    }",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(file))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(8);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(INJECT_INTO_PRIVATE_CLASS).inFile(file).onLine(8);
   }
 
   @Test public void nestedInPrivateInjectClassWarning() {
@@ -699,12 +713,10 @@
         "    }",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(file))
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(8);
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.privateMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningContaining(INJECT_INTO_PRIVATE_CLASS).inFile(file).onLine(8);
   }
 
   @Test public void finalInjectField() {
@@ -716,10 +728,9 @@
         "class FinalInjectField {",
         "  @Inject final String s;",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(FINAL_INJECT_FIELD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(FINAL_INJECT_FIELD).inFile(file).onLine(6);
   }
 
   @Test public void privateInjectFieldError() {
@@ -731,10 +742,9 @@
         "class PrivateInjectField {",
         "  @Inject private String s;",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(PRIVATE_INJECT_FIELD).inFile(file).onLine(6);
   }
 
   @Test public void privateInjectFieldWarning() {
@@ -746,10 +756,9 @@
         "class PrivateInjectField {",
         "  @Inject private String s;",
         "}");
-    assertAbout(javaSource()).that(file)
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError(); // TODO: Verify warning message when supported
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.privateMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded(); // TODO: Verify warning message when supported
   }
 
   @Test public void staticInjectFieldError() {
@@ -761,10 +770,9 @@
         "class StaticInjectField {",
         "  @Inject static String s;",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(STATIC_INJECT_FIELD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(STATIC_INJECT_FIELD).inFile(file).onLine(6);
   }
 
   @Test public void staticInjectFieldWarning() {
@@ -776,10 +784,9 @@
         "class StaticInjectField {",
         "  @Inject static String s;",
         "}");
-    assertAbout(javaSource()).that(file)
-        .withCompilerOptions("-Adagger.staticMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError(); // TODO: Verify warning message when supported
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.staticMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded(); // TODO: Verify warning message when supported
   }
 
   @Test public void multipleQualifiersOnField() {
@@ -791,10 +798,18 @@
         "class MultipleQualifierInjectField {",
         "  @Inject @QualifierA @QualifierB String s;",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(11)
-        .and().withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(23);
+    Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MULTIPLE_QUALIFIERS)
+        .inFile(file)
+        .onLine(6)
+        .atColumn(11);
+    assertThat(compilation)
+        .hadErrorContaining(MULTIPLE_QUALIFIERS)
+        .inFile(file)
+        .onLine(6)
+        .atColumn(23);
   }
 
   @Test public void abstractInjectMethod() {
@@ -806,10 +821,9 @@
         "abstract class AbstractInjectMethod {",
         "  @Inject abstract void method();",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(ABSTRACT_INJECT_METHOD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(ABSTRACT_INJECT_METHOD).inFile(file).onLine(6);
   }
 
   @Test public void privateInjectMethodError() {
@@ -821,10 +835,9 @@
         "class PrivateInjectMethod {",
         "  @Inject private void method(){}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRIVATE_INJECT_METHOD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(PRIVATE_INJECT_METHOD).inFile(file).onLine(6);
   }
 
   @Test public void privateInjectMethodWarning() {
@@ -836,10 +849,9 @@
         "class PrivateInjectMethod {",
         "  @Inject private void method(){}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError(); // TODO: Verify warning message when supported
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.privateMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded(); // TODO: Verify warning message when supported
   }
 
   @Test public void staticInjectMethodError() {
@@ -851,10 +863,9 @@
         "class StaticInjectMethod {",
         "  @Inject static void method(){}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(STATIC_INJECT_METHOD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(STATIC_INJECT_METHOD).inFile(file).onLine(6);
   }
 
   @Test public void staticInjectMethodWarning() {
@@ -866,10 +877,9 @@
         "class StaticInjectMethod {",
         "  @Inject static void method(){}",
         "}");
-    assertAbout(javaSource()).that(file)
-        .withCompilerOptions("-Adagger.staticMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError(); // TODO: Verify warning message when supported
+    Compilation compilation =
+        daggerCompiler().withOptions("-Adagger.staticMemberValidation=WARNING").compile(file);
+    assertThat(compilation).succeeded(); // TODO: Verify warning message when supported
   }
 
   @Test public void genericInjectMethod() {
@@ -881,10 +891,9 @@
         "class AbstractInjectMethod {",
         "  @Inject <T> void method();",
         "}");
-    assertAbout(javaSource()).that(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(GENERIC_INJECT_METHOD).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(GENERIC_INJECT_METHOD).inFile(file).onLine(6);
   }
 
   @Test public void multipleQualifiersOnInjectMethodParameter() {
@@ -896,11 +905,9 @@
         "class MultipleQualifierMethodParam {",
         "  @Inject void method(@QualifierA @QualifierB String s) {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        // for whatever reason, javac only reports the error once on the method
-        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
+    Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MULTIPLE_QUALIFIERS).inFile(file).onLine(6);
   }
 
   @Test public void injectConstructorDependsOnProduced() {
@@ -913,10 +920,10 @@
         "final class A {",
         "  @Inject A(Produced<String> str) {}",
         "}");
-    assertAbout(javaSource()).that(aFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Produced may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(aFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Produced may only be injected in @Produces methods");
   }
 
   @Test public void injectConstructorDependsOnProducer() {
@@ -929,10 +936,10 @@
         "final class A {",
         "  @Inject A(Producer<String> str) {}",
         "}");
-    assertAbout(javaSource()).that(aFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Producer may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(aFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Producer may only be injected in @Produces methods");
   }
 
   @Test public void injectFieldDependsOnProduced() {
@@ -945,10 +952,10 @@
         "final class A {",
         "  @Inject Produced<String> str;",
         "}");
-    assertAbout(javaSource()).that(aFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Produced may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(aFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Produced may only be injected in @Produces methods");
   }
 
   @Test public void injectFieldDependsOnProducer() {
@@ -961,10 +968,10 @@
         "final class A {",
         "  @Inject Producer<String> str;",
         "}");
-    assertAbout(javaSource()).that(aFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Producer may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(aFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Producer may only be injected in @Produces methods");
   }
 
   @Test public void injectMethodDependsOnProduced() {
@@ -977,10 +984,10 @@
         "final class A {",
         "  @Inject void inject(Produced<String> str) {}",
         "}");
-    assertAbout(javaSource()).that(aFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Produced may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(aFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Produced may only be injected in @Produces methods");
   }
 
   @Test public void injectMethodDependsOnProducer() {
@@ -993,10 +1000,10 @@
         "final class A {",
         "  @Inject void inject(Producer<String> str) {}",
         "}");
-    assertAbout(javaSource()).that(aFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Producer may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(aFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Producer may only be injected in @Produces methods");
   }
 
   @Test public void injectConstructor() {
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 77baa5de9..0f8d95789 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -16,13 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
-import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Collection;
@@ -1127,18 +1124,13 @@ public void mapBindingsWithDuplicateKeys() {
             "interface TestComponent {",
             "  Map<String, Object> objects();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(module, componentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("The same map key is bound more than once")
-        .and()
-        .withErrorContaining("provideObjectForAKey()")
-        .and()
-        .withErrorContaining("provideObjectForAKeyAgain()")
-        .and()
-        .withErrorCount(1);
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(module, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("The same map key is bound more than once");
+    assertThat(compilation).hadErrorContaining("provideObjectForAKey()");
+    assertThat(compilation).hadErrorContaining("provideObjectForAKeyAgain()");
+    assertThat(compilation).hadErrorCount(1);
   }
 
   @Test
@@ -1186,17 +1178,14 @@ public void mapBindingsWithInconsistentKeyAnnotations() {
             "interface TestComponent {",
             "  Map<String, Object> objects();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(module, stringKeyTwoFile, componentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("uses more than one @MapKey annotation type")
-        .and()
-        .withErrorContaining("provideObjectForAKey()")
-        .and()
-        .withErrorContaining("provideObjectForBKey()")
-        .and()
-        .withErrorCount(1);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, stringKeyTwoFile, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("uses more than one @MapKey annotation type");
+    assertThat(compilation).hadErrorContaining("provideObjectForAKey()");
+    assertThat(compilation).hadErrorContaining("provideObjectForBKey()");
+    assertThat(compilation).hadErrorCount(1);
   }
 }
diff --git a/javatests/dagger/internal/codegen/MembersInjectionTest.java b/javatests/dagger/internal/codegen/MembersInjectionTest.java
index 160005095..6d297f64d 100644
--- a/javatests/dagger/internal/codegen/MembersInjectionTest.java
+++ b/javatests/dagger/internal/codegen/MembersInjectionTest.java
@@ -19,7 +19,6 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
 import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
@@ -853,13 +852,12 @@ public void lowerCaseNamedMembersInjector_forLowerCaseType() {
             "  void inject(foo target);",
             "}");
 
-    assertAbout(javaSources())
-        .that(ImmutableList.of(foo, fooModule, fooComponent))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesFileNamed(CLASS_OUTPUT, "test", "foo_MembersInjector.class");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(foo, fooModule, fooComponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation).generatedFile(CLASS_OUTPUT, "test", "foo_MembersInjector.class");
   }
 
   @Test
@@ -972,14 +970,9 @@ public void fieldInjectionForShadowedMember() {
         "    @Inject int field;",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(file)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS)
-        .in(file)
-        .onLine(6);
+    Compilation compilation = daggerCompiler().withOptions(compilerMode.javacopts()).compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(INJECT_INTO_PRIVATE_CLASS).inFile(file).onLine(6);
   }
 
   @Test public void privateNestedClassWarning() {
@@ -993,15 +986,13 @@ public void fieldInjectionForShadowedMember() {
         "    @Inject int field;",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(file)
-        .withCompilerOptions(
-            compilerMode.javacopts().append("-Adagger.privateMemberValidation=WARNING"))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS)
-        .in(file)
-        .onLine(6);
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(
+                compilerMode.javacopts().append("-Adagger.privateMemberValidation=WARNING"))
+            .compile(file);
+    assertThat(compilation).succeeded();
+    assertThat(compilation).hadWarningContaining(INJECT_INTO_PRIVATE_CLASS).inFile(file).onLine(6);
   }
 
   @Test public void privateSuperclassIsOkIfNotInjectedInto() {
@@ -1017,11 +1008,8 @@ public void fieldInjectionForShadowedMember() {
         "    @Inject int field;",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(file)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation = daggerCompiler().withOptions(compilerMode.javacopts()).compile(file);
+    assertThat(compilation).succeeded();
   }
 
   @Test public void rawFrameworkTypes() {
@@ -1047,16 +1035,15 @@ public void fieldInjectionForShadowedMember() {
             "  void inject(RawProviderField rawProviderField);",
             "  void inject(RawProviderParameter rawProviderParameter);",
             "}");
-    assertThat(file)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("javax.inject.Provider cannot be provided")
-        .in(file)
-        .onLine(17)
-        .and()
-        .withErrorContaining("javax.inject.Provider cannot be provided")
-        .in(file)
+    Compilation compilation = daggerCompiler().withOptions(compilerMode.javacopts()).compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("javax.inject.Provider cannot be provided")
+        .inFile(file)
+        .onLine(17);
+    assertThat(compilation)
+        .hadErrorContaining("javax.inject.Provider cannot be provided")
+        .inFile(file)
         .onLine(18);
   }
 
diff --git a/javatests/dagger/internal/codegen/MissingBindingSuggestionsTest.java b/javatests/dagger/internal/codegen/MissingBindingSuggestionsTest.java
index f63771743..e2f963494 100644
--- a/javatests/dagger/internal/codegen/MissingBindingSuggestionsTest.java
+++ b/javatests/dagger/internal/codegen/MissingBindingSuggestionsTest.java
@@ -16,10 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
-import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -91,12 +91,11 @@ private static JavaFileObject emptyInterface(String interfaceName) {
         "  BarComponent getBar(BarModule barModule);",
         "}");
 
-    assertAbout(javaSources())
-        .that(ImmutableList.of(
-            fooComponent, barComponent, topComponent, foo, bar, barModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("A binding with matching key exists in component: test.BarComponent");
+    Compilation compilation =
+        daggerCompiler().compile(fooComponent, barComponent, topComponent, foo, bar, barModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("A binding with matching key exists in component: test.BarComponent");
   }
 
   @Test public void suggestsBindingInNestedSubcomponent() {
@@ -151,11 +150,11 @@ private static JavaFileObject emptyInterface(String interfaceName) {
         "  BarComponent getBar();",
         "}");
 
-    assertAbout(javaSources())
-        .that(ImmutableList.of(
-            fooComponent, barComponent, bazComponent, topComponent, foo, baz, bazModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("A binding with matching key exists in component: test.BazComponent");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(fooComponent, barComponent, bazComponent, topComponent, foo, baz, bazModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("A binding with matching key exists in component: test.BazComponent");
   }
 }
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 3c0751d4c..88c4c67aa 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -17,9 +17,10 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
@@ -39,7 +40,7 @@
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
 import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.CompileTester;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import com.squareup.javapoet.CodeBlock;
 import javax.tools.JavaFileObject;
@@ -147,12 +148,11 @@ public void providesMethodReturnsProduced() {
         "",
         "@Module",
         "final class TestModule<A> {}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT)
-        .in(moduleFile)
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT)
+        .inFile(moduleFile)
         .onLine(6);
   }
 
@@ -226,11 +226,10 @@ public void providesMethodReturnsProduced() {
         "",
         "@Module(includes = Void.class)",
         "class TestModule {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(module))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(module);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED, "java.lang.Void", "@Module"));
   }
@@ -692,12 +691,16 @@ public void providesMethodReturnsProduced() {
         "    return \"\";",
         "  }",
         "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-    .withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME)).in(moduleFile).onLine(8)
-        .and().withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME))
-        .in(moduleFile).onLine(12);
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME))
+        .inFile(moduleFile)
+        .onLine(8);
+    assertThat(compilation)
+        .hadErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME))
+        .inFile(moduleFile)
+        .onLine(12);
   }
 
   @Test
@@ -720,16 +723,15 @@ public void providesMethodThrowsChecked() {
             "    return \"\";",
             "  }",
             "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))
-        .in(moduleFile)
-        .onLine(8)
-        .and()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))
-        .in(moduleFile)
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))
+        .inFile(moduleFile)
+        .onLine(8);
+    assertThat(compilation)
+        .hadErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))
+        .inFile(moduleFile)
         .onLine(12);
   }
 
@@ -769,9 +771,8 @@ public void providedTypes() {
         "    return null;",
         "  }",
         "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).succeeded();
   }
 
   @Test
@@ -785,12 +786,12 @@ public void privateModule() {
         "  @Module private static final class PrivateModule {",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Modules cannot be private.")
-        .in(moduleFile).onLine(6);
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Modules cannot be private.")
+        .inFile(moduleFile)
+        .onLine(6);
   }
 
   @Test
@@ -806,12 +807,12 @@ public void enclosedInPrivateModule() {
         "    }",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Modules cannot be enclosed in private types.")
-        .in(moduleFile).onLine(7);
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Modules cannot be enclosed in private types.")
+        .inFile(moduleFile)
+        .onLine(7);
   }
 
   @Test
@@ -850,16 +851,22 @@ public void publicModuleNonPublicIncludes() {
         "@Module",
         "public final class OtherPublicModule {",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(
-            publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("This module is public, but it includes non-public "
-            + "(or effectively non-public) modules. "
-            + "Either reduce the visibility of this module or make "
-            + "test.NonPublicModule1 and test.NonPublicModule2 public.")
-        .in(publicModuleFile).onLine(8);
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                publicModuleFile,
+                nonPublicModule1File,
+                nonPublicModule2File,
+                otherPublicModuleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "This module is public, but it includes non-public "
+                + "(or effectively non-public) modules. "
+                + "Either reduce the visibility of this module or make "
+                + "test.NonPublicModule1 and test.NonPublicModule2 public.")
+        .inFile(publicModuleFile)
+        .onLine(8);
   }
 
   @Test
@@ -1309,10 +1316,9 @@ public void genericSubclassedModule() {
         "    return \"foo\";",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(BINDING_METHOD_MULTIPLE_QUALIFIERS);
+    Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(BINDING_METHOD_MULTIPLE_QUALIFIERS);
   }
 
   @Test public void providerDependsOnProduced() {
@@ -1329,10 +1335,10 @@ public void genericSubclassedModule() {
         "    return \"foo\";",
         "  }",
         "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Producer may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Producer may only be injected in @Produces methods");
   }
 
   @Test public void providerDependsOnProducer() {
@@ -1349,10 +1355,10 @@ public void genericSubclassedModule() {
         "    return \"foo\";",
         "  }",
         "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Produced may only be injected in @Produces methods");
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Produced may only be injected in @Produces methods");
   }
 
   private static final String BINDS_METHOD = "@Binds abstract Foo bindFoo(FooImpl impl);";
@@ -1364,25 +1370,47 @@ public void genericSubclassedModule() {
   private static final String SOME_ABSTRACT_METHOD = "abstract void blah();";
 
   @Test
-  public void moduleMethodPermutations() {
-    assertThatMethodCombination(BINDS_METHOD, INSTANCE_PROVIDES_METHOD)
-        .failsToCompile()
-        .withErrorContaining(
+  public void bindsWithInstanceProvides() {
+    Compilation compilation = compileMethodCombination(BINDS_METHOD, INSTANCE_PROVIDES_METHOD);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "A @Module may not contain both non-static @Provides methods and "
                 + "abstract @Binds or @Multibinds declarations");
-    assertThatMethodCombination(MULTIBINDS_METHOD, INSTANCE_PROVIDES_METHOD)
-        .failsToCompile()
-        .withErrorContaining(
+  }
+
+  @Test
+  public void multibindsWithInstanceProvides() {
+    Compilation compilation = compileMethodCombination(MULTIBINDS_METHOD, INSTANCE_PROVIDES_METHOD);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "A @Module may not contain both non-static @Provides methods and "
                 + "abstract @Binds or @Multibinds declarations");
-    assertThatMethodCombination(BINDS_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
-    assertThatMethodCombination(BINDS_METHOD, MULTIBINDS_METHOD).compilesWithoutError();
-    assertThatMethodCombination(MULTIBINDS_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
-    assertThatMethodCombination(INSTANCE_PROVIDES_METHOD, SOME_ABSTRACT_METHOD)
-        .compilesWithoutError();
   }
 
-  private CompileTester assertThatMethodCombination(String... methodLines) {
+  @Test
+  public void bindsWithStaticProvides() {
+    assertThat(compileMethodCombination(BINDS_METHOD, STATIC_PROVIDES_METHOD)).succeeded();
+  }
+
+  @Test
+  public void bindsWithMultibinds() {
+    assertThat(compileMethodCombination(BINDS_METHOD, MULTIBINDS_METHOD)).succeeded();
+  }
+
+  @Test
+  public void multibindsWithStaticProvides() {
+    assertThat(compileMethodCombination(MULTIBINDS_METHOD, STATIC_PROVIDES_METHOD)).succeeded();
+  }
+
+  @Test
+  public void instanceProvidesWithAbstractMethod() {
+    assertThat(compileMethodCombination(INSTANCE_PROVIDES_METHOD, SOME_ABSTRACT_METHOD))
+        .succeeded();
+  }
+
+  private Compilation compileMethodCombination(String... methodLines) {
     JavaFileObject fooFile =
         JavaFileObjects.forSourceLines(
             "test.Foo",
@@ -1430,8 +1458,8 @@ private CompileTester assertThatMethodCombination(String... methodLines) {
 
     JavaFileObject bindsMethodAndInstanceProvidesMethodModuleFile =
         JavaFileObjects.forSourceLines("test.TestModule", moduleLines);
-    return assertThat(
-            fooFile, fooImplFile, barFile, bazFile, bindsMethodAndInstanceProvidesMethodModuleFile)
-        .processedWith(new ComponentProcessor());
+    return daggerCompiler()
+        .compile(
+            fooFile, fooImplFile, barFile, bazFile, bindsMethodAndInstanceProvidesMethodModuleFile);
   }
 }
diff --git a/javatests/dagger/internal/codegen/ModuleValidatorTest.java b/javatests/dagger/internal/codegen/ModuleValidatorTest.java
index ea45f41ac..1c605bb5c 100644
--- a/javatests/dagger/internal/codegen/ModuleValidatorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleValidatorTest.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
 
@@ -85,12 +84,12 @@ public void moduleSubcomponents_notASubcomponent() {
     JavaFileObject notASubcomponent =
         JavaFileObjects.forSourceLines(
             "test.NotASubcomponent", "package test;", "", "class NotASubcomponent {}");
-    assertThat(module, notASubcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(module, notASubcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.NotASubcomponent is not a @Subcomponent or @ProductionSubcomponent")
-        .in(module)
+        .inFile(module)
         .onLine(5);
   }
 
@@ -119,12 +118,12 @@ public void moduleSubcomponents_listsSubcomponentBuilder() {
             "    Sub build();",
             "  }",
             "}");
-    assertThat(module, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(module, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.Sub.Builder is a @Subcomponent.Builder. Did you mean to use test.Sub?")
-        .in(module)
+        .inFile(module)
         .onLine(5);
   }
 
@@ -153,12 +152,12 @@ public void moduleSubcomponents_listsProductionSubcomponentBuilder() {
             "    Sub build();",
             "  }",
             "}");
-    assertThat(module, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(module, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.Sub.Builder is a @ProductionSubcomponent.Builder. Did you mean to use test.Sub?")
-        .in(module)
+        .inFile(module)
         .onLine(5);
   }
 
@@ -182,15 +181,15 @@ public void moduleSubcomponents_noSubcomponentBuilder() {
             "",
             "@Subcomponent",
             "interface NoBuilder {}");
-    assertThat(module, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(module, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.NoBuilder doesn't have a @Subcomponent.Builder, which is required when used "
                 + "with @"
                 + moduleType.simpleName()
                 + ".subcomponents")
-        .in(module)
+        .inFile(module)
         .onLine(5);
   }
 
@@ -214,15 +213,15 @@ public void moduleSubcomponents_noProductionSubcomponentBuilder() {
             "",
             "@ProductionSubcomponent",
             "interface NoBuilder {}");
-    assertThat(module, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(module, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.NoBuilder doesn't have a @ProductionSubcomponent.Builder, which is required "
                 + "when used with @"
                 + moduleType.simpleName()
                 + ".subcomponents")
-        .in(module)
+        .inFile(module)
         .onLine(5);
   }
 
@@ -237,11 +236,11 @@ public void moduleSubcomponentsAreTypes() {
             "",
             "@Module(subcomponents = int.class)",
             "class TestModule {}");
-    assertThat(module)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("int is not a valid subcomponent type")
-        .in(module)
+    Compilation compilation = daggerCompiler().compile(module);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("int is not a valid subcomponent type")
+        .inFile(module)
         .onLine(5);
   }
 
diff --git a/javatests/dagger/internal/codegen/MultibindingTest.java b/javatests/dagger/internal/codegen/MultibindingTest.java
index 29063c22c..a2d38b928 100644
--- a/javatests/dagger/internal/codegen/MultibindingTest.java
+++ b/javatests/dagger/internal/codegen/MultibindingTest.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 
 import com.google.testing.compile.Compilation;
@@ -49,12 +48,12 @@ public void providesWithTwoMultibindingAnnotations_failsToCompile() {
             "  }",
             "}");
 
-    assertThat(module)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(module);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "Multiple multibinding annotations cannot be placed on the same Provides method")
-        .in(module)
+        .inFile(module)
         .onLine(10);
   }
 
@@ -78,22 +77,22 @@ public void appliedOnInvalidMethods_failsToCompile() {
             "  @IntoMap Map<Integer, Double> map();",
             "}");
 
-    assertThat(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
-        .in(component)
-        .onLine(11)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(11);
+    assertThat(compilation)
+        .hadErrorContaining(
             "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
-        .in(component)
-        .onLine(12)
-        .and()
-        .withErrorContaining(
+        .inFile(component)
+        .onLine(12);
+    assertThat(compilation)
+        .hadErrorContaining(
             "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
-        .in(component)
+        .inFile(component)
         .onLine(13);
   }
 
diff --git a/javatests/dagger/internal/codegen/MultipleRequestTest.java b/javatests/dagger/internal/codegen/MultipleRequestTest.java
index 3dfd29566..a5514caf7 100644
--- a/javatests/dagger/internal/codegen/MultipleRequestTest.java
+++ b/javatests/dagger/internal/codegen/MultipleRequestTest.java
@@ -16,10 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
-import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -38,9 +38,9 @@
       "}");
 
   @Test public void multipleRequests_constructor() {
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
                 DEP_FILE,
                 JavaFileObjects.forSourceLines(
                     "test.ConstructorInjectsMultiple",
@@ -60,15 +60,14 @@
                     "@Component",
                     "interface SimpleComponent {",
                     "  ConstructorInjectsMultiple get();",
-                    "}")))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+                    "}"));
+    assertThat(compilation).succeeded();
   }
 
   @Test public void multipleRequests_field() {
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
                 DEP_FILE,
                 JavaFileObjects.forSourceLines(
                     "test.FieldInjectsMultiple",
@@ -90,15 +89,14 @@
                     "@Component",
                     "interface SimpleComponent {",
                     "  FieldInjectsMultiple get();",
-                    "}")))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+                    "}"));
+    assertThat(compilation).succeeded();
   }
 
   @Test public void multipleRequests_providesMethod() {
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
                 DEP_FILE,
                 JavaFileObjects.forSourceLines(
                     "test.FieldInjectsMultiple",
@@ -122,8 +120,7 @@
                     "@Component(modules = SimpleModule.class)",
                     "interface SimpleComponent {",
                     "  Object get();",
-                    "}")))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+                    "}"));
+    assertThat(compilation).succeeded();
   }
 }
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 578d7fec7..bbbb9c5f1 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -18,8 +18,9 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatProductionModuleMethod;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
@@ -38,8 +39,8 @@
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.inject.Qualifier;
 import javax.tools.JavaFileObject;
@@ -185,11 +186,10 @@ public void producesProduced() {
         "  }",
         "}");
     String errorMessage = String.format(BINDING_METHOD_WITH_SAME_NAME, "Produces");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage).in(moduleFile).onLine(8)
-        .and().withErrorContaining(errorMessage).in(moduleFile).onLine(12);
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(errorMessage).inFile(moduleFile).onLine(8);
+    assertThat(compilation).hadErrorContaining(errorMessage).inFile(moduleFile).onLine(12);
   }
 
   @Test
@@ -216,12 +216,12 @@ public void privateModule() {
         "  @ProducerModule private static final class PrivateModule {",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Modules cannot be private.")
-        .in(moduleFile).onLine(6);
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Modules cannot be private.")
+        .inFile(moduleFile)
+        .onLine(6);
   }
 
   @Test
@@ -237,12 +237,12 @@ public void enclosedInPrivateModule() {
         "    }",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Modules cannot be enclosed in private types.")
-        .in(moduleFile).onLine(7);
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Modules cannot be enclosed in private types.")
+        .inFile(moduleFile)
+        .onLine(7);
   }
 
   @Test
@@ -259,11 +259,10 @@ public void includesNonModule() {
             "@ProducerModule(includes = X.class)",
             "public final class FooModule {",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(xFile, moduleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(xFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
                 "X",
@@ -306,16 +305,22 @@ public void publicModuleNonPublicIncludes() {
         "@ProducerModule",
         "public final class OtherPublicModule {",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(
-            publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("This module is public, but it includes non-public "
-            + "(or effectively non-public) modules. "
-            + "Either reduce the visibility of this module or make "
-            + "test.NonPublicModule1 and test.NonPublicModule2 public.")
-        .in(publicModuleFile).onLine(8);
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                publicModuleFile,
+                nonPublicModule1File,
+                nonPublicModule2File,
+                otherPublicModuleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "This module is public, but it includes non-public "
+                + "(or effectively non-public) modules. "
+                + "Either reduce the visibility of this module or make "
+                + "test.NonPublicModule1 and test.NonPublicModule2 public.")
+        .inFile(publicModuleFile)
+        .onLine(8);
   }
 
   @Test public void argumentNamedModuleCompiles() {
@@ -331,10 +336,8 @@ public void publicModuleNonPublicIncludes() {
         "    return null;",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation = daggerCompiler().compile(moduleFile);
+    assertThat(compilation).succeeded();
   }
 
   @Test public void singleProducesMethodNoArgsFuture() {
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index fad441e49..b7fa898ca 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -17,12 +17,13 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
-import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
@@ -52,10 +53,9 @@ public ProductionComponentProcessorTest(CompilerMode compilerMode) {
         "",
         "@ProductionComponent",
         "final class NotAComponent {}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
   }
 
   @Test public void componentOnEnum() {
@@ -68,12 +68,10 @@ public ProductionComponentProcessorTest(CompilerMode compilerMode) {
         "enum NotAComponent {",
         "  INSTANCE",
         "}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
   }
 
   @Test public void componentOnAnnotation() {
@@ -84,12 +82,10 @@ public ProductionComponentProcessorTest(CompilerMode compilerMode) {
         "",
         "@ProductionComponent",
         "@interface NotAComponent {}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
   }
 
   @Test public void nonModuleModule() {
@@ -100,12 +96,11 @@ public ProductionComponentProcessorTest(CompilerMode compilerMode) {
         "",
         "@ProductionComponent(modules = Object.class)",
         "interface NotAComponent {}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("is not annotated with one of @Module, @ProducerModule");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("is not annotated with one of @Module, @ProducerModule");
   }
 
   @Test
@@ -161,12 +156,12 @@ public void dependsOnProductionExecutor() {
             "    SimpleComponent build();",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("may not depend on the production executor");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(moduleFile, producerModuleFile, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("may not depend on the production executor");
   }
 
   @Test
@@ -576,17 +571,16 @@ public void simpleComponent() {
         "    ListenableFuture<A> a();",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(component)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .withWarningContaining("@Nullable on @Produces methods does not do anything")
-        .in(component)
-        .onLine(33)
-        .and()
-        .withWarningContaining("@Nullable on @Produces methods does not do anything")
-        .in(component)
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining("@Nullable on @Produces methods does not do anything")
+        .inFile(component)
+        .onLine(33);
+    assertThat(compilation)
+        .hadWarningContaining("@Nullable on @Produces methods does not do anything")
+        .inFile(component)
         .onLine(36);
   }
 }
diff --git a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
index f3fe3bf45..32f984b81 100644
--- a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -16,12 +16,9 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 
-import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -78,14 +75,13 @@
         "    return null;",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(EXECUTOR_MODULE, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.Bar cannot be provided without an @Inject constructor or an @Provides- or "
                 + "@Produces-annotated method.")
-        .in(component)
+        .inFile(component)
         .onLine(8);
   }
 
@@ -106,10 +102,9 @@
         "}");
     String expectedError =
         "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated method.";
-    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(11);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(11);
   }
 
   @Test public void provisionDependsOnProduction() {
@@ -148,10 +143,9 @@
         "}");
     String expectedError =
         "test.TestClass.A is a provision, which cannot depend on a production.";
-    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(30);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(30);
   }
 
   @Test public void provisionEntryPointDependsOnProduction() {
@@ -182,10 +176,9 @@
             "}");
     String expectedError =
         "test.TestClass.A is a provision entry-point, which cannot depend on a production.";
-    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(20);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(20);
   }
 
   @Test
@@ -238,12 +231,11 @@ public void providingMultibindingWithProductions() {
             "    ListenableFuture<B> b();",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(EXECUTOR_MODULE, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("test.TestClass.A is a provision, which cannot depend on a production")
-        .in(component)
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.TestClass.A is a provision, which cannot depend on a production")
+        .inFile(component)
         .onLine(43);
   }
 
@@ -290,12 +282,9 @@ public void monitoringDependsOnUnboundType() {
             "}");
     String expectedError =
         "test.TestClass.A cannot be provided without an @Provides-annotated method.";
-    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(34);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(34);
   }
 
   @Test
@@ -346,12 +335,9 @@ public void monitoringDependsOnProduction() {
         "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory>"
             + " test.TestClass.MonitoringModule#monitorFactory is a provision,"
             + " which cannot depend on a production.";
-    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(37);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(37);
   }
 
   @Test
@@ -390,13 +376,9 @@ public void cycleNotBrokenByMap() {
             "    return string;",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(EXECUTOR_MODULE, component, module))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("cycle")
-        .in(component)
-        .onLine(8);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component, module);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("cycle").inFile(component).onLine(8);
   }
 
   @Test
@@ -436,13 +418,9 @@ public void cycleNotBrokenByProducerMap() {
             "    return string;",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(EXECUTOR_MODULE, component, module))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("cycle")
-        .in(component)
-        .onLine(8);
+    Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component, module);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("cycle").inFile(component).onLine(8);
   }
   
   @Test
diff --git a/javatests/dagger/internal/codegen/RepeatedModuleValidationTest.java b/javatests/dagger/internal/codegen/RepeatedModuleValidationTest.java
index 4fc74d811..60a9bd516 100644
--- a/javatests/dagger/internal/codegen/RepeatedModuleValidationTest.java
+++ b/javatests/dagger/internal/codegen/RepeatedModuleValidationTest.java
@@ -16,10 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
-import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -61,12 +61,12 @@ public void moduleRepeatedInSubcomponentFactoryMethod() {
             "interface TestComponent {",
             "  TestSubcomponent newTestSubcomponent(TestModule module);",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("TestModule is present in test.TestComponent.")
-        .in(componentFile)
+    Compilation compilation =
+        daggerCompiler().compile(MODULE_FILE, subcomponentFile, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("TestModule is present in test.TestComponent.")
+        .inFile(componentFile)
         .onLine(7)
         .atColumn(51);
   }
@@ -99,10 +99,9 @@ public void moduleRepeatedInSubcomponentBuilderMethod() {
             "interface TestComponent {",
             "  TestSubcomponent.Builder newTestSubcomponentBuilder();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation =
+        daggerCompiler().compile(MODULE_FILE, subcomponentFile, componentFile);
+    assertThat(compilation).succeeded();
     // TODO(gak): assert about the warning when we have that ability
   }
 
@@ -129,9 +128,8 @@ public void moduleRepeatedButNotPassed() {
             "interface TestComponent {",
             "  TestSubcomponent newTestSubcomponent();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
+    Compilation compilation =
+        daggerCompiler().compile(MODULE_FILE, subcomponentFile, componentFile);
+    assertThat(compilation).succeeded();
   }
 }
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index 1351702e0..a829ec3d5 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -16,14 +16,10 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 
 import com.google.common.base.Joiner;
-import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -63,12 +59,13 @@ public void testRefSubcomponentAndSubBuilderFails() {
         "    ChildComponent build();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
-            "test.ChildComponent", "[child(), builder()]"))
-        .in(componentFile);
+    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                MSGS.moreThanOneRefToSubcomponent(), "test.ChildComponent", "[child(), builder()]"))
+        .inFile(componentFile);
   }
 
   @Test
@@ -96,12 +93,15 @@ public void testRefSubBuilderTwiceFails() {
         "    ChildComponent build();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
-            "test.ChildComponent", "[builder1(), builder2()]"))
-        .in(componentFile);
+    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                MSGS.moreThanOneRefToSubcomponent(),
+                "test.ChildComponent",
+                "[builder1(), builder2()]"))
+        .inFile(componentFile);
   }
 
   @Test
@@ -133,12 +133,13 @@ public void testMoreThanOneBuilderFails() {
         "    ChildComponent build();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.moreThanOne(),
-            "[test.ChildComponent.Builder1, test.ChildComponent.Builder2]"))
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                MSGS.moreThanOne(), "[test.ChildComponent.Builder1, test.ChildComponent.Builder2]"))
+        .inFile(childComponentFile);
   }
 
   @Test
@@ -165,11 +166,9 @@ public void testBuilderGenericsFails() {
         "     ChildComponent build();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.generics())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.generics()).inFile(childComponentFile);
   }
 
   @Test
@@ -181,11 +180,9 @@ public void testBuilderNotInComponentFails() {
         "",
         "@Subcomponent.Builder",
         "interface Builder {}");
-    assertAbout(javaSource()).that(builder)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeInComponent())
-        .in(builder);
+    Compilation compilation = daggerCompiler().compile(builder);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.mustBeInComponent()).inFile(builder);
   }
 
   @Test
@@ -210,11 +207,11 @@ public void testBuilderMissingBuildMethodFails() {
         "  @Subcomponent.Builder",
         "  interface Builder {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.missingBuildMethod())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.missingBuildMethod())
+        .inFile(childComponentFile);
   }
 
   @Test
@@ -229,11 +226,9 @@ public void testPrivateBuilderFails() {
         "  @Subcomponent.Builder",
         "  private interface Builder {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.isPrivate())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.isPrivate()).inFile(childComponentFile);
   }
 
   @Test
@@ -248,11 +243,9 @@ public void testNonStaticBuilderFails() {
         "  @Subcomponent.Builder",
         "  abstract class Builder {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeStatic())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.mustBeStatic()).inFile(childComponentFile);
   }
 
   @Test
@@ -267,11 +260,9 @@ public void testNonAbstractBuilderFails() {
         "  @Subcomponent.Builder",
         "  static class Builder {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeAbstract())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining(MSGS.mustBeAbstract()).inFile(childComponentFile);
   }
 
   @Test
@@ -288,11 +279,11 @@ public void testBuilderOneCxtorWithArgsFails() {
         "    Builder(String unused) {}",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .inFile(childComponentFile);
   }
 
   @Test
@@ -310,11 +301,11 @@ public void testBuilderMoreThanOneCxtorFails() {
         "    Builder(String unused) {}",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .inFile(childComponentFile);
   }
 
   @Test
@@ -329,11 +320,11 @@ public void testBuilderEnumFails() {
         "  @Subcomponent.Builder",
         "  enum Builder {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeClassOrInterface())
-        .in(childComponentFile);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.mustBeClassOrInterface())
+        .inFile(childComponentFile);
   }
 
   @Test
@@ -350,11 +341,12 @@ public void testBuilderBuildReturnsWrongTypeFails() {
         "    String build();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.buildMustReturnComponentType())
-            .in(childComponentFile).onLine(9);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.buildMustReturnComponentType())
+        .inFile(childComponentFile)
+        .onLine(9);
   }
 
   @Test
@@ -373,12 +365,12 @@ public void testInheritedBuilderBuildReturnsWrongTypeFails() {
         "  @Subcomponent.Builder",
         "  interface Builder extends Parent {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
-            .in(childComponentFile).onLine(12);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+        .inFile(childComponentFile)
+        .onLine(12);
   }
 
   @Test
@@ -396,11 +388,12 @@ public void testTwoBuildMethodsFails() {
         "    ChildComponent create();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
-            .in(childComponentFile).onLine(10);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
+        .inFile(childComponentFile)
+        .onLine(10);
   }
 
   @Test
@@ -420,12 +413,12 @@ public void testInheritedTwoBuildMethodsFails() {
         "  @Subcomponent.Builder",
         "  interface Builder extends Parent {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
-            .in(childComponentFile).onLine(13);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
+        .inFile(childComponentFile)
+        .onLine(13);
   }
 
   @Test
@@ -444,13 +437,16 @@ public void testMoreThanOneArgFails() {
         "    Builder set(Number n, Double d);",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(childComponentFile).onLine(10)
-        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(childComponentFile).onLine(11);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.methodsMustTakeOneArg())
+        .inFile(childComponentFile)
+        .onLine(10);
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.methodsMustTakeOneArg())
+        .inFile(childComponentFile)
+        .onLine(11);
   }
 
   @Test
@@ -470,13 +466,14 @@ public void testInheritedMoreThanOneArgFails() {
         "  @Subcomponent.Builder",
         "  interface Builder extends Parent {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
-                "set1(java.lang.String,java.lang.Integer)"))
-            .in(childComponentFile).onLine(13);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                MSGS.inheritedMethodsMustTakeOneArg(), "set1(java.lang.String,java.lang.Integer)"))
+        .inFile(childComponentFile)
+        .onLine(13);
   }
 
   @Test
@@ -494,11 +491,12 @@ public void testSetterReturningNonVoidOrBuilderFails() {
         "    String set(Integer i);",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
-            .in(childComponentFile).onLine(10);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
+        .inFile(childComponentFile)
+        .onLine(10);
   }
 
   @Test
@@ -518,13 +516,13 @@ public void testInheritedSetterReturningNonVoidOrBuilderFails() {
         "  @Subcomponent.Builder",
         "  interface Builder extends Parent {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
-                "set(java.lang.Integer)"))
-            .in(childComponentFile).onLine(13);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(), "set(java.lang.Integer)"))
+        .inFile(childComponentFile)
+        .onLine(13);
   }
 
   @Test
@@ -542,11 +540,12 @@ public void testGenericsOnSetterMethodFails() {
         "    <T> Builder set(T t);",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
-            .in(childComponentFile).onLine(10);
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
+        .inFile(childComponentFile)
+        .onLine(10);
   }
 
   @Test
@@ -566,12 +565,13 @@ public void testGenericsOnInheritedSetterMethodFails() {
         "  @Subcomponent.Builder",
         "  interface Builder extends Parent {}",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
-            .in(childComponentFile).onLine(13);
+        .inFile(childComponentFile)
+        .onLine(13);
   }
 
   @Test
@@ -617,16 +617,16 @@ public void testMultipleSettersPerTypeFails() {
             "    void set2(TestModule s);",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().compile(moduleFile, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 MSGS.manyMethodsForType(),
                 "test.TestModule",
                 "[set1(test.TestModule), set2(test.TestModule)]"))
-        .in(childComponentFile)
+        .inFile(childComponentFile)
         .onLine(10);
   }
 
@@ -676,14 +676,14 @@ public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
             "    void set2(TestModule s);",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler().compile(moduleFile, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             String.format(
                 MSGS.manyMethodsForType(), "test.TestModule", "[set1(T), set2(test.TestModule)]"))
-        .in(childComponentFile)
+        .inFile(childComponentFile)
         .onLine(14);
   }
 
@@ -758,14 +758,16 @@ public void testExtraSettersFails() {
         "    void set2(Integer s);",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.extraSetters(),
-                  "[void test.ChildComponent.Builder.set1(String),"
-                  + " void test.ChildComponent.Builder.set2(Integer)]"))
-            .in(childComponentFile).onLine(8);
+    Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                MSGS.extraSetters(),
+                "[void test.ChildComponent.Builder.set1(String),"
+                    + " void test.ChildComponent.Builder.set2(Integer)]"))
+        .inFile(childComponentFile)
+        .onLine(8);
   }
 
   @Test
@@ -827,19 +829,17 @@ public void testMissingSettersFail() {
         "    ChildComponent create();",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile,
-            module2File,
-            module3File,
-            componentFile,
-            childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .compile(moduleFile, module2File, module3File, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             // Ignores Test2Module because we can construct it ourselves.
             // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
             String.format(MSGS.missingSetters(), "[test.TestModule, test.Test3Module]"))
-            .in(childComponentFile).onLine(11);
+        .inFile(childComponentFile)
+        .onLine(11);
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index e8def7a4c..5e02bd637 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -16,17 +16,13 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
 import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
-import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Collection;
@@ -86,16 +82,17 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "    return object;",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(componentFile, childComponentFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.ChildComponent requires modules which have no visible default constructors. "
                 + "Add the following modules as parameters to this method: "
                 + "test.ModuleWithParameters")
-        .in(componentFile)
+        .inFile(componentFile)
         .onLine(7);
   }
 
@@ -116,14 +113,15 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "",
         "@Subcomponent",
         "interface ChildComponent {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(componentFile, childComponentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "Subcomponent factory methods may only accept modules, but java.lang.String is not.")
-        .in(componentFile)
+        .inFile(componentFile)
         .onLine(7)
         .atColumn(43);
   }
@@ -152,15 +150,16 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "",
         "@Subcomponent(modules = TestModule.class)",
         "interface ChildComponent {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(moduleFile, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "A module may only occur once an an argument in a Subcomponent factory method, "
                 + "but test.TestModule was already passed.")
-        .in(componentFile)
+        .inFile(componentFile)
         .onLine(7)
         .atColumn(71);
   }
@@ -189,15 +188,16 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "",
         "@Subcomponent",
         "interface ChildComponent {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(moduleFile, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.TestModule is present as an argument to the test.ChildComponent factory method, "
                 + "but is not one of the modules used to implement the subcomponent.")
-        .in(componentFile)
+        .inFile(componentFile)
         .onLine(7);
   }
 
@@ -232,16 +232,17 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "interface ChildComponent {",
         "  String getString();",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(moduleFile, componentFile, childComponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "[test.ChildComponent.getString()] "
                 + "java.lang.Integer cannot be provided without an @Inject constructor or an "
                 + "@Provides-annotated method")
-        .in(componentFile)
+        .inFile(componentFile)
         .onLine(6);
   }
 
@@ -253,12 +254,10 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "",
         "@Subcomponent",
         "final class NotASubcomponent {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(subcomponentFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(subcomponentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
   }
 
   @Test public void scopeMismatch() {
@@ -293,12 +292,12 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         "final class ChildModule {",
         "  @Provides @Singleton Object provideObject() { return null; }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(componentFile, subcomponentFile, moduleFile))
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Singleton");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(componentFile, subcomponentFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("@Singleton");
   }
 
   @Test
@@ -1033,15 +1032,17 @@ public void duplicateBindingWithSubcomponentDeclaration() {
             "  Object dependsOnBuilder();",
             "}");
 
-    assertThat(module, component, subcomponent)
-        .withCompilerOptions(compilerMode.javacopts())
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("test.Sub.Builder is bound multiple times:")
-        .and()
-        .withErrorContaining(
-            "@Provides test.Sub.Builder test.TestModule.providesConflictsWithModuleSubcomponents()")
-        .and()
-        .withErrorContaining("@Module(subcomponents = test.Sub.class) for test.TestModule");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(module, component, subcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("test.Sub.Builder is bound multiple times:");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@Provides test.Sub.Builder "
+                + "test.TestModule.providesConflictsWithModuleSubcomponents()");
+    assertThat(compilation)
+        .hadErrorContaining("@Module(subcomponents = test.Sub.class) for test.TestModule");
   }
 }
diff --git a/javatests/dagger/internal/codegen/ValidationReportTest.java b/javatests/dagger/internal/codegen/ValidationReportTest.java
index 2ca4ce75f..b0f2f2fe1 100644
--- a/javatests/dagger/internal/codegen/ValidationReportTest.java
+++ b/javatests/dagger/internal/codegen/ValidationReportTest.java
@@ -16,11 +16,12 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.truth.Truth.assertAbout;
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
 
 import com.google.common.collect.ImmutableSet;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import dagger.internal.codegen.ValidationReport.Builder;
 import java.util.Set;
@@ -42,67 +43,67 @@
 
   @Test
   public void basicReport() {
-    assertAbout(javaSource())
-        .that(TEST_CLASS_FILE)
-        .processedWith(
-            new SimpleTestProcessor() {
-              @Override
-              void test() {
-                Builder<TypeElement> reportBuilder =
-                    ValidationReport.about(getTypeElement("test.TestClass"));
-                reportBuilder.addError("simple error");
-                reportBuilder.build().printMessagesTo(processingEnv.getMessager());
-              }
-            })
-        .failsToCompile()
-        .withErrorContaining("simple error")
-        .in(TEST_CLASS_FILE)
-        .onLine(3);
+    Compilation compilation =
+        javac()
+            .withProcessors(
+                new SimpleTestProcessor() {
+                  @Override
+                  void test() {
+                    Builder<TypeElement> reportBuilder =
+                        ValidationReport.about(getTypeElement("test.TestClass"));
+                    reportBuilder.addError("simple error");
+                    reportBuilder.build().printMessagesTo(processingEnv.getMessager());
+                  }
+                })
+            .compile(TEST_CLASS_FILE);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("simple error").inFile(TEST_CLASS_FILE).onLine(3);
   }
 
   @Test
   public void messageOnDifferentElement() {
-    assertAbout(javaSource())
-        .that(TEST_CLASS_FILE)
-        .processedWith(
-            new SimpleTestProcessor() {
-              @Override
-              void test() {
-                Builder<TypeElement> reportBuilder =
-                    ValidationReport.about(getTypeElement("test.TestClass"));
-                reportBuilder.addError("simple error", getTypeElement(String.class));
-                reportBuilder.build().printMessagesTo(processingEnv.getMessager());
-              }
-            })
-        .failsToCompile()
-        .withErrorContaining("[java.lang.String] simple error")
-        .in(TEST_CLASS_FILE)
+    Compilation compilation =
+        javac()
+            .withProcessors(
+                new SimpleTestProcessor() {
+                  @Override
+                  void test() {
+                    Builder<TypeElement> reportBuilder =
+                        ValidationReport.about(getTypeElement("test.TestClass"));
+                    reportBuilder.addError("simple error", getTypeElement(String.class));
+                    reportBuilder.build().printMessagesTo(processingEnv.getMessager());
+                  }
+                })
+            .compile(TEST_CLASS_FILE);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("[java.lang.String] simple error")
+        .inFile(TEST_CLASS_FILE)
         .onLine(3);
   }
 
   @Test
   public void subreport() {
-    assertAbout(javaSource())
-        .that(TEST_CLASS_FILE)
-        .processedWith(
-            new SimpleTestProcessor() {
-              @Override
-              void test() {
-                Builder<TypeElement> reportBuilder =
-                    ValidationReport.about(getTypeElement("test.TestClass"));
-                reportBuilder.addError("simple error");
-                ValidationReport<TypeElement> parentReport =
-                    ValidationReport.about(getTypeElement(String.class))
-                        .addSubreport(reportBuilder.build())
-                        .build();
-                assertThat(parentReport.isClean()).isFalse();
-                parentReport.printMessagesTo(processingEnv.getMessager());
-              }
-            })
-        .failsToCompile()
-        .withErrorContaining("simple error")
-        .in(TEST_CLASS_FILE)
-        .onLine(3);
+    Compilation compilation =
+        javac()
+            .withProcessors(
+                new SimpleTestProcessor() {
+                  @Override
+                  void test() {
+                    Builder<TypeElement> reportBuilder =
+                        ValidationReport.about(getTypeElement("test.TestClass"));
+                    reportBuilder.addError("simple error");
+                    ValidationReport<TypeElement> parentReport =
+                        ValidationReport.about(getTypeElement(String.class))
+                            .addSubreport(reportBuilder.build())
+                            .build();
+                    assertThat(parentReport.isClean()).isFalse();
+                    parentReport.printMessagesTo(processingEnv.getMessager());
+                  }
+                })
+            .compile(TEST_CLASS_FILE);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("simple error").inFile(TEST_CLASS_FILE).onLine(3);
   }
 
   private static abstract class SimpleTestProcessor extends AbstractProcessor {
