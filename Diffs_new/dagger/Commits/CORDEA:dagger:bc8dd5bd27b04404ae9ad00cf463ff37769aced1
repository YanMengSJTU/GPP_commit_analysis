diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 7c18ddd30..13e51df2a 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -210,7 +210,6 @@ java_library(
         "DependsOnProductionExecutorValidator.java",
         "DuplicateBindingsValidator.java",
         "IncompatiblyScopedBindingsValidator.java",
-        "IncorrectlyInstalledBindsMethodsValidator.java",
         "InjectBindingValidator.java",
         "MapMultibindingValidator.java",
         "MissingBindingValidator.java",
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index b0c55e949..6263e8717 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -46,7 +46,6 @@
 import dagger.MembersInjector;
 import dagger.Reusable;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
-import dagger.model.ComponentPath;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
@@ -77,7 +76,6 @@
   private final InjectBindingRegistry injectBindingRegistry;
   private final KeyFactory keyFactory;
   private final BindingFactory bindingFactory;
-  private final IncorrectlyInstalledBindsMethodsValidator incorrectlyInstalledBindsMethodsValidator;
   private final CompilerOptions compilerOptions;
 
   @Inject
@@ -86,13 +84,11 @@
       InjectBindingRegistry injectBindingRegistry,
       KeyFactory keyFactory,
       BindingFactory bindingFactory,
-      IncorrectlyInstalledBindsMethodsValidator incorrectlyInstalledBindsMethodsValidator,
       CompilerOptions compilerOptions) {
     this.elements = elements;
     this.injectBindingRegistry = injectBindingRegistry;
     this.keyFactory = keyFactory;
     this.bindingFactory = bindingFactory;
-    this.incorrectlyInstalledBindsMethodsValidator = incorrectlyInstalledBindsMethodsValidator;
     this.compilerOptions = compilerOptions;
   }
 
@@ -573,72 +569,18 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
 
     private boolean containsExplicitBinding(ContributionBinding binding) {
       return explicitBindingsSet.contains(binding)
-          || resolverContainsDelegateDeclarationForBinding(this, binding)
+          || resolverContainsDelegateDeclarationForBinding(binding)
           || subcomponentDeclarations.containsKey(binding.key());
     }
 
-    /**
-     * Returns true if {@code binding} was installed in a module in this resolver's component. If
-     * {@link CompilerOptions#floatingBindsMethods()} is enabled, calls {@link
-     * #recordFloatingBindsMethod(Resolver, ContributionBinding)} and returns false.
-     */
-    private boolean resolverContainsDelegateDeclarationForBinding(
-        Resolver resolver, ContributionBinding binding) {
-      // TODO(ronshapiro): remove the flag once we feel enough time has passed, and return this
-      // value directly. At that point, this can be remove the resolver parameter and become a
-      // method invoked on a particular resolver
-      boolean resolverContainsDeclaration =
-          binding.kind().equals(DELEGATE)
-              && resolver
-                  .delegateDeclarations
-                  .get(binding.key())
-                  .stream()
-                  .anyMatch(
-                      declaration ->
-                          declaration.contributingModule().equals(binding.contributingModule())
-                              && declaration.bindingElement().equals(binding.bindingElement()));
-      if (resolverContainsDeclaration && compilerOptions.floatingBindsMethods()) {
-        recordFloatingBindsMethod(resolver, binding);
-        return false;
-      }
-      return resolverContainsDeclaration;
-    }
-
-    /**
-     * Records binds methods that are resolved in the wrong component due to b/79859714. These will
-     * be reported later on in {@link IncorrectlyInstalledBindsMethodsValidator}.
-     */
-    private void recordFloatingBindsMethod(Resolver idealResolver, ContributionBinding binding) {
-      Resolver actualResolver = this;
-      if (binding.scope().isPresent()) {
-        for (Resolver requestResolver : getResolverLineage().reverse()) {
-          if (requestResolver.componentDescriptor.scopes().contains(binding.scope().get())) {
-            actualResolver = requestResolver;
-            break;
-          }
-        }
-      }
-      if (actualResolver != idealResolver) {
-        incorrectlyInstalledBindsMethodsValidator.recordBinding(
-            componentPath(idealResolver), binding);
-      }
-    }
-
-    /**
-     * Constructs a {@link ComponentPath} from the root component of this resolver to a {@code
-     * destination}.
-     */
-    private ComponentPath componentPath(Resolver destination) {
-      ImmutableList.Builder<TypeElement> path = ImmutableList.builder();
-      for (Resolver resolver : getResolverLineage()) {
-        path.add(resolver.componentDescriptor.typeElement());
-        if (resolver == destination) {
-          return ComponentPath.create(path.build());
-        }
-      }
-      throw new AssertionError(
-          String.format(
-              "%s not found in %s", destination.componentDescriptor.typeElement(), path.build()));
+    /** Returns true if {@code binding} was installed in a module in this resolver's component. */
+    private boolean resolverContainsDelegateDeclarationForBinding(ContributionBinding binding) {
+      return binding.kind().equals(DELEGATE)
+          && delegateDeclarations.get(binding.key()).stream()
+              .anyMatch(
+                  declaration ->
+                      declaration.contributingModule().equals(binding.contributingModule())
+                          && declaration.bindingElement().equals(binding.bindingElement()));
     }
 
     /** Returns the resolver lineage from parent to child. */
diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index ec30de211..926cbd110 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -102,9 +102,6 @@ boolean doCheckForNulls() {
 
   abstract boolean aheadOfTimeSubcomponents();
 
-  /** See b/79859714 */
-  abstract boolean floatingBindsMethods();
-
   abstract boolean useGradleIncrementalProcessing();
 
   static Builder builder() {
@@ -159,8 +156,6 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
 
     Builder aheadOfTimeSubcomponents(boolean aheadOfTimeSubcomponents);
 
-    Builder floatingBindsMethods(boolean enabled);
-
     Builder useGradleIncrementalProcessing(boolean enabled);
 
     @CheckReturnValue
@@ -221,7 +216,18 @@ boolean isEnabled(ProcessingEnvironment processingEnvironment) {
 
     EXPERIMENTAL_AHEAD_OF_TIME_SUBCOMPONENTS(Builder::aheadOfTimeSubcomponents),
 
-    FLOATING_BINDS_METHODS(Builder::floatingBindsMethods),
+    FLOATING_BINDS_METHODS((builder, ignoredValue) -> {}) {
+     @Override
+      public void set(Builder builder, ProcessingEnvironment processingEnvironment) {
+        if (processingEnvironment.getOptions().containsKey(toString())) {
+          processingEnvironment
+            .getMessager()
+            .printMessage(
+                Diagnostic.Kind.WARNING,
+                toString() + " is no longer a recognized option by Dagger");
+        }
+      }
+    },
 
     USE_GRADLE_INCREMENTAL_PROCESSING(Builder::useGradleIncrementalProcessing) {
       @Override
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index b5159a1b2..f02c926e9 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -122,7 +122,6 @@ public SourceVersion getSupportedSourceVersion() {
         BindingGraphPluginsModule.class,
         BindingGraphValidationModule.class,
         BindingMethodValidatorsModule.class,
-        IncorrectlyInstalledBindsMethodsValidator.Module.class,
         ProcessingStepsModule.class,
         SourceFileGeneratorsModule.class,
         SystemComponentsModule.class
diff --git a/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java b/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
deleted file mode 100644
index 3da907b2a..000000000
--- a/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkState;
-import static java.util.stream.Collectors.toCollection;
-import static javax.tools.Diagnostic.Kind.WARNING;
-
-import com.google.common.collect.Iterables;
-import com.google.common.collect.MultimapBuilder;
-import com.google.common.collect.SetMultimap;
-import com.google.common.graph.EndpointPair;
-import com.google.common.graph.Graphs;
-import com.google.common.graph.ImmutableGraph;
-import com.google.common.graph.ImmutableNetwork;
-import com.google.common.graph.MutableNetwork;
-import com.google.common.graph.NetworkBuilder;
-import dagger.Binds;
-import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.DependencyEdge;
-import dagger.model.BindingGraph.Edge;
-import dagger.model.BindingGraph.Node;
-import dagger.model.ComponentPath;
-import dagger.multibindings.IntoSet;
-import dagger.spi.BindingGraphPlugin;
-import dagger.spi.DiagnosticReporter;
-import java.util.LinkedHashSet;
-import java.util.Map.Entry;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-
-/**
- * Prints warnings to help users debug <a
- * href="https://github.com/google/dagger/wiki/Dagger-2.17-@Binds-bugs">the floating {@code @Binds}
- * bug</a>.
- */
-@Singleton
-final class IncorrectlyInstalledBindsMethodsValidator implements BindingGraphPlugin {
-  private final SetMultimap<ComponentPath, ContributionBinding> incorrectlyInstalledBindingsCache =
-      MultimapBuilder.hashKeys().linkedHashSetValues().build();
-  private final CompilerOptions compilerOptions;
-
-  @Inject
-  IncorrectlyInstalledBindsMethodsValidator(CompilerOptions compilerOptions) {
-    this.compilerOptions = compilerOptions;
-  }
-
-  @Override
-  public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
-    checkState(
-        compilerOptions.floatingBindsMethods() || incorrectlyInstalledBindingsCache.isEmpty());
-    for (Entry<ComponentPath, ContributionBinding> entry :
-        incorrectlyInstalledBindingsCache.entries()) {
-      ComponentPath idealComponentPath = entry.getKey();
-      ContributionBinding incorrectlyInstalledBinding = entry.getValue();
-      graph.bindings(incorrectlyInstalledBinding.key()).stream()
-          .filter(binding -> ((BindingNode) binding).delegate().equals(incorrectlyInstalledBinding))
-          .forEach(binding -> report(binding, idealComponentPath, graph, diagnosticReporter));
-    }
-  }
-
-  private void report(
-      dagger.model.Binding incompatiblyInstalledBinding,
-      ComponentPath idealComponentPath,
-      BindingGraph graph,
-      DiagnosticReporter diagnosticReporter) {
-    // TODO(dpb): consider creating this once per visitGraph()
-    ImmutableGraph<Node> dependencyGraph = dependencyGraph(graph).asGraph();
-    Set<Node> culpableDependencies =
-        Graphs.reachableNodes(dependencyGraph, incompatiblyInstalledBinding).stream()
-            .filter(binding -> isChild(idealComponentPath, binding.componentPath()))
-            .filter(binding -> !binding.equals(incompatiblyInstalledBinding))
-            .collect(toCollection(LinkedHashSet::new));
-    if (culpableDependencies.isEmpty()) {
-      return;
-    }
-    StringBuilder warning =
-        new StringBuilder()
-            .append("Floating @Binds method detected:\n  ")
-            .append(incompatiblyInstalledBinding)
-            .append("\n  It is installed in:       ")
-            .append(idealComponentPath)
-            .append("\n  But is being resolved in: ")
-            .append(incompatiblyInstalledBinding.componentPath())
-            .append("\n  This is because it depends transitively on:");
-
-    while (!culpableDependencies.isEmpty()) {
-      dagger.model.Binding culpableDependency =
-          (dagger.model.Binding) Iterables.get(culpableDependencies, 0);
-      warning
-          .append("\n      ")
-          .append(culpableDependency)
-          .append(", resolved in: ")
-          .append(culpableDependency.componentPath());
-      culpableDependencies.removeAll(Graphs.reachableNodes(dependencyGraph, culpableDependency));
-    }
-
-    diagnosticReporter.reportComponent(WARNING, graph.rootComponentNode(), warning.toString());
-  }
-
-  private boolean isChild(ComponentPath possibleParent, ComponentPath possibleChild) {
-    return !possibleParent.equals(possibleChild)
-        && possibleChild.components().containsAll(possibleParent.components());
-  }
-
-  private ImmutableNetwork<Node, Edge> dependencyGraph(BindingGraph graph) {
-    MutableNetwork<Node, Edge> dependencyGraph = NetworkBuilder.from(graph.network()).build();
-    for (DependencyEdge dependencyEdge : graph.dependencyEdges()) {
-      EndpointPair<Node> endpoint = graph.network().incidentNodes(dependencyEdge);
-      dependencyGraph.addEdge(endpoint.source(), endpoint.target(), dependencyEdge);
-    }
-    return ImmutableNetwork.copyOf(dependencyGraph);
-  }
-
-  void recordBinding(ComponentPath componentPath, ContributionBinding binding) {
-    incorrectlyInstalledBindingsCache.put(componentPath, binding);
-  }
-
-  @dagger.Module
-  interface Module {
-    @Binds
-    @IntoSet
-    @Validation
-    BindingGraphPlugin validator(IncorrectlyInstalledBindsMethodsValidator validator);
-  }
-}
diff --git a/java/dagger/internal/codegen/KytheBindingGraphFactory.java b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
index 8332e2499..91c9a4c49 100644
--- a/java/dagger/internal/codegen/KytheBindingGraphFactory.java
+++ b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
@@ -76,7 +76,6 @@ static CompilerOptions createCompilerOptions() {
         .fastInit(false)
         .experimentalAndroidMode2(false)
         .aheadOfTimeSubcomponents(false)
-        .floatingBindsMethods(false)
         .build()
         .validate();
   }
@@ -135,7 +134,6 @@ private static BindingGraphFactory createBindingGraphFactory(
         injectBindingRegistry,
         keyFactory,
         bindingFactory,
-        new IncorrectlyInstalledBindsMethodsValidator(compilerOptions),
         compilerOptions);
   }
 
