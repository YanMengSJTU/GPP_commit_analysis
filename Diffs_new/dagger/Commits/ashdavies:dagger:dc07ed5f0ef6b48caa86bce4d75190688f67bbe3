diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 3eb0c0a7b..58475ec04 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -69,7 +69,6 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -125,12 +124,14 @@
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
   private final ComponentBindingExpressions bindingExpressions;
+  protected final ComponentRequirementFields componentRequirementFields;
   // TODO(user): Merge into ComponentBindingExpressions after we refactor BindingKey.
   private final Map<BindingKey, FrameworkInstanceBindingExpression>
       producerFromProviderBindingExpressions = new LinkedHashMap<>();
   private final List<CodeBlock> initializations = new ArrayList<>();
   protected final List<MethodSpec> interfaceMethods = new ArrayList<>();
   private final BindingExpression.Factory bindingExpressionFactory;
+  private final ComponentRequirementField.Factory componentRequirementFieldFactory;
 
   private final Map<Key, MethodSpec> membersInjectionMethods = new LinkedHashMap<>();
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
@@ -142,16 +143,7 @@
    * For each component requirement, the builder field. This map is empty for subcomponents that do
    * not use a builder.
    */
-  private ImmutableMap<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.of();
-
-  /**
-   * For each component requirement, the member select for the component field that holds it.
-   *
-   * <p>Fields are written for all requirements for subcomponents that do not use a builder, and for
-   * any requirement that is reused from a subcomponent of this component.
-   */
-  protected final Map<ComponentRequirement, MemberSelect> componentContributionFields =
-      Maps.newHashMap();
+  private final ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
 
   /**
    * The member-selects for {@link dagger.internal.ReferenceReleasingProviderManager} fields,
@@ -168,7 +160,8 @@
       BindingGraph graph,
       ImmutableMap<ComponentDescriptor, String> subcomponentNames,
       OptionalFactories optionalFactories,
-      ComponentBindingExpressions bindingExpressions) {
+      ComponentBindingExpressions bindingExpressions,
+      ComponentRequirementFields componentRequirementFields) {
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
@@ -179,16 +172,27 @@
     this.subcomponentNames = subcomponentNames;
     this.optionalFactories = optionalFactories;
     this.bindingExpressions = bindingExpressions;
+    // TODO(dpb): Allow ComponentBuilder.create to return a no-op object
+    if (hasBuilder(graph)) {
+      builder = ComponentBuilder.create(name, graph, subcomponentNames, elements, types);
+      builderFields = builder.builderFields();
+    } else {
+      builderFields = ImmutableMap.of();
+    }
+    this.componentRequirementFields = componentRequirementFields;
     this.bindingExpressionFactory =
         new BindingExpression.Factory(
             compilerOptions,
             name,
             componentFieldNames,
             bindingExpressions,
+            componentRequirementFields,
             this,
             childComponentNames(keyFactory, subcomponentNames),
             graph,
             elements);
+    this.componentRequirementFieldFactory =
+        new ComponentRequirementField.Factory(this, componentFieldNames, name, builderFields);
   }
 
   private static ImmutableMap<BindingKey, String> childComponentNames(
@@ -216,55 +220,14 @@ protected AbstractComponentWriter(
         graph,
         parent.subcomponentNames,
         parent.optionalFactories,
-        parent.bindingExpressions.forChildComponent());
+        parent.bindingExpressions.forChildComponent(),
+        parent.componentRequirementFields.forChildComponent());
   }
 
   protected final ClassName componentDefinitionTypeName() {
     return ClassName.get(graph.componentType());
   }
 
-  /**
-   * Returns an expression that evaluates to an instance of the requirement, looking for either a
-   * builder field or a component field.
-   */
-  private CodeBlock getComponentContributionExpression(ComponentRequirement componentRequirement) {
-    if (builderFields.containsKey(componentRequirement)) {
-      return CodeBlock.of("builder.$N", builderFields.get(componentRequirement));
-    } else {
-      Optional<CodeBlock> codeBlock =
-          getOrCreateComponentRequirementFieldExpression(componentRequirement);
-      checkState(
-          codeBlock.isPresent(), "no builder or component field for %s", componentRequirement);
-      return codeBlock.get();
-    }
-  }
-
-  /**
-   * Returns an expression for a component requirement field. Adds a field the first time one is
-   * requested for a requirement if this component's builder has a field for it.
-   */
-  protected Optional<CodeBlock> getOrCreateComponentRequirementFieldExpression(
-      ComponentRequirement componentRequirement) {
-    MemberSelect fieldSelect = componentContributionFields.get(componentRequirement);
-    if (fieldSelect == null) {
-      if (!builderFields.containsKey(componentRequirement)) {
-        return Optional.empty();
-      }
-      FieldSpec componentField =
-          componentField(
-                  TypeName.get(componentRequirement.type()),
-                  simpleVariableName(componentRequirement.typeElement()))
-              .addModifiers(PRIVATE, FINAL)
-              .build();
-      component.addField(componentField);
-      constructor.addCode(
-          "this.$N = builder.$N;", componentField, builderFields.get(componentRequirement));
-      fieldSelect = localField(name, componentField.name);
-      componentContributionFields.put(componentRequirement, fieldSelect);
-    }
-    return Optional.of(fieldSelect.getExpressionFor(name));
-  }
-
   /**
    * Creates a {@link FieldSpec.Builder} with a unique name based off of {@code name}.
    */
@@ -300,7 +263,7 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
   final TypeSpec.Builder write() {
     checkState(!done, "ComponentWriter has already been generated.");
     decorateComponent();
-    if (hasBuilder()) {
+    if (hasBuilder(graph)) {
       addBuilder();
     }
 
@@ -311,6 +274,7 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
     addFactoryMethods();
     addReferenceReleasingProviderManagerFields();
     createBindingExpressions();
+    createComponentRequirementFields();
     implementInterfaceMethods();
     addSubcomponents();
     writeInitializeAndInterfaceMethods();
@@ -329,7 +293,7 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
    */
   protected abstract void decorateComponent();
 
-  private boolean hasBuilder() {
+  private static boolean hasBuilder(BindingGraph graph) {
     ComponentDescriptor component = graph.componentDescriptor();
     return component.kind().isTopLevel() || component.builderSpec().isPresent();
   }
@@ -338,9 +302,6 @@ private boolean hasBuilder() {
    * Adds a builder type.
    */
   private void addBuilder() {
-    builder = ComponentBuilder.create(name, graph, subcomponentNames, elements, types);
-    builderFields = builder.builderFields();
-
     addBuilderClass(builder.typeSpec());
 
     constructor.addParameter(builderName(), "builder");
@@ -457,6 +418,14 @@ private void createBindingExpression(ResolvedBindings resolvedBindings) {
     bindingExpressions.addBindingExpression(bindingExpressionFactory.forField(resolvedBindings));
   }
 
+  private void createComponentRequirementFields() {
+    builderFields
+        .keySet()
+        .stream()
+        .map(componentRequirementFieldFactory::forBuilderField)
+        .forEach(componentRequirementFields::add);
+  }
+
   private boolean useRawType(Binding binding) {
     return useRawType(binding.bindingPackage());
   }
@@ -578,7 +547,7 @@ private void writeInitializeAndInterfaceMethods() {
                * separate fields and initilization as we do now. */
               .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
               .addCode(CodeBlocks.concat(partition));
-      if (hasBuilder()) {
+      if (hasBuilder(graph)) {
         initializeMethod.addParameter(builderName(), "builder", FINAL);
         constructor.addStatement("$L(builder)", methodName);
       } else {
@@ -720,14 +689,15 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
     TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
     switch (binding.bindingKind()) {
       case COMPONENT:
+        // This bindingKeyTypeName type parameter can be removed when we drop java 7 source support
+        return CodeBlock.of("$T.<$T>create(this)", INSTANCE_FACTORY, bindingKeyTypeName);
+
+      case COMPONENT_DEPENDENCY:
         return CodeBlock.of(
-            "$T.<$T>create($L)",
+            "$T.create($L)",
             INSTANCE_FACTORY,
-            bindingKeyTypeName,
-            bindingKeyTypeName.equals(componentDefinitionTypeName())
-                ? "this"
-                : getComponentContributionExpression(
-                    ComponentRequirement.forDependency(binding.key().type())));
+            componentRequirementFields.getExpressionDuringInitialization(
+                ComponentRequirement.forDependency(binding.key().type()), name));
 
       case COMPONENT_PROVISION:
         {
@@ -778,8 +748,8 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
           return CodeBlock.of(
               "new $L($L)",
               factoryName,
-              getComponentContributionExpression(
-                  ComponentRequirement.forDependency(dependencyType.asType())));
+              componentRequirementFields.getExpressionDuringInitialization(
+                  ComponentRequirement.forDependency(dependencyType.asType()), name));
         }
 
       case SUBCOMPONENT_BUILDER:
@@ -807,7 +777,8 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
             "$T.$L($L)",
             InstanceFactory.class,
             binding.nullableType().isPresent() ? "createNullable" : "create",
-            getComponentContributionExpression(ComponentRequirement.forBinding(binding)));
+            componentRequirementFields.getExpressionDuringInitialization(
+                ComponentRequirement.forBinding(binding), name));
 
       case INJECTION:
       case PROVISION:
@@ -816,8 +787,9 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
               Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
           if (binding.requiresModuleInstance()) {
             arguments.add(
-                getComponentContributionExpression(
-                    ComponentRequirement.forModule(binding.contributingModule().get().asType())));
+                componentRequirementFields.getExpressionDuringInitialization(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
+                    name));
           }
           arguments.addAll(getDependencyArguments(binding));
 
@@ -853,8 +825,8 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
               /* 1 */ PRODUCER,
               /* 2 */ binding.key().type(),
               /* 3 */ LISTENABLE_FUTURE,
-              /* 4 */ getComponentContributionExpression(
-                  ComponentRequirement.forDependency(dependencyType.asType())),
+              /* 4 */ componentRequirementFields.getExpressionDuringInitialization(
+                  ComponentRequirement.forDependency(dependencyType.asType()), name),
               /* 5 */ binding.bindingElement().get().getSimpleName(),
               /* 6 */ dependencyType,
               /* 7 */ simpleVariableName(dependencyType));
@@ -866,8 +838,9 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
               Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
           if (binding.requiresModuleInstance()) {
             arguments.add(
-                getComponentContributionExpression(
-                    ComponentRequirement.forModule(binding.contributingModule().get().asType())));
+                componentRequirementFields.getExpressionDuringInitialization(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
+                    name));
           }
           arguments.addAll(getDependencyArguments(binding));
 
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 4d06d38ca..2206e66ca 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -59,6 +59,7 @@ abstract CodeBlock getDependencyExpression(
     private final ClassName componentName;
     private final UniqueNameSet componentFieldNames;
     private final ComponentBindingExpressions componentBindingExpressions;
+    private final ComponentRequirementFields componentRequirementFields;
     private final GeneratedComponentModel generatedComponentModel;
     private final ImmutableMap<BindingKey, String> subcomponentNames;
     private final BindingGraph graph;
@@ -69,6 +70,7 @@ abstract CodeBlock getDependencyExpression(
         ClassName componentName,
         UniqueNameSet componentFieldNames,
         ComponentBindingExpressions componentBindingExpressions,
+        ComponentRequirementFields componentRequirementFields,
         GeneratedComponentModel generatedComponentModel,
         ImmutableMap<BindingKey, String> subcomponentNames,
         BindingGraph graph,
@@ -77,6 +79,7 @@ abstract CodeBlock getDependencyExpression(
       this.componentName = checkNotNull(componentName);
       this.componentFieldNames = checkNotNull(componentFieldNames);
       this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+      this.componentRequirementFields = checkNotNull(componentRequirementFields);
       this.generatedComponentModel = checkNotNull(generatedComponentModel);
       this.subcomponentNames = checkNotNull(subcomponentNames);
       this.graph = checkNotNull(graph);
@@ -151,6 +154,13 @@ private BindingExpression create(
 
       ProvisionBinding provisionBinding = (ProvisionBinding) resolvedBindings.contributionBinding();
       switch (provisionBinding.bindingKind()) {
+        case COMPONENT:
+          return new ComponentInstanceBindingExpression(bindingExpression, componentName);
+        case COMPONENT_DEPENDENCY:
+          return new BoundInstanceBindingExpression(
+              bindingExpression,
+              ComponentRequirement.forDependency(provisionBinding.key().type()),
+              componentRequirementFields);
         case SUBCOMPONENT_BUILDER:
           return new SubcomponentBuilderBindingExpression(
               bindingExpression, subcomponentNames.get(resolvedBindings.bindingKey()));
@@ -160,17 +170,29 @@ private BindingExpression create(
         case SYNTHETIC_OPTIONAL_BINDING:
           return new OptionalBindingExpression(
               provisionBinding, bindingExpression, componentBindingExpressions);
-            case INJECTION:
+        case BUILDER_BINDING:
+              return new BoundInstanceBindingExpression(
+                  bindingExpression,
+                  ComponentRequirement.forBinding(provisionBinding),
+                  componentRequirementFields);
+        case INJECTION:
         case PROVISION:
           if (!provisionBinding.scope().isPresent()
-              && !provisionBinding.requiresModuleInstance()
               && provisionBinding.bindingElement().isPresent()) {
+            Optional<ComponentRequirement> moduleRequirement =
+                provisionBinding.requiresModuleInstance()
+                    ? Optional.of(
+                        ComponentRequirement.forModule(
+                            provisionBinding.contributingModule().get().asType()))
+                    : Optional.empty();
             return new SimpleMethodBindingExpression(
                 compilerOptions,
                 provisionBinding,
                 bindingExpression,
                 componentBindingExpressions,
-                generatedComponentModel);
+                generatedComponentModel,
+                moduleRequirement,
+                componentRequirementFields);
           }
           // fall through
         default:
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 25feb5b0b..ba01bb723 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -230,7 +230,8 @@ private BindingGraph create(
 
       // Collect Component dependencies.
       for (TypeElement componentDependency : componentDescriptor.dependencies()) {
-        explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
+        explicitBindingsBuilder.add(
+            provisionBindingFactory.forComponentDependency(componentDependency));
         List<ExecutableElement> dependencyMethods =
             ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
         for (ExecutableElement method : dependencyMethods) {
diff --git a/java/dagger/internal/codegen/BoundInstanceBindingExpression.java b/java/dagger/internal/codegen/BoundInstanceBindingExpression.java
new file mode 100644
index 000000000..2f3cd5bd1
--- /dev/null
+++ b/java/dagger/internal/codegen/BoundInstanceBindingExpression.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.Component;
+
+/**
+ * A binding expression for instances bound with {@link dagger.BindsInstance} and instances of
+ * {@link Component#dependencies() component dependencies}.
+ */
+final class BoundInstanceBindingExpression extends SimpleInvocationBindingExpression {
+  private final ComponentRequirement componentRequirement;
+  private final ComponentRequirementFields componentRequirementFields;
+
+  BoundInstanceBindingExpression(
+      BindingExpression delegate,
+      ComponentRequirement componentRequirement,
+      ComponentRequirementFields componentRequirementFields) {
+    super(delegate);
+    this.componentRequirement = componentRequirement;
+    this.componentRequirementFields = componentRequirementFields;
+  }
+
+  @Override
+  CodeBlock getInstanceDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    return componentRequirementFields.getExpression(componentRequirement, requestingClass);
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 32f053cf3..8e45306ac 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -29,11 +29,12 @@
 import java.util.Map;
 import javax.lang.model.type.TypeMirror;
 
-/** A factory of code expressions used to access any binding available to a component. */
+/** A central repository of code expressions used to access any binding available to a component. */
 final class ComponentBindingExpressions {
 
-  // TODO(dpb): Can this use a flattened ImmutableMap, built from its parents? Maybe make
-  // BindingExpression.Factory create it.
+  // TODO(dpb,ronshapiro): refactor this and ComponentRequirementFields into a
+  // HierarchicalComponentMap<K, V>, or perhaps this use a flattened ImmutableMap, built from its
+  // parents? If so, maybe make BindingExpression.Factory create it.
 
   /**
    * A list of binding expression maps. The first element contains the bindings owned by this
diff --git a/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
new file mode 100644
index 000000000..7523cf389
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+
+/** A binding expression for the instance of the component itself, i.e. {@code this}. */
+final class ComponentInstanceBindingExpression extends SimpleInvocationBindingExpression {
+  private final ClassName componentName;
+
+  ComponentInstanceBindingExpression(BindingExpression delegate, ClassName componentName) {
+    super(delegate);
+    this.componentName = componentName;
+  }
+
+  @Override
+  CodeBlock getInstanceDependencyExpression(
+      DependencyRequest.Kind requestKind, ClassName requestingClass) {
+    return componentName.equals(requestingClass)
+        ? CodeBlock.of("this")
+        : CodeBlock.of("$T.this", componentName);
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentRequirementField.java b/java/dagger/internal/codegen/ComponentRequirementField.java
new file mode 100644
index 000000000..e8d721d47
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentRequirementField.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.google.common.collect.ImmutableMap;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.TypeName;
+
+/**
+ * A factory for expressions of {@link ComponentRequirement}s in the generated component. This is
+ * <em>not</em> a {@link BindingExpression}, since {@link ComponentRequirement}s do not have a
+ * {@link BindingKey}. See {@link BoundInstanceBindingExpression} for binding expressions that are
+ * themselves a binding.
+ */
+abstract class ComponentRequirementField {
+  private final ComponentRequirement componentRequirement;
+
+  private ComponentRequirementField(ComponentRequirement componentRequirement) {
+    this.componentRequirement = checkNotNull(componentRequirement);
+  }
+
+  final ComponentRequirement componentRequirement() {
+    return componentRequirement;
+  }
+
+  /**
+   * Returns an expression for the {@link ComponentRequirement} to be used when implementing a
+   * component method. This may add a field to the component in order to reference the component
+   * requirement outside of the {@code initialize()} methods.
+   */
+  abstract CodeBlock getExpression(ClassName requestingClass);
+
+  /**
+   * Returns an expression for the {@link ComponentRequirement} to be used only within {@code
+   * initialize()} methods, where the component builder is available.
+   *
+   * <p>When accessing this field from a subcomponent, this may cause a field to be initialized in
+   * the component that owns this {@link ComponentRequirement}.
+   */
+  abstract CodeBlock getExpressionDuringInitialization(ClassName requestingClass);
+
+  /**
+   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a corresponding
+   * field on the component builder.
+   */
+  private static final class BuilderField extends ComponentRequirementField {
+    private final GeneratedComponentModel generatedComponentModel;
+    private final UniqueNameSet componentFieldNames;
+    private final ClassName owningComponent;
+    private final FieldSpec builderField;
+    private MemberSelect field;
+
+    private BuilderField(
+        ComponentRequirement componentRequirement,
+        GeneratedComponentModel generatedComponentModel,
+        UniqueNameSet componentFieldNames,
+        ClassName owningComponent,
+        FieldSpec builderField) {
+      super(componentRequirement);
+      this.generatedComponentModel = checkNotNull(generatedComponentModel);
+      this.componentFieldNames = checkNotNull(componentFieldNames);
+      this.owningComponent = checkNotNull(owningComponent);
+      this.builderField = checkNotNull(builderField);
+    }
+
+    @Override
+    CodeBlock getExpression(ClassName requestingClass) {
+      return getField().getExpressionFor(requestingClass);
+    }
+
+    @Override
+    CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
+      if (owningComponent.equals(requestingClass)) {
+        return CodeBlock.of("builder.$N", builderField);
+      } else {
+        // requesting this component requirement during initialization of a child component requires
+        // the it to be access from a field and not the builder (since it is no longer available)
+        return getExpression(requestingClass);
+      }
+    }
+
+    private MemberSelect getField() {
+      if (field == null) {
+        // TODO(dpb,ronshapiro): think about whether GeneratedComponentModel.addField should make a
+        // unique name for the field.
+        String fieldName = componentFieldNames.getUniqueName(componentRequirement().variableName());
+        FieldSpec componentField =
+            FieldSpec.builder(TypeName.get(componentRequirement().type()), fieldName, PRIVATE)
+                .build();
+        generatedComponentModel.addField(componentField);
+        generatedComponentModel.addInitialization(
+            CodeBlock.of("this.$N = builder.$N;", componentField, builderField));
+        field = MemberSelect.localField(owningComponent, fieldName);
+      }
+      return field;
+    }
+  }
+
+  /**
+   * A {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a corresponding
+   * field already added on the component.
+   */
+  private static final class ComponentField extends ComponentRequirementField {
+    private final MemberSelect memberSelect;
+
+    private ComponentField(
+        ComponentRequirement componentRequirement,
+        FieldSpec componentField,
+        ClassName owningComponent) {
+      super(componentRequirement);
+      this.memberSelect = MemberSelect.localField(owningComponent, componentField.name);
+    }
+
+    @Override
+    CodeBlock getExpression(ClassName requestingClass) {
+      return memberSelect.getExpressionFor(requestingClass);
+    }
+
+    @Override
+    CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
+      return getExpression(requestingClass);
+    }
+  }
+
+  static final class Factory {
+    private final GeneratedComponentModel generatedComponentModel;
+    private final UniqueNameSet componentFieldNames;
+    private final ClassName owningComponent;
+    private final ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
+
+    Factory(
+        GeneratedComponentModel generatedComponentModel,
+        UniqueNameSet componentFieldNames,
+        ClassName owningComponent,
+        ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
+      this.generatedComponentModel = checkNotNull(generatedComponentModel);
+      this.componentFieldNames = checkNotNull(componentFieldNames);
+      this.owningComponent = checkNotNull(owningComponent);
+      this.builderFields = checkNotNull(builderFields);
+    }
+
+    /**
+     * Returns a {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a
+     * corresponding field on the component builder.
+     */
+    ComponentRequirementField forBuilderField(ComponentRequirement componentRequirement) {
+      return new BuilderField(
+          componentRequirement,
+          generatedComponentModel,
+          componentFieldNames,
+          owningComponent,
+          builderFields.get(componentRequirement));
+    }
+  }
+
+  /**
+   * Returns a {@link ComponentRequirementField} for {@link ComponentRequirement}s that have a
+   * corresponding field already added on the component.
+   */
+  static ComponentRequirementField componentField(
+      ComponentRequirement componentRequirement,
+      FieldSpec componentField,
+      ClassName owningComponent) {
+    return new ComponentField(componentRequirement, componentField, owningComponent);
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentRequirementFields.java b/java/dagger/internal/codegen/ComponentRequirementFields.java
new file mode 100644
index 000000000..afa33828d
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentRequirementFields.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A central repository of fields used to access any {@link ComponentRequirement} available to a
+ * component.
+ */
+final class ComponentRequirementFields {
+
+  // TODO(dpb,ronshapiro): refactor this and ComponentBindingExpressions into a
+  // HierarchicalComponentMap<K, V>, or perhaps this use a flattened ImmutableMap, built from its
+  // parents? If so, maybe make ComponentRequirementField.Factory create it.
+
+  /**
+   * A list of component requirement field maps. The first element contains the fields on this
+   * component; the second contains the fields owned by its parent; and so on.
+   */
+  private final ImmutableList<Map<ComponentRequirement, ComponentRequirementField>>
+      componentRequirementFieldsMaps;
+
+  private ComponentRequirementFields(
+      ImmutableList<Map<ComponentRequirement, ComponentRequirementField>>
+          componentRequirementFieldsMaps) {
+    this.componentRequirementFieldsMaps = componentRequirementFieldsMaps;
+  }
+
+  ComponentRequirementFields() {
+    this(ImmutableList.of(newComponentRequirementsMap()));
+  }
+
+  /**
+   * Returns an expression for the {@code componentRequirement} to be used when implementing a
+   * component method. This may add a field to the component in order to reference the component
+   * requirement outside of the {@code initialize()} methods.
+   */
+  CodeBlock getExpression(ComponentRequirement componentRequirement, ClassName requestingClass) {
+    return getField(componentRequirement).getExpression(requestingClass);
+  }
+
+  /**
+   * Returns an expression for the {@code componentRequirement} to be used only within {@code
+   * initialize()} methods, where the component builder is available.
+   *
+   * <p>When accessing this field from a subcomponent, this may cause a field to be initialized in
+   * the component that owns this {@link ComponentRequirement}.
+   */
+  CodeBlock getExpressionDuringInitialization(
+      ComponentRequirement componentRequirement, ClassName requestingClass) {
+    return getField(componentRequirement).getExpressionDuringInitialization(requestingClass);
+  }
+
+  private ComponentRequirementField getField(ComponentRequirement componentRequirement) {
+    for (Map<ComponentRequirement, ComponentRequirementField> componentRequirementFieldsMap :
+        componentRequirementFieldsMaps) {
+      ComponentRequirementField field = componentRequirementFieldsMap.get(componentRequirement);
+      if (field != null) {
+        return field;
+      }
+    }
+    throw new IllegalStateException(
+        "no component requirement field found for " + componentRequirement);
+  }
+
+  /**
+   * Adds a component requirement field for a single component requirement owned by this component.
+   */
+  void add(ComponentRequirementField field) {
+    componentRequirementFieldsMaps.get(0).put(field.componentRequirement(), field);
+  }
+
+  /**
+   * Returns {@code true} if the component that owns this {@link ComponentRequirementFields} has a
+   * registered {@link ComponentRequirementField} for {@code componentRequirement}.
+   */
+  boolean contains(ComponentRequirement componentRequirement) {
+    return componentRequirementFieldsMaps
+        .stream()
+        .anyMatch(map -> map.containsKey(componentRequirement));
+  }
+
+  private static Map<ComponentRequirement, ComponentRequirementField>
+      newComponentRequirementsMap() {
+    return new HashMap<>();
+  }
+
+  /**
+   * Returns a new object representing the fields available from a child component of this one.
+   */
+  ComponentRequirementFields forChildComponent() {
+    return new ComponentRequirementFields(
+        FluentIterable.of(newComponentRequirementsMap())
+            .append(componentRequirementFieldsMaps)
+            .toList());
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index 53b10c7ea..8bb273ab8 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -65,7 +65,8 @@
         graph,
         new UniqueSubcomponentNamesGenerator(graph).generate(),
         new OptionalFactories(),
-        new ComponentBindingExpressions());
+        new ComponentBindingExpressions(),
+        new ComponentRequirementFields());
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index 81eb8d9e6..8891e67d1 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -129,6 +129,9 @@
     /** A provision method on a component's {@linkplain Component#dependencies() dependency}. */
     COMPONENT_PROVISION,
 
+    /** An instance of a {@linkplain Component#dependencies() dependency}. */
+    COMPONENT_DEPENDENCY,
+
     /**
      * A subcomponent builder method on a component or subcomponent.
      */
diff --git a/java/dagger/internal/codegen/InjectionMethods.java b/java/dagger/internal/codegen/InjectionMethods.java
index d2ebf4ef3..6eff4dd54 100644
--- a/java/dagger/internal/codegen/InjectionMethods.java
+++ b/java/dagger/internal/codegen/InjectionMethods.java
@@ -25,11 +25,11 @@
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.CodeBlocks.toConcatenatedCodeBlock;
-import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.TypeNames.rawTypeName;
+import static dagger.internal.codegen.Util.toImmutableList;
 import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -136,13 +136,16 @@
     static CodeBlock invoke(
         ProvisionBinding binding,
         Function<DependencyRequest, CodeBlock> dependencyUsage,
-        ClassName requestingClass) {
+        ClassName requestingClass,
+        Optional<CodeBlock> moduleReference) {
+      ImmutableList.Builder<CodeBlock> arguments = ImmutableList.builder();
+      moduleReference.ifPresent(arguments::add);
+      arguments.addAll(
+          injectionMethodArguments(
+              binding.provisionDependencies(), dependencyUsage, requestingClass));
       return callInjectionMethod(
           create(binding).get().name,
-          // TODO(dpb): would this be simpler if injectionMethodArguments returned a List?
-          ImmutableList.of(
-              injectionMethodArguments(
-                  binding.provisionDependencies(), dependencyUsage, requestingClass)),
+          arguments.build(),
           generatedClassNameForBinding(binding),
           requestingClass);
     }
@@ -336,13 +339,13 @@ private static String methodName(InjectionSite injectionSite) {
    * @param dependencyUsage function to apply on each of {@code dependencies} before casting
    * @param requestingClass the class calling the injection method
    */
-  private static CodeBlock injectionMethodArguments(
+  private static ImmutableList<CodeBlock> injectionMethodArguments(
       ImmutableSet<DependencyRequest> dependencies,
       Function<DependencyRequest, CodeBlock> dependencyUsage,
       ClassName requestingClass) {
     return dependencies.stream()
         .map(dep -> injectionMethodArgument(dep, dependencyUsage.apply(dep), requestingClass))
-        .collect(toParametersCodeBlock());
+        .collect(toImmutableList());
   }
 
   private static CodeBlock injectionMethodArgument(
diff --git a/java/dagger/internal/codegen/Key.java b/java/dagger/internal/codegen/Key.java
index 50d12bcc4..3c4cecc06 100644
--- a/java/dagger/internal/codegen/Key.java
+++ b/java/dagger/internal/codegen/Key.java
@@ -503,7 +503,8 @@ Key forInjectConstructorWithResolvedType(TypeMirror type) {
       return builder(type).build();
     }
 
-    Key forComponent(TypeMirror type) {
+    // TODO(ronshapiro): Remove these conveniences which are simple wrappers around Key.Builder
+    Key forType(TypeMirror type) {
       return builder(type).build();
     }
 
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index 5eeca8d52..12f43dad1 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -272,11 +272,21 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .bindingElement(componentDefinitionType)
-          .key(keyFactory.forComponent(componentDefinitionType.asType()))
+          .key(keyFactory.forType(componentDefinitionType.asType()))
           .bindingKind(Kind.COMPONENT)
           .build();
     }
 
+    ProvisionBinding forComponentDependency(TypeElement dependencyType) {
+      checkNotNull(dependencyType);
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(dependencyType)
+          .key(keyFactory.forType(dependencyType.asType()))
+          .bindingKind(Kind.COMPONENT_DEPENDENCY)
+          .build();
+    }
+
     ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index ec9d208e7..de83e7b65 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -18,20 +18,19 @@
 
 import static com.google.auto.common.MoreElements.asExecutable;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.FactoryGenerator.checkNotNullProvidesMethod;
 import static dagger.internal.codegen.InjectionMethods.ProvisionMethod.requiresInjectionMethod;
 import static dagger.internal.codegen.TypeNames.rawTypeName;
-import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreTypes;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.TypeName;
 import dagger.internal.codegen.InjectionMethods.ProvisionMethod;
+import java.util.Optional;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
 
@@ -44,24 +43,29 @@
   private final ProvisionBinding provisionBinding;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final GeneratedComponentModel generatedComponentModel;
+  private final Optional<ComponentRequirement> moduleRequirement;
+  private final ComponentRequirementFields componentRequirementFields;
 
   SimpleMethodBindingExpression(
       CompilerOptions compilerOptions,
       ProvisionBinding provisionBinding,
       BindingExpression delegate,
       ComponentBindingExpressions componentBindingExpressions,
-      GeneratedComponentModel generatedComponentModel) {
+      GeneratedComponentModel generatedComponentModel,
+      Optional<ComponentRequirement> moduleRequirement,
+      ComponentRequirementFields componentRequirementFields) {
     super(delegate);
     checkArgument(
         provisionBinding.implicitDependencies().isEmpty(),
         "framework deps are not currently supported");
     checkArgument(!provisionBinding.scope().isPresent());
-    checkArgument(!provisionBinding.requiresModuleInstance());
     checkArgument(provisionBinding.bindingElement().isPresent());
     this.compilerOptions = compilerOptions;
     this.provisionBinding = provisionBinding;
     this.componentBindingExpressions = componentBindingExpressions;
     this.generatedComponentModel = generatedComponentModel;
+    this.moduleRequirement = moduleRequirement;
+    this.componentRequirementFields = componentRequirementFields;
   }
 
   @Override
@@ -85,13 +89,11 @@ private CodeBlock invokeMethod(ClassName requestingClass) {
       case CONSTRUCTOR:
         return CodeBlock.of("new $T($L)", constructorTypeName(requestingClass), arguments);
       case METHOD:
-        checkState(method.getModifiers().contains(STATIC));
+        CodeBlock module =
+            moduleReference(requestingClass)
+                .orElse(CodeBlock.of("$T", provisionBinding.bindingTypeElement().get()));
         return maybeCheckForNulls(
-            CodeBlock.of(
-                "$T.$L($L)",
-                provisionBinding.bindingTypeElement().get(),
-                method.getSimpleName(),
-                arguments));
+            CodeBlock.of("$L.$L($L)", module, method.getSimpleName(), arguments));
       default:
         throw new IllegalStateException();
     }
@@ -114,7 +116,8 @@ private CodeBlock invokeInjectionMethod(ClassName requestingClass) {
             ProvisionMethod.invoke(
                 provisionBinding,
                 request -> dependencyArgument(request, requestingClass),
-                requestingClass)));
+                requestingClass,
+                moduleReference(requestingClass))));
   }
 
   private CodeBlock dependencyArgument(DependencyRequest dependency, ClassName requestingClass) {
@@ -145,4 +148,9 @@ private CodeBlock injectMembers(CodeBlock instance) {
         generatedComponentModel.getMembersInjectionMethod(provisionBinding.key()),
         instance);
   }
+
+  private Optional<CodeBlock> moduleReference(ClassName requestingClass) {
+    return moduleRequirement.map(
+        requirement -> componentRequirementFields.getExpression(requirement, requestingClass));
+  }
 }
diff --git a/java/dagger/internal/codegen/SubcomponentWriter.java b/java/dagger/internal/codegen/SubcomponentWriter.java
index 48e674f47..739e3c4b5 100644
--- a/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -18,10 +18,8 @@
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Sets.difference;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.MemberSelect.localField;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -29,7 +27,9 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.CaseFormat;
+import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
@@ -73,16 +73,6 @@ private static ClassName subcomponentName(AbstractComponentWriter parent, Bindin
         parent.subcomponentNames.get(subgraph.componentDescriptor()) + "Impl");
   }
 
-  @Override
-  protected Optional<CodeBlock> getOrCreateComponentRequirementFieldExpression(
-      ComponentRequirement componentRequirement) {
-    Optional<CodeBlock> expression =
-        super.getOrCreateComponentRequirementFieldExpression(componentRequirement);
-    return expression.isPresent()
-        ? expression
-        : parent.getOrCreateComponentRequirementFieldExpression(componentRequirement);
-  }
-
   @Override
   protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
     return parent.getReferenceReleasingProviderManagerExpression(scope);
@@ -147,7 +137,7 @@ private void writeSubcomponentWithoutBuilder(
           ComponentRequirement.forModule(moduleTypeElement.asType());
       TypeName moduleType = TypeName.get(paramTypes.get(i));
       componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
-      if (!componentContributionFields.containsKey(componentRequirement)) {
+      if (!componentRequirementFields.contains(componentRequirement)) {
         String preferredModuleName =
             CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleTypeElement.getSimpleName().toString());
         FieldSpec contributionField =
@@ -156,23 +146,23 @@ private void writeSubcomponentWithoutBuilder(
                 .build();
         component.addField(contributionField);
 
-        String actualModuleName = contributionField.name;
         constructor
-            .addParameter(moduleType, actualModuleName)
+            .addParameter(moduleType, contributionField.name)
             .addStatement(
-                "this.$1L = $2T.checkNotNull($1L)",
-                actualModuleName,
-                Preconditions.class);
+                "this.$1N = $2T.checkNotNull($1N)", contributionField, Preconditions.class);
 
-        MemberSelect moduleSelect = localField(name, actualModuleName);
-        componentContributionFields.put(componentRequirement, moduleSelect);
+        componentRequirementFields.add(
+            ComponentRequirementField.componentField(
+                componentRequirement, contributionField, name));
         subcomponentConstructorParameters.add(
             CodeBlock.of("$L", moduleVariable.getSimpleName()));
       }
     }
 
     Set<ComponentRequirement> uninitializedModules =
-        difference(graph.componentRequirements(), componentContributionFields.keySet());
+        Sets.filter(
+            graph.componentRequirements(),
+            Predicates.not(componentRequirementFields::contains));
 
     for (ComponentRequirement componentRequirement : uninitializedModules) {
       checkState(componentRequirement.kind().equals(ComponentRequirement.Kind.MODULE));
@@ -184,11 +174,10 @@ private void writeSubcomponentWithoutBuilder(
               .addModifiers(PRIVATE, FINAL)
               .build();
       component.addField(contributionField);
-      String actualModuleName = contributionField.name;
-      constructor.addStatement(
-          "this.$L = new $T()", actualModuleName, ClassName.get(moduleType));
-      MemberSelect moduleSelect = localField(name, actualModuleName);
-      componentContributionFields.put(componentRequirement, moduleSelect);
+      constructor.addStatement("this.$N = new $T()", contributionField, ClassName.get(moduleType));
+      componentRequirementFields.add(
+          ComponentRequirementField.componentField(
+              componentRequirement, contributionField, name));
     }
 
     componentMethod.addStatement("return new $T($L)",
diff --git a/javatests/dagger/internal/codegen/ComponentBuilderTest.java b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
index c9ea2c30e..56bdc09eb 100644
--- a/javatests/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
@@ -22,6 +22,7 @@
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
@@ -145,11 +146,10 @@ public void testUsesBuildAndSetterNames() {
             "",
             "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<String> stringProvider;",
+            "  private TestModule testModule;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
             "    initialize(builder);",
@@ -165,12 +165,13 @@ public void testUsesBuildAndSetterNames() {
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
+            "    this.testModule = builder.testModule;",
             "  }",
             "",
             "  @Override",
             "  public String string() {",
-            "    return stringProvider.get();",
+            "    return Preconditions.checkNotNull(",
+            "        testModule.string()," + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "",
             "  private static final class Builder implements TestComponent.Builder {",
@@ -251,12 +252,11 @@ public void testIgnoresModulesNotInApi() {
             "",
             "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<String> stringProvider;",
-            "  private Provider<Integer> integerProvider;",
+            "  private TestModule1 testModule1;",
+            "  private TestModule2 testModule2;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
             "    initialize(builder);",
@@ -272,18 +272,20 @@ public void testIgnoresModulesNotInApi() {
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
-            "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
+            "    this.testModule1 = builder.testModule1;",
+            "    this.testModule2 = builder.testModule2;",
             "  }",
             "",
             "  @Override",
             "  public String string() {",
-            "    return stringProvider.get();",
+            "    return Preconditions.checkNotNull(",
+            "        testModule1.string()," + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "",
             "  @Override",
             "  public Integer integer() {",
-            "    return integerProvider.get();",
+            "    return Preconditions.checkNotNull(",
+            "        testModule2.integer()," + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "",
             "  private static final class Builder implements TestComponent.Builder {",
@@ -443,14 +445,12 @@ public void testBuilderBindsInstanceNoCreateGenerated() {
             "test.DaggerSimpleComponent",
             "package test;",
             "",
-            "import dagger.internal.InstanceFactory;",
             "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private Provider<Object> objectProvider;",
+            "  private Object object;",
             "",
             "  private DaggerSimpleComponent(Builder builder) {",
             "    initialize(builder);",
@@ -462,12 +462,12 @@ public void testBuilderBindsInstanceNoCreateGenerated() {
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.objectProvider = InstanceFactory.create(builder.object);",
+            "    this.object = builder.object;",
             "  }",
             "",
             "  @Override",
             "  public Object object() {",
-            "    return objectProvider.get();",
+            "    return object;",
             "  }",
             "",
             "  private static final class Builder implements SimpleComponent.Builder {",
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index 695ff9441..d6b741b0b 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -515,11 +515,10 @@ public void componentWithInvalidModule() {
             "",
             "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<B> bProvider;",
+            "  private TestModule testModule;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
             "    initialize(builder);",
@@ -535,13 +534,13 @@ public void componentWithInvalidModule() {
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
-            "        C_Factory.create());",
+            "    this.testModule = builder.testModule;",
             "  }",
             "",
             "  @Override",
             "  public A a() {",
-            "    return new A(bProvider.get());",
+            "    return new A(Preconditions.checkNotNull(",
+            "        testModule.b(new C()), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "",
             "  public static final class Builder {",
@@ -1107,6 +1106,7 @@ public void testDefaultPackage() {
         "@Component",
         "interface SimpleComponent {",
         "  SomeInjectableType someInjectableType();",
+        "  Provider<SimpleComponent> selfProvider();",
         "}");
     JavaFileObject generatedComponent =
         JavaFileObjects.forSourceLines(
@@ -1140,7 +1140,12 @@ public void testDefaultPackage() {
             "",
             "  @Override",
             "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType(simpleComponentProvider.get())",
+            "    return new SomeInjectableType(this)",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<SimpleComponent> selfProvider() {",
+            "    return simpleComponentProvider;",
             "  }",
             "",
             "  public static final class Builder {",
@@ -1458,12 +1463,12 @@ public void testDefaultPackage() {
         "",
         "import dagger.internal.Preconditions;",
         "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
+        "import other.test.TestModule_AFactory;",
         "",
         GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<A> aProvider;",
-        "  private Provider<other.test.A> aProvider2;",
+        "  private TestModule testModule;",
+        "  private other.test.TestModule testModule2;",
         "",
         "  private DaggerTestComponent(Builder builder) {",
         "    initialize(builder);",
@@ -1479,18 +1484,19 @@ public void testDefaultPackage() {
         "",
         "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
-        "    this.aProvider = TestModule_AFactory.create(builder.testModule);",
-        "    this.aProvider2 = other.test.TestModule_AFactory.create(builder.testModule2);",
+        "    this.testModule = builder.testModule;",
+        "    this.testModule2 = builder.testModule2;",
         "  }",
         "",
         "  @Override",
         "  public A a() {",
-        "    return aProvider.get();",
+        "    return Preconditions.checkNotNull(testModule.a(), " + NPE_FROM_PROVIDES_METHOD + ");",
         "  }",
         "",
         "  @Override",
         "  public other.test.A otherA() {",
-        "    return aProvider2.get();",
+        "    return Preconditions.checkNotNull(",
+        "        TestModule_AFactory.proxyA(testModule2), " + NPE_FROM_PROVIDES_METHOD + ");",
         "  }",
         "",
         "  public static final class Builder {",
diff --git a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
new file mode 100644
index 000000000..e974f687c
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
@@ -0,0 +1,551 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_COMPONENT_METHOD;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ComponentRequirementFieldTest {
+  @Test
+  public void bindsInstance() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "import java.util.List;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  int i();",
+            "  List<String> list();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    @BindsInstance Builder i(int i);",
+            "    @BindsInstance Builder list(List<String> list);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import java.util.List;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Integer i;",
+                "  private List<String> list;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static TestComponent.Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.i = builder.i;",
+                "    this.list = builder.list;",
+                "  }",
+                "",
+                "  @Override",
+                "  public int i() {",
+                "    return i;",
+                "  }",
+                "",
+                "  @Override",
+                "  public List<String> list() {",
+                "    return list;",
+                "  }",
+                "",
+                "  private static final class Builder implements TestComponent.Builder {",
+                "    private Integer i;",
+                "    private List<String> list;",
+                "",
+                "    @Override",
+                "    public TestComponent build() {",
+                "      if (i == null) {",
+                "        throw new IllegalStateException(",
+                "            Integer.class.getCanonicalName() + \" must be set\");",
+                "      }",
+                "      if (list == null) {",
+                "        throw new IllegalStateException(",
+                "            List.class.getCanonicalName() + \" must be set\");",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    @Override",
+                "    public Builder i(int i) {",
+                "      this.i = Preconditions.checkNotNull(i);",
+                "      return this;",
+                "    }",
+                "",
+                "    @Override",
+                "    public Builder list(List<String> list) {",
+                "      this.list = Preconditions.checkNotNull(list);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void instanceModuleMethod() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides int i() { return 0; }",
+            "}");
+    JavaFileObject otherPackageModule =
+        JavaFileObjects.forSourceLines(
+            "other.OtherPackageModule",
+            "package other;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "public class OtherPackageModule {",
+            "  @Provides long l() { return 0L; }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import other.OtherPackageModule;",
+            "",
+            "@Component(modules = {ParentModule.class, OtherPackageModule.class})",
+            "interface TestComponent {",
+            "  int i();",
+            "  long l();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(module, otherPackageModule, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import other.OtherPackageModule;",
+                "import other.OtherPackageModule_LFactory;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private ParentModule parentModule;",
+                "  private OtherPackageModule otherPackageModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.parentModule = builder.parentModule;",
+                "    this.otherPackageModule = builder.otherPackageModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public int i() {",
+                "    return parentModule.i();",
+                "  }",
+                "",
+                "  @Override",
+                "  public long l() {",
+                "    return OtherPackageModule_LFactory.proxyL(otherPackageModule);",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "    private OtherPackageModule otherPackageModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      if (otherPackageModule == null) {",
+                "        this.otherPackageModule = new OtherPackageModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "",
+                "    public Builder otherPackageModule(OtherPackageModule otherPackageModule) {",
+                "      this.otherPackageModule = Preconditions.checkNotNull(otherPackageModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void componentInstances() {
+    JavaFileObject dependency =
+        JavaFileObjects.forSourceLines(
+            "test.Dep",
+            "package test;",
+            "",
+            "interface Dep {",
+            "  String string();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = Dep.class)",
+            "interface TestComponent {",
+            "  TestComponent self();",
+            "  TestSubcomponent subcomponent();",
+            "",
+            "  Dep dep();",
+            "  String methodOnDep();",
+            "}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface TestSubcomponent {",
+            "  TestComponent parent();",
+            "  Dep depFromSubcomponent();",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(dependency, component, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Dep dep;",
+                "",
+                "  private Provider<String> stringProvider;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.dep = builder.dep;",
+                "    this.stringProvider = new test_Dep_string(builder.dep);",
+                "  }",
+                "",
+                "  @Override",
+                "  public TestComponent self() {",
+                "    return this;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Dep dep() {",
+                "    return dep;",
+                "  }",
+                "",
+                "  @Override",
+                "  public String methodOnDep() {",
+                "    return stringProvider.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public TestSubcomponent subcomponent() {",
+                "    return new TestSubcomponentImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private Dep dep;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (dep == null) {",
+                "        throw new IllegalStateException(",
+                "            Dep.class.getCanonicalName() + \" must be set\");",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder dep(Dep dep) {",
+                "      this.dep = Preconditions.checkNotNull(dep);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private static class test_Dep_string implements Provider<String> {",
+                "    private final Dep dep;",
+                "",
+                "    test_Dep_string(Dep dep) {",
+                "      this.dep = dep;",
+                "    }",
+                "",
+                "    @Override",
+                "    public String get() {",
+                "      return Preconditions.checkNotNull(",
+                "          dep.string(), " + NPE_FROM_COMPONENT_METHOD + ");",
+                "    }",
+                "  }",
+                "",
+                "  private final class TestSubcomponentImpl implements TestSubcomponent {",
+                "    private TestSubcomponentImpl() {}",
+                "",
+                "    @Override",
+                "    public TestComponent parent() {",
+                "      return DaggerTestComponent.this;",
+                "    }",
+                "",
+                "    @Override",
+                "    public Dep depFromSubcomponent() {",
+                "      return DaggerTestComponent.this.dep;",
+                "    }",
+                "  }",
+                "}"));
+  }
+
+  @Test
+  public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.Provides;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides",
+            // intentionally non-static. this needs to require the module when the subcompnent
+            // adds to the Set binding
+            "  Object reliesOnMultibinding(Set<Object> set) { return set; }",
+            "",
+            "  @Provides @IntoSet static Object contribution() { return new Object(); }",
+            "}");
+
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides @IntoSet static Object contribution() { return new Object(); }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface TestComponent {",
+            "  Provider<Object> dependsOnMultibinding();",
+            "  TestSubcomponent subcomponent();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface TestSubcomponent {",
+            "  Provider<Object> dependsOnMultibinding();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(parentModule, childModule, component, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(
+            JavaFileObjects.forSourceLines(
+                "test.DaggerTestComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import dagger.internal.SetFactory;",
+                "import java.util.Set;",
+                "import javax.annotation.Generated;",
+                "import javax.inject.Provider;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerTestComponent implements TestComponent {",
+                "  private Provider<Set<Object>> setOfObjectProvider;",
+                "  private Provider<Object> reliesOnMultibindingProvider;",
+                "  private ParentModule parentModule;",
+                "",
+                "  private DaggerTestComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static TestComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.setOfObjectProvider =",
+                "        SetFactory.<Object>builder(1, 0)",
+                "            .addProvider(ParentModule_ContributionFactory.create())",
+                "            .build();",
+                "    this.reliesOnMultibindingProvider =",
+                "        ParentModule_ReliesOnMultibindingFactory.create(",
+                "            builder.parentModule, setOfObjectProvider);",
+                "    this.parentModule = builder.parentModule;",
+                "  }",
+                "",
+                "  @Override",
+                "  public Provider<Object> dependsOnMultibinding() {",
+                "    return reliesOnMultibindingProvider;",
+                "  }",
+                "",
+                "  @Override",
+                "  public TestSubcomponent subcomponent() {",
+                "    return new TestSubcomponentImpl();",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private ParentModule parentModule;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public TestComponent build() {",
+                "      if (parentModule == null) {",
+                "        this.parentModule = new ParentModule();",
+                "      }",
+                "      return new DaggerTestComponent(this);",
+                "    }",
+                "",
+                "    public Builder parentModule(ParentModule parentModule) {",
+                "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+                "      return this;",
+                "    }",
+                "  }",
+                "",
+                "  private final class TestSubcomponentImpl implements TestSubcomponent {",
+                "    private Provider<Set<Object>> setOfObjectProvider;",
+                "",
+                "    private Provider<Object> reliesOnMultibindingProvider;",
+                "",
+                "    private TestSubcomponentImpl() {",
+                "      initialize();",
+                "    }",
+                "",
+                "    @SuppressWarnings(\"unchecked\")",
+                "    private void initialize() {",
+                "      this.setOfObjectProvider =",
+                "          SetFactory.<Object>builder(2, 0)",
+                "              .addProvider(ParentModule_ContributionFactory.create())",
+                "              .addProvider(ChildModule_ContributionFactory.create())",
+                "              .build();",
+                "      this.reliesOnMultibindingProvider =",
+                "          ParentModule_ReliesOnMultibindingFactory.create(",
+                "              DaggerTestComponent.this.parentModule, setOfObjectProvider);",
+                "    }",
+                "",
+                "    @Override",
+                "    public Provider<Object> dependsOnMultibinding() {",
+                "      return reliesOnMultibindingProvider;",
+                "    }",
+                "  }",
+                "}"));
+  }
+}
diff --git a/javatests/dagger/internal/codegen/GeneratedLines.java b/javatests/dagger/internal/codegen/GeneratedLines.java
index 4a6f2f477..e4eb159a8 100644
--- a/javatests/dagger/internal/codegen/GeneratedLines.java
+++ b/javatests/dagger/internal/codegen/GeneratedLines.java
@@ -16,6 +16,10 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.CodeBlocks.stringLiteral;
+
+import com.squareup.javapoet.CodeBlock;
+
 /**
  * Common lines outputted during code generation.
  */
@@ -24,4 +28,11 @@
       "@Generated("
           + "value = \"dagger.internal.codegen.ComponentProcessor\", "
           + "comments = \"https://google.github.io/dagger\")";
+
+  public static final CodeBlock NPE_FROM_PROVIDES_METHOD =
+      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
+  public static final CodeBlock NPE_FROM_COMPONENT_METHOD =
+      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+
 }
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index bf46a3c0d..6aba380dc 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.auto.value.processor.AutoAnnotationProcessor;
 import com.google.common.collect.ImmutableList;
@@ -30,7 +31,6 @@
 
 @RunWith(JUnit4.class)
 public class MapBindingComponentProcessorTest {
-
   @Test
   public void mapBindingsWithEnumKey() {
     JavaFileObject mapModuleOneFile =
@@ -715,11 +715,10 @@ public void injectMapWithoutMapBinding() {
         "import dagger.internal.Preconditions;",
         "import java.util.Map;",
         "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
         "",
         GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Map<String, String>> provideAMapProvider;",
+        "  private MapModule mapModule;",
         "",
         "  private DaggerTestComponent(Builder builder) {",
         "    initialize(builder);",
@@ -735,12 +734,13 @@ public void injectMapWithoutMapBinding() {
         "",
         "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
-        "    this.provideAMapProvider = MapModule_ProvideAMapFactory.create(builder.mapModule);",
+        "    this.mapModule = builder.mapModule;",
         "  }",
         "",
         "  @Override",
         "  public Map<String, String> dispatcher() {",
-        "    return provideAMapProvider.get();",
+        "    return Preconditions.checkNotNull(",
+        "        mapModule.provideAMap(), " + NPE_FROM_PROVIDES_METHOD + ");",
         "  }",
         "",
         "  public static final class Builder {",
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index c873fadca..0ff883892 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -246,7 +246,7 @@ public void simpleComponent() {
             "         DoubleCheck.provider(",
             "             TestClass_SimpleComponent_ProductionExecutorModule_ExecutorFactory",
             "                 .create(executorProvider));",
-            "    this.simpleComponentProvider =",
+            "    this.simpleComponentProvider = ",
             "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
             "    this.monitorProvider =",
             "        DoubleCheck.provider(",
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index f749f085b..056914e7e 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -20,6 +20,7 @@
 import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
@@ -356,7 +357,9 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
             "test.DaggerParentComponent",
             "package test;",
             "",
+            "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
             "import dagger.internal.DoubleCheck;",
+            "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
@@ -409,30 +412,27 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
             "",
             "  private final class ChildComponentImpl implements ChildComponent {",
             "    private final ChildModule childModule;",
-            "    private Provider<NeedsDep1> needsDep1Provider;",
-            "    private Provider<A> aProvider;",
-            "    private Provider<Object> provideObjectProvider;",
             "  ",
             "    private ChildComponentImpl() {  ",
             "      this.childModule = new ChildModule();",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {  ",
-            "      this.needsDep1Provider = NeedsDep1_Factory.create(",
-            "          DaggerParentComponent.this.dep1Provider);",
-            "      this.aProvider = A_Factory.create(",
-            "          needsDep1Provider,",
-            "          DaggerParentComponent.this.dep1Provider,",
-            "          DaggerParentComponent.this.dep2Provider);",
-            "      this.provideObjectProvider = ChildModule_ProvideObjectFactory.create(",
-            "          childModule, aProvider);",
             "    }",
             "  ",
             "    @Override",
             "    public Object getObject() {  ",
-            "      return provideObjectProvider.get();",
+            "      return Preconditions.checkNotNull(",
+            "          childModule.provideObject(",
+            "              injectA(",
+            "                  A_Factory.newA(",
+            "                      new NeedsDep1(DaggerParentComponent.this.dep1Provider.get()),",
+            "                      DaggerParentComponent.this.dep1Provider.get(),",
+            "                      DaggerParentComponent.this.dep2Provider.get()))),",
+            "          " + NPE_FROM_PROVIDES_METHOD + ");",
+            "    }",
+            "",
+            "    @CanIgnoreReturnValue",
+            "    private A injectA(A instance) {",
+            "      A_MembersInjector.injectMethodA(instance);",
+            "      return instance;",
             "    }",
             "  }",
             "}");
