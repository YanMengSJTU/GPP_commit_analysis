diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 97b89c9e1..fe451b7ce 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -38,32 +38,27 @@
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
-import static dagger.internal.codegen.MemberSelect.emptySetProvider;
+import static dagger.internal.codegen.MemberSelect.emptySetFactory;
 import static dagger.internal.codegen.MemberSelect.localField;
 import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
 import static dagger.internal.codegen.MemberSelect.staticMethod;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
+import static dagger.internal.codegen.SourceFiles.frameworkMapFactoryClassName;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
 import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
 import static dagger.internal.codegen.TypeNames.LISTENABLE_FUTURE;
-import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
-import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCED_PRODUCER;
-import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
-import static dagger.internal.codegen.TypeNames.MAP_PRODUCER;
-import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
 import static dagger.internal.codegen.TypeNames.PRODUCER;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER_MANAGER;
-import static dagger.internal.codegen.TypeNames.SET_FACTORY;
-import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
-import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
 import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
 import static dagger.internal.codegen.TypeNames.providerOf;
@@ -98,20 +93,13 @@
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.DelegateFactory;
 import dagger.internal.InstanceFactory;
-import dagger.internal.MapFactory;
-import dagger.internal.MapProviderFactory;
 import dagger.internal.Preconditions;
-import dagger.internal.SetFactory;
 import dagger.internal.TypedReleasableReferenceManagerDecorator;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.producers.internal.MapOfProducerProducer;
-import dagger.producers.internal.MapProducer;
-import dagger.producers.internal.SetOfProducedProducer;
-import dagger.producers.internal.SetProducer;
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
 import dagger.releasablereferences.ReleasableReferenceManager;
@@ -688,18 +676,10 @@ private boolean useRawType(Optional<String> bindingPackage) {
             && !contributionBinding.scope().isPresent()) {
           switch (contributionBinding.bindingKind()) {
             case SYNTHETIC_MULTIBOUND_MAP:
-              BindingType bindingType = contributionBinding.bindingType();
-              MapType mapType = MapType.from(contributionBinding.key());
-              return Optional.of(
-                  emptyFrameworkMapFactory(
-                      bindingType,
-                      mapType.keyType(),
-                      mapType.unwrappedValueType(bindingType.frameworkClass())));
+              return Optional.of(emptyFrameworkMapFactory(contributionBinding));
 
             case SYNTHETIC_MULTIBOUND_SET:
-              return Optional.of(
-                  emptySetFactoryStaticMemberSelect(
-                      contributionBinding.bindingType(), contributionBinding.key()));
+              return Optional.of(emptySetFactory(contributionBinding));
 
             case INJECTION:
             case PROVISION:
@@ -738,69 +718,6 @@ private boolean useRawType(Optional<String> bindingPackage) {
     return Optional.empty();
   }
 
-  /**
-   * A static member select for an empty set factory. Calls {@link SetFactory#empty()}, {@link
-   * SetProducer#empty()}, or {@link SetOfProducedProducer#empty()}, depending on the set
-   * bindings.
-   */
-  private static MemberSelect emptySetFactoryStaticMemberSelect(BindingType bindingType, Key key) {
-    return emptySetProvider(setFactoryClassName(bindingType, key), SetType.from(key));
-  }
-
-  /**
-   * The {@link Set} factory class name appropriate for set bindings.
-   *
-   * <ul>
-   * <li>{@link SetFactory} for provision bindings.
-   * <li>{@link SetProducer} for production bindings for {@code Set<T>}.
-   * <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
-   * </ul>
-   */
-  private static ClassName setFactoryClassName(BindingType bindingType, Key key) {
-    if (bindingType.equals(BindingType.PROVISION)) {
-      return SET_FACTORY;
-    } else {
-      SetType setType = SetType.from(key);
-      return setType.elementsAreTypeOf(Produced.class) ? SET_OF_PRODUCED_PRODUCER : SET_PRODUCER;
-    }
-  }
-
-  /**
-   * The {@link Map}-of-value factory class name appropriate for map bindings.
-   *
-   * <ul>
-   * <li>{@link MapFactory} for provision bindings.
-   * <li>{@link MapProducer} for production bindings.
-   * </ul>
-   */
-  private static ClassName mapFactoryClassName(ContributionBinding binding) {
-    switch (binding.bindingType()) {
-      case PRODUCTION:
-        return MapType.from(binding.key()).valuesAreTypeOf(Produced.class)
-            ? MAP_OF_PRODUCED_PRODUCER : MAP_PRODUCER;
-
-      case PROVISION:
-      case MEMBERS_INJECTION:
-        return MAP_FACTORY;
-
-      default:
-        throw new AssertionError(binding.toString());
-    }
-  }
-
-  /**
-   * The {@link Map}-of-framework factory class name appropriate for map bindings.
-   *
-   * <ul>
-   * <li>{@link MapProviderFactory} for provision bindings.
-   * <li>{@link MapOfProducerProducer} for production bindings.
-   * </ul>
-   */
-  private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
-    return bindingType.equals(BindingType.PRODUCTION)
-        ? MAP_OF_PRODUCER_PRODUCER : MAP_PROVIDER_FACTORY;
-  }
-
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
     for (ComponentMethodDescriptor componentMethod :
@@ -1337,8 +1254,7 @@ private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency)
   }
 
   private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding binding) {
-    CodeBlock.Builder builder =
-        CodeBlock.builder().add("$T.", setFactoryClassName(binding.bindingType(), binding.key()));
+    CodeBlock.Builder builder = CodeBlock.builder().add("$T.", setFactoryClassName(binding));
     boolean useRawTypes = useRawType(binding);
     if (!useRawTypes) {
       SetType setType = SetType.from(binding.key());
diff --git a/java/dagger/internal/codegen/MemberSelect.java b/java/dagger/internal/codegen/MemberSelect.java
index 97ee9845a..a99a4709a 100644
--- a/java/dagger/internal/codegen/MemberSelect.java
+++ b/java/dagger/internal/codegen/MemberSelect.java
@@ -19,9 +19,9 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.toTypeNamesCodeBlock;
+import static dagger.internal.codegen.SourceFiles.frameworkMapFactoryClassName;
+import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
 import static dagger.internal.codegen.TypeNames.FACTORY;
-import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
-import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
 
@@ -31,7 +31,6 @@
 import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
 import java.util.List;
-import java.util.Set;
 import javax.lang.model.type.TypeMirror;
 
 /**
@@ -110,41 +109,33 @@ static MemberSelect noOpMembersInjector(TypeMirror type) {
         MEMBERS_INJECTOR);
   }
 
-   /**
-   * A {@link MemberSelect} for an empty map of framework types.
-   *
-   * @param bindingType the type of the binding of the empty map
+  /**
+   * A {@link MemberSelect} for a factory of an empty map of factory types, where a factory can be
+   * either a {@link javax.inject.Provider} or {@link dagger.producers.Producer}.
    */
-  static MemberSelect emptyFrameworkMapFactory(
-      BindingType bindingType, TypeMirror keyType, TypeMirror unwrappedValueType) {
-    final ClassName frameworkMapFactoryClass;
-    switch (bindingType) {
-      case PROVISION:
-        frameworkMapFactoryClass = MAP_PROVIDER_FACTORY;
-        break;
-      case PRODUCTION:
-        frameworkMapFactoryClass = MAP_OF_PRODUCER_PRODUCER;
-        break;
-      case MEMBERS_INJECTION:
-        throw new IllegalArgumentException();
-      default:
-        throw new AssertionError();
-    }
+  static MemberSelect emptyFrameworkMapFactory(ContributionBinding contributionBinding) {
+    BindingType bindingType = contributionBinding.bindingType();
+    MapType mapType = MapType.from(contributionBinding.key());
+
     return new ParameterizedStaticMethod(
-        frameworkMapFactoryClass,
-        ImmutableList.of(keyType, unwrappedValueType),
+        frameworkMapFactoryClassName(bindingType),
+        ImmutableList.of(
+            mapType.keyType(), mapType.unwrappedValueType(bindingType.frameworkClass())),
         CodeBlock.of("empty()"),
         ClassName.get(bindingType.frameworkClass()));
   }
 
   /**
-   * Returns the {@link MemberSelect} for an empty set provider.  Since there are several different
-   * implementations for a multibound {@link Set}, the caller is responsible for passing the
-   * correct factory.
+   * A static member select for an empty set factory. Calls {@link
+   * dagger.internal.SetFactory#empty()}, {@link dagger.producers.internal.SetProducer#empty()}, or
+   * {@link dagger.producers.internal.SetOfProducedProducer#empty()}, depending on the set bindings.
    */
-  static MemberSelect emptySetProvider(ClassName setFactoryType, SetType setType) {
+  static MemberSelect emptySetFactory(ContributionBinding binding) {
     return new ParameterizedStaticMethod(
-        setFactoryType, ImmutableList.of(setType.elementType()), CodeBlock.of("empty()"), FACTORY);
+        setFactoryClassName(binding),
+        ImmutableList.of(SetType.from(binding.key()).elementType()),
+        CodeBlock.of("empty()"),
+        FACTORY);
   }
 
   private static final class ParameterizedStaticMethod extends MemberSelect {
diff --git a/java/dagger/internal/codegen/SourceFiles.java b/java/dagger/internal/codegen/SourceFiles.java
index 0fcde5c0c..42fd91006 100644
--- a/java/dagger/internal/codegen/SourceFiles.java
+++ b/java/dagger/internal/codegen/SourceFiles.java
@@ -21,9 +21,18 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_SET;
 import static dagger.internal.codegen.Optionals.optionalComparator;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
+import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
+import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCED_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
 import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
+import static dagger.internal.codegen.TypeNames.SET_FACTORY;
+import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
+import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
 import static dagger.internal.codegen.Util.toImmutableList;
 import static java.util.Comparator.comparing;
 import static javax.lang.model.SourceVersion.isName;
@@ -40,6 +49,14 @@
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
+import dagger.internal.MapFactory;
+import dagger.internal.MapProviderFactory;
+import dagger.internal.SetFactory;
+import dagger.producers.Produced;
+import dagger.producers.internal.MapOfProducerProducer;
+import dagger.producers.internal.MapProducer;
+import dagger.producers.internal.SetOfProducedProducer;
+import dagger.producers.internal.SetProducer;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
@@ -213,6 +230,60 @@ private static ClassName siblingClassName(TypeElement typeElement, String suffix
     return className.topLevelClassName().peerClass(classFileName(className) + suffix);
   }
 
+  /**
+   * The {@link java.util.Set} factory class name appropriate for set bindings.
+   *
+   * <ul>
+   * <li>{@link SetFactory} for provision bindings.
+   * <li>{@link SetProducer} for production bindings for {@code Set<T>}.
+   * <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
+   * </ul>
+   */
+  static ClassName setFactoryClassName(ContributionBinding binding) {
+    checkArgument(binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_SET));
+    if (binding.bindingType().equals(BindingType.PROVISION)) {
+      return SET_FACTORY;
+    } else {
+      SetType setType = SetType.from(binding.key());
+      return setType.elementsAreTypeOf(Produced.class) ? SET_OF_PRODUCED_PRODUCER : SET_PRODUCER;
+    }
+  }
+
+  /**
+   * The {@link java.util.Map}-of-value factory class name appropriate for map bindings.
+   *
+   * <ul>
+   * <li>{@link MapFactory} for provision bindings.
+   * <li>{@link MapProducer} for production bindings.
+   * </ul>
+   */
+  static ClassName mapFactoryClassName(ContributionBinding binding) {
+    switch (binding.bindingType()) {
+      case PRODUCTION:
+        return MapType.from(binding.key()).valuesAreTypeOf(Produced.class)
+            ? MAP_OF_PRODUCED_PRODUCER : MAP_PRODUCER;
+
+      case PROVISION:
+        return MAP_FACTORY;
+
+      default:
+        throw new AssertionError(binding.toString());
+    }
+  }
+
+  /**
+   * The {@link java.util.Map}-of-framework factory class name appropriate for map bindings.
+   *
+   * <ul>
+   * <li>{@link MapProviderFactory} for provision bindings.
+   * <li>{@link MapOfProducerProducer} for production bindings.
+   * </ul>
+   */
+  static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
+    return bindingType.equals(BindingType.PRODUCTION)
+        ? MAP_OF_PRODUCER_PRODUCER : MAP_PROVIDER_FACTORY;
+  }
+
   private static String factoryPrefix(ContributionBinding binding) {
     switch (binding.bindingKind()) {
       case INJECTION:
