diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index cc4889677..0784a92bf 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -377,6 +377,7 @@
         "  }",
         "",
         "  @Override public Map<String, String> strings() {",
+        "     "
         "    return mapOfStringProvider.get();",
         "  }",
         "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
new file mode 100644
index 000000000..1e4926a5a
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+
+import javax.tools.JavaFileObject;
+
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+
+/**
+ * TODO: Insert description here. (generated by houcy)
+ */
+@RunWith(JUnit4.class)
+public class MapBindingComponentProcessorTest {
+  @Test public void mapBindingsFramework() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "");
+    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "");
+    ASSERT.about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile, mapModuleTwoFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+  
+  @Ignore @Test public void mapBindingsWithEnumKey() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @EnumKey(Admin) Handler provideAdminHandler() { return new AdminHandler(); }",
+        "}");
+    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @EnumKey(Login) Handler provideLoginHandler() { return new LoginHandler(); }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.EnumKey", 
+        "package test;",
+        "",
+        "@MapKey",
+        "public @interface EnumKey {",
+        "  enum PathEnum {",
+        "    Admin(\"/admin\"),",
+        "    Login(\"/login\");",
+        "    private final String path;",
+        "    PathEnum(String path) {",
+        "      this.path = path;",
+        "    }",
+        "  }",
+        "  PathEnum value();",
+        "}");
+    JavaFileObject enumKeyFileTwo = JavaFileObjects.forSourceLines("test.EnumKey", 
+        "package test;",
+        "",
+        "@MapKey",
+        "public @interface EnumKey {",
+        "  PathEnum value();",  // Or Enum value(); using annotationMirror to obtain the concrete value, compile reflection
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.pathEnumFile", 
+        "package test:",
+        "",
+        "public enum PathEnum {",
+        "    Admin(\"/admin\"),",
+        "    Login(\"/login\");",
+        "    private final String path;",
+        "    PathEnum(String path) {",
+        "      this.path = path;",
+        "    }");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<EnumKey.PathEnum, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModuleOne mapModuleOne;",
+        "  private final MapModuleTwo mapModuleTwo;",
+        "  private final Provider<Map<EnumKey.PathEnum, Provider<Handler>>> mapOfEnumHandlerProvider;",
+        "",
+        "  public Dagger_TestComponent(MapModuleOne mapModuleOne, MapModuleTwo mapModuleTwo) {",
+        "    if (mapModuleOne == null) {",
+        "      throw new NullPointerException(\"mapModuleOne\");",
+        "    }",
+        "    this.mapModuleOne = mapModuleOne;",
+        "    if (mapModuletwo == null) {",
+        "      throw new NullPointerException(\"mapModuleTwo\");",
+        "    }",
+        "    this.mapModuleTwo = mapModuleTwo;",
+        "    this.mapOfEnumHandlerProvider = MapFactoryFactory.build()",
+        "        .put(Admin(\"/admin\"), new ProviderAdminHandlerFactory(mapModuleOne))",
+        "        .put(Login(\"/login\"), new ProviderLoginHandlerFactory(mapModuleTwo));",
+        "  }",
+        "",
+        "  @Override public Map<EnumKey.PathEnum, Provider<Handler>> dispatcher() {",
+        //add if else to return map<k, v> or map<k, provider<v>> 
+        "    return mapOfEnumHandlerProvider.get();",
+        "  }",
+        "}");
+    ASSERT.about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile, mapModuleTwoFile, enumKeyFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+  
+  @Ignore @Test public void mapBindingsWithStringKey() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @StringKey(\"admin\") Handler provideAdminHandler() { return new AdminHandler(); }",
+        "}");
+    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @StringKey(\"login\") Handler provideLoginHandler() { return new LoginHandler(); }",
+        "}");
+    JavaFileObject stringKeyFile = JavaFileObjects.forSourceLines("test.StringKey", 
+        "package test;",
+        "",
+        "@MapKey",
+        "public @interface StringKey {",
+        "  String value();",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<String, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModuleOne mapModuleOne;",
+        "  private final MapModuleTwo mapModuleTwo;",
+        "  private final Provider<Map<EnumKey.PathEnum, Provider<Handler>>> mapOfStringHandlerProvider;",
+        "",
+        "  public Dagger_TestComponent(MapModuleOne mapModuleOne, MapModuleTwo mapModuleTwo) {",
+        "    if (mapModuleOne == null) {",
+        "      throw new NullPointerException(\"mapModuleOne\");",
+        "    }",
+        "    this.mapModuleOne = mapModuleOne;",
+        "    if (mapModuletwo == null) {",
+        "      throw new NullPointerException(\"mapModuleTwo\");",
+        "    }",
+        "    this.mapModuleTwo = mapModuleTwo;",
+        "    this.mapOfStringHandlerProvider = MapFactoryFactory.build()",
+        "        .put(\"admin\", new ProviderAdminHandlerFactory(mapModuleOne))",
+        "        .put(\"login\", new ProviderLoginHandlerFactory(mapModuleTwo));",
+        "  }",
+        "",
+        "  @Override public Map<String, Provider<Handler>> dispatcher() {",
+        //add if else to return map<k, v> or map<k, provider<v>> 
+        "    return mapOfStringHandlerProvider.get();",
+        "  }",
+        "}");
+    ASSERT.about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile, mapModuleTwoFile, stringKeyFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingModuleProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingModuleProcessorTest.java
new file mode 100644
index 000000000..3ff68daf8
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingModuleProcessorTest.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+
+import javax.tools.JavaFileObject;
+
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+/**
+ * TODO: Insert description here. (generated by houcy)
+ */
+public class MapBindingModuleProcessorTest {
+  @Ignore @Test public void proviesValueWithEnumKey() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @EnumKey(Admin) Handler provideAdminHandler() { return new AdminHandler(); }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.EnumKey", 
+        "package test;",
+        "",
+        "@MapKey",
+        "public @interface EnumKey {",
+        "  enum PathEnum {",
+        "    Admin(\"/admin\"),",
+        "    Login(\"/login\");",
+        "    private final String path;",
+        "    PathEnum(String path) {",
+        "      this.path = path;",
+        "    }",
+        "  }",
+        "  PathEnum value();",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProvideAdminHandlerFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProvideAdminHandlerFactory implements Factory<Handler> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule$$ProvideLoginHandlerFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        //or @Provides(type = MAP) @EnumKey(Admin) public Handler get() {}
+        "  @Override public Handler get() {",
+        "    return module.provideAdminHandler();",
+        "  }",
+        "}");
+    ASSERT.about(javaSource())
+        .that((JavaFileObject) ImmutableList.of(moduleFile, enumKeyFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Ignore @Test public void proviesValueWithStringKey() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @StringKey(\"login\") Handler provideLoginHandler() { return new LoginHandler(); }",
+        "}");
+    JavaFileObject stringKeyFile = JavaFileObjects.forSourceLines("test.StringKey", 
+        "package test;",
+        "",
+        "@MapKey",
+        "public @interface StringKey {",
+        "  String value();",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProvideLoginHandlerFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProvideLoginHandlerFactory implements Factory<Handler> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule$$ProvideLoginHandlerFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public Handler get() {",
+        "    return module.provideLoginHandler();",
+        "  }",
+        "}");
+    ASSERT.about(javaSource())
+        .that((JavaFileObject) ImmutableList.of(moduleFile, stringKeyFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+}
diff --git a/examples/simple/src/main/java/coffee/ForPath.java b/examples/simple/src/main/java/coffee/ForPath.java
new file mode 100644
index 000000000..c42a3c42a
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/ForPath.java
@@ -0,0 +1,17 @@
+package coffee;
+
+/**
+ * TODO: Insert description here. (generated by houcy)
+ */
+@MapKey
+public @interface ForPath {
+  enum PathEnum{
+    Admin("/admin"),
+    Login("/login");
+    private final String path;
+    PathEnum(String path) {
+      this.path = path;
+    }
+  }
+  PathEnum value();
+} 
