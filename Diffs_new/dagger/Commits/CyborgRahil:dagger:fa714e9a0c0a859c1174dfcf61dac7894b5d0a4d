diff --git a/java/dagger/internal/codegen/ComponentCreatorDescriptor.java b/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
index f5ac8c214..8846faaaf 100644
--- a/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
@@ -55,21 +55,21 @@
    */
   abstract ImmutableSetMultimap<ComponentRequirement, ExecutableElement> requirementElements();
 
-  /** Returns the set of component requirements this creator can set. */
-  final ImmutableSet<ComponentRequirement> settableRequirements() {
+  /** Returns the set of component requirements this creator allows the user to set. */
+  final ImmutableSet<ComponentRequirement> userSettableRequirements() {
     return requirementElements().keySet();
   }
 
   /** Returns the set of requirements for modules and component dependencies for this creator. */
   final ImmutableSet<ComponentRequirement> moduleAndDependencyRequirements() {
-    return settableRequirements().stream()
+    return userSettableRequirements().stream()
         .filter(requirement -> !requirement.isBoundInstance())
         .collect(toImmutableSet());
   }
 
   /** Returns the set of bound instance requirements for this creator. */
   final ImmutableSet<ComponentRequirement> boundInstanceRequirements() {
-    return settableRequirements().stream()
+    return userSettableRequirements().stream()
         .filter(requirement -> requirement.isBoundInstance())
         .collect(toImmutableSet());
   }
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementation.java b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
index 4a5d218ba..a5eb68034 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementation.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
@@ -18,7 +18,6 @@
 
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.TypeSpec;
@@ -31,9 +30,8 @@
   static ComponentCreatorImplementation create(
       TypeSpec spec,
       ClassName name,
-      ImmutableSet<ComponentRequirement> providedRequirements,
       ImmutableMap<ComponentRequirement, FieldSpec> fields) {
-    return new AutoValue_ComponentCreatorImplementation(spec, name, providedRequirements, fields);
+    return new AutoValue_ComponentCreatorImplementation(spec, name, fields);
   }
 
   /** The type spec for the creator implementation. */
@@ -42,15 +40,6 @@ static ComponentCreatorImplementation create(
   /** The name of the creator implementation class. */
   abstract ClassName name();
 
-  /**
-   * The component requirements this creator provides instances for when calling the component's
-   * constructor.
-   *
-   * <p>Instances will be passed to the  constructor in the same order the requirements are returned
-   * here.
-   */
-  abstract ImmutableSet<ComponentRequirement> providedRequirements();
-
   /**
    * All fields that are present in this implementation or its supertype.
    *
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
index ad1b70c23..08b192d4a 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
@@ -17,13 +17,13 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
-import static dagger.internal.codegen.ModuleProxies.newModuleInstance;
 import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -34,7 +34,6 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
@@ -47,6 +46,7 @@
 import dagger.internal.Preconditions;
 import dagger.internal.codegen.ComponentRequirement.NullPolicy;
 import java.util.Optional;
+import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -109,8 +109,7 @@ ComponentCreatorImplementation build() {
       addConstructor();
       addSetterMethods();
       addFactoryMethod();
-      return ComponentCreatorImplementation.create(
-          classBuilder.build(), className, providedRequirements(), fields);
+      return ComponentCreatorImplementation.create(classBuilder.build(), className, fields);
     }
 
     /** Returns the binding graph for the component. */
@@ -119,17 +118,21 @@ final BindingGraph graph() {
     }
 
     /**
-     * The component requirements that this creator will actually provide when constructing a
+     * The {@link ComponentRequirement}s that this creator allows users to set. Values are a status
+     * for each requirement indicating what's needed for that requirement in the implementation
+     * class currently being generated.
+     */
+    abstract ImmutableMap<ComponentRequirement, RequirementStatus> userSettableRequirements();
+
+    /**
+     * Component requirements that are both settable by the creator and needed to construct the
      * component.
      */
-    final ImmutableSet<ComponentRequirement> providedRequirements() {
-      return Sets.intersection(fields.keySet(), componentImplementation.requirements())
-          .immutableCopy();
+    private Set<ComponentRequirement> neededUserSettableRequirements() {
+      return Sets.intersection(
+          userSettableRequirements().keySet(), componentImplementation.requirements());
     }
 
-    /** The {@link ComponentRequirement}s that this creator can set. */
-    abstract ImmutableMap<ComponentRequirement, RequirementStatus> settableRequirements();
-
     private void setModifiers() {
       classBuilder.addModifiers(visibility());
       if (!componentImplementation.isNested()) {
@@ -162,7 +165,7 @@ private void setModifiers() {
       UniqueNameSet fieldNames = new UniqueNameSet();
       ImmutableMap<ComponentRequirement, FieldSpec> result =
           Maps.toMap(
-              componentImplementation.requirements(),
+              neededUserSettableRequirements(),
               requirement ->
                   FieldSpec.builder(
                           TypeName.get(requirement.type()),
@@ -174,7 +177,7 @@ private void setModifiers() {
     }
 
     private void addSetterMethods() {
-      settableRequirements()
+      userSettableRequirements()
           .forEach(
               (requirement, status) ->
                   createSetterMethod(requirement, status).ifPresent(classBuilder::addMethod));
@@ -254,34 +257,31 @@ MethodSpec factoryMethod() {
       MethodSpec.Builder factoryMethod = factoryMethodBuilder();
       factoryMethod.returns(ClassName.get(graph().componentTypeElement())).addModifiers(PUBLIC);
 
-      providedRequirements().forEach(
-          requirement -> {
-            FieldSpec field = fields.get(requirement);
-            switch (requirement.nullPolicy(elements, types)) {
-              case NEW:
-                checkState(requirement.kind().isModule());
-                factoryMethod
-                    .beginControlFlow("if ($N == null)", field)
-                    .addStatement(
-                        "this.$N = $L",
+      neededUserSettableRequirements()
+          .forEach(
+              requirement -> {
+                FieldSpec field = fields.get(requirement);
+                switch (requirement.nullPolicy(elements, types)) {
+                  case NEW:
+                    checkState(requirement.kind().isModule());
+                    factoryMethod
+                        .beginControlFlow("if ($N == null)", field)
+                        .addStatement("this.$N = $L", field, newModuleInstance(requirement))
+                        .endControlFlow();
+                    break;
+                  case THROW:
+                    // TODO(cgdecker,ronshapiro): ideally this should use the key instead of a class
+                    // for @BindsInstance requirements, but that's not easily proguardable.
+                    factoryMethod.addStatement(
+                        "$T.checkBuilderRequirement($N, $T.class)",
+                        Preconditions.class,
                         field,
-                        newModuleInstance(
-                            requirement.typeElement(), componentImplementation.name(), elements))
-                    .endControlFlow();
-                break;
-              case THROW:
-                // TODO(cgdecker,ronshapiro): ideally this should use the key instead of a class for
-                // @BindsInstance requirements, but that's not easily proguardable.
-                factoryMethod.addStatement(
-                    "$T.checkBuilderRequirement($N, $T.class)",
-                    Preconditions.class,
-                    field,
-                    TypeNames.rawTypeName(field.type));
-                break;
-              case ALLOW:
-                break;
-            }
-          });
+                        TypeNames.rawTypeName(field.type));
+                    break;
+                  case ALLOW:
+                    break;
+                }
+              });
       factoryMethod.addStatement(
           "return new $T($L)", componentImplementation.name(), componentConstructorArgs());
       return factoryMethod.build();
@@ -291,11 +291,19 @@ MethodSpec factoryMethod() {
     protected abstract MethodSpec.Builder factoryMethodBuilder();
 
     private CodeBlock componentConstructorArgs() {
-      return providedRequirements().stream()
-          .map(fields::get)
-          .map(field -> CodeBlock.of("$N", field))
+      return componentImplementation.requirements().stream()
+          .map(
+              requirement ->
+                  fields.containsKey(requirement)
+                      ? CodeBlock.of("$N", fields.get(requirement))
+                      : newModuleInstance(requirement))
           .collect(toParametersCodeBlock());
     }
+
+    private CodeBlock newModuleInstance(ComponentRequirement requirement) {
+      checkArgument(requirement.kind().isModule()); // this should be guaranteed to be true here
+      return ModuleProxies.newModuleInstance(requirement.typeElement(), className, elements);
+    }
   }
 
   /** Builder for a creator type defined by a {@code ComponentCreatorDescriptor}. */
@@ -309,8 +317,8 @@ private CodeBlock componentConstructorArgs() {
     }
 
     @Override
-    protected ImmutableMap<ComponentRequirement, RequirementStatus> settableRequirements() {
-      return Maps.toMap(creatorDescriptor.settableRequirements(), this::requirementStatus);
+    protected ImmutableMap<ComponentRequirement, RequirementStatus> userSettableRequirements() {
+      return Maps.toMap(creatorDescriptor.userSettableRequirements(), this::requirementStatus);
     }
 
     @Override
@@ -416,7 +424,7 @@ private boolean hasBaseCreatorImplementation() {
     }
 
     @Override
-    protected ImmutableMap<ComponentRequirement, RequirementStatus> settableRequirements() {
+    protected ImmutableMap<ComponentRequirement, RequirementStatus> userSettableRequirements() {
       return Maps.toMap(
           graph().componentDescriptor().dependenciesAndConcreteModules(),
           requirement -> componentImplementation.requirements().contains(requirement)
diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index 8b4022ae6..de55350ba 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -561,9 +561,7 @@ private void addInitializeMethods(
     Map<ComponentRequirement, ParameterSpec> parameters;
     if (creatorImplementation.isPresent()) {
       parameters =
-          Maps.toMap(
-              creatorImplementation.get().providedRequirements(),
-              ComponentRequirement::toParameterSpec);
+          Maps.toMap(componentImplementation.requirements(), ComponentRequirement::toParameterSpec);
     } else if (componentImplementation.isAbstract() && componentImplementation.isNested()) {
       // If we're generating an abstract inner subcomponent, then we are not implementing module
       // instance bindings and have no need for factory method parameters.
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index f5147826c..b1b0d3752 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -3162,9 +3162,9 @@ public void subcomponentBuilders() {
             "  }",
             "",
             "  public abstract static class Builder implements Leaf.Builder {",
-            "    protected LeafModule leafModule;",
             "    protected Integer bindsInstance;",
             "    protected String inducedInSubclass;",
+            "    protected LeafModule leafModule;",
             "",
             "    @Override",
             "    public Builder bindsInstance(int boundInstance) {",
@@ -3326,9 +3326,9 @@ public void subcomponentBuilders() {
             // builder so that the contents of this method are just call to that and then new
             // FooImpl? But repeated modules may make this more complicated, since those *should*
             // be null
-            "        Preconditions.checkBuilderRequirement(leafModule, LeafModule.class);",
             "        Preconditions.checkBuilderRequirement(bindsInstance, Integer.class);",
             "        Preconditions.checkBuilderRequirement(inducedInSubclass, String.class);",
+            "        Preconditions.checkBuilderRequirement(leafModule, LeafModule.class);",
             "        return new LeafImpl(leafModule, bindsInstance, inducedInSubclass);",
             "      }",
             "    }",
@@ -3403,6 +3403,8 @@ public void subcomponentBuilders_moduleWithUnusedInstanceBindings() {
             "",
             "  @Subcomponent.Builder",
             "  interface Builder {",
+            "    Builder setUsed(ModuleWithUsedBinding module);",
+            "    Builder setUnused(ModuleWithUnusedBinding module);",
             "    Leaf build();",
             "  }",
             "}"));
@@ -3412,6 +3414,7 @@ public void subcomponentBuilders_moduleWithUnusedInstanceBindings() {
             "package test;",
             "",
             "import dagger.internal.GenerationOptions;",
+            "import dagger.internal.Preconditions;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATION_OPTIONS_ANNOTATION,
@@ -3439,6 +3442,18 @@ public void subcomponentBuilders_moduleWithUnusedInstanceBindings() {
             "  public abstract static class Builder implements Leaf.Builder {",
             "    protected ModuleWithUsedBinding moduleWithUsedBinding;",
             "    protected ModuleWithUnusedBinding moduleWithUnusedBinding;",
+            "",
+            "    @Override",
+            "    public Builder setUsed(ModuleWithUsedBinding module) {",
+            "      this.moduleWithUsedBinding = Preconditions.checkNotNull(module);",
+            "      return this;",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder setUnused(ModuleWithUnusedBinding module) {",
+            "      this.moduleWithUnusedBinding = Preconditions.checkNotNull(module);",
+            "      return this;",
+            "    }",
             "  }",
             "}");
     Compilation compilation = compile(filesToCompile.build());
@@ -4871,6 +4886,9 @@ public void componentBuilderFields_consistencyAcrossImplementations() {
             "",
             "  @Subcomponent.Builder",
             "  interface Builder {",
+            "    Builder setAMod(a.Mod mod);",
+            "    Builder setBMod(b.Mod mod);",
+            "    Builder setCMod(c.Mod mod);",
             "    HasUnusedModuleLeaf build();",
             "  }",
             "}"));
@@ -4887,9 +4905,7 @@ public void componentBuilderFields_consistencyAcrossImplementations() {
             "public abstract class DaggerHasUnusedModuleLeaf implements HasUnusedModuleLeaf {",
             "  public abstract static class Builder implements HasUnusedModuleLeaf.Builder {",
             "    protected Mod mod;",
-            "",
             "    protected b.Mod mod2;",
-            "",
             "    protected c.Mod mod3;",
             "  }",
             "}");
diff --git a/javatests/dagger/internal/codegen/ComponentBuilderTest.java b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
index 90f4e737f..0552b3bbe 100644
--- a/javatests/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
@@ -252,7 +252,6 @@ public void testIgnoresModulesNotInApi() {
             "",
             "  private static final class Builder implements TestComponent.Builder {",
             "    private TestModule1 testModule1;",
-            "    private TestModule2 testModule2;",
             "",
             "    @Override",
             "    public Builder testModule1(TestModule1 testModule1) {",
@@ -265,10 +264,7 @@ public void testIgnoresModulesNotInApi() {
             "      if (testModule1 == null) {",
             "        this.testModule1 = new TestModule1();",
             "      }",
-            "      if (testModule2 == null) {",
-            "        this.testModule2 = new TestModule2();",
-            "      }",
-            "      return new DaggerTestComponent(testModule1, testModule2);",
+            "      return new DaggerTestComponent(testModule1, new TestModule2());",
             "    }",
             "  }",
             "}");
