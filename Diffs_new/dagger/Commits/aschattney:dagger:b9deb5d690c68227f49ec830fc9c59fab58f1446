diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index d73610196..0af8aa7a0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -114,6 +114,7 @@
 import dagger.releasablereferences.ForReleasableReferences;
 import dagger.releasablereferences.ReleasableReferenceManager;
 import dagger.releasablereferences.TypedReleasableReferenceManager;
+
 import java.util.Arrays;
 import java.util.EnumSet;
 import java.util.HashMap;
@@ -134,823 +135,829 @@
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
-/** Creates the implementation class for a component or subcomponent. */
+/**
+ * Creates the implementation class for a component or subcomponent.
+ */
 abstract class AbstractComponentWriter implements HasBindingMembers {
-  private static final String NOOP_BUILDER_METHOD_JAVADOC =
-      "This module is declared, but an instance is not used in the component. This method is a "
-          + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
-
-  // TODO(dpb): Make all these fields private after refactoring is complete.
-  protected final Elements elements;
-  protected final Types types;
-  protected final Key.Factory keyFactory;
-  protected final CompilerOptions compilerOptions;
-  private boolean forTests;
-  protected final ClassName name;
-  protected final BindingGraph graph;
-  protected final ImmutableMap<ComponentDescriptor, String> subcomponentNames;
-  private final Map<BindingKey, InitializationState> initializationStates = new HashMap<>();
-  protected final TypeSpec.Builder component;
-  private final UniqueNameSet componentFieldNames = new UniqueNameSet();
-  private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
-  private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
-  private final RequestFulfillmentRegistry requestFulfillmentRegistry;
-  protected final MethodSpec.Builder constructor = constructorBuilder();
-  protected Optional<ClassName> builderName = Optional.empty();
-  private Map<Key, String> delegateFieldNames = new HashMap<>();
-  private Map<Key, String> mockFieldNames = new HashMap<>();
-  private final OptionalFactories optionalFactories;
-  private boolean done;
-
-  /**
-   * For each component requirement, the builder field. This map is empty for subcomponents that do
-   * not use a builder.
-   */
-  private ImmutableMap<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.of();
-
-  /**
-   * For each component requirement, the member select for the component field that holds it.
-   *
-   * <p>Fields are written for all requirements for subcomponents that do not use a builder, and for
-   * any requirement that is reused from a subcomponent of this component.
-   */
-  protected final Map<ComponentRequirement, MemberSelect> componentContributionFields =
-      Maps.newHashMap();
-
-  /**
-   * The member-selects for {@link dagger.internal.ReferenceReleasingProviderManager} fields,
-   * indexed by their {@link CanReleaseReferences @CanReleaseReferences} scope.
-   */
-  private ImmutableMap<Scope, MemberSelect> referenceReleasingProviderManagerFields;
-  private List<MethodSpec> initializationMethods;
-
-  AbstractComponentWriter(
-      Types types,
-      Elements elements,
-      Key.Factory keyFactory,
-      CompilerOptions compilerOptions,
-      ClassName name,
-      BindingGraph graph,
-      ImmutableMap<ComponentDescriptor, String> subcomponentNames,
-      OptionalFactories optionalFactories,
-      boolean forTests) {
-    this.types = types;
-    this.elements = elements;
-    this.keyFactory = keyFactory;
-    this.compilerOptions = compilerOptions;
-    this.forTests = forTests;
-    this.component = classBuilder(name);
-    this.name = name;
-    this.graph = graph;
-    this.subcomponentNames = subcomponentNames;
-    this.optionalFactories = optionalFactories;
-    this.requestFulfillmentRegistry =
-        new RequestFulfillmentRegistry(graph.resolvedBindings(), this);
-  }
-
-  protected AbstractComponentWriter(
-      AbstractComponentWriter parent, ClassName name, BindingGraph graph, boolean forTests) {
-    this(
-        parent.types,
-        parent.elements,
-        parent.keyFactory,
-        parent.compilerOptions,
-        name,
-        graph,
-        parent.subcomponentNames,
-        parent.optionalFactories,
-        forTests
-    );
-  }
-
-  protected final ClassName componentDefinitionTypeName() {
-    return ClassName.get(graph.componentType());
-  }
-
-  /**
-   * Returns an expression that evaluates to an instance of the requirement, looking for either a
-   * builder field or a component field.
-   */
-  private CodeBlock getComponentContributionExpression(ComponentRequirement componentRequirement) {
-    if (builderFields.containsKey(componentRequirement)) {
-      return CodeBlock.of("builder.$N", builderFields.get(componentRequirement));
-    } else {
-      Optional<CodeBlock> codeBlock =
-          getOrCreateComponentRequirementFieldExpression(componentRequirement);
-      checkState(
-          codeBlock.isPresent(), "no builder or component field for %s", componentRequirement);
-      return codeBlock.get();
-    }
-  }
-
-  /**
-   * Returns an expression for a component requirement field. Adds a field the first time one is
-   * requested for a requirement if this component's builder has a field for it.
-   */
-  protected Optional<CodeBlock> getOrCreateComponentRequirementFieldExpression(
-      ComponentRequirement componentRequirement) {
-    MemberSelect fieldSelect = componentContributionFields.get(componentRequirement);
-    if (fieldSelect == null) {
-      if (!builderFields.containsKey(componentRequirement)) {
+    private static final String NOOP_BUILDER_METHOD_JAVADOC =
+            "This module is declared, but an instance is not used in the component. This method is a "
+                    + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
+
+    // TODO(dpb): Make all these fields private after refactoring is complete.
+    protected final Elements elements;
+    protected final Types types;
+    protected final Key.Factory keyFactory;
+    protected final CompilerOptions compilerOptions;
+    private boolean forTests;
+    protected final ClassName name;
+    protected final BindingGraph graph;
+    protected final ImmutableMap<ComponentDescriptor, String> subcomponentNames;
+    private final Map<BindingKey, InitializationState> initializationStates = new HashMap<>();
+    protected final TypeSpec.Builder component;
+    private final UniqueNameSet componentFieldNames = new UniqueNameSet();
+    private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
+    private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
+    private final RequestFulfillmentRegistry requestFulfillmentRegistry;
+    protected final MethodSpec.Builder constructor = constructorBuilder();
+    protected Optional<ClassName> builderName = Optional.empty();
+    private Map<Key, String> delegateFieldNames = new HashMap<>();
+    private Map<Key, String> mockFieldNames = new HashMap<>();
+    private final OptionalFactories optionalFactories;
+    private boolean done;
+
+    /**
+     * For each component requirement, the builder field. This map is empty for subcomponents that do
+     * not use a builder.
+     */
+    private ImmutableMap<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.of();
+
+    /**
+     * For each component requirement, the member select for the component field that holds it.
+     * <p>
+     * <p>Fields are written for all requirements for subcomponents that do not use a builder, and for
+     * any requirement that is reused from a subcomponent of this component.
+     */
+    protected final Map<ComponentRequirement, MemberSelect> componentContributionFields =
+            Maps.newHashMap();
+
+    /**
+     * The member-selects for {@link dagger.internal.ReferenceReleasingProviderManager} fields,
+     * indexed by their {@link CanReleaseReferences @CanReleaseReferences} scope.
+     */
+    private ImmutableMap<Scope, MemberSelect> referenceReleasingProviderManagerFields;
+    private List<MethodSpec> initializationMethods;
+
+    AbstractComponentWriter(
+            Types types,
+            Elements elements,
+            Key.Factory keyFactory,
+            CompilerOptions compilerOptions,
+            ClassName name,
+            BindingGraph graph,
+            ImmutableMap<ComponentDescriptor, String> subcomponentNames,
+            OptionalFactories optionalFactories,
+            boolean forTests) {
+        this.types = types;
+        this.elements = elements;
+        this.keyFactory = keyFactory;
+        this.compilerOptions = compilerOptions;
+        this.forTests = forTests;
+        this.component = classBuilder(name);
+        this.name = name;
+        this.graph = graph;
+        this.subcomponentNames = subcomponentNames;
+        this.optionalFactories = optionalFactories;
+        this.requestFulfillmentRegistry =
+                new RequestFulfillmentRegistry(graph.resolvedBindings(), this);
+    }
+
+    protected AbstractComponentWriter(
+            AbstractComponentWriter parent, ClassName name, BindingGraph graph, boolean forTests) {
+        this(
+                parent.types,
+                parent.elements,
+                parent.keyFactory,
+                parent.compilerOptions,
+                name,
+                graph,
+                parent.subcomponentNames,
+                parent.optionalFactories,
+                forTests
+        );
+    }
+
+    protected final ClassName componentDefinitionTypeName() {
+        return ClassName.get(graph.componentType());
+    }
+
+    /**
+     * Returns an expression that evaluates to an instance of the requirement, looking for either a
+     * builder field or a component field.
+     */
+    private CodeBlock getComponentContributionExpression(ComponentRequirement componentRequirement) {
+        if (builderFields.containsKey(componentRequirement)) {
+            return CodeBlock.of("builder.$N", builderFields.get(componentRequirement));
+        } else {
+            Optional<CodeBlock> codeBlock =
+                    getOrCreateComponentRequirementFieldExpression(componentRequirement);
+            checkState(
+                    codeBlock.isPresent(), "no builder or component field for %s", componentRequirement);
+            return codeBlock.get();
+        }
+    }
+
+    /**
+     * Returns an expression for a component requirement field. Adds a field the first time one is
+     * requested for a requirement if this component's builder has a field for it.
+     */
+    protected Optional<CodeBlock> getOrCreateComponentRequirementFieldExpression(
+            ComponentRequirement componentRequirement) {
+        MemberSelect fieldSelect = componentContributionFields.get(componentRequirement);
+        if (fieldSelect == null) {
+            if (!builderFields.containsKey(componentRequirement)) {
+                return Optional.empty();
+            }
+            FieldSpec componentField =
+                    componentField(
+                            TypeName.get(componentRequirement.type()),
+                            simpleVariableName(componentRequirement.typeElement()))
+                            .addModifiers(PRIVATE, FINAL)
+                            .build();
+            component.addField(componentField);
+            constructor.addCode(
+                    "this.$N = builder.$N;", componentField, builderFields.get(componentRequirement));
+            fieldSelect = localField(name, componentField.name);
+            componentContributionFields.put(componentRequirement, fieldSelect);
+        }
+        return Optional.of(fieldSelect.getExpressionFor(name));
+    }
+
+    /**
+     * Creates a {@link FieldSpec.Builder} with a unique name based off of {@code name}.
+     */
+    protected final FieldSpec.Builder componentField(TypeName type, String name) {
+        return FieldSpec.builder(type, componentFieldNames.getUniqueName(name));
+    }
+
+    protected CodeBlock getMemberSelectExpression(BindingKey key) {
+        return getMemberSelect(key).getExpressionFor(name);
+    }
+
+    @Override
+    public MemberSelect getMemberSelect(BindingKey key) {
+        return memberSelects.get(key);
+    }
+
+    /**
+     * Returns the initialization state of the factory field for a binding key in this component.
+     */
+    protected InitializationState getInitializationState(BindingKey bindingKey) {
+        return initializationStates.containsKey(bindingKey)
+                ? initializationStates.get(bindingKey)
+                : UNINITIALIZED;
+    }
+
+    private void setInitializationState(BindingKey bindingKey, InitializationState state) {
+        initializationStates.put(bindingKey, state);
+    }
+
+    /**
+     * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
+     * object for a scope.
+     */
+    protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
+        return referenceReleasingProviderManagerFields.get(scope).getExpressionFor(name);
+    }
+
+    /**
+     * Constructs a {@link TypeSpec.Builder} that models the {@link BindingGraph} for this component.
+     * This is only intended to be called once (and will throw on successive invocations). If the
+     * component must be regenerated, use a new instance.
+     */
+    final TypeSpec.Builder write() {
+        checkState(!done, "ComponentWriter has already been generated.");
+        decorateComponent();
+        addBuilder();
+        addFactoryMethods();
+        addReferenceReleasingProviderManagerFields();
+        addFrameworkFields();
+        postAddBuildMethod();
+        initializeFrameworkTypes();
+        implementInterfaceMethods();
+        addSubcomponents();
+        if (forTests) {
+            implementProvisionMethodsForDebug();
+        }
+        component.addMethod(constructor.build());
+        if (graph.componentDescriptor().kind().isTopLevel()) {
+            optionalFactories.addMembers(component);
+        }
+        done = true;
+        return component;
+    }
+
+    private void implementProvisionMethodsForDebug() {
+        List<ResolvedBindings> result =
+                this.graph.resolvedBindings().values().stream()
+                        .filter(resolvedBindings -> !resolvedBindings.ownedContributionBindings().isEmpty())
+                        .filter(resolvedBindings -> resolvedBindings.contributionBinding().bindingType() == BindingType.PROVISION)
+                        .filter(resolvedBindings -> Util.bindingCanBeProvidedInTest(resolvedBindings.contributionBinding()))
+                        .filter(resolvedBindings -> !resolvedBindings.isMultibindingContribution())
+                        .filter(resolvedBindings -> !resolvedBindings.contributionBinding().contributedType().toString().contains("DispatchingAndroidInjector"))
+                        .filter(resolvedBindings -> !resolvedBindings.contributionBinding().contributedType().toString().equals(graph.application().get().toString()))
+                        .collect(Collectors.toList());
+
+        result.forEach(this::implementProvisionMethodForDebug);
+
+        final List<ResolvedBindings> subcomponentBuilderBindings =
+                this.graph.resolvedBindings().values().stream()
+                        .filter(resolvedBindings -> !resolvedBindings.ownedContributionBindings().isEmpty())
+                        .filter(resolvedBindings -> resolvedBindings.contributionBinding().bindingType() == BindingType.PROVISION)
+                        .filter(resolvedBindings -> resolvedBindings.contributionBinding().bindingKind() == ContributionBinding.Kind.SUBCOMPONENT_BUILDER)
+                        .collect(Collectors.toList());
+
+        subcomponentBuilderBindings.forEach(this::implementSubcomponentBuilderBindingForDebug);
+
+    }
+
+    private void implementSubcomponentBuilderBindingForDebug(ResolvedBindings resolvedBindings) {
+
+        final ComponentDescriptor subcomponentDescriptor = graph.componentDescriptor()
+                .subcomponentsByBuilderType()
+                .get(MoreTypes.asTypeElement(resolvedBindings.contributionBinding().key().type()));
+        String subcomponentName = subcomponentNames.get(subcomponentDescriptor);
+        final ClassName subcomponent = this.name.nestedClass("Test" + subcomponentName + "Impl");
+
+        final MethodSpec.Builder builder = MethodSpec.methodBuilder("get" + subcomponentName);
+        builder.addModifiers(Modifier.PUBLIC);
+        final CodeBlock memberSelectExpression = getMemberSelectExpression(BindingKey.contribution(resolvedBindings.key()));
+
+        final Optional<TypeMirror> param = getParameterFromSeedInstanceMethod(subcomponentDescriptor.componentDefinitionType());
+        if (param.isPresent()) {
+            final TypeMirror injecteeParam = param.get();
+            builder.addParameter(ClassName.get(injecteeParam), "instance");
+            builder.addStatement("return ($T) $L.get().seedInstance(instance).build()", subcomponent, memberSelectExpression);
+        } else {
+            builder.addStatement("return ($T) $L.get().build()", subcomponent, memberSelectExpression);
+        }
+        builder.returns(subcomponent);
+        this.component.addMethod(builder.build());
+    }
+
+    private Optional<TypeMirror> getParameterFromSeedInstanceMethod(TypeElement element) {
+        final List<? extends TypeMirror> typeMirrors = types.directSupertypes(element.asType());
+        if (typeMirrors.isEmpty()) {
+            return Optional.empty();
+        }
+        for (TypeMirror typeMirror : typeMirrors) {
+            final DeclaredType declaredType = (DeclaredType) typeMirror;
+            if (declaredType.toString().contains("AndroidInjector")) {
+                if (declaredType.getTypeArguments().size() == 1) {
+                    return Optional.of(declaredType.getTypeArguments().get(0));
+                }
+            }
+        }
         return Optional.empty();
-      }
-      FieldSpec componentField =
-          componentField(
-                  TypeName.get(componentRequirement.type()),
-                  simpleVariableName(componentRequirement.typeElement()))
-              .addModifiers(PRIVATE, FINAL)
-              .build();
-      component.addField(componentField);
-      constructor.addCode(
-          "this.$N = builder.$N;", componentField, builderFields.get(componentRequirement));
-      fieldSelect = localField(name, componentField.name);
-      componentContributionFields.put(componentRequirement, fieldSelect);
-    }
-    return Optional.of(fieldSelect.getExpressionFor(name));
-  }
-
-  /**
-   * Creates a {@link FieldSpec.Builder} with a unique name based off of {@code name}.
-   */
-  protected final FieldSpec.Builder componentField(TypeName type, String name) {
-    return FieldSpec.builder(type, componentFieldNames.getUniqueName(name));
-  }
-
-  protected CodeBlock getMemberSelectExpression(BindingKey key) {
-    return getMemberSelect(key).getExpressionFor(name);
-  }
-
-  @Override
-  public MemberSelect getMemberSelect(BindingKey key) {
-    return memberSelects.get(key);
-  }
-
-  /**
-   * Returns the initialization state of the factory field for a binding key in this component.
-   */
-  protected InitializationState getInitializationState(BindingKey bindingKey) {
-    return initializationStates.containsKey(bindingKey)
-        ? initializationStates.get(bindingKey)
-        : UNINITIALIZED;
-  }
-
-  private void setInitializationState(BindingKey bindingKey, InitializationState state) {
-    initializationStates.put(bindingKey, state);
-  }
-
-  /**
-   * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
-   * object for a scope.
-   */
-  protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
-    return referenceReleasingProviderManagerFields.get(scope).getExpressionFor(name);
-  }
-  /**
-   * Constructs a {@link TypeSpec.Builder} that models the {@link BindingGraph} for this component.
-   * This is only intended to be called once (and will throw on successive invocations). If the
-   * component must be regenerated, use a new instance.
-   */
-  final TypeSpec.Builder write() {
-    checkState(!done, "ComponentWriter has already been generated.");
-    decorateComponent();
-    addBuilder();
-    addFactoryMethods();
-    addReferenceReleasingProviderManagerFields();
-    addFrameworkFields();
-    postAddBuildMethod();
-    initializeFrameworkTypes();
-    implementInterfaceMethods();
-    addSubcomponents();
-    if (forTests) {
-      implementProvisionMethodsForDebug();
-    }
-    component.addMethod(constructor.build());
-    if (graph.componentDescriptor().kind().isTopLevel()) {
-      optionalFactories.addMembers(component);
-    }
-    done = true;
-    return component;
-  }
-
-  private void implementProvisionMethodsForDebug() {
-      List<ResolvedBindings> result =
-              this.graph.resolvedBindings().values().stream()
-              .filter(resolvedBindings -> !resolvedBindings.ownedContributionBindings().isEmpty())
-              .filter(resolvedBindings -> resolvedBindings.contributionBinding().bindingType() == BindingType.PROVISION)
-              .filter(resolvedBindings -> Util.bindingCanBeProvidedInTest(resolvedBindings.contributionBinding()))
-              .filter(resolvedBindings -> !resolvedBindings.isMultibindingContribution())
-              .filter(resolvedBindings -> !resolvedBindings.contributionBinding().contributedType().toString().contains("DispatchingAndroidInjector"))
-              .filter(resolvedBindings -> !resolvedBindings.contributionBinding().contributedType().toString().equals(graph.application().get().toString()))
-              .collect(Collectors.toList());
-
-      result.forEach(this::implementProvisionMethodForDebug);
-
-    final List<ResolvedBindings> subcomponentBuilderBindings =
-            this.graph.resolvedBindings().values().stream()
-            .filter(resolvedBindings -> !resolvedBindings.ownedContributionBindings().isEmpty())
-            .filter(resolvedBindings -> resolvedBindings.contributionBinding().bindingType() == BindingType.PROVISION)
-            .filter(resolvedBindings -> resolvedBindings.contributionBinding().bindingKind() == ContributionBinding.Kind.SUBCOMPONENT_BUILDER)
-            .collect(Collectors.toList());
-
-    subcomponentBuilderBindings.forEach(this::implementSubcomponentBuilderBindingForDebug);
-
-  }
-
-  private void implementSubcomponentBuilderBindingForDebug(ResolvedBindings resolvedBindings) {
-
-    final ComponentDescriptor subcomponentDescriptor = graph.componentDescriptor()
-            .subcomponentsByBuilderType()
-            .get(MoreTypes.asTypeElement(resolvedBindings.contributionBinding().key().type()));
-    String subcomponentName = subcomponentNames.get(subcomponentDescriptor);
-    final ClassName subcomponent = this.name.nestedClass("Test" + subcomponentName + "Impl");
-
-    final MethodSpec.Builder builder = MethodSpec.methodBuilder("get" + subcomponentName);
-    builder.addModifiers(Modifier.PUBLIC);
-    final CodeBlock memberSelectExpression = getMemberSelectExpression(BindingKey.contribution(resolvedBindings.key()));
-
-    final Optional<TypeMirror> param = getParameterFromSeedInstanceMethod(subcomponentDescriptor.componentDefinitionType());
-    if (param.isPresent()) {
-      final TypeMirror injecteeParam = param.get();
-      builder.addParameter(ClassName.get(injecteeParam), "instance");
-      builder.addStatement("return ($T) $L.get().seedInstance(instance).build()", subcomponent, memberSelectExpression);
-    }else {
-      builder.addStatement("return ($T) $L.get().build()", subcomponent, memberSelectExpression);
-    }
-    builder.returns(subcomponent);
-    this.component.addMethod(builder.build());
-  }
-
-  private Optional<TypeMirror> getParameterFromSeedInstanceMethod(TypeElement element) {
-    final List<? extends TypeMirror> typeMirrors = types.directSupertypes(element.asType());
-    if (typeMirrors.isEmpty()) {
-      return Optional.empty();
-    }
-    for (TypeMirror typeMirror : typeMirrors) {
-      final DeclaredType declaredType = (DeclaredType) typeMirror;
-      if (declaredType.toString().contains("AndroidInjector")) {
-        if (declaredType.getTypeArguments().size() == 1) {
-          return Optional.of(declaredType.getTypeArguments().get(0));
+    }
+
+    private void implementProvisionMethodForDebug(ResolvedBindings resolvedBindings) {
+        final FieldSpec frameworkField = createFrameworkField(resolvedBindings, Optional.empty());
+        final MethodSpec.Builder builder = MethodSpec.methodBuilder(Util.getProvisionMethodName(resolvedBindings.contributionBinding()));
+        builder.addModifiers(Modifier.PUBLIC);
+        builder.returns(frameworkField.type);
+        final CodeBlock memberSelectExpression = getMemberSelectExpression(BindingKey.contribution(resolvedBindings.key()));
+        builder.addStatement("return $L", memberSelectExpression);
+        this.component.addMethod(builder.build());
+    }
+
+    /**
+     * Adds Javadoc, modifiers, supertypes, and annotations to the component implementation class
+     * declaration.
+     */
+    protected abstract void decorateComponent();
+
+    /**
+     * Adds a builder type.
+     */
+    protected void addBuilder() {
+        builderName = Optional.of(builderName());
+        TypeSpec.Builder componentBuilder =
+                createBuilder(builderName.get().simpleName()).addModifiers(PUBLIC, FINAL);
+
+        Optional<BuilderSpec> builderSpec = graph.componentDescriptor().builderSpec();
+        if (builderSpec.isPresent()) {
+            addSupertype(componentBuilder, builderSpec.get().builderDefinitionType());
+        } else {
+            componentBuilder
+                    .addMethod(constructorBuilder().addModifiers(PRIVATE).build());
         }
-      }
-    }
-    return Optional.empty();
-  }
-
-  private void implementProvisionMethodForDebug(ResolvedBindings resolvedBindings) {
-    final FieldSpec frameworkField = createFrameworkField(resolvedBindings, Optional.empty());
-    final MethodSpec.Builder builder = MethodSpec.methodBuilder(Util.getProvisionMethodName(resolvedBindings.contributionBinding()));
-    builder.addModifiers(Modifier.PUBLIC);
-    builder.returns(frameworkField.type);
-    final CodeBlock memberSelectExpression = getMemberSelectExpression(BindingKey.contribution(resolvedBindings.key()));
-    builder.addStatement("return $L", memberSelectExpression);
-    this.component.addMethod(builder.build());
-  }
-
-  /**
-   * Adds Javadoc, modifiers, supertypes, and annotations to the component implementation class
-   * declaration.
-   */
-  protected abstract void decorateComponent();
-
-  /**
-   * Adds a builder type.
-   */
-  protected void addBuilder() {
-    builderName = Optional.of(builderName());
-    TypeSpec.Builder componentBuilder =
-        createBuilder(builderName.get().simpleName()).addModifiers(PUBLIC, FINAL);
-
-    Optional<BuilderSpec> builderSpec = graph.componentDescriptor().builderSpec();
-    if (builderSpec.isPresent()) {
-      addSupertype(componentBuilder, builderSpec.get().builderDefinitionType());
-    } else {
-      componentBuilder
-          .addMethod(constructorBuilder().addModifiers(PRIVATE).build());
-    }
-
-    builderFields = addBuilderFields(componentBuilder);
-    addBuildMethod(componentBuilder, builderSpec);
-    addBuilderMethods(componentBuilder, builderSpec);
-    addBuilderClass(componentBuilder.build());
-
-    constructor.addParameter(builderName.get(), "builder");
-    constructor.addStatement("assert builder != null");
-  }
-
-  /**
-   * Adds {@code builder} as a nested builder class. Root components and subcomponents will nest
-   * this in different classes.
-   */
-  protected abstract void addBuilderClass(TypeSpec builder);
-
-  /**
-   * Adds fields for each of the {@linkplain BindingGraph#componentRequirements component
-   * requirements}. Regardless of builder spec, there is always one field per requirement.
-   */
-  private ImmutableMap<ComponentRequirement, FieldSpec> addBuilderFields(
-      TypeSpec.Builder componentBuilder) {
-    UniqueNameSet builderFieldNames = new UniqueNameSet();
-    ImmutableMap.Builder<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.builder();
-    for (ComponentRequirement componentRequirement : graph.componentRequirements()) {
-      String contributionName =
-          builderFieldNames.getUniqueName(componentRequirement.variableName());
-      FieldSpec builderField =
-          FieldSpec.builder(TypeName.get(componentRequirement.type()), contributionName, PRIVATE)
-              .build();
-      componentBuilder.addField(builderField);
-      builderFields.put(componentRequirement, builderField);
+
+        builderFields = addBuilderFields(componentBuilder);
+        addBuildMethod(componentBuilder, builderSpec);
+        addBuilderMethods(componentBuilder, builderSpec);
+        addBuilderClass(componentBuilder.build());
+
+        constructor.addParameter(builderName.get(), "builder");
+        constructor.addStatement("assert builder != null");
     }
 
-    for (ContributionBinding contributionBinding : graph.delegateRequirements()) {
-      if (forTests || Util.generateTestDelegate(contributionBinding)) {
-        createDelegateFieldAndMethod(builderName(), componentBuilder, contributionBinding, delegateFieldNames, false);
-        createMockFieldAndMethod(builderName(), componentBuilder, contributionBinding, mockFieldNames, false);
-      }
-    }
-
-    return builderFields.build();
-  }
-
-  /** Adds the build method to the builder. */
-  private void addBuildMethod(
-      TypeSpec.Builder componentBuilder, Optional<BuilderSpec> builderSpec) {
-    MethodSpec.Builder buildMethod;
-    if (builderSpec.isPresent()) {
-      ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
-      // Note: we don't use the specBuildMethod.getReturnType() as the return type
-      // because it might be a type variable.  We make use of covariant returns to allow
-      // us to return the component type, which will always be valid.
-      buildMethod =
-          methodBuilder(specBuildMethod.getSimpleName().toString()).addAnnotation(Override.class);
-    } else {
-      buildMethod = methodBuilder("build");
-    }
-    buildMethod.returns(componentDefinitionTypeName()).addModifiers(PUBLIC);
-
-    for (Map.Entry<ComponentRequirement, FieldSpec> builderFieldEntry : builderFields.entrySet()) {
-      FieldSpec builderField = builderFieldEntry.getValue();
-      switch (builderFieldEntry.getKey().nullPolicy(elements, types)) {
-        case NEW:
-          buildMethod.addCode(
-              "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
-          break;
-        case THROW:
-          buildMethod.addCode(
-              "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
-              builderField,
-              IllegalStateException.class,
-              TypeNames.rawTypeName(builderField.type),
-              " must be set");
-          break;
-        case ALLOW:
-          break;
-        default:
-          throw new AssertionError(builderFieldEntry.getKey());
-      }
-    }
-    buildMethod.addStatement("return new $T(this)", name);
-    componentBuilder.addMethod(buildMethod.build());
-  }
-
-  /**
-   * Adds the methods that set each of parameters on the builder. If the {@link BuilderSpec} is
-   * present, it will tailor the methods to match the spec.
-   */
-  private void addBuilderMethods(
-      TypeSpec.Builder componentBuilder, Optional<BuilderSpec> builderSpec) {
-    ImmutableSet<ComponentRequirement> componentRequirements = graph.componentRequirements();
-    if (builderSpec.isPresent()) {
-      UniqueNameSet parameterNames = new UniqueNameSet();
-      for (BuilderRequirementMethod requirementMethod : builderSpec.get().requirementMethods()) {
-        ComponentRequirement builderRequirement = requirementMethod.requirement();
-        ExecutableElement specMethod = requirementMethod.method();
-        MethodSpec.Builder builderMethod = addBuilderMethodFromSpec(specMethod);
-        VariableElement parameterElement = Iterables.getOnlyElement(specMethod.getParameters());
-        String parameterName = parameterNames.getUniqueName(parameterElement.getSimpleName());
-
-        TypeName argType =
-            parameterElement.asType().getKind().isPrimitive()
-                // Primitives need to use the original (unresolved) type to avoid boxing.
-                ? TypeName.get(parameterElement.asType())
-                // Otherwise we use the full resolved type.
-                : TypeName.get(builderRequirement.type());
-
-        builderMethod.addParameter(argType, parameterName);
-        if (componentRequirements.contains(builderRequirement)) {
-          // required type
-          builderMethod.addStatement(
-              "this.$N = $L",
-              builderFields.get(builderRequirement),
-              builderRequirement
-                      .nullPolicy(elements, types)
-                      .equals(ComponentRequirement.NullPolicy.ALLOW)
-                  ? parameterName
-                  : CodeBlock.of("$T.checkNotNull($L)", Preconditions.class, parameterName));
-          addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
-        } else if (graph.ownedModuleTypes().contains(builderRequirement.typeElement())) {
-          // owned, but not required
-          builderMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);
-          addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
+    /**
+     * Adds {@code builder} as a nested builder class. Root components and subcomponents will nest
+     * this in different classes.
+     */
+    protected abstract void addBuilderClass(TypeSpec builder);
+
+    /**
+     * Adds fields for each of the {@linkplain BindingGraph#componentRequirements component
+     * requirements}. Regardless of builder spec, there is always one field per requirement.
+     */
+    private ImmutableMap<ComponentRequirement, FieldSpec> addBuilderFields(
+            TypeSpec.Builder componentBuilder) {
+        UniqueNameSet builderFieldNames = new UniqueNameSet();
+        ImmutableMap.Builder<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.builder();
+        for (ComponentRequirement componentRequirement : graph.componentRequirements()) {
+            String contributionName =
+                    builderFieldNames.getUniqueName(componentRequirement.variableName());
+            FieldSpec builderField =
+                    FieldSpec.builder(TypeName.get(componentRequirement.type()), contributionName, PRIVATE)
+                            .build();
+            componentBuilder.addField(builderField);
+            builderFields.put(componentRequirement, builderField);
+        }
+
+        for (ContributionBinding contributionBinding : graph.delegateRequirements()) {
+            if (forTests || Util.generateTestDelegate(contributionBinding)) {
+                createDelegateFieldAndMethod(builderName(), componentBuilder, contributionBinding, delegateFieldNames, false);
+                createMockFieldAndMethod(builderName(), componentBuilder, contributionBinding, mockFieldNames, false);
+            }
+        }
+
+        return builderFields.build();
+    }
+
+    /**
+     * Adds the build method to the builder.
+     */
+    private void addBuildMethod(
+            TypeSpec.Builder componentBuilder, Optional<BuilderSpec> builderSpec) {
+        MethodSpec.Builder buildMethod;
+        if (builderSpec.isPresent()) {
+            ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
+            // Note: we don't use the specBuildMethod.getReturnType() as the return type
+            // because it might be a type variable.  We make use of covariant returns to allow
+            // us to return the component type, which will always be valid.
+            buildMethod =
+                    methodBuilder(specBuildMethod.getSimpleName().toString()).addAnnotation(Override.class);
         } else {
-          // neither owned nor required, so it must be an inherited module
-          builderMethod.addStatement(
-              "throw new $T($T.format($S, $T.class.getCanonicalName()))",
-              UnsupportedOperationException.class,
-              String.class,
-              "%s cannot be set because it is inherited from the enclosing component",
-              TypeNames.rawTypeName(TypeName.get(builderRequirement.type())));
+            buildMethod = methodBuilder("build");
         }
-        componentBuilder.addMethod(builderMethod.build());
-      }
-    } else {
-      for (ComponentRequirement componentRequirement : graph.availableDependencies()) {
-        String componentRequirementName = simpleVariableName(componentRequirement.typeElement());
-        MethodSpec.Builder builderMethod =
-            methodBuilder(componentRequirementName)
-                .returns(builderName.get())
-                .addModifiers(PUBLIC)
-                .addParameter(ClassName.get(componentRequirement.type()), componentRequirementName);
-        if (componentRequirements.contains(componentRequirement)) {
-          builderMethod.addStatement(
-              "this.$N = $T.checkNotNull($L)",
-              builderFields.get(componentRequirement),
-              Preconditions.class,
-              componentRequirementName);
+        buildMethod.returns(componentDefinitionTypeName()).addModifiers(PUBLIC);
+
+        for (Map.Entry<ComponentRequirement, FieldSpec> builderFieldEntry : builderFields.entrySet()) {
+            FieldSpec builderField = builderFieldEntry.getValue();
+            switch (builderFieldEntry.getKey().nullPolicy(elements, types)) {
+                case NEW:
+                    buildMethod.addCode(
+                            "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
+                    break;
+                case THROW:
+                    buildMethod.addCode(
+                            "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
+                            builderField,
+                            IllegalStateException.class,
+                            TypeNames.rawTypeName(builderField.type),
+                            " must be set");
+                    break;
+                case ALLOW:
+                    break;
+                default:
+                    throw new AssertionError(builderFieldEntry.getKey());
+            }
+        }
+        buildMethod.addStatement("return new $T(this)", name);
+        componentBuilder.addMethod(buildMethod.build());
+    }
+
+    /**
+     * Adds the methods that set each of parameters on the builder. If the {@link BuilderSpec} is
+     * present, it will tailor the methods to match the spec.
+     */
+    private void addBuilderMethods(
+            TypeSpec.Builder componentBuilder, Optional<BuilderSpec> builderSpec) {
+        ImmutableSet<ComponentRequirement> componentRequirements = graph.componentRequirements();
+        if (builderSpec.isPresent()) {
+            UniqueNameSet parameterNames = new UniqueNameSet();
+            for (BuilderRequirementMethod requirementMethod : builderSpec.get().requirementMethods()) {
+                ComponentRequirement builderRequirement = requirementMethod.requirement();
+                ExecutableElement specMethod = requirementMethod.method();
+                MethodSpec.Builder builderMethod = addBuilderMethodFromSpec(specMethod);
+                VariableElement parameterElement = Iterables.getOnlyElement(specMethod.getParameters());
+                String parameterName = parameterNames.getUniqueName(parameterElement.getSimpleName());
+
+                TypeName argType =
+                        parameterElement.asType().getKind().isPrimitive()
+                                // Primitives need to use the original (unresolved) type to avoid boxing.
+                                ? TypeName.get(parameterElement.asType())
+                                // Otherwise we use the full resolved type.
+                                : TypeName.get(builderRequirement.type());
+
+                builderMethod.addParameter(argType, parameterName);
+                if (componentRequirements.contains(builderRequirement)) {
+                    // required type
+                    builderMethod.addStatement(
+                            "this.$N = $L",
+                            builderFields.get(builderRequirement),
+                            builderRequirement
+                                    .nullPolicy(elements, types)
+                                    .equals(ComponentRequirement.NullPolicy.ALLOW)
+                                    ? parameterName
+                                    : CodeBlock.of("$T.checkNotNull($L)", Preconditions.class, parameterName));
+                    addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
+                } else if (graph.ownedModuleTypes().contains(builderRequirement.typeElement())) {
+                    // owned, but not required
+                    builderMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);
+                    addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
+                } else {
+                    // neither owned nor required, so it must be an inherited module
+                    builderMethod.addStatement(
+                            "throw new $T($T.format($S, $T.class.getCanonicalName()))",
+                            UnsupportedOperationException.class,
+                            String.class,
+                            "%s cannot be set because it is inherited from the enclosing component",
+                            TypeNames.rawTypeName(TypeName.get(builderRequirement.type())));
+                }
+                componentBuilder.addMethod(builderMethod.build());
+            }
         } else {
-          builderMethod.addStatement("$T.checkNotNull($L)",
-              Preconditions.class,
-              componentRequirementName);
-          builderMethod.addJavadoc("@deprecated " + NOOP_BUILDER_METHOD_JAVADOC);
-          builderMethod.addAnnotation(Deprecated.class);
+            for (ComponentRequirement componentRequirement : graph.availableDependencies()) {
+                String componentRequirementName = simpleVariableName(componentRequirement.typeElement());
+                MethodSpec.Builder builderMethod =
+                        methodBuilder(componentRequirementName)
+                                .returns(builderName.get())
+                                .addModifiers(PUBLIC)
+                                .addParameter(ClassName.get(componentRequirement.type()), componentRequirementName);
+                if (componentRequirements.contains(componentRequirement)) {
+                    builderMethod.addStatement(
+                            "this.$N = $T.checkNotNull($L)",
+                            builderFields.get(componentRequirement),
+                            Preconditions.class,
+                            componentRequirementName);
+                } else {
+                    builderMethod.addStatement("$T.checkNotNull($L)",
+                            Preconditions.class,
+                            componentRequirementName);
+                    builderMethod.addJavadoc("@deprecated " + NOOP_BUILDER_METHOD_JAVADOC);
+                    builderMethod.addAnnotation(Deprecated.class);
+                }
+                builderMethod.addStatement("return this");
+                componentBuilder.addMethod(builderMethod.build());
+            }
         }
-        builderMethod.addStatement("return this");
-        componentBuilder.addMethod(builderMethod.build());
-      }
-    }
-  }
-
-  public void postAddBuildMethod() {}
-
-  private void addBuilderMethodReturnStatementForSpec(
-      ExecutableElement specMethod, MethodSpec.Builder builderMethod) {
-    if (!specMethod.getReturnType().getKind().equals(VOID)) {
-      builderMethod.addStatement("return this");
-    }
-  }
-
-  private MethodSpec.Builder addBuilderMethodFromSpec(ExecutableElement method) {
-    TypeMirror returnType = method.getReturnType();
-    MethodSpec.Builder builderMethod =
-        methodBuilder(method.getSimpleName().toString())
-            .addAnnotation(Override.class)
-            .addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
-    // If the return type is void, we add a method with the void return type.
-    // Otherwise we use the generated builder name and take advantage of covariant returns
-    // (so that we don't have to worry about setter methods that return type variables).
-    if (!returnType.getKind().equals(TypeKind.VOID)) {
-      builderMethod.returns(builderName.get());
-    }
-    return builderMethod;
-  }
-
-  /**
-   * Creates the builder class.
-   */
-  protected abstract TypeSpec.Builder createBuilder(String builderName);
-
-  protected abstract ClassName builderName();
-
-  /**
-   * Adds component factory methods.
-   */
-  protected abstract void addFactoryMethods();
-
-  /**
-   * Adds a {@link dagger.internal.ReferenceReleasingProviderManager} field for every {@link
-   * CanReleaseReferences @ReleasableReferences} scope for which {@linkplain
-   * #requiresReleasableReferences(Scope) one is required}.
-   */
-  private void addReferenceReleasingProviderManagerFields() {
-    ImmutableMap.Builder<Scope, MemberSelect> fields = ImmutableMap.builder();
-    for (Scope scope : graph.componentDescriptor().releasableReferencesScopes()) {
-      if (requiresReleasableReferences(scope)) {
-        FieldSpec field = referenceReleasingProxyManagerField(scope);
-        component.addField(field);
-        fields.put(scope, localField(name, field.name));
-      }
-    }
-    referenceReleasingProviderManagerFields = fields.build();
-  }
-
-  /**
-   * Returns {@code true} if {@code scope} {@linkplain CanReleaseReferences can release its
-   * references} and there is a dependency request in the component for any of
-   *
-   * <ul>
-   * <li>{@code @ForReleasableReferences(scope)} {@link ReleasableReferenceManager}
-   * <li>{@code @ForReleasableReferences(scope)} {@code TypedReleasableReferenceManager<M>}, where
-   *     {@code M} is the releasable-references metatadata type for {@code scope}
-   * <li>{@code Set<ReleasableReferenceManager>}
-   * <li>{@code Set<TypedReleasableReferenceManager<M>>}, where {@code M} is the metadata type for
-   *     the scope
-   * </ul>
-   */
-  private boolean requiresReleasableReferences(Scope scope) {
-    if (!scope.canReleaseReferences()) {
-      return false;
-    }
-
-    if (graphHasContributionBinding(keyFactory.forReleasableReferenceManager(scope))
-        || graphHasContributionBinding(keyFactory.forSetOfReleasableReferenceManagers())) {
-      return true;
-    }
-
-    for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
-      if (graphHasContributionBinding(
-              keyFactory.forTypedReleasableReferenceManager(scope, metadata.getAnnotationType()))
-          || graphHasContributionBinding(
-              keyFactory.forSetOfTypedReleasableReferenceManagers(metadata.getAnnotationType()))) {
-        return true;
-      }
-    }
-
-    return false;
-  }
-
-  private boolean graphHasContributionBinding(Key key) {
-    return graph.resolvedBindings().containsKey(contribution(key));
-  }
-
-  private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
-    return componentField(
-            REFERENCE_RELEASING_PROVIDER_MANAGER,
-            UPPER_CAMEL.to(
-                LOWER_CAMEL, scope.scopeAnnotationElement().getSimpleName() + "References"))
-        .addModifiers(PRIVATE, FINAL)
-        .initializer(
-            "new $T($T.class)",
-            REFERENCE_RELEASING_PROVIDER_MANAGER,
-            scope.scopeAnnotationElement())
-        .addJavadoc(
-            "The manager that releases references for the {@link $T} scope.\n",
-            scope.scopeAnnotationElement())
-        .build();
-  }
-
-  private void addFrameworkFields() {
-    graph.resolvedBindings().values().forEach(this::addField);
+    }
+
+    public void postAddBuildMethod() {
+    }
+
+    private void addBuilderMethodReturnStatementForSpec(
+            ExecutableElement specMethod, MethodSpec.Builder builderMethod) {
+        if (!specMethod.getReturnType().getKind().equals(VOID)) {
+            builderMethod.addStatement("return this");
+        }
+    }
+
+    private MethodSpec.Builder addBuilderMethodFromSpec(ExecutableElement method) {
+        TypeMirror returnType = method.getReturnType();
+        MethodSpec.Builder builderMethod =
+                methodBuilder(method.getSimpleName().toString())
+                        .addAnnotation(Override.class)
+                        .addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
+        // If the return type is void, we add a method with the void return type.
+        // Otherwise we use the generated builder name and take advantage of covariant returns
+        // (so that we don't have to worry about setter methods that return type variables).
+        if (!returnType.getKind().equals(TypeKind.VOID)) {
+            builderMethod.returns(builderName.get());
+        }
+        return builderMethod;
+    }
+
+    /**
+     * Creates the builder class.
+     */
+    protected abstract TypeSpec.Builder createBuilder(String builderName);
+
+    protected abstract ClassName builderName();
+
+    /**
+     * Adds component factory methods.
+     */
+    protected abstract void addFactoryMethods();
+
+    /**
+     * Adds a {@link dagger.internal.ReferenceReleasingProviderManager} field for every {@link
+     * CanReleaseReferences @ReleasableReferences} scope for which {@linkplain
+     * #requiresReleasableReferences(Scope) one is required}.
+     */
+    private void addReferenceReleasingProviderManagerFields() {
+        ImmutableMap.Builder<Scope, MemberSelect> fields = ImmutableMap.builder();
+        for (Scope scope : graph.componentDescriptor().releasableReferencesScopes()) {
+            if (requiresReleasableReferences(scope)) {
+                FieldSpec field = referenceReleasingProxyManagerField(scope);
+                component.addField(field);
+                fields.put(scope, localField(name, field.name));
+            }
+        }
+        referenceReleasingProviderManagerFields = fields.build();
+    }
+
+    /**
+     * Returns {@code true} if {@code scope} {@linkplain CanReleaseReferences can release its
+     * references} and there is a dependency request in the component for any of
+     * <p>
+     * <ul>
+     * <li>{@code @ForReleasableReferences(scope)} {@link ReleasableReferenceManager}
+     * <li>{@code @ForReleasableReferences(scope)} {@code TypedReleasableReferenceManager<M>}, where
+     * {@code M} is the releasable-references metatadata type for {@code scope}
+     * <li>{@code Set<ReleasableReferenceManager>}
+     * <li>{@code Set<TypedReleasableReferenceManager<M>>}, where {@code M} is the metadata type for
+     * the scope
+     * </ul>
+     */
+    private boolean requiresReleasableReferences(Scope scope) {
+        if (!scope.canReleaseReferences()) {
+            return false;
+        }
+
+        if (graphHasContributionBinding(keyFactory.forReleasableReferenceManager(scope))
+                || graphHasContributionBinding(keyFactory.forSetOfReleasableReferenceManagers())) {
+            return true;
+        }
+
+        for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
+            if (graphHasContributionBinding(
+                    keyFactory.forTypedReleasableReferenceManager(scope, metadata.getAnnotationType()))
+                    || graphHasContributionBinding(
+                    keyFactory.forSetOfTypedReleasableReferenceManagers(metadata.getAnnotationType()))) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private boolean graphHasContributionBinding(Key key) {
+        return graph.resolvedBindings().containsKey(contribution(key));
+    }
+
+    private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
+        return componentField(
+                REFERENCE_RELEASING_PROVIDER_MANAGER,
+                UPPER_CAMEL.to(
+                        LOWER_CAMEL, scope.scopeAnnotationElement().getSimpleName() + "References"))
+                .addModifiers(PRIVATE, FINAL)
+                .initializer(
+                        "new $T($T.class)",
+                        REFERENCE_RELEASING_PROVIDER_MANAGER,
+                        scope.scopeAnnotationElement())
+                .addJavadoc(
+                        "The manager that releases references for the {@link $T} scope.\n",
+                        scope.scopeAnnotationElement())
+                .build();
+    }
+
+    private void addFrameworkFields() {
+        graph.resolvedBindings().values().forEach(this::addField);
     /*for (ContributionBinding contributionBinding : graph.delegateRequirements()) {
       createDelegateField(component, contributionBinding, delegateFieldNames);
     }*/
-  }
-
-  private void addField(ResolvedBindings resolvedBindings) {
-    BindingKey bindingKey = resolvedBindings.bindingKey();
-    // If the binding can be satisfied with a static method call without dependencies or state,
-    // no field is necessary.
-    Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
-    if (staticMemberSelect.isPresent()) {
-      memberSelects.put(bindingKey, staticMemberSelect.get());
-      return;
-    }
-
-    // No field needed if there are no owned bindings.
-    if (resolvedBindings.ownedBindings().isEmpty()) {
-      return;
-    }
-
-    // TODO(gak): get rid of the field for unscoped delegated bindings
-
-    FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.empty());
-    memberSelects.put(bindingKey, localField(name, frameworkField.name));
-  }
-
-  /**
-   * Adds a field representing the resolved bindings, optionally forcing it to use a particular
-   * framework class (instead of the class the resolved bindings would typically use).
-   */
-  private FieldSpec addFrameworkField(
-      ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
-    FieldSpec field = createFrameworkField(resolvedBindings, frameworkClass);
-    component.addField(field);
-    return field;
-  }
-
-  private FieldSpec createFrameworkField(ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
-    boolean useRawType = useRawType(resolvedBindings);
-
-    FrameworkField contributionBindingField =
-        FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);
-    FieldSpec.Builder contributionField =
-        componentField(
-            useRawType
-                ? contributionBindingField.type().rawType
-                : contributionBindingField.type(),
-            contributionBindingField.name());
-
-    if (useRawType) {
-      contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
-    }
-    return contributionField.build();
-  }
-
-  private boolean useRawType(ResolvedBindings resolvedBindings) {
-    return useRawType(resolvedBindings.bindingPackage());
-  }
-
-  private boolean useRawType(Binding binding) {
-    return useRawType(binding.bindingPackage());
-  }
-
-  private boolean useRawType(Optional<String> bindingPackage) {
-    return bindingPackage.isPresent() && !bindingPackage.get().equals(name.packageName());
-  }
-
-  /**
-   * If {@code resolvedBindings} is an unscoped provision binding with no factory arguments or a
-   * no-op members injection binding, then we don't need a field to hold its factory. In that case,
-   * this method returns the static member select that returns the factory or no-op members
-   * injector.
-   */
-  private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
-    BindingKey bindingKey = resolvedBindings.bindingKey();
-    switch (bindingKey.kind()) {
-      case CONTRIBUTION:
-        ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
-        if (contributionBinding.factoryCreationStrategy().equals(SINGLETON_INSTANCE)
-            && !contributionBinding.scope().isPresent()) {
-          switch (contributionBinding.bindingKind()) {
-            case SYNTHETIC_MULTIBOUND_MAP:
-              BindingType bindingType = contributionBinding.bindingType();
-              MapType mapType = MapType.from(contributionBinding.key());
-              return Optional.of(
-                  emptyFrameworkMapFactory(
-                      bindingType,
-                      mapType.keyType(),
-                      mapType.unwrappedValueType(bindingType.frameworkClass())));
+    }
 
-            case SYNTHETIC_MULTIBOUND_SET:
-              return Optional.of(
-                  emptySetFactoryStaticMemberSelect(
-                      contributionBinding.bindingType(), contributionBinding.key()));
+    private void addField(ResolvedBindings resolvedBindings) {
+        BindingKey bindingKey = resolvedBindings.bindingKey();
+        // If the binding can be satisfied with a static method call without dependencies or state,
+        // no field is necessary.
+        Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
+        if (staticMemberSelect.isPresent()) {
+            memberSelects.put(bindingKey, staticMemberSelect.get());
+            return;
+        }
 
-            case INJECTION:
-            case PROVISION:
-              if (bindingKey.key().type().getKind().equals(DECLARED)) {
-                ImmutableList<TypeVariableName> typeVariables =
-                    bindingTypeElementTypeVariableNames(contributionBinding);
-                if (!typeVariables.isEmpty()) {
-                  List<? extends TypeMirror> typeArguments =
-                      ((DeclaredType) bindingKey.key().type()).getTypeArguments();
-                  return Optional.of(MemberSelect.parameterizedFactoryCreateMethod(
-                      this.generatedClassNameForBinding(contributionBinding), typeArguments));
+        // No field needed if there are no owned bindings.
+        if (resolvedBindings.ownedBindings().isEmpty()) {
+            return;
+        }
+
+        // TODO(gak): get rid of the field for unscoped delegated bindings
+
+        FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.empty());
+        memberSelects.put(bindingKey, localField(name, frameworkField.name));
+    }
+
+    /**
+     * Adds a field representing the resolved bindings, optionally forcing it to use a particular
+     * framework class (instead of the class the resolved bindings would typically use).
+     */
+    private FieldSpec addFrameworkField(
+            ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
+        FieldSpec field = createFrameworkField(resolvedBindings, frameworkClass);
+        component.addField(field);
+        return field;
+    }
+
+    private FieldSpec createFrameworkField(ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
+        boolean useRawType = useRawType(resolvedBindings);
+
+        FrameworkField contributionBindingField =
+                FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);
+        FieldSpec.Builder contributionField =
+                componentField(
+                        useRawType
+                                ? contributionBindingField.type().rawType
+                                : contributionBindingField.type(),
+                        contributionBindingField.name());
+
+        if (useRawType) {
+            contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
+        }
+        return contributionField.build();
+    }
+
+    private boolean useRawType(ResolvedBindings resolvedBindings) {
+        return useRawType(resolvedBindings.bindingPackage());
+    }
+
+    private boolean useRawType(Binding binding) {
+        return useRawType(binding.bindingPackage());
+    }
+
+    private boolean useRawType(Optional<String> bindingPackage) {
+        return bindingPackage.isPresent() && !bindingPackage.get().equals(name.packageName());
+    }
+
+    /**
+     * If {@code resolvedBindings} is an unscoped provision binding with no factory arguments or a
+     * no-op members injection binding, then we don't need a field to hold its factory. In that case,
+     * this method returns the static member select that returns the factory or no-op members
+     * injector.
+     */
+    private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
+        BindingKey bindingKey = resolvedBindings.bindingKey();
+        switch (bindingKey.kind()) {
+            case CONTRIBUTION:
+                ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
+                if (contributionBinding.factoryCreationStrategy().equals(SINGLETON_INSTANCE)
+                        && !contributionBinding.scope().isPresent()) {
+                    switch (contributionBinding.bindingKind()) {
+                        case SYNTHETIC_MULTIBOUND_MAP:
+                            BindingType bindingType = contributionBinding.bindingType();
+                            MapType mapType = MapType.from(contributionBinding.key());
+                            return Optional.of(
+                                    emptyFrameworkMapFactory(
+                                            bindingType,
+                                            mapType.keyType(),
+                                            mapType.unwrappedValueType(bindingType.frameworkClass())));
+
+                        case SYNTHETIC_MULTIBOUND_SET:
+                            return Optional.of(
+                                    emptySetFactoryStaticMemberSelect(
+                                            contributionBinding.bindingType(), contributionBinding.key()));
+
+                        case INJECTION:
+                        case PROVISION:
+                            if (bindingKey.key().type().getKind().equals(DECLARED)) {
+                                ImmutableList<TypeVariableName> typeVariables =
+                                        bindingTypeElementTypeVariableNames(contributionBinding);
+                                if (!typeVariables.isEmpty()) {
+                                    List<? extends TypeMirror> typeArguments =
+                                            ((DeclaredType) bindingKey.key().type()).getTypeArguments();
+                                    return Optional.of(MemberSelect.parameterizedFactoryCreateMethod(
+                                            this.generatedClassNameForBinding(contributionBinding), typeArguments));
+                                }
+                            }
+                            // fall through
+
+                        default:
+                            return Optional.of(
+                                    staticMethod(
+                                            this.generatedClassNameForBinding(contributionBinding), CodeBlock.of("create()")));
+                    }
+                }
+                break;
+
+            case MEMBERS_INJECTION:
+                Optional<MembersInjectionBinding> membersInjectionBinding =
+                        resolvedBindings.membersInjectionBinding();
+                if (membersInjectionBinding.isPresent()
+                        && membersInjectionBinding.get().injectionSites().isEmpty()) {
+                    return Optional.of(noOpMembersInjector(membersInjectionBinding.get().key().type()));
                 }
-              }
-              // fall through
+                break;
 
             default:
-              return Optional.of(
-                  staticMethod(
-                      this.generatedClassNameForBinding(contributionBinding), CodeBlock.of("create()")));
-          }
+                throw new AssertionError();
         }
-        break;
-
-      case MEMBERS_INJECTION:
-        Optional<MembersInjectionBinding> membersInjectionBinding =
-            resolvedBindings.membersInjectionBinding();
-        if (membersInjectionBinding.isPresent()
-            && membersInjectionBinding.get().injectionSites().isEmpty()) {
-          return Optional.of(noOpMembersInjector(membersInjectionBinding.get().key().type()));
+        return Optional.empty();
+    }
+
+    protected ClassName generatedClassNameForBinding(ContributionBinding contributionBinding) {
+        if (forTests && !contributionBinding.contributedType().toString().contains("DispatchingAndroidInjector")) {
+            return SourceFiles.generatedTestClassNameForBinding(contributionBinding);
+        } else {
+            return SourceFiles.generatedClassNameForBinding(contributionBinding);
         }
-        break;
+    }
 
-      default:
-        throw new AssertionError();
+    /**
+     * A static member select for an empty set factory. Calls {@link SetFactory#empty()}, {@link
+     * SetProducer#empty()}, or {@link SetOfProducedProducer#empty()}, depending on the set
+     * bindings.
+     */
+    private static MemberSelect emptySetFactoryStaticMemberSelect(BindingType bindingType, Key key) {
+        return emptySetProvider(setFactoryClassName(bindingType, key), SetType.from(key));
     }
-    return Optional.empty();
-  }
-
-  protected ClassName generatedClassNameForBinding(ContributionBinding contributionBinding) {
-    if (forTests && !contributionBinding.contributedType().toString().contains("DispatchingAndroidInjector")) {
-      return SourceFiles.generatedTestClassNameForBinding(contributionBinding);
-    }else {
-      return SourceFiles.generatedClassNameForBinding(contributionBinding);
-    }
-  }
-
-  /**
-   * A static member select for an empty set factory. Calls {@link SetFactory#empty()}, {@link
-   * SetProducer#empty()}, or {@link SetOfProducedProducer#empty()}, depending on the set
-   * bindings.
-   */
-  private static MemberSelect emptySetFactoryStaticMemberSelect(BindingType bindingType, Key key) {
-    return emptySetProvider(setFactoryClassName(bindingType, key), SetType.from(key));
-  }
-
-  /**
-   * The {@link Set} factory class name appropriate for set bindings.
-   *
-   * <ul>
-   * <li>{@link SetFactory} for provision bindings.
-   * <li>{@link SetProducer} for production bindings for {@code Set<T>}.
-   * <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
-   * </ul>
-   */
-  private static ClassName setFactoryClassName(BindingType bindingType, Key key) {
-    if (bindingType.equals(BindingType.PROVISION)) {
-      return SET_FACTORY;
-    } else {
-      SetType setType = SetType.from(key);
-      return setType.elementsAreTypeOf(Produced.class) ? SET_OF_PRODUCED_PRODUCER : SET_PRODUCER;
-    }
-  }
-
-  /**
-   * The {@link Map}-of-value factory class name appropriate for map bindings.
-   *
-   * <ul>
-   * <li>{@link MapFactory} for provision bindings.
-   * <li>{@link MapProducer} for production bindings.
-   * </ul>
-   */
-  private static ClassName mapFactoryClassName(ContributionBinding binding) {
-    switch (binding.bindingType()) {
-      case PRODUCTION:
-        return MapType.from(binding.key()).valuesAreTypeOf(Produced.class)
-            ? MAP_OF_PRODUCED_PRODUCER : MAP_PRODUCER;
-
-      case PROVISION:
-      case MEMBERS_INJECTION:
-        return MAP_FACTORY;
 
-      default:
-        throw new AssertionError(binding.toString());
-    }
-  }
-
-  /**
-   * The {@link Map}-of-framework factory class name appropriate for map bindings.
-   *
-   * <ul>
-   * <li>{@link MapProviderFactory} for provision bindings.
-   * <li>{@link MapOfProducerProducer} for production bindings.
-   * </ul>
-   */
-  private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
-    return bindingType.equals(BindingType.PRODUCTION)
-        ? MAP_OF_PRODUCER_PRODUCER : MAP_PROVIDER_FACTORY;
-  }
-
-  private void implementInterfaceMethods() {
-    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
-    final ImmutableSet<ComponentMethodDescriptor> componentMethodDescriptors = graph.componentDescriptor().componentMethods();
-    for (ComponentMethodDescriptor componentMethod : componentMethodDescriptors) {
-      if (componentMethod.dependencyRequest().isPresent()) {
-        DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
-        ExecutableElement methodElement = MoreElements.asExecutable(componentMethod.methodElement());
-        ExecutableType requestType =
-            MoreTypes.asExecutable(
-                types.asMemberOf(
-                    MoreTypes.asDeclared(graph.componentType().asType()), methodElement));
-        MethodSignature signature =
-            MethodSignature.fromExecutableType(
-                methodElement.getSimpleName().toString(), requestType);
-        if (!interfaceMethods.contains(signature)) {
-          interfaceMethods.add(signature);
-          MethodSpec.Builder interfaceMethod =
-              methodSpecForComponentMethod(methodElement, requestType);
-          RequestFulfillment fulfillment =
-              requestFulfillmentRegistry.getRequestFulfillment(interfaceRequest.bindingKey());
-          CodeBlock codeBlock = fulfillment.getSnippetForDependencyRequest(interfaceRequest, name);
-          switch (interfaceRequest.kind()) {
-            case MEMBERS_INJECTOR:
-              List<? extends VariableElement> parameters = methodElement.getParameters();
-              if (!parameters.isEmpty()) {
-                Name parameterName =
-                    Iterables.getOnlyElement(methodElement.getParameters()).getSimpleName();
-                interfaceMethod.addStatement("$L.injectMembers($L)", codeBlock, parameterName);
-                if (!requestType.getReturnType().getKind().equals(VOID)) {
-                  interfaceMethod.addStatement("return $L", parameterName);
-                }
-                break;
-              }
-              // fall through
+    /**
+     * The {@link Set} factory class name appropriate for set bindings.
+     * <p>
+     * <ul>
+     * <li>{@link SetFactory} for provision bindings.
+     * <li>{@link SetProducer} for production bindings for {@code Set<T>}.
+     * <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
+     * </ul>
+     */
+    private static ClassName setFactoryClassName(BindingType bindingType, Key key) {
+        if (bindingType.equals(BindingType.PROVISION)) {
+            return SET_FACTORY;
+        } else {
+            SetType setType = SetType.from(key);
+            return setType.elementsAreTypeOf(Produced.class) ? SET_OF_PRODUCED_PRODUCER : SET_PRODUCER;
+        }
+    }
+
+    /**
+     * The {@link Map}-of-value factory class name appropriate for map bindings.
+     * <p>
+     * <ul>
+     * <li>{@link MapFactory} for provision bindings.
+     * <li>{@link MapProducer} for production bindings.
+     * </ul>
+     */
+    private static ClassName mapFactoryClassName(ContributionBinding binding) {
+        switch (binding.bindingType()) {
+            case PRODUCTION:
+                return MapType.from(binding.key()).valuesAreTypeOf(Produced.class)
+                        ? MAP_OF_PRODUCED_PRODUCER : MAP_PRODUCER;
+
+            case PROVISION:
+            case MEMBERS_INJECTION:
+                return MAP_FACTORY;
+
             default:
+                throw new AssertionError(binding.toString());
+        }
+    }
 
-              final MemberSelect memberSelect = memberSelects.get(BindingKey.membersInjection(interfaceRequest.key()));
-              if (memberSelect != null) {
-                final CodeBlock expressionFor = memberSelect.getExpressionFor(name);
-                final Optional<String> variableName = interfaceRequest.overriddenVariableName();
-                String name = variableName.isPresent() ? variableName.get() : "obj";
-                interfaceMethod.addStatement("$T $L = $L", ClassName.get(interfaceRequest.key().type()), name, codeBlock);
-                interfaceMethod.addStatement("$L.injectMembers($L)", expressionFor, name);
-                if (!requestType.getReturnType().getKind().equals(VOID)) {
-                  interfaceMethod.addStatement("return $L", name);
-                }
-              }else {
-                interfaceMethod.addStatement("return $L", codeBlock);
-              }
+    /**
+     * The {@link Map}-of-framework factory class name appropriate for map bindings.
+     * <p>
+     * <ul>
+     * <li>{@link MapProviderFactory} for provision bindings.
+     * <li>{@link MapOfProducerProducer} for production bindings.
+     * </ul>
+     */
+    private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
+        return bindingType.equals(BindingType.PRODUCTION)
+                ? MAP_OF_PRODUCER_PRODUCER : MAP_PROVIDER_FACTORY;
+    }
+
+    private void implementInterfaceMethods() {
+        Set<MethodSignature> interfaceMethods = Sets.newHashSet();
+        final ImmutableSet<ComponentMethodDescriptor> componentMethodDescriptors = graph.componentDescriptor().componentMethods();
+        for (ComponentMethodDescriptor componentMethod : componentMethodDescriptors) {
+            if (componentMethod.dependencyRequest().isPresent()) {
+                DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
+                ExecutableElement methodElement = MoreElements.asExecutable(componentMethod.methodElement());
+                ExecutableType requestType =
+                        MoreTypes.asExecutable(
+                                types.asMemberOf(
+                                        MoreTypes.asDeclared(graph.componentType().asType()), methodElement));
+                MethodSignature signature =
+                        MethodSignature.fromExecutableType(
+                                methodElement.getSimpleName().toString(), requestType);
+                if (!interfaceMethods.contains(signature)) {
+                    interfaceMethods.add(signature);
+                    MethodSpec.Builder interfaceMethod =
+                            methodSpecForComponentMethod(methodElement, requestType);
+                    RequestFulfillment fulfillment =
+                            requestFulfillmentRegistry.getRequestFulfillment(interfaceRequest.bindingKey());
+                    CodeBlock codeBlock = fulfillment.getSnippetForDependencyRequest(interfaceRequest, name);
+                    switch (interfaceRequest.kind()) {
+                        case MEMBERS_INJECTOR:
+                            List<? extends VariableElement> parameters = methodElement.getParameters();
+                            if (!parameters.isEmpty()) {
+                                Name parameterName =
+                                        Iterables.getOnlyElement(methodElement.getParameters()).getSimpleName();
+                                interfaceMethod.addStatement("$L.injectMembers($L)", codeBlock, parameterName);
+                                if (!requestType.getReturnType().getKind().equals(VOID)) {
+                                    interfaceMethod.addStatement("return $L", parameterName);
+                                }
+                                break;
+                            }
+                            // fall through
+                        default:
+
+                            final MemberSelect memberSelect = memberSelects.get(BindingKey.membersInjection(interfaceRequest.key()));
+                            if (memberSelect != null) {
+                                final CodeBlock expressionFor = memberSelect.getExpressionFor(name);
+                                final Optional<String> variableName = interfaceRequest.overriddenVariableName();
+                                String name = variableName.isPresent() ? variableName.get() : "obj";
+                                interfaceMethod.addStatement("$T $L = $L", ClassName.get(interfaceRequest.key().type()), name, codeBlock);
+                                interfaceMethod.addStatement("$L.injectMembers($L)", expressionFor, name);
+                                if (!requestType.getReturnType().getKind().equals(VOID)) {
+                                    interfaceMethod.addStatement("return $L", name);
+                                }
+                            } else {
+                                interfaceMethod.addStatement("return $L", codeBlock);
+                            }
 
               /*CodeBlock.Builder builder = CodeBlock.builder();
               final boolean supportsTestDelegate = !componentMethod.methodElement().getReturnType().toString().equals(void.class.getName());
@@ -964,95 +971,95 @@ private void implementInterfaceMethods() {
                 builder.endControlFlow();
               }*/
 
-              break;
-          }
-          component.addMethod(interfaceMethod.build());
+                            break;
+                    }
+                    component.addMethod(interfaceMethod.build());
+                }
+            }
+        }
+    }
+
+    private MethodSpec.Builder methodSpecForComponentMethod(
+            ExecutableElement method, ExecutableType methodType) {
+        String methodName = method.getSimpleName().toString();
+        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName);
+
+        methodBuilder.addAnnotation(Override.class);
+
+        Set<Modifier> modifiers = EnumSet.copyOf(method.getModifiers());
+        modifiers.remove(Modifier.ABSTRACT);
+        methodBuilder.addModifiers(modifiers);
+
+        methodBuilder.returns(TypeName.get(methodType.getReturnType()));
+
+        List<? extends VariableElement> parameters = method.getParameters();
+        List<? extends TypeMirror> resolvedParameterTypes = methodType.getParameterTypes();
+        verify(parameters.size() == resolvedParameterTypes.size());
+        for (int i = 0; i < parameters.size(); i++) {
+            VariableElement parameter = parameters.get(i);
+            TypeName type = TypeName.get(resolvedParameterTypes.get(i));
+            String name = parameter.getSimpleName().toString();
+            Set<Modifier> parameterModifiers = parameter.getModifiers();
+            ParameterSpec.Builder parameterBuilder =
+                    ParameterSpec.builder(type, name)
+                            .addModifiers(parameterModifiers.toArray(new Modifier[0]));
+            methodBuilder.addParameter(parameterBuilder.build());
+        }
+        for (TypeMirror thrownType : method.getThrownTypes()) {
+            methodBuilder.addException(TypeName.get(thrownType));
+        }
+        return methodBuilder;
+    }
+
+    private void addSubcomponents() {
+        for (BindingGraph subgraph : graph.subgraphs()) {
+            ComponentMethodDescriptor componentMethodDescriptor =
+                    graph.componentDescriptor()
+                            .subcomponentsByFactoryMethod()
+                            .inverse()
+                            .get(subgraph.componentDescriptor());
+            SubcomponentWriter subcomponent =
+                    new SubcomponentWriter(this, Optional.ofNullable(componentMethodDescriptor), subgraph, forTests);
+            component.addType(subcomponent.write().build());
+        }
+    }
+
+    private static final int INITIALIZATIONS_PER_INITIALIZE_METHOD = 100;
+
+    private void initializeFrameworkTypes() {
+        ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+
+        for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
+            initializeFrameworkType(bindingKey).ifPresent(codeBlocks::add);
         }
-      }
-    }
-  }
-
-  private MethodSpec.Builder methodSpecForComponentMethod(
-      ExecutableElement method, ExecutableType methodType) {
-    String methodName = method.getSimpleName().toString();
-    MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName);
-
-    methodBuilder.addAnnotation(Override.class);
-
-    Set<Modifier> modifiers = EnumSet.copyOf(method.getModifiers());
-    modifiers.remove(Modifier.ABSTRACT);
-    methodBuilder.addModifiers(modifiers);
-
-    methodBuilder.returns(TypeName.get(methodType.getReturnType()));
-
-    List<? extends VariableElement> parameters = method.getParameters();
-    List<? extends TypeMirror> resolvedParameterTypes = methodType.getParameterTypes();
-    verify(parameters.size() == resolvedParameterTypes.size());
-    for (int i = 0; i < parameters.size(); i++) {
-      VariableElement parameter = parameters.get(i);
-      TypeName type = TypeName.get(resolvedParameterTypes.get(i));
-      String name = parameter.getSimpleName().toString();
-      Set<Modifier> parameterModifiers = parameter.getModifiers();
-      ParameterSpec.Builder parameterBuilder =
-          ParameterSpec.builder(type, name)
-              .addModifiers(parameterModifiers.toArray(new Modifier[0]));
-      methodBuilder.addParameter(parameterBuilder.build());
-    }
-    for (TypeMirror thrownType : method.getThrownTypes()) {
-      methodBuilder.addException(TypeName.get(thrownType));
-    }
-    return methodBuilder;
-  }
-
-  private void addSubcomponents() {
-    for (BindingGraph subgraph : graph.subgraphs()) {
-      ComponentMethodDescriptor componentMethodDescriptor =
-          graph.componentDescriptor()
-              .subcomponentsByFactoryMethod()
-              .inverse()
-              .get(subgraph.componentDescriptor());
-      SubcomponentWriter subcomponent =
-          new SubcomponentWriter(this, Optional.ofNullable(componentMethodDescriptor), subgraph, forTests);
-      component.addType(subcomponent.write().build());
-    }
-  }
-
-  private static final int INITIALIZATIONS_PER_INITIALIZE_METHOD = 100;
-
-  private void initializeFrameworkTypes() {
-    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-
-    for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
-      initializeFrameworkType(bindingKey).ifPresent(codeBlocks::add);
-    }
-    List<List<CodeBlock>> partitions =
-        Lists.partition(codeBlocks.build(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
-
-    initializationMethods = new ArrayList<>();
-
-    UniqueNameSet methodNames = new UniqueNameSet();
-    for (List<CodeBlock> partition : partitions) {
-      String methodName = methodNames.getUniqueName("initialize");
-      MethodSpec.Builder initializeMethod =
-          methodBuilder(methodName)
-              .addModifiers(PRIVATE)
+        List<List<CodeBlock>> partitions =
+                Lists.partition(codeBlocks.build(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
+
+        initializationMethods = new ArrayList<>();
+
+        UniqueNameSet methodNames = new UniqueNameSet();
+        for (List<CodeBlock> partition : partitions) {
+            String methodName = methodNames.getUniqueName("initialize");
+            MethodSpec.Builder initializeMethod =
+                    methodBuilder(methodName)
+                            .addModifiers(PRIVATE)
               /* TODO(gak): Strictly speaking, we only need the suppression here if we are also
                * initializing a raw field in this method, but the structure of this code makes it
                * awkward to pass that bit through.  This will be cleaned up when we no longer
                * separate fields and initilization as we do now. */
-              .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
-              .addCode(CodeBlocks.concat(partition));
-      if (builderName.isPresent()) {
-        initializeMethod.addParameter(builderName.get(), "builder", FINAL);
-        constructor.addStatement("$L(builder)", methodName);
-      } else {
-        constructor.addStatement("$L()", methodName);
-      }
-      final MethodSpec method = initializeMethod.build();
-      initializationMethods.add(method);
-      component.addMethod(method);
-    }
-  }
+                            .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
+                            .addCode(CodeBlocks.concat(partition));
+            if (builderName.isPresent()) {
+                initializeMethod.addParameter(builderName.get(), "builder", FINAL);
+                constructor.addStatement("$L(builder)", methodName);
+            } else {
+                constructor.addStatement("$L()", methodName);
+            }
+            final MethodSpec method = initializeMethod.build();
+            initializationMethods.add(method);
+            component.addMethod(method);
+        }
+    }
 
   /*private CodeBlock initDelegateFields() {
     List<CodeBlock> codeBlocks = new ArrayList<>();
@@ -1065,232 +1072,259 @@ private void initializeFrameworkTypes() {
     return CodeBlocks.concat(codeBlocks);
   }*/
 
-  /**
-   * Returns a single code block representing the initialization of the framework type.
-   *
-   * <p>Note that this must be a single code block because initialization code blocks can be invoked
-   * from any place in any order.  By requiring a single code block (often of concatenated code
-   * blocks) we ensure that things like local variables always behave as expected by the
-   * initialization logic.
-   */
-  private Optional<CodeBlock> initializeFrameworkType(BindingKey bindingKey) {
-    // If the field is inherited or the member select is static, don't initialize.
-    MemberSelect memberSelect = getMemberSelect(bindingKey);
-    if (memberSelect.staticMember() || !memberSelect.owningClass().equals(name)) {
-      return Optional.empty();
-    }
+    /**
+     * Returns a single code block representing the initialization of the framework type.
+     * <p>
+     * <p>Note that this must be a single code block because initialization code blocks can be invoked
+     * from any place in any order.  By requiring a single code block (often of concatenated code
+     * blocks) we ensure that things like local variables always behave as expected by the
+     * initialization logic.
+     */
+    private Optional<CodeBlock> initializeFrameworkType(BindingKey bindingKey) {
+        // If the field is inherited or the member select is static, don't initialize.
+        MemberSelect memberSelect = getMemberSelect(bindingKey);
+        if (memberSelect.staticMember() || !memberSelect.owningClass().equals(name)) {
+            return Optional.empty();
+        }
 
-    switch (bindingKey.kind()) {
-      case CONTRIBUTION:
-        return initializeContributionBinding(bindingKey);
+        switch (bindingKey.kind()) {
+            case CONTRIBUTION:
+                return initializeContributionBinding(bindingKey);
 
-      case MEMBERS_INJECTION:
-        return initializeMembersInjectionBinding(bindingKey);
+            case MEMBERS_INJECTION:
+                return initializeMembersInjectionBinding(bindingKey);
 
-      default:
-        throw new AssertionError();
+            default:
+                throw new AssertionError();
+        }
     }
-  }
 
-  private Optional<CodeBlock> initializeContributionBinding(BindingKey bindingKey) {
-    ContributionBinding binding = graph.resolvedBindings().get(bindingKey).contributionBinding();
+    private Optional<CodeBlock> initializeContributionBinding(BindingKey bindingKey) {
+        ContributionBinding binding = graph.resolvedBindings().get(bindingKey).contributionBinding();
     /* We have some duplication in the branches below b/c initializeDeferredDependencies must be
      * called before we get the code block that initializes the member. */
-    switch (binding.factoryCreationStrategy()) {
-      case DELEGATE:
-        CodeBlock delegatingCodeBlock =
-            CodeBlock.of(
-                "($T) $L",
-                binding.bindingType().frameworkClass(),
-                getMemberSelect(Iterables.getOnlyElement(binding.explicitDependencies()).bindingKey()).getExpressionFor(name)
-            );
-        return Optional.of(
-            CodeBlocks.concat(
-                ImmutableList.of(
-                    initializeDeferredDependencies(binding),
-                    initializeDelegateMember(bindingKey, decorateForScope(delegatingCodeBlock, binding.scope())))));
-      case SINGLETON_INSTANCE:
-        if (!binding.scope().isPresent()) {
-          return Optional.empty();
+        switch (binding.factoryCreationStrategy()) {
+            case DELEGATE:
+                CodeBlock delegatingCodeBlock =
+                        CodeBlock.of(
+                                "($T) $L",
+                                binding.bindingType().frameworkClass(),
+                                getMemberSelect(Iterables.getOnlyElement(binding.explicitDependencies()).bindingKey()).getExpressionFor(name)
+                        );
+                return Optional.of(
+                        CodeBlocks.concat(
+                                ImmutableList.of(
+                                        initializeDeferredDependencies(binding),
+                                        initializeDelegateMember(bindingKey, decorateForScope(delegatingCodeBlock, binding.scope())))));
+            case SINGLETON_INSTANCE:
+                if (!binding.scope().isPresent()) {
+                    return Optional.empty();
+                }
+                // fall through
+            case CLASS_CONSTRUCTOR:
+                return Optional.of(
+                        CodeBlocks.concat(
+                                ImmutableList.of(
+                                        initializeDeferredDependencies(binding),
+                                        initializeMember(
+                                                bindingKey, initializeFactoryForContributionBinding(binding)))));
+            default:
+                throw new AssertionError();
+        }
+    }
+
+    private Optional<CodeBlock> initializeMembersInjectionBinding(BindingKey bindingKey) {
+        MembersInjectionBinding binding =
+                graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();
+
+        if (binding.injectionSites().isEmpty()) {
+            return Optional.empty();
         }
-        // fall through
-      case CLASS_CONSTRUCTOR:
+
         return Optional.of(
-            CodeBlocks.concat(
+                CodeBlocks.concat(
+                        ImmutableList.of(
+                                initializeDeferredDependencies(binding),
+                                initializeMember(bindingKey, initializeMembersInjectorForBinding(binding)))));
+    }
+
+    /**
+     * Initializes any dependencies of the given binding that need to be instantiated, i.e., as we get
+     * to them during normal initialization.
+     */
+    private CodeBlock initializeDeferredDependencies(Binding binding) {
+        return CodeBlocks.concat(
                 ImmutableList.of(
-                    initializeDeferredDependencies(binding),
-                    initializeMember(
-                        bindingKey, initializeFactoryForContributionBinding(binding)))));
-      default:
-        throw new AssertionError();
+                        initializeDelegateFactoriesForUninitializedDependencies(binding),
+                        initializeProducersFromProviderDependencies(binding)));
     }
-  }
-
-  private Optional<CodeBlock> initializeMembersInjectionBinding(BindingKey bindingKey) {
-    MembersInjectionBinding binding =
-        graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();
-
-    if (binding.injectionSites().isEmpty()) {
-      return Optional.empty();
-    }
-
-    return Optional.of(
-        CodeBlocks.concat(
-            ImmutableList.of(
-                initializeDeferredDependencies(binding),
-                initializeMember(bindingKey, initializeMembersInjectorForBinding(binding)))));
-  }
-
-  /**
-   * Initializes any dependencies of the given binding that need to be instantiated, i.e., as we get
-   * to them during normal initialization.
-   */
-  private CodeBlock initializeDeferredDependencies(Binding binding) {
-    return CodeBlocks.concat(
-        ImmutableList.of(
-            initializeDelegateFactoriesForUninitializedDependencies(binding),
-            initializeProducersFromProviderDependencies(binding)));
-  }
-
-  /**
-   * Initializes delegate factories for any dependencies of {@code binding} that are uninitialized
-   * because of a dependency cycle.
-   */
-  private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {
-    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
-
-    final ImmutableSet<BindingKey> bindingKeys = FluentIterable.from(binding.dependencies())
-            .transform(DependencyRequest::bindingKey)
-            .toSet();
-    for (BindingKey dependencyKey : bindingKeys) {
-      if (!getMemberSelect(dependencyKey).staticMember() && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
-        final CodeBlock codeBlock = CodeBlock.of("this.$L = new $T();", getMemberSelectExpression(dependencyKey), DELEGATE_FACTORY);
-        initializations.add(codeBlock);
-        setInitializationState(dependencyKey, DELEGATED);
-      }
-    }
-
-    return CodeBlocks.concat(initializations.build());
-  }
-
-  private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {
-    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
-    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
-      ResolvedBindings resolvedBindings =
-          graph.resolvedBindings().get(frameworkDependency.bindingKey());
-      if (resolvedBindings.frameworkClass().equals(Provider.class)
-          && frameworkDependency.frameworkClass().equals(Producer.class)) {
-        MemberSelect memberSelect =
-            producerFromProviderMemberSelects.get(frameworkDependency.bindingKey());
-        if (memberSelect != null) {
-          continue;
+
+    /**
+     * Initializes delegate factories for any dependencies of {@code binding} that are uninitialized
+     * because of a dependency cycle.
+     */
+    private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {
+        ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
+
+        final ImmutableSet<BindingKey> bindingKeys = FluentIterable.from(binding.dependencies())
+                .transform(DependencyRequest::bindingKey)
+                .toSet();
+        for (BindingKey dependencyKey : bindingKeys) {
+            if (!getMemberSelect(dependencyKey).staticMember() && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
+                final CodeBlock codeBlock = CodeBlock.of("this.$L = new $T();", getMemberSelectExpression(dependencyKey), DELEGATE_FACTORY);
+                initializations.add(codeBlock);
+                setInitializationState(dependencyKey, DELEGATED);
+            }
+        }
+
+        return CodeBlocks.concat(initializations.build());
+    }
+
+    private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {
+        ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
+        for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
+            ResolvedBindings resolvedBindings =
+                    graph.resolvedBindings().get(frameworkDependency.bindingKey());
+            if (resolvedBindings.frameworkClass().equals(Provider.class)
+                    && frameworkDependency.frameworkClass().equals(Producer.class)) {
+                MemberSelect memberSelect =
+                        producerFromProviderMemberSelects.get(frameworkDependency.bindingKey());
+                if (memberSelect != null) {
+                    continue;
+                }
+                FieldSpec frameworkField =
+                        addFrameworkField(resolvedBindings, Optional.of(PRODUCER));
+                memberSelect = localField(name, frameworkField.name);
+                producerFromProviderMemberSelects.put(frameworkDependency.bindingKey(), memberSelect);
+                initializations.add(
+                        CodeBlock.of(
+                                "this.$L = $L;",
+                                memberSelect.getExpressionFor(name),
+                                requestFulfillmentRegistry
+                                        .getRequestFulfillment(frameworkDependency.bindingKey())
+                                        .getSnippetForFrameworkDependency(frameworkDependency, name)));
+            }
+        }
+        return CodeBlocks.concat(initializations.build());
+    }
+
+    private CodeBlock initializeMember(BindingKey bindingKey, CodeBlock initializationCodeBlock) {
+        ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
+
+        CodeBlock memberSelect = getMemberSelectExpression(bindingKey);
+        CodeBlock delegateFactoryVariable = delegateFactoryVariableExpression(bindingKey);
+        if (getInitializationState(bindingKey).equals(DELEGATED)) {
+            initializations.add(
+                    CodeBlock.of(
+                            "$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, memberSelect));
         }
-        FieldSpec frameworkField =
-            addFrameworkField(resolvedBindings, Optional.of(PRODUCER));
-        memberSelect = localField(name, frameworkField.name);
-        producerFromProviderMemberSelects.put(frameworkDependency.bindingKey(), memberSelect);
-        initializations.add(
-            CodeBlock.of(
-                "this.$L = $L;",
-                memberSelect.getExpressionFor(name),
-                requestFulfillmentRegistry
-                    .getRequestFulfillment(frameworkDependency.bindingKey())
-                    .getSnippetForFrameworkDependency(frameworkDependency, name)));
-      }
-    }
-    return CodeBlocks.concat(initializations.build());
-  }
-
-  private CodeBlock initializeMember(BindingKey bindingKey, CodeBlock initializationCodeBlock) {
-    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
-
-    CodeBlock memberSelect = getMemberSelectExpression(bindingKey);
-    CodeBlock delegateFactoryVariable = delegateFactoryVariableExpression(bindingKey);
-    if (getInitializationState(bindingKey).equals(DELEGATED)) {
-      initializations.add(
-          CodeBlock.of(
-              "$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, memberSelect));
-    }
-    initializations.add(
-        CodeBlock.of("this.$L = $L;", memberSelect, initializationCodeBlock));
-    if (getInitializationState(bindingKey).equals(DELEGATED)) {
-      initializations.add(
-          CodeBlock.of("$L.setDelegatedProvider($L);", delegateFactoryVariable, memberSelect));
-    }
-    setInitializationState(bindingKey, INITIALIZED);
-
-    return CodeBlocks.concat(initializations.build());
-  }
-
-  private CodeBlock initializeDelegateMember(BindingKey bindingKey, CodeBlock initializationCodeBlock) {
-    final String delegateFieldName = delegateFieldNames.get(bindingKey.key());
-    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
-
-    CodeBlock memberSelect = getMemberSelectExpression(bindingKey);
-    CodeBlock delegateFactoryVariable = delegateFactoryVariableExpression(bindingKey);
-    if (getInitializationState(bindingKey).equals(DELEGATED)) {
         initializations.add(
-                CodeBlock.of(
-                        "$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, memberSelect));
-    }
-    if (!getInitializationState(bindingKey).equals(DELEGATED) && delegateFieldName != null) {
-        final TypeName interfaceTypeName = ClassName.get(bindingKey.key().type());
-        final CodeBlock.Builder codeBuilder = CodeBlock.builder();
-        codeBuilder.beginControlFlow("if (builder.$L != null)", delegateFieldName);
-        codeBuilder.add("$1L = new javax.inject.Provider<$2T>() {\n" +
-              "   public $2T get() {\n" +
-              "     return builder.$3L.get();\n" +
-              "   }\n" +
-              "};\n", memberSelect, interfaceTypeName, delegateFieldName);
-      codeBuilder.nextControlFlow("else");
-      codeBuilder.add(CodeBlock.of("this.$L = $L;", memberSelect, initializationCodeBlock));
-      codeBuilder.endControlFlow();
-      initializations.add(codeBuilder.build());
-    }else {
-      initializations.add(
-              CodeBlock.of("this.$L = $L;", memberSelect, initializationCodeBlock));
-    }
-    if (getInitializationState(bindingKey).equals(DELEGATED)) {
-      initializations.add(
-              CodeBlock.of("$L.setDelegatedProvider($L);", delegateFactoryVariable, memberSelect));
-    }
-    setInitializationState(bindingKey, INITIALIZED);
-
-    return CodeBlocks.concat(initializations.build());
-  }
-
-  private CodeBlock delegateFactoryVariableExpression(BindingKey key) {
-    return CodeBlock.of("$LDelegate", getMemberSelectExpression(key).toString().replace('.', '_'));
-  }
-
-  private CodeBlock initializeFactoryForContributionBinding(ContributionBinding binding) {
-    TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
-    final String delegateFieldName = delegateFieldNames.get(binding.key());
-    final String mockFieldName = mockFieldNames.get(binding.key());
-    switch (binding.bindingKind()) {
-      case COMPONENT:
-        return CodeBlock.of(
-            "$T.<$T>create($L)",
-            INSTANCE_FACTORY,
-            bindingKeyTypeName,
-            bindingKeyTypeName.equals(componentDefinitionTypeName())
-                ? "this"
-                : getComponentContributionExpression(
-                    ComponentRequirement.forDependency(binding.key().type())));
-
-      case COMPONENT_PROVISION:
-        {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
-          String dependencyVariable = simpleVariableName(dependencyType);
-          String componentMethod = binding.bindingElement().get().getSimpleName().toString();
-          CodeBlock callFactoryMethod =
-              CodeBlock.of("$L.$L()", dependencyVariable, componentMethod);
-          // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
-          // help to figure out what the method or return type is.  If we include a string
-          // of the return type or method name in the error message, that can defeat obfuscation.
-          // We can easily include the raw type (no generics) + annotation type (no values),
-          // using .class & String.format -- but that wouldn't be the whole story.
-          // What should we do?
+                CodeBlock.of("this.$L = $L;", memberSelect, initializationCodeBlock));
+        if (getInitializationState(bindingKey).equals(DELEGATED)) {
+            initializations.add(
+                    CodeBlock.of("$L.setDelegatedProvider($L);", delegateFactoryVariable, memberSelect));
+        }
+        setInitializationState(bindingKey, INITIALIZED);
+
+        return CodeBlocks.concat(initializations.build());
+    }
+
+    private CodeBlock initializeDelegateMember(BindingKey bindingKey, CodeBlock initializationCodeBlock) {
+
+        final String delegateFieldName = delegateFieldNames.get(bindingKey.key());
+        final String mockFieldName = mockFieldNames.get(bindingKey.key());
+
+        ProvisionBinding binding = (ProvisionBinding) graph.resolvedBindings().get(bindingKey).contributionBinding();
+        ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
+
+        CodeBlock memberSelect = getMemberSelectExpression(bindingKey);
+        CodeBlock delegateFactoryVariable = delegateFactoryVariableExpression(bindingKey);
+        if (getInitializationState(bindingKey).equals(DELEGATED)) {
+            initializations.add(
+                    CodeBlock.of(
+                            "$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, memberSelect));
+        }
+        if (!getInitializationState(bindingKey).equals(DELEGATED) && delegateFieldName != null) {
+            final TypeName interfaceTypeName = ClassName.get(bindingKey.key().type());
+            final CodeBlock.Builder codeBuilder = CodeBlock.builder();
+            codeBuilder.beginControlFlow("if (builder.$L != null)", delegateFieldName);
+            String withoutMock = "     return builder.$3L.get($4L);\n";
+            String withMock = "     if (builder.$5L != null) {\n" +
+                    "         return builder.$5L.get();\n" +
+                    "     } else {\n" +
+                    "         return builder.$3L.get($4L);\n" +
+                    "     }\n";
+
+            final String block = mockFieldName != null ? withMock : withoutMock;
+
+            final String format = "$1L = new javax.inject.Provider<$2T>() {\n" +
+                    "   public $2T get() {\n" +
+                    block +
+                    "   }\n" +
+                    "};\n";
+
+            if (mockFieldName != null) {
+                codeBuilder.add(format,
+                        memberSelect,
+                        interfaceTypeName,
+                        delegateFieldName,
+                        makeParametersCodeBlock(getStubDependencyArguments(binding)), mockFieldName);
+            }else {
+                codeBuilder.add(format,
+                        memberSelect,
+                        interfaceTypeName,
+                        delegateFieldName,
+                        makeParametersCodeBlock(getStubDependencyArguments(binding)));
+            }
+
+            codeBuilder.nextControlFlow("else");
+            codeBuilder.add(CodeBlock.of("this.$L = $L;", memberSelect, initializationCodeBlock));
+            codeBuilder.endControlFlow();
+            initializations.add(codeBuilder.build());
+        } else {
+            initializations.add(
+                    CodeBlock.of("this.$L = $L;", memberSelect, initializationCodeBlock));
+        }
+        if (getInitializationState(bindingKey).equals(DELEGATED)) {
+            initializations.add(
+                    CodeBlock.of("$L.setDelegatedProvider($L);", delegateFactoryVariable, memberSelect));
+        }
+        setInitializationState(bindingKey, INITIALIZED);
+
+        return CodeBlocks.concat(initializations.build());
+    }
+
+    private CodeBlock delegateFactoryVariableExpression(BindingKey key) {
+        return CodeBlock.of("$LDelegate", getMemberSelectExpression(key).toString().replace('.', '_'));
+    }
+
+    private CodeBlock initializeFactoryForContributionBinding(ContributionBinding binding) {
+        TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
+        final String delegateFieldName = delegateFieldNames.get(binding.key());
+        final String mockFieldName = mockFieldNames.get(binding.key());
+        switch (binding.bindingKind()) {
+            case COMPONENT:
+                return CodeBlock.of(
+                        "$T.<$T>create($L)",
+                        INSTANCE_FACTORY,
+                        bindingKeyTypeName,
+                        bindingKeyTypeName.equals(componentDefinitionTypeName())
+                                ? "this"
+                                : getComponentContributionExpression(
+                                ComponentRequirement.forDependency(binding.key().type())));
+
+            case COMPONENT_PROVISION: {
+                TypeElement dependencyType = dependencyTypeForBinding(binding);
+                String dependencyVariable = simpleVariableName(dependencyType);
+                String componentMethod = binding.bindingElement().get().getSimpleName().toString();
+                CodeBlock callFactoryMethod =
+                        CodeBlock.of("$L.$L()", dependencyVariable, componentMethod);
+                // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
+                // help to figure out what the method or return type is.  If we include a string
+                // of the return type or method name in the error message, that can defeat obfuscation.
+                // We can easily include the raw type (no generics) + annotation type (no values),
+                // using .class & String.format -- but that wouldn't be the whole story.
+                // What should we do?
 /*
 
           CodeBlock.Builder getMethodBodyBuilder = CodeBlock.builder();
@@ -1314,231 +1348,233 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
                       dependencyVariable,
                       getMethodBodyBuilder.build());
 =======*/
-          CodeBlock getMethodBody =
-              binding.nullableType().isPresent()
-                      || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
-                  ? CodeBlock.of("return $L;", callFactoryMethod)
-                  : CodeBlock.of(
-                      "return $T.checkNotNull($L, $S);",
-                      Preconditions.class,
-                      callFactoryMethod,
-                      CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-          ClassName dependencyClassName = ClassName.get(dependencyType);
-          String factoryName =
-              dependencyClassName.toString().replace('.', '_') + "_" + componentMethod;
-          MethodSpec.Builder getMethod =
-              methodBuilder("get")
-                  .addAnnotation(Override.class)
-                  .addModifiers(PUBLIC)
-                  .returns(bindingKeyTypeName)
-                  .addCode(getMethodBody);
-          if (binding.nullableType().isPresent()) {
-            getMethod.addAnnotation(
-                ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
-          }
-          component.addType(
-              TypeSpec.classBuilder(factoryName)
-                  .addSuperinterface(providerOf(bindingKeyTypeName))
-                  .addModifiers(PRIVATE, STATIC)
-                  .addField(dependencyClassName, dependencyVariable, PRIVATE, FINAL)
-                  .addMethod(
-                      constructorBuilder()
-                          .addParameter(dependencyClassName, dependencyVariable)
-                          .addStatement("this.$1L = $1L", dependencyVariable)
-                          .build())
-                  .addMethod(getMethod.build())
-                  .build());
-          return CodeBlock.of(
-              "new $L($L)",
-              factoryName,
-              getComponentContributionExpression(
-                  ComponentRequirement.forDependency(dependencyType.asType())));
-        }
-
-      case SUBCOMPONENT_BUILDER:
-
-        final CodeBlock expression = getMemberSelectExpression(BindingKey.contribution(Key.builder(graph.application().get()).build()));
+                CodeBlock getMethodBody =
+                        binding.nullableType().isPresent()
+                                || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
+                                ? CodeBlock.of("return $L;", callFactoryMethod)
+                                : CodeBlock.of(
+                                "return $T.checkNotNull($L, $S);",
+                                Preconditions.class,
+                                callFactoryMethod,
+                                CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+                ClassName dependencyClassName = ClassName.get(dependencyType);
+                String factoryName =
+                        dependencyClassName.toString().replace('.', '_') + "_" + componentMethod;
+                MethodSpec.Builder getMethod =
+                        methodBuilder("get")
+                                .addAnnotation(Override.class)
+                                .addModifiers(PUBLIC)
+                                .returns(bindingKeyTypeName)
+                                .addCode(getMethodBody);
+                if (binding.nullableType().isPresent()) {
+                    getMethod.addAnnotation(
+                            ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
+                }
+                component.addType(
+                        TypeSpec.classBuilder(factoryName)
+                                .addSuperinterface(providerOf(bindingKeyTypeName))
+                                .addModifiers(PRIVATE, STATIC)
+                                .addField(dependencyClassName, dependencyVariable, PRIVATE, FINAL)
+                                .addMethod(
+                                        constructorBuilder()
+                                                .addParameter(dependencyClassName, dependencyVariable)
+                                                .addStatement("this.$1L = $1L", dependencyVariable)
+                                                .build())
+                                .addMethod(getMethod.build())
+                                .build());
+                return CodeBlock.of(
+                        "new $L($L)",
+                        factoryName,
+                        getComponentContributionExpression(
+                                ComponentRequirement.forDependency(dependencyType.asType())));
+            }
 
-        String subcomponentName =
-            subcomponentNames.get(
-                graph.componentDescriptor()
-                    .subcomponentsByBuilderType()
-                    .get(MoreTypes.asTypeElement(binding.key().type())));
-        return CodeBlock.of(
-            Joiner.on('\n')
-                .join(
-                    "new $1L<$2T>() {",
-                    "  @Override public $2T get() {",
-                    "    return $4L.get().$5L(new $3LBuilder());",
-                    "  }",
-                    "}"),
-            // TODO(ronshapiro): Until we remove Factory, fully qualify the import so it doesn't
-            // conflict with dagger.android.ActivityInjector.Factory
+            case SUBCOMPONENT_BUILDER:
+
+                final CodeBlock expression = getMemberSelectExpression(BindingKey.contribution(Key.builder(graph.application().get()).build()));
+
+                String subcomponentName =
+                        subcomponentNames.get(
+                                graph.componentDescriptor()
+                                        .subcomponentsByBuilderType()
+                                        .get(MoreTypes.asTypeElement(binding.key().type())));
+                return CodeBlock.of(
+                        Joiner.on('\n')
+                                .join(
+                                        "new $1L<$2T>() {",
+                                        "  @Override public $2T get() {",
+                                        "    return $4L.get().$5L(new $3LBuilder());",
+                                        "  }",
+                                        "}"),
+                        // TODO(ronshapiro): Until we remove Factory, fully qualify the import so it doesn't
+                        // conflict with dagger.android.ActivityInjector.Factory
             /* 1 */ "dagger.internal.Factory",
             /* 2 */ bindingKeyTypeName,
             /* 3 */ subcomponentName,
             /* 4 */ expression,
             /* 5 */ "decorate" + subcomponentName);
 
-      case BUILDER_BINDING:
+            case BUILDER_BINDING:
 
-        final CodeBlock parameter = getComponentContributionExpression(ComponentRequirement.forBinding(binding));
-        CodeBlock parameterDecision;
-        if (delegateFieldName != null) {
-          parameterDecision = CodeBlock.of("builder.$L == null ? $L : builder.$L.get()", delegateFieldName, parameter, delegateFieldName);
-        }else {
-          parameterDecision = CodeBlock.of("$L", parameter);
-        }
-        return CodeBlock.of(
-            "$T.$L($L)",
-            InstanceFactory.class,
-            binding.nullableType().isPresent() ? "createNullable" : "create",
-                parameterDecision);
-
-      case INJECTION:
-      case PROVISION:
-        {
-          List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 3);
-          if (binding.requiresModuleInstance()) {
-            arguments.add(
-                getComponentContributionExpression(
-                    ComponentRequirement.forModule(binding.contributingModule().get().asType())));
-          }
-          arguments.addAll(getDependencyArguments(binding));
-
-          if (delegateFieldName != null && Util.bindingSupportsTestDelegate(binding)) {
-            if (mockFieldName != null) {
-              arguments.add(0, CodeBlock.of("builder.$L", mockFieldName));
+                final CodeBlock parameter = getComponentContributionExpression(ComponentRequirement.forBinding(binding));
+                CodeBlock parameterDecision;
+                if (delegateFieldName != null) {
+                    parameterDecision = CodeBlock.of("builder.$L == null ? $L : builder.$L.get()", delegateFieldName, parameter, delegateFieldName);
+                } else {
+                    parameterDecision = CodeBlock.of("$L", parameter);
+                }
+                return CodeBlock.of(
+                        "$T.$L($L)",
+                        InstanceFactory.class,
+                        binding.nullableType().isPresent() ? "createNullable" : "create",
+                        parameterDecision);
+
+            case INJECTION:
+            case PROVISION: {
+
+                if (binding.contributedType().toString().contains("PermissionService")) {
+                    int a = 0;
+                }
+
+                List<CodeBlock> arguments =
+                        Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 3);
+                if (binding.requiresModuleInstance()) {
+                    arguments.add(
+                            getComponentContributionExpression(
+                                    ComponentRequirement.forModule(binding.contributingModule().get().asType())));
+                }
+                arguments.addAll(getDependencyArguments(binding));
+
+                if (delegateFieldName != null && Util.bindingSupportsTestDelegate(binding)) {
+                    if (mockFieldName != null) {
+                        arguments.add(0, CodeBlock.of("builder.$L", mockFieldName));
+                    }
+                    arguments.add(0, CodeBlock.of("builder.$L", delegateFieldName));
+                }
+
+                CodeBlock factoryCreate =
+                        CodeBlock.of(
+                                "$T.create($L)",
+                                this.generatedClassNameForBinding(binding),
+                                makeParametersCodeBlock(arguments));
+
+                // If scoping a parameterized factory for an @Inject class, Java 7 cannot always infer the
+                // type properly, so cast to a raw framework type before scoping.
+                if (binding.bindingKind().equals(INJECTION)
+                        && binding.unresolved().isPresent()
+                        && binding.scope().isPresent()) {
+                    factoryCreate =
+                            CodeBlock.of("($T) $L", binding.bindingType().frameworkClass(), factoryCreate);
+                }
+                return decorateForScope(factoryCreate, binding.scope());
             }
-            arguments.add(0, CodeBlock.of("builder.$L", delegateFieldName));
-          }
-
-          CodeBlock factoryCreate =
-              CodeBlock.of(
-                  "$T.create($L)",
-                  this.generatedClassNameForBinding(binding),
-                  makeParametersCodeBlock(arguments));
-
-          // If scoping a parameterized factory for an @Inject class, Java 7 cannot always infer the
-          // type properly, so cast to a raw framework type before scoping.
-          if (binding.bindingKind().equals(INJECTION)
-              && binding.unresolved().isPresent()
-              && binding.scope().isPresent()) {
-            factoryCreate =
-                CodeBlock.of("($T) $L", binding.bindingType().frameworkClass(), factoryCreate);
-          }
-          return decorateForScope(factoryCreate, binding.scope());
-        }
 
-      case COMPONENT_PRODUCTION:
-        {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
-          return CodeBlock.of(
-              Joiner.on('\n')
-                  .join(
-                      "new $1T<$2T>() {",
-                      "  private final $6T $7L = $4L;",
-                      "  @Override public $3T<$2T> get() {",
-                      "    return $7L.$5L();",
-                      "  }",
-                      "}"),
+            case COMPONENT_PRODUCTION: {
+                TypeElement dependencyType = dependencyTypeForBinding(binding);
+                return CodeBlock.of(
+                        Joiner.on('\n')
+                                .join(
+                                        "new $1T<$2T>() {",
+                                        "  private final $6T $7L = $4L;",
+                                        "  @Override public $3T<$2T> get() {",
+                                        "    return $7L.$5L();",
+                                        "  }",
+                                        "}"),
               /* 1 */ PRODUCER,
               /* 2 */ TypeName.get(binding.key().type()),
               /* 3 */ LISTENABLE_FUTURE,
               /* 4 */ getComponentContributionExpression(
-                  ComponentRequirement.forDependency(dependencyType.asType())),
+                                ComponentRequirement.forDependency(dependencyType.asType())),
               /* 5 */ binding.bindingElement().get().getSimpleName(),
               /* 6 */ TypeName.get(dependencyType.asType()),
               /* 7 */ simpleVariableName(dependencyType));
-        }
+            }
 
-      case PRODUCTION:
-        {
-          List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
-          if (binding.requiresModuleInstance()) {
-            arguments.add(
-                getComponentContributionExpression(
-                    ComponentRequirement.forModule(binding.contributingModule().get().asType())));
-          }
-          arguments.addAll(getDependencyArguments(binding));
+            case PRODUCTION: {
+                List<CodeBlock> arguments =
+                        Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
+                if (binding.requiresModuleInstance()) {
+                    arguments.add(
+                            getComponentContributionExpression(
+                                    ComponentRequirement.forModule(binding.contributingModule().get().asType())));
+                }
+                arguments.addAll(getDependencyArguments(binding));
 
-          return CodeBlock.of(
-              "new $T($L)",
-              this.generatedClassNameForBinding(binding),
-              makeParametersCodeBlock(arguments));
-        }
+                return CodeBlock.of(
+                        "new $T($L)",
+                        this.generatedClassNameForBinding(binding),
+                        makeParametersCodeBlock(arguments));
+            }
 
-      case SYNTHETIC_MAP:
-        FrameworkDependency frameworkDependency = getOnlyElement(binding.frameworkDependencies());
-        return CodeBlock.of(
-            "$T.create($L)",
-            mapFactoryClassName(binding),
-            requestFulfillmentRegistry
-                .getRequestFulfillment(frameworkDependency.bindingKey())
-                .getSnippetForFrameworkDependency(frameworkDependency, name));
+            case SYNTHETIC_MAP:
+                FrameworkDependency frameworkDependency = getOnlyElement(binding.frameworkDependencies());
+                return CodeBlock.of(
+                        "$T.create($L)",
+                        mapFactoryClassName(binding),
+                        requestFulfillmentRegistry
+                                .getRequestFulfillment(frameworkDependency.bindingKey())
+                                .getSnippetForFrameworkDependency(frameworkDependency, name));
 
-      case SYNTHETIC_MULTIBOUND_SET:
-        return initializeFactoryForSetMultibinding(binding);
+            case SYNTHETIC_MULTIBOUND_SET:
+                return initializeFactoryForSetMultibinding(binding);
 
-      case SYNTHETIC_MULTIBOUND_MAP:
-        return initializeFactoryForMapMultibinding(binding);
+            case SYNTHETIC_MULTIBOUND_MAP:
+                return initializeFactoryForMapMultibinding(binding);
 
-      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
-        return initializeFactoryForSyntheticReleasableReferenceManagerBinding(binding);
+            case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
+                return initializeFactoryForSyntheticReleasableReferenceManagerBinding(binding);
 
-      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
-        return initializeFactoryForSyntheticSetOfReleasableReferenceManagers(binding);
+            case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
+                return initializeFactoryForSyntheticSetOfReleasableReferenceManagers(binding);
 
-      case SYNTHETIC_OPTIONAL_BINDING:
-        return initializeFactoryForSyntheticOptionalBinding(binding);
+            case SYNTHETIC_OPTIONAL_BINDING:
+                return initializeFactoryForSyntheticOptionalBinding(binding);
 
-      default:
-        throw new AssertionError(binding);
-    }
-  }
-
-  private CodeBlock getCodeBlock(ContributionBinding binding, CodeBlock callFactoryMethod) {
-    return binding.nullableType().isPresent()
-            || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
-        ? CodeBlock.of("return $L;", callFactoryMethod)
-        : CodeBlock.of("return $T.checkNotNull($L, $S);",
-            Preconditions.class,
-            callFactoryMethod,
-            CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-  }
-
-  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
-    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
-  }
-
-  private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope) {
-    if (!maybeScope.isPresent()) {
-      return factoryCreate;
-    }
-    Scope scope = maybeScope.get();
-    if (requiresReleasableReferences(scope)) {
-      return CodeBlock.of(
-          "$T.create($L, $L)",
-          REFERENCE_RELEASING_PROVIDER,
-          factoryCreate,
-          getReferenceReleasingProviderManagerExpression(scope));
-    } else {
-      return CodeBlock.of(
-          "$T.provider($L)",
-          scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK,
-          factoryCreate);
-    }
-  }
-
-  private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
-    return binding.injectionSites().isEmpty()
-        ? CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS)
-        : CodeBlock.of(
-            "$T.create($L)",
-            membersInjectorNameForType(binding.membersInjectedType()),
-            makeParametersCodeBlock(getDependencyArguments(binding)));
+            default:
+                throw new AssertionError(binding);
+        }
+    }
+
+    private CodeBlock getCodeBlock(ContributionBinding binding, CodeBlock callFactoryMethod) {
+        return binding.nullableType().isPresent()
+                || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
+                ? CodeBlock.of("return $L;", callFactoryMethod)
+                : CodeBlock.of("return $T.checkNotNull($L, $S);",
+                Preconditions.class,
+                callFactoryMethod,
+                CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+    }
+
+    private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
+        return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
+    }
+
+    private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope) {
+        if (!maybeScope.isPresent()) {
+            return factoryCreate;
+        }
+        Scope scope = maybeScope.get();
+        if (requiresReleasableReferences(scope)) {
+            return CodeBlock.of(
+                    "$T.create($L, $L)",
+                    REFERENCE_RELEASING_PROVIDER,
+                    factoryCreate,
+                    getReferenceReleasingProviderManagerExpression(scope));
+        } else {
+            return CodeBlock.of(
+                    "$T.provider($L)",
+                    scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK,
+                    factoryCreate);
+        }
+    }
+
+    private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
+        return binding.injectionSites().isEmpty()
+                ? CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS)
+                : CodeBlock.of(
+                "$T.create($L)",
+                membersInjectorNameForType(binding.membersInjectedType()),
+                makeParametersCodeBlock(getDependencyArguments(binding)));
 /*
     switch (binding.injectionStrategy()) {
       case NO_OP:
@@ -1553,267 +1589,299 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
         throw new AssertionError();
     }
 */
-  }
-
-  /**
-   * The expressions that represent factory arguments for the dependencies of a binding.
-   */
-  private ImmutableList<CodeBlock> getDependencyArguments(Binding binding) {
-    ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
-    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
-      parameters.add(getDependencyArgument(frameworkDependency));
-    }
-    return parameters.build();
-  }
-
-  /** Returns the expression to use as an argument for a dependency. */
-  private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency) {
-    BindingKey requestedKey = frameworkDependency.bindingKey();
-    ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
-    if (resolvedBindings.frameworkClass().equals(Provider.class)
-        && frameworkDependency.frameworkClass().equals(Producer.class)) {
-      return producerFromProviderMemberSelects.get(requestedKey).getExpressionFor(name);
-    } else {
-      RequestFulfillment requestFulfillment =
-          requestFulfillmentRegistry.getRequestFulfillment(requestedKey);
-      return requestFulfillment.getSnippetForFrameworkDependency(frameworkDependency, name);
-    }
-  }
-
-  private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding binding) {
-    CodeBlock.Builder builder =
-        CodeBlock.builder().add("$T.", setFactoryClassName(binding.bindingType(), binding.key()));
-    boolean useRawTypes = useRawType(binding);
-    if (!useRawTypes) {
-      SetType setType = SetType.from(binding.key());
-      builder.add(
-          "<$T>",
-          setType.elementsAreTypeOf(Produced.class)
-              ? setType.unwrappedElementType(Produced.class)
-              : setType.elementType());
-    }
-    int individualProviders = 0;
-    int setProviders = 0;
-    CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
-    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
-      ContributionType contributionType =
-          graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
-      String methodName;
-      String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
-      switch (contributionType) {
-        case SET:
-          individualProviders++;
-          methodName = "add" + methodNameSuffix;
-          break;
-        case SET_VALUES:
-          setProviders++;
-          methodName = "addCollection" + methodNameSuffix;
-          break;
-        default:
-          throw new AssertionError(frameworkDependency + " is not a set multibinding");
-      }
-
-      builderMethodCalls.add(
-          ".$L($L)",
-          methodName,
-          potentiallyCast(
-              useRawTypes,
-              frameworkDependency.frameworkClass(),
-              getDependencyArgument(frameworkDependency)));
-    }
-    builder.add("builder($L, $L)", individualProviders, setProviders);
-    builder.add(builderMethodCalls.build());
-    return builder.add(".build()").build();
-  }
-
-  private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding binding) {
-    ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
-
-    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    MapType mapType = MapType.from(binding.key().type());
-    CodeBlock.Builder builderCall =
-        CodeBlock.builder().add("$T.", frameworkMapFactoryClassName(binding.bindingType()));
-    boolean useRawTypes = useRawType(binding);
-    if (!useRawTypes) {
-      builderCall.add("<$T, $T>", TypeName.get(mapType.keyType()),
-          TypeName.get(mapType.unwrappedValueType(binding.bindingType().frameworkClass())));
-    }
-    builderCall.add("builder($L)", frameworkDependencies.size());
-    codeBlocks.add(builderCall.build());
-
-    for (FrameworkDependency frameworkDependency : frameworkDependencies) {
-      BindingKey bindingKey = frameworkDependency.bindingKey();
-      ContributionBinding contributionBinding =
-          graph.resolvedBindings().get(bindingKey).contributionBinding();
-      CodeBlock value =
-          potentiallyCast(
-              useRawTypes,
-              frameworkDependency.frameworkClass(),
-              getDependencyArgument(frameworkDependency));
-      codeBlocks.add(
-          CodeBlock.of(
-              ".put($L, $L)", getMapKeyExpression(contributionBinding.mapKey().get()), value));
-    }
-    codeBlocks.add(CodeBlock.of(".build()"));
-
-    return CodeBlocks.concat(codeBlocks.build());
-  }
-
-  private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, CodeBlock notCasted) {
-    if (!shouldCast) {
-      return notCasted;
-    }
-    return CodeBlock.of("($T) $L", classToCast, notCasted);
-  }
-
-  /**
-   * Initializes the factory for a {@link
-   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} binding.
-   *
-   * <p>The {@code get()} method just returns the component field with the {@link
-   * dagger.internal.ReferenceReleasingProviderManager} object.
-   */
-  private CodeBlock initializeFactoryForSyntheticReleasableReferenceManagerBinding(
-      ContributionBinding binding) {
-    // The scope is the value of the @ForReleasableReferences annotation.
-    Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
-
-    CodeBlock managerExpression;
-    if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
+    }
+
+    /**
+     * The expressions that represent factory arguments for the dependencies of a binding.
+     */
+    private ImmutableList<CodeBlock> getDependencyArguments(Binding binding) {
+        ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
+        for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
+            parameters.add(getDependencyArgument(frameworkDependency));
+        }
+        return parameters.build();
+    }
+
+    /**
+     * Returns the expression to use as an argument for a dependency.
+     */
+    private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency) {
+        BindingKey requestedKey = frameworkDependency.bindingKey();
+        ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
+        if (resolvedBindings.frameworkClass().equals(Provider.class)
+                && frameworkDependency.frameworkClass().equals(Producer.class)) {
+            return producerFromProviderMemberSelects.get(requestedKey).getExpressionFor(name);
+        } else {
+            RequestFulfillment requestFulfillment =
+                    requestFulfillmentRegistry.getRequestFulfillment(requestedKey);
+            return requestFulfillment.getSnippetForFrameworkDependency(frameworkDependency, name);
+        }
+    }
+
+    private ImmutableList<CodeBlock> getStubDependencyArguments(ProvisionBinding binding) {
+        ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
+        for (FrameworkDependency frameworkDependency : binding.stubFrameworkDependencies()) {
+            parameters.add(getStubDependencyArgument(frameworkDependency));
+        }
+        return parameters.build();
+    }
+
+    /**
+     * Returns the expression to use as an argument for a dependency.
+     */
+    private CodeBlock getStubDependencyArgument(FrameworkDependency frameworkDependency) {
+        BindingKey requestedKey = frameworkDependency.bindingKey();
+        ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
+        if (resolvedBindings.frameworkClass().equals(Provider.class)
+                && frameworkDependency.frameworkClass().equals(Producer.class)) {
+            return CodeBlock.of("$L.get()", producerFromProviderMemberSelects.get(requestedKey).getExpressionFor(name));
+        } else {
+            RequestFulfillment requestFulfillment =
+                    requestFulfillmentRegistry.getRequestFulfillment(requestedKey);
+            return CodeBlock.of("$L.get()", requestFulfillment.getSnippetForFrameworkDependency(frameworkDependency, name));
+        }
+    }
+
+    private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding binding) {
+        CodeBlock.Builder builder =
+                CodeBlock.builder().add("$T.", setFactoryClassName(binding.bindingType(), binding.key()));
+        boolean useRawTypes = useRawType(binding);
+        if (!useRawTypes) {
+            SetType setType = SetType.from(binding.key());
+            builder.add(
+                    "<$T>",
+                    setType.elementsAreTypeOf(Produced.class)
+                            ? setType.unwrappedElementType(Produced.class)
+                            : setType.elementType());
+        }
+        int individualProviders = 0;
+        int setProviders = 0;
+        CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
+        for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
+            ContributionType contributionType =
+                    graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
+            String methodName;
+            String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
+            switch (contributionType) {
+                case SET:
+                    individualProviders++;
+                    methodName = "add" + methodNameSuffix;
+                    break;
+                case SET_VALUES:
+                    setProviders++;
+                    methodName = "addCollection" + methodNameSuffix;
+                    break;
+                default:
+                    throw new AssertionError(frameworkDependency + " is not a set multibinding");
+            }
+
+            builderMethodCalls.add(
+                    ".$L($L)",
+                    methodName,
+                    potentiallyCast(
+                            useRawTypes,
+                            frameworkDependency.frameworkClass(),
+                            getDependencyArgument(frameworkDependency)));
+        }
+        builder.add("builder($L, $L)", individualProviders, setProviders);
+        builder.add(builderMethodCalls.build());
+        return builder.add(".build()").build();
+    }
+
+    private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding binding) {
+        ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
+
+        ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+        MapType mapType = MapType.from(binding.key().type());
+        CodeBlock.Builder builderCall =
+                CodeBlock.builder().add("$T.", frameworkMapFactoryClassName(binding.bindingType()));
+        boolean useRawTypes = useRawType(binding);
+        if (!useRawTypes) {
+            builderCall.add("<$T, $T>", TypeName.get(mapType.keyType()),
+                    TypeName.get(mapType.unwrappedValueType(binding.bindingType().frameworkClass())));
+        }
+        builderCall.add("builder($L)", frameworkDependencies.size());
+        codeBlocks.add(builderCall.build());
+
+        for (FrameworkDependency frameworkDependency : frameworkDependencies) {
+            BindingKey bindingKey = frameworkDependency.bindingKey();
+            ContributionBinding contributionBinding =
+                    graph.resolvedBindings().get(bindingKey).contributionBinding();
+            CodeBlock value =
+                    potentiallyCast(
+                            useRawTypes,
+                            frameworkDependency.frameworkClass(),
+                            getDependencyArgument(frameworkDependency));
+            codeBlocks.add(
+                    CodeBlock.of(
+                            ".put($L, $L)", getMapKeyExpression(contributionBinding.mapKey().get()), value));
+        }
+        codeBlocks.add(CodeBlock.of(".build()"));
+
+        return CodeBlocks.concat(codeBlocks.build());
+    }
+
+    private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, CodeBlock notCasted) {
+        if (!shouldCast) {
+            return notCasted;
+        }
+        return CodeBlock.of("($T) $L", classToCast, notCasted);
+    }
+
+    /**
+     * Initializes the factory for a {@link
+     * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} binding.
+     * <p>
+     * <p>The {@code get()} method just returns the component field with the {@link
+     * dagger.internal.ReferenceReleasingProviderManager} object.
+     */
+    private CodeBlock initializeFactoryForSyntheticReleasableReferenceManagerBinding(
+            ContributionBinding binding) {
+        // The scope is the value of the @ForReleasableReferences annotation.
+        Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
+
+        CodeBlock managerExpression;
+        if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
       /* The key's type is TypedReleasableReferenceManager<M>, so return
        * new TypedReleasableReferenceManager(field, metadata). */
-      TypeMirror metadataType =
-          MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
-      managerExpression =
-          typedReleasableReferenceManagerDecoratorExpression(
-              getReferenceReleasingProviderManagerExpression(scope),
-              scope.releasableReferencesMetadata(metadataType).get());
-    } else {
-      // The key's type is ReleasableReferenceManager, so return the field as is.
-      managerExpression = getReferenceReleasingProviderManagerExpression(scope);
-    }
-
-    TypeName keyType = TypeName.get(binding.key().type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyType))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyType)
-                    .addCode("return $L;", managerExpression)
-                    .build())
-            .build());
-  }
-
-  /**
-   * Initializes the factory for a {@link
-   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} binding.
-   *
-   * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
-   * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
-   * include managers for all reference-releasing scopes whose metadata type is {@code M}.
-   */
-  private CodeBlock initializeFactoryForSyntheticSetOfReleasableReferenceManagers(
-      ContributionBinding binding) {
-    Key key = binding.key();
-    SetType keyType = SetType.from(key);
-    ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
-    for (Map.Entry<Scope, MemberSelect> entry :
-        referenceReleasingProviderManagerFields.entrySet()) {
-      Scope scope = entry.getKey();
-      CodeBlock releasableReferenceManagerExpression = entry.getValue().getExpressionFor(name);
-
-      if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
-        managerExpressions.add(releasableReferenceManagerExpression);
-      } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
-        TypeMirror metadataType =
-            keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
-        Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
-        if (metadata.isPresent()) {
-          managerExpressions.add(
-              typedReleasableReferenceManagerDecoratorExpression(
-                  releasableReferenceManagerExpression, metadata.get()));
+            TypeMirror metadataType =
+                    MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
+            managerExpression =
+                    typedReleasableReferenceManagerDecoratorExpression(
+                            getReferenceReleasingProviderManagerExpression(scope),
+                            scope.releasableReferencesMetadata(metadataType).get());
+        } else {
+            // The key's type is ReleasableReferenceManager, so return the field as is.
+            managerExpression = getReferenceReleasingProviderManagerExpression(scope);
         }
-      } else {
-        throw new IllegalArgumentException("inappropriate key: " + binding);
-      }
-    }
-    TypeName keyTypeName = TypeName.get(key.type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyTypeName))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyTypeName)
-                    .addCode(
-                        "return new $T($T.asList($L));",
-                        HashSet.class,
-                        Arrays.class,
-                        makeParametersCodeBlock(managerExpressions.build()))
-                    .build())
-            .build());
-  }
-
-  /**
-   * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
-   * decorates the {@code managerExpression} to supply {@code metadata}.
-   */
-  private CodeBlock typedReleasableReferenceManagerDecoratorExpression(
-      CodeBlock managerExpression, AnnotationMirror metadata) {
-    return CodeBlock.of(
-        "new $T($L, $L)",
-        ParameterizedTypeName.get(
-            TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
-            TypeName.get(metadata.getAnnotationType())),
-        managerExpression,
-        new AnnotationExpression(metadata).getAnnotationInstanceExpression());
-  }
-
-  private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
-    checkArgument(
-        MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
-    return Scope.scope(
-        MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
-  }
-
-  /**
-   * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
-   * binding.
-   */
-  private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBinding binding) {
-    if (binding.explicitDependencies().isEmpty()) {
-      verify(
-          binding.bindingType().equals(BindingType.PROVISION),
-          "Absent optional bindings should be provisions: %s",
-          binding);
-      return optionalFactories.absentOptionalProvider(binding);
-    } else {
-      return optionalFactories.presentOptionalFactory(
-          binding, getOnlyElement(getDependencyArguments(binding)));
-    }
-  }
-
-  public static String simpleVariableName(Element typeElement) {
-    return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
-  }
-
-  /**
-   * Initialization state for a factory field.
-   */
-  enum InitializationState {
-    /** The field is {@code null}. */
-    UNINITIALIZED,
-
-    /** The field is set to a {@link DelegateFactory}. */
-    DELEGATED,
-
-    /** The field is set to an undelegated factory. */
-    INITIALIZED;
-  }
+
+        TypeName keyType = TypeName.get(binding.key().type());
+        return CodeBlock.of(
+                "$L",
+                anonymousClassBuilder("")
+                        .addSuperinterface(providerOf(keyType))
+                        .addMethod(
+                                methodBuilder("get")
+                                        .addAnnotation(Override.class)
+                                        .addModifiers(PUBLIC)
+                                        .returns(keyType)
+                                        .addCode("return $L;", managerExpression)
+                                        .build())
+                        .build());
+    }
+
+    /**
+     * Initializes the factory for a {@link
+     * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} binding.
+     * <p>
+     * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
+     * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
+     * include managers for all reference-releasing scopes whose metadata type is {@code M}.
+     */
+    private CodeBlock initializeFactoryForSyntheticSetOfReleasableReferenceManagers(
+            ContributionBinding binding) {
+        Key key = binding.key();
+        SetType keyType = SetType.from(key);
+        ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
+        for (Map.Entry<Scope, MemberSelect> entry :
+                referenceReleasingProviderManagerFields.entrySet()) {
+            Scope scope = entry.getKey();
+            CodeBlock releasableReferenceManagerExpression = entry.getValue().getExpressionFor(name);
+
+            if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
+                managerExpressions.add(releasableReferenceManagerExpression);
+            } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
+                TypeMirror metadataType =
+                        keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
+                Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
+                if (metadata.isPresent()) {
+                    managerExpressions.add(
+                            typedReleasableReferenceManagerDecoratorExpression(
+                                    releasableReferenceManagerExpression, metadata.get()));
+                }
+            } else {
+                throw new IllegalArgumentException("inappropriate key: " + binding);
+            }
+        }
+        TypeName keyTypeName = TypeName.get(key.type());
+        return CodeBlock.of(
+                "$L",
+                anonymousClassBuilder("")
+                        .addSuperinterface(providerOf(keyTypeName))
+                        .addMethod(
+                                methodBuilder("get")
+                                        .addAnnotation(Override.class)
+                                        .addModifiers(PUBLIC)
+                                        .returns(keyTypeName)
+                                        .addCode(
+                                                "return new $T($T.asList($L));",
+                                                HashSet.class,
+                                                Arrays.class,
+                                                makeParametersCodeBlock(managerExpressions.build()))
+                                        .build())
+                        .build());
+    }
+
+    /**
+     * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
+     * decorates the {@code managerExpression} to supply {@code metadata}.
+     */
+    private CodeBlock typedReleasableReferenceManagerDecoratorExpression(
+            CodeBlock managerExpression, AnnotationMirror metadata) {
+        return CodeBlock.of(
+                "new $T($L, $L)",
+                ParameterizedTypeName.get(
+                        TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
+                        TypeName.get(metadata.getAnnotationType())),
+                managerExpression,
+                new AnnotationExpression(metadata).getAnnotationInstanceExpression());
+    }
+
+    private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
+        checkArgument(
+                MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
+        return Scope.scope(
+                MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
+    }
+
+    /**
+     * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
+     * binding.
+     */
+    private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBinding binding) {
+        if (binding.explicitDependencies().isEmpty()) {
+            verify(
+                    binding.bindingType().equals(BindingType.PROVISION),
+                    "Absent optional bindings should be provisions: %s",
+                    binding);
+            return optionalFactories.absentOptionalProvider(binding);
+        } else {
+            return optionalFactories.presentOptionalFactory(
+                    binding, getOnlyElement(getDependencyArguments(binding)));
+        }
+    }
+
+    public static String simpleVariableName(Element typeElement) {
+        return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
+    }
+
+    /**
+     * Initialization state for a factory field.
+     */
+    enum InitializationState {
+        /**
+         * The field is {@code null}.
+         */
+        UNINITIALIZED,
+
+        /**
+         * The field is set to a {@link DelegateFactory}.
+         */
+        DELEGATED,
+
+        /**
+         * The field is set to an undelegated factory.
+         */
+        INITIALIZED;
+    }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ApplicationValidator.java b/compiler/src/main/java/dagger/internal/codegen/ApplicationValidator.java
new file mode 100644
index 000000000..ab04849ae
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ApplicationValidator.java
@@ -0,0 +1,103 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import javax.tools.Diagnostic;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+import static dagger.internal.codegen.Util.joinClassNames;
+
+public class ApplicationValidator {
+
+    private final Elements elements;
+    private final AppConfig.Provider appConfigProvider;
+    private final Messager messager;
+
+    public ApplicationValidator(Elements elements, AppConfig.Provider appConfigProvider, Messager messager) {
+        this.elements = elements;
+        this.appConfigProvider = appConfigProvider;
+        this.messager = messager;
+    }
+
+    private Stream<BindingGraph> flatMapAllSubgraphs(BindingGraph graph) {
+        return Stream.concat(
+                Stream.of(graph),
+                graph.subgraphs().stream().flatMap(this::flatMapAllSubgraphs));
+    }
+
+    public boolean validate(BindingGraph topGraph) {
+        final TypeElement appClass = appConfigProvider.get().getAppClass();
+        final List<ExecutableElement> methods = appClass.getEnclosedElements()
+                .stream()
+                .filter(element -> element.getKind() == ElementKind.METHOD)
+                .map(method -> (ExecutableElement) method)
+                .filter(method -> method.getSimpleName().toString().startsWith("decorate"))
+                .collect(Collectors.toList());
+
+        final List<BindingGraph> graphs = Stream.of(topGraph)
+                .flatMap(this::flatMapAllSubgraphs)
+                .filter(bindingGraph -> bindingGraph.componentDescriptor() != null && !bindingGraph.delegateRequirements().isEmpty())
+                .collect(Collectors.toList());
+
+        List<String> errorMessages = new ArrayList<>();
+
+        for (BindingGraph bindingGraph : graphs) {
+            final ClassName builderClassName = getBuilderClassName(bindingGraph.componentDescriptor(), bindingGraph.componentType());
+            final TypeElement builderType = elements.getTypeElement(builderClassName.packageName() + "." + Util.joinClassNames(builderClassName));
+            Optional<ExecutableElement> foundMethod = Optional.empty();
+            for (ExecutableElement method : methods) {
+                if (method.getSimpleName().toString().equals("decorate" + bindingGraph.componentType().getSimpleName().toString())
+                        && builderType.getQualifiedName().toString().endsWith(method.getReturnType().toString())
+                        && method.getParameters().size() == 1
+                        && builderType.getQualifiedName().toString().endsWith(method.getParameters().get(0).asType().toString())) {
+                    foundMethod = Optional.of(method);
+                    break;
+                }
+            }
+            if (!foundMethod.isPresent()) {
+                final String message = String.format("public %s decorate%s(%s builder) { return builder; }\n",
+                        joinClassNames(builderType.asType()),
+                        bindingGraph.componentType().getSimpleName().toString(),
+                        joinClassNames(builderType.asType()));
+                errorMessages.add(message);
+            }
+        }
+
+        if (!errorMessages.isEmpty()) {
+            for (String errorMessage : errorMessages) {
+                messager.printMessage(Diagnostic.Kind.ERROR, errorMessage, appClass);
+            }
+        }
+
+        return !errorMessages.isEmpty();
+
+    }
+
+    protected ClassName getBuilderClassName(ComponentDescriptor descriptor, TypeElement component) {
+        ClassName builderClassName;
+        if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
+            if (descriptor.builderSpec().isPresent()) {
+                builderClassName = ClassName.get(descriptor.builderSpec().get().builderDefinitionType());
+            }else {
+                builderClassName = Util.getDaggerComponentClassName(ClassName.get(component)).nestedClass("Builder");
+            }
+        }else {
+            if (descriptor.builderSpec().isPresent()) {
+                builderClassName = ClassName.get(descriptor.builderSpec().get().builderDefinitionType());
+            }else {
+                throw new IllegalStateException("builder spec missing for: " + simpleVariableName(component));
+            }
+        }
+        return builderClassName;
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index b8f6ad24a..56a8204a6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -29,6 +29,7 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
 import static dagger.internal.codegen.Key.indexByKey;
 import static dagger.internal.codegen.Scope.reusableScope;
+import static dagger.internal.codegen.Scope.uniqueScopeOf;
 import static dagger.internal.codegen.Util.toImmutableSet;
 import static java.util.function.Predicate.isEqual;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -56,8 +57,10 @@
 
 import java.util.*;
 import java.util.concurrent.ExecutionException;
+import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
+import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -225,7 +228,9 @@ TypeElement componentType() {
     private final Key.Factory keyFactory;
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
+    private final StubGenerator stubGenerator;
     private AppConfig.Provider appConfigProvider;
+    private final Messager messager;
     private TypeMirror application;
 
     Factory(
@@ -234,13 +239,17 @@ TypeElement componentType() {
             Key.Factory keyFactory,
             ProvisionBinding.Factory provisionBindingFactory,
             ProductionBinding.Factory productionBindingFactory,
-            AppConfig.Provider appConfigProvider) {
+            StubGenerator stubGenerator,
+            AppConfig.Provider appConfigProvider,
+            Messager messager) {
       this.elements = elements;
       this.injectBindingRegistry = injectBindingRegistry;
       this.keyFactory = keyFactory;
       this.provisionBindingFactory = provisionBindingFactory;
       this.productionBindingFactory = productionBindingFactory;
+      this.stubGenerator = stubGenerator;
       this.appConfigProvider = appConfigProvider;
+      this.messager = messager;
     }
 
     BindingGraph create(ComponentDescriptor componentDescriptor) {
@@ -385,7 +394,7 @@ private BindingGraph create(Optional<Resolver> parentResolver, ComponentDescript
           componentDescriptor,
           requestResolver.getResolvedBindings(),
           subgraphs.build(),
-          MoreTypes.equivalence().wrap(application),
+          Util.wrap(application),
           requestResolver.getOwnedModules());
     }
 
@@ -521,12 +530,28 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey, TypeMirror application) {
                 .map(Optional::get)
                 .forEach(contributionBindings::add);
 
-            if (bindingKey.key().type().toString().equals(application.toString())) {
+            if (contributionBindings.isEmpty()) {
+              injectBindingRegistry.delegateDeclarations().stream()
+                      .map(this::createDelegateBinding)
+                      .filter(binding ->  bindingKey.key().equals(binding.key()))
+                      .filter(binding -> !binding.scope().isPresent() || binding.scope().equals(componentDescriptor.scopes().stream().findFirst()))
+                      .map(binding -> {
+                        stubGenerator.generate((ProvisionBinding) binding, messager);
+                        return binding;
+                      })
+                      .forEach(contributionBindings::add);
+            }
+
+            if (bindingKey.key().type().toString().equals(application.toString()) && contributionBindings.isEmpty()) {
               explicitBindingsSet.stream()
                       .filter(contributionBinding -> contributionBinding.key().type().toString().equals(application.toString()))
                       .findFirst().ifPresent(contributionBindings::add);
             }
 
+            if (bindingKey.key().qualifier().isPresent() && bindingKey.key().qualifier().get().toString().toLowerCase().contains("api")) {
+              int a = 0;
+            }
+
             return ResolvedBindings.forContributionBindings(
                 bindingKey,
                 componentDescriptor,
@@ -712,7 +737,11 @@ private boolean multibindingsRequireProduction(
           ImmutableSet<DelegateDeclaration> delegateDeclarations) {
         ImmutableSet.Builder<ContributionBinding> builder = ImmutableSet.builder();
         for (DelegateDeclaration delegateDeclaration : delegateDeclarations) {
-          builder.add(createDelegateBinding(delegateDeclaration));
+          final ContributionBinding delegateBinding = createDelegateBinding(delegateDeclaration);
+          if (delegateBinding instanceof ProvisionBinding){
+            stubGenerator.generate((ProvisionBinding) delegateBinding, messager);
+          }
+          builder.add(delegateBinding);
         }
         return builder.build();
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index d68d86975..e6fe7c78a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -109,9 +109,7 @@
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.*;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
@@ -529,9 +527,12 @@ private void checkScopedBindings(BindingGraph graph) {
         switch (binding.bindingKind()) {
           case SYNTHETIC_DELEGATE_BINDING:
           case PROVISION:
-            message.append(
-                methodSignatureFormatter.format(
-                    MoreElements.asExecutable(binding.bindingElement().get())));
+            final Element element = binding.bindingElement().get();
+            if (element.getKind() == ElementKind.METHOD) {
+              message.append(
+                      methodSignatureFormatter.format(
+                              MoreElements.asExecutable(binding.bindingElement().get())));
+            }
             break;
 
           case INJECTION:
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 2416313e8..36dc32be4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -18,6 +18,7 @@
 
 import static dagger.internal.codegen.ModuleProcessingStep.moduleProcessingStep;
 import static dagger.internal.codegen.ModuleProcessingStep.producerModuleProcessingStep;
+import static dagger.internal.codegen.Util.initEquivalenceWrapper;
 
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
@@ -74,6 +75,8 @@ public SourceVersion getSupportedSourceVersion() {
     filer = new FormattingFiler(processingEnv.getFiler());
     CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
 
+    initEquivalenceWrapper(types);
+
     KeyFormatter keyFormatter = new KeyFormatter();
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     BindingDeclarationFormatter bindingDeclarationFormatter =
@@ -117,7 +120,6 @@ public SourceVersion getSupportedSourceVersion() {
 
     appConfigProvider = new AppConfig.Provider();
     StubGenerator stubGenerator = new StubGenerator(filer, elements, types, appConfigProvider, testRegistry);
-    //MockGenerator mockGenerator = new MockGenerator(filer, elements, types, appConfigProvider, testRegistry);
     FactoryGenerator factoryGenerator = new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);
     TestFactoryGenerator testFactoryGenerator = new TestFactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode, appConfigProvider, testRegistry);
     multipleGenerator = new MultipleSourceFileGenerator<>(filer, elements, Arrays.asList(stubGenerator, factoryGenerator, testFactoryGenerator));
@@ -157,6 +159,7 @@ public SourceVersion getSupportedSourceVersion() {
             keyFactory,
             provisionBindingFactory,
             membersInjectionBindingFactory,
+            bindingDelegateDeclarationFactory,
             compilerOptions);
 
     ModuleDescriptor.Factory moduleDescriptorFactory =
@@ -178,7 +181,9 @@ public SourceVersion getSupportedSourceVersion() {
             keyFactory,
             provisionBindingFactory,
             productionBindingFactory,
-            appConfigProvider);
+            stubGenerator,
+            appConfigProvider,
+            messager);
 
     AnnotationCreatorGenerator annotationCreatorGenerator =
             new AnnotationCreatorGenerator(filer, elements);
@@ -262,14 +267,15 @@ public SourceVersion getSupportedSourceVersion() {
                 provisionBindingFactory,
                 new ApplicationGenerator(filer, types, elements, bindingGraphFactory, componentDescriptorFactory),
                 stubGenerator,
-                new AnnotationGenerator(filer, elements, testRegistry)
+                new AnnotationGenerator(filer, elements, testRegistry),
+                new ApplicationValidator(elements, appConfigProvider, messager)
         )
     );
   }
 
   @Override
   protected void postRound(RoundEnvironment roundEnv) {
-    if (!roundEnv.processingOver()) {
+    if (!roundEnv.processingOver() && !roundEnv.errorRaised()) {
       try {
         injectBindingRegistry.generateSourcesForRequiredBindings(
             multipleGenerator, membersInjectorGenerator);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
index c0216c23c..b1dc91c90 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
@@ -156,7 +156,7 @@ boolean requiresAPassedInstance(Elements elements, Types types) {
   static ComponentRequirement forDependency(TypeMirror type) {
     return new dagger.internal.codegen.AutoValue_ComponentRequirement(
         Kind.DEPENDENCY,
-        MoreTypes.equivalence().wrap(checkNotNull(type)),
+        Util.wrap(checkNotNull(type)),
         Optional.empty(),
         Optional.empty(),
         simpleVariableName(MoreTypes.asTypeElement(type)),
@@ -167,7 +167,7 @@ static ComponentRequirement forModule(TypeMirror type) {
     final Module annotation = MoreTypes.asTypeElement(type).getAnnotation(Module.class);
     return new dagger.internal.codegen.AutoValue_ComponentRequirement(
         Kind.MODULE,
-        MoreTypes.equivalence().wrap(checkNotNull(type)),
+        Util.wrap(checkNotNull(type)),
         Optional.empty(),
         Optional.empty(),
         simpleVariableName(MoreTypes.asTypeElement(type)),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index b8bd4fa0f..91e0ca66c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -279,7 +279,7 @@ final TypeMirror contributedType() {
         Multimaps.index(
             mapBindings,
             mapBinding ->
-                MoreTypes.equivalence().wrap(mapBinding.mapKey().get().getAnnotationType())));
+                Util.wrap(mapBinding.mapKey().get().getAnnotationType())));
   }
 
   /**
@@ -292,7 +292,7 @@ final TypeMirror contributedType() {
 
     abstract B bindingElement(Element bindingElement);
 
-    abstract B contributingModule(TypeElement contributingModule);
+    abstract B contributingModule(Optional<TypeElement> contributingModule);
 
     abstract B key(Key key);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index c2d3e8d9f..545130215 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -29,9 +29,11 @@
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 
 /**
@@ -40,7 +42,7 @@
 @AutoValue
 abstract class DelegateDeclaration extends BindingDeclaration implements HasContributionType {
   @Override
-  abstract Optional<ExecutableElement> bindingElement();
+  abstract Optional<Element> bindingElement();
 
   abstract DependencyRequest delegateRequest();
 
@@ -76,5 +78,19 @@ DelegateDeclaration create(
           delegateRequest,
           wrapOptionalInEquivalence(getMapKey(bindsMethod)));
     }
+
+    DelegateDeclaration createFromInjectConstructor(Element sourceType, TypeMirror destinationType) {
+      checkArgument(MoreElements.isAnnotationPresent(sourceType, Binds.class));
+      DependencyRequest delegateRequest =
+              dependencyRequestFactory.forInlinedBinds(sourceType, sourceType.asType());
+      return new AutoValue_DelegateDeclaration(
+              ContributionType.UNIQUE,
+              keyFactory.forQualifiedType(Optional.empty(), destinationType),
+              Optional.empty(),
+              Optional.of(sourceType),
+              delegateRequest,
+              Optional.empty());
+    }
+
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index aaec20556..f3352f230 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -401,6 +401,10 @@ DependencyRequest forRequiredResolvedVariable(
       return newDependencyRequest(Optional.of(variableElement), resolvedType, qualifier, Optional.empty());
     }
 
+    DependencyRequest forInlinedBinds(Element sourceElement, TypeMirror destinationType) {
+      return newDependencyRequest(Optional.of(sourceElement), destinationType, Optional.empty(), Optional.empty());
+    }
+
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
         ExecutableType provisionMethodType) {
       checkNotNull(provisionMethod);
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index f1c3176d5..65a6dafbe 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -247,9 +247,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         createMethod = Optional.empty();
     }
 
-    if (constructorBuilder.isPresent()) {
-      factoryBuilder.addMethod(constructorBuilder.get().build());
-    }
+    constructorBuilder.ifPresent(builder -> factoryBuilder.addMethod(builder.build()));
 
     List<CodeBlock> parameters = Lists.newArrayList();
     for (DependencyRequest dependency : binding.explicitDependencies()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 24054f930..8489881d3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -30,18 +30,18 @@
 import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
+import dagger.Binds;
 import dagger.Component;
 import dagger.Provides;
-import java.util.ArrayDeque;
-import java.util.Deque;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
+
+import java.util.*;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.MirroredTypeException;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -56,143 +56,160 @@
  * @author Gregory Kick
  */
 final class InjectBindingRegistry {
-  private final Elements elements;
-  private final Types types;
-  private final Messager messager;
-  private final InjectValidator injectValidator;
-  private final Key.Factory keyFactory;
-  private final ProvisionBinding.Factory provisionBindingFactory;
-  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
-  private final CompilerOptions compilerOptions;
+    private final Elements elements;
+    private final Types types;
+    private final Messager messager;
+    private final InjectValidator injectValidator;
+    private final Key.Factory keyFactory;
+    private final ProvisionBinding.Factory provisionBindingFactory;
+    private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
+    private final DelegateDeclaration.Factory delegateDeclarationFactory;
+    private final CompilerOptions compilerOptions;
 
-  final class BindingsCollection<B extends Binding> {
-    private final BindingType bindingType;
-    private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
-    private final Deque<B> bindingsRequiringGeneration = new ArrayDeque<>();
-    private final Set<Key> materializedBindingKeys = Sets.newLinkedHashSet();
-    
-    BindingsCollection(BindingType bindingType) {
-      this.bindingType = bindingType;
-    }
+    private final Set<DelegateDeclaration> delegateDeclarations = new HashSet<>();
 
-    void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
-      for (B binding = bindingsRequiringGeneration.poll();
-          binding != null;
-          binding = bindingsRequiringGeneration.poll()) {
-        checkState(!binding.unresolved().isPresent());
-        generator.generate(binding);
-        materializedBindingKeys.add(binding.key());
-      }
-      // Because Elements instantiated across processing rounds are not guaranteed to be equals() to
-      // the logically same element, clear the cache after generating
-      bindingsByKey.clear();
+    public Set<DelegateDeclaration> delegateDeclarations() {
+        return this.delegateDeclarations;
     }
 
-    /** Returns a previously cached binding. */
-    B getBinding(Key key) {
-      return bindingsByKey.get(key);
-    }
+    final class BindingsCollection<B extends Binding> {
+        private final BindingType bindingType;
+        private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
+        private final Deque<B> bindingsRequiringGeneration = new ArrayDeque<>();
+        private final Set<Key> materializedBindingKeys = Sets.newLinkedHashSet();
 
-    /** Caches the binding and generates it if it needs generation. */
-    void tryRegisterBinding(B binding, boolean warnIfNotAlreadyGenerated) {
-      tryToCacheBinding(binding);
-      tryToGenerateBinding(binding, warnIfNotAlreadyGenerated);
-    }
+        BindingsCollection(BindingType bindingType) {
+            this.bindingType = bindingType;
+        }
 
-    /**
-     * Tries to generate a binding, not generating if it already is generated. For resolved
-     * bindings, this will try to generate the unresolved version of the binding.
-     */
-    void tryToGenerateBinding(B binding, boolean warnIfNotAlreadyGenerated) {
-      if (shouldGenerateBinding(binding, generatedClassNameForBinding(binding))) {
-        bindingsRequiringGeneration.offer(binding);
-        if (compilerOptions.warnIfInjectionFactoryNotGeneratedUpstream()
-            && warnIfNotAlreadyGenerated) {
-          messager.printMessage(
-              Kind.NOTE,
-              String.format(
-                  "Generating a %s for %s. "
-                      + "Prefer to run the dagger processor over that class instead.",
-                  bindingType.frameworkClass().getSimpleName(),
-                  types.erasure(binding.key().type()))); // erasure to strip <T> from msgs.
+        void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
+            for (B binding = bindingsRequiringGeneration.poll();
+                 binding != null;
+                 binding = bindingsRequiringGeneration.poll()) {
+                checkState(!binding.unresolved().isPresent());
+                generator.generate(binding);
+                materializedBindingKeys.add(binding.key());
+            }
+            // Because Elements instantiated across processing rounds are not guaranteed to be equals() to
+            // the logically same element, clear the cache after generating
+            bindingsByKey.clear();
         }
-      }
-    }
 
-    /** Returns true if the binding needs to be generated. */
-    private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
-      return !binding.unresolved().isPresent()
-          && elements.getTypeElement(factoryName.toString()) == null
-          && !materializedBindingKeys.contains(binding.key())
-          && !bindingsRequiringGeneration.contains(binding);
-    }
+        /**
+         * Returns a previously cached binding.
+         */
+        B getBinding(Key key) {
+            return bindingsByKey.get(key);
+        }
+
+        /**
+         * Caches the binding and generates it if it needs generation.
+         */
+        void tryRegisterBinding(B binding, boolean warnIfNotAlreadyGenerated) {
+            tryToCacheBinding(binding);
+            tryToGenerateBinding(binding, warnIfNotAlreadyGenerated);
+        }
 
-    /** Caches the binding for future lookups by key. */
-    private void tryToCacheBinding(B binding) {
-      // We only cache resolved bindings or unresolved bindings w/o type arguments.
-      // Unresolved bindings w/ type arguments aren't valid for the object graph.
-      if (binding.unresolved().isPresent()
-          || binding.bindingTypeElement().get().getTypeParameters().isEmpty()) {
-        Key key = binding.key();
-        Binding previousValue = bindingsByKey.put(key, binding);
-        checkState(previousValue == null || binding.equals(previousValue),
-            "couldn't register %s. %s was already registered for %s",
-            binding, previousValue, key);
-      }
+        /**
+         * Tries to generate a binding, not generating if it already is generated. For resolved
+         * bindings, this will try to generate the unresolved version of the binding.
+         */
+        void tryToGenerateBinding(B binding, boolean warnIfNotAlreadyGenerated) {
+            if (shouldGenerateBinding(binding, generatedClassNameForBinding(binding))) {
+                bindingsRequiringGeneration.offer(binding);
+                if (compilerOptions.warnIfInjectionFactoryNotGeneratedUpstream()
+                        && warnIfNotAlreadyGenerated) {
+                    messager.printMessage(
+                            Kind.NOTE,
+                            String.format(
+                                    "Generating a %s for %s. "
+                                            + "Prefer to run the dagger processor over that class instead.",
+                                    bindingType.frameworkClass().getSimpleName(),
+                                    types.erasure(binding.key().type()))); // erasure to strip <T> from msgs.
+                }
+            }
+        }
+
+        /**
+         * Returns true if the binding needs to be generated.
+         */
+        private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
+            return !binding.unresolved().isPresent()
+                    && elements.getTypeElement(factoryName.toString()) == null
+                    && !materializedBindingKeys.contains(binding.key())
+                    && !bindingsRequiringGeneration.contains(binding);
+        }
+
+        /**
+         * Caches the binding for future lookups by key.
+         */
+        private void tryToCacheBinding(B binding) {
+            // We only cache resolved bindings or unresolved bindings w/o type arguments.
+            // Unresolved bindings w/ type arguments aren't valid for the object graph.
+            if (binding.unresolved().isPresent()
+                    || binding.bindingTypeElement().get().getTypeParameters().isEmpty()) {
+                Key key = binding.key();
+                Binding previousValue = bindingsByKey.put(key, binding);
+                checkState(previousValue == null || binding.equals(previousValue),
+                        "couldn't register %s. %s was already registered for %s",
+                        binding, previousValue, key);
+            }
+        }
     }
-  }
 
-  private final BindingsCollection<ProvisionBinding> provisionBindings =
-      new BindingsCollection<>(BindingType.PROVISION);
-  private final BindingsCollection<MembersInjectionBinding> membersInjectionBindings =
-      new BindingsCollection<>(BindingType.MEMBERS_INJECTION);
+    private final BindingsCollection<ProvisionBinding> provisionBindings =
+            new BindingsCollection<>(BindingType.PROVISION);
+    private final BindingsCollection<MembersInjectionBinding> membersInjectionBindings =
+            new BindingsCollection<>(BindingType.MEMBERS_INJECTION);
 
-  InjectBindingRegistry(
-      Elements elements,
-      Types types,
-      Messager messager,
-      InjectValidator injectValidator,
-      Key.Factory keyFactory,
-      ProvisionBinding.Factory provisionBindingFactory,
-      MembersInjectionBinding.Factory membersInjectionBindingFactory,
-      CompilerOptions compilerOptions) {
-    this.elements = elements;
-    this.types = types;
-    this.messager = messager;
-    this.injectValidator = injectValidator;
-    this.keyFactory = keyFactory;
-    this.provisionBindingFactory = provisionBindingFactory;
-    this.membersInjectionBindingFactory = membersInjectionBindingFactory;
-    this.compilerOptions = compilerOptions;
-  }
+    InjectBindingRegistry(
+            Elements elements,
+            Types types,
+            Messager messager,
+            InjectValidator injectValidator,
+            Key.Factory keyFactory,
+            ProvisionBinding.Factory provisionBindingFactory,
+            MembersInjectionBinding.Factory membersInjectionBindingFactory,
+            DelegateDeclaration.Factory delegateDeclarationFactory,
+            CompilerOptions compilerOptions) {
+        this.elements = elements;
+        this.types = types;
+        this.messager = messager;
+        this.injectValidator = injectValidator;
+        this.keyFactory = keyFactory;
+        this.provisionBindingFactory = provisionBindingFactory;
+        this.membersInjectionBindingFactory = membersInjectionBindingFactory;
+        this.delegateDeclarationFactory = delegateDeclarationFactory;
+        this.compilerOptions = compilerOptions;
+    }
 
-  /**
-   * This method ensures that sources for all registered {@link Binding bindings} (either
-   * {@linkplain #registerBinding explicitly} or implicitly via
-   * {@link #getOrFindMembersInjectionBinding} or {@link #getOrFindProvisionBinding}) are generated.
-   */
-  void generateSourcesForRequiredBindings(SourceFileGenerator<ProvisionBinding> factoryGenerator,
-                                          MembersInjectorGenerator membersInjectorGenerator) throws SourceFileGenerationException {
-    membersInjectionBindings.generateBindings(membersInjectorGenerator);
-    provisionBindings.generateBindings(factoryGenerator);
-  }
+    /**
+     * This method ensures that sources for all registered {@link Binding bindings} (either
+     * {@linkplain #registerBinding explicitly} or implicitly via
+     * {@link #getOrFindMembersInjectionBinding} or {@link #getOrFindProvisionBinding}) are generated.
+     */
+    void generateSourcesForRequiredBindings(SourceFileGenerator<ProvisionBinding> factoryGenerator,
+                                            MembersInjectorGenerator membersInjectorGenerator) throws SourceFileGenerationException {
+        membersInjectionBindings.generateBindings(membersInjectorGenerator);
+        provisionBindings.generateBindings(factoryGenerator);
+    }
 
-  /**
-   * Registers the binding for generation and later lookup. If the binding is resolved, we also
-   * attempt to register an unresolved version of it.
-   */
-  private void registerBinding(ProvisionBinding binding, boolean warnIfNotAlreadyGenerated) {
-    provisionBindings.tryRegisterBinding(binding, warnIfNotAlreadyGenerated);
-    if (binding.unresolved().isPresent()) {
-      provisionBindings.tryToGenerateBinding(binding.unresolved().get(), warnIfNotAlreadyGenerated);
+    /**
+     * Registers the binding for generation and later lookup. If the binding is resolved, we also
+     * attempt to register an unresolved version of it.
+     */
+    private void registerBinding(ProvisionBinding binding, boolean warnIfNotAlreadyGenerated) {
+        provisionBindings.tryRegisterBinding(binding, warnIfNotAlreadyGenerated);
+        if (binding.unresolved().isPresent()) {
+            provisionBindings.tryToGenerateBinding(binding.unresolved().get(), warnIfNotAlreadyGenerated);
+        }
     }
-  }
 
-  /**
-   * Registers the binding for generation and later lookup. If the binding is resolved, we also
-   * attempt to register an unresolved version of it.
-   */
-  private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotAlreadyGenerated) {
+    /**
+     * Registers the binding for generation and later lookup. If the binding is resolved, we also
+     * attempt to register an unresolved version of it.
+     */
+    private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotAlreadyGenerated) {
     /*
      * We generate MembersInjector classes for types with @Inject constructors only if they have any
      * injection sites.
@@ -202,125 +219,143 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
      *
      * Warn only when registering bindings post-hoc for those types.
      */
-    warnIfNotAlreadyGenerated =
-        warnIfNotAlreadyGenerated
-            && (!injectedConstructors(binding.membersInjectedType()).isEmpty()
-                ? !binding.injectionSites().isEmpty()
-                : binding.hasLocalInjectionSites());
-    membersInjectionBindings.tryRegisterBinding(binding, warnIfNotAlreadyGenerated);
-    if (binding.unresolved().isPresent()) {
-      membersInjectionBindings.tryToGenerateBinding(
-          binding.unresolved().get(), warnIfNotAlreadyGenerated);
+        warnIfNotAlreadyGenerated =
+                warnIfNotAlreadyGenerated
+                        && (!injectedConstructors(binding.membersInjectedType()).isEmpty()
+                        ? !binding.injectionSites().isEmpty()
+                        : binding.hasLocalInjectionSites());
+        membersInjectionBindings.tryRegisterBinding(binding, warnIfNotAlreadyGenerated);
+        if (binding.unresolved().isPresent()) {
+            membersInjectionBindings.tryToGenerateBinding(
+                    binding.unresolved().get(), warnIfNotAlreadyGenerated);
+        }
     }
-  }
-
-  @CanIgnoreReturnValue
-  Optional<ProvisionBinding> tryRegisterConstructor(ExecutableElement constructorElement) {
-    return tryRegisterConstructor(constructorElement, Optional.empty(), false);
-  }
 
-  @CanIgnoreReturnValue
-  private Optional<ProvisionBinding> tryRegisterConstructor(
-      ExecutableElement constructorElement,
-      Optional<TypeMirror> resolvedType,
-      boolean warnIfNotAlreadyGenerated) {
-    TypeElement typeElement = MoreElements.asType(constructorElement.getEnclosingElement());
-    DeclaredType type = MoreTypes.asDeclared(typeElement.asType());
-    Key key = keyFactory.forInjectConstructorWithResolvedType(type);
-    ProvisionBinding cachedBinding = provisionBindings.getBinding(key);
-    if (cachedBinding != null) {
-      return Optional.of(cachedBinding);
+    @CanIgnoreReturnValue
+    Optional<ProvisionBinding> tryRegisterConstructor(ExecutableElement constructorElement) {
+        return tryRegisterConstructor(constructorElement, Optional.empty(), false);
     }
 
-    ValidationReport<TypeElement> report = injectValidator.validateConstructor(constructorElement);
-    report.printMessagesTo(messager);
-    if (report.isClean()) {
-      ProvisionBinding binding =
-          provisionBindingFactory.forInjectConstructor(constructorElement, resolvedType);
-      registerBinding(binding, warnIfNotAlreadyGenerated);
-      if (membersInjectionBindingFactory.hasInjectedMembersIn(type)) {
-        tryRegisterMembersInjectedType(typeElement, resolvedType, warnIfNotAlreadyGenerated);
-      }
-      return Optional.of(binding);
-    }
-    return Optional.empty();
-  }
+    @CanIgnoreReturnValue
+    private Optional<ProvisionBinding> tryRegisterConstructor(
+            ExecutableElement constructorElement,
+            Optional<TypeMirror> resolvedType,
+            boolean warnIfNotAlreadyGenerated) {
+        TypeElement typeElement = MoreElements.asType(constructorElement.getEnclosingElement());
+        DeclaredType type = MoreTypes.asDeclared(typeElement.asType());
+        Key key = keyFactory.forInjectConstructorWithResolvedType(type);
+        ProvisionBinding cachedBinding = provisionBindings.getBinding(key);
+        if (cachedBinding != null) {
+            return Optional.of(cachedBinding);
+        }
 
-  @CanIgnoreReturnValue
-  Optional<MembersInjectionBinding> tryRegisterMembersInjectedType(TypeElement typeElement) {
-    return tryRegisterMembersInjectedType(typeElement, Optional.empty(), false);
-  }
+        ValidationReport<TypeElement> report = injectValidator.validateConstructor(constructorElement);
+        report.printMessagesTo(messager);
+        if (report.isClean()) {
 
-  @CanIgnoreReturnValue
-  private Optional<MembersInjectionBinding> tryRegisterMembersInjectedType(
-      TypeElement typeElement,
-      Optional<TypeMirror> resolvedType,
-      boolean warnIfNotAlreadyGenerated) {
-    DeclaredType type = MoreTypes.asDeclared(typeElement.asType());
-    Key key = keyFactory.forInjectConstructorWithResolvedType(type);
-    MembersInjectionBinding cachedBinding = membersInjectionBindings.getBinding(key);
-    if (cachedBinding != null) {
-      return Optional.of(cachedBinding);
+            final Element enclosingElement = constructorElement.getEnclosingElement();
+            final Binds binds = enclosingElement.getAnnotation(Binds.class);
+            if (binds != null) {
+                this.createDelegateDeclaration(enclosingElement, binds);
+            }
+            ProvisionBinding binding =
+                    provisionBindingFactory.forInjectConstructor(constructorElement, resolvedType);
+            registerBinding(binding, warnIfNotAlreadyGenerated);
+            if (membersInjectionBindingFactory.hasInjectedMembersIn(type)) {
+                tryRegisterMembersInjectedType(typeElement, resolvedType, warnIfNotAlreadyGenerated);
+            }
+            return Optional.of(binding);
+        }
+        return Optional.empty();
     }
 
-    ValidationReport<TypeElement> report =
-        injectValidator.validateMembersInjectionType(typeElement);
-    report.printMessagesTo(messager);
-    if (report.isClean()) {
-      MembersInjectionBinding binding =
-          membersInjectionBindingFactory.forInjectedType(type, resolvedType);
-      registerBinding(binding, warnIfNotAlreadyGenerated);
-      if (binding.parentKey().isPresent() && !binding.injectionSites().isEmpty()) {
-        getOrFindMembersInjectionBinding(binding.parentKey().get());
-      }
-      return Optional.of(binding);
+    private void createDelegateDeclaration(Element enclosingElement, Binds binds) {
+        TypeMirror mirroredInterface = null;
+        try {
+            binds.to();
+        } catch (MirroredTypeException e) {
+            mirroredInterface = e.getTypeMirror();
+        }
+        final DelegateDeclaration delegate =
+                delegateDeclarationFactory.createFromInjectConstructor(enclosingElement, mirroredInterface);
+        delegateDeclarations.add(delegate);
     }
-    return Optional.empty();
-  }
 
-  @CanIgnoreReturnValue
-  Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
-    checkNotNull(key);
-    if (!key.isValidImplicitProvisionKey(types)) {
-      return Optional.empty();
-    }
-    ProvisionBinding binding = provisionBindings.getBinding(key);
-    if (binding != null) {
-      return Optional.of(binding);
+    @CanIgnoreReturnValue
+    Optional<MembersInjectionBinding> tryRegisterMembersInjectedType(TypeElement typeElement) {
+        return tryRegisterMembersInjectedType(typeElement, Optional.empty(), false);
     }
 
-    // ok, let's see if we can find an @Inject constructor
-    TypeElement element = MoreElements.asType(types.asElement(key.type()));
-    ImmutableSet<ExecutableElement> injectConstructors = injectedConstructors(element);
-    switch (injectConstructors.size()) {
-      case 0:
-        // No constructor found.
+    @CanIgnoreReturnValue
+    private Optional<MembersInjectionBinding> tryRegisterMembersInjectedType(
+            TypeElement typeElement,
+            Optional<TypeMirror> resolvedType,
+            boolean warnIfNotAlreadyGenerated) {
+        DeclaredType type = MoreTypes.asDeclared(typeElement.asType());
+        Key key = keyFactory.forInjectConstructorWithResolvedType(type);
+        MembersInjectionBinding cachedBinding = membersInjectionBindings.getBinding(key);
+        if (cachedBinding != null) {
+            return Optional.of(cachedBinding);
+        }
+
+        ValidationReport<TypeElement> report =
+                injectValidator.validateMembersInjectionType(typeElement);
+        report.printMessagesTo(messager);
+        if (report.isClean()) {
+            MembersInjectionBinding binding =
+                    membersInjectionBindingFactory.forInjectedType(type, resolvedType);
+            registerBinding(binding, warnIfNotAlreadyGenerated);
+            if (binding.parentKey().isPresent() && !binding.injectionSites().isEmpty()) {
+                getOrFindMembersInjectionBinding(binding.parentKey().get());
+            }
+            return Optional.of(binding);
+        }
         return Optional.empty();
-      case 1:
-        return tryRegisterConstructor(
-            Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()), true);
-      default:
-        throw new IllegalStateException("Found multiple @Inject constructors: "
-            + injectConstructors);
     }
-  }
 
-  /**
-   * Returns a {@link MembersInjectionBinding} for {@code key}. If none has been registered yet,
-   * registers one, along with all necessary members injection bindings for superclasses.
-   */
-  @CanIgnoreReturnValue
-  Optional<MembersInjectionBinding> getOrFindMembersInjectionBinding(Key key) {
-    checkNotNull(key);
-    // TODO(gak): is checking the kind enough?
-    checkArgument(key.isValidMembersInjectionKey());
-    MembersInjectionBinding binding = membersInjectionBindings.getBinding(key);
-    if (binding != null) {
-      return Optional.of(binding);
+    @CanIgnoreReturnValue
+    Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
+        checkNotNull(key);
+        if (!key.isValidImplicitProvisionKey(types)) {
+            return Optional.empty();
+        }
+        ProvisionBinding binding = provisionBindings.getBinding(key);
+        if (binding != null) {
+            return Optional.of(binding);
+        }
+
+        // ok, let's see if we can find an @Inject constructor
+        TypeElement element = MoreElements.asType(types.asElement(key.type()));
+        ImmutableSet<ExecutableElement> injectConstructors = injectedConstructors(element);
+        switch (injectConstructors.size()) {
+            case 0:
+                // No constructor found.
+                return Optional.empty();
+            case 1:
+                return tryRegisterConstructor(
+                        Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()), true);
+            default:
+                throw new IllegalStateException("Found multiple @Inject constructors: "
+                        + injectConstructors);
+        }
+    }
+
+    /**
+     * Returns a {@link MembersInjectionBinding} for {@code key}. If none has been registered yet,
+     * registers one, along with all necessary members injection bindings for superclasses.
+     */
+    @CanIgnoreReturnValue
+    Optional<MembersInjectionBinding> getOrFindMembersInjectionBinding(Key key) {
+        checkNotNull(key);
+        // TODO(gak): is checking the kind enough?
+        checkArgument(key.isValidMembersInjectionKey());
+        MembersInjectionBinding binding = membersInjectionBindings.getBinding(key);
+        if (binding != null) {
+            return Optional.of(binding);
+        }
+        Optional<MembersInjectionBinding> newBinding =
+                tryRegisterMembersInjectedType(
+                        MoreTypes.asTypeElement(key.type()), Optional.of(key.type()), true);
+        return newBinding;
     }
-    Optional<MembersInjectionBinding> newBinding =
-        tryRegisterMembersInjectedType(
-            MoreTypes.asTypeElement(key.type()), Optional.of(key.type()), true);
-    return newBinding;
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
index f0c0e7f85..f6a7b8259 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
@@ -31,6 +31,7 @@
     private HashSet<TypeElement> components = new HashSet<>();
     private DecoratorGenerator decoratorGenerator;
     private AnnotationGenerator annotationGenerator;
+    private final ApplicationValidator applicationValidator;
 
     public InjectorProcessingStep(Types types, Messager messager,
                                   AppConfig.Provider appConfigProvider,
@@ -44,7 +45,8 @@ public InjectorProcessingStep(Types types, Messager messager,
                                   ProvisionBinding.Factory provisionBindingFactory,
                                   ApplicationGenerator applicationGenerator,
                                   StubGenerator stubGenerator,
-                                  AnnotationGenerator annotationGenerator) {
+                                  AnnotationGenerator annotationGenerator,
+                                  ApplicationValidator applicationValidator) {
         this.types = types;
         this.messager = messager;
         this.appConfigProvider = appConfigProvider;
@@ -60,6 +62,7 @@ public InjectorProcessingStep(Types types, Messager messager,
         this.stubGenerator = stubGenerator;
         this.decoratorGenerator = decoratorGenerator;
         this.annotationGenerator = annotationGenerator;
+        this.applicationValidator = applicationValidator;
     }
 
     @Override
@@ -93,6 +96,10 @@ public InjectorProcessingStep(Types types, Messager messager,
             for (TypeElement component : components) {
                 final ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(component);
                 final BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+                boolean hasErrors = applicationValidator.validate(bindingGraph);
+                if (hasErrors) {
+                    return ImmutableSet.of(component);
+                }
                 this.createAnnotations(bindingGraph);
                 final ImmutableSet<ComponentDescriptor> componentDescriptors = bindingGraph.componentDescriptors();
                 componentDescriptors
@@ -110,7 +117,6 @@ public InjectorProcessingStep(Types types, Messager messager,
             final ClassName decoratorClassName = ClassName.get(appConfig.getAppClass()).topLevelClassName().peerClass("GraphDecorator");
             final DI di = new DI(appConfig, components, injectorTypeList, decoratorClassName);
             this.decoratorGenerator.generate(di, messager);
-            this.applicationGenerator.generate(di, messager);
             this.dependencySpecGenerator.generate(di, messager);
             this.injectorGenerator.generate(di, messager);
             if (appConfig.debug() || appConfig.generateExtendedComponents()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index f26e3179d..4464c4a55 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -135,7 +135,7 @@ static Builder builder(TypeMirror type) {
     abstract Builder wrappedType(Equivalence.Wrapper<TypeMirror> wrappedType);
 
     Builder type(TypeMirror type) {
-      return wrappedType(MoreTypes.equivalence().wrap(checkNotNull(type)));
+      return wrappedType(Util.wrap(checkNotNull(type)));
     }
 
     abstract Builder wrappedQualifier(
@@ -144,7 +144,7 @@ abstract Builder wrappedQualifier(
     abstract Builder wrappedQualifier(Equivalence.Wrapper<AnnotationMirror> wrappedQualifier);
 
     Builder qualifier(AnnotationMirror qualifier) {
-      return wrappedQualifier(AnnotationMirrors.equivalence().wrap(checkNotNull(qualifier)));
+      return wrappedQualifier(Util.wrap(checkNotNull(qualifier)));
     }
 
     Builder qualifier(Optional<AnnotationMirror> qualifier) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapType.java b/compiler/src/main/java/dagger/internal/codegen/MapType.java
index 55c55eb1f..7a3b2da88 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapType.java
@@ -126,7 +126,7 @@ static boolean isMap(Key key) {
    */
   static MapType from(TypeMirror type) {
     checkArgument(isMap(type), "%s is not a Map", type);
-    return new AutoValue_MapType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
+    return new AutoValue_MapType(Util.wrap(MoreTypes.asDeclared(type)));
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
index 0c1fae7f6..3ada3e073 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
@@ -36,10 +36,10 @@ static MethodSignature fromExecutableType(String methodName, ExecutableType meth
     ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> parameters = ImmutableList.builder();
     ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> thrownTypes = ImmutableList.builder();
     for (TypeMirror parameter : methodType.getParameterTypes()) {
-      parameters.add(MoreTypes.equivalence().wrap(parameter));
+      parameters.add(Util.wrap(parameter));
     }
     for (TypeMirror thrownType : methodType.getThrownTypes()) {
-      thrownTypes.add(MoreTypes.equivalence().wrap(thrownType));
+      thrownTypes.add(Util.wrap(thrownType));
     }
     return new AutoValue_MethodSignature(
         methodName,
diff --git a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
index c9ab5cfcc..d4d53cc8a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
@@ -42,7 +42,7 @@ private MoreAnnotationMirrors() {}
    */
   static Optional<Equivalence.Wrapper<AnnotationMirror>> wrapOptionalInEquivalence(
       Optional<AnnotationMirror> optional) {
-    return optional.map(AnnotationMirrors.equivalence()::wrap);
+    return optional.map(Util::wrap);
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalType.java b/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
index f154ab2d1..810ff0191 100644
--- a/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
@@ -129,7 +129,7 @@ static boolean isOptional(Key key) {
    */
   static OptionalType from(TypeMirror type) {
     checkArgument(isOptional(type), "%s must be an Optional", type);
-    return new AutoValue_OptionalType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
+    return new AutoValue_OptionalType(Util.wrap(MoreTypes.asDeclared(type)));
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 6399866b9..6a8e9eed7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -165,7 +165,7 @@ ProductionBinding forProducesMethod(
       return ProductionBinding.builder()
           .contributionType(contributionType)
           .bindingElement(producesMethod)
-          .contributingModule(contributedBy)
+          .contributingModule(Optional.of(contributedBy))
           .key(key)
           .explicitDependencies(dependencies)
           .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(producesMethod)))
@@ -235,7 +235,7 @@ ProductionBinding delegate(
       return ProductionBinding.builder()
           .contributionType(delegateDeclaration.contributionType())
           .bindingElement(delegateDeclaration.bindingElement().get())
-          .contributingModule(delegateDeclaration.contributingModule().get())
+          .contributingModule(delegateDeclaration.contributingModule())
           .key(keyFactory.forDelegateBinding(delegateDeclaration, Producer.class))
           .explicitDependencies(delegateDeclaration.delegateRequest())
           .nullableType(delegateBinding.nullableType())
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index c982138c0..28b7453ec 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -16,42 +16,42 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.MapKeys.getMapKey;
-import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.ElementKind.FIELD;
-import static javax.lang.model.element.ElementKind.METHOD;
-
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Sets;
+import com.google.common.base.Supplier;
+import com.google.common.collect.*;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
-import java.util.Optional;
+import dagger.Binds;
+import dagger.BindsOptionalOf;
 import dagger.Replaceable;
+import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 
 import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
 import javax.inject.Provider;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
+import javax.lang.model.element.*;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.common.base.Preconditions.*;
+import static com.google.common.base.Suppliers.memoize;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
+import static dagger.internal.codegen.Util.toImmutableList;
+import static javax.lang.model.element.ElementKind.*;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -63,380 +63,459 @@
 @AutoValue
 abstract class ProvisionBinding extends ContributionBinding {
 
-  @Override
-  ImmutableSet<DependencyRequest> implicitDependencies() {
-    return membersInjectionRequest().isPresent()
-        ? ImmutableSet.of(membersInjectionRequest().get())
-        : ImmutableSet.of();
-  }
-
-  /** If this provision requires members injection, this will be the corresponding request. */
-  abstract Optional<DependencyRequest> membersInjectionRequest();
-
-  @Override
-  public BindingType bindingType() {
-    return BindingType.PROVISION;
-  }
-
-  @Override
-  public boolean shouldGenerateDelegate() {
-    return Util.bindingSupportsTestDelegate(this) && bindingKind() != Kind.SYNTHETIC_DELEGATE_BINDING;
-  }
-
-  @Override
-  abstract Optional<ProvisionBinding> unresolved();
-
-  @Override
-  abstract Optional<Scope> scope();
-
-  private static Builder builder() {
-    return new AutoValue_ProvisionBinding.Builder()
-        .genericParameter(false)
-        .ignoreStubGeneration(true)
-        .generateTestDelegate(false)
-        .explicitDependencies(ImmutableSet.<DependencyRequest>of());
-  }
-  
-  abstract Builder toBuilder();
-
-  @AutoValue.Builder
-  @CanIgnoreReturnValue
-  abstract static class Builder extends ContributionBinding.Builder<Builder> {
-
-    abstract Builder membersInjectionRequest(Optional<DependencyRequest> membersInjectionRequest);
-
-    abstract Builder unresolved(ProvisionBinding unresolved);
-
-    abstract Builder scope(Optional<Scope> scope);
-
-    @CheckReturnValue
-    abstract ProvisionBinding build();
-  }
-
-  static final class Factory {
-    private final Elements elements;
-    private final Types types;
-    private final Key.Factory keyFactory;
-    private final DependencyRequest.Factory dependencyRequestFactory;
-    private final AppConfig.Provider appConfigProvider;
-    Factory(Elements elements, Types types, Key.Factory keyFactory,
-        DependencyRequest.Factory dependencyRequestFactory,
-            AppConfig.Provider appConfigProvider) {
-      this.elements = elements;
-      this.types = types;
-      this.keyFactory = keyFactory;
-      this.dependencyRequestFactory = dependencyRequestFactory;
-      this.appConfigProvider = appConfigProvider;
+    @Override
+    ImmutableSet<DependencyRequest> implicitDependencies() {
+        return membersInjectionRequest().isPresent()
+                ? ImmutableSet.of(membersInjectionRequest().get())
+                : ImmutableSet.of();
     }
 
+    abstract ImmutableSet<DependencyRequest> stubDependencies();
+
     /**
-     * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this
-     * will return a resolved binding, with the key and type resolved to the given type (using
-     * {@link Types#asMemberOf(DeclaredType, Element)}).
+     * If this provision requires members injection, this will be the corresponding request.
      */
-    ProvisionBinding forInjectConstructor(
-        ExecutableElement constructorElement, Optional<TypeMirror> resolvedType) {
-      checkNotNull(constructorElement);
-      checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
-      checkArgument(isAnnotationPresent(constructorElement, Inject.class));
-      checkArgument(!getQualifier(constructorElement).isPresent());
-
-      ExecutableType cxtorType = MoreTypes.asExecutable(constructorElement.asType());
-      DeclaredType enclosingCxtorType =
-          MoreTypes.asDeclared(constructorElement.getEnclosingElement().asType());
-      // If the class this is constructing has some type arguments, resolve everything.
-      if (!enclosingCxtorType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
-        DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
-        // Validate that we're resolving from the correct type.
-        checkState(types.isSameType(types.erasure(resolved), types.erasure(enclosingCxtorType)),
-            "erased expected type: %s, erased actual type: %s",
-            types.erasure(resolved), types.erasure(enclosingCxtorType));
-        cxtorType = MoreTypes.asExecutable(types.asMemberOf(resolved, constructorElement));
-        enclosingCxtorType = resolved;
-      }
-
-      Key key = keyFactory.forInjectConstructorWithResolvedType(enclosingCxtorType);
-      checkArgument(!key.qualifier().isPresent());
-      ImmutableSet<DependencyRequest> dependencies =
-          dependencyRequestFactory.forRequiredResolvedVariables(
-              constructorElement.getParameters(), cxtorType.getParameterTypes());
-      Optional<DependencyRequest> membersInjectionRequest =
-          membersInjectionRequest(enclosingCxtorType);
-
-      final boolean ignoreStubGeneration = constructorElement.getAnnotation(Replaceable.class) == null;
-      ProvisionBinding.Builder builder =
-          ProvisionBinding.builder()
-              .contributionType(ContributionType.UNIQUE)
-              .bindingElement(constructorElement)
-              .ignoreStubGeneration(ignoreStubGeneration)
-              .generateTestDelegate(!ignoreStubGeneration && appConfigProvider.get().debug())
-              .key(key)
-              .explicitDependencies(dependencies)
-              .membersInjectionRequest(membersInjectionRequest)
-              .bindingKind(Kind.INJECTION)
-              .scope(Scope.uniqueScopeOf(constructorElement.getEnclosingElement()));
-
-      TypeElement bindingTypeElement =
-          MoreElements.asType(constructorElement.getEnclosingElement());
-      if (hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)) {
-        builder.unresolved(forInjectConstructor(constructorElement, Optional.empty()));
-      }
-      return builder.build();
-    }
+    abstract Optional<DependencyRequest> membersInjectionRequest();
 
-    private static final ImmutableSet<ElementKind> MEMBER_KINDS =
-        Sets.immutableEnumSet(METHOD, FIELD);
-
-    private Optional<DependencyRequest> membersInjectionRequest(DeclaredType type) {
-      TypeElement typeElement = MoreElements.asType(type.asElement());
-      if (!types.isSameType(elements.getTypeElement(Object.class.getCanonicalName()).asType(),
-          typeElement.getSuperclass())) {
-        return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
-      }
-      for (Element enclosedElement : typeElement.getEnclosedElements()) {
-        if (MEMBER_KINDS.contains(enclosedElement.getKind())
-            && (isAnnotationPresent(enclosedElement, Inject.class))) {
-          return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
-        }
-      }
-      return Optional.empty();
+    @Override
+    public BindingType bindingType() {
+        return BindingType.PROVISION;
     }
 
-    ProvisionBinding forProvidesMethod(
-        ExecutableElement providesMethod, TypeElement contributedBy) {
-      checkArgument(providesMethod.getKind().equals(METHOD));
-      final DeclaredType declaredType = (DeclaredType) contributedBy.asType();
-      boolean genericParameter = !declaredType.getTypeArguments().isEmpty();
-      ExecutableType resolvedMethod =
-          MoreTypes.asExecutable(
-              types.asMemberOf(MoreTypes.asDeclared(contributedBy.asType()), providesMethod));
-      Key key = keyFactory.forProvidesMethod(providesMethod, contributedBy);
-      ImmutableSet<DependencyRequest> dependencies =
-          dependencyRequestFactory.forRequiredResolvedVariables(
-              providesMethod.getParameters(),
-              resolvedMethod.getParameterTypes());
-      final boolean ignoreStubGeneration = genericParameter || providesMethod.getAnnotation(Replaceable.class) == null;
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.fromBindingMethod(providesMethod))
-          .bindingElement(providesMethod)
-          .ignoreStubGeneration(ignoreStubGeneration)
-          .generateTestDelegate(!ignoreStubGeneration && (appConfigProvider.get().debug()))
-          .contributingModule(contributedBy)
-          .key(key)
-          .genericParameter(genericParameter)
-          .explicitDependencies(dependencies)
-          .nullableType(ConfigurationAnnotations.getNullableType(providesMethod))
-          .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(providesMethod)))
-          .bindingKind(Kind.PROVISION)
-          .scope(Scope.uniqueScopeOf(providesMethod))
-          .build();
+    @Override
+    public boolean shouldGenerateDelegate() {
+        return Util.bindingSupportsTestDelegate(this); //&& bindingKind() != Kind.SYNTHETIC_DELEGATE_BINDING;
     }
 
-    /** A synthetic binding of {@code Map<K, V>} that depends on {@code Map<K, Provider<V>>}. */
-    ProvisionBinding syntheticMapOfValuesBinding(Key mapOfValuesKey) {
-      checkNotNull(mapOfValuesKey);
-      Optional<Key> mapOfProvidersKey = keyFactory.implicitMapProviderKeyFrom(mapOfValuesKey);
-      checkArgument(mapOfProvidersKey.isPresent(), "%s is not a key for Map<K, V>", mapOfValuesKey);
-      DependencyRequest requestForMapOfProviders =
-          dependencyRequestFactory.providerForImplicitMapBinding(mapOfProvidersKey.get());
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(mapOfValuesKey)
-          .explicitDependencies(requestForMapOfProviders)
-          .bindingKind(Kind.SYNTHETIC_MAP)
-          .build();
-    }
+    @Override
+    abstract Optional<ProvisionBinding> unresolved();
 
-    /**
-     * A synthetic binding that depends explicitly on a set of individual provision multibinding
-     * contribution methods.
-     *
-     * <p>Note that these could be set multibindings or map multibindings.
-     */
-    ProvisionBinding syntheticMultibinding(
-        Key key, Iterable<ContributionBinding> multibindingContributions) {
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(key)
-          .explicitDependencies(
-              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
-          .bindingKind(Kind.forMultibindingKey(key))
-          .build();
-    }
+    @Override
+    abstract Optional<Scope> scope();
 
-    ProvisionBinding forComponent(TypeElement componentDefinitionType) {
-      checkNotNull(componentDefinitionType);
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .bindingElement(componentDefinitionType)
-          .key(keyFactory.forComponent(componentDefinitionType.asType()))
-          .bindingKind(Kind.COMPONENT)
-          .build();
+    private static Builder builder() {
+        return new AutoValue_ProvisionBinding.Builder()
+                .genericParameter(false)
+                .ignoreStubGeneration(true)
+                .generateTestDelegate(false)
+                .explicitDependencies(ImmutableSet.<DependencyRequest>of())
+                .stubDependencies(ImmutableSet.of());
     }
 
-    ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
-      checkNotNull(componentMethod);
-      checkArgument(componentMethod.getKind().equals(METHOD));
-      checkArgument(componentMethod.getParameters().isEmpty());
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .bindingElement(componentMethod)
-          .key(keyFactory.forComponentMethod(componentMethod))
-          .nullableType(ConfigurationAnnotations.getNullableType(componentMethod))
-          .bindingKind(Kind.COMPONENT_PROVISION)
-          .scope(Scope.uniqueScopeOf(componentMethod))
-          .build();
+    ImmutableList<DependencyAssociation> stubDependencyAssocations() {
+        return this.stubDependencyAssociations.get();
     }
 
-    ProvisionBinding forBuilderBinding(BuilderRequirementMethod method) {
-      ExecutableElement builderMethod = method.method();
-
-      checkNotNull(builderMethod);
-      checkArgument(builderMethod.getKind().equals(METHOD));
-      checkArgument(builderMethod.getParameters().size() == 1);
-      VariableElement parameterElement = Iterables.getOnlyElement(builderMethod.getParameters());
-      final boolean ignoreStubGeneration = builderMethod.getAnnotation(Replaceable.class) == null;
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .bindingElement(builderMethod)
-          .ignoreStubGeneration(ignoreStubGeneration)
-          .generateTestDelegate(!ignoreStubGeneration && (appConfigProvider.get().debug()))
-          .key(method.requirement().key().get())
-          .nullableType(ConfigurationAnnotations.getNullableType(parameterElement))
-          .bindingKind(Kind.BUILDER_BINDING)
-          .build();
+    ImmutableList<FrameworkDependency> stubFrameworkDependencies() {
+        return frameworkDependencies.get();
     }
 
-    ProvisionBinding forSubcomponentBuilderMethod(
-            ExecutableElement subcomponentBuilderMethod, TypeElement contributedBy, TypeMirror application) {
-      checkNotNull(subcomponentBuilderMethod);
-      checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
-      checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
-      DeclaredType declaredContainer = asDeclared(contributedBy.asType());
-      final DependencyRequest request = dependencyRequestFactory.plantDependency(application);
-      final boolean ignoreStubGeneration = subcomponentBuilderMethod.getAnnotation(Replaceable.class) == null;
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .ignoreStubGeneration(ignoreStubGeneration)
-          .generateTestDelegate(!ignoreStubGeneration && (appConfigProvider.get().debug()))
-          .bindingElement(subcomponentBuilderMethod)
-          .key(keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer))
-          .bindingKind(Kind.SUBCOMPONENT_BUILDER)
-          .explicitDependencies(request)
-          .build();
+    private final Supplier<ImmutableList<FrameworkDependency>> frameworkDependencies =
+            memoize(
+                    () ->
+                            stubDependencyAssocations()
+                                    .stream()
+                                    .map(DependencyAssociation::frameworkDependency)
+                                    .collect(toImmutableList()));
+
+    abstract Builder toBuilder();
+
+    private final Supplier<ImmutableList<DependencyAssociation>> stubDependencyAssociations =
+            memoize(
+                    () -> {
+                        BindingTypeMapper bindingTypeMapper = BindingTypeMapper.forBindingType(bindingType());
+                        ImmutableList.Builder<DependencyAssociation> list = ImmutableList.builder();
+                        for (Collection<DependencyRequest> requests : groupStubDependenciesByUnresolvedKey()) {
+                            list.add(
+                                    DependencyAssociation.create(
+                                            FrameworkDependency.create(
+                                                    getOnlyElement(
+                                                            requests.stream()
+                                                                    .map(DependencyRequest::bindingKey)
+                                                                    .collect(Collectors.toSet())),
+                                                    bindingTypeMapper.getBindingType(requests)),
+                                            requests));
+                        }
+                        return list.build();
+                    });
+
+
+    private ImmutableList<Collection<DependencyRequest>> groupStubDependenciesByUnresolvedKey() {
+        ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
+                ImmutableSetMultimap.builder();
+        Iterator<DependencyRequest> dependencies = stubDependencies().iterator();
+        while (dependencies.hasNext()) {
+            final DependencyRequest next = dependencies.next();
+            dependenciesByKeyBuilder.put(next.bindingKey(), next);
+        }
+        return ImmutableList.copyOf(
+                dependenciesByKeyBuilder
+                        .orderValuesBy(SourceFiles.DEPENDENCY_ORDERING)
+                        .build()
+                        .asMap()
+                        .values());
     }
 
-    ProvisionBinding syntheticSubcomponentBuilder(
-            ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations, TypeMirror application) {
-      SubcomponentDeclaration subcomponentDeclaration = subcomponentDeclarations.iterator().next();
-      final DependencyRequest request = dependencyRequestFactory.plantDependency(application);
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(subcomponentDeclaration.key())
-          .bindingKind(Kind.SUBCOMPONENT_BUILDER)
-          .explicitDependencies(request)
-          .build();
-    }
+    @AutoValue.Builder
+    @CanIgnoreReturnValue
+    abstract static class Builder extends ContributionBinding.Builder<Builder> {
 
-    ProvisionBinding delegate(
-        DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
-      return delegateBuilder(delegateDeclaration).nullableType(delegate.nullableType()).build();
-    }
+        abstract Builder membersInjectionRequest(Optional<DependencyRequest> membersInjectionRequest);
 
-    /**
-     * A form of {@link #delegate(DelegateDeclaration, ProvisionBinding)} when the right-hand-side
-     * of a {@link dagger.Binds} method cannot be resolved.
-     */
-    ProvisionBinding missingDelegate(DelegateDeclaration delegateDeclaration) {
-      return delegateBuilder(delegateDeclaration).build();
-    }
+        abstract Builder unresolved(ProvisionBinding unresolved);
 
-    private ProvisionBinding.Builder delegateBuilder(DelegateDeclaration delegateDeclaration) {
-      boolean ignoreStubGeneration = true;
-      final Optional<ExecutableElement> element = delegateDeclaration.bindingElement();
-      if (element.isPresent()) {
-        ignoreStubGeneration = element.get().getAnnotation(Replaceable.class) == null;
-      }
-      return ProvisionBinding.builder()
-          .contributionType(delegateDeclaration.contributionType())
-          .bindingElement(delegateDeclaration.bindingElement().get())
-          .contributingModule(delegateDeclaration.contributingModule().get())
-          .key(keyFactory.forDelegateBinding(delegateDeclaration, Provider.class))
-          .explicitDependencies(delegateDeclaration.delegateRequest())
-          .ignoreStubGeneration(ignoreStubGeneration)
-          .generateTestDelegate(!ignoreStubGeneration && appConfigProvider.get().debug())
-          .wrappedMapKey(delegateDeclaration.wrappedMapKey())
-          .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
-          .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()));
-    }
+        abstract Builder stubDependencies(ImmutableSet<DependencyRequest> stubDependencies);
 
-    /**
-     * Returns a synthetic binding for a {@code @ForReleasableReferences(scope)
-     * ReleasableReferenceManager} that provides the component-instantiated object.
-     */
-    ProvisionBinding provideReleasableReferenceManager(Scope scope) {
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(keyFactory.forReleasableReferenceManager(scope))
-          .bindingKind(Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGER)
-          .build();
-    }
+        abstract Builder scope(Optional<Scope> scope);
 
-    /**
-     * Returns a synthetic binding for a {@code @ForReleasableReferences(scope)
-     * TypedReleasableReferenceManager<metadataType>} that provides the component-instantiated
-     * object.
-     */
-    ContributionBinding provideTypedReleasableReferenceManager(
-        Scope scope, DeclaredType metadataType) {
-      return provideReleasableReferenceManager(scope)
-          .toBuilder()
-          .key(keyFactory.forTypedReleasableReferenceManager(scope, metadataType))
-          .build();
+        @CheckReturnValue
+        abstract ProvisionBinding build();
     }
 
-    /** Returns a synthetic binding for {@code Set<ReleasableReferenceManager>}. */
-    ProvisionBinding provideSetOfReleasableReferenceManagers() {
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(keyFactory.forSetOfReleasableReferenceManagers())
-          .bindingKind(Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS)
-          .build();
-    }
+    static final class Factory {
+        private final Elements elements;
+        private final Types types;
+        private final Key.Factory keyFactory;
+        private final DependencyRequest.Factory dependencyRequestFactory;
+        private final AppConfig.Provider appConfigProvider;
+
+        Factory(Elements elements, Types types, Key.Factory keyFactory,
+                DependencyRequest.Factory dependencyRequestFactory,
+                AppConfig.Provider appConfigProvider) {
+            this.elements = elements;
+            this.types = types;
+            this.keyFactory = keyFactory;
+            this.dependencyRequestFactory = dependencyRequestFactory;
+            this.appConfigProvider = appConfigProvider;
+        }
 
-    /**
-     * Returns a synthetic binding for {@code Set<TypedReleasableReferenceManager<metadataType>}.
-     */
-    ContributionBinding provideSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
-      return provideSetOfReleasableReferenceManagers()
-          .toBuilder()
-          .key(keyFactory.forSetOfTypedReleasableReferenceManagers(metadataType))
-          .build();
-    }
+        /**
+         * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this
+         * will return a resolved binding, with the key and type resolved to the given type (using
+         * {@link Types#asMemberOf(DeclaredType, Element)}).
+         */
+        ProvisionBinding forInjectConstructor(
+                ExecutableElement constructorElement, Optional<TypeMirror> resolvedType) {
+            checkNotNull(constructorElement);
+            checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
+            checkArgument(isAnnotationPresent(constructorElement, Inject.class));
+            checkArgument(!getQualifier(constructorElement).isPresent());
+
+            ExecutableType cxtorType = MoreTypes.asExecutable(constructorElement.asType());
+            DeclaredType enclosingCxtorType =
+                    MoreTypes.asDeclared(constructorElement.getEnclosingElement().asType());
+            // If the class this is constructing has some type arguments, resolve everything.
+            if (!enclosingCxtorType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+                DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
+                // Validate that we're resolving from the correct type.
+                checkState(types.isSameType(types.erasure(resolved), types.erasure(enclosingCxtorType)),
+                        "erased expected type: %s, erased actual type: %s",
+                        types.erasure(resolved), types.erasure(enclosingCxtorType));
+                cxtorType = MoreTypes.asExecutable(types.asMemberOf(resolved, constructorElement));
+                enclosingCxtorType = resolved;
+            }
+
+            Key key = keyFactory.forInjectConstructorWithResolvedType(enclosingCxtorType);
+            checkArgument(!key.qualifier().isPresent());
+            ImmutableSet<DependencyRequest> dependencies =
+                    dependencyRequestFactory.forRequiredResolvedVariables(
+                            constructorElement.getParameters(), cxtorType.getParameterTypes());
+            Optional<DependencyRequest> membersInjectionRequest =
+                    membersInjectionRequest(enclosingCxtorType);
+
+            final boolean ignoreStubGeneration = constructorElement.getEnclosingElement().getAnnotation(Replaceable.class) == null;
+            Builder builder =
+                    ProvisionBinding.builder()
+                            .contributionType(ContributionType.UNIQUE)
+                            .bindingElement(constructorElement)
+                            .ignoreStubGeneration(ignoreStubGeneration)
+                            .generateTestDelegate(!ignoreStubGeneration && appConfigProvider.get().debug())
+                            .key(key)
+                            .explicitDependencies(dependencies)
+                            .membersInjectionRequest(membersInjectionRequest)
+                            .bindingKind(Kind.INJECTION)
+                            .scope(Scope.uniqueScopeOf(constructorElement.getEnclosingElement()));
+
+            TypeElement bindingTypeElement =
+                    MoreElements.asType(constructorElement.getEnclosingElement());
+            if (hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)) {
+                builder.unresolved(forInjectConstructor(constructorElement, Optional.empty()));
+            }
+            return builder.build();
+        }
 
-    /**
-     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
-     * component with no binding for the underlying key.
-     */
-    ProvisionBinding syntheticAbsentBinding(Key key) {
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(key)
-          .bindingKind(Kind.SYNTHETIC_OPTIONAL_BINDING)
-          .build();
-    }
+        private static final ImmutableSet<ElementKind> MEMBER_KINDS =
+                Sets.immutableEnumSet(METHOD, FIELD);
 
-    /**
-     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
-     * component with a binding for the underlying key.
-     */
-    ProvisionBinding syntheticPresentBinding(Key key) {
-      return syntheticAbsentBinding(key)
-          .toBuilder()
-          .explicitDependencies(
-              dependencyRequestFactory.forSyntheticPresentOptionalBinding(
-                  key, DependencyRequest.Kind.PROVIDER))
-          .build();
+        private Optional<DependencyRequest> membersInjectionRequest(DeclaredType type) {
+            return this.membersInjectionRequest(type, type);
+        }
+
+        private Optional<DependencyRequest> membersInjectionRequest(DeclaredType type, DeclaredType original) {
+            TypeElement typeElement = MoreElements.asType(type.asElement());
+            if (!types.isSameType(elements.getTypeElement(Object.class.getCanonicalName()).asType(),
+                    typeElement.getSuperclass()) && typeElement.getSuperclass().getKind() != TypeKind.NONE) {
+                Optional<DependencyRequest> result = this.membersInjectionRequest(MoreTypes.asDeclared(typeElement.getSuperclass()), original);
+                if (result.isPresent()) {
+                    return result;
+                }
+            }
+            for (Element enclosedElement : typeElement.getEnclosedElements()) {
+                if (MEMBER_KINDS.contains(enclosedElement.getKind())
+                        && (isAnnotationPresent(enclosedElement, Inject.class))) {
+                    return Optional.of(dependencyRequestFactory.forMembersInjectedType(original));
+                }
+            }
+            return Optional.empty();
+        }
+
+        ProvisionBinding forProvidesMethod(
+                ExecutableElement providesMethod, TypeElement contributedBy) {
+            checkArgument(providesMethod.getKind().equals(METHOD));
+            final DeclaredType declaredType = (DeclaredType) contributedBy.asType();
+            boolean genericParameter = !declaredType.getTypeArguments().isEmpty();
+            ExecutableType resolvedMethod =
+                    MoreTypes.asExecutable(
+                            types.asMemberOf(MoreTypes.asDeclared(contributedBy.asType()), providesMethod));
+            Key key = keyFactory.forProvidesMethod(providesMethod, contributedBy);
+            ImmutableSet<DependencyRequest> dependencies =
+                    dependencyRequestFactory.forRequiredResolvedVariables(
+                            providesMethod.getParameters(),
+                            resolvedMethod.getParameterTypes());
+            final boolean ignoreStubGeneration = genericParameter || providesMethod.getAnnotation(Replaceable.class) == null;
+            return ProvisionBinding.builder()
+                    .contributionType(ContributionType.fromBindingMethod(providesMethod))
+                    .bindingElement(providesMethod)
+                    .ignoreStubGeneration(ignoreStubGeneration)
+                    .generateTestDelegate(!ignoreStubGeneration && (appConfigProvider.get().debug()))
+                    .contributingModule(Optional.of(contributedBy))
+                    .key(key)
+                    .genericParameter(genericParameter)
+                    .explicitDependencies(dependencies)
+                    .nullableType(ConfigurationAnnotations.getNullableType(providesMethod))
+                    .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(providesMethod)))
+                    .bindingKind(Kind.PROVISION)
+                    .scope(Scope.uniqueScopeOf(providesMethod))
+                    .build();
+        }
+
+        /**
+         * A synthetic binding of {@code Map<K, V>} that depends on {@code Map<K, Provider<V>>}.
+         */
+        ProvisionBinding syntheticMapOfValuesBinding(Key mapOfValuesKey) {
+            checkNotNull(mapOfValuesKey);
+            Optional<Key> mapOfProvidersKey = keyFactory.implicitMapProviderKeyFrom(mapOfValuesKey);
+            checkArgument(mapOfProvidersKey.isPresent(), "%s is not a key for Map<K, V>", mapOfValuesKey);
+            DependencyRequest requestForMapOfProviders =
+                    dependencyRequestFactory.providerForImplicitMapBinding(mapOfProvidersKey.get());
+            return ProvisionBinding.builder()
+                    .contributionType(ContributionType.UNIQUE)
+                    .key(mapOfValuesKey)
+                    .explicitDependencies(requestForMapOfProviders)
+                    .bindingKind(Kind.SYNTHETIC_MAP)
+                    .build();
+        }
+
+        /**
+         * A synthetic binding that depends explicitly on a set of individual provision multibinding
+         * contribution methods.
+         * <p>
+         * <p>Note that these could be set multibindings or map multibindings.
+         */
+        ProvisionBinding syntheticMultibinding(
+                Key key, Iterable<ContributionBinding> multibindingContributions) {
+            return ProvisionBinding.builder()
+                    .contributionType(ContributionType.UNIQUE)
+                    .key(key)
+                    .explicitDependencies(
+                            dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
+                    .bindingKind(Kind.forMultibindingKey(key))
+                    .build();
+        }
+
+        ProvisionBinding forComponent(TypeElement componentDefinitionType) {
+            checkNotNull(componentDefinitionType);
+            return ProvisionBinding.builder()
+                    .contributionType(ContributionType.UNIQUE)
+                    .bindingElement(componentDefinitionType)
+                    .key(keyFactory.forComponent(componentDefinitionType.asType()))
+                    .bindingKind(Kind.COMPONENT)
+                    .build();
+        }
+
+        ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
+            checkNotNull(componentMethod);
+            checkArgument(componentMethod.getKind().equals(METHOD));
+            checkArgument(componentMethod.getParameters().isEmpty());
+            return ProvisionBinding.builder()
+                    .contributionType(ContributionType.UNIQUE)
+                    .bindingElement(componentMethod)
+                    .key(keyFactory.forComponentMethod(componentMethod))
+                    .nullableType(ConfigurationAnnotations.getNullableType(componentMethod))
+                    .bindingKind(Kind.COMPONENT_PROVISION)
+                    .scope(Scope.uniqueScopeOf(componentMethod))
+                    .build();
+        }
+
+        ProvisionBinding forBuilderBinding(BuilderRequirementMethod method) {
+            ExecutableElement builderMethod = method.method();
+
+            checkNotNull(builderMethod);
+            checkArgument(builderMethod.getKind().equals(METHOD));
+            checkArgument(builderMethod.getParameters().size() == 1);
+            VariableElement parameterElement = Iterables.getOnlyElement(builderMethod.getParameters());
+            final boolean ignoreStubGeneration = builderMethod.getAnnotation(Replaceable.class) == null;
+            return ProvisionBinding.builder()
+                    .contributionType(ContributionType.UNIQUE)
+                    .bindingElement(builderMethod)
+                    .ignoreStubGeneration(ignoreStubGeneration)
+                    .generateTestDelegate(!ignoreStubGeneration && (appConfigProvider.get().debug()))
+                    .key(method.requirement().key().get())
+                    .nullableType(ConfigurationAnnotations.getNullableType(parameterElement))
+                    .bindingKind(Kind.BUILDER_BINDING)
+                    .build();
+        }
+
+        ProvisionBinding forSubcomponentBuilderMethod(
+                ExecutableElement subcomponentBuilderMethod, TypeElement contributedBy, TypeMirror application) {
+            checkNotNull(subcomponentBuilderMethod);
+            checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
+            checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
+            DeclaredType declaredContainer = asDeclared(contributedBy.asType());
+            final DependencyRequest request = dependencyRequestFactory.plantDependency(application);
+            final boolean ignoreStubGeneration = subcomponentBuilderMethod.getAnnotation(Replaceable.class) == null;
+            return ProvisionBinding.builder()
+                    .contributionType(ContributionType.UNIQUE)
+                    .ignoreStubGeneration(ignoreStubGeneration)
+                    .generateTestDelegate(!ignoreStubGeneration && (appConfigProvider.get().debug()))
+                    .bindingElement(subcomponentBuilderMethod)
+                    .key(keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer))
+                    .bindingKind(Kind.SUBCOMPONENT_BUILDER)
+                    .explicitDependencies(request)
+                    .build();
+        }
+
+        ProvisionBinding syntheticSubcomponentBuilder(
+                ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations, TypeMirror application) {
+            SubcomponentDeclaration subcomponentDeclaration = subcomponentDeclarations.iterator().next();
+            final DependencyRequest request = dependencyRequestFactory.plantDependency(application);
+            return ProvisionBinding.builder()
+                    .contributionType(ContributionType.UNIQUE)
+                    .key(subcomponentDeclaration.key())
+                    .bindingKind(Kind.SUBCOMPONENT_BUILDER)
+                    .explicitDependencies(request)
+                    .build();
+        }
+
+        ProvisionBinding delegate(
+                DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
+            return delegateBuilder(delegateDeclaration, Optional.of(delegate)).nullableType(delegate.nullableType()).build();
+        }
+
+        /**
+         * A form of {@link #delegate(DelegateDeclaration, ProvisionBinding)} when the right-hand-side
+         * of a {@link Binds} method cannot be resolved.
+         */
+        ProvisionBinding missingDelegate(DelegateDeclaration delegateDeclaration) {
+            return delegateBuilder(delegateDeclaration, Optional.empty()).build();
+        }
+
+        private Builder delegateBuilder(
+                DelegateDeclaration delegateDeclaration,
+                Optional<ProvisionBinding> delegate) {
+            boolean ignoreStubGeneration = true;
+            final Optional<Element> element = delegateDeclaration.bindingElement();
+            if (element.isPresent()) {
+                ignoreStubGeneration = element.get().getAnnotation(Replaceable.class) == null;
+            }else {
+                final Optional<Element> requestElement = delegateDeclaration.delegateRequest().requestElement();
+                if(requestElement.isPresent()) {
+                    ignoreStubGeneration = requestElement.get().getAnnotation(Replaceable.class) == null;
+                }
+            }
+            return ProvisionBinding.builder()
+                    .contributionType(delegateDeclaration.contributionType())
+                    .bindingElement(delegateDeclaration.bindingElement().get())
+                    .contributingModule(delegateDeclaration.contributingModule())
+                    .key(keyFactory.forDelegateBinding(delegateDeclaration, Provider.class))
+                    .explicitDependencies(delegateDeclaration.delegateRequest())
+                    .ignoreStubGeneration(ignoreStubGeneration)
+                    .stubDependencies(delegate.isPresent() ? delegate.get().explicitDependencies() : ImmutableSet.of())
+                    .generateTestDelegate(!ignoreStubGeneration && appConfigProvider.get().debug())
+                    .wrappedMapKey(delegateDeclaration.wrappedMapKey())
+                    .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
+                    .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()));
+        }
+
+        /**
+         * Returns a synthetic binding for a {@code @ForReleasableReferences(scope)
+         * ReleasableReferenceManager} that provides the component-instantiated object.
+         */
+        ProvisionBinding provideReleasableReferenceManager(Scope scope) {
+            return ProvisionBinding.builder()
+                    .contributionType(ContributionType.UNIQUE)
+                    .key(keyFactory.forReleasableReferenceManager(scope))
+                    .bindingKind(Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGER)
+                    .build();
+        }
+
+        /**
+         * Returns a synthetic binding for a {@code @ForReleasableReferences(scope)
+         * TypedReleasableReferenceManager<metadataType>} that provides the component-instantiated
+         * object.
+         */
+        ContributionBinding provideTypedReleasableReferenceManager(
+                Scope scope, DeclaredType metadataType) {
+            return provideReleasableReferenceManager(scope)
+                    .toBuilder()
+                    .key(keyFactory.forTypedReleasableReferenceManager(scope, metadataType))
+                    .build();
+        }
+
+        /**
+         * Returns a synthetic binding for {@code Set<ReleasableReferenceManager>}.
+         */
+        ProvisionBinding provideSetOfReleasableReferenceManagers() {
+            return ProvisionBinding.builder()
+                    .contributionType(ContributionType.UNIQUE)
+                    .key(keyFactory.forSetOfReleasableReferenceManagers())
+                    .bindingKind(Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS)
+                    .build();
+        }
+
+        /**
+         * Returns a synthetic binding for {@code Set<TypedReleasableReferenceManager<metadataType>}.
+         */
+        ContributionBinding provideSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
+            return provideSetOfReleasableReferenceManagers()
+                    .toBuilder()
+                    .key(keyFactory.forSetOfTypedReleasableReferenceManagers(metadataType))
+                    .build();
+        }
+
+        /**
+         * Returns a synthetic binding for an {@linkplain BindsOptionalOf optional binding} in a
+         * component with no binding for the underlying key.
+         */
+        ProvisionBinding syntheticAbsentBinding(Key key) {
+            return ProvisionBinding.builder()
+                    .contributionType(ContributionType.UNIQUE)
+                    .key(key)
+                    .bindingKind(Kind.SYNTHETIC_OPTIONAL_BINDING)
+                    .build();
+        }
+
+        /**
+         * Returns a synthetic binding for an {@linkplain BindsOptionalOf optional binding} in a
+         * component with a binding for the underlying key.
+         */
+        ProvisionBinding syntheticPresentBinding(Key key) {
+            return syntheticAbsentBinding(key)
+                    .toBuilder()
+                    .explicitDependencies(
+                            dependencyRequestFactory.forSyntheticPresentOptionalBinding(
+                                    key, DependencyRequest.Kind.PROVIDER))
+                    .build();
+        }
     }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index 74021aede..356b6f957 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -54,7 +54,7 @@
    */
   static Scope scope(AnnotationMirror scopeAnnotation) {
     checkArgument(isScope(scopeAnnotation));
-    return new AutoValue_Scope(AnnotationMirrors.equivalence().wrap(scopeAnnotation));
+    return new AutoValue_Scope(Util.wrap(scopeAnnotation));
   }
 
   /** Returns {@code true} if {@code scopeAnnotation} is a {@link javax.inject.Scope} annotation. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/SetType.java b/compiler/src/main/java/dagger/internal/codegen/SetType.java
index 180fc66fb..115c66c23 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SetType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SetType.java
@@ -105,7 +105,7 @@ static boolean isSet(Key key) {
    */
   static SetType from(TypeMirror type) {
     checkArgument(isSet(type), "%s must be a Set", type);
-    return new AutoValue_SetType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
+    return new AutoValue_SetType(Util.wrap(MoreTypes.asDeclared(type)));
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index ed9be4aff..4bab8f38f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -102,6 +102,23 @@
     return bindingFields.build();
   }
 
+  static ImmutableMap<BindingKey, FrameworkField> generateBindingFieldsForStubDependencies(
+          ProvisionBinding binding) {
+    checkArgument(!binding.unresolved().isPresent(), "binding must be unresolved: %s", binding);
+
+    ImmutableMap.Builder<BindingKey, FrameworkField> bindingFields = ImmutableMap.builder();
+    for (Binding.DependencyAssociation dependencyAssociation : binding.stubDependencyAssocations()) {
+      FrameworkDependency frameworkDependency = dependencyAssociation.frameworkDependency();
+      bindingFields.put(
+              frameworkDependency.bindingKey(),
+              FrameworkField.create(
+                      ClassName.get(frameworkDependency.frameworkClass()),
+                      TypeName.get(frameworkDependency.bindingKey().key().type()),
+                      fieldNameForDependency(dependencyAssociation.dependencyRequests())));
+    }
+    return bindingFields.build();
+  }
+
   private static String fieldNameForDependency(ImmutableSet<DependencyRequest> dependencyRequests) {
     // collect together all of the names that we would want to call the provider
     ImmutableSet<String> dependencyNames =
diff --git a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
index 5fdea873f..4d119b824 100644
--- a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
@@ -2,6 +2,9 @@
 
 import java.io.IOException;
 import java.util.Optional;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.*;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
@@ -10,6 +13,7 @@
 import javax.lang.model.util.Types;
 import java.util.*;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
+import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForStubDependencies;
 import static dagger.internal.codegen.TypeNames.*;
 
 
@@ -47,7 +51,12 @@ ClassName nameGeneratedType(ProvisionBinding input) {
         final TypeName contributedTypeName = ClassName.get(input.contributedType());
         methodBuilder.returns(contributedTypeName);
         HashMap<BindingKey, FrameworkField> fields = new HashMap<>();
-        for (Map.Entry<BindingKey, FrameworkField> entry : generateBindingFieldsForDependencies(input).entrySet()) {
+
+        final ImmutableMap<BindingKey, FrameworkField> map =
+                input.bindingKind() == ContributionBinding.Kind.SYNTHETIC_DELEGATE_BINDING ?
+                generateBindingFieldsForStubDependencies(input) :
+                generateBindingFieldsForDependencies(input);
+        for (Map.Entry<BindingKey, FrameworkField> entry : map.entrySet()) {
             FrameworkField bindingField = entry.getValue();
             fields.put(entry.getKey(), bindingField);
         }
@@ -61,7 +70,11 @@ ClassName nameGeneratedType(ProvisionBinding input) {
 
     protected List<ParameterSpec> buildMethodParamsList(ProvisionBinding input, HashMap<BindingKey, FrameworkField> fields) {
         List<ParameterSpec> parameterSpecList = new ArrayList<>();
-        for (DependencyRequest request : input.explicitDependencies()) {
+        final ImmutableSet<DependencyRequest> dependencyRequests =
+                input.bindingKind() == ContributionBinding.Kind.SYNTHETIC_DELEGATE_BINDING ?
+                        input.stubDependencies() :
+                        input.explicitDependencies();
+        for (DependencyRequest request : dependencyRequests) {
             final FrameworkField frameworkField = fields.get(request.bindingKey());
             TypeName typeName = request.kind() == DependencyRequest.Kind.INSTANCE ?
                     frameworkField.type().typeArguments.get(0) :
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 318a523ca..bbae977b4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -21,15 +21,17 @@
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.collect.Lists.asList;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static java.util.stream.Collectors.collectingAndThen;
 import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import java.util.Optional;
@@ -37,10 +39,6 @@
 import com.google.common.collect.*;
 import com.squareup.javapoet.*;
 import dagger.*;
-import dagger.multibindings.ClassKey;
-import dagger.multibindings.IntKey;
-import dagger.multibindings.LongKey;
-import dagger.multibindings.StringKey;
 import dagger.producers.Produces;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Predicate;
@@ -54,14 +52,10 @@
 import javax.lang.model.util.Elements;
 import java.lang.annotation.Annotation;
 import java.util.Comparator;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.stream.Collector;
-import javax.inject.Named;
 import javax.lang.model.element.*;
 import javax.lang.model.type.*;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
@@ -637,6 +631,64 @@ public static String lowerCaseFirstLetter(String original) {
         return original.substring(0, 1).toLowerCase() + original.substring(1);
     }
 
+    static class TypeMirrorEquivalence<T> extends com.google.common.base.Equivalence<T> {
+
+        private final Types types;
+
+        public TypeMirrorEquivalence(Types types) {
+            this.types = types;
+        }
+
+        @Override
+        protected boolean doEquivalent(T t1, T t2) {
+            return types.isSameType((TypeMirror)t1, (TypeMirror)t2) || t1.toString().equals(t2.toString());
+        }
+
+        @Override
+        protected int doHash(T typeMirror) {
+            return typeMirror.toString().hashCode();
+        }
+
+    }
+
+    static class AnnotationEquivalence extends com.google.common.base.Equivalence<Object> {
+
+        public AnnotationEquivalence() {}
+
+        @Override
+        protected boolean doEquivalent(Object t1, Object t2) {
+            return t1.toString().equals(t2.toString());
+        }
+
+        @Override
+        protected int doHash(Object t) {
+            return t.toString().hashCode();
+        }
+
+    }
+
+    private static TypeMirrorEquivalence<TypeMirror> equivalenceInstanceMirror;
+    private static TypeMirrorEquivalence<DeclaredType> equivalenceInstanceDeclared;
+    private static AnnotationEquivalence equivalenceInstanceAnnotation;
+
+    public static void initEquivalenceWrapper(Types types) {
+        equivalenceInstanceMirror = new TypeMirrorEquivalence<>(types);
+        equivalenceInstanceDeclared = new TypeMirrorEquivalence<>(types);
+        equivalenceInstanceAnnotation = new AnnotationEquivalence();
+    }
+
+    public static Equivalence.Wrapper<TypeMirror> wrap(TypeMirror type) {
+        return equivalenceInstanceMirror.wrap(type);
+    }
+
+    public static Equivalence.Wrapper<AnnotationMirror> wrap(AnnotationMirror type) {
+        return equivalenceInstanceAnnotation.wrap(type);
+    }
+
+    public static Equivalence.Wrapper<DeclaredType> wrap(DeclaredType type) {
+        return equivalenceInstanceDeclared.wrap(type);
+    }
+
     public static boolean bindingCanBeProvidedInTest(ContributionBinding binding) {
         final ImmutableList<ContributionBinding.Kind> kinds = ImmutableList.of(
                 ContributionBinding.Kind.PROVISION,
@@ -824,6 +876,15 @@ public static String getDelegateMethodName(ClassName delegateType) {
         return "with" + delegateType.simpleName().replaceAll("Delegate$", "");
     }
 
+    public static String joinClassNames(TypeMirror typeMirror) {
+        final ClassName className = ClassName.bestGuess(typeMirror.toString());
+        return joinClassNames(className);
+    }
+
+    public static String joinClassNames(ClassName className) {
+        return Joiner.on(".").join(className.simpleNames());
+    }
+
     public static ClassName getDaggerComponentClassName(ClassName componentDefinitionClassName) {
        String componentName =
                 "Dagger" + Joiner.on('_').join(componentDefinitionClassName.simpleNames());
diff --git a/core/src/main/java/dagger/Binds.java b/core/src/main/java/dagger/Binds.java
index 848619fb7..cdd0fa8e2 100644
--- a/core/src/main/java/dagger/Binds.java
+++ b/core/src/main/java/dagger/Binds.java
@@ -17,6 +17,7 @@
 package dagger;
 
 import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import java.lang.annotation.Documented;
@@ -63,5 +64,7 @@
  */
 @Documented
 @Retention(RUNTIME)
-@Target(METHOD)
-public @interface Binds {}
+@Target({METHOD, TYPE})
+public @interface Binds {
+    Class<?> to() default Object.class;
+}
diff --git a/core/src/main/java/dagger/Replaceable.java b/core/src/main/java/dagger/Replaceable.java
index 3494d6b65..14751ab45 100644
--- a/core/src/main/java/dagger/Replaceable.java
+++ b/core/src/main/java/dagger/Replaceable.java
@@ -10,7 +10,7 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 @Retention(RUNTIME)
-@Target({METHOD, CONSTRUCTOR})
+@Target({METHOD, TYPE})
 @Documented
 public @interface Replaceable {
 }
