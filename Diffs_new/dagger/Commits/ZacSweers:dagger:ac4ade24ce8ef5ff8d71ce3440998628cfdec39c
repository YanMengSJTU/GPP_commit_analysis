diff --git a/BUILD b/BUILD
index b55d28e34..4e8b7c4ac 100644
--- a/BUILD
+++ b/BUILD
@@ -56,17 +56,17 @@ SHADE_RULES = ["rule com.google.auto.common.** dagger.shaded.auto.common.@1"]
 jarjar_library(
     name = "shaded_compiler",
     jars = [
-        "//java/dagger/internal/codegen:binding",
         "//java/dagger/internal/codegen:binding_graph_validation",
         "//java/dagger/internal/codegen:processor",
         "//java/dagger/internal/codegen:validation",
         "//java/dagger/internal/codegen:writing",
         "//java/dagger/internal/codegen/base",
+        "//java/dagger/internal/codegen/binding",
         "//java/dagger/internal/codegen/compileroption",
+        "//java/dagger/internal/codegen/extension",
         "//java/dagger/internal/codegen/javapoet",
         "//java/dagger/internal/codegen/langmodel",
         "//java/dagger/internal/codegen/statistics",
-        "//java/dagger/internal/codegen/extension",
         "//java/dagger/model:internal-proxies",
         "//java/dagger/errorprone",
         "@com_google_auto_auto_common//jar",
@@ -77,17 +77,17 @@ jarjar_library(
 jarjar_library(
     name = "shaded_compiler_src",
     jars = [
-        "//java/dagger/internal/codegen:libbinding-src.jar",
         "//java/dagger/internal/codegen:libbinding_graph_validation-src.jar",
         "//java/dagger/internal/codegen:libprocessor-src.jar",
         "//java/dagger/internal/codegen:libvalidation-src.jar",
         "//java/dagger/internal/codegen:libwriting-src.jar",
         "//java/dagger/internal/codegen/base:libbase-src.jar",
+        "//java/dagger/internal/codegen/binding:libbinding-src.jar",
         "//java/dagger/internal/codegen/compileroption:libcompileroption-src.jar",
+        "//java/dagger/internal/codegen/extension:libextension-src.jar",
         "//java/dagger/internal/codegen/javapoet:libjavapoet-src.jar",
         "//java/dagger/internal/codegen/langmodel:liblangmodel-src.jar",
         "//java/dagger/internal/codegen/statistics:libstatistics-src.jar",
-        "//java/dagger/internal/codegen/extension:libextension-src.jar",
         # TODO(ronshapiro): is there a generated src.jar for protos in Bazel?
         "//java/dagger/errorprone:liberrorprone-src.jar",
     ],
diff --git a/java/dagger/internal/codegen/AnnotationCreatorGenerator.java b/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
index 079b59425..d16768693 100644
--- a/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
+++ b/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
@@ -19,8 +19,8 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AnnotationExpression.createMethodName;
-import static dagger.internal.codegen.AnnotationExpression.getAnnotationCreatorClassName;
+import static dagger.internal.codegen.binding.AnnotationExpression.createMethodName;
+import static dagger.internal.codegen.binding.AnnotationExpression.getAnnotationCreatorClassName;
 import static dagger.internal.codegen.javapoet.CodeBlocks.makeParametersCodeBlock;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
diff --git a/java/dagger/internal/codegen/AnonymousProviderCreationExpression.java b/java/dagger/internal/codegen/AnonymousProviderCreationExpression.java
index fc30eaa70..8b9ca7cc9 100644
--- a/java/dagger/internal/codegen/AnonymousProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/AnonymousProviderCreationExpression.java
@@ -16,13 +16,15 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.javapoet.CodeBlocks.anonymousProvider;
 import static dagger.model.RequestKind.INSTANCE;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.binding.BindingRequest;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.internal.codegen.javapoet.Expression;
 
 /**
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 1edfc4f10..768adab2b 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -59,7 +59,6 @@ CODEGEN_SHARED_DEPS = [
 
 CODEGEN_DEPS = CODEGEN_SHARED_DEPS + [
     ":package_info",
-    "//java/dagger/internal/codegen/extension",
     "@google_bazel_common//third_party/java/guava",
 ]
 
@@ -72,72 +71,6 @@ java_library(
     ],
 )
 
-# Classes that help to build a model of the binding graph
-java_library(
-    name = "binding",
-    srcs = [
-        "AnnotationExpression.java",
-        "Binding.java",
-        "BindingDeclaration.java",
-        "BindingDeclarationFormatter.java",
-        "BindingFactory.java",
-        "BindingGraph.java",
-        "BindingGraphConverter.java",
-        "BindingGraphFactory.java",
-        "BindingNode.java",
-        "BindingRequest.java",
-        "BindingType.java",
-        "BindsTypeChecker.java",
-        "ChildFactoryMethodEdgeImpl.java",
-        "ComponentCreatorAnnotation.java",
-        "ComponentCreatorDescriptor.java",
-        "ComponentCreatorKind.java",
-        "ComponentDescriptor.java",
-        "ComponentDescriptorFactory.java",
-        "ComponentKind.java",
-        "ComponentNodeImpl.java",
-        "ComponentRequirement.java",
-        "ComponentTreeTraverser.java",
-        "ConfigurationAnnotations.java",  # Uses ModuleDescriptors
-        "ContributionBinding.java",
-        "DelegateDeclaration.java",
-        "DependencyEdgeImpl.java",
-        "DependencyRequestFactory.java",
-        "DependencyRequestFormatter.java",
-        "DependencyVariableNamer.java",  # Used by SourceFiles
-        "ErrorMessages.java",  # Consider splitting this up as it pulls in too much
-        "FrameworkField.java",  # Used by SourceFiles
-        "FrameworkType.java",
-        "FrameworkTypeMapper.java",
-        "InjectBindingRegistry.java",
-        "InjectionSiteFactory.java",
-        "KeyFactory.java",
-        "KeyVariableNamer.java",  # needs ConfigurationAnnotations, SourceFiles
-        "MapKeys.java",
-        "MembersInjectionBinding.java",
-        "MethodSignature.java",
-        "MethodSignatureFormatter.java",
-        "ModuleDescriptor.java",
-        "ModuleKind.java",
-        "MultibindingDeclaration.java",
-        "OptionalBindingDeclaration.java",
-        "ProductionBinding.java",
-        "ProvisionBinding.java",
-        "ResolvedBindings.java",
-        "SourceFiles.java",  # Consider splitting this up?
-        "SubcomponentCreatorBindingEdgeImpl.java",
-        "SubcomponentDeclaration.java",
-    ],
-    plugins = CODEGEN_PLUGINS,
-    tags = ["maven:merged"],
-    deps = CODEGEN_DEPS + [
-        "//java/dagger/internal/codegen/base",
-        "//java/dagger/internal/codegen/compileroption",
-        "//java/dagger/internal/codegen/langmodel",
-        "//java/dagger/internal/codegen/javapoet",
-    ],
-)
-
 # Code related to validating the user-written Dagger code
 java_library(
     name = "validation",
@@ -177,9 +110,10 @@ java_library(
     plugins = CODEGEN_PLUGINS,
     tags = ["maven:merged"],
     deps = CODEGEN_DEPS + [
-        ":binding",
         "//java/dagger/internal/codegen/base",
+        "//java/dagger/internal/codegen/binding",
         "//java/dagger/internal/codegen/compileroption",
+        "//java/dagger/internal/codegen/extension",
         "//java/dagger/internal/codegen/javapoet",
         "//java/dagger/internal/codegen/langmodel",
     ],
@@ -202,10 +136,11 @@ java_library(
     plugins = CODEGEN_PLUGINS,
     tags = ["maven:merged"],
     deps = CODEGEN_DEPS + [
-        ":binding",
         ":validation",
         "//java/dagger/internal/codegen/base",
+        "//java/dagger/internal/codegen/binding",
         "//java/dagger/internal/codegen/compileroption",
+        "//java/dagger/internal/codegen/extension",
         "//java/dagger/internal/codegen/langmodel",
     ],
 )
@@ -282,9 +217,10 @@ java_library(
     plugins = CODEGEN_PLUGINS,
     tags = ["maven:merged"],
     deps = CODEGEN_DEPS + [
-        ":binding",
         "//java/dagger/internal/codegen/base",
+        "//java/dagger/internal/codegen/binding",
         "//java/dagger/internal/codegen/compileroption",
+        "//java/dagger/internal/codegen/extension",
         "//java/dagger/internal/codegen/javapoet",
         "//java/dagger/internal/codegen/langmodel",
         "//java/dagger/internal/codegen/statistics",
@@ -320,12 +256,13 @@ java_library(
     plugins = CODEGEN_PLUGINS,
     tags = ["maven_coordinates=com.google.dagger:dagger-compiler:" + POM_VERSION],
     deps = CODEGEN_DEPS + [
-        ":binding",
         ":binding_graph_validation",
         ":writing",
         ":validation",
         "//java/dagger/internal/codegen/base",
+        "//java/dagger/internal/codegen/binding",
         "//java/dagger/internal/codegen/compileroption",
+        "//java/dagger/internal/codegen/extension",
         "//java/dagger/internal/codegen/javapoet",
         "//java/dagger/internal/codegen/langmodel",
         "//java/dagger/internal/codegen/statistics",
@@ -339,12 +276,16 @@ pom_file(
     artifact_name = "Dagger Compiler",
     targets = [
         ":processor",
-        ":binding",
         ":binding_graph_validation",
         ":writing",
         ":validation",
         "//java/dagger/internal/codegen/base",
+        "//java/dagger/internal/codegen/binding",
+        "//java/dagger/internal/codegen/compileroption",
+        "//java/dagger/internal/codegen/extension",
         "//java/dagger/internal/codegen/javapoet",
+        "//java/dagger/internal/codegen/langmodel",
+        "//java/dagger/internal/codegen/statistics",
     ],
 )
 
@@ -356,7 +297,7 @@ java_library(
     deps = [
         ":javac",
         "//java/dagger:core",
-        "//java/dagger/internal/codegen/base",
+        "//java/dagger/internal/codegen/binding",
         "//java/dagger/internal/codegen/compileroption",
         "//java/dagger/internal/codegen/langmodel",
     ],
@@ -367,14 +308,13 @@ java_library(
     srcs = KYTHE_SRCS,
     plugins = [":component-codegen"],
     deps = [
-        ":binding",
         ":javac",
         ":javac-plugin-module",
         ":kythe_plugin",
         ":package_info",
         ":processor",
         "//java/dagger:core",
-        "//java/dagger/internal/codegen/base",
+        "//java/dagger/internal/codegen/binding",
         "//java/dagger/internal/codegen/langmodel",
         "//java/dagger/model",
         "//java/dagger/producers",
@@ -415,7 +355,9 @@ java_library(
     plugins = CODEGEN_PLUGINS,
     deps = CODEGEN_DEPS + [
         "//java/dagger/internal/codegen/base",
+        "//java/dagger/internal/codegen/binding",
         "//java/dagger/internal/codegen/compileroption",
+        "//java/dagger/internal/codegen/extension",
         "//java/dagger/internal/codegen/langmodel",
         "//java/dagger/internal/codegen/javapoet",
         "//java/dagger/internal/codegen/statistics",
@@ -442,13 +384,13 @@ java_library(
     srcs = STATISTICS_COLLECTOR_SRCS,
     plugins = [":component-codegen"],
     deps = [
-        ":binding",
         ":javac",
         ":javac-plugin-module",
         ":package_info",
         ":processor",
         "//java/dagger:core",
         "//java/dagger/internal/codegen/base",
+        "//java/dagger/internal/codegen/binding",
         "//java/dagger/model",
         "@google_bazel_common//third_party/java/error_prone:check_api",
     ],
diff --git a/java/dagger/internal/codegen/BindingElementValidator.java b/java/dagger/internal/codegen/BindingElementValidator.java
index 892f683e6..5e5a8c17c 100644
--- a/java/dagger/internal/codegen/BindingElementValidator.java
+++ b/java/dagger/internal/codegen/BindingElementValidator.java
@@ -17,10 +17,10 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Verify.verifyNotNull;
-import static dagger.internal.codegen.MapKeys.getMapKeys;
 import static dagger.internal.codegen.base.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.base.Scopes.scopesOf;
 import static dagger.internal.codegen.base.Util.reentrantComputeIfAbsent;
+import static dagger.internal.codegen.binding.MapKeys.getMapKeys;
 import static dagger.internal.codegen.langmodel.DaggerElements.getAnnotationMirror;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index aabd6c9e5..6d9621900 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -18,7 +18,7 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.javapoet.Expression;
 
 /** A factory of code expressions used to access a single request for a binding in a component. */
diff --git a/java/dagger/internal/codegen/BindingGraphStatisticsCollector.java b/java/dagger/internal/codegen/BindingGraphStatisticsCollector.java
index 751877c04..e17783489 100644
--- a/java/dagger/internal/codegen/BindingGraphStatisticsCollector.java
+++ b/java/dagger/internal/codegen/BindingGraphStatisticsCollector.java
@@ -28,6 +28,9 @@
 import com.sun.tools.javac.util.Context;
 import dagger.BindsInstance;
 import dagger.Component;
+import dagger.internal.codegen.binding.BindingGraphConverter;
+import dagger.internal.codegen.binding.BindingGraphFactory;
+import dagger.internal.codegen.binding.ComponentDescriptorFactory;
 import dagger.model.BindingGraph;
 import javax.inject.Inject;
 import javax.inject.Singleton;
diff --git a/java/dagger/internal/codegen/BindsMethodValidator.java b/java/dagger/internal/codegen/BindsMethodValidator.java
index 540ea70e9..410f28d8d 100644
--- a/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -27,6 +27,7 @@
 import dagger.Module;
 import dagger.internal.codegen.base.ContributionType;
 import dagger.internal.codegen.base.SetType;
+import dagger.internal.codegen.binding.BindsTypeChecker;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.producers.ProducerModule;
@@ -44,6 +45,7 @@
   BindsMethodValidator(
       DaggerElements elements,
       DaggerTypes types,
+      BindsTypeChecker bindsTypeChecker,
       DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
@@ -56,7 +58,7 @@
         ALLOWS_MULTIBINDINGS,
         ALLOWS_SCOPING);
     this.types = types;
-    this.bindsTypeChecker = new BindsTypeChecker(types, elements);
+    this.bindsTypeChecker = bindsTypeChecker;
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 8022f0248..8d9af2d78 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -19,9 +19,9 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Verify.verify;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.DelegateBindingExpression.isBindsScopeStrongerThanDependencyScope;
 import static dagger.internal.codegen.MemberSelect.staticFactoryCreation;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.javapoet.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.javapoet.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.javapoet.TypeNames.SINGLE_CHECK;
@@ -36,9 +36,20 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
 import dagger.internal.codegen.MethodBindingExpression.MethodImplementationStrategy;
+import dagger.internal.codegen.binding.Binding;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.BindingRequest;
+import dagger.internal.codegen.binding.BindingType;
+import dagger.internal.codegen.binding.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.ComponentRequirement;
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.FrameworkType;
+import dagger.internal.codegen.binding.FrameworkTypeMapper;
+import dagger.internal.codegen.binding.MembersInjectionBinding;
+import dagger.internal.codegen.binding.ProvisionBinding;
+import dagger.internal.codegen.binding.ResolvedBindings;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerElements;
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementation.java b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
index e355c100b..d604958b6 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementation.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
@@ -21,6 +21,7 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.TypeSpec;
+import dagger.internal.codegen.binding.ComponentRequirement;
 
 /** The implementation of a component creator type. */
 @AutoValue
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
index 868bc9a24..d8c4fd389 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
@@ -23,7 +23,7 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.binding.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.javapoet.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.javapoet.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -43,8 +43,12 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.Preconditions;
-import dagger.internal.codegen.ComponentRequirement.NullPolicy;
 import dagger.internal.codegen.base.UniqueNameSet;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.ComponentCreatorDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptor;
+import dagger.internal.codegen.binding.ComponentRequirement;
+import dagger.internal.codegen.binding.ComponentRequirement.NullPolicy;
 import dagger.internal.codegen.javapoet.TypeNames;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
diff --git a/java/dagger/internal/codegen/ComponentCreatorValidator.java b/java/dagger/internal/codegen/ComponentCreatorValidator.java
index c55dadd80..53528a42c 100644
--- a/java/dagger/internal/codegen/ComponentCreatorValidator.java
+++ b/java/dagger/internal/codegen/ComponentCreatorValidator.java
@@ -18,7 +18,7 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.getCreatorAnnotations;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.getCreatorAnnotations;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -29,7 +29,9 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ObjectArrays;
 import dagger.BindsInstance;
-import dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages;
+import dagger.internal.codegen.binding.ComponentCreatorAnnotation;
+import dagger.internal.codegen.binding.ErrorMessages;
+import dagger.internal.codegen.binding.ErrorMessages.ComponentCreatorMessages;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import java.util.List;
diff --git a/java/dagger/internal/codegen/ComponentDescriptorValidator.java b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
index adb95ccd5..dc1844542 100644
--- a/java/dagger/internal/codegen/ComponentDescriptorValidator.java
+++ b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
@@ -41,8 +41,15 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
-import dagger.internal.codegen.ComponentRequirement.NullPolicy;
-import dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages;
+import dagger.internal.codegen.binding.ComponentCreatorDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptor;
+import dagger.internal.codegen.binding.ComponentRequirement;
+import dagger.internal.codegen.binding.ComponentRequirement.NullPolicy;
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.ErrorMessages;
+import dagger.internal.codegen.binding.ErrorMessages.ComponentCreatorMessages;
+import dagger.internal.codegen.binding.MethodSignatureFormatter;
+import dagger.internal.codegen.binding.ModuleDescriptor;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.compileroption.ValidationType;
 import dagger.internal.codegen.langmodel.DaggerElements;
diff --git a/java/dagger/internal/codegen/ComponentGenerator.java b/java/dagger/internal/codegen/ComponentGenerator.java
index 2e009bc35..026b03401 100644
--- a/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/java/dagger/internal/codegen/ComponentGenerator.java
@@ -17,12 +17,13 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Verify.verify;
-import static dagger.internal.codegen.SourceFiles.classFileName;
+import static dagger.internal.codegen.binding.SourceFiles.classFileName;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.Component;
 import dagger.internal.codegen.base.SourceFileGenerator;
+import dagger.internal.codegen.binding.BindingGraph;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import java.util.Optional;
 import javax.annotation.processing.Filer;
diff --git a/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index 4ba407fbe..b44e33c03 100644
--- a/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -37,7 +37,10 @@
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.ModuleDescriptor;
+import dagger.internal.codegen.binding.ModuleKind;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.model.Scope;
 import java.util.Collection;
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index 2e676c6d2..73fd74857 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -21,9 +21,9 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
-import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
 import static dagger.internal.codegen.ComponentGenerator.componentName;
 import static dagger.internal.codegen.base.ComponentAnnotation.rootComponentAnnotations;
+import static dagger.internal.codegen.binding.ComponentCreatorKind.BUILDER;
 import static dagger.internal.codegen.javapoet.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -43,6 +43,13 @@
 import dagger.BindsInstance;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
 import dagger.internal.codegen.base.SourceFileGenerator;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.ComponentCreatorDescriptor;
+import dagger.internal.codegen.binding.ComponentCreatorKind;
+import dagger.internal.codegen.binding.ComponentDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptorFactory;
+import dagger.internal.codegen.binding.ComponentRequirement;
+import dagger.internal.codegen.binding.MethodSignature;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.producers.internal.CancellationListener;
diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index 222f14673..b8cdf2dca 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -23,7 +23,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
+import static dagger.internal.codegen.binding.ComponentCreatorKind.BUILDER;
 import static dagger.internal.codegen.langmodel.Accessibility.isTypeAccessibleFrom;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -41,6 +41,13 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.codegen.base.UniqueNameSet;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.BindingRequest;
+import dagger.internal.codegen.binding.ComponentCreatorDescriptor;
+import dagger.internal.codegen.binding.ComponentCreatorKind;
+import dagger.internal.codegen.binding.ComponentDescriptor;
+import dagger.internal.codegen.binding.ComponentRequirement;
+import dagger.internal.codegen.binding.KeyVariableNamer;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.javapoet.TypeSpecs;
 import dagger.model.Key;
diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index 4a762a3aa..8a7b60ab7 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -21,8 +21,6 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
-import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.BUILDER_METHOD;
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.CANCELLATION_LISTENER_METHOD;
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.COMPONENT_METHOD;
@@ -30,6 +28,8 @@
 import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.INITIALIZE_METHOD;
 import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.COMPONENT_CREATOR;
 import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.SUBCOMPONENT;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.binding.ComponentCreatorKind.BUILDER;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableList;
 import static dagger.internal.codegen.javapoet.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.javapoet.CodeBlocks.parameterNames;
@@ -53,7 +53,13 @@
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.Preconditions;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.ComponentCreatorDescriptor;
+import dagger.internal.codegen.binding.ComponentCreatorKind;
+import dagger.internal.codegen.binding.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.ComponentRequirement;
+import dagger.internal.codegen.binding.FrameworkType;
+import dagger.internal.codegen.binding.MethodSignature;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.javapoet.AnnotationSpecs;
 import dagger.internal.codegen.javapoet.CodeBlocks;
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
index a0367f1a2..742a044f9 100644
--- a/java/dagger/internal/codegen/ComponentImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -20,6 +20,8 @@
 import static dagger.internal.codegen.base.Util.reentrantComputeIfAbsent;
 
 import dagger.internal.codegen.base.ClearableCache;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.KeyFactory;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import java.util.HashMap;
 import java.util.Map;
diff --git a/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
index 9ec177af1..e77e6d089 100644
--- a/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
@@ -18,6 +18,7 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.internal.codegen.javapoet.Expression;
 
 /** A binding expression for the instance of the component itself, i.e. {@code this}. */
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index 3f9f1373f..9643329ba 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -20,7 +20,9 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.BindingRequest;
+import dagger.internal.codegen.binding.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import javax.lang.model.type.TypeMirror;
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index de06e32c9..342611a79 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -17,12 +17,12 @@
 package dagger.internal.codegen;
 
 import static com.google.common.collect.Sets.union;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.allCreatorAnnotations;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.rootComponentCreatorAnnotations;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.subcomponentCreatorAnnotations;
 import static dagger.internal.codegen.base.ComponentAnnotation.allComponentAnnotations;
 import static dagger.internal.codegen.base.ComponentAnnotation.rootComponentAnnotations;
 import static dagger.internal.codegen.base.ComponentAnnotation.subcomponentAnnotations;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.allCreatorAnnotations;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.rootComponentCreatorAnnotations;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.subcomponentCreatorAnnotations;
 import static dagger.internal.codegen.compileroption.ValidationType.NONE;
 import static java.util.Collections.disjoint;
 
@@ -36,6 +36,11 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
 import dagger.internal.codegen.base.SourceFileGenerator;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.BindingGraphConverter;
+import dagger.internal.codegen.binding.BindingGraphFactory;
+import dagger.internal.codegen.binding.ComponentDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptorFactory;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import java.lang.annotation.Annotation;
 import java.util.HashMap;
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index 6196b1ee9..ba8608cf1 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -35,6 +35,9 @@
 import dagger.internal.codegen.base.ClearableCache;
 import dagger.internal.codegen.base.SourceFileGenerationException;
 import dagger.internal.codegen.base.SourceFileGenerator;
+import dagger.internal.codegen.binding.InjectBindingRegistry;
+import dagger.internal.codegen.binding.MembersInjectionBinding;
+import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.compileroption.ProcessingEnvironmentCompilerOptions;
 import dagger.internal.codegen.statistics.DaggerStatisticsCollectingProcessingStep;
diff --git a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
index 8feb81305..7d6aa7ec8 100644
--- a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
@@ -21,6 +21,9 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.Preconditions;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.ComponentRequirement;
+import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.javapoet.Expression;
 
diff --git a/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java b/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
index 1a044f389..6d9b94568 100644
--- a/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
@@ -17,6 +17,8 @@
 package dagger.internal.codegen;
 
 import com.squareup.javapoet.ClassName;
+import dagger.internal.codegen.binding.ComponentRequirement;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.internal.codegen.javapoet.Expression;
 
 /**
diff --git a/java/dagger/internal/codegen/ComponentRequirementExpression.java b/java/dagger/internal/codegen/ComponentRequirementExpression.java
index b25c01b67..8c0ec6488 100644
--- a/java/dagger/internal/codegen/ComponentRequirementExpression.java
+++ b/java/dagger/internal/codegen/ComponentRequirementExpression.java
@@ -18,6 +18,7 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.binding.ComponentRequirement;
 
 /**
  * A factory for expressions of {@link ComponentRequirement}s in the generated component. This is
diff --git a/java/dagger/internal/codegen/ComponentRequirementExpressions.java b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
index b51baa55d..2562e949b 100644
--- a/java/dagger/internal/codegen/ComponentRequirementExpressions.java
+++ b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
@@ -29,6 +29,8 @@
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.TypeName;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.ComponentRequirement;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import java.util.HashMap;
 import java.util.Map;
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index cd0335ca5..f62d739ea 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -25,16 +25,16 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Multimaps.asMap;
 import static com.google.common.collect.Sets.intersection;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.creatorAnnotationsFor;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.productionCreatorAnnotations;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.subcomponentCreatorAnnotations;
-import static dagger.internal.codegen.ComponentKind.annotationsFor;
-import static dagger.internal.codegen.ConfigurationAnnotations.enclosedAnnotatedTypes;
-import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
-import static dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages.builderMethodRequiresNoArgs;
-import static dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages.moreThanOneRefToSubcomponent;
 import static dagger.internal.codegen.base.ComponentAnnotation.anyComponentAnnotation;
 import static dagger.internal.codegen.base.ModuleAnnotation.moduleAnnotation;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.creatorAnnotationsFor;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.productionCreatorAnnotations;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.subcomponentCreatorAnnotations;
+import static dagger.internal.codegen.binding.ComponentKind.annotationsFor;
+import static dagger.internal.codegen.binding.ConfigurationAnnotations.enclosedAnnotatedTypes;
+import static dagger.internal.codegen.binding.ConfigurationAnnotations.getTransitiveModules;
+import static dagger.internal.codegen.binding.ErrorMessages.ComponentCreatorMessages.builderMethodRequiresNoArgs;
+import static dagger.internal.codegen.binding.ErrorMessages.ComponentCreatorMessages.moreThanOneRefToSubcomponent;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableList;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.langmodel.DaggerElements.getAnnotationMirror;
@@ -58,6 +58,11 @@
 import dagger.Component;
 import dagger.Reusable;
 import dagger.internal.codegen.base.ComponentAnnotation;
+import dagger.internal.codegen.binding.ComponentKind;
+import dagger.internal.codegen.binding.DependencyRequestFactory;
+import dagger.internal.codegen.binding.ErrorMessages;
+import dagger.internal.codegen.binding.MethodSignatureFormatter;
+import dagger.internal.codegen.binding.ModuleKind;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.DependencyRequest;
diff --git a/java/dagger/internal/codegen/CurrentImplementationSubcomponent.java b/java/dagger/internal/codegen/CurrentImplementationSubcomponent.java
index 361e5a123..19d83b7ab 100644
--- a/java/dagger/internal/codegen/CurrentImplementationSubcomponent.java
+++ b/java/dagger/internal/codegen/CurrentImplementationSubcomponent.java
@@ -20,6 +20,7 @@
 import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentImplementationBuilder.RootComponentImplementationBuilder;
 import dagger.internal.codegen.ComponentImplementationBuilder.SubcomponentImplementationBuilder;
+import dagger.internal.codegen.binding.BindingGraph;
 import java.util.Optional;
 
 /**
diff --git a/java/dagger/internal/codegen/DaggerKythePlugin.java b/java/dagger/internal/codegen/DaggerKythePlugin.java
index 393773967..7e3df1552 100644
--- a/java/dagger/internal/codegen/DaggerKythePlugin.java
+++ b/java/dagger/internal/codegen/DaggerKythePlugin.java
@@ -19,7 +19,7 @@
 // the regular kythe/java tree.
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.langmodel.DaggerElements.isAnyAnnotationPresent;
 
 import com.google.auto.service.AutoService;
@@ -35,6 +35,15 @@
 import com.sun.tools.javac.util.Context;
 import dagger.BindsInstance;
 import dagger.Component;
+import dagger.internal.codegen.binding.Binding;
+import dagger.internal.codegen.binding.BindingDeclaration;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.BindingGraphFactory;
+import dagger.internal.codegen.binding.BindingRequest;
+import dagger.internal.codegen.binding.ComponentDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptorFactory;
+import dagger.internal.codegen.binding.ModuleDescriptor;
+import dagger.internal.codegen.binding.ResolvedBindings;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.producers.ProductionComponent;
diff --git a/java/dagger/internal/codegen/DelegateBindingExpression.java b/java/dagger/internal/codegen/DelegateBindingExpression.java
index bf48db3e6..5854fd4fd 100644
--- a/java/dagger/internal/codegen/DelegateBindingExpression.java
+++ b/java/dagger/internal/codegen/DelegateBindingExpression.java
@@ -19,12 +19,16 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.base.RequestKinds.requestType;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.langmodel.Accessibility.isTypeAccessibleFrom;
 import static dagger.model.BindingKind.DELEGATE;
 
 import com.squareup.javapoet.ClassName;
+import dagger.internal.codegen.binding.Binding;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.BindsTypeChecker;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
diff --git a/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java b/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
index 7524cdf06..40852693d 100644
--- a/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
+++ b/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
@@ -18,10 +18,11 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.internal.codegen.javapoet.CodeBlocks;
 import dagger.model.DependencyRequest;
 
diff --git a/java/dagger/internal/codegen/DependencyCycleValidator.java b/java/dagger/internal/codegen/DependencyCycleValidator.java
index 3d008caf5..2010a4169 100644
--- a/java/dagger/internal/codegen/DependencyCycleValidator.java
+++ b/java/dagger/internal/codegen/DependencyCycleValidator.java
@@ -39,6 +39,7 @@
 import com.google.common.graph.NetworkBuilder;
 import dagger.internal.codegen.base.MapType;
 import dagger.internal.codegen.base.OptionalType;
+import dagger.internal.codegen.binding.DependencyRequestFormatter;
 import dagger.model.BindingGraph;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
diff --git a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
index b42f9c424..e251c11db 100644
--- a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
@@ -30,6 +30,9 @@
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.TypeName;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.ComponentRequirement;
+import dagger.internal.codegen.binding.ContributionBinding;
 
 /**
  * A {@link dagger.producers.Producer} creation expression for a production method on a production
diff --git a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
index 7c8170898..8bc07b039 100644
--- a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
@@ -33,6 +33,10 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.ComponentRequirement;
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import javax.lang.model.element.Element;
 
diff --git a/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
index 3ff55e866..8ee814052 100644
--- a/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
+++ b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
@@ -19,6 +19,7 @@
 import static dagger.internal.codegen.extension.DaggerStreams.instancesOf;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
+import dagger.internal.codegen.binding.KeyFactory;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.model.BindingGraph;
 import dagger.model.BindingGraph.MaybeBinding;
diff --git a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
index b54579464..61d7b1d7b 100644
--- a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
@@ -17,10 +17,12 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.ClassName;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.BindingRequest;
+import dagger.internal.codegen.binding.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.FrameworkType;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.Key;
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index 4f57f61bd..fdc4039ba 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -51,6 +51,7 @@
 import com.google.errorprone.annotations.FormatMethod;
 import dagger.internal.codegen.base.ElementFormatter;
 import dagger.internal.codegen.base.Formatter;
+import dagger.internal.codegen.binding.DependencyRequestFormatter;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.compileroption.ValidationType;
 import dagger.internal.codegen.langmodel.DaggerTypes;
diff --git a/java/dagger/internal/codegen/DuplicateBindingsValidator.java b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
index 0f6d431ca..bc3a3227e 100644
--- a/java/dagger/internal/codegen/DuplicateBindingsValidator.java
+++ b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
@@ -38,6 +38,10 @@
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import dagger.internal.codegen.base.Formatter;
+import dagger.internal.codegen.binding.BindingDeclaration;
+import dagger.internal.codegen.binding.BindingDeclarationFormatter;
+import dagger.internal.codegen.binding.BindingNode;
+import dagger.internal.codegen.binding.MultibindingDeclaration;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.model.Binding;
 import dagger.model.BindingGraph;
diff --git a/java/dagger/internal/codegen/FactoryGenerator.java b/java/dagger/internal/codegen/FactoryGenerator.java
index 5f3b96925..433b0ec97 100644
--- a/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/java/dagger/internal/codegen/FactoryGenerator.java
@@ -21,15 +21,15 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
-import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
-import static dagger.internal.codegen.SourceFiles.frameworkFieldUsages;
-import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.binding.ContributionBinding.FactoryCreationStrategy.DELEGATE;
+import static dagger.internal.codegen.binding.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
+import static dagger.internal.codegen.binding.SourceFiles.bindingTypeElementTypeVariableNames;
+import static dagger.internal.codegen.binding.SourceFiles.frameworkFieldUsages;
+import static dagger.internal.codegen.binding.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.binding.SourceFiles.generateBindingFieldsForDependencies;
+import static dagger.internal.codegen.binding.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.binding.SourceFiles.parameterizedGeneratedTypeNameForBinding;
 import static dagger.internal.codegen.javapoet.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.javapoet.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.javapoet.AnnotationSpecs.suppressWarnings;
@@ -58,6 +58,7 @@
 import dagger.internal.codegen.InjectionMethods.ProvisionMethod;
 import dagger.internal.codegen.base.SourceFileGenerator;
 import dagger.internal.codegen.base.UniqueNameSet;
+import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.javapoet.CodeBlocks;
 import dagger.internal.codegen.langmodel.DaggerElements;
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index 7aa2ae953..f32a6b1b4 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -26,6 +26,9 @@
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.TypeName;
 import dagger.internal.DelegateFactory;
+import dagger.internal.codegen.binding.BindingType;
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.FrameworkField;
 import dagger.internal.codegen.javapoet.AnnotationSpecs;
 import dagger.internal.codegen.javapoet.TypeNames;
 import dagger.producers.internal.DelegateProducer;
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 103765735..23bed3dd7 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -22,6 +22,8 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.FrameworkType;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
diff --git a/java/dagger/internal/codegen/GwtCompatibility.java b/java/dagger/internal/codegen/GwtCompatibility.java
index 34d8f6d69..bcbe4b7cf 100644
--- a/java/dagger/internal/codegen/GwtCompatibility.java
+++ b/java/dagger/internal/codegen/GwtCompatibility.java
@@ -19,6 +19,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 
 import com.squareup.javapoet.AnnotationSpec;
+import dagger.internal.codegen.binding.Binding;
 import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
diff --git a/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java b/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
index 9a0853c7d..84790e0ef 100644
--- a/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
+++ b/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
@@ -17,7 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
index 96c3a70ae..5fd30ad50 100644
--- a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
+++ b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
@@ -25,6 +25,8 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.codegen.base.SourceFileGenerator;
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.MapKeys;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import java.util.Optional;
diff --git a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
index 0985b53ef..03371eaee 100644
--- a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
+++ b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
@@ -27,6 +27,7 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
 import dagger.internal.codegen.base.Scopes;
+import dagger.internal.codegen.binding.MethodSignatureFormatter;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.model.Binding;
 import dagger.model.BindingGraph;
diff --git a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
index 29c4c80a4..89f0fccb4 100644
--- a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
+++ b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
@@ -19,10 +19,10 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.base.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.base.Keys.isValidImplicitProvisionKey;
 import static dagger.internal.codegen.base.Keys.isValidMembersInjectionKey;
+import static dagger.internal.codegen.binding.SourceFiles.generatedClassNameForBinding;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -37,6 +37,12 @@
 import dagger.Provides;
 import dagger.internal.codegen.base.SourceFileGenerationException;
 import dagger.internal.codegen.base.SourceFileGenerator;
+import dagger.internal.codegen.binding.Binding;
+import dagger.internal.codegen.binding.BindingFactory;
+import dagger.internal.codegen.binding.InjectBindingRegistry;
+import dagger.internal.codegen.binding.KeyFactory;
+import dagger.internal.codegen.binding.MembersInjectionBinding;
+import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
diff --git a/java/dagger/internal/codegen/InjectBindingRegistryModule.java b/java/dagger/internal/codegen/InjectBindingRegistryModule.java
index 45633620d..35328e2f9 100644
--- a/java/dagger/internal/codegen/InjectBindingRegistryModule.java
+++ b/java/dagger/internal/codegen/InjectBindingRegistryModule.java
@@ -18,6 +18,7 @@
 
 import dagger.Binds;
 import dagger.Module;
+import dagger.internal.codegen.binding.InjectBindingRegistry;
 
 @Module
 interface InjectBindingRegistryModule {
diff --git a/java/dagger/internal/codegen/InjectProcessingStep.java b/java/dagger/internal/codegen/InjectProcessingStep.java
index be8c975a1..6ce76d4e9 100644
--- a/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -18,6 +18,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.binding.InjectBindingRegistry;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.inject.Inject;
diff --git a/java/dagger/internal/codegen/InjectionMethod.java b/java/dagger/internal/codegen/InjectionMethod.java
index cd06aea7a..5fc447d48 100644
--- a/java/dagger/internal/codegen/InjectionMethod.java
+++ b/java/dagger/internal/codegen/InjectionMethod.java
@@ -18,7 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static dagger.internal.codegen.SourceFiles.protectAgainstKeywords;
+import static dagger.internal.codegen.binding.SourceFiles.protectAgainstKeywords;
 import static dagger.internal.codegen.javapoet.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.langmodel.Accessibility.isRawTypePubliclyAccessible;
 import static javax.lang.model.element.Modifier.PUBLIC;
diff --git a/java/dagger/internal/codegen/InjectionMethods.java b/java/dagger/internal/codegen/InjectionMethods.java
index 4a15d279a..bd6517cbe 100644
--- a/java/dagger/internal/codegen/InjectionMethods.java
+++ b/java/dagger/internal/codegen/InjectionMethods.java
@@ -19,11 +19,11 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
 import static dagger.internal.codegen.FactoryGenerator.checkNotNullProvidesMethod;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.base.RequestKinds.requestTypeName;
+import static dagger.internal.codegen.binding.ConfigurationAnnotations.getNullableType;
+import static dagger.internal.codegen.binding.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.binding.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableList;
 import static dagger.internal.codegen.javapoet.CodeBlocks.toConcatenatedCodeBlock;
 import static dagger.internal.codegen.javapoet.TypeNames.rawTypeName;
@@ -42,7 +42,8 @@
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeName;
-import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+import dagger.internal.codegen.binding.MembersInjectionBinding.InjectionSite;
+import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerElements;
diff --git a/java/dagger/internal/codegen/InjectionOrProvisionProviderCreationExpression.java b/java/dagger/internal/codegen/InjectionOrProvisionProviderCreationExpression.java
index 2d2e8cb11..a0039a583 100644
--- a/java/dagger/internal/codegen/InjectionOrProvisionProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/InjectionOrProvisionProviderCreationExpression.java
@@ -17,11 +17,12 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.binding.SourceFiles.generatedClassNameForBinding;
 import static dagger.model.BindingKind.INJECTION;
 
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.internal.codegen.javapoet.CodeBlocks;
 import javax.inject.Provider;
 
diff --git a/java/dagger/internal/codegen/InnerSwitchingProviders.java b/java/dagger/internal/codegen/InnerSwitchingProviders.java
index 74c4366e1..077e5f2d5 100644
--- a/java/dagger/internal/codegen/InnerSwitchingProviders.java
+++ b/java/dagger/internal/codegen/InnerSwitchingProviders.java
@@ -17,7 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
 import static dagger.model.RequestKind.INSTANCE;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -26,6 +26,7 @@
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.Key;
diff --git a/java/dagger/internal/codegen/JavacPluginModule.java b/java/dagger/internal/codegen/JavacPluginModule.java
index 0877321da..ac584346b 100644
--- a/java/dagger/internal/codegen/JavacPluginModule.java
+++ b/java/dagger/internal/codegen/JavacPluginModule.java
@@ -22,6 +22,8 @@
 import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.binding.BindingGraphFactory;
+import dagger.internal.codegen.binding.ComponentDescriptorFactory;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.compileroption.JavacPluginCompilerOptions;
 import dagger.internal.codegen.langmodel.DaggerElements;
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index 178500aa0..00eb84e90 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -18,8 +18,8 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
-import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.binding.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.javapoet.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.langmodel.Accessibility.isTypeAccessibleFrom;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
@@ -31,6 +31,9 @@
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.MapBuilder;
 import dagger.internal.codegen.base.MapType;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
diff --git a/java/dagger/internal/codegen/MapFactoryCreationExpression.java b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
index 7ffdc4df1..85d1f3053 100644
--- a/java/dagger/internal/codegen/MapFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
@@ -17,12 +17,14 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
-import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
+import static dagger.internal.codegen.binding.MapKeys.getMapKeyExpression;
+import static dagger.internal.codegen.binding.SourceFiles.mapFactoryClassName;
 
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.base.MapType;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.model.DependencyRequest;
 import dagger.producers.Produced;
diff --git a/java/dagger/internal/codegen/MapKeyProcessingStep.java b/java/dagger/internal/codegen/MapKeyProcessingStep.java
index 2f23aee3d..53927590c 100644
--- a/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -16,7 +16,7 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
+import static dagger.internal.codegen.binding.MapKeys.getUnwrappedMapKeyType;
 import static javax.lang.model.element.ElementKind.ANNOTATION_TYPE;
 
 import com.google.auto.common.MoreElements;
diff --git a/java/dagger/internal/codegen/MapMultibindingValidator.java b/java/dagger/internal/codegen/MapMultibindingValidator.java
index c433c7e61..8a909f11b 100644
--- a/java/dagger/internal/codegen/MapMultibindingValidator.java
+++ b/java/dagger/internal/codegen/MapMultibindingValidator.java
@@ -32,6 +32,11 @@
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
 import dagger.internal.codegen.base.MapType;
+import dagger.internal.codegen.binding.BindingDeclaration;
+import dagger.internal.codegen.binding.BindingDeclarationFormatter;
+import dagger.internal.codegen.binding.BindingNode;
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.KeyFactory;
 import dagger.model.BindingGraph;
 import dagger.model.Key;
 import dagger.producers.Producer;
diff --git a/java/dagger/internal/codegen/MemberSelect.java b/java/dagger/internal/codegen/MemberSelect.java
index 6dcdd3b50..7e0a2b889 100644
--- a/java/dagger/internal/codegen/MemberSelect.java
+++ b/java/dagger/internal/codegen/MemberSelect.java
@@ -17,10 +17,10 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
-import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
+import static dagger.internal.codegen.binding.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
+import static dagger.internal.codegen.binding.SourceFiles.bindingTypeElementTypeVariableNames;
+import static dagger.internal.codegen.binding.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.binding.SourceFiles.setFactoryClassName;
 import static dagger.internal.codegen.javapoet.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.javapoet.TypeNames.FACTORY;
 import static dagger.internal.codegen.javapoet.TypeNames.MAP_FACTORY;
@@ -36,6 +36,8 @@
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.codegen.base.SetType;
+import dagger.internal.codegen.binding.BindingType;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.internal.codegen.javapoet.CodeBlocks;
 import java.util.List;
 import java.util.Optional;
diff --git a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
index f2b1d1a6e..80503ed3a 100644
--- a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
+++ b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
@@ -22,7 +22,8 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.ParameterSpec;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.MembersInjectionBinding;
 import dagger.internal.codegen.javapoet.Expression;
 import javax.lang.model.element.ExecutableElement;
 
diff --git a/java/dagger/internal/codegen/MembersInjectionMethods.java b/java/dagger/internal/codegen/MembersInjectionMethods.java
index c24af89ae..9b9d0094f 100644
--- a/java/dagger/internal/codegen/MembersInjectionMethods.java
+++ b/java/dagger/internal/codegen/MembersInjectionMethods.java
@@ -30,7 +30,12 @@
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeName;
 import dagger.internal.codegen.InjectionMethods.InjectionSiteMethod;
-import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+import dagger.internal.codegen.binding.Binding;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.MembersInjectionBinding;
+import dagger.internal.codegen.binding.MembersInjectionBinding.InjectionSite;
+import dagger.internal.codegen.binding.ProvisionBinding;
+import dagger.internal.codegen.binding.ResolvedBindings;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.Key;
diff --git a/java/dagger/internal/codegen/MembersInjectorGenerator.java b/java/dagger/internal/codegen/MembersInjectorGenerator.java
index c447c94f1..574e94a7c 100644
--- a/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -21,11 +21,11 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
-import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
-import static dagger.internal.codegen.SourceFiles.frameworkFieldUsages;
-import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
-import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.binding.SourceFiles.bindingTypeElementTypeVariableNames;
+import static dagger.internal.codegen.binding.SourceFiles.frameworkFieldUsages;
+import static dagger.internal.codegen.binding.SourceFiles.generateBindingFieldsForDependencies;
+import static dagger.internal.codegen.binding.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.binding.SourceFiles.parameterizedGeneratedTypeNameForBinding;
 import static dagger.internal.codegen.javapoet.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.javapoet.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.javapoet.AnnotationSpecs.suppressWarnings;
@@ -49,9 +49,11 @@
 import com.squareup.javapoet.TypeVariableName;
 import dagger.MembersInjector;
 import dagger.internal.codegen.InjectionMethods.InjectionSiteMethod;
-import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import dagger.internal.codegen.base.SourceFileGenerator;
 import dagger.internal.codegen.base.UniqueNameSet;
+import dagger.internal.codegen.binding.FrameworkField;
+import dagger.internal.codegen.binding.MembersInjectionBinding;
+import dagger.internal.codegen.binding.MembersInjectionBinding.InjectionSite;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.internal.codegen.statistics.DaggerStatisticsCollector;
diff --git a/java/dagger/internal/codegen/MembersInjectorProviderCreationExpression.java b/java/dagger/internal/codegen/MembersInjectorProviderCreationExpression.java
index 8e863e526..a478e9496 100644
--- a/java/dagger/internal/codegen/MembersInjectorProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/MembersInjectorProviderCreationExpression.java
@@ -18,13 +18,14 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.binding.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.javapoet.TypeNames.INSTANCE_FACTORY;
 import static dagger.internal.codegen.javapoet.TypeNames.MEMBERS_INJECTORS;
 
 import com.google.auto.common.MoreTypes;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.binding.ProvisionBinding;
 import javax.lang.model.type.TypeMirror;
 
 /** A {@code Provider<MembersInjector<Foo>>} creation expression. */
diff --git a/java/dagger/internal/codegen/MethodBindingExpression.java b/java/dagger/internal/codegen/MethodBindingExpression.java
index 915d9a58b..8a8554b95 100644
--- a/java/dagger/internal/codegen/MethodBindingExpression.java
+++ b/java/dagger/internal/codegen/MethodBindingExpression.java
@@ -29,7 +29,11 @@
 import com.squareup.javapoet.TypeName;
 import dagger.internal.DoubleCheck;
 import dagger.internal.MemoizedSentinel;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.BindingRequest;
+import dagger.internal.codegen.binding.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.FrameworkField;
+import dagger.internal.codegen.binding.KeyVariableNamer;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.RequestKind;
diff --git a/java/dagger/internal/codegen/MissingBindingValidator.java b/java/dagger/internal/codegen/MissingBindingValidator.java
index b006e7c1a..a9dfdce76 100644
--- a/java/dagger/internal/codegen/MissingBindingValidator.java
+++ b/java/dagger/internal/codegen/MissingBindingValidator.java
@@ -23,6 +23,7 @@
 import static dagger.internal.codegen.extension.DaggerStreams.instancesOf;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
+import dagger.internal.codegen.binding.InjectBindingRegistry;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.BindingGraph;
 import dagger.model.BindingGraph.ComponentNode;
diff --git a/java/dagger/internal/codegen/ModuleConstructorProxyGenerator.java b/java/dagger/internal/codegen/ModuleConstructorProxyGenerator.java
index b17fb2e92..df484cbd9 100644
--- a/java/dagger/internal/codegen/ModuleConstructorProxyGenerator.java
+++ b/java/dagger/internal/codegen/ModuleConstructorProxyGenerator.java
@@ -19,8 +19,8 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.ModuleKind.checkIsModule;
 import static dagger.internal.codegen.ModuleProxies.nonPublicNullaryConstructor;
+import static dagger.internal.codegen.binding.ModuleKind.checkIsModule;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
diff --git a/java/dagger/internal/codegen/ModuleProcessingStep.java b/java/dagger/internal/codegen/ModuleProcessingStep.java
index f7fc0698d..20bd575a5 100644
--- a/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -28,8 +28,13 @@
 import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.DelegateDeclaration.Factory;
 import dagger.internal.codegen.base.SourceFileGenerator;
+import dagger.internal.codegen.binding.BindingFactory;
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.DelegateDeclaration;
+import dagger.internal.codegen.binding.DelegateDeclaration.Factory;
+import dagger.internal.codegen.binding.ProductionBinding;
+import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
diff --git a/java/dagger/internal/codegen/ModuleProxies.java b/java/dagger/internal/codegen/ModuleProxies.java
index 6426e693e..82fe78584 100644
--- a/java/dagger/internal/codegen/ModuleProxies.java
+++ b/java/dagger/internal/codegen/ModuleProxies.java
@@ -24,6 +24,8 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.binding.ModuleKind;
+import dagger.internal.codegen.binding.SourceFiles;
 import dagger.internal.codegen.langmodel.Accessibility;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import java.util.Optional;
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index 6dafa3b6a..29d8365b7 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -21,8 +21,6 @@
 import static com.google.auto.common.Visibility.PUBLIC;
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.getCreatorAnnotations;
-import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentCreator;
 import static dagger.internal.codegen.base.ComponentAnnotation.componentAnnotation;
 import static dagger.internal.codegen.base.ComponentAnnotation.isComponentAnnotation;
 import static dagger.internal.codegen.base.ComponentAnnotation.subcomponentAnnotation;
@@ -31,6 +29,8 @@
 import static dagger.internal.codegen.base.MoreAnnotationMirrors.simpleName;
 import static dagger.internal.codegen.base.MoreAnnotationValues.asType;
 import static dagger.internal.codegen.base.Util.reentrantComputeIfAbsent;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.getCreatorAnnotations;
+import static dagger.internal.codegen.binding.ConfigurationAnnotations.getSubcomponentCreator;
 import static dagger.internal.codegen.compileroption.ValidationType.NONE;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.langmodel.DaggerElements.getAnnotationMirror;
@@ -55,6 +55,12 @@
 import dagger.Module;
 import dagger.Subcomponent;
 import dagger.internal.codegen.base.ModuleAnnotation;
+import dagger.internal.codegen.binding.BindingGraphConverter;
+import dagger.internal.codegen.binding.BindingGraphFactory;
+import dagger.internal.codegen.binding.ComponentCreatorAnnotation;
+import dagger.internal.codegen.binding.ComponentDescriptorFactory;
+import dagger.internal.codegen.binding.MethodSignatureFormatter;
+import dagger.internal.codegen.binding.ModuleKind;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
diff --git a/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index d839490ce..38abc8626 100644
--- a/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -32,6 +32,7 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.codegen.base.SourceFileGenerator;
+import dagger.internal.codegen.binding.SourceFiles;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProductionScope;
diff --git a/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java b/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
index fdbd2a073..a39530eb0 100644
--- a/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
@@ -20,6 +20,8 @@
 
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.binding.BindingRequest;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.internal.codegen.javapoet.CodeBlocks;
 import dagger.model.DependencyRequest;
 
diff --git a/java/dagger/internal/codegen/OptionalBindingExpression.java b/java/dagger/internal/codegen/OptionalBindingExpression.java
index 3c74f07c0..07e7c283a 100644
--- a/java/dagger/internal/codegen/OptionalBindingExpression.java
+++ b/java/dagger/internal/codegen/OptionalBindingExpression.java
@@ -17,13 +17,14 @@
 package dagger.internal.codegen;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.langmodel.Accessibility.isTypeAccessibleFrom;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.base.OptionalType;
 import dagger.internal.codegen.base.OptionalType.OptionalKind;
+import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.DependencyRequest;
diff --git a/java/dagger/internal/codegen/OptionalFactories.java b/java/dagger/internal/codegen/OptionalFactories.java
index aeb2a0af5..c3d67264a 100644
--- a/java/dagger/internal/codegen/OptionalFactories.java
+++ b/java/dagger/internal/codegen/OptionalFactories.java
@@ -57,6 +57,9 @@
 import dagger.internal.Preconditions;
 import dagger.internal.codegen.base.OptionalType;
 import dagger.internal.codegen.base.OptionalType.OptionalKind;
+import dagger.internal.codegen.binding.BindingType;
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.FrameworkType;
 import dagger.internal.codegen.javapoet.AnnotationSpecs;
 import dagger.model.RequestKind;
 import dagger.producers.Producer;
diff --git a/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java b/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
index ba9e25f0f..38232cb40 100644
--- a/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
+++ b/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
@@ -17,10 +17,11 @@
 package dagger.internal.codegen;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.binding.ContributionBinding;
 
 /**
  * A {@link FrameworkInstanceCreationExpression} for {@link dagger.model.BindingKind#OPTIONAL
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 3152e306b..617c6c922 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -23,6 +23,8 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.squareup.javapoet.TypeName;
+import dagger.internal.codegen.binding.BindingRequest;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 
 /**
diff --git a/java/dagger/internal/codegen/ProcessingRoundCacheModule.java b/java/dagger/internal/codegen/ProcessingRoundCacheModule.java
index ee1f49d5b..5efa02f72 100644
--- a/java/dagger/internal/codegen/ProcessingRoundCacheModule.java
+++ b/java/dagger/internal/codegen/ProcessingRoundCacheModule.java
@@ -19,6 +19,8 @@
 import dagger.Binds;
 import dagger.Module;
 import dagger.internal.codegen.base.ClearableCache;
+import dagger.internal.codegen.binding.BindingGraphFactory;
+import dagger.internal.codegen.binding.ModuleDescriptor;
 import dagger.multibindings.IntoSet;
 
 /**
diff --git a/java/dagger/internal/codegen/ProducerCreationExpression.java b/java/dagger/internal/codegen/ProducerCreationExpression.java
index 1dd7a1c4b..148ff5356 100644
--- a/java/dagger/internal/codegen/ProducerCreationExpression.java
+++ b/java/dagger/internal/codegen/ProducerCreationExpression.java
@@ -17,10 +17,11 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.binding.SourceFiles.generatedClassNameForBinding;
 
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.binding.ContributionBinding;
 
 /**
  * A {@link dagger.producers.Producer} creation expression for a {@link
diff --git a/java/dagger/internal/codegen/ProducerEntryPointView.java b/java/dagger/internal/codegen/ProducerEntryPointView.java
index 87b5a4a0f..06930e45b 100644
--- a/java/dagger/internal/codegen/ProducerEntryPointView.java
+++ b/java/dagger/internal/codegen/ProducerEntryPointView.java
@@ -22,7 +22,7 @@
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.TypeName;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.RequestKind;
diff --git a/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index a785ef1f7..f4d550228 100644
--- a/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -23,10 +23,10 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
-import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
-import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.binding.SourceFiles.bindingTypeElementTypeVariableNames;
+import static dagger.internal.codegen.binding.SourceFiles.generateBindingFieldsForDependencies;
+import static dagger.internal.codegen.binding.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.binding.SourceFiles.parameterizedGeneratedTypeNameForBinding;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableList;
 import static dagger.internal.codegen.javapoet.AnnotationSpecs.Suppression.FUTURE_RETURN_VALUE_IGNORED;
 import static dagger.internal.codegen.javapoet.AnnotationSpecs.Suppression.UNCHECKED;
@@ -60,6 +60,11 @@
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.codegen.base.SourceFileGenerator;
 import dagger.internal.codegen.base.UniqueNameSet;
+import dagger.internal.codegen.binding.Binding;
+import dagger.internal.codegen.binding.FrameworkField;
+import dagger.internal.codegen.binding.KeyFactory;
+import dagger.internal.codegen.binding.ProductionBinding;
+import dagger.internal.codegen.binding.SourceFiles;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.javapoet.AnnotationSpecs;
 import dagger.internal.codegen.javapoet.AnnotationSpecs.Suppression;
diff --git a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
index aca97562e..19a39094b 100644
--- a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
@@ -17,11 +17,13 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.FrameworkType;
 import dagger.internal.codegen.javapoet.TypeNames;
 import dagger.model.RequestKind;
 import dagger.producers.Producer;
diff --git a/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
index a1810c877..a5f0f119a 100644
--- a/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
@@ -19,7 +19,9 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.squareup.javapoet.ClassName;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.FrameworkType;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
diff --git a/java/dagger/internal/codegen/ProducesMethodValidator.java b/java/dagger/internal/codegen/ProducesMethodValidator.java
index bf4594856..34e412c0e 100644
--- a/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -24,6 +24,7 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.internal.codegen.binding.ConfigurationAnnotations;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.multibindings.ElementsIntoSet;
diff --git a/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java b/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java
index e9f696817..9a7c07693 100644
--- a/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java
@@ -16,6 +16,8 @@
 
 package dagger.internal.codegen;
 
+import dagger.internal.codegen.binding.ContributionBinding;
+import dagger.internal.codegen.binding.FrameworkType;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
index e9daa0ff8..4aa8b03e3 100644
--- a/java/dagger/internal/codegen/SetBindingExpression.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -17,7 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.javapoet.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.langmodel.Accessibility.isTypeAccessibleFrom;
 import static javax.lang.model.util.ElementFilter.methodsIn;
@@ -28,6 +28,8 @@
 import dagger.internal.SetBuilder;
 import dagger.internal.codegen.base.ContributionType;
 import dagger.internal.codegen.base.SetType;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
diff --git a/java/dagger/internal/codegen/SetFactoryCreationExpression.java b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
index 2660e2cc6..f2d1da51c 100644
--- a/java/dagger/internal/codegen/SetFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
@@ -17,11 +17,14 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
+import static dagger.internal.codegen.binding.SourceFiles.setFactoryClassName;
 
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.base.ContributionType;
 import dagger.internal.codegen.base.SetType;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.BindingType;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.model.DependencyRequest;
 import dagger.producers.Produced;
 
diff --git a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
index 297842624..10e74b0fc 100644
--- a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
@@ -18,6 +18,8 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
+import dagger.internal.codegen.binding.ContributionBinding;
+
 /** A simple binding expression for instance requests. Does not scope. */
 abstract class SimpleInvocationBindingExpression extends BindingExpression {
   private final ContributionBinding binding;
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index 9fea33653..0cf79f0fc 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -31,6 +31,8 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import dagger.internal.codegen.InjectionMethods.ProvisionMethod;
+import dagger.internal.codegen.binding.ComponentRequirement;
+import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.internal.codegen.javapoet.Expression;
 import dagger.internal.codegen.langmodel.DaggerElements;
diff --git a/java/dagger/internal/codegen/SourceFileGeneratorsModule.java b/java/dagger/internal/codegen/SourceFileGeneratorsModule.java
index 1a13f2401..2aff685de 100644
--- a/java/dagger/internal/codegen/SourceFileGeneratorsModule.java
+++ b/java/dagger/internal/codegen/SourceFileGeneratorsModule.java
@@ -23,6 +23,10 @@
 import dagger.internal.codegen.SourceFileGeneratorsModule.ProductionModule;
 import dagger.internal.codegen.SourceFileGeneratorsModule.ProvisionModule;
 import dagger.internal.codegen.base.SourceFileGenerator;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.MembersInjectionBinding;
+import dagger.internal.codegen.binding.ProductionBinding;
+import dagger.internal.codegen.binding.ProvisionBinding;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import javax.lang.model.element.TypeElement;
 
diff --git a/java/dagger/internal/codegen/SubcomponentCreatorBindingExpression.java b/java/dagger/internal/codegen/SubcomponentCreatorBindingExpression.java
index 4f6958303..ab39c60ac 100644
--- a/java/dagger/internal/codegen/SubcomponentCreatorBindingExpression.java
+++ b/java/dagger/internal/codegen/SubcomponentCreatorBindingExpression.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import com.squareup.javapoet.ClassName;
+import dagger.internal.codegen.binding.ContributionBinding;
 import dagger.internal.codegen.javapoet.Expression;
 import javax.lang.model.type.TypeMirror;
 
diff --git a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
index 3f3481d2b..018560e73 100644
--- a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
+++ b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
@@ -30,6 +30,7 @@
 import com.google.common.collect.Sets;
 import com.google.common.collect.Sets.SetView;
 import dagger.internal.codegen.base.Util;
+import dagger.internal.codegen.binding.ComponentNodeImpl;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.BindingGraph;
 import dagger.model.BindingGraph.ChildFactoryMethodEdge;
diff --git a/java/dagger/internal/codegen/SubcomponentNames.java b/java/dagger/internal/codegen/SubcomponentNames.java
index f690ae1f4..5b1ef3768 100644
--- a/java/dagger/internal/codegen/SubcomponentNames.java
+++ b/java/dagger/internal/codegen/SubcomponentNames.java
@@ -29,6 +29,10 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimaps;
 import dagger.internal.codegen.base.UniqueNameSet;
+import dagger.internal.codegen.binding.BindingGraph;
+import dagger.internal.codegen.binding.ComponentCreatorDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptor;
+import dagger.internal.codegen.binding.KeyFactory;
 import dagger.model.Key;
 import java.util.Collection;
 import java.util.Iterator;
diff --git a/java/dagger/internal/codegen/AnnotationExpression.java b/java/dagger/internal/codegen/binding/AnnotationExpression.java
similarity index 93%
rename from java/dagger/internal/codegen/AnnotationExpression.java
rename to java/dagger/internal/codegen/binding/AnnotationExpression.java
index 8d729e274..6b470919a 100644
--- a/java/dagger/internal/codegen/AnnotationExpression.java
+++ b/java/dagger/internal/codegen/binding/AnnotationExpression.java
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
-import static dagger.internal.codegen.SourceFiles.classFileName;
+import static dagger.internal.codegen.binding.SourceFiles.classFileName;
 import static dagger.internal.codegen.javapoet.CodeBlocks.makeParametersCodeBlock;
 import static java.util.stream.Collectors.toList;
 
@@ -40,7 +40,7 @@
 
 /**
  * Returns an expression creating an instance of the visited annotation type. Its parameter must be
- * a class as generated by {@link AnnotationCreatorGenerator}.
+ * a class as generated by {@link dagger.internal.codegen.AnnotationCreatorGenerator}.
  *
  * <p>Note that {@link AnnotationValue#toString()} is the source-code representation of the value
  * <em>when used in an annotation</em>, which is not always the same as the representation needed
@@ -49,7 +49,8 @@
  * <p>For example, inside an annotation, a nested array of {@code int}s is simply {@code {1, 2, 3}},
  * but in code it would have to be {@code new int[] {1, 2, 3}}.
  */
-class AnnotationExpression extends SimpleAnnotationValueVisitor6<CodeBlock, AnnotationValue> {
+public class AnnotationExpression
+    extends SimpleAnnotationValueVisitor6<CodeBlock, AnnotationValue> {
 
   private final AnnotationMirror annotation;
   private final ClassName creatorClass;
@@ -87,14 +88,14 @@ private CodeBlock getAnnotationInstanceExpression(AnnotationMirror annotation) {
    * Returns the name of the generated class that contains the static {@code create} methods for an
    * annotation type.
    */
-  static ClassName getAnnotationCreatorClassName(TypeElement annotationType) {
+  public static ClassName getAnnotationCreatorClassName(TypeElement annotationType) {
     ClassName annotationTypeName = ClassName.get(annotationType);
     return annotationTypeName
         .topLevelClassName()
         .peerClass(classFileName(annotationTypeName) + "Creator");
   }
 
-  static String createMethodName(TypeElement annotationType) {
+  public static String createMethodName(TypeElement annotationType) {
     return "create" + annotationType.getSimpleName();
   }
 
diff --git a/java/dagger/internal/codegen/binding/BUILD b/java/dagger/internal/codegen/binding/BUILD
new file mode 100644
index 000000000..7dd453f54
--- /dev/null
+++ b/java/dagger/internal/codegen/binding/BUILD
@@ -0,0 +1,41 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   JavaPoet extensions for use in Dagger
+
+package(default_visibility = ["//:src"])
+
+java_library(
+    name = "binding",
+    srcs = glob(["*.java"]),
+    plugins = ["//java/dagger/internal/codegen/bootstrap"],
+    tags = ["maven:merged"],
+    deps = [
+        "//java/dagger:core",
+        "//java/dagger/internal/codegen/base",
+        "//java/dagger/internal/codegen/compileroption",
+        "//java/dagger/internal/codegen/extension",
+        "//java/dagger/internal/codegen/javapoet",
+        "//java/dagger/internal/codegen/langmodel",
+        "//java/dagger/model",
+        "//java/dagger/model:internal-proxies",
+        "//java/dagger/producers",
+        "@google_bazel_common//third_party/java/auto:common",
+        "@google_bazel_common//third_party/java/auto:value",
+        "@google_bazel_common//third_party/java/error_prone:annotations",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/javapoet",
+    ],
+)
diff --git a/java/dagger/internal/codegen/Binding.java b/java/dagger/internal/codegen/binding/Binding.java
similarity index 87%
rename from java/dagger/internal/codegen/Binding.java
rename to java/dagger/internal/codegen/binding/Binding.java
index 9502fadc7..0d4eef65e 100644
--- a/java/dagger/internal/codegen/Binding.java
+++ b/java/dagger/internal/codegen/binding/Binding.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.Suppliers.memoize;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -46,13 +46,13 @@
  * to satisfy the binding, but leaves the specifics of the <i>mechanism</i> of the binding to the
  * subtypes.
  */
-abstract class Binding extends BindingDeclaration {
+public abstract class Binding extends BindingDeclaration {
 
   /**
    * Returns {@code true} if using this binding requires an instance of the {@link
    * #contributingModule()}.
    */
-  boolean requiresModuleInstance() {
+  public boolean requiresModuleInstance() {
     if (!bindingElement().isPresent() || !contributingModule().isPresent()) {
       return false;
     }
@@ -65,16 +65,16 @@ boolean requiresModuleInstance() {
    * #key()}. Nullable bindings cannot be requested from {@linkplain DependencyRequest#isNullable()
    * non-nullable dependency requests}.
    */
-  abstract boolean isNullable();
+  public abstract boolean isNullable();
 
   /** The kind of binding this instance represents. */
-  abstract BindingKind kind();
+  public abstract BindingKind kind();
 
   /** The {@link BindingType} of this binding. */
-  abstract BindingType bindingType();
+  public abstract BindingType bindingType();
 
   /** The {@link FrameworkType} of this binding. */
-  final FrameworkType frameworkType() {
+  public final FrameworkType frameworkType() {
     return FrameworkType.forBindingType(bindingType());
   }
 
@@ -82,13 +82,13 @@ final FrameworkType frameworkType() {
    * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding as
    * defined by the user-defined injection sites.
    */
-  abstract ImmutableSet<DependencyRequest> explicitDependencies();
+  public abstract ImmutableSet<DependencyRequest> explicitDependencies();
 
   /**
    * The set of {@link DependencyRequest dependencies} that are added by the framework rather than a
    * user-defined injection site. This returns an unmodifiable set.
    */
-  ImmutableSet<DependencyRequest> implicitDependencies() {
+  public ImmutableSet<DependencyRequest> implicitDependencies() {
     return ImmutableSet.of();
   }
 
@@ -107,18 +107,18 @@ final FrameworkType frameworkType() {
    * union of {@link #explicitDependencies()} and {@link #implicitDependencies()}. This returns an
    * unmodifiable set.
    */
-  final ImmutableSet<DependencyRequest> dependencies() {
+  public final ImmutableSet<DependencyRequest> dependencies() {
     return dependencies.get();
   }
 
   /**
-   * If this binding's key's type parameters are different from those of the
-   * {@link #bindingTypeElement()}, this is the binding for the {@link #bindingTypeElement()}'s
-   * unresolved type.
+   * If this binding's key's type parameters are different from those of the {@link
+   * #bindingTypeElement()}, this is the binding for the {@link #bindingTypeElement()}'s unresolved
+   * type.
    */
-  abstract Optional<? extends Binding> unresolved();
+  public abstract Optional<? extends Binding> unresolved();
 
-  Optional<Scope> scope() {
+  public Optional<Scope> scope() {
     return Optional.empty();
   }
 
diff --git a/java/dagger/internal/codegen/BindingDeclaration.java b/java/dagger/internal/codegen/binding/BindingDeclaration.java
similarity index 80%
rename from java/dagger/internal/codegen/BindingDeclaration.java
rename to java/dagger/internal/codegen/binding/BindingDeclaration.java
index 3e0db7f3e..712260fb7 100644
--- a/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/java/dagger/internal/codegen/binding/BindingDeclaration.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static dagger.internal.codegen.extension.Optionals.emptiesLast;
 import static java.util.Comparator.comparing;
@@ -28,21 +28,21 @@
 import javax.lang.model.element.TypeElement;
 
 /** An object that declares or specifies a binding. */
-abstract class BindingDeclaration {
+public abstract class BindingDeclaration {
   /**
-    * A comparator that compares binding declarations with elements.
-    *
-    * Compares, in order:
-    *
-    * <ol>
-    * <li>Contributing module or enclosing type name
-    * <li>Binding element's simple name
-    * <li>Binding element's type
-    * </ol>
-    *
-    * Any binding declarations without elements are last.
-    */
-  static final Comparator<BindingDeclaration> COMPARATOR =
+   * A comparator that compares binding declarations with elements.
+   *
+   * <p>Compares, in order:
+   *
+   * <ol>
+   *   <li>Contributing module or enclosing type name
+   *   <li>Binding element's simple name
+   *   <li>Binding element's type
+   * </ol>
+   *
+   * Any binding declarations without elements are last.
+   */
+  public static final Comparator<BindingDeclaration> COMPARATOR =
       comparing(
               (BindingDeclaration declaration) ->
                   declaration.contributingModule().isPresent()
@@ -56,7 +56,7 @@
                       .thenComparing((Element element) -> element.asType().toString())));
 
   /** The {@link Key} of this declaration. */
-  abstract Key key();
+  public abstract Key key();
 
   /**
    * The {@link Element} that declares this binding. Absent for {@linkplain BindingKind binding
@@ -68,13 +68,13 @@
    * contribute a synthetic binding, but since multiple {@code @Multibinds} methods can coexist in
    * the same component (and contribute to one single binding), it has no binding element.
    */
-  abstract Optional<Element> bindingElement();
+  public abstract Optional<Element> bindingElement();
 
   /**
    * The type enclosing the {@link #bindingElement()}, or {@link Optional#empty()} if {@link
    * #bindingElement()} is empty.
    */
-  final Optional<TypeElement> bindingTypeElement() {
+  public final Optional<TypeElement> bindingTypeElement() {
     return bindingElement().map(DaggerElements::closestEnclosingTypeElement);
   }
 
@@ -83,5 +83,5 @@
    * the class that contains {@link #bindingElement()}. Absent if {@link #bindingElement()} is
    * empty.
    */
-  abstract Optional<TypeElement> contributingModule();
+  public abstract Optional<TypeElement> contributingModule();
 }
diff --git a/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/java/dagger/internal/codegen/binding/BindingDeclarationFormatter.java
similarity index 96%
rename from java/dagger/internal/codegen/BindingDeclarationFormatter.java
rename to java/dagger/internal/codegen/binding/BindingDeclarationFormatter.java
index 1bbc61aee..d88dd4b7b 100644
--- a/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/java/dagger/internal/codegen/binding/BindingDeclarationFormatter.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.collect.Sets.immutableEnumSet;
 import static dagger.internal.codegen.base.DiagnosticFormatting.stripCommonTypePrefixes;
@@ -36,7 +36,7 @@
 /**
  * Formats a {@link BindingDeclaration} into a {@link String} suitable for use in error messages.
  */
-final class BindingDeclarationFormatter extends Formatter<BindingDeclaration> {
+public final class BindingDeclarationFormatter extends Formatter<BindingDeclaration> {
   private static final ImmutableSet<TypeKind> FORMATTABLE_ELEMENT_TYPE_KINDS =
       immutableEnumSet(EXECUTABLE, DECLARED);
 
@@ -52,7 +52,7 @@
    * from subcomponent declarations or those with {@linkplain BindingDeclaration#bindingElement()
    * binding elements} that are methods, constructors, or types.
    */
-  boolean canFormat(BindingDeclaration bindingDeclaration) {
+  public boolean canFormat(BindingDeclaration bindingDeclaration) {
     if (bindingDeclaration instanceof SubcomponentDeclaration) {
       return true;
     }
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/binding/BindingFactory.java
similarity index 94%
rename from java/dagger/internal/codegen/BindingFactory.java
rename to java/dagger/internal/codegen/binding/BindingFactory.java
index 58f5af824..f934b6acb 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/binding/BindingFactory.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asDeclared;
@@ -22,14 +22,14 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.Binding.hasNonDefaultTypeParameters;
-import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
-import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
-import static dagger.internal.codegen.ContributionBinding.bindingKindForMultibindingKey;
-import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.base.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.base.MoreAnnotationMirrors.wrapOptionalInEquivalence;
 import static dagger.internal.codegen.base.Scopes.uniqueScopeOf;
+import static dagger.internal.codegen.binding.Binding.hasNonDefaultTypeParameters;
+import static dagger.internal.codegen.binding.ComponentDescriptor.isComponentProductionMethod;
+import static dagger.internal.codegen.binding.ConfigurationAnnotations.getNullableType;
+import static dagger.internal.codegen.binding.ContributionBinding.bindingKindForMultibindingKey;
+import static dagger.internal.codegen.binding.MapKeys.getMapKey;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableSet;
 import static dagger.model.BindingKind.BOUND_INSTANCE;
 import static dagger.model.BindingKind.COMPONENT;
@@ -52,11 +52,11 @@
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
 import dagger.Module;
-import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-import dagger.internal.codegen.ProductionBinding.ProductionKind;
 import dagger.internal.codegen.base.ContributionType;
 import dagger.internal.codegen.base.MapType;
 import dagger.internal.codegen.base.SetType;
+import dagger.internal.codegen.binding.MembersInjectionBinding.InjectionSite;
+import dagger.internal.codegen.binding.ProductionBinding.ProductionKind;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.DependencyRequest;
@@ -77,7 +77,7 @@
 import javax.lang.model.type.TypeMirror;
 
 /** A factory for {@link Binding} objects. */
-final class BindingFactory {
+public final class BindingFactory {
   private final DaggerTypes types;
   private final KeyFactory keyFactory;
   private final DependencyRequestFactory dependencyRequestFactory;
@@ -106,7 +106,7 @@
    *     binding should be for the parameterized type
    */
   // TODO(dpb): See if we can just pass the parameterized type and not also the constructor.
-  ProvisionBinding injectionBinding(
+  public ProvisionBinding injectionBinding(
       ExecutableElement constructorElement, Optional<TypeMirror> resolvedType) {
     checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
     checkArgument(isAnnotationPresent(constructorElement, Inject.class));
@@ -156,7 +156,7 @@ ProvisionBinding injectionBinding(
    *
    * @param contributedBy the installed module that declares or inherits the method
    */
-  ProvisionBinding providesMethodBinding(
+  public ProvisionBinding providesMethodBinding(
       ExecutableElement providesMethod, TypeElement contributedBy) {
     return setMethodBindingProperties(
             ProvisionBinding.builder(),
@@ -176,7 +176,7 @@ ProvisionBinding providesMethodBinding(
    *
    * @param contributedBy the installed module that declares or inherits the method
    */
-  ProductionBinding producesMethodBinding(
+  public ProductionBinding producesMethodBinding(
       ExecutableElement producesMethod, TypeElement contributedBy) {
     // TODO(beder): Add nullability checking with Java 8.
     ProductionBinding.Builder builder =
@@ -226,7 +226,7 @@ B setMethodBindingProperties(
    *
    * @param key a key that may be satisfied by a multibinding
    */
-  ContributionBinding syntheticMultibinding(
+  public ContributionBinding syntheticMultibinding(
       Key key, Iterable<ContributionBinding> multibindingContributions) {
     ContributionBinding.Builder<?, ?> builder =
         multibindingRequiresProduction(key, multibindingContributions)
@@ -256,7 +256,7 @@ private boolean multibindingRequiresProduction(
   }
 
   /** Returns a {@link dagger.model.BindingKind#COMPONENT} binding for the component. */
-  ProvisionBinding componentBinding(TypeElement componentDefinitionType) {
+  public ProvisionBinding componentBinding(TypeElement componentDefinitionType) {
     checkNotNull(componentDefinitionType);
     return ProvisionBinding.builder()
         .contributionType(ContributionType.UNIQUE)
@@ -270,7 +270,7 @@ ProvisionBinding componentBinding(TypeElement componentDefinitionType) {
    * Returns a {@link dagger.model.BindingKind#COMPONENT_DEPENDENCY} binding for a component's
    * dependency.
    */
-  ProvisionBinding componentDependencyBinding(ComponentRequirement dependency) {
+  public ProvisionBinding componentDependencyBinding(ComponentRequirement dependency) {
     checkNotNull(dependency);
     return ProvisionBinding.builder()
         .contributionType(ContributionType.UNIQUE)
@@ -288,7 +288,7 @@ ProvisionBinding componentDependencyBinding(ComponentRequirement dependency) {
    * @param componentDescriptor the component with the dependency, not the dependency that has the
    *     method
    */
-  ContributionBinding componentDependencyMethodBinding(
+  public ContributionBinding componentDependencyMethodBinding(
       ComponentDescriptor componentDescriptor, ExecutableElement dependencyMethod) {
     checkArgument(dependencyMethod.getKind().equals(METHOD));
     checkArgument(dependencyMethod.getParameters().isEmpty());
@@ -402,7 +402,7 @@ ContributionBinding delegateBinding(
    * Returns a {@link dagger.model.BindingKind#DELEGATE} binding used when there is no binding that
    * satisfies the {@code @Binds} declaration.
    */
-  ContributionBinding unresolvedDelegateBinding(DelegateDeclaration delegateDeclaration) {
+  public ContributionBinding unresolvedDelegateBinding(DelegateDeclaration delegateDeclaration) {
     return buildDelegateBinding(
         ProvisionBinding.builder().scope(uniqueScopeOf(delegateDeclaration.bindingElement().get())),
         delegateDeclaration,
@@ -456,7 +456,7 @@ ContributionBinding syntheticOptionalBinding(
   }
 
   /** Returns a {@link dagger.model.BindingKind#MEMBERS_INJECTOR} binding. */
-  ProvisionBinding membersInjectorBinding(
+  public ProvisionBinding membersInjectorBinding(
       Key key, MembersInjectionBinding membersInjectionBinding) {
     return ProvisionBinding.builder()
         .key(key)
@@ -475,7 +475,7 @@ ProvisionBinding membersInjectorBinding(
    *     parameterization of that type, the returned binding will be for the resolved type
    */
   // TODO(dpb): See if we can just pass one nongeneric/parameterized type.
-  MembersInjectionBinding membersInjectionBinding(
+  public MembersInjectionBinding membersInjectionBinding(
       DeclaredType declaredType, Optional<TypeMirror> resolvedType) {
     // If the class this is injecting has some type arguments, resolve everything.
     if (!declaredType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/binding/BindingGraph.java
similarity index 90%
rename from java/dagger/internal/codegen/BindingGraph.java
rename to java/dagger/internal/codegen/binding/BindingGraph.java
index f1af8313e..33a5c8f9a 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/binding/BindingGraph.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.extension.DaggerStreams.presentValues;
@@ -45,21 +45,21 @@
 
 /** The canonical representation of a full-resolved graph. */
 @AutoValue
-abstract class BindingGraph {
-  abstract ComponentDescriptor componentDescriptor();
+public abstract class BindingGraph {
+  public abstract ComponentDescriptor componentDescriptor();
 
   /**
    * The resolved bindings for all {@link ContributionBinding}s in this graph, keyed by {@link Key}.
    */
   // TODO(ronshapiro): when MembersInjectionBinding no longer extends Binding, rename this to
   // bindings()
-  abstract ImmutableMap<Key, ResolvedBindings> contributionBindings();
+  public abstract ImmutableMap<Key, ResolvedBindings> contributionBindings();
 
   /**
    * The resolved bindings for all {@link MembersInjectionBinding}s in this graph, keyed by {@link
    * Key}.
    */
-  abstract ImmutableMap<Key, ResolvedBindings> membersInjectionBindings();
+  public abstract ImmutableMap<Key, ResolvedBindings> membersInjectionBindings();
 
   /**
    * Returns the {@link ResolvedBindings resolved bindings} instance for {@code
@@ -68,13 +68,13 @@
    * be returned, otherwise a {@link ResolvedBindings} with {@link #contributionBindings()} will be
    * returned.
    */
-  final ResolvedBindings resolvedBindings(BindingRequest request) {
+  public final ResolvedBindings resolvedBindings(BindingRequest request) {
     return request.isRequestKind(RequestKind.MEMBERS_INJECTION)
         ? membersInjectionBindings().get(request.key())
         : contributionBindings().get(request.key());
   }
 
-  final Iterable<ResolvedBindings> resolvedBindings() {
+  public final Iterable<ResolvedBindings> resolvedBindings() {
     // Don't return an immutable collection - this is only ever used for looping over all bindings
     // in the graph. Copying is wasteful, especially if is a hashing collection, since the values
     // should all, by definition, be distinct.
@@ -82,14 +82,14 @@ final ResolvedBindings resolvedBindings(BindingRequest request) {
     return Iterables.concat(membersInjectionBindings().values(), contributionBindings().values());
   }
 
-  abstract ImmutableList<BindingGraph> subgraphs();
+  public abstract ImmutableList<BindingGraph> subgraphs();
 
   /**
    * The type that defines the component for this graph.
    *
    * @see ComponentDescriptor#typeElement()
    */
-  TypeElement componentTypeElement() {
+  public TypeElement componentTypeElement() {
     return componentDescriptor().typeElement();
   }
 
@@ -104,7 +104,7 @@ TypeElement componentTypeElement() {
   abstract ImmutableSet<ModuleDescriptor> ownedModules();
 
   @Memoized
-  ImmutableSet<TypeElement> ownedModuleTypes() {
+  public ImmutableSet<TypeElement> ownedModuleTypes() {
     return FluentIterable.from(ownedModules()).transform(ModuleDescriptor::moduleElement).toSet();
   }
 
@@ -124,7 +124,7 @@ TypeElement componentTypeElement() {
    * </code></pre>
    */
   // TODO(b/73294201): Consider returning the resolved ExecutableType for the factory method.
-  abstract Optional<ExecutableElement> factoryMethod();
+  public abstract Optional<ExecutableElement> factoryMethod();
 
   /**
    * Returns a map between the {@linkplain ComponentRequirement component requirement} and the
@@ -132,7 +132,7 @@ TypeElement componentTypeElement() {
    * BindingGraph#factoryMethod factory method}.
    */
   // TODO(dpb): Consider disallowing modules if none of their bindings are used.
-  ImmutableMap<ComponentRequirement, VariableElement> factoryMethodParameters() {
+  public ImmutableMap<ComponentRequirement, VariableElement> factoryMethodParameters() {
     checkState(factoryMethod().isPresent());
     ImmutableMap.Builder<ComponentRequirement, VariableElement> builder = ImmutableMap.builder();
     for (VariableElement parameter : factoryMethod().get().getParameters()) {
@@ -155,7 +155,7 @@ TypeElement componentTypeElement() {
    * </ul>
    */
   @Memoized
-  ImmutableSet<ComponentRequirement> componentRequirements() {
+  public ImmutableSet<ComponentRequirement> componentRequirements() {
     ImmutableSet<TypeElement> requiredModules = requiredModuleElements();
     ImmutableSet.Builder<ComponentRequirement> requirements = ImmutableSet.builder();
     componentDescriptor().requirements().stream()
@@ -182,7 +182,7 @@ TypeElement componentTypeElement() {
   }
 
   /** Returns the {@link ComponentDescriptor}s for this component and its subcomponents. */
-  ImmutableSet<ComponentDescriptor> componentDescriptors() {
+  public ImmutableSet<ComponentDescriptor> componentDescriptors() {
     return FluentIterable.from(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this))
         .transform(BindingGraph::componentDescriptor)
         .toSet();
@@ -201,7 +201,7 @@ TypeElement componentTypeElement() {
   @Override // Suppresses ErrorProne warning that hashCode was overridden w/o equals
   public abstract boolean equals(Object other);
 
-  static BindingGraph create(
+  public static BindingGraph create(
       ComponentDescriptor componentDescriptor,
       Map<Key, ResolvedBindings> resolvedContributionBindingsMap,
       Map<Key, ResolvedBindings> resolvedMembersInjectionBindings,
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/binding/BindingGraphConverter.java
similarity index 96%
rename from java/dagger/internal/codegen/BindingGraphConverter.java
rename to java/dagger/internal/codegen/binding/BindingGraphConverter.java
index e9741e318..571f900be 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/binding/BindingGraphConverter.java
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreTypes.asTypeElement;
-import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.binding.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.extension.DaggerGraphs.unreachableNodes;
 import static dagger.model.BindingKind.SUBCOMPONENT_CREATOR;
 
@@ -38,8 +38,8 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
-/** Converts {@link dagger.internal.codegen.BindingGraph}s to {@link dagger.model.BindingGraph}s. */
-final class BindingGraphConverter {
+/** Converts {@link BindingGraph}s to {@link dagger.model.BindingGraph}s. */
+public final class BindingGraphConverter {
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
 
   @Inject
@@ -49,9 +49,9 @@
 
   /**
    * Creates the external {@link dagger.model.BindingGraph} representing the given internal {@link
-   * dagger.internal.codegen.BindingGraph}.
+   * BindingGraph}.
    */
-  dagger.model.BindingGraph convert(BindingGraph bindingGraph) {
+  public dagger.model.BindingGraph convert(BindingGraph bindingGraph) {
     Traverser traverser = new Traverser(bindingGraph);
     traverser.traverseComponents();
 
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/binding/BindingGraphFactory.java
similarity index 98%
rename from java/dagger/internal/codegen/BindingGraphFactory.java
rename to java/dagger/internal/codegen/binding/BindingGraphFactory.java
index 506157bbd..e9cacbe63 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/binding/BindingGraphFactory.java
@@ -14,17 +14,17 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreTypes.isType;
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.isEmpty;
-import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
-import static dagger.internal.codegen.SourceFiles.generatedMonitoringModuleName;
 import static dagger.internal.codegen.base.RequestKinds.getRequestKind;
 import static dagger.internal.codegen.base.Util.reentrantComputeIfAbsent;
+import static dagger.internal.codegen.binding.ComponentDescriptor.isComponentContributionMethod;
+import static dagger.internal.codegen.binding.SourceFiles.generatedMonitoringModuleName;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableSet;
 import static dagger.model.BindingKind.DELEGATE;
 import static dagger.model.BindingKind.INJECTION;
@@ -75,7 +75,7 @@
 
 /** A factory for {@link BindingGraph} objects. */
 @Singleton
-final class BindingGraphFactory implements ClearableCache {
+public final class BindingGraphFactory implements ClearableCache {
   private final DaggerElements elements;
   private final InjectBindingRegistry injectBindingRegistry;
   private final KeyFactory keyFactory;
@@ -103,7 +103,8 @@
    * @param createFullBindingGraph if {@code true}, the binding graph will include all bindings;
    *     otherwise it will include only bindings reachable from at least one entry point
    */
-  BindingGraph create(ComponentDescriptor componentDescriptor, boolean createFullBindingGraph) {
+  public BindingGraph create(
+      ComponentDescriptor componentDescriptor, boolean createFullBindingGraph) {
     return create(Optional.empty(), componentDescriptor, createFullBindingGraph);
   }
 
@@ -253,7 +254,7 @@ private boolean shouldIncludeImplicitProductionModules(
 
   /**
    * Returns a descriptor for a generated module that handles monitoring for production components.
-   * This module is generated in the {@link MonitoringModuleProcessingStep}.
+   * This module is generated in the {@link dagger.internal.codegen.MonitoringModuleProcessingStep}.
    *
    * @throws TypeNotPresentException if the module has not been generated yet. This will cause the
    *     processor to retry in a later processing round.
@@ -942,7 +943,7 @@ private void resolveDependencies(ResolvedBindings resolvedBindings) {
        *
        * @throws IllegalArgumentException if {@link #getPreviouslyResolvedBindings(Key)} is empty
        */
-      boolean dependsOnLocalBindings(Key key) {
+      private boolean dependsOnLocalBindings(Key key) {
         // Don't recur infinitely if there are valid cycles in the dependency graph.
         // http://b/23032377
         if (!cycleChecker.add(key)) {
@@ -952,6 +953,23 @@ boolean dependsOnLocalBindings(Key key) {
             keyDependsOnLocalBindingsCache, key, this::dependsOnLocalBindingsUncached);
       }
 
+      /**
+       * Returns {@code true} if {@code binding} is unscoped (or has {@link Reusable @Reusable}
+       * scope) and depends on multibindings with contributions declared within this component's
+       * modules, or if any of its unscoped or {@link Reusable @Reusable} scoped dependencies depend
+       * on such local multibindings.
+       *
+       * <p>We don't care about non-reusable scoped dependencies because they will never depend on
+       * multibindings with contributions from subcomponents.
+       */
+      private boolean dependsOnLocalBindings(Binding binding) {
+        if (!cycleChecker.add(binding)) {
+          return false;
+        }
+        return reentrantComputeIfAbsent(
+            bindingDependsOnLocalBindingsCache, binding, this::dependsOnLocalBindingsUncached);
+      }
+
       private boolean dependsOnLocalBindingsUncached(Key key) {
         checkArgument(
             getPreviouslyResolvedBindings(key).isPresent(),
@@ -972,23 +990,6 @@ private boolean dependsOnLocalBindingsUncached(Key key) {
         return false;
       }
 
-      /**
-       * Returns {@code true} if {@code binding} is unscoped (or has {@link Reusable @Reusable}
-       * scope) and depends on multibindings with contributions declared within this component's
-       * modules, or if any of its unscoped or {@link Reusable @Reusable} scoped dependencies depend
-       * on such local multibindings.
-       *
-       * <p>We don't care about non-reusable scoped dependencies because they will never depend on
-       * multibindings with contributions from subcomponents.
-       */
-      boolean dependsOnLocalBindings(Binding binding) {
-        if (!cycleChecker.add(binding)) {
-          return false;
-        }
-        return reentrantComputeIfAbsent(
-            bindingDependsOnLocalBindingsCache, binding, this::dependsOnLocalBindingsUncached);
-      }
-
       private boolean dependsOnLocalBindingsUncached(Binding binding) {
         if ((!binding.scope().isPresent() || binding.scope().get().isReusable())
             // TODO(beder): Figure out what happens with production subcomponents.
diff --git a/java/dagger/internal/codegen/BindingNode.java b/java/dagger/internal/codegen/binding/BindingNode.java
similarity index 89%
rename from java/dagger/internal/codegen/BindingNode.java
rename to java/dagger/internal/codegen/binding/BindingNode.java
index a7da0920c..e3ef61f0d 100644
--- a/java/dagger/internal/codegen/BindingNode.java
+++ b/java/dagger/internal/codegen/binding/BindingNode.java
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.BindingType.PRODUCTION;
+import static dagger.internal.codegen.binding.BindingType.PRODUCTION;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableSet;
@@ -38,11 +38,12 @@
  * An implementation of {@link dagger.model.Binding} that also exposes {@link BindingDeclaration}s
  * associated with the binding.
  */
-// TODO(dpb): Consider a supertype of dagger.model.Binding that dagger.internal.codegen.Binding
+// TODO(dpb): Consider a supertype of dagger.model.Binding that
+// dagger.internal.codegen.binding.Binding
 // could also implement.
 @AutoValue
-abstract class BindingNode implements dagger.model.Binding {
-  static BindingNode create(
+public abstract class BindingNode implements dagger.model.Binding {
+  public static BindingNode create(
       ComponentPath component,
       Binding delegate,
       ImmutableSet<MultibindingDeclaration> multibindingDeclarations,
@@ -62,7 +63,7 @@ static BindingNode create(
 
   private BindingDeclarationFormatter bindingDeclarationFormatter;
 
-  abstract Binding delegate();
+  public abstract Binding delegate();
 
   abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
 
@@ -80,7 +81,7 @@ static BindingNode create(
    *   <li>{@linkplain Multibinds multibinding} declarations
    * </ul>
    */
-  final Iterable<BindingDeclaration> associatedDeclarations() {
+  public final Iterable<BindingDeclaration> associatedDeclarations() {
     return Iterables.concat(
         multibindingDeclarations(), optionalBindingDeclarations(), subcomponentDeclarations());
   }
diff --git a/java/dagger/internal/codegen/BindingRequest.java b/java/dagger/internal/codegen/binding/BindingRequest.java
similarity index 83%
rename from java/dagger/internal/codegen/BindingRequest.java
rename to java/dagger/internal/codegen/binding/BindingRequest.java
index 52e398e5d..d61d9cfba 100644
--- a/java/dagger/internal/codegen/BindingRequest.java
+++ b/java/dagger/internal/codegen/binding/BindingRequest.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static dagger.internal.codegen.base.RequestKinds.requestType;
 
@@ -32,9 +32,9 @@
  * instance ({@link FrameworkType}).
  */
 @AutoValue
-abstract class BindingRequest {
+public abstract class BindingRequest {
   /** Creates a {@link BindingRequest} for the given {@link DependencyRequest}. */
-  static BindingRequest bindingRequest(DependencyRequest dependencyRequest) {
+  public static BindingRequest bindingRequest(DependencyRequest dependencyRequest) {
     return bindingRequest(dependencyRequest.key(), dependencyRequest.kind());
   }
 
@@ -42,7 +42,7 @@ static BindingRequest bindingRequest(DependencyRequest dependencyRequest) {
    * Creates a {@link BindingRequest} for a normal dependency request for the given {@link Key} and
    * {@link RequestKind}.
    */
-  static BindingRequest bindingRequest(Key key, RequestKind requestKind) {
+  public static BindingRequest bindingRequest(Key key, RequestKind requestKind) {
     // When there's a request that has a 1:1 mapping to a FrameworkType, the request should be
     // associated with that FrameworkType as well, because we want to ensure that if a request
     // comes in for that as a dependency first and as a framework instance later, they resolve to
@@ -59,26 +59,26 @@ static BindingRequest bindingRequest(Key key, RequestKind requestKind) {
    * Creates a {@link BindingRequest} for a request for a framework instance for the given {@link
    * Key} with the given {@link FrameworkType}.
    */
-  static BindingRequest bindingRequest(Key key, FrameworkType frameworkType) {
+  public static BindingRequest bindingRequest(Key key, FrameworkType frameworkType) {
     return new AutoValue_BindingRequest(
         key, frameworkType.requestKind(), Optional.of(frameworkType));
   }
 
   /** Returns the {@link Key} for the requested binding. */
-  abstract Key key();
+  public abstract Key key();
 
   /** Returns the request kind associated with this request, if any. */
-  abstract Optional<RequestKind> requestKind();
+  public abstract Optional<RequestKind> requestKind();
 
   /** Returns the framework type associated with this request, if any. */
-  abstract Optional<FrameworkType> frameworkType();
+  public abstract Optional<FrameworkType> frameworkType();
 
   /** Returns whether this request is of the given kind. */
-  final boolean isRequestKind(RequestKind requestKind) {
+  public final boolean isRequestKind(RequestKind requestKind) {
     return requestKind.equals(requestKind().orElse(null));
   }
 
-  final TypeMirror requestedType(TypeMirror contributedType, DaggerTypes types) {
+  public final TypeMirror requestedType(TypeMirror contributedType, DaggerTypes types) {
     if (requestKind().isPresent()) {
       return requestType(requestKind().get(), contributedType, types);
     }
@@ -86,7 +86,7 @@ final TypeMirror requestedType(TypeMirror contributedType, DaggerTypes types) {
   }
 
   /** Returns a name that can be used for the kind of request this is. */
-  final String kindName() {
+  public final String kindName() {
     Object requestKindObject =
         requestKind().isPresent()
             ? requestKind().get()
diff --git a/java/dagger/internal/codegen/BindingType.java b/java/dagger/internal/codegen/binding/BindingType.java
similarity index 93%
rename from java/dagger/internal/codegen/BindingType.java
rename to java/dagger/internal/codegen/binding/BindingType.java
index 37109c73b..7f5ea54df 100644
--- a/java/dagger/internal/codegen/BindingType.java
+++ b/java/dagger/internal/codegen/binding/BindingType.java
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import dagger.MembersInjector;
 
 /** Whether a binding or declaration is for provision, production, or a {@link MembersInjector}. */
-enum BindingType {
+public enum BindingType {
   /** A binding with this type is a {@link ProvisionBinding}. */
   PROVISION,
 
diff --git a/java/dagger/internal/codegen/BindsTypeChecker.java b/java/dagger/internal/codegen/binding/BindsTypeChecker.java
similarity index 87%
rename from java/dagger/internal/codegen/BindsTypeChecker.java
rename to java/dagger/internal/codegen/binding/BindsTypeChecker.java
index e69c1fd13..bed5521f1 100644
--- a/java/dagger/internal/codegen/BindsTypeChecker.java
+++ b/java/dagger/internal/codegen/binding/BindsTypeChecker.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 
@@ -34,16 +34,18 @@
 
 /**
  * Checks the assignability of one type to another, given a {@link ContributionType} context. This
- * is used by {@link BindsMethodValidator} to validate that the right-hand-side of a {@link
- * dagger.Binds} method is valid, as well as in {@link DelegateBindingExpression} when the
- * right-hand-side in generated code might be an erased type due to accessibility.
+ * is used by {@link dagger.internal.codegen.BindsMethodValidator} to validate that the right-hand-
+ * side of a {@link dagger.Binds} method is valid, as well as in {@link
+ * dagger.internal.codegen.DelegateBindingExpression} when the right-hand-side in generated code
+ * might be an erased type due to accessibility.
  */
-final class BindsTypeChecker {
+public final class BindsTypeChecker {
   private final DaggerTypes types;
   private final DaggerElements elements;
 
+  // TODO(user): Make this pkg-private. Used by DelegateBindingExpression.
   @Inject
-  BindsTypeChecker(DaggerTypes types, DaggerElements elements) {
+  public BindsTypeChecker(DaggerTypes types, DaggerElements elements) {
     this.types = types;
     this.elements = elements;
   }
@@ -52,7 +54,7 @@
    * Checks the assignability of {@code rightHandSide} to {@code leftHandSide} given a {@link
    * ContributionType} context.
    */
-  boolean isAssignable(
+  public boolean isAssignable(
       TypeMirror rightHandSide, TypeMirror leftHandSide, ContributionType contributionType) {
     return types.isAssignable(rightHandSide, desiredAssignableType(leftHandSide, contributionType));
   }
diff --git a/java/dagger/internal/codegen/ChildFactoryMethodEdgeImpl.java b/java/dagger/internal/codegen/binding/ChildFactoryMethodEdgeImpl.java
similarity index 90%
rename from java/dagger/internal/codegen/ChildFactoryMethodEdgeImpl.java
rename to java/dagger/internal/codegen/binding/ChildFactoryMethodEdgeImpl.java
index b4dc5c3ea..c0565881a 100644
--- a/java/dagger/internal/codegen/ChildFactoryMethodEdgeImpl.java
+++ b/java/dagger/internal/codegen/binding/ChildFactoryMethodEdgeImpl.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static dagger.internal.codegen.base.ElementFormatter.elementToString;
 
@@ -22,7 +22,7 @@
 import javax.lang.model.element.ExecutableElement;
 
 /** An implementation of {@link ChildFactoryMethodEdge}. */
-final class ChildFactoryMethodEdgeImpl implements ChildFactoryMethodEdge {
+public final class ChildFactoryMethodEdgeImpl implements ChildFactoryMethodEdge {
 
   private final ExecutableElement factoryMethod;
 
diff --git a/java/dagger/internal/codegen/ComponentCreatorAnnotation.java b/java/dagger/internal/codegen/binding/ComponentCreatorAnnotation.java
similarity index 84%
rename from java/dagger/internal/codegen/ComponentCreatorAnnotation.java
rename to java/dagger/internal/codegen/binding/ComponentCreatorAnnotation.java
index a45cf50bf..545f30557 100644
--- a/java/dagger/internal/codegen/ComponentCreatorAnnotation.java
+++ b/java/dagger/internal/codegen/binding/ComponentCreatorAnnotation.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Ascii.toUpperCase;
@@ -34,7 +34,7 @@
 import javax.lang.model.element.TypeElement;
 
 /** Simple representation of a component creator annotation type. */
-enum ComponentCreatorAnnotation {
+public enum ComponentCreatorAnnotation {
   COMPONENT_BUILDER(Component.Builder.class),
   COMPONENT_FACTORY(Component.Factory.class),
   SUBCOMPONENT_BUILDER(Subcomponent.Builder.class),
@@ -56,30 +56,30 @@
   }
 
   /** The actual annotation type. */
-  Class<? extends Annotation> annotation() {
+  public Class<? extends Annotation> annotation() {
     return annotation;
   }
 
   /** The component annotation type that encloses this creator annotation type. */
-  final Class<? extends Annotation> componentAnnotation() {
+  public final Class<? extends Annotation> componentAnnotation() {
     return componentAnnotation;
   }
 
   /** Returns {@code true} if the creator annotation is for a subcomponent. */
-  final boolean isSubcomponentCreatorAnnotation() {
+  public final boolean isSubcomponentCreatorAnnotation() {
     return componentAnnotation().getSimpleName().endsWith("Subcomponent");
   }
 
   /**
    * Returns {@code true} if the creator annotation is for a production component or subcomponent.
    */
-  final boolean isProductionCreatorAnnotation() {
+  public final boolean isProductionCreatorAnnotation() {
     return componentAnnotation().getSimpleName().startsWith("Production");
   }
 
   /** The creator kind the annotation is associated with. */
   // TODO(dpb): Remove ComponentCreatorKind.
-  ComponentCreatorKind creatorKind() {
+  public ComponentCreatorKind creatorKind() {
     return creatorKind;
   }
 
@@ -89,12 +89,12 @@ public final String toString() {
   }
 
   /** Returns all component creator annotations. */
-  static ImmutableSet<Class<? extends Annotation>> allCreatorAnnotations() {
+  public static ImmutableSet<Class<? extends Annotation>> allCreatorAnnotations() {
     return stream().collect(toAnnotationClasses());
   }
 
   /** Returns all root component creator annotations. */
-  static ImmutableSet<Class<? extends Annotation>> rootComponentCreatorAnnotations() {
+  public static ImmutableSet<Class<? extends Annotation>> rootComponentCreatorAnnotations() {
     return stream()
         .filter(
             componentCreatorAnnotation ->
@@ -103,7 +103,7 @@ public final String toString() {
   }
 
   /** Returns all subcomponent creator annotations. */
-  static ImmutableSet<Class<? extends Annotation>> subcomponentCreatorAnnotations() {
+  public static ImmutableSet<Class<? extends Annotation>> subcomponentCreatorAnnotations() {
     return stream()
         .filter(
             componentCreatorAnnotation ->
@@ -112,7 +112,7 @@ public final String toString() {
   }
 
   /** Returns all production component creator annotations. */
-  static ImmutableSet<Class<? extends Annotation>> productionCreatorAnnotations() {
+  public static ImmutableSet<Class<? extends Annotation>> productionCreatorAnnotations() {
     return stream()
         .filter(
             componentCreatorAnnotation ->
@@ -121,7 +121,7 @@ public final String toString() {
   }
 
   /** Returns the legal creator annotations for the given {@code componentAnnotation}. */
-  static ImmutableSet<Class<? extends Annotation>> creatorAnnotationsFor(
+  public static ImmutableSet<Class<? extends Annotation>> creatorAnnotationsFor(
       ComponentAnnotation componentAnnotation) {
     return stream()
         .filter(
@@ -134,7 +134,7 @@ public final String toString() {
   }
 
   /** Returns all creator annotations present on the given {@code type}. */
-  static ImmutableSet<ComponentCreatorAnnotation> getCreatorAnnotations(TypeElement type) {
+  public static ImmutableSet<ComponentCreatorAnnotation> getCreatorAnnotations(TypeElement type) {
     return stream()
         .filter(cca -> isAnnotationPresent(type, cca.annotation()))
         .collect(toImmutableSet());
diff --git a/java/dagger/internal/codegen/ComponentCreatorDescriptor.java b/java/dagger/internal/codegen/binding/ComponentCreatorDescriptor.java
similarity index 91%
rename from java/dagger/internal/codegen/ComponentCreatorDescriptor.java
rename to java/dagger/internal/codegen/binding/ComponentCreatorDescriptor.java
index 79861b2bf..5ea30ed42 100644
--- a/java/dagger/internal/codegen/ComponentCreatorDescriptor.java
+++ b/java/dagger/internal/codegen/binding/ComponentCreatorDescriptor.java
@@ -14,14 +14,14 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asTypeElement;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.getCreatorAnnotations;
 import static dagger.internal.codegen.base.ModuleAnnotation.moduleAnnotation;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.getCreatorAnnotations;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableSet;
 
 import com.google.auto.common.MoreTypes;
@@ -50,21 +50,21 @@
  * {@code @Component.Builder} (or one of the corresponding production or subcomponent versions).
  */
 @AutoValue
-abstract class ComponentCreatorDescriptor {
+public abstract class ComponentCreatorDescriptor {
 
   /** Returns the annotation marking this creator. */
-  abstract ComponentCreatorAnnotation annotation();
+  public abstract ComponentCreatorAnnotation annotation();
 
   /** The kind of this creator. */
-  final ComponentCreatorKind kind() {
+  public final ComponentCreatorKind kind() {
     return annotation().creatorKind();
   }
 
   /** The annotated creator type. */
-  abstract TypeElement typeElement();
+  public abstract TypeElement typeElement();
 
   /** The method that creates and returns a component instance. */
-  abstract ExecutableElement factoryMethod();
+  public abstract ExecutableElement factoryMethod();
 
   /**
    * Multimap of component requirements to setter methods that set that requirement.
@@ -90,7 +90,8 @@ final ComponentCreatorKind kind() {
    * <p>In a valid creator, there will be exactly one element per component requirement, so this
    * method should only be called when validating the descriptor.
    */
-  final ImmutableSetMultimap<ComponentRequirement, Element> unvalidatedRequirementElements() {
+  public final ImmutableSetMultimap<ComponentRequirement, Element>
+      unvalidatedRequirementElements() {
     // ComponentCreatorValidator ensures that there are either setter methods or factory method
     // parameters, but not both, so we can cheat a little here since we know that only one of
     // the two multimaps will be non-empty.
@@ -111,13 +112,13 @@ final ComponentCreatorKind kind() {
 
   /** Map of component requirements to setter methods for those requirements. */
   @Memoized
-  ImmutableMap<ComponentRequirement, ExecutableElement> setterMethods() {
+  public ImmutableMap<ComponentRequirement, ExecutableElement> setterMethods() {
     return flatten(unvalidatedSetterMethods());
   }
 
   /** Map of component requirements to factory method parameters for those requirements. */
   @Memoized
-  ImmutableMap<ComponentRequirement, VariableElement> factoryParameters() {
+  public ImmutableMap<ComponentRequirement, VariableElement> factoryParameters() {
     return flatten(unvalidatedFactoryParameters());
   }
 
@@ -127,13 +128,13 @@ final ComponentCreatorKind kind() {
   }
 
   /** Returns the set of component requirements this creator allows the user to set. */
-  final ImmutableSet<ComponentRequirement> userSettableRequirements() {
+  public final ImmutableSet<ComponentRequirement> userSettableRequirements() {
     // Note: they should have been validated at the point this is used, so this set is valid.
     return unvalidatedRequirementElements().keySet();
   }
 
   /** Returns the set of requirements for modules and component dependencies for this creator. */
-  final ImmutableSet<ComponentRequirement> moduleAndDependencyRequirements() {
+  public final ImmutableSet<ComponentRequirement> moduleAndDependencyRequirements() {
     return userSettableRequirements().stream()
         .filter(requirement -> !requirement.isBoundInstance())
         .collect(toImmutableSet());
@@ -152,7 +153,7 @@ final Element elementForRequirement(ComponentRequirement requirement) {
   }
 
   /** Creates a new {@link ComponentCreatorDescriptor} for the given creator {@code type}. */
-  static ComponentCreatorDescriptor create(
+  public static ComponentCreatorDescriptor create(
       DeclaredType type,
       DaggerElements elements,
       DaggerTypes types,
diff --git a/java/dagger/internal/codegen/ComponentCreatorKind.java b/java/dagger/internal/codegen/binding/ComponentCreatorKind.java
similarity index 90%
rename from java/dagger/internal/codegen/ComponentCreatorKind.java
rename to java/dagger/internal/codegen/binding/ComponentCreatorKind.java
index dc203de2a..b2581d685 100644
--- a/java/dagger/internal/codegen/ComponentCreatorKind.java
+++ b/java/dagger/internal/codegen/binding/ComponentCreatorKind.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
@@ -22,7 +22,7 @@
 import com.google.common.base.Ascii;
 
 /** Enumeration of the different kinds of component creators. */
-enum ComponentCreatorKind {
+public enum ComponentCreatorKind {
   /** {@code @Component.Builder} or one of its subcomponent/production variants. */
   BUILDER,
 
@@ -31,12 +31,12 @@
   ;
 
   /** Name to use as (or as part of) a type name for a creator of this kind. */
-  String typeName() {
+  public String typeName() {
     return UPPER_UNDERSCORE.to(UPPER_CAMEL, name());
   }
 
   /** Name to use for a component's static method returning a creator of this kind. */
-  String methodName() {
+  public String methodName() {
     return Ascii.toLowerCase(name());
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/binding/ComponentDescriptor.java
similarity index 87%
rename from java/dagger/internal/codegen/ComponentDescriptor.java
rename to java/dagger/internal/codegen/binding/ComponentDescriptor.java
index 080f7cb92..a7e4cc4f3 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/binding/ComponentDescriptor.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -64,12 +64,12 @@
  * the module.
  */
 @AutoValue
-abstract class ComponentDescriptor {
+public abstract class ComponentDescriptor {
   /** The annotation that specifies that {@link #typeElement()} is a component. */
-  abstract ComponentAnnotation annotation();
+  public abstract ComponentAnnotation annotation();
 
   /** Returns {@code true} if this is a subcomponent. */
-  final boolean isSubcomponent() {
+  public final boolean isSubcomponent() {
     return annotation().isSubcomponent();
   }
 
@@ -77,7 +77,7 @@ final boolean isSubcomponent() {
    * Returns {@code true} if this is a production component or subcomponent, or a
    * {@code @ProducerModule} when doing module binding validation.
    */
-  final boolean isProduction() {
+  public final boolean isProduction() {
     return annotation().isProduction();
   }
 
@@ -85,7 +85,7 @@ final boolean isProduction() {
    * Returns {@code true} if this is a real component, and not a fictional one used to validate
    * module bindings.
    */
-  final boolean isRealComponent() {
+  public final boolean isRealComponent() {
     return annotation().isRealComponent();
   }
 
@@ -93,16 +93,16 @@ final boolean isRealComponent() {
    * The element that defines the component. This is the element to which the {@link #annotation()}
    * was applied.
    */
-  abstract TypeElement typeElement();
+  public abstract TypeElement typeElement();
 
   /**
    * The set of component dependencies listed in {@link Component#dependencies} or {@link
    * ProductionComponent#dependencies()}.
    */
-  abstract ImmutableSet<ComponentRequirement> dependencies();
+  public abstract ImmutableSet<ComponentRequirement> dependencies();
 
   /** The non-abstract {@link #modules()} and the {@link #dependencies()}. */
-  final ImmutableSet<ComponentRequirement> dependenciesAndConcreteModules() {
+  public final ImmutableSet<ComponentRequirement> dependenciesAndConcreteModules() {
     return Stream.concat(
             moduleTypes().stream()
                 .filter(dep -> !dep.getModifiers().contains(ABSTRACT))
@@ -115,10 +115,10 @@ final boolean isRealComponent() {
    * The {@link ModuleDescriptor modules} declared in {@link Component#modules()} and reachable by
    * traversing {@link Module#includes()}.
    */
-  abstract ImmutableSet<ModuleDescriptor> modules();
+  public abstract ImmutableSet<ModuleDescriptor> modules();
 
   /** The types of the {@link #modules()}. */
-  final ImmutableSet<TypeElement> moduleTypes() {
+  public final ImmutableSet<TypeElement> moduleTypes() {
     return modules().stream().map(ModuleDescriptor::moduleElement).collect(toImmutableSet());
   }
 
@@ -156,20 +156,19 @@ final boolean isRealComponent() {
    * the enclosing type of the method; a method may be declared by a supertype of the actual
    * dependency.
    */
-  abstract ImmutableMap<ExecutableElement, ComponentRequirement> dependenciesByDependencyMethod();
+  public abstract ImmutableMap<ExecutableElement, ComponentRequirement>
+      dependenciesByDependencyMethod();
 
   /** The {@linkplain #dependencies() component dependency} that defines a method. */
-  final ComponentRequirement getDependencyThatDefinesMethod(Element method) {
+  public final ComponentRequirement getDependencyThatDefinesMethod(Element method) {
     checkArgument(
         method instanceof ExecutableElement, "method must be an executable element: %s", method);
     return checkNotNull(
         dependenciesByDependencyMethod().get(method), "no dependency implements %s", method);
   }
 
-  /**
-   * The scopes of the component.
-   */
-  abstract ImmutableSet<Scope> scopes();
+  /** The scopes of the component. */
+  public abstract ImmutableSet<Scope> scopes();
 
   /**
    * All {@link Subcomponent}s which are direct children of this component. This includes
@@ -177,7 +176,7 @@ final ComponentRequirement getDependencyThatDefinesMethod(Element method) {
    * #childComponentsDeclaredByFactoryMethods() factory methods} and {@linkplain
    * #childComponentsDeclaredByBuilderEntryPoints() builder methods}.
    */
-  final ImmutableSet<ComponentDescriptor> childComponents() {
+  public final ImmutableSet<ComponentDescriptor> childComponents() {
     return ImmutableSet.<ComponentDescriptor>builder()
         .addAll(childComponentsDeclaredByFactoryMethods().values())
         .addAll(childComponentsDeclaredByBuilderEntryPoints().values())
@@ -195,12 +194,12 @@ final ComponentRequirement getDependencyThatDefinesMethod(Element method) {
    * All {@linkplain Subcomponent direct child} components that are declared by a subcomponent
    * factory method.
    */
-  abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
+  public abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
       childComponentsDeclaredByFactoryMethods();
 
   /** Returns a map of {@link #childComponents()} indexed by {@link #typeElement()}. */
   @Memoized
-  ImmutableMap<TypeElement, ComponentDescriptor> childComponentsByElement() {
+  public ImmutableMap<TypeElement, ComponentDescriptor> childComponentsByElement() {
     return Maps.uniqueIndex(childComponents(), ComponentDescriptor::typeElement);
   }
 
@@ -237,10 +236,10 @@ final ComponentDescriptor getChildComponentWithBuilderType(TypeElement builderTy
         builderType.getQualifiedName());
   }
 
-  abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
+  public abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
   /** Returns the first component method associated with this binding request, if one exists. */
-  Optional<ComponentMethodDescriptor> firstMatchingComponentMethod(BindingRequest request) {
+  public Optional<ComponentMethodDescriptor> firstMatchingComponentMethod(BindingRequest request) {
     return componentMethods().stream()
         .filter(method -> doesComponentMethodMatch(method, request))
         .findFirst();
@@ -257,7 +256,7 @@ private static boolean doesComponentMethodMatch(
   }
 
   /** The entry point methods on the component type. Each has a {@link DependencyRequest}. */
-  final ImmutableSet<ComponentMethodDescriptor> entryPointMethods() {
+  public final ImmutableSet<ComponentMethodDescriptor> entryPointMethods() {
     return componentMethods()
         .stream()
         .filter(method -> method.dependencyRequest().isPresent())
@@ -267,14 +266,14 @@ private static boolean doesComponentMethodMatch(
   // TODO(gak): Consider making this non-optional and revising the
   // interaction between the spec & generation
   /** Returns a descriptor for the creator type for this component type, if the user defined one. */
-  abstract Optional<ComponentCreatorDescriptor> creatorDescriptor();
+  public abstract Optional<ComponentCreatorDescriptor> creatorDescriptor();
 
   /**
    * Returns {@code true} for components that have a creator, either because the user {@linkplain
    * #creatorDescriptor() specified one} or because it's a top-level component with an implicit
    * builder.
    */
-  final boolean hasCreator() {
+  public final boolean hasCreator() {
     return !isSubcomponent() || creatorDescriptor().isPresent();
   }
 
@@ -282,7 +281,7 @@ final boolean hasCreator() {
    * Returns the {@link CancellationPolicy} for this component, or an empty optional if either the
    * component is not a production component or no {@code CancellationPolicy} annotation is present.
    */
-  final Optional<CancellationPolicy> cancellationPolicy() {
+  public final Optional<CancellationPolicy> cancellationPolicy() {
     return isProduction()
         ? Optional.ofNullable(typeElement().getAnnotation(CancellationPolicy.class))
         : Optional.empty();
@@ -301,25 +300,25 @@ public int hashCode() {
 
   /** A component method. */
   @AutoValue
-  abstract static class ComponentMethodDescriptor {
+  public abstract static class ComponentMethodDescriptor {
     /** The method itself. Note that this may be declared on a supertype of the component. */
-    abstract ExecutableElement methodElement();
+    public abstract ExecutableElement methodElement();
 
     /**
      * The dependency request for production, provision, and subcomponent creator methods. Absent
      * for subcomponent factory methods.
      */
-    abstract Optional<DependencyRequest> dependencyRequest();
+    public abstract Optional<DependencyRequest> dependencyRequest();
 
     /** The subcomponent for subcomponent factory methods and subcomponent creator methods. */
-    abstract Optional<ComponentDescriptor> subcomponent();
+    public abstract Optional<ComponentDescriptor> subcomponent();
 
     /**
      * Returns the return type of {@link #methodElement()} as resolved in the {@link
      * ComponentDescriptor#typeElement() component type}. If there are no type variables in the
      * return type, this is the equivalent of {@code methodElement().getReturnType()}.
      */
-    TypeMirror resolvedReturnType(DaggerTypes types) {
+    public TypeMirror resolvedReturnType(DaggerTypes types) {
       checkState(dependencyRequest().isPresent());
 
       TypeMirror returnType = methodElement().getReturnType();
@@ -331,7 +330,7 @@ TypeMirror resolvedReturnType(DaggerTypes types) {
     }
 
     /** A {@link ComponentMethodDescriptor}builder for a method. */
-    static Builder builder(ExecutableElement method) {
+    public static Builder builder(ExecutableElement method) {
       return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor.Builder()
           .methodElement(method);
     }
@@ -339,7 +338,7 @@ static Builder builder(ExecutableElement method) {
     /** A builder of {@link ComponentMethodDescriptor}s. */
     @AutoValue.Builder
     @CanIgnoreReturnValue
-    interface Builder {
+    public interface Builder {
       /** @see ComponentMethodDescriptor#methodElement() */
       Builder methodElement(ExecutableElement methodElement);
 
diff --git a/java/dagger/internal/codegen/ComponentDescriptorFactory.java b/java/dagger/internal/codegen/binding/ComponentDescriptorFactory.java
similarity index 93%
rename from java/dagger/internal/codegen/ComponentDescriptorFactory.java
rename to java/dagger/internal/codegen/binding/ComponentDescriptorFactory.java
index 873b21b69..4f1954d5d 100644
--- a/java/dagger/internal/codegen/ComponentDescriptorFactory.java
+++ b/java/dagger/internal/codegen/binding/ComponentDescriptorFactory.java
@@ -14,20 +14,20 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreElements.asType;
 import static com.google.auto.common.MoreTypes.asTypeElement;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.creatorAnnotationsFor;
-import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
-import static dagger.internal.codegen.ConfigurationAnnotations.enclosedAnnotatedTypes;
-import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentCreator;
 import static dagger.internal.codegen.base.ComponentAnnotation.subcomponentAnnotation;
 import static dagger.internal.codegen.base.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.base.Scopes.productionScope;
 import static dagger.internal.codegen.base.Scopes.scopesOf;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.creatorAnnotationsFor;
+import static dagger.internal.codegen.binding.ComponentDescriptor.isComponentContributionMethod;
+import static dagger.internal.codegen.binding.ConfigurationAnnotations.enclosedAnnotatedTypes;
+import static dagger.internal.codegen.binding.ConfigurationAnnotations.isSubcomponentCreator;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableSet;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -37,9 +37,9 @@
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.base.ComponentAnnotation;
 import dagger.internal.codegen.base.ModuleAnnotation;
+import dagger.internal.codegen.binding.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.Scope;
@@ -53,7 +53,7 @@
 import javax.lang.model.type.TypeMirror;
 
 /** A factory for {@link ComponentDescriptor}s. */
-final class ComponentDescriptorFactory {
+public final class ComponentDescriptorFactory {
   private final DaggerElements elements;
   private final DaggerTypes types;
   private final DependencyRequestFactory dependencyRequestFactory;
@@ -72,7 +72,7 @@
   }
 
   /** Returns a descriptor for a root component type. */
-  ComponentDescriptor rootComponentDescriptor(TypeElement typeElement) {
+  public ComponentDescriptor rootComponentDescriptor(TypeElement typeElement) {
     return create(
         typeElement,
         checkAnnotation(
@@ -82,7 +82,7 @@ ComponentDescriptor rootComponentDescriptor(TypeElement typeElement) {
   }
 
   /** Returns a descriptor for a subcomponent type. */
-  ComponentDescriptor subcomponentDescriptor(TypeElement typeElement) {
+  public ComponentDescriptor subcomponentDescriptor(TypeElement typeElement) {
     return create(
         typeElement,
         checkAnnotation(
@@ -95,7 +95,7 @@ ComponentDescriptor subcomponentDescriptor(TypeElement typeElement) {
    * Returns a descriptor for a fictional component based on a module type in order to validate its
    * bindings.
    */
-  ComponentDescriptor moduleComponentDescriptor(TypeElement typeElement) {
+  public ComponentDescriptor moduleComponentDescriptor(TypeElement typeElement) {
     return create(
         typeElement,
         ComponentAnnotation.fromModuleAnnotation(
diff --git a/java/dagger/internal/codegen/ComponentKind.java b/java/dagger/internal/codegen/binding/ComponentKind.java
similarity index 87%
rename from java/dagger/internal/codegen/ComponentKind.java
rename to java/dagger/internal/codegen/binding/ComponentKind.java
index 93da0daa7..1cb3d7c1c 100644
--- a/java/dagger/internal/codegen/ComponentKind.java
+++ b/java/dagger/internal/codegen/binding/ComponentKind.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Sets.immutableEnumSet;
@@ -35,7 +35,7 @@
 import javax.lang.model.element.TypeElement;
 
 /** Enumeration of the different kinds of components. */
-enum ComponentKind {
+public enum ComponentKind {
   /** {@code @Component} */
   COMPONENT(Component.class, true, false),
 
@@ -74,22 +74,23 @@
           .collect(toImmutableSet());
 
   /** Returns the set of kinds for root components. */
-  static ImmutableSet<ComponentKind> rootComponentKinds() {
+  public static ImmutableSet<ComponentKind> rootComponentKinds() {
     return ROOT_COMPONENT_KINDS;
   }
 
   /** Returns the set of kinds for subcomponents. */
-  static ImmutableSet<ComponentKind> subcomponentKinds() {
+  public static ImmutableSet<ComponentKind> subcomponentKinds() {
     return SUBCOMPONENT_KINDS;
   }
 
   /** Returns the annotations for components of the given kinds. */
-  static ImmutableSet<Class<? extends Annotation>> annotationsFor(Iterable<ComponentKind> kinds) {
+  public static ImmutableSet<Class<? extends Annotation>> annotationsFor(
+      Iterable<ComponentKind> kinds) {
     return stream(kinds).map(ComponentKind::annotation).collect(toImmutableSet());
   }
 
   /** Returns the set of component kinds the given {@code element} has annotations for. */
-  static ImmutableSet<ComponentKind> getComponentKinds(TypeElement element) {
+  public static ImmutableSet<ComponentKind> getComponentKinds(TypeElement element) {
     return valuesOf(ComponentKind.class)
         .filter(kind -> isAnnotationPresent(element, kind.annotation()))
         .collect(toImmutableSet());
@@ -102,7 +103,7 @@
    * @throws IllegalArgumentException if the element is annotated with more than one of the
    *     annotations
    */
-  static Optional<ComponentKind> forAnnotatedElement(TypeElement element) {
+  public static Optional<ComponentKind> forAnnotatedElement(TypeElement element) {
     ImmutableSet<ComponentKind> kinds = getComponentKinds(element);
     if (kinds.size() > 1) {
       throw new IllegalArgumentException(
@@ -125,19 +126,19 @@
   }
 
   /** Returns the annotation that marks a component of this kind. */
-  Class<? extends Annotation> annotation() {
+  public Class<? extends Annotation> annotation() {
     return annotation;
   }
 
   /** Returns the kinds of modules that can be used with a component of this kind. */
-  ImmutableSet<ModuleKind> legalModuleKinds() {
+  public ImmutableSet<ModuleKind> legalModuleKinds() {
     return isProducer()
         ? immutableEnumSet(allOf(ModuleKind.class))
         : immutableEnumSet(ModuleKind.MODULE);
   }
 
   /** Returns the kinds of subcomponents a component of this kind can have. */
-  ImmutableSet<ComponentKind> legalSubcomponentKinds() {
+  public ImmutableSet<ComponentKind> legalSubcomponentKinds() {
     return isProducer()
         ? immutableEnumSet(PRODUCTION_SUBCOMPONENT)
         : immutableEnumSet(SUBCOMPONENT, PRODUCTION_SUBCOMPONENT);
@@ -147,17 +148,17 @@
    * Returns {@code true} if the descriptor is for a root component (not a subcomponent) or is for
    * {@linkplain #isForModuleValidation() module-validation}.
    */
-  boolean isRoot() {
+  public boolean isRoot() {
     return isRoot;
   }
 
   /** Returns true if this is a production component. */
-  boolean isProducer() {
+  public boolean isProducer() {
     return production;
   }
 
   /** Returns {@code true} if the descriptor is for a module in order to validate its bindings. */
-  boolean isForModuleValidation() {
+  public boolean isForModuleValidation() {
     switch (this) {
       case MODULE:
       case PRODUCER_MODULE:
diff --git a/java/dagger/internal/codegen/ComponentNodeImpl.java b/java/dagger/internal/codegen/binding/ComponentNodeImpl.java
similarity index 89%
rename from java/dagger/internal/codegen/ComponentNodeImpl.java
rename to java/dagger/internal/codegen/binding/ComponentNodeImpl.java
index 697255f8d..0947c252c 100644
--- a/java/dagger/internal/codegen/ComponentNodeImpl.java
+++ b/java/dagger/internal/codegen/binding/ComponentNodeImpl.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableSet;
 
@@ -27,8 +27,8 @@
 
 /** An implementation of {@link ComponentNode} that also exposes the {@link ComponentDescriptor}. */
 @AutoValue
-abstract class ComponentNodeImpl implements ComponentNode {
-  static ComponentNode create(
+public abstract class ComponentNodeImpl implements ComponentNode {
+  public static ComponentNode create(
       ComponentPath componentPath, ComponentDescriptor componentDescriptor) {
     return new AutoValue_ComponentNodeImpl(componentPath, componentDescriptor);
   }
@@ -55,7 +55,7 @@ public boolean isRealComponent() {
     return componentDescriptor().scopes();
   }
 
-  abstract ComponentDescriptor componentDescriptor();
+  public abstract ComponentDescriptor componentDescriptor();
 
   @Override
   public final String toString() {
diff --git a/java/dagger/internal/codegen/ComponentRequirement.java b/java/dagger/internal/codegen/binding/ComponentRequirement.java
similarity index 87%
rename from java/dagger/internal/codegen/ComponentRequirement.java
rename to java/dagger/internal/codegen/binding/ComponentRequirement.java
index 847c69959..264d06f21 100644
--- a/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/java/dagger/internal/codegen/binding/ComponentRequirement.java
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.base.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.binding.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.langmodel.DaggerElements.isAnyAnnotationPresent;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -47,8 +47,9 @@
 
 /** A type that a component needs an instance of. */
 @AutoValue
-abstract class ComponentRequirement {
-  enum Kind {
+public abstract class ComponentRequirement {
+  /** The kind of the {@link ComponentRequirement}. */
+  public enum Kind {
     /** A type listed in the component's {@code dependencies} attribute. */
     DEPENDENCY,
 
@@ -61,17 +62,17 @@
     BOUND_INSTANCE,
     ;
 
-    boolean isBoundInstance() {
+    public boolean isBoundInstance() {
       return equals(BOUND_INSTANCE);
     }
 
-    boolean isModule() {
+    public boolean isModule() {
       return equals(MODULE);
     }
   }
 
   /** The kind of requirement. */
-  abstract Kind kind();
+  public abstract Kind kind();
 
   /** Returns true if this is a {@link Kind#BOUND_INSTANCE} requirement. */
   // TODO(ronshapiro): consider removing this and inlining the usages
@@ -83,20 +84,20 @@ final boolean isBoundInstance() {
    * The type of the instance the component must have, wrapped so that requirements can be used as
    * value types.
    */
-  abstract Equivalence.Wrapper<TypeMirror> wrappedType();
+  public abstract Equivalence.Wrapper<TypeMirror> wrappedType();
 
   /** The type of the instance the component must have. */
-  TypeMirror type() {
+  public TypeMirror type() {
     return wrappedType().get();
   }
 
   /** The element associated with the type of this requirement. */
-  TypeElement typeElement() {
+  public TypeElement typeElement() {
     return MoreTypes.asTypeElement(type());
   }
 
   /** The action a component builder should take if it {@code null} is passed. */
-  enum NullPolicy {
+  public enum NullPolicy {
     /** Make a new instance. */
     NEW,
     /** Throw an exception. */
@@ -116,7 +117,7 @@ TypeElement typeElement() {
   abstract Optional<NullPolicy> overrideNullPolicy();
 
   /** The requirement's null policy. */
-  NullPolicy nullPolicy(DaggerElements elements, DaggerTypes types) {
+  public NullPolicy nullPolicy(DaggerElements elements, DaggerTypes types) {
     if (overrideNullPolicy().isPresent()) {
       return overrideNullPolicy().get();
     }
@@ -136,7 +137,7 @@ NullPolicy nullPolicy(DaggerElements elements, DaggerTypes types) {
    * Returns true if the passed {@link ComponentRequirement} requires a passed instance in order to
    * be used within a component.
    */
-  boolean requiresAPassedInstance(DaggerElements elements, DaggerTypes types) {
+  public boolean requiresAPassedInstance(DaggerElements elements, DaggerTypes types) {
     if (!kind().isModule()) {
       // Bound instances and dependencies always require the user to provide an instance.
       return true;
@@ -175,17 +176,17 @@ private boolean isBindingMethod(ExecutableElement method) {
   }
 
   /** The key for this requirement, if one is available. */
-  abstract Optional<Key> key();
+  public abstract Optional<Key> key();
 
   /** Returns the name for this requirement that could be used as a variable. */
-  abstract String variableName();
+  public abstract String variableName();
 
   /** Returns a parameter spec for this requirement. */
-  ParameterSpec toParameterSpec() {
+  public ParameterSpec toParameterSpec() {
     return ParameterSpec.builder(TypeName.get(type()), variableName()).build();
   }
 
-  static ComponentRequirement forDependency(TypeMirror type) {
+  public static ComponentRequirement forDependency(TypeMirror type) {
     return new AutoValue_ComponentRequirement(
         Kind.DEPENDENCY,
         MoreTypes.equivalence().wrap(checkNotNull(type)),
@@ -194,7 +195,7 @@ static ComponentRequirement forDependency(TypeMirror type) {
         simpleVariableName(MoreTypes.asTypeElement(type)));
   }
 
-  static ComponentRequirement forModule(TypeMirror type) {
+  public static ComponentRequirement forModule(TypeMirror type) {
     return new AutoValue_ComponentRequirement(
         Kind.MODULE,
         MoreTypes.equivalence().wrap(checkNotNull(type)),
@@ -212,7 +213,7 @@ static ComponentRequirement forBoundInstance(Key key, boolean nullable, String v
         variableName);
   }
 
-  static ComponentRequirement forBoundInstance(ContributionBinding binding) {
+  public static ComponentRequirement forBoundInstance(ContributionBinding binding) {
     checkArgument(binding.kind().equals(BindingKind.BOUND_INSTANCE));
     return forBoundInstance(
         binding.key(),
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/binding/ComponentTreeTraverser.java
similarity index 94%
rename from java/dagger/internal/codegen/ComponentTreeTraverser.java
rename to java/dagger/internal/codegen/binding/ComponentTreeTraverser.java
index 5b81cb772..3ff4c3469 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/binding/ComponentTreeTraverser.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
@@ -22,7 +22,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterators;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.ComponentPath;
 import dagger.model.DependencyRequest;
 import java.util.ArrayDeque;
@@ -46,7 +46,7 @@
   private final Deque<ComponentPath> componentPaths = new ArrayDeque<>();
 
   /** Constructs a traverser for a root (component, not subcomponent) binding graph. */
-  public ComponentTreeTraverser(BindingGraph rootGraph) {
+  ComponentTreeTraverser(BindingGraph rootGraph) {
     bindingGraphPath.add(rootGraph);
     componentPaths.add(ComponentPath.create(ImmutableList.of(rootGraph.componentTypeElement())));
   }
@@ -56,7 +56,7 @@ public ComponentTreeTraverser(BindingGraph rootGraph) {
    *
    * @throws IllegalStateException if a traversal is in progress
    */
-  public final void traverseComponents() {
+  final void traverseComponents() {
     checkState(bindingGraphPath.size() == 1);
     checkState(componentPaths.size() == 1);
     visitComponent(bindingGraphPath.getFirst());
@@ -154,7 +154,7 @@ protected final ComponentPath componentPath() {
    * Returns the subpath from the root component to the matching {@code ancestor} of the current
    * component.
    */
-  protected final ComponentPath pathFromRootToAncestor(TypeElement ancestor) {
+  final ComponentPath pathFromRootToAncestor(TypeElement ancestor) {
     for (ComponentPath componentPath : componentPaths) {
       if (componentPath.currentComponent().equals(ancestor)) {
         return componentPath;
@@ -168,7 +168,7 @@ protected final ComponentPath pathFromRootToAncestor(TypeElement ancestor) {
    * Returns the BindingGraph for {@code ancestor}, where {@code ancestor} is in the component path
    * of the current traversal.
    */
-  protected final BindingGraph graphForAncestor(TypeElement ancestor) {
+  final BindingGraph graphForAncestor(TypeElement ancestor) {
     for (BindingGraph graph : bindingGraphPath) {
       if (graph.componentTypeElement().equals(ancestor)) {
         return graph;
diff --git a/java/dagger/internal/codegen/ConfigurationAnnotations.java b/java/dagger/internal/codegen/binding/ConfigurationAnnotations.java
similarity index 90%
rename from java/dagger/internal/codegen/ConfigurationAnnotations.java
rename to java/dagger/internal/codegen/binding/ConfigurationAnnotations.java
index 177a36eb0..539a66ac6 100644
--- a/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/java/dagger/internal/codegen/binding/ConfigurationAnnotations.java
@@ -14,15 +14,15 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.consumingIterable;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.subcomponentCreatorAnnotations;
 import static dagger.internal.codegen.base.ComponentAnnotation.subcomponentAnnotation;
 import static dagger.internal.codegen.base.ModuleAnnotation.moduleAnnotation;
 import static dagger.internal.codegen.base.MoreAnnotationMirrors.getTypeListValue;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.subcomponentCreatorAnnotations;
 import static dagger.internal.codegen.langmodel.DaggerElements.isAnyAnnotationPresent;
 import static javax.lang.model.util.ElementFilter.typesIn;
 
@@ -50,12 +50,12 @@
 import javax.lang.model.type.TypeMirror;
 
 /**
- * Utility methods related to dagger configuration annotations (e.g.: {@link Component}
- * and {@link Module}).
+ * Utility methods related to dagger configuration annotations (e.g.: {@link Component} and {@link
+ * Module}).
  */
-final class ConfigurationAnnotations {
+public final class ConfigurationAnnotations {
 
-  static Optional<TypeElement> getSubcomponentCreator(TypeElement subcomponent) {
+  public static Optional<TypeElement> getSubcomponentCreator(TypeElement subcomponent) {
     checkArgument(subcomponentAnnotation(subcomponent).isPresent());
     for (TypeElement nestedType : typesIn(subcomponent.getEnclosedElements())) {
       if (isSubcomponentCreator(nestedType)) {
@@ -70,13 +70,13 @@ static boolean isSubcomponentCreator(Element element) {
   }
 
   // Dagger 1 support.
-  static ImmutableList<TypeMirror> getModuleInjects(AnnotationMirror moduleAnnotation) {
+  public static ImmutableList<TypeMirror> getModuleInjects(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
     return getTypeListValue(moduleAnnotation, "injects");
   }
 
   /** Returns the first type that specifies this' nullability, or empty if none. */
-  static Optional<DeclaredType> getNullableType(Element element) {
+  public static Optional<DeclaredType> getNullableType(Element element) {
     List<? extends AnnotationMirror> mirrors = element.getAnnotationMirrors();
     for (AnnotationMirror mirror : mirrors) {
       if (mirror.getAnnotationType().asElement().getSimpleName().contentEquals("Nullable")) {
@@ -94,7 +94,7 @@ static boolean isSubcomponentCreator(Element element) {
    * @deprecated Use {@link ComponentDescriptor#modules()}.
    */
   @Deprecated
-  static ImmutableSet<TypeElement> getTransitiveModules(
+  public static ImmutableSet<TypeElement> getTransitiveModules(
       DaggerTypes types, DaggerElements elements, Iterable<TypeElement> seedModules) {
     TypeMirror objectType = elements.getTypeElement(Object.class).asType();
     Queue<TypeElement> moduleQueue = new ArrayDeque<>();
@@ -125,7 +125,7 @@ static boolean isSubcomponentCreator(Element element) {
   }
 
   /** Returns the enclosed types annotated with the given annotation. */
-  static ImmutableList<DeclaredType> enclosedAnnotatedTypes(
+  public static ImmutableList<DeclaredType> enclosedAnnotatedTypes(
       TypeElement typeElement, Class<? extends Annotation> annotation) {
     final ImmutableList.Builder<DeclaredType> builders = ImmutableList.builder();
     for (TypeElement element : typesIn(typeElement.getEnclosedElements())) {
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/binding/ContributionBinding.java
similarity index 71%
rename from java/dagger/internal/codegen/ContributionBinding.java
rename to java/dagger/internal/codegen/binding/ContributionBinding.java
index 325369583..b991b4910 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/binding/ContributionBinding.java
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.CLASS_CONSTRUCTOR;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.base.MoreAnnotationMirrors.unwrapOptionalEquivalence;
+import static dagger.internal.codegen.binding.ContributionBinding.FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+import static dagger.internal.codegen.binding.ContributionBinding.FactoryCreationStrategy.DELEGATE;
+import static dagger.internal.codegen.binding.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static java.util.Arrays.asList;
 
 import com.google.auto.common.MoreElements;
@@ -45,19 +45,19 @@
  * An abstract class for a value object representing the mechanism by which a {@link Key} can be
  * contributed to a dependency graph.
  */
-abstract class ContributionBinding extends Binding implements HasContributionType {
+public abstract class ContributionBinding extends Binding implements HasContributionType {
 
   /** Returns the type that specifies this' nullability, absent if not nullable. */
-  abstract Optional<DeclaredType> nullableType();
+  public abstract Optional<DeclaredType> nullableType();
 
-  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKeyAnnotation();
+  public abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKeyAnnotation();
 
-  final Optional<AnnotationMirror> mapKeyAnnotation() {
+  public final Optional<AnnotationMirror> mapKeyAnnotation() {
     return unwrapOptionalEquivalence(wrappedMapKeyAnnotation());
   }
 
   /** If {@link #bindingElement()} is a method that returns a primitive type, returns that type. */
-  final Optional<TypeMirror> contributedPrimitiveType() {
+  public final Optional<TypeMirror> contributedPrimitiveType() {
     return bindingElement()
         .filter(bindingElement -> bindingElement instanceof ExecutableElement)
         .map(bindingElement -> MoreElements.asExecutable(bindingElement).getReturnType())
@@ -69,10 +69,8 @@ public final boolean isNullable() {
     return nullableType().isPresent();
   }
 
-  /**
-   * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
-   */
-  enum FactoryCreationStrategy {
+  /** The strategy for getting an instance of a factory for a {@link ContributionBinding}. */
+  public enum FactoryCreationStrategy {
     /** The factory class is a single instance. */
     SINGLETON_INSTANCE,
     /** The factory must be created by calling the constructor. */
@@ -91,7 +89,7 @@ public final boolean isNullable() {
    *
    * <p>All other bindings use the {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR} strategy.
    */
-  final FactoryCreationStrategy factoryCreationStrategy() {
+  public final FactoryCreationStrategy factoryCreationStrategy() {
     switch (kind()) {
       case DELEGATE:
         return DELEGATE;
@@ -113,7 +111,7 @@ final FactoryCreationStrategy factoryCreationStrategy() {
    * for this binding. Uses the binding's key, V in the case of {@code Map<K, FrameworkClass<V>>>},
    * and E {@code Set<E>} for {@link dagger.multibindings.IntoSet @IntoSet} methods.
    */
-  final TypeMirror contributedType() {
+  public final TypeMirror contributedType() {
     switch (contributionType()) {
       case MAP:
         return MapType.from(key()).unwrappedFrameworkValueType();
@@ -126,27 +124,6 @@ final TypeMirror contributedType() {
     throw new AssertionError();
   }
 
-  final boolean isSyntheticMultibinding() {
-    switch (kind()) {
-      case MULTIBOUND_SET:
-      case MULTIBOUND_MAP:
-        return true;
-      default:
-        return false;
-    }
-  }
-
-  /** Whether the bound type has a generated implementation. */
-  final boolean requiresGeneratedInstance() {
-    switch (kind()) {
-      case COMPONENT:
-      case SUBCOMPONENT_CREATOR:
-        return true;
-      default:
-        return false;
-    }
-  }
-
   /**
    * Returns {@link BindingKind#MULTIBOUND_SET} or {@link
    * BindingKind#MULTIBOUND_MAP} if the key is a set or map.
@@ -168,31 +145,31 @@ static BindingKind bindingKindForMultibindingKey(Key key) {
    * ContributionBinding}.
    */
   @CanIgnoreReturnValue
-  abstract static class Builder<C extends ContributionBinding, B extends Builder<C, B>> {
-    abstract B dependencies(Iterable<DependencyRequest> dependencies);
+  public abstract static class Builder<C extends ContributionBinding, B extends Builder<C, B>> {
+    public abstract B dependencies(Iterable<DependencyRequest> dependencies);
 
-    B dependencies(DependencyRequest... dependencies) {
+    public B dependencies(DependencyRequest... dependencies) {
       return dependencies(asList(dependencies));
     }
 
-    abstract B unresolved(C unresolved);
+    public abstract B unresolved(C unresolved);
 
-    abstract B contributionType(ContributionType contributionType);
+    public abstract B contributionType(ContributionType contributionType);
 
-    abstract B bindingElement(Element bindingElement);
+    public abstract B bindingElement(Element bindingElement);
 
-    abstract B contributingModule(TypeElement contributingModule);
+    public abstract B contributingModule(TypeElement contributingModule);
 
-    abstract B key(Key key);
+    public abstract B key(Key key);
 
-    abstract B nullableType(Optional<DeclaredType> nullableType);
+    public abstract B nullableType(Optional<DeclaredType> nullableType);
 
     abstract B wrappedMapKeyAnnotation(
         Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKeyAnnotation);
 
-    abstract B kind(BindingKind kind);
+    public abstract B kind(BindingKind kind);
 
     @CheckReturnValue
-    abstract C build();
+    public abstract C build();
   }
 }
diff --git a/java/dagger/internal/codegen/DelegateDeclaration.java b/java/dagger/internal/codegen/binding/DelegateDeclaration.java
similarity index 88%
rename from java/dagger/internal/codegen/DelegateDeclaration.java
rename to java/dagger/internal/codegen/binding/DelegateDeclaration.java
index a186b3cc2..b6c3c3830 100644
--- a/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/java/dagger/internal/codegen/binding/DelegateDeclaration.java
@@ -14,11 +14,11 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.base.MoreAnnotationMirrors.wrapOptionalInEquivalence;
+import static dagger.internal.codegen.binding.MapKeys.getMapKey;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -39,11 +39,10 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ExecutableType;
 
-/**
- * The declaration for a delegate binding established by a {@link Binds} method.
- */
+/** The declaration for a delegate binding established by a {@link Binds} method. */
 @AutoValue
-abstract class DelegateDeclaration extends BindingDeclaration implements HasContributionType {
+public abstract class DelegateDeclaration extends BindingDeclaration
+    implements HasContributionType {
   abstract DependencyRequest delegateRequest();
 
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
@@ -55,7 +54,8 @@
   @Override
   public abstract boolean equals(Object obj);
 
-  static final class Factory {
+  /** A {@link DelegateDeclaration} factory. */
+  public static final class Factory {
     private final DaggerTypes types;
     private final KeyFactory keyFactory;
     private final DependencyRequestFactory dependencyRequestFactory;
@@ -70,7 +70,7 @@
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
-    DelegateDeclaration create(
+    public DelegateDeclaration create(
         ExecutableElement bindsMethod, TypeElement contributingModule) {
       checkArgument(MoreElements.isAnnotationPresent(bindsMethod, Binds.class));
       ExecutableType resolvedMethod =
diff --git a/java/dagger/internal/codegen/DependencyEdgeImpl.java b/java/dagger/internal/codegen/binding/DependencyEdgeImpl.java
similarity index 97%
rename from java/dagger/internal/codegen/DependencyEdgeImpl.java
rename to java/dagger/internal/codegen/binding/DependencyEdgeImpl.java
index 517904a0f..f11517e6d 100644
--- a/java/dagger/internal/codegen/DependencyEdgeImpl.java
+++ b/java/dagger/internal/codegen/binding/DependencyEdgeImpl.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import dagger.internal.codegen.base.ElementFormatter;
 import dagger.model.BindingGraph.DependencyEdge;
diff --git a/java/dagger/internal/codegen/DependencyRequestFactory.java b/java/dagger/internal/codegen/binding/DependencyRequestFactory.java
similarity index 97%
rename from java/dagger/internal/codegen/DependencyRequestFactory.java
rename to java/dagger/internal/codegen/binding/DependencyRequestFactory.java
index 301118cc8..3c3228c7e 100644
--- a/java/dagger/internal/codegen/DependencyRequestFactory.java
+++ b/java/dagger/internal/codegen/binding/DependencyRequestFactory.java
@@ -14,17 +14,17 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
 import static dagger.internal.codegen.base.RequestKinds.extractKeyType;
 import static dagger.internal.codegen.base.RequestKinds.frameworkClass;
 import static dagger.internal.codegen.base.RequestKinds.getRequestKind;
+import static dagger.internal.codegen.binding.ConfigurationAnnotations.getNullableType;
 import static dagger.model.RequestKind.FUTURE;
 import static dagger.model.RequestKind.INSTANCE;
 import static dagger.model.RequestKind.MEMBERS_INJECTION;
@@ -59,7 +59,7 @@
  * <p>Any factory method may throw {@link TypeNotPresentException} if a type is not available, which
  * may mean that the type will be generated in a later round of processing.
  */
-final class DependencyRequestFactory {
+public final class DependencyRequestFactory {
   private final KeyFactory keyFactory;
   private final DaggerTypes types;
 
@@ -138,7 +138,7 @@ DependencyRequest forRequiredResolvedVariable(
     return newDependencyRequest(variableElement, resolvedType, qualifier);
   }
 
-  DependencyRequest forComponentProvisionMethod(
+  public DependencyRequest forComponentProvisionMethod(
       ExecutableElement provisionMethod, ExecutableType provisionMethodType) {
     checkNotNull(provisionMethod);
     checkNotNull(provisionMethodType);
@@ -150,7 +150,7 @@ DependencyRequest forComponentProvisionMethod(
     return newDependencyRequest(provisionMethod, provisionMethodType.getReturnType(), qualifier);
   }
 
-  DependencyRequest forComponentProductionMethod(
+  public DependencyRequest forComponentProductionMethod(
       ExecutableElement productionMethod, ExecutableType productionMethodType) {
     checkNotNull(productionMethod);
     checkNotNull(productionMethodType);
diff --git a/java/dagger/internal/codegen/DependencyRequestFormatter.java b/java/dagger/internal/codegen/binding/DependencyRequestFormatter.java
similarity index 95%
rename from java/dagger/internal/codegen/DependencyRequestFormatter.java
rename to java/dagger/internal/codegen/binding/DependencyRequestFormatter.java
index 057e158f8..3c326b6ea 100644
--- a/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/java/dagger/internal/codegen/binding/DependencyRequestFormatter.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static dagger.internal.codegen.base.ElementFormatter.elementToString;
 import static dagger.internal.codegen.base.RequestKinds.requestType;
@@ -54,7 +54,7 @@
  *   <dd>{@code @Qualified ResolvedType is injected at\n EnclosingType.field}
  * </dl>
  */
-final class DependencyRequestFormatter extends Formatter<DependencyRequest> {
+public final class DependencyRequestFormatter extends Formatter<DependencyRequest> {
 
   private final DaggerTypes types;
 
@@ -76,7 +76,8 @@ public String format(DependencyRequest request) {
    * #format(DependencyRequest)} returns the empty string.
    */
   @CanIgnoreReturnValue
-  StringBuilder appendFormatLine(StringBuilder builder, DependencyRequest dependencyRequest) {
+  public StringBuilder appendFormatLine(
+      StringBuilder builder, DependencyRequest dependencyRequest) {
     String formatted = format(dependencyRequest);
     if (!formatted.isEmpty()) {
       builder.append('\n').append(formatted);
diff --git a/java/dagger/internal/codegen/DependencyVariableNamer.java b/java/dagger/internal/codegen/binding/DependencyVariableNamer.java
similarity index 96%
rename from java/dagger/internal/codegen/DependencyVariableNamer.java
rename to java/dagger/internal/codegen/binding/DependencyVariableNamer.java
index 21f2d32af..e01d22ef2 100644
--- a/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/java/dagger/internal/codegen/binding/DependencyVariableNamer.java
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.binding.SourceFiles.simpleVariableName;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Ascii;
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/binding/ErrorMessages.java
similarity index 74%
rename from java/dagger/internal/codegen/ErrorMessages.java
rename to java/dagger/internal/codegen/binding/ErrorMessages.java
index 5d8786053..8962ade81 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/binding/ErrorMessages.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableMap;
@@ -27,7 +27,7 @@
 import javax.lang.model.type.TypeMirror;
 
 /** The collection of error messages to be reported back to users. */
-final class ErrorMessages {
+public final class ErrorMessages {
 
   private static final UnaryOperator<String> PRODUCTION =
       s ->
@@ -47,16 +47,17 @@
               ComponentKind.PRODUCTION_COMPONENT, PRODUCTION,
               ComponentKind.PRODUCTION_SUBCOMPONENT, PRODUCTION.andThen(SUBCOMPONENT));
 
-  static ComponentMessages componentMessagesFor(ComponentKind componentKind) {
+  public static ComponentMessages componentMessagesFor(ComponentKind componentKind) {
     return new ComponentMessages(COMPONENT_TRANSFORMATIONS.get(componentKind));
   }
 
-  static ComponentMessages componentMessagesFor(ComponentAnnotation componentAnnotation) {
+  public static ComponentMessages componentMessagesFor(ComponentAnnotation componentAnnotation) {
     return new ComponentMessages(
         transformation(componentAnnotation.isProduction(), componentAnnotation.isSubcomponent()));
   }
 
-  static ComponentCreatorMessages creatorMessagesFor(ComponentCreatorAnnotation creatorAnnotation) {
+  public static ComponentCreatorMessages creatorMessagesFor(
+      ComponentCreatorAnnotation creatorAnnotation) {
     Function<String, String> transformation =
         transformation(
             creatorAnnotation.isProductionCreatorAnnotation(),
@@ -89,115 +90,115 @@ protected final String process(String s) {
   }
 
   /** Errors for components. */
-  static final class ComponentMessages extends Messages {
+  public static final class ComponentMessages extends Messages {
     ComponentMessages(Function<String, String> transformation) {
       super(transformation);
     }
 
-    final String moreThanOne() {
+    public final String moreThanOne() {
       return process("@Component has more than one @Component.Builder or @Component.Factory: %s");
     }
   }
 
   /** Errors for component creators. */
-  abstract static class ComponentCreatorMessages extends Messages {
+  public abstract static class ComponentCreatorMessages extends Messages {
     ComponentCreatorMessages(Function<String, String> transformation) {
       super(transformation);
     }
 
-    static String builderMethodRequiresNoArgs() {
+    public static String builderMethodRequiresNoArgs() {
       return "Methods returning a @Component.Builder must have no arguments";
     }
 
-    static String moreThanOneRefToSubcomponent() {
+    public static String moreThanOneRefToSubcomponent() {
       return "Only one method can create a given subcomponent. %s is created by: %s";
     }
 
-    final String invalidConstructor() {
+    public final String invalidConstructor() {
       return process("@Component.Builder classes must have exactly one constructor,"
           + " and it must not be private or have any parameters");
     }
 
-    final String generics() {
+    public final String generics() {
       return process("@Component.Builder types must not have any generic types");
     }
 
-    final String mustBeInComponent() {
+    public final String mustBeInComponent() {
       return process("@Component.Builder types must be nested within a @Component");
     }
 
-    final String mustBeClassOrInterface() {
+    public final String mustBeClassOrInterface() {
       return process("@Component.Builder types must be abstract classes or interfaces");
     }
 
-    final String isPrivate() {
+    public final String isPrivate() {
       return process("@Component.Builder types must not be private");
     }
 
-    final String mustBeStatic() {
+    public final String mustBeStatic() {
       return process("@Component.Builder types must be static");
     }
 
-    final String mustBeAbstract() {
+    public final String mustBeAbstract() {
       return process("@Component.Builder types must be abstract");
     }
 
-    abstract String missingFactoryMethod();
+    public abstract String missingFactoryMethod();
 
-    abstract String multipleSettersForModuleOrDependencyType();
+    public abstract String multipleSettersForModuleOrDependencyType();
 
-    abstract String extraSetters();
+    public abstract String extraSetters();
 
-    abstract String missingSetters();
+    public abstract String missingSetters();
 
-    abstract String twoFactoryMethods();
+    public abstract String twoFactoryMethods();
 
-    abstract String inheritedTwoFactoryMethods();
+    public abstract String inheritedTwoFactoryMethods();
 
-    abstract String factoryMethodMustReturnComponentType();
+    public abstract String factoryMethodMustReturnComponentType();
 
-    final String inheritedFactoryMethodMustReturnComponentType() {
+    public final String inheritedFactoryMethodMustReturnComponentType() {
       return factoryMethodMustReturnComponentType() + ". Inherited method: %s";
     }
 
-    abstract String factoryMethodMayNotBeAnnotatedWithBindsInstance();
+    public abstract String factoryMethodMayNotBeAnnotatedWithBindsInstance();
 
-    final String inheritedFactoryMethodMayNotBeAnnotatedWithBindsInstance() {
+    public final String inheritedFactoryMethodMayNotBeAnnotatedWithBindsInstance() {
       return factoryMethodMayNotBeAnnotatedWithBindsInstance() + ". Inherited method: %s";
     }
 
-    final String setterMethodsMustTakeOneArg() {
+    public final String setterMethodsMustTakeOneArg() {
       return process("@Component.Builder methods must not have more than one argument");
     }
 
-    final String inheritedSetterMethodsMustTakeOneArg() {
+    public final String inheritedSetterMethodsMustTakeOneArg() {
       return setterMethodsMustTakeOneArg() + ". Inherited method: %s";
     }
 
-    final String setterMethodsMustReturnVoidOrBuilder() {
+    public final String setterMethodsMustReturnVoidOrBuilder() {
       return process("@Component.Builder setter methods must return void, the builder,"
           + " or a supertype of the builder");
     }
 
-    final String inheritedSetterMethodsMustReturnVoidOrBuilder() {
+    public final String inheritedSetterMethodsMustReturnVoidOrBuilder() {
       return setterMethodsMustReturnVoidOrBuilder() + ". Inherited method: %s";
     }
 
-    final String methodsMayNotHaveTypeParameters() {
+    public final String methodsMayNotHaveTypeParameters() {
       return process("@Component.Builder methods must not have type parameters");
     }
 
-    final String inheritedMethodsMayNotHaveTypeParameters() {
+    public final String inheritedMethodsMayNotHaveTypeParameters() {
       return methodsMayNotHaveTypeParameters() + ". Inherited method: %s";
     }
 
-    abstract String nonBindsInstanceParametersMayNotBePrimitives();
+    public abstract String nonBindsInstanceParametersMayNotBePrimitives();
 
-    final String inheritedNonBindsInstanceParametersMayNotBePrimitives() {
+    public final String inheritedNonBindsInstanceParametersMayNotBePrimitives() {
       return nonBindsInstanceParametersMayNotBePrimitives() + ". Inherited method: %s";
     }
 
-    final String factoryMethodReturnsSupertypeWithMissingMethods(
+    public final String factoryMethodReturnsSupertypeWithMissingMethods(
         TypeElement component,
         TypeElement componentBuilder,
         TypeMirror returnType,
@@ -214,12 +215,12 @@ final String factoryMethodReturnsSupertypeWithMissingMethods(
           Joiner.on(", ").join(additionalMethods));
     }
 
-    final String bindsInstanceNotAllowedOnBothSetterMethodAndParameter() {
+    public final String bindsInstanceNotAllowedOnBothSetterMethodAndParameter() {
       return process("@Component.Builder setter methods may not have @BindsInstance on both the "
           + "method and its parameter; choose one or the other");
     }
 
-    final String inheritedBindsInstanceNotAllowedOnBothSetterMethodAndParameter() {
+    public final String inheritedBindsInstanceNotAllowedOnBothSetterMethodAndParameter() {
       return bindsInstanceNotAllowedOnBothSetterMethodAndParameter() + ". Inherited method: %s";
     }
   }
@@ -230,60 +231,60 @@ final String inheritedBindsInstanceNotAllowedOnBothSetterMethodAndParameter() {
     }
 
     @Override
-    String missingFactoryMethod() {
+    public String missingFactoryMethod() {
       return process(
           "@Component.Builder types must have exactly one no-args method that "
               + " returns the @Component type");
     }
 
     @Override
-    String multipleSettersForModuleOrDependencyType() {
+    public String multipleSettersForModuleOrDependencyType() {
       return process(
           "@Component.Builder types must not have more than one setter method per module or "
               + "dependency, but %s is set by %s");
     }
 
     @Override
-    String extraSetters() {
+    public String extraSetters() {
       return process(
           "@Component.Builder has setters for modules or components that aren't required: %s");
     }
 
     @Override
-    String missingSetters() {
+    public String missingSetters() {
       return process(
           "@Component.Builder is missing setters for required modules or components: %s");
     }
 
     @Override
-    String twoFactoryMethods() {
+    public String twoFactoryMethods() {
       return process(
           "@Component.Builder types must have exactly one zero-arg method, and that"
               + " method must return the @Component type. Already found: %s");
     }
 
     @Override
-    String inheritedTwoFactoryMethods() {
+    public String inheritedTwoFactoryMethods() {
       return process(
           "@Component.Builder types must have exactly one zero-arg method, and that"
               + " method must return the @Component type. Found %s and %s");
     }
 
     @Override
-    String factoryMethodMustReturnComponentType() {
+    public String factoryMethodMustReturnComponentType() {
       return process(
           "@Component.Builder methods that have no arguments must return the @Component type or a "
               + "supertype of the @Component");
     }
 
     @Override
-    String factoryMethodMayNotBeAnnotatedWithBindsInstance() {
+    public String factoryMethodMayNotBeAnnotatedWithBindsInstance() {
       return process(
           "@Component.Builder no-arg build methods may not be annotated with @BindsInstance");
     }
 
     @Override
-    String nonBindsInstanceParametersMayNotBePrimitives() {
+    public String nonBindsInstanceParametersMayNotBePrimitives() {
       return process(
           "@Component.Builder methods that are not annotated with @BindsInstance "
               + "must take either a module or a component dependency, not a primitive");
@@ -296,57 +297,57 @@ String nonBindsInstanceParametersMayNotBePrimitives() {
     }
 
     @Override
-    String missingFactoryMethod() {
+    public String missingFactoryMethod() {
       return process(
           "@Component.Factory types must have exactly one method that "
               + "returns the @Component type");
     }
 
     @Override
-    String multipleSettersForModuleOrDependencyType() {
+    public String multipleSettersForModuleOrDependencyType() {
       return process(
           "@Component.Factory methods must not have more than one parameter per module or "
               + "dependency, but %s is set by %s");
     }
 
     @Override
-    String extraSetters() {
+    public String extraSetters() {
       return process(
           "@Component.Factory method has parameters for modules or components that aren't "
               + "required: %s");
     }
 
     @Override
-    String missingSetters() {
+    public String missingSetters() {
       return process(
           "@Component.Factory method is missing parameters for required modules or components: %s");
     }
 
     @Override
-    String twoFactoryMethods() {
+    public String twoFactoryMethods() {
       return process(
           "@Component.Factory types must have exactly one abstract method. Already found: %s");
     }
 
     @Override
-    String inheritedTwoFactoryMethods() {
+    public String inheritedTwoFactoryMethods() {
       return twoFactoryMethods();
     }
 
     @Override
-    String factoryMethodMustReturnComponentType() {
+    public String factoryMethodMustReturnComponentType() {
       return process(
           "@Component.Factory abstract methods must return the @Component type or a "
               + "supertype of the @Component");
     }
 
     @Override
-    String factoryMethodMayNotBeAnnotatedWithBindsInstance() {
+    public String factoryMethodMayNotBeAnnotatedWithBindsInstance() {
       return process("@Component.Factory method may not be annotated with @BindsInstance");
     }
 
     @Override
-    String nonBindsInstanceParametersMayNotBePrimitives() {
+    public String nonBindsInstanceParametersMayNotBePrimitives() {
       return process(
           "@Component.Factory method parameters that are not annotated with @BindsInstance "
               + "must be either a module or a component dependency, not a primitive");
diff --git a/java/dagger/internal/codegen/FrameworkField.java b/java/dagger/internal/codegen/binding/FrameworkField.java
similarity index 94%
rename from java/dagger/internal/codegen/FrameworkField.java
rename to java/dagger/internal/codegen/binding/FrameworkField.java
index 038c8e69b..3b0b73fbe 100644
--- a/java/dagger/internal/codegen/FrameworkField.java
+++ b/java/dagger/internal/codegen/binding/FrameworkField.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static dagger.model.BindingKind.MEMBERS_INJECTOR;
 
@@ -36,6 +36,7 @@
  * A value object that represents a field in the generated Component class.
  *
  * <p>Examples:
+ *
  * <ul>
  *   <li>{@code Provider<String>}
  *   <li>{@code Producer<Widget>}
@@ -43,17 +44,17 @@
  * </ul>
  */
 @AutoValue
-abstract class FrameworkField {
+public abstract class FrameworkField {
 
   /**
    * Creates a framework field.
-   * 
+   *
    * @param frameworkClassName the name of the framework class (e.g., {@link javax.inject.Provider})
    * @param valueTypeName the name of the type parameter of the framework class (e.g., {@code Foo}
    *     for {@code Provider<Foo>}
    * @param fieldName the name of the field
    */
-  static FrameworkField create(
+  public static FrameworkField create(
       ClassName frameworkClassName, TypeName valueTypeName, String fieldName) {
     String suffix = frameworkClassName.simpleName();
     return new AutoValue_FrameworkField(
@@ -63,11 +64,11 @@ static FrameworkField create(
 
   /**
    * A framework field for a {@link ContributionBinding}.
-   * 
+   *
    * @param frameworkClass if present, the field will use this framework class instead of the normal
    *     one for the binding's type.
    */
-  static FrameworkField forBinding(
+  public static FrameworkField forBinding(
       ContributionBinding binding, Optional<ClassName> frameworkClass) {
     return create(
         frameworkClass.orElse(
@@ -120,6 +121,7 @@ public String visitVariableAsParameter(VariableElement e, Binding p) {
         }
       };
 
-  abstract ParameterizedTypeName type();
-  abstract String name();
+  public abstract ParameterizedTypeName type();
+
+  public abstract String name();
 }
diff --git a/java/dagger/internal/codegen/FrameworkType.java b/java/dagger/internal/codegen/binding/FrameworkType.java
similarity index 86%
rename from java/dagger/internal/codegen/FrameworkType.java
rename to java/dagger/internal/codegen/binding/FrameworkType.java
index 4f094753c..6b160b613 100644
--- a/java/dagger/internal/codegen/FrameworkType.java
+++ b/java/dagger/internal/codegen/binding/FrameworkType.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
@@ -42,21 +42,21 @@
 import javax.lang.model.type.TypeMirror;
 
 /** One of the core types initialized as fields in a generated component. */
-enum FrameworkType {
+public enum FrameworkType {
   /** A {@link Provider}. */
   PROVIDER {
     @Override
-    Class<?> frameworkClass() {
+    public Class<?> frameworkClass() {
       return Provider.class;
     }
 
     @Override
-    Optional<RequestKind> requestKind() {
+    public Optional<RequestKind> requestKind() {
       return Optional.of(RequestKind.PROVIDER);
     }
 
     @Override
-    CodeBlock to(RequestKind requestKind, CodeBlock from) {
+    public CodeBlock to(RequestKind requestKind, CodeBlock from) {
       switch (requestKind) {
         case INSTANCE:
           return CodeBlock.of("$L.get()", from);
@@ -86,7 +86,7 @@ CodeBlock to(RequestKind requestKind, CodeBlock from) {
     }
 
     @Override
-    Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
+    public Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
       CodeBlock codeBlock = to(requestKind, from.codeBlock());
       switch (requestKind) {
         case INSTANCE:
@@ -113,7 +113,7 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
   /** A {@link Producer}. */
   PRODUCER_NODE {
     @Override
-    Class<?> frameworkClass() {
+    public Class<?> frameworkClass() {
       // TODO(cgdecker): Replace this with new class for representing internal producer nodes.
       // Currently the new class is CancellableProducer, but it may be changed to ProducerNode and
       // made to not implement Producer.
@@ -121,12 +121,12 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
     }
 
     @Override
-    Optional<RequestKind> requestKind() {
+    public Optional<RequestKind> requestKind() {
       return Optional.empty();
     }
 
     @Override
-    CodeBlock to(RequestKind requestKind, CodeBlock from) {
+    public CodeBlock to(RequestKind requestKind, CodeBlock from) {
       switch (requestKind) {
         case FUTURE:
           return CodeBlock.of("$L.get()", from);
@@ -141,7 +141,7 @@ CodeBlock to(RequestKind requestKind, CodeBlock from) {
     }
 
     @Override
-    Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
+    public Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
       switch (requestKind) {
         case FUTURE:
           return Expression.create(
@@ -160,7 +160,7 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
   ;
 
   /** Returns the framework type appropriate for fields for a given binding type. */
-  static FrameworkType forBindingType(BindingType bindingType) {
+  public static FrameworkType forBindingType(BindingType bindingType) {
     switch (bindingType) {
       case PROVISION:
         return PROVIDER;
@@ -172,7 +172,7 @@ static FrameworkType forBindingType(BindingType bindingType) {
   }
 
   /** Returns the framework type that exactly matches the given request kind, if one exists. */
-  static Optional<FrameworkType> forRequestKind(RequestKind requestKind) {
+  public static Optional<FrameworkType> forRequestKind(RequestKind requestKind) {
     switch (requestKind) {
       case PROVIDER:
         return Optional.of(FrameworkType.PROVIDER);
@@ -182,15 +182,15 @@ static FrameworkType forBindingType(BindingType bindingType) {
   }
 
   /** The class of fields of this type. */
-  abstract Class<?> frameworkClass();
+  public abstract Class<?> frameworkClass();
 
   /** Returns the {@link #frameworkClass()} parameterized with a type. */
-  ParameterizedTypeName frameworkClassOf(TypeName valueType) {
+  public ParameterizedTypeName frameworkClassOf(TypeName valueType) {
     return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);
   }
 
   /** The request kind that an instance of this framework type can satisfy directly, if any. */
-  abstract Optional<RequestKind> requestKind();
+  public abstract Optional<RequestKind> requestKind();
 
   /**
    * Returns a {@link CodeBlock} that evaluates to a requested object given an expression that
@@ -202,7 +202,7 @@ ParameterizedTypeName frameworkClassOf(TypeName valueType) {
    * @throws IllegalArgumentException if a valid expression cannot be generated for {@code
    *     requestKind}
    */
-  abstract CodeBlock to(RequestKind requestKind, CodeBlock from);
+  public abstract CodeBlock to(RequestKind requestKind, CodeBlock from);
 
   /**
    * Returns an {@link Expression} that evaluates to a requested object given an expression that
@@ -214,7 +214,7 @@ ParameterizedTypeName frameworkClassOf(TypeName valueType) {
    * @throws IllegalArgumentException if a valid expression cannot be generated for {@code
    *     requestKind}
    */
-  abstract Expression to(RequestKind requestKind, Expression from, DaggerTypes types);
+  public abstract Expression to(RequestKind requestKind, Expression from, DaggerTypes types);
 
   @Override
   public String toString() {
diff --git a/java/dagger/internal/codegen/FrameworkTypeMapper.java b/java/dagger/internal/codegen/binding/FrameworkTypeMapper.java
similarity index 86%
rename from java/dagger/internal/codegen/FrameworkTypeMapper.java
rename to java/dagger/internal/codegen/binding/FrameworkTypeMapper.java
index 04915350b..85463aff8 100644
--- a/java/dagger/internal/codegen/FrameworkTypeMapper.java
+++ b/java/dagger/internal/codegen/binding/FrameworkTypeMapper.java
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
-import static dagger.internal.codegen.BindingType.PRODUCTION;
+import static dagger.internal.codegen.binding.BindingType.PRODUCTION;
 
 import dagger.model.RequestKind;
 import dagger.producers.Producer;
@@ -26,7 +26,7 @@
  * A mapper for associating a {@link RequestKind} to a {@link FrameworkType}, dependent on the type
  * of code to be generated (e.g., for {@link Provider} or {@link Producer}).
  */
-enum FrameworkTypeMapper {
+public enum FrameworkTypeMapper {
   FOR_PROVIDER() {
     @Override
     public FrameworkType getFrameworkType(RequestKind requestKind) {
@@ -62,9 +62,9 @@ public FrameworkType getFrameworkType(RequestKind requestKind) {
     }
   };
 
-  static FrameworkTypeMapper forBindingType(BindingType bindingType) {
+  public static FrameworkTypeMapper forBindingType(BindingType bindingType) {
     return bindingType.equals(PRODUCTION) ? FOR_PRODUCER : FOR_PROVIDER;
   }
 
-  abstract FrameworkType getFrameworkType(RequestKind requestKind);
+  public abstract FrameworkType getFrameworkType(RequestKind requestKind);
 }
diff --git a/java/dagger/internal/codegen/InjectBindingRegistry.java b/java/dagger/internal/codegen/binding/InjectBindingRegistry.java
similarity index 97%
rename from java/dagger/internal/codegen/InjectBindingRegistry.java
rename to java/dagger/internal/codegen/binding/InjectBindingRegistry.java
index 0bfda0fbc..5203130f4 100644
--- a/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/java/dagger/internal/codegen/binding/InjectBindingRegistry.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Component;
@@ -33,7 +33,7 @@
  * that this registry <b>does not</b> handle any explicit bindings (those from {@link Provides}
  * methods, {@link Component} dependencies, etc.).
  */
-interface InjectBindingRegistry {
+public interface InjectBindingRegistry {
   /**
    * Returns a {@link ProvisionBinding} for {@code key}. If none has been registered yet, registers
    * one.
diff --git a/java/dagger/internal/codegen/InjectionSiteFactory.java b/java/dagger/internal/codegen/binding/InjectionSiteFactory.java
similarity index 96%
rename from java/dagger/internal/codegen/InjectionSiteFactory.java
rename to java/dagger/internal/codegen/binding/InjectionSiteFactory.java
index d09f91d3e..64660998c 100644
--- a/java/dagger/internal/codegen/InjectionSiteFactory.java
+++ b/java/dagger/internal/codegen/binding/InjectionSiteFactory.java
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.MembersInjectionBinding.InjectionSite.Kind.METHOD;
+import static dagger.internal.codegen.binding.MembersInjectionBinding.InjectionSite.Kind.METHOD;
 import static dagger.internal.codegen.langmodel.DaggerElements.DECLARATION_ORDER;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -27,7 +27,7 @@
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.SetMultimap;
-import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+import dagger.internal.codegen.binding.MembersInjectionBinding.InjectionSite;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import java.util.ArrayList;
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/binding/KeyFactory.java
similarity index 94%
rename from java/dagger/internal/codegen/KeyFactory.java
rename to java/dagger/internal/codegen/binding/KeyFactory.java
index a75b44db2..1f1734114 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/binding/KeyFactory.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asExecutable;
@@ -22,11 +22,11 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.MapKeys.getMapKey;
-import static dagger.internal.codegen.MapKeys.mapKeyType;
 import static dagger.internal.codegen.base.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.base.RequestKinds.extractKeyType;
 import static dagger.internal.codegen.base.RequestKinds.getRequestKind;
+import static dagger.internal.codegen.binding.MapKeys.getMapKey;
+import static dagger.internal.codegen.binding.MapKeys.mapKeyType;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.extension.Optionals.firstPresent;
 import static dagger.internal.codegen.langmodel.DaggerTypes.isFutureType;
@@ -71,12 +71,13 @@
 import javax.lang.model.type.TypeMirror;
 
 /** A factory for {@link Key}s. */
-final class KeyFactory {
+public final class KeyFactory {
   private final DaggerTypes types;
   private final DaggerElements elements;
 
+  // TODO(user): Make this pkg-private. This is used by KeyFactoryTest.
   @Inject
-  KeyFactory(DaggerTypes types, DaggerElements elements) {
+  public KeyFactory(DaggerTypes types, DaggerElements elements) {
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
   }
@@ -123,16 +124,16 @@ Key forSubcomponentCreatorMethod(
     return Key.builder(resolvedMethod.getReturnType()).build();
   }
 
-  Key forSubcomponentCreator(TypeMirror creatorType) {
+  public Key forSubcomponentCreator(TypeMirror creatorType) {
     return Key.builder(creatorType).build();
   }
 
-  Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
+  public Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
     return forBindingMethod(
         method, contributingModule, Optional.of(elements.getTypeElement(Provider.class)));
   }
 
-  Key forProducesMethod(ExecutableElement method, TypeElement contributingModule) {
+  public Key forProducesMethod(ExecutableElement method, TypeElement contributingModule) {
     return forBindingMethod(
         method, contributingModule, Optional.of(elements.getTypeElement(Producer.class)));
   }
@@ -243,7 +244,7 @@ private Key forMethod(ExecutableElement method, TypeMirror keyType) {
     return forQualifiedType(getQualifier(method), keyType);
   }
 
-  Key forInjectConstructorWithResolvedType(TypeMirror type) {
+  public Key forInjectConstructorWithResolvedType(TypeMirror type) {
     return Key.builder(type).build();
   }
 
@@ -252,7 +253,7 @@ Key forType(TypeMirror type) {
     return Key.builder(type).build();
   }
 
-  Key forMembersInjectedType(TypeMirror type) {
+  public Key forMembersInjectedType(TypeMirror type) {
     return Key.builder(type).build();
   }
 
@@ -260,19 +261,19 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
     return Key.builder(boxPrimitives(type)).qualifier(qualifier).build();
   }
 
-  Key forProductionExecutor() {
+  public Key forProductionExecutor() {
     return Key.builder(elements.getTypeElement(Executor.class).asType())
         .qualifier(SimpleAnnotationMirror.of(elements.getTypeElement(Production.class)))
         .build();
   }
 
-  Key forProductionImplementationExecutor() {
+  public Key forProductionImplementationExecutor() {
     return Key.builder(elements.getTypeElement(Executor.class).asType())
         .qualifier(SimpleAnnotationMirror.of(elements.getTypeElement(ProductionImplementation.class)))
         .build();
   }
 
-  Key forProductionComponentMonitor() {
+  public Key forProductionComponentMonitor() {
     return Key.builder(elements.getTypeElement(ProductionComponentMonitor.class).asType()).build();
   }
 
@@ -319,7 +320,7 @@ Key forProductionComponentMonitor() {
    *
    * <p>Otherwise, returns {@code key}.
    */
-  Key unwrapMapValueType(Key key) {
+  public Key unwrapMapValueType(Key key) {
     if (MapType.isMap(key)) {
       MapType mapType = MapType.from(key);
       if (!mapType.isRawType()) {
@@ -354,7 +355,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
    * @throws IllegalArgumentException if {@code newWrappingClass} is the same as {@code
    *     currentWrappingClass}
    */
-  Optional<Key> rewrapMapKey(
+  public Optional<Key> rewrapMapKey(
       Key possibleMapKey, Class<?> currentWrappingClass, Class<?> newWrappingClass) {
     checkArgument(!currentWrappingClass.equals(newWrappingClass));
     if (MapType.isMap(possibleMapKey)) {
diff --git a/java/dagger/internal/codegen/KeyVariableNamer.java b/java/dagger/internal/codegen/binding/KeyVariableNamer.java
similarity index 94%
rename from java/dagger/internal/codegen/KeyVariableNamer.java
rename to java/dagger/internal/codegen/binding/KeyVariableNamer.java
index 407f208ca..9ac0efa83 100644
--- a/java/dagger/internal/codegen/KeyVariableNamer.java
+++ b/java/dagger/internal/codegen/binding/KeyVariableNamer.java
@@ -14,11 +14,11 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static dagger.internal.codegen.SourceFiles.protectAgainstKeywords;
+import static dagger.internal.codegen.binding.SourceFiles.protectAgainstKeywords;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
@@ -37,7 +37,7 @@
  * Suggests a variable name for a type based on a {@link Key}. Prefer {@link
  * DependencyVariableNamer} for cases where a specific {@link DependencyRequest} is present.
  */
-final class KeyVariableNamer {
+public final class KeyVariableNamer {
   /** Simple names that are very common. Inspired by https://errorprone.info/bugpattern/BadImport */
   private static final ImmutableSet<String> VERY_SIMPLE_NAMES =
       ImmutableSet.of(
@@ -88,7 +88,7 @@ public Void visitArray(ArrayType type, StringBuilder builder) {
 
   private KeyVariableNamer() {}
 
-  static String name(Key key) {
+  public static String name(Key key) {
     if (key.multibindingContributionIdentifier().isPresent()) {
       return key.multibindingContributionIdentifier().get().bindingElement();
     }
diff --git a/java/dagger/internal/codegen/MapKeys.java b/java/dagger/internal/codegen/binding/MapKeys.java
similarity index 93%
rename from java/dagger/internal/codegen/MapKeys.java
rename to java/dagger/internal/codegen/binding/MapKeys.java
index 0b2f84e06..ec7d79df1 100644
--- a/java/dagger/internal/codegen/MapKeys.java
+++ b/java/dagger/internal/codegen/binding/MapKeys.java
@@ -14,15 +14,15 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static dagger.internal.codegen.SourceFiles.elementBasedClassName;
 import static dagger.internal.codegen.base.MapKeyAccessibility.isMapKeyPubliclyAccessible;
+import static dagger.internal.codegen.binding.SourceFiles.elementBasedClassName;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.util.ElementFilter.methodsIn;
@@ -52,10 +52,8 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
-/**
- * Methods for extracting {@link MapKey} annotations and key code blocks from binding elements.
- */
-final class MapKeys {
+/** Methods for extracting {@link MapKey} annotations and key code blocks from binding elements. */
+public final class MapKeys {
 
   /**
    * If {@code bindingElement} is annotated with a {@link MapKey} annotation, returns it.
@@ -70,10 +68,8 @@
         : Optional.<AnnotationMirror>of(getOnlyElement(mapKeys));
   }
 
-  /**
-   * Returns all of the {@link MapKey} annotations that annotate {@code bindingElement}.
-   */
-  static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element bindingElement) {
+  /** Returns all of the {@link MapKey} annotations that annotate {@code bindingElement}. */
+  public static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element bindingElement) {
     return getAnnotatedAnnotations(bindingElement, MapKey.class);
   }
 
@@ -107,7 +103,7 @@ static TypeMirror mapKeyType(AnnotationMirror mapKeyAnnotation, DaggerTypes type
    *     has more than one member, or if its single member is an array
    * @throws NoSuchElementException if the annotation has no members
    */
-  static DeclaredType getUnwrappedMapKeyType(
+  public static DeclaredType getUnwrappedMapKeyType(
       final DeclaredType mapKeyAnnotationType, final DaggerTypes types) {
     checkArgument(
         MoreTypes.asTypeElement(mapKeyAnnotationType).getKind() == ElementKind.ANNOTATION_TYPE,
@@ -148,7 +144,7 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
    * @throws IllegalStateException if {@code binding} is not a {@link dagger.multibindings.IntoMap
    *     map} contribution.
    */
-  static CodeBlock getMapKeyExpression(
+  public static CodeBlock getMapKeyExpression(
       ContributionBinding binding, ClassName requestingClass, DaggerElements elements) {
     AnnotationMirror mapKeyAnnotation = binding.mapKeyAnnotation().get();
     return MapKeyAccessibility.isMapKeyAccessibleFrom(
@@ -198,7 +194,7 @@ private static CodeBlock directMapKeyExpression(
    * Returns the {@link ClassName} in which {@link #mapKeyFactoryMethod(ContributionBinding,
    * DaggerTypes, DaggerElements)} is generated.
    */
-  static ClassName mapKeyProxyClassName(ContributionBinding binding) {
+  public static ClassName mapKeyProxyClassName(ContributionBinding binding) {
     return elementBasedClassName(
         MoreElements.asExecutable(binding.bindingElement().get()), "MapKey");
   }
@@ -208,7 +204,7 @@ static ClassName mapKeyProxyClassName(ContributionBinding binding) {
    * #mapKeyProxyClassName(ContributionBinding)} when the {@code @MapKey} annotation is not publicly
    * accessible.
    */
-  static Optional<MethodSpec> mapKeyFactoryMethod(
+  public static Optional<MethodSpec> mapKeyFactoryMethod(
       ContributionBinding binding, DaggerTypes types, DaggerElements elements) {
     return binding
         .mapKeyAnnotation()
diff --git a/java/dagger/internal/codegen/MembersInjectionBinding.java b/java/dagger/internal/codegen/binding/MembersInjectionBinding.java
similarity index 77%
rename from java/dagger/internal/codegen/MembersInjectionBinding.java
rename to java/dagger/internal/codegen/binding/MembersInjectionBinding.java
index 4918fa1fc..3dd101657 100644
--- a/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/java/dagger/internal/codegen/binding/MembersInjectionBinding.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static java.util.stream.Collectors.toList;
@@ -33,20 +33,18 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 
-/**
- * Represents the full members injection of a particular type.
- */
+/** Represents the full members injection of a particular type. */
 @AutoValue
-abstract class MembersInjectionBinding extends Binding {
+public abstract class MembersInjectionBinding extends Binding {
   @Override
   public final Optional<Element> bindingElement() {
     return Optional.of(membersInjectedType());
   }
 
-  abstract TypeElement membersInjectedType();
+  public abstract TypeElement membersInjectedType();
 
   @Override
-  abstract Optional<MembersInjectionBinding> unresolved();
+  public abstract Optional<MembersInjectionBinding> unresolved();
 
   @Override
   public Optional<TypeElement> contributingModule() {
@@ -54,10 +52,10 @@
   }
 
   /** The set of individual sites where {@link Inject} is applied. */
-  abstract ImmutableSortedSet<InjectionSite> injectionSites();
+  public abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
   @Override
-  BindingType bindingType() {
+  public BindingType bindingType() {
     return BindingType.MEMBERS_INJECTION;
   }
 
@@ -74,7 +72,7 @@ public boolean isNullable() {
   /**
    * Returns {@code true} if any of this binding's injection sites are directly on the bound type.
    */
-  boolean hasLocalInjectionSites() {
+  public boolean hasLocalInjectionSites() {
     return injectionSites()
         .stream()
         .anyMatch(
@@ -83,7 +81,7 @@ boolean hasLocalInjectionSites() {
   }
 
   @Override
-  boolean requiresModuleInstance() {
+  public boolean requiresModuleInstance() {
     return false;
   }
 
@@ -95,18 +93,20 @@ boolean requiresModuleInstance() {
   @Override
   public abstract boolean equals(Object obj);
 
+  /** Metadata about a field or method injection site. */
   @AutoValue
-  abstract static class InjectionSite {
-    enum Kind {
+  public abstract static class InjectionSite {
+    /** The type of injection site. */
+    public enum Kind {
       FIELD,
       METHOD,
     }
 
-    abstract Kind kind();
+    public abstract Kind kind();
 
-    abstract Element element();
+    public abstract Element element();
 
-    abstract ImmutableSet<DependencyRequest> dependencies();
+    public abstract ImmutableSet<DependencyRequest> dependencies();
 
     /**
      * Returns the index of {@link #element()} in its parents {@code @Inject} members that have the
@@ -114,7 +114,7 @@ boolean requiresModuleInstance() {
      * consistent independent of whether the build system uses header jars or not.
      */
     @Memoized
-    int indexAmongAtInjectMembersWithSameSimpleName() {
+    public int indexAmongAtInjectMembersWithSameSimpleName() {
       return element()
           .getEnclosingElement()
           .getEnclosedElements()
@@ -126,12 +126,12 @@ int indexAmongAtInjectMembersWithSameSimpleName() {
           .indexOf(element());
     }
 
-    static InjectionSite field(VariableElement element, DependencyRequest dependency) {
+    public static InjectionSite field(VariableElement element, DependencyRequest dependency) {
       return new AutoValue_MembersInjectionBinding_InjectionSite(
           Kind.FIELD, element, ImmutableSet.of(dependency));
     }
 
-    static InjectionSite method(
+    public static InjectionSite method(
         ExecutableElement element, Iterable<DependencyRequest> dependencies) {
       return new AutoValue_MembersInjectionBinding_InjectionSite(
           Kind.METHOD, element, ImmutableSet.copyOf(dependencies));
diff --git a/java/dagger/internal/codegen/MethodSignature.java b/java/dagger/internal/codegen/binding/MethodSignature.java
similarity index 76%
rename from java/dagger/internal/codegen/MethodSignature.java
rename to java/dagger/internal/codegen/binding/MethodSignature.java
index 1a5707743..00643a575 100644
--- a/java/dagger/internal/codegen/MethodSignature.java
+++ b/java/dagger/internal/codegen/binding/MethodSignature.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableList;
 
@@ -22,23 +22,25 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableList;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.binding.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import java.util.List;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 
+/** A class that defines proper {@code equals} and {@code hashcode} for a method signature. */
 @AutoValue
-abstract class MethodSignature {
+public abstract class MethodSignature {
 
-  abstract String name();
+  public abstract String name();
 
-  abstract ImmutableList<? extends Equivalence.Wrapper<? extends TypeMirror>> parameterTypes();
+  public abstract ImmutableList<? extends Equivalence.Wrapper<? extends TypeMirror>>
+      parameterTypes();
 
-  abstract ImmutableList<? extends Equivalence.Wrapper<? extends TypeMirror>> thrownTypes();
+  public abstract ImmutableList<? extends Equivalence.Wrapper<? extends TypeMirror>> thrownTypes();
 
-  static MethodSignature forComponentMethod(
+  public static MethodSignature forComponentMethod(
       ComponentMethodDescriptor componentMethod, DeclaredType componentType, DaggerTypes types) {
     ExecutableType methodType =
         MoreTypes.asExecutable(types.asMemberOf(componentType, componentMethod.methodElement()));
diff --git a/java/dagger/internal/codegen/MethodSignatureFormatter.java b/java/dagger/internal/codegen/binding/MethodSignatureFormatter.java
similarity index 92%
rename from java/dagger/internal/codegen/MethodSignatureFormatter.java
rename to java/dagger/internal/codegen/binding/MethodSignatureFormatter.java
index 07f3f841c..afa259544 100644
--- a/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/java/dagger/internal/codegen/binding/MethodSignatureFormatter.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.base.DiagnosticFormatting.stripCommonTypePrefixes;
@@ -36,14 +36,12 @@
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 
-/**
- * Formats the signature of an {@link ExecutableElement} suitable for use in error messages.
- */
-final class MethodSignatureFormatter extends Formatter<ExecutableElement> {
+/** Formats the signature of an {@link ExecutableElement} suitable for use in error messages. */
+public final class MethodSignatureFormatter extends Formatter<ExecutableElement> {
   private final DaggerTypes types;
 
   @Inject
-  MethodSignatureFormatter(DaggerTypes types) {
+  public MethodSignatureFormatter(DaggerTypes types) {
     this.types = types;
   }
 
@@ -51,7 +49,7 @@
    * A formatter that uses the type where the method is declared for the annotations and name of the
    * method, but the method's resolved type as a member of {@code declaredType} for the key.
    */
-  Formatter<ExecutableElement> typedFormatter(DeclaredType declaredType) {
+  public Formatter<ExecutableElement> typedFormatter(DeclaredType declaredType) {
     return new Formatter<ExecutableElement>() {
       @Override
       public String format(ExecutableElement method) {
@@ -63,7 +61,8 @@ public String format(ExecutableElement method) {
     };
   }
 
-  @Override public String format(ExecutableElement method) {
+  @Override
+  public String format(ExecutableElement method) {
     return format(method, Optional.empty());
   }
 
diff --git a/java/dagger/internal/codegen/ModuleDescriptor.java b/java/dagger/internal/codegen/binding/ModuleDescriptor.java
similarity index 93%
rename from java/dagger/internal/codegen/ModuleDescriptor.java
rename to java/dagger/internal/codegen/binding/ModuleDescriptor.java
index 3ec3d4d6f..cd071a4bc 100644
--- a/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/java/dagger/internal/codegen/binding/ModuleDescriptor.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
@@ -22,9 +22,9 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.transform;
-import static dagger.internal.codegen.SourceFiles.classFileName;
 import static dagger.internal.codegen.base.ModuleAnnotation.moduleAnnotation;
 import static dagger.internal.codegen.base.Util.reentrantComputeIfAbsent;
+import static dagger.internal.codegen.binding.SourceFiles.classFileName;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.langmodel.DaggerElements.isAnnotationPresent;
 import static javax.lang.model.type.TypeKind.DECLARED;
@@ -58,14 +58,15 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
+/** Contains metadata that describes a module. */
 @AutoValue
-abstract class ModuleDescriptor {
+public abstract class ModuleDescriptor {
 
-  abstract TypeElement moduleElement();
+  public abstract TypeElement moduleElement();
 
   abstract ImmutableSet<TypeElement> includedModules();
 
-  abstract ImmutableSet<ContributionBinding> bindings();
+  public abstract ImmutableSet<ContributionBinding> bindings();
 
   /** The multibinding declarations contained in this module. */
   abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
@@ -80,11 +81,11 @@
   abstract ImmutableSet<OptionalBindingDeclaration> optionalDeclarations();
 
   /** The kind of the module. */
-  abstract ModuleKind kind();
+  public abstract ModuleKind kind();
 
   /** Returns all of the bindings declared in this module. */
   @Memoized
-  ImmutableSet<BindingDeclaration> allBindingDeclarations() {
+  public ImmutableSet<BindingDeclaration> allBindingDeclarations() {
     return ImmutableSet.<BindingDeclaration>builder()
         .addAll(bindings())
         .addAll(delegateDeclarations())
@@ -99,8 +100,9 @@
     return allBindingDeclarations().stream().map(BindingDeclaration::key).collect(toImmutableSet());
   }
 
+  /** A {@link ModuleDescriptor} factory. */
   @Singleton
-  static final class Factory implements ClearableCache {
+  public static final class Factory implements ClearableCache {
     private final DaggerElements elements;
     private final BindingFactory bindingFactory;
     private final MultibindingDeclaration.Factory multibindingDeclarationFactory;
@@ -125,11 +127,11 @@
       this.optionalBindingDeclarationFactory = optionalBindingDeclarationFactory;
     }
 
-    ModuleDescriptor create(TypeElement moduleElement) {
+    public ModuleDescriptor create(TypeElement moduleElement) {
       return reentrantComputeIfAbsent(cache, moduleElement, this::createUncached);
     }
 
-    ModuleDescriptor createUncached(TypeElement moduleElement) {
+    public ModuleDescriptor createUncached(TypeElement moduleElement) {
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
       ImmutableSet.Builder<DelegateDeclaration> delegates = ImmutableSet.builder();
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
diff --git a/java/dagger/internal/codegen/ModuleKind.java b/java/dagger/internal/codegen/binding/ModuleKind.java
similarity index 87%
rename from java/dagger/internal/codegen/ModuleKind.java
rename to java/dagger/internal/codegen/binding/ModuleKind.java
index 50b0667a2..3737041e7 100644
--- a/java/dagger/internal/codegen/ModuleKind.java
+++ b/java/dagger/internal/codegen/binding/ModuleKind.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableSet;
@@ -33,7 +33,7 @@
 import javax.lang.model.element.TypeElement;
 
 /** Enumeration of the kinds of modules. */
-enum ModuleKind {
+public enum ModuleKind {
   /** {@code @Module} */
   MODULE(Module.class),
 
@@ -41,7 +41,7 @@
   PRODUCER_MODULE(ProducerModule.class);
 
   /** Returns the annotations for modules of the given kinds. */
-  static ImmutableSet<Class<? extends Annotation>> annotationsFor(Set<ModuleKind> kinds) {
+  public static ImmutableSet<Class<? extends Annotation>> annotationsFor(Set<ModuleKind> kinds) {
     return kinds.stream().map(ModuleKind::annotation).collect(toImmutableSet());
   }
 
@@ -52,7 +52,7 @@
    * @throws IllegalArgumentException if the element is annotated with more than one of the module
    *     annotations
    */
-  static Optional<ModuleKind> forAnnotatedElement(TypeElement element) {
+  public static Optional<ModuleKind> forAnnotatedElement(TypeElement element) {
     Set<ModuleKind> kinds = EnumSet.noneOf(ModuleKind.class);
     for (ModuleKind kind : values()) {
       if (MoreElements.isAnnotationPresent(element, kind.annotation())) {
@@ -67,7 +67,7 @@
     return kinds.stream().findAny();
   }
 
-  static void checkIsModule(TypeElement moduleElement) {
+  public static void checkIsModule(TypeElement moduleElement) {
     checkArgument(forAnnotatedElement(moduleElement).isPresent());
   }
 
@@ -82,7 +82,7 @@ static void checkIsModule(TypeElement moduleElement) {
    *
    * @throws IllegalArgumentException if the annotation is not present on the type
    */
-  AnnotationMirror getModuleAnnotation(TypeElement element) {
+  public AnnotationMirror getModuleAnnotation(TypeElement element) {
     Optional<AnnotationMirror> result = getAnnotationMirror(element, moduleAnnotation);
     checkArgument(
         result.isPresent(), "annotation %s is not present on type %s", moduleAnnotation, element);
@@ -90,12 +90,12 @@ AnnotationMirror getModuleAnnotation(TypeElement element) {
   }
 
   /** Returns the annotation that marks a module of this kind. */
-  Class<? extends Annotation> annotation() {
+  public Class<? extends Annotation> annotation() {
     return moduleAnnotation;
   }
 
   /** Returns the kinds of modules that a module of this kind is allowed to include. */
-  ImmutableSet<ModuleKind> legalIncludedModuleKinds() {
+  public ImmutableSet<ModuleKind> legalIncludedModuleKinds() {
     switch (this) {
       case MODULE:
         return Sets.immutableEnumSet(MODULE);
diff --git a/java/dagger/internal/codegen/MultibindingDeclaration.java b/java/dagger/internal/codegen/binding/MultibindingDeclaration.java
similarity index 94%
rename from java/dagger/internal/codegen/MultibindingDeclaration.java
rename to java/dagger/internal/codegen/binding/MultibindingDeclaration.java
index da058c609..f1d3f8d75 100644
--- a/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/java/dagger/internal/codegen/binding/MultibindingDeclaration.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
@@ -45,7 +45,8 @@
  * method annotated with {@link Multibinds @Multibinds}.
  */
 @AutoValue
-abstract class MultibindingDeclaration extends BindingDeclaration implements HasContributionType {
+public abstract class MultibindingDeclaration extends BindingDeclaration
+    implements HasContributionType {
 
   /**
    * The map or set key whose availability is declared. For maps, this will be {@code Map<K,
@@ -68,10 +69,8 @@
   @Override
   public abstract boolean equals(Object obj);
 
-  /**
-   * A factory for {@link MultibindingDeclaration}s.
-   */
-  static final class Factory {
+  /** A factory for {@link MultibindingDeclaration}s. */
+  public static final class Factory {
     private final DaggerTypes types;
     private final KeyFactory keyFactory;
 
diff --git a/java/dagger/internal/codegen/OptionalBindingDeclaration.java b/java/dagger/internal/codegen/binding/OptionalBindingDeclaration.java
similarity index 98%
rename from java/dagger/internal/codegen/OptionalBindingDeclaration.java
rename to java/dagger/internal/codegen/binding/OptionalBindingDeclaration.java
index b26ab9175..d7ba7bcfc 100644
--- a/java/dagger/internal/codegen/OptionalBindingDeclaration.java
+++ b/java/dagger/internal/codegen/binding/OptionalBindingDeclaration.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
diff --git a/java/dagger/internal/codegen/ProductionBinding.java b/java/dagger/internal/codegen/binding/ProductionBinding.java
similarity index 81%
rename from java/dagger/internal/codegen/ProductionBinding.java
rename to java/dagger/internal/codegen/binding/ProductionBinding.java
index 3f9895984..80b3b01a7 100644
--- a/java/dagger/internal/codegen/ProductionBinding.java
+++ b/java/dagger/internal/codegen/binding/ProductionBinding.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.langmodel.DaggerTypes.isFutureType;
@@ -33,11 +33,9 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.TypeMirror;
 
-/**
- * A value object representing the mechanism by which a {@link Key} can be produced.
- */
+/** A value object representing the mechanism by which a {@link Key} can be produced. */
 @AutoValue
-abstract class ProductionBinding extends ContributionBinding {
+public abstract class ProductionBinding extends ContributionBinding {
 
   @Override
   public BindingType bindingType() {
@@ -45,10 +43,10 @@ public BindingType bindingType() {
   }
 
   @Override
-  abstract Optional<ProductionBinding> unresolved();
+  public abstract Optional<ProductionBinding> unresolved();
 
   @Override
-  ImmutableSet<DependencyRequest> implicitDependencies() {
+  public ImmutableSet<DependencyRequest> implicitDependencies() {
     return Stream.of(executorRequest(), monitorRequest())
         .filter(Optional::isPresent)
         .map(Optional::get)
@@ -56,7 +54,7 @@ public BindingType bindingType() {
   }
 
   /** What kind of object a {@code @Produces}-annotated method returns. */
-  enum ProductionKind {
+  public enum ProductionKind {
     /** A value. */
     IMMEDIATE,
     /** A {@code ListenableFuture<T>}. */
@@ -65,7 +63,7 @@ public BindingType bindingType() {
     SET_OF_FUTURE;
 
     /** Returns the kind of object a {@code @Produces}-annotated method returns. */
-    static ProductionKind fromProducesMethod(ExecutableElement producesMethod) {
+    public static ProductionKind fromProducesMethod(ExecutableElement producesMethod) {
       if (isFutureType(producesMethod.getReturnType())) {
         return FUTURE;
       } else if (ContributionType.fromBindingElement(producesMethod)
@@ -83,10 +81,10 @@ static ProductionKind fromProducesMethod(ExecutableElement producesMethod) {
    * {@code @Produces} methods will have a production kind, but synthetic production bindings may
    * not.
    */
-  abstract Optional<ProductionKind> productionKind();
+  public abstract Optional<ProductionKind> productionKind();
 
   /** Returns the list of types in the throws clause of the method. */
-  abstract ImmutableList<? extends TypeMirror> thrownTypes();
+  public abstract ImmutableList<? extends TypeMirror> thrownTypes();
 
   /**
    * If this production requires an executor, this will be the corresponding request.  All
@@ -105,11 +103,11 @@ static ProductionKind fromProducesMethod(ExecutableElement producesMethod) {
   // performance improvement for large components.
   @Memoized
   @Override
-  boolean requiresModuleInstance() {
+  public boolean requiresModuleInstance() {
     return super.requiresModuleInstance();
   }
 
-  static Builder builder() {
+  public static Builder builder() {
     return new AutoValue_ProductionBinding.Builder()
         .explicitDependencies(ImmutableList.<DependencyRequest>of())
         .thrownTypes(ImmutableList.<TypeMirror>of());
@@ -123,12 +121,14 @@ static Builder builder() {
   @Override
   public abstract boolean equals(Object obj);
 
+  /** A {@link ProductionBinding} builder. */
   @AutoValue.Builder
   @CanIgnoreReturnValue
-  abstract static class Builder extends ContributionBinding.Builder<ProductionBinding, Builder> {
+  public abstract static class Builder
+      extends ContributionBinding.Builder<ProductionBinding, Builder> {
 
     @Override
-    Builder dependencies(Iterable<DependencyRequest> dependencies) {
+    public Builder dependencies(Iterable<DependencyRequest> dependencies) {
       return explicitDependencies(dependencies);
     }
 
@@ -137,7 +137,7 @@ Builder dependencies(Iterable<DependencyRequest> dependencies) {
     abstract Builder productionKind(ProductionKind productionKind);
 
     @Override
-    abstract Builder unresolved(ProductionBinding unresolved);
+    public abstract Builder unresolved(ProductionBinding unresolved);
 
     abstract Builder thrownTypes(Iterable<? extends TypeMirror> thrownTypes);
 
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/binding/ProvisionBinding.java
similarity index 74%
rename from java/dagger/internal/codegen/ProvisionBinding.java
rename to java/dagger/internal/codegen/binding/ProvisionBinding.java
index 22a18ddf5..c0d52b356 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/binding/ProvisionBinding.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static dagger.internal.codegen.extension.DaggerStreams.toImmutableSet;
 import static dagger.model.BindingKind.COMPONENT_PROVISION;
@@ -25,7 +25,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+import dagger.internal.codegen.binding.MembersInjectionBinding.InjectionSite;
 import dagger.internal.codegen.compileroption.CompilerOptions;
 import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
@@ -33,15 +33,13 @@
 import dagger.model.Scope;
 import java.util.Optional;
 
-/**
- * A value object representing the mechanism by which a {@link Key} can be provided.
- */
+/** A value object representing the mechanism by which a {@link Key} can be provided. */
 @AutoValue
-abstract class ProvisionBinding extends ContributionBinding {
+public abstract class ProvisionBinding extends ContributionBinding {
 
   @Override
   @Memoized
-  ImmutableSet<DependencyRequest> explicitDependencies() {
+  public ImmutableSet<DependencyRequest> explicitDependencies() {
     return ImmutableSet.<DependencyRequest>builder()
         .addAll(provisionDependencies())
         .addAll(membersInjectionDependencies())
@@ -51,7 +49,7 @@
   /**
    * Dependencies necessary to invoke an {@code @Inject} constructor or {@code @Provides} method.
    */
-  abstract ImmutableSet<DependencyRequest> provisionDependencies();
+  public abstract ImmutableSet<DependencyRequest> provisionDependencies();
 
   @Memoized
   ImmutableSet<DependencyRequest> membersInjectionDependencies() {
@@ -65,7 +63,7 @@
    * {@link InjectionSite}s for all {@code @Inject} members if {@link #kind()} is {@link
    * BindingKind#INJECTION}, otherwise empty.
    */
-  abstract ImmutableSortedSet<InjectionSite> injectionSites();
+  public abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
   @Override
   public BindingType bindingType() {
@@ -73,25 +71,25 @@ public BindingType bindingType() {
   }
 
   @Override
-  abstract Optional<ProvisionBinding> unresolved();
+  public abstract Optional<ProvisionBinding> unresolved();
 
   // TODO(ronshapiro): we should be able to remove this, but AutoValue barks on the Builder's scope
   // method, saying that the method doesn't correspond to a property of ProvisionBinding
   @Override
   public abstract Optional<Scope> scope();
 
-  static Builder builder() {
+  public static Builder builder() {
     return new AutoValue_ProvisionBinding.Builder()
         .provisionDependencies(ImmutableSet.of())
         .injectionSites(ImmutableSortedSet.of());
   }
 
-  abstract Builder toBuilder();
+  public abstract Builder toBuilder();
 
   private static final ImmutableSet<BindingKind> KINDS_TO_CHECK_FOR_NULL =
       ImmutableSet.of(PROVISION, COMPONENT_PROVISION);
 
-  boolean shouldCheckForNull(CompilerOptions compilerOptions) {
+  public boolean shouldCheckForNull(CompilerOptions compilerOptions) {
     return KINDS_TO_CHECK_FOR_NULL.contains(kind())
         && !contributedPrimitiveType().isPresent()
         && !nullableType().isPresent()
@@ -102,7 +100,7 @@ boolean shouldCheckForNull(CompilerOptions compilerOptions) {
   // performance improvement for large components.
   @Memoized
   @Override
-  boolean requiresModuleInstance() {
+  public boolean requiresModuleInstance() {
     return super.requiresModuleInstance();
   }
 
@@ -114,23 +112,25 @@ boolean requiresModuleInstance() {
   @Override
   public abstract boolean equals(Object obj);
 
+  /** A {@link ProvisionBinding} builder. */
   @AutoValue.Builder
   @CanIgnoreReturnValue
-  abstract static class Builder extends ContributionBinding.Builder<ProvisionBinding, Builder> {
+  public abstract static class Builder
+      extends ContributionBinding.Builder<ProvisionBinding, Builder> {
 
     @Override
-    Builder dependencies(Iterable<DependencyRequest> dependencies) {
+    public Builder dependencies(Iterable<DependencyRequest> dependencies) {
       return provisionDependencies(dependencies);
     }
 
     abstract Builder provisionDependencies(Iterable<DependencyRequest> provisionDependencies);
 
-    abstract Builder injectionSites(ImmutableSortedSet<InjectionSite> injectionSites);
+    public abstract Builder injectionSites(ImmutableSortedSet<InjectionSite> injectionSites);
 
     @Override
-    abstract Builder unresolved(ProvisionBinding unresolved);
+    public abstract Builder unresolved(ProvisionBinding unresolved);
 
-    abstract Builder scope(Optional<Scope> scope);
+    public abstract Builder scope(Optional<Scope> scope);
   }
 
 }
diff --git a/java/dagger/internal/codegen/ResolvedBindings.java b/java/dagger/internal/codegen/binding/ResolvedBindings.java
similarity index 89%
rename from java/dagger/internal/codegen/ResolvedBindings.java
rename to java/dagger/internal/codegen/binding/ResolvedBindings.java
index 30635a766..bed7f01e3 100644
--- a/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/java/dagger/internal/codegen/binding/ResolvedBindings.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
@@ -46,11 +46,9 @@
  * component has a members injection method, and the type is also requested normally.)
  */
 @AutoValue
-abstract class ResolvedBindings implements HasContributionType {
-  /**
-   * The binding key for which the {@link #bindings()} have been resolved.
-   */
-  abstract Key key();
+public abstract class ResolvedBindings implements HasContributionType {
+  /** The binding key for which the {@link #bindings()} have been resolved. */
+  public abstract Key key();
 
   /**
    * The {@link ContributionBinding}s for {@link #key()} indexed by the component that owns the
@@ -65,15 +63,13 @@
   abstract ImmutableMap<TypeElement, MembersInjectionBinding> allMembersInjectionBindings();
 
   /** The multibinding declarations for {@link #key()}. */
-  abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
+  public abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
 
   /** The subcomponent declarations for {@link #key()}. */
   abstract ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations();
 
-  /**
-   * The optional binding declarations for {@link #key()}.
-   */
-  abstract ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations();
+  /** The optional binding declarations for {@link #key()}. */
+  public abstract ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations();
 
   // Computing the hash code is an expensive operation.
   @Memoized
@@ -92,7 +88,7 @@
   }
 
   /** All bindings for {@link #key()}, regardless of which component owns them. */
-  final ImmutableCollection<? extends Binding> bindings() {
+  public final ImmutableCollection<? extends Binding> bindings() {
     return allBindings().values();
   }
 
@@ -102,7 +98,7 @@
    * @throws IllegalStateException if there is not exactly one element in {@link #bindings()}, which
    *     will never happen for contributions in valid graphs
    */
-  final Binding binding() {
+  public final Binding binding() {
     return getOnlyElement(bindings());
   }
 
@@ -110,7 +106,7 @@ final Binding binding() {
    * {@code true} if there are no {@link #bindings()}, {@link #multibindingDeclarations()}, {@link
    * #optionalBindingDeclarations()}, or {@link #subcomponentDeclarations()}.
    */
-  final boolean isEmpty() {
+  public final boolean isEmpty() {
     return allMembersInjectionBindings().isEmpty()
         && allContributionBindings().isEmpty()
         && multibindingDeclarations().isEmpty()
@@ -119,7 +115,7 @@ final boolean isEmpty() {
   }
 
   /** All bindings for {@link #key()} that are owned by a component. */
-  ImmutableSet<? extends Binding> bindingsOwnedBy(ComponentDescriptor component) {
+  public ImmutableSet<? extends Binding> bindingsOwnedBy(ComponentDescriptor component) {
     return allBindings().get(component.typeElement());
   }
 
@@ -128,7 +124,7 @@ final boolean isEmpty() {
    * binding.
    */
   @Memoized
-  ImmutableSet<ContributionBinding> contributionBindings() {
+  public ImmutableSet<ContributionBinding> contributionBindings() {
     // TODO(ronshapiro): consider optimizing ImmutableSet.copyOf(Collection) for small immutable
     // collections so that it doesn't need to call toArray(). Even though this method is memoized,
     // toArray() can take ~150ms for large components, and there are surely other places in the
@@ -150,7 +146,7 @@ final TypeElement owningComponent(ContributionBinding binding) {
    * The members-injection binding, regardless of owning component. Absent if these are contribution
    * bindings, or if there is no members-injection binding because the type fails validation.
    */
-  final Optional<MembersInjectionBinding> membersInjectionBinding() {
+  public final Optional<MembersInjectionBinding> membersInjectionBinding() {
     return allMembersInjectionBindings().isEmpty()
         ? Optional.empty()
         : Optional.of(Iterables.getOnlyElement(allMembersInjectionBindings().values()));
@@ -204,10 +200,10 @@ static ResolvedBindings noBindings(Key key) {
   /**
    * Returns the single contribution binding.
    *
-   * @throws IllegalStateException if there is not exactly one element in
-   *     {@link #contributionBindings()}, which will never happen for contributions in valid graphs
+   * @throws IllegalStateException if there is not exactly one element in {@link
+   *     #contributionBindings()}, which will never happen for contributions in valid graphs
    */
-  ContributionBinding contributionBinding() {
+  public ContributionBinding contributionBinding() {
     return getOnlyElement(contributionBindings());
   }
 
@@ -217,7 +213,7 @@ ContributionBinding contributionBinding() {
    *
    * @throws IllegalStateException if {@link #isEmpty()} or the binding types conflict
    */
-  final BindingType bindingType() {
+  public final BindingType bindingType() {
     checkState(!isEmpty(), "empty bindings for %s", key());
     if (allBindings().isEmpty()
         && (!multibindingDeclarations().isEmpty() || !subcomponentDeclarations().isEmpty())) {
@@ -251,7 +247,7 @@ public ContributionType contributionType() {
    *
    * @throws IllegalStateException if {@link #bindings()} does not have exactly one element
    */
-  Optional<Scope> scope() {
+  public Optional<Scope> scope() {
     return binding().scope();
   }
 }
diff --git a/java/dagger/internal/codegen/SourceFiles.java b/java/dagger/internal/codegen/binding/SourceFiles.java
similarity index 88%
rename from java/dagger/internal/codegen/SourceFiles.java
rename to java/dagger/internal/codegen/binding/SourceFiles.java
index 0fdf642ec..3dc70a33c 100644
--- a/java/dagger/internal/codegen/SourceFiles.java
+++ b/java/dagger/internal/codegen/binding/SourceFiles.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
@@ -68,7 +68,7 @@
 import javax.lang.model.element.TypeParameterElement;
 
 /** Utilities for generating files. */
-class SourceFiles {
+public class SourceFiles {
 
   private static final Joiner CLASS_FILE_NAME_JOINER = Joiner.on('_');
 
@@ -77,15 +77,15 @@
    * all of the dependencies of {@code binding}. It is responsible for choosing a name that
    *
    * <ul>
-   * <li>represents all of the dependency requests for this key
-   * <li>is <i>probably</i> associated with the type being bound
-   * <li>is unique within the class
+   *   <li>represents all of the dependency requests for this key
+   *   <li>is <i>probably</i> associated with the type being bound
+   *   <li>is unique within the class
    * </ul>
    *
    * @param binding must be an unresolved binding (type parameters must match its type element's)
    */
-  static ImmutableMap<DependencyRequest, FrameworkField> generateBindingFieldsForDependencies(
-      Binding binding) {
+  public static ImmutableMap<DependencyRequest, FrameworkField>
+      generateBindingFieldsForDependencies(Binding binding) {
     checkArgument(!binding.unresolved().isPresent(), "binding must be unresolved: %s", binding);
 
     FrameworkTypeMapper frameworkTypeMapper =
@@ -101,7 +101,7 @@
                 DependencyVariableNamer.name(dependency)));
   }
 
-  static CodeBlock frameworkTypeUsageStatement(
+  public static CodeBlock frameworkTypeUsageStatement(
       CodeBlock frameworkTypeMemberSelect, RequestKind dependencyKind) {
     switch (dependencyKind) {
       case LAZY:
@@ -123,7 +123,7 @@ static CodeBlock frameworkTypeUsageStatement(
    * Returns a mapping of {@link DependencyRequest}s to {@link CodeBlock}s that {@linkplain
    * #frameworkTypeUsageStatement(CodeBlock, RequestKind) use them}.
    */
-  static ImmutableMap<DependencyRequest, CodeBlock> frameworkFieldUsages(
+  public static ImmutableMap<DependencyRequest, CodeBlock> frameworkFieldUsages(
       ImmutableSet<DependencyRequest> dependencies,
       ImmutableMap<DependencyRequest, FieldSpec> fields) {
     return Maps.toMap(
@@ -132,7 +132,7 @@ static CodeBlock frameworkTypeUsageStatement(
   }
 
   /** Returns the generated factory or members injector name for a binding. */
-  static ClassName generatedClassNameForBinding(Binding binding) {
+  public static ClassName generatedClassNameForBinding(Binding binding) {
     switch (binding.bindingType()) {
       case PROVISION:
       case PRODUCTION:
@@ -162,7 +162,7 @@ static ClassName generatedClassNameForBinding(Binding binding) {
    * <p>This will always return a {@linkplain ClassName#topLevelClassName() top level class name},
    * even if {@code element}'s enclosing class is a nested type.
    */
-  static ClassName elementBasedClassName(ExecutableElement element, String suffix) {
+  public static ClassName elementBasedClassName(ExecutableElement element, String suffix) {
     ClassName enclosingClassName =
         ClassName.get(MoreElements.asType(element.getEnclosingElement()));
     String methodName =
@@ -174,7 +174,7 @@ static ClassName elementBasedClassName(ExecutableElement element, String suffix)
         classFileName(enclosingClassName) + "_" + methodName + suffix);
   }
 
-  static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
+  public static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
     ClassName className = generatedClassNameForBinding(binding);
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
     return typeParameters.isEmpty()
@@ -182,16 +182,15 @@ static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
         : ParameterizedTypeName.get(className, Iterables.toArray(typeParameters, TypeName.class));
   }
 
-  static ClassName membersInjectorNameForType(TypeElement typeElement) {
+  public static ClassName membersInjectorNameForType(TypeElement typeElement) {
     return siblingClassName(typeElement,  "_MembersInjector");
   }
 
-  static String classFileName(ClassName className) {
+  public static String classFileName(ClassName className) {
     return CLASS_FILE_NAME_JOINER.join(className.simpleNames());
   }
 
-  static ClassName generatedMonitoringModuleName(
-      TypeElement componentElement) {
+  public static ClassName generatedMonitoringModuleName(TypeElement componentElement) {
     return siblingClassName(componentElement, "_MonitoringModule");
   }
 
@@ -211,7 +210,7 @@ private static ClassName siblingClassName(TypeElement typeElement, String suffix
    *   <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
    * </ul>
    */
-  static ClassName setFactoryClassName(ContributionBinding binding) {
+  public static ClassName setFactoryClassName(ContributionBinding binding) {
     checkArgument(binding.kind().equals(MULTIBOUND_SET));
     if (binding.bindingType().equals(BindingType.PROVISION)) {
       return SET_FACTORY;
@@ -222,7 +221,7 @@ static ClassName setFactoryClassName(ContributionBinding binding) {
   }
 
   /** The {@link java.util.Map} factory class name appropriate for map bindings. */
-  static ClassName mapFactoryClassName(ContributionBinding binding) {
+  public static ClassName mapFactoryClassName(ContributionBinding binding) {
     checkState(binding.kind().equals(MULTIBOUND_MAP), binding.kind());
     MapType mapType = MapType.from(binding.key());
     switch (binding.bindingType()) {
@@ -239,7 +238,8 @@ static ClassName mapFactoryClassName(ContributionBinding binding) {
     }
   }
 
-  static ImmutableList<TypeVariableName> bindingTypeElementTypeVariableNames(Binding binding) {
+  public static ImmutableList<TypeVariableName> bindingTypeElementTypeVariableNames(
+      Binding binding) {
     if (binding instanceof ContributionBinding) {
       ContributionBinding contributionBinding = (ContributionBinding) binding;
       if (!contributionBinding.kind().equals(INJECTION)
@@ -258,14 +258,14 @@ static ClassName mapFactoryClassName(ContributionBinding binding) {
    * readable.
    */
   // TODO(gak): maybe this should be a function of TypeMirrors instead of Elements?
-  static String simpleVariableName(TypeElement typeElement) {
+  public static String simpleVariableName(TypeElement typeElement) {
     String candidateName = UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
     String variableName = protectAgainstKeywords(candidateName);
     verify(isName(variableName), "'%s' was expected to be a valid variable name");
     return variableName;
   }
 
-  static String protectAgainstKeywords(String candidateName) {
+  public static String protectAgainstKeywords(String candidateName) {
     switch (candidateName) {
       case "package":
         return "pkg";
diff --git a/java/dagger/internal/codegen/SubcomponentCreatorBindingEdgeImpl.java b/java/dagger/internal/codegen/binding/SubcomponentCreatorBindingEdgeImpl.java
similarity index 93%
rename from java/dagger/internal/codegen/SubcomponentCreatorBindingEdgeImpl.java
rename to java/dagger/internal/codegen/binding/SubcomponentCreatorBindingEdgeImpl.java
index 0fe4ef2c7..93e79b5b9 100644
--- a/java/dagger/internal/codegen/SubcomponentCreatorBindingEdgeImpl.java
+++ b/java/dagger/internal/codegen/binding/SubcomponentCreatorBindingEdgeImpl.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.extension.DaggerStreams.presentValues;
@@ -26,7 +26,7 @@
 import javax.lang.model.element.TypeElement;
 
 /** An implementation of {@link SubcomponentCreatorBindingEdge}. */
-final class SubcomponentCreatorBindingEdgeImpl implements SubcomponentCreatorBindingEdge {
+public final class SubcomponentCreatorBindingEdgeImpl implements SubcomponentCreatorBindingEdge {
 
   private final ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations;
 
diff --git a/java/dagger/internal/codegen/SubcomponentDeclaration.java b/java/dagger/internal/codegen/binding/SubcomponentDeclaration.java
similarity index 88%
rename from java/dagger/internal/codegen/SubcomponentDeclaration.java
rename to java/dagger/internal/codegen/binding/SubcomponentDeclaration.java
index 451847a63..4f1f3efd2 100644
--- a/java/dagger/internal/codegen/SubcomponentDeclaration.java
+++ b/java/dagger/internal/codegen/binding/SubcomponentDeclaration.java
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package dagger.internal.codegen;
+package dagger.internal.codegen.binding;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationElementAndValue;
-import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentCreator;
+import static dagger.internal.codegen.binding.ConfigurationAnnotations.getSubcomponentCreator;
 
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
@@ -34,7 +34,7 @@
  * dagger.Module#subcomponents()}.
  */
 @AutoValue
-abstract class SubcomponentDeclaration extends BindingDeclaration {
+public abstract class SubcomponentDeclaration extends BindingDeclaration {
   /**
    * Key for the {@link dagger.Subcomponent.Builder} or {@link
    * dagger.producers.ProductionSubcomponent.Builder} of {@link #subcomponentType()}.
@@ -49,7 +49,7 @@
   abstract TypeElement subcomponentType();
 
   /** The module annotation. */
-  abstract ModuleAnnotation moduleAnnotation();
+  public abstract ModuleAnnotation moduleAnnotation();
 
   @Memoized
   @Override
@@ -58,7 +58,8 @@
   @Override
   public abstract boolean equals(Object obj);
 
-  static class Factory {
+  /** A {@link SubcomponentDeclaration} factory. */
+  public static class Factory {
     private final KeyFactory keyFactory;
 
     @Inject
diff --git a/javatests/dagger/internal/codegen/BUILD b/javatests/dagger/internal/codegen/BUILD
index 8a58c3d8c..707b19cd6 100644
--- a/javatests/dagger/internal/codegen/BUILD
+++ b/javatests/dagger/internal/codegen/BUILD
@@ -27,13 +27,13 @@ GenJavaTests(
     javacopts = DOCLINT_HTML_AND_SYNTAX,
     deps = [
         "//java/dagger:core",
-        "//java/dagger/internal/codegen:binding",
         "//java/dagger/internal/codegen:binding_graph_validation",
         "//java/dagger/internal/codegen:package_info",
         "//java/dagger/internal/codegen:processor",
         "//java/dagger/internal/codegen:validation",
         "//java/dagger/internal/codegen:writing",
         "//java/dagger/internal/codegen/base",
+        "//java/dagger/internal/codegen/binding",
         "//java/dagger/internal/codegen/compileroption",
         "//java/dagger/internal/codegen/javapoet",
         "//java/dagger/internal/codegen/langmodel",
diff --git a/javatests/dagger/internal/codegen/ComponentBuilderTest.java b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
index 49b01d115..206419e75 100644
--- a/javatests/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
@@ -18,12 +18,13 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.COMPONENT_BUILDER;
-import static dagger.internal.codegen.ErrorMessages.creatorMessagesFor;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_CODE_ANNOTATIONS;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.COMPONENT_BUILDER;
+import static dagger.internal.codegen.binding.ErrorMessages.creatorMessagesFor;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.binding.ErrorMessages;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
diff --git a/javatests/dagger/internal/codegen/ComponentCreatorTest.java b/javatests/dagger/internal/codegen/ComponentCreatorTest.java
index e447fdfc6..e3d4c3c8e 100644
--- a/javatests/dagger/internal/codegen/ComponentCreatorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentCreatorTest.java
@@ -21,20 +21,21 @@
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
 import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.COMPONENT_BUILDER;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.COMPONENT_FACTORY;
-import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
-import static dagger.internal.codegen.ComponentCreatorKind.FACTORY;
-import static dagger.internal.codegen.ComponentKind.COMPONENT;
-import static dagger.internal.codegen.ErrorMessages.componentMessagesFor;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_CODE_ANNOTATIONS;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.COMPONENT_BUILDER;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.COMPONENT_FACTORY;
+import static dagger.internal.codegen.binding.ComponentCreatorKind.BUILDER;
+import static dagger.internal.codegen.binding.ComponentCreatorKind.FACTORY;
+import static dagger.internal.codegen.binding.ComponentKind.COMPONENT;
+import static dagger.internal.codegen.binding.ErrorMessages.componentMessagesFor;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.binding.ComponentCreatorAnnotation;
 import java.util.Collection;
 import java.util.List;
 import java.util.Set;
diff --git a/javatests/dagger/internal/codegen/ComponentCreatorTestHelper.java b/javatests/dagger/internal/codegen/ComponentCreatorTestHelper.java
index 2ee120ea2..0a4e452f9 100644
--- a/javatests/dagger/internal/codegen/ComponentCreatorTestHelper.java
+++ b/javatests/dagger/internal/codegen/ComponentCreatorTestHelper.java
@@ -17,12 +17,15 @@
 package dagger.internal.codegen;
 
 import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.ComponentCreatorKind.FACTORY;
-import static dagger.internal.codegen.ErrorMessages.creatorMessagesFor;
+import static dagger.internal.codegen.binding.ComponentCreatorKind.FACTORY;
+import static dagger.internal.codegen.binding.ErrorMessages.creatorMessagesFor;
 import static java.util.stream.Collectors.joining;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.binding.ComponentCreatorAnnotation;
+import dagger.internal.codegen.binding.ComponentCreatorKind;
+import dagger.internal.codegen.binding.ErrorMessages;
 import java.util.Arrays;
 import java.util.stream.Stream;
 import javax.tools.JavaFileObject;
diff --git a/javatests/dagger/internal/codegen/ComponentFactoryTest.java b/javatests/dagger/internal/codegen/ComponentFactoryTest.java
index e46ae5e6a..8039af8e9 100644
--- a/javatests/dagger/internal/codegen/ComponentFactoryTest.java
+++ b/javatests/dagger/internal/codegen/ComponentFactoryTest.java
@@ -18,12 +18,13 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.COMPONENT_FACTORY;
-import static dagger.internal.codegen.ErrorMessages.creatorMessagesFor;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_CODE_ANNOTATIONS;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.COMPONENT_FACTORY;
+import static dagger.internal.codegen.binding.ErrorMessages.creatorMessagesFor;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.binding.ErrorMessages;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
diff --git a/javatests/dagger/internal/codegen/FrameworkFieldTest.java b/javatests/dagger/internal/codegen/FrameworkFieldTest.java
index cbc8c03b3..be495d79b 100644
--- a/javatests/dagger/internal/codegen/FrameworkFieldTest.java
+++ b/javatests/dagger/internal/codegen/FrameworkFieldTest.java
@@ -24,6 +24,7 @@
 
 import com.google.testing.compile.CompilationRule;
 import com.squareup.javapoet.ClassName;
+import dagger.internal.codegen.binding.FrameworkField;
 import javax.inject.Inject;
 import org.junit.Before;
 import org.junit.Rule;
diff --git a/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java b/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
index 3e6e3ad69..e27534d7b 100644
--- a/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
+++ b/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
@@ -23,6 +23,8 @@
 import static dagger.model.RequestKind.PRODUCER;
 import static dagger.model.RequestKind.PROVIDER;
 
+import dagger.internal.codegen.binding.FrameworkType;
+import dagger.internal.codegen.binding.FrameworkTypeMapper;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
diff --git a/javatests/dagger/internal/codegen/KeyFactoryTest.java b/javatests/dagger/internal/codegen/KeyFactoryTest.java
index ee369538e..fa3d8d3f2 100644
--- a/javatests/dagger/internal/codegen/KeyFactoryTest.java
+++ b/javatests/dagger/internal/codegen/KeyFactoryTest.java
@@ -26,6 +26,7 @@
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.binding.KeyFactory;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import dagger.model.Key;
diff --git a/javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java b/javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java
index 687c29aaf..a1fc220ea 100644
--- a/javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java
+++ b/javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java
@@ -23,6 +23,7 @@
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
 import dagger.internal.codegen.MethodSignatureFormatterTest.OuterClass.InnerClass;
+import dagger.internal.codegen.binding.MethodSignatureFormatter;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
 import javax.inject.Singleton;
diff --git a/javatests/dagger/internal/codegen/SourceFilesTest.java b/javatests/dagger/internal/codegen/SourceFilesTest.java
index c7fe99876..248e2efe9 100644
--- a/javatests/dagger/internal/codegen/SourceFilesTest.java
+++ b/javatests/dagger/internal/codegen/SourceFilesTest.java
@@ -17,9 +17,10 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertThat;
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.binding.SourceFiles.simpleVariableName;
 
 import com.google.testing.compile.CompilationRule;
+import dagger.internal.codegen.binding.SourceFiles;
 import java.util.List;
 import javax.lang.model.element.TypeElement;
 import org.junit.Rule;
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index 5dab4c488..0fd7e084d 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -18,11 +18,12 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.SUBCOMPONENT_BUILDER;
-import static dagger.internal.codegen.ErrorMessages.creatorMessagesFor;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.SUBCOMPONENT_BUILDER;
+import static dagger.internal.codegen.binding.ErrorMessages.creatorMessagesFor;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.binding.ErrorMessages;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
diff --git a/javatests/dagger/internal/codegen/SubcomponentCreatorRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SubcomponentCreatorRequestFulfillmentTest.java
index 1576de152..ea0b4cc19 100644
--- a/javatests/dagger/internal/codegen/SubcomponentCreatorRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentCreatorRequestFulfillmentTest.java
@@ -21,14 +21,15 @@
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
 import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.SUBCOMPONENT_BUILDER;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.SUBCOMPONENT_FACTORY;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_CODE_ANNOTATIONS;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.SUBCOMPONENT_BUILDER;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.SUBCOMPONENT_FACTORY;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.Compilation;
+import dagger.internal.codegen.binding.ComponentCreatorAnnotation;
 import java.util.Collection;
 import java.util.List;
 import java.util.Set;
diff --git a/javatests/dagger/internal/codegen/SubcomponentCreatorValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentCreatorValidationTest.java
index b5753d470..a3ff70b75 100644
--- a/javatests/dagger/internal/codegen/SubcomponentCreatorValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentCreatorValidationTest.java
@@ -18,18 +18,19 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.SUBCOMPONENT_BUILDER;
-import static dagger.internal.codegen.ComponentCreatorAnnotation.SUBCOMPONENT_FACTORY;
-import static dagger.internal.codegen.ComponentCreatorKind.BUILDER;
-import static dagger.internal.codegen.ComponentCreatorKind.FACTORY;
-import static dagger.internal.codegen.ComponentKind.SUBCOMPONENT;
-import static dagger.internal.codegen.ErrorMessages.ComponentCreatorMessages.moreThanOneRefToSubcomponent;
-import static dagger.internal.codegen.ErrorMessages.componentMessagesFor;
 import static dagger.internal.codegen.TestUtils.message;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.SUBCOMPONENT_BUILDER;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.SUBCOMPONENT_FACTORY;
+import static dagger.internal.codegen.binding.ComponentCreatorKind.BUILDER;
+import static dagger.internal.codegen.binding.ComponentCreatorKind.FACTORY;
+import static dagger.internal.codegen.binding.ComponentKind.SUBCOMPONENT;
+import static dagger.internal.codegen.binding.ErrorMessages.ComponentCreatorMessages.moreThanOneRefToSubcomponent;
+import static dagger.internal.codegen.binding.ErrorMessages.componentMessagesFor;
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.binding.ComponentCreatorAnnotation;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
