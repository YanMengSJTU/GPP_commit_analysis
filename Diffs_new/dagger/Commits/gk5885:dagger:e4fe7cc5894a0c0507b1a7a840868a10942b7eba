diff --git a/multibindings.md b/multibindings.md
index 4fdbd9e1a..232654de6 100644
--- a/multibindings.md
+++ b/multibindings.md
@@ -14,7 +14,8 @@ so that a central class can use the entire set of plugins. Or you could have
 several modules contribute individual service providers to a map, keyed by name.
 
 
-## Set multibindings {#set-multibindings}
+<a name=set-multibindings></a>
+## Set multibindings
 
 In order to contribute one element to an injectable multibound set, add a method
 to a module that returns an element and is annotated with
@@ -92,8 +93,8 @@ class MyModuleD {
   static FooSetUser provideFooSetUser(@MyQualifier Set<Foo> foos) { … }
 }
 ```
-
-## Map multibindings {#map-multibindings}
+<a name=map-multibindings></a>
+## Map multibindings
 
 Dagger lets you use multibindings to contribute entries to an injectable map as
 long as the map keys are known at compile time.
@@ -322,22 +323,8 @@ You can declare that a multibound set or map is bound by nesting a
 the sets or maps you want to declare.
 
 You do not have to use [`@Multibindings`] for sets or maps that have at least
-one contribution, but you do have to declare them if they may be empty.[^empty-set-values]
-
-[^empty-set-values]:
-    For empty sets only, as an alternative, you can add a [`@Provides(type =
-    SET_VALUES)`] method that returns an empty set:
-
-    ```java
-    @Module
-    class MyEmptySetModule {
-      @Provides(type = SET_VALUES)
-      static Set<Foo> primeEmptyFooSet() {
-        return Collections.emptySet();
-      }
-    }
-    ```
-
+one contribution, but you do have to declare them if they may be empty.
+    
 ```java
 @Module
 class MyModule {
@@ -357,6 +344,22 @@ are ignored. A given set or map multibinding can be declared any number of times
 without error. Dagger never implements the interface or calls any of its
 methods.
 
+<!-- TODO(dpb): Render as footnote once Github supports them. -->
+### Alternative: `SET_VALUES` returning an empty set
+
+For empty sets only, as an alternative, you can add a [`@Provides(type =
+SET_VALUES)`] method that returns an empty set:
+
+```java
+@Module
+class MyEmptySetModule {
+  @Provides(type = SET_VALUES)
+  static Set<Foo> primeEmptyFooSet() {
+    return Collections.emptySet();
+  }
+}
+```
+
 ## Inherited subcomponent multibindings
 
 A binding in a subcomponent can depend on a multibound set or map from its
@@ -452,10 +455,6 @@ class ChildModule {
 
 <!-- references & footnotes -->
 
-[^AutoAnnotation]:
-    You can use [`@AutoAnnotation`] to create annotation instances to pass to
-    the map's `get(Object)` method.
-
 
 [`@AutoAnnotation`]: https://github.com/google/auto/blob/master/value/src/main/java/com/google/auto/value/AutoAnnotation.java
 [`dagger.mapkeys`]: http://google.github.io/dagger/api/latest/dagger/mapkeys/package-summary.html
diff --git a/producers.md b/producers.md
index 644a68129..5959ed9b8 100644
--- a/producers.md
+++ b/producers.md
@@ -290,7 +290,7 @@ individual monitors for each producer method.
 
 ### Timing, Logging and Debugging
 
-==As of January 2016, not implemented yet==
+**As of March 2016, not implemented yet**
 
 Since graphs are constructed at compile-time, the graph will be able to be
 viewed immediately after compiling, likely via writing its structure to json
diff --git a/subcomponents.md b/subcomponents.md
index 08ecd96a1..4e45341a0 100644
--- a/subcomponents.md
+++ b/subcomponents.md
@@ -271,11 +271,9 @@ the parent component. In the example above, `FooRequestComponent` and
 into one `@RequestScope` component with all their modules, but you might have
 some conflicting bindings.
 
-> TODO(dpb): Explore this idea further.
+<!-- TODO(dpb): Explore this idea further. -->
 
-## Subcomponents vs. dependent components
-
-> TODO(dpb)
+<!-- TODO(dpb): ## Subcomponents vs. dependent components -->
 
 ## Details
 
diff --git a/testing.md b/testing.md
index d993c24ec..577eef3bb 100644
--- a/testing.md
+++ b/testing.md
@@ -41,11 +41,11 @@ public class ThingDoerTest {
 ## Replace bindings for functional/integration/end-to-end testing
 
 Functional/integration/end-to-end tests typically use the production
-application, but substitute fakes[^fakes-not-mocks] for persistence, backends,
-and auth systems, leaving the rest of the application to operate normally. That
-approach lends itself to having one (or maybe a small finite number) of test
-configurations, where the test configuration replaces some of the bindings in
-the prod configuration.
+application, but substitute [fakes] (don’t use mocks in large functional tests!)
+for persistence, backends, and auth systems, leaving the rest of the
+application to operate normally. That approach lends itself to having one (or
+maybe a small finite number) of test configurations, where the test
+configuration replaces some of the bindings in the prod configuration.
 
 ### Option 1: Override bindings by subclassing modules
 
@@ -95,16 +95,14 @@ But there are limitations to this approach:
 
     *   Similarly, the overriding module cannot add bindings to the graph,
         including new [multibinding](multibindings.md)
-        contributions.[^new-multibindings?] Any new `@Provides` methods in the
-        subclass are silently ignored by Dagger. Practically, this means that
-        your fakes cannot take advantage of dependency injection.
+        contributions (although you can still override a `SET_VALUES` method to
+        return a different set). Any new `@Provides` methods in the subclass are
+        silently ignored by Dagger. Practically, this means that your fakes
+        cannot take advantage of dependency injection.
 
 *   `@Provides` methods that are overridable in this way cannot be static, so
     their module instances cannot be [elided][elide-static-module-instances].
 
-[^new-multibindings?]:
-    You can still override a `SET_VALUES` method to return a different set.
-
 <a name="separate-component-configurations"></a>
 ### Option 2: Separate component configurations
 
@@ -142,23 +140,22 @@ if necessary.
 
 But how do you design your modules to make this pattern easy?
 
-[^fakes-not-mocks]:
-    Don’t use mocks in large functional tests! [More explanation TODO.]
-
 ## Organize modules for testability
 
 Module classes are a kind of [utility class]: a collection of
-independent[^independent?] `@Provides` methods, each of which may be used by the
-injector to provide some type used by the application. So how do you decide
-which `@Provides` methods should go together into one module class?
-
-[^independent?]:
-    Although several `@Provides` methods may be related in that one depends on
-    a type provided by another, they typically do not explicitly call each
-    other or rely on the same mutable state. Some `@Provides` methods do refer
-    to the same instance field, in which case they are not in fact independent.
-    The advice given here treats `@Provides` methods as utility methods anyway
-    because it leads to modules that can be readily substituted for testing.
+independent `@Provides` methods, each of which may be used by the
+injector to provide some type used by the application.
+
+<!-- TODO(dpb): Reformat as a footnote once Github supports them. -->
+(Although several `@Provides` methods may be related in that one depends on
+a type provided by another, they typically do not explicitly call each
+other or rely on the same mutable state. Some `@Provides` methods do refer
+to the same instance field, in which case they are not in fact independent.
+The advice given here treats `@Provides` methods as utility methods anyway
+because it leads to modules that can be readily substituted for testing.)
+
+So how do you decide which `@Provides` methods should go together into one
+module class?
 
 One way to think about it is to classify bindings into *published* bindings and
 *internal* bindings, and then to further decide which of the published bindings
@@ -252,6 +249,7 @@ configuration the fake modules, as described
 <!-- Reference links -->
 
 [cohesive]: https://en.wikipedia.org/wiki/Cohesion_(computer_science)
+[fakes]: http://googletesting.blogspot.com/2013/07/testing-on-toilet-know-your-test-doubles.html
 [single responsibility principle]: https://en.wikipedia.org/wiki/Single_responsibility_principle
 [unit testing]: https://en.wikipedia.org/wiki/Unit_testing
 [utility class]: https://en.wikipedia.org/wiki/Utility_class
