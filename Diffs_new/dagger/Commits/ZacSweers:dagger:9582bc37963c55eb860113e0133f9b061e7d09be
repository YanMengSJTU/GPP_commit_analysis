diff --git a/java/dagger/internal/codegen/BindingMethodValidator.java b/java/dagger/internal/codegen/BindingMethodValidator.java
index f55005f27..4b829797f 100644
--- a/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Verify.verifyNotNull;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
@@ -62,6 +63,7 @@
   private final ExceptionSuperclass exceptionSuperclass;
   private final Map<ExecutableElement, ValidationReport<ExecutableElement>> cache = new HashMap<>();
   private final AllowsMultibindings allowsMultibindings;
+  private final AllowsScoping allowsScoping;
 
   /**
    * Creates a validator object.
@@ -78,7 +80,8 @@ protected BindingMethodValidator(
       Class<? extends Annotation> enclosingElementAnnotation,
       Abstractness abstractness,
       ExceptionSuperclass exceptionSuperclass,
-      AllowsMultibindings allowsMultibindings) {
+      AllowsMultibindings allowsMultibindings,
+      AllowsScoping allowsScoping) {
     this(
         elements,
         types,
@@ -87,7 +90,8 @@ protected BindingMethodValidator(
         dependencyRequestValidator,
         abstractness,
         exceptionSuperclass,
-        allowsMultibindings);
+        allowsMultibindings,
+        allowsScoping);
   }
 
   /**
@@ -105,7 +109,8 @@ protected BindingMethodValidator(
       DependencyRequestValidator dependencyRequestValidator,
       Abstractness abstractness,
       ExceptionSuperclass exceptionSuperclass,
-      AllowsMultibindings allowsMultibindings) {
+      AllowsMultibindings allowsMultibindings,
+      AllowsScoping allowsScoping) {
     this.elements = elements;
     this.types = types;
     this.methodAnnotation = methodAnnotation;
@@ -114,6 +119,7 @@ protected BindingMethodValidator(
     this.abstractness = abstractness;
     this.exceptionSuperclass = exceptionSuperclass;
     this.allowsMultibindings = allowsMultibindings;
+    this.allowsScoping = allowsScoping;
   }
 
   /** The annotation that identifies binding methods validated by this object. */
@@ -385,13 +391,23 @@ protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> bu
   }
 
   /** Adds an error if the method has more than one {@linkplain Scope scope} annotation. */
-  protected void checkScopes(ValidationReport.Builder<ExecutableElement> builder) {
+  private void checkScopes(ValidationReport.Builder<ExecutableElement> builder) {
     ImmutableSet<Scope> scopes = scopesOf(builder.getSubject());
-    if (scopes.size() > 1) {
-      for (Scope scope : scopes) {
-        builder.addError(
-            "Cannot use more than one @Scope", builder.getSubject(), scope.scopeAnnotation());
-      }
+    String error = null;
+    switch (allowsScoping) {
+      case ALLOWS_SCOPING:
+        if (scopes.size() <= 1) {
+          return;
+        }
+        error = bindingMethods("cannot use more than one @Scope");
+        break;
+      case NO_SCOPING:
+        error = bindingMethods("cannot be scoped");
+        break;
+    }
+    verifyNotNull(error);
+    for (Scope scope : scopes) {
+      builder.addError(error, builder.getSubject(), scope.scopeAnnotation());
     }
   }
 
@@ -521,4 +537,14 @@ private boolean allowsMultibindings() {
       return this == ALLOWS_MULTIBINDINGS;
     }
   }
+
+  /** How to check scoping annotations. */
+  protected enum AllowsScoping {
+    /** This method disallows scope annotations, so check that none are present. */
+    NO_SCOPING,
+
+    /** This method allows scoping, so validate that there's at most one. */
+    ALLOWS_SCOPING,
+    ;
+  }
 }
diff --git a/java/dagger/internal/codegen/BindsMethodValidator.java b/java/dagger/internal/codegen/BindsMethodValidator.java
index dd7083fe5..1e017bc7e 100644
--- a/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -18,6 +18,7 @@
 
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsScoping.ALLOWS_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
 
 import com.google.auto.common.MoreTypes;
@@ -50,7 +51,8 @@
         dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         RUNTIME_EXCEPTION,
-        ALLOWS_MULTIBINDINGS);
+        ALLOWS_MULTIBINDINGS,
+        ALLOWS_SCOPING);
     this.types = types;
     this.bindsTypeChecker = new BindsTypeChecker(types, elements);
   }
diff --git a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
index 39ff80122..e8088d980 100644
--- a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -18,18 +18,17 @@
 
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsScoping.NO_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
-import static dagger.internal.codegen.Scopes.scopesOf;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import dagger.BindsOptionalOf;
 import dagger.Module;
-import dagger.model.Scope;
 import dagger.producers.ProducerModule;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
@@ -53,7 +52,8 @@
         dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         NO_EXCEPTIONS,
-        NO_MULTIBINDINGS);
+        NO_MULTIBINDINGS,
+        NO_SCOPING);
     this.types = types;
   }
 
@@ -83,14 +83,4 @@ protected void checkParameters(ValidationReport.Builder<ExecutableElement> build
       builder.addError("@BindsOptionalOf methods cannot have parameters");
     }
   }
-
-  @Override
-  protected void checkScopes(ValidationReport.Builder<ExecutableElement> builder) {
-    for (Scope scope : scopesOf(builder.getSubject())) {
-      builder.addError(
-          "@BindsOptionalOf methods cannot be scoped",
-          builder.getSubject(),
-          scope.scopeAnnotation());
-    }
-  }
 }
diff --git a/java/dagger/internal/codegen/MultibindsMethodValidator.java b/java/dagger/internal/codegen/MultibindsMethodValidator.java
index 28f94538d..f912792d5 100644
--- a/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -18,6 +18,7 @@
 
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsScoping.NO_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;
 import static dagger.internal.codegen.FrameworkTypes.isFrameworkType;
 
@@ -47,9 +48,10 @@
         dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         NO_EXCEPTIONS,
-        NO_MULTIBINDINGS);
+        NO_MULTIBINDINGS,
+        NO_SCOPING);
   }
-  
+
   @Override
   protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
     super.checkMethod(builder);
diff --git a/java/dagger/internal/codegen/ProducesMethodValidator.java b/java/dagger/internal/codegen/ProducesMethodValidator.java
index 66400a52b..400370619 100644
--- a/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -19,8 +19,8 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsScoping.NO_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.EXCEPTION;
-import static dagger.internal.codegen.Scopes.scopesOf;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -52,9 +52,10 @@
         ProducerModule.class,
         MUST_BE_CONCRETE,
         EXCEPTION,
-        ALLOWS_MULTIBINDINGS);
+        ALLOWS_MULTIBINDINGS,
+        NO_SCOPING);
   }
-  
+
   @Override
   protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
     super.checkMethod(builder);
@@ -69,14 +70,6 @@ private void checkNullable(ValidationReport.Builder<ExecutableElement> builder)
     }
   }
 
-  /** Adds an error if a {@link Produces @Produces} method has a scope annotation. */
-  @Override
-  protected void checkScopes(ValidationReport.Builder<ExecutableElement> builder) {
-    if (!scopesOf(builder.getSubject()).isEmpty()) {
-      builder.addError("@Produces methods may not have scope annotations");
-    }
-  }
-
   @Override
   protected String badReturnTypeMessage() {
     return "@Produces methods can return only a primitive, an array, a type variable, "
diff --git a/java/dagger/internal/codegen/ProvidesMethodValidator.java b/java/dagger/internal/codegen/ProvidesMethodValidator.java
index ea8efbefd..db24e6685 100644
--- a/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -18,6 +18,7 @@
 
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsScoping.ALLOWS_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
 
 import com.google.common.collect.ImmutableSet;
@@ -48,7 +49,8 @@
         dependencyRequestValidator,
         MUST_BE_CONCRETE,
         RUNTIME_EXCEPTION,
-        ALLOWS_MULTIBINDINGS);
+        ALLOWS_MULTIBINDINGS,
+        ALLOWS_SCOPING);
     this.dependencyRequestValidator = dependencyRequestValidator;
   }
 
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 294838c24..f8b726e75 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -1338,11 +1338,11 @@ public void providesMethodMultipleScopes() {
     Compilation compilation = daggerCompiler().compile(moduleFile, SCOPE_A, SCOPE_B);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("Cannot use more than one @Scope")
+        .hadErrorContaining("cannot use more than one @Scope")
         .inFile(moduleFile)
         .onLineContaining("@ScopeA");
     assertThat(compilation)
-        .hadErrorContaining("Cannot use more than one @Scope")
+        .hadErrorContaining("cannot use more than one @Scope")
         .inFile(moduleFile)
         .onLineContaining("@ScopeB");
   }
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 0b4b2116f..df4da839a 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -204,7 +204,7 @@ public void producesMethodThrowsThrowable() {
 
   @Test public void producesMethodWithScope() {
     assertThatProductionModuleMethod("@Produces @Singleton String str() { return \"\"; }")
-        .hasError("@Produces methods may not have scope annotations");
+        .hasError("@Produces methods cannot be scoped");
   }
 
   @Test
