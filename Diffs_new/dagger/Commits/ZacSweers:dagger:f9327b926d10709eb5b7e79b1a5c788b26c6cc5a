diff --git a/java/dagger/internal/AbstractMapFactory.java b/java/dagger/internal/AbstractMapFactory.java
new file mode 100644
index 000000000..d252bf3ce
--- /dev/null
+++ b/java/dagger/internal/AbstractMapFactory.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.Preconditions.checkNotNull;
+import static java.util.Collections.unmodifiableMap;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import javax.inject.Provider;
+
+/**
+ * An {@code abstract} {@link Factory} implementation used to implement {@link Map} bindings.
+ *
+ * @param <K> the key type of the map that this provides
+ * @param <V> the type that each contributing factory
+ * @param <V2> the value type of the map that this provides
+ */
+abstract class AbstractMapFactory<K, V, V2> implements Factory<Map<K, V2>> {
+  private final Map<K, Provider<V>> contributingMap;
+
+  AbstractMapFactory(Map<K, Provider<V>> map) {
+    this.contributingMap = unmodifiableMap(map);
+  }
+
+  /** The map of {@link Provider}s that contribute to this map binding. */
+  final Map<K, Provider<V>> contributingMap() {
+    return contributingMap;
+  }
+
+  /** A builder for {@link AbstractMapFactory}. */
+  public abstract static class Builder<K, V, V2> {
+    final LinkedHashMap<K, Provider<V>> map;
+
+    Builder(int size) {
+      this.map = newLinkedHashMapWithExpectedSize(size);
+    }
+
+    // Unfortunately, we cannot return a self-type here because a raw Provider type passed to one of
+    // these methods affects the returned type of the method. The first put*() call erases the self
+    // type to the "raw" self type, and the second erases the type to the upper bound
+    // (AbstractMapFactory.Builder), which doesn't have a build() method.
+    //
+    // The methods are therefore not declared public so that each subtype will redeclare them and
+    // expand their accessibility
+
+    /** Associates {@code key} with {@code providerOfValue}. */
+    Builder<K, V, V2> put(K key, Provider<V> providerOfValue) {
+      map.put(checkNotNull(key, "key"), checkNotNull(providerOfValue, "provider"));
+      return this;
+    }
+
+    Builder<K, V, V2> putAll(Provider<Map<K, V2>> mapOfProviders) {
+      @SuppressWarnings("unchecked")
+      AbstractMapFactory<K, V, ?> asAbstractMapFactory =
+          ((AbstractMapFactory<K, V, ?>) (Provider) mapOfProviders);
+      map.putAll(asAbstractMapFactory.contributingMap);
+      return this;
+    }
+  }
+}
diff --git a/java/dagger/internal/MapFactory.java b/java/dagger/internal/MapFactory.java
index ea2135494..8eb078312 100644
--- a/java/dagger/internal/MapFactory.java
+++ b/java/dagger/internal/MapFactory.java
@@ -17,11 +17,9 @@
 package dagger.internal;
 
 import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
-import static dagger.internal.Preconditions.checkNotNull;
 import static java.util.Collections.unmodifiableMap;
 
 import java.util.Collections;
-import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.inject.Provider;
@@ -30,63 +28,51 @@
  * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
  * {@code Map<K, V>} when calling {@link #get} (as specified by {@link Factory}).
  */
-public final class MapFactory<K, V> implements Factory<Map<K, V>> {
+public final class MapFactory<K, V> extends AbstractMapFactory<K, V, V> {
   private static final Provider<Map<Object, Object>> EMPTY =
       InstanceFactory.create(Collections.emptyMap());
 
-  private final Map<K, Provider<V>> contributingMap;
-
-  /**
-   * Returns a new {@link Builder}
-   */
+  /** Returns a new {@link Builder} */
   public static <K, V> Builder<K, V> builder(int size) {
     return new Builder<>(size);
   }
 
-  /**
-   * Returns a factory of an empty map.
-   */
+  /** Returns a factory of an empty map. */
   @SuppressWarnings("unchecked") // safe contravariant cast
   public static <K, V> Provider<Map<K, V>> emptyMapProvider() {
     return (Provider<Map<K, V>>) (Provider) EMPTY;
   }
 
   private MapFactory(Map<K, Provider<V>> map) {
-    this.contributingMap = unmodifiableMap(map);
+    super(map);
   }
 
   /**
-   * Returns a {@code Map<K, V>} whose iteration order is that of the elements
-   * given by each of the providers, which are invoked in the order given at creation.
+   * Returns a {@code Map<K, V>} whose iteration order is that of the elements given by each of the
+   * providers, which are invoked in the order given at creation.
    */
   @Override
   public Map<K, V> get() {
-    Map<K, V> result = newLinkedHashMapWithExpectedSize(contributingMap.size());
-    for (Entry<K, Provider<V>> entry: contributingMap.entrySet()) {
+    Map<K, V> result = newLinkedHashMapWithExpectedSize(contributingMap().size());
+    for (Entry<K, Provider<V>> entry : contributingMap().entrySet()) {
       result.put(entry.getKey(), entry.getValue().get());
     }
     return unmodifiableMap(result);
   }
 
-  // TODO(ronshapiro): can we merge the builders? Or maybe just use a (Immutable)MapBuilder?
   /** A builder for {@link MapFactory}. */
-  public static final class Builder<K, V> {
-    private final LinkedHashMap<K, Provider<V>> map;
-
+  public static final class Builder<K, V> extends AbstractMapFactory.Builder<K, V, V> {
     private Builder(int size) {
-      this.map = newLinkedHashMapWithExpectedSize(size);
+      super(size);
     }
 
-    /** Associates {@code key} with {@code providerOfValue}. */
     public Builder<K, V> put(K key, Provider<V> providerOfValue) {
-      map.put(checkNotNull(key, "key"), checkNotNull(providerOfValue, "provider"));
+      super.put(key, providerOfValue);
       return this;
     }
 
-    // TODO(b/118630627): make this accept MapFactory<K, V>, and change all framework fields to be
-    // of that type so we don't need an unsafe cast
     public Builder<K, V> putAll(Provider<Map<K, V>> mapFactory) {
-      map.putAll(((MapFactory<K, V>) mapFactory).contributingMap);
+      super.putAll(mapFactory);
       return this;
     }
 
diff --git a/java/dagger/internal/MapProviderFactory.java b/java/dagger/internal/MapProviderFactory.java
index 950ad6417..1fe478856 100644
--- a/java/dagger/internal/MapProviderFactory.java
+++ b/java/dagger/internal/MapProviderFactory.java
@@ -16,12 +16,7 @@
 
 package dagger.internal;
 
-import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
-import static dagger.internal.Preconditions.checkNotNull;
-import static java.util.Collections.unmodifiableMap;
-
 import dagger.Lazy;
-import java.util.LinkedHashMap;
 import java.util.Map;
 import javax.inject.Provider;
 
@@ -29,49 +24,42 @@
  * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
  * {@code Map<K, Provider<V>>} when calling {@link #get} (as specified by {@link Factory}).
  */
-public final class MapProviderFactory<K, V>
-    implements Factory<Map<K, Provider<V>>>, Lazy<Map<K, Provider<V>>> {
-  private final Map<K, Provider<V>> contributingMap;
+public final class MapProviderFactory<K, V> extends AbstractMapFactory<K, V, Provider<V>>
+    implements Lazy<Map<K, Provider<V>>> {
 
-  /**
-   * Returns a new {@link Builder}
-   */
+  /** Returns a new {@link Builder} */
   public static <K, V> Builder<K, V> builder(int size) {
     return new Builder<>(size);
   }
 
   private MapProviderFactory(Map<K, Provider<V>> contributingMap) {
-    this.contributingMap = unmodifiableMap(contributingMap);
+    super(contributingMap);
   }
 
   /**
-   * Returns a {@code Map<K, Provider<V>>} whose iteration order is that of the elements
-   * given by each of the providers, which are invoked in the order given at creation.
-   *
+   * Returns a {@code Map<K, Provider<V>>} whose iteration order is that of the elements given by
+   * each of the providers, which are invoked in the order given at creation.
    */
   @Override
   public Map<K, Provider<V>> get() {
-    return this.contributingMap;
+    return contributingMap();
   }
 
   /** A builder for {@link MapProviderFactory}. */
-  public static final class Builder<K, V> {
-    private final LinkedHashMap<K, Provider<V>> map;
-
+  public static final class Builder<K, V> extends AbstractMapFactory.Builder<K, V, Provider<V>> {
     private Builder(int size) {
-      this.map = newLinkedHashMapWithExpectedSize(size);
+      super(size);
     }
 
-    /** Associates {@code key} with {@code providerOfValue}. */
+    @Override
     public Builder<K, V> put(K key, Provider<V> providerOfValue) {
-      map.put(checkNotNull(key, "key"), checkNotNull(providerOfValue, "provider"));
+      super.put(key, providerOfValue);
       return this;
     }
 
-    // TODO(b/118630627): make this accept MapProviderFactory<K, V>, and change all framework fields
-    // to be of that type so we don't need an unsafe cast
+    @Override
     public Builder<K, V> putAll(Provider<Map<K, Provider<V>>> mapProviderFactory) {
-      map.putAll(((MapProviderFactory<K, V>) mapProviderFactory).contributingMap);
+      super.putAll(mapProviderFactory);
       return this;
     }
 
diff --git a/java/dagger/producers/internal/AbstractMapProducer.java b/java/dagger/producers/internal/AbstractMapProducer.java
new file mode 100644
index 000000000..f689d9b91
--- /dev/null
+++ b/java/dagger/producers/internal/AbstractMapProducer.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.producers.internal.Producers.producerFromProvider;
+
+import com.google.common.collect.ImmutableMap;
+import dagger.producers.Producer;
+import java.util.Map;
+import javax.inject.Provider;
+
+/**
+ * An {@code abstract} {@link Producer} implementation used to implement {@link Map} bindings.
+ *
+ * @param <K>The key type of the map that this produces
+ * @param <V>The type that each contributing producer
+ * @param <V2>The value type of the map that this produces. For {@link MapProducer}, {@code V} and
+ *     {@code V2} will be equivalent.
+ */
+abstract class AbstractMapProducer<K, V, V2> extends AbstractProducer<Map<K, V2>> {
+  private final ImmutableMap<K, Producer<V>> contributingMap;
+
+  AbstractMapProducer(ImmutableMap<K, Producer<V>> contributingMap) {
+    this.contributingMap = contributingMap;
+  }
+
+  /** The map of {@link Producer}s that contribute to this map binding. */
+  final ImmutableMap<K, Producer<V>> contributingMap() {
+    return contributingMap;
+  }
+
+  /** A builder for {@link AbstractMapProducer} */
+  public abstract static class Builder<K, V, V2> {
+    final ImmutableMap.Builder<K, Producer<V>> mapBuilder;
+
+    Builder(int size) {
+      mapBuilder = ImmutableMap.builderWithExpectedSize(size);
+    }
+
+    // Unfortunately, we cannot return a self-type here because a raw Producer type passed to one of
+    // these methods affects the returned type of the method. The first put*() call erases the self
+    // type to the "raw" self type, and the second erases the type to the upper bound
+    // (AbstractMapProducer.Builder), which doesn't have a build() method.
+    //
+    // The methods are therefore not declared public so that each subtype will redeclare them and
+    // expand their accessibility
+
+    /** Associates {@code key} with {@code producerOfValue}. */
+    Builder<K, V, V2> put(K key, Producer<V> producerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(producerOfValue, "producer of value");
+      mapBuilder.put(key, producerOfValue);
+      return this;
+    }
+
+    /** Associates {@code key} with {@code providerOfValue}. */
+    Builder<K, V, V2> put(K key, Provider<V> providerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(providerOfValue, "provider of value");
+      mapBuilder.put(key, producerFromProvider(providerOfValue));
+      return this;
+    }
+
+    /** Adds contributions from a super-implementation of a component into this builder. */
+    Builder<K, V, V2> putAll(Producer<Map<K, V2>> mapOfProducers) {
+      @SuppressWarnings("unchecked")
+      AbstractMapProducer<K, V, ?> asAbstractMapProducer =
+          ((AbstractMapProducer<K, V, ?>) (Producer) mapOfProducers);
+      mapBuilder.putAll(asAbstractMapProducer.contributingMap);
+      return this;
+    }
+  }
+}
diff --git a/java/dagger/producers/internal/MapOfProducedProducer.java b/java/dagger/producers/internal/MapOfProducedProducer.java
index 2eda7f3f7..bd9f1bfcc 100644
--- a/java/dagger/producers/internal/MapOfProducedProducer.java
+++ b/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -16,10 +16,8 @@
 
 package dagger.producers.internal;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Futures.transform;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
-import static dagger.producers.internal.Producers.producerFromProvider;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
@@ -38,11 +36,9 @@
  * {@code Map<K, Produced<V>>} which is populated by calls to the delegate {@link Producer#get}
  * methods.
  */
-public final class MapOfProducedProducer<K, V> extends AbstractProducer<Map<K, Produced<V>>> {
-  private final Map<K, Producer<V>> contributingMap;
-
-  private MapOfProducedProducer(Map<K, Producer<V>> contributingMap) {
-    this.contributingMap = contributingMap;
+public final class MapOfProducedProducer<K, V> extends AbstractMapProducer<K, V, Produced<V>> {
+  private MapOfProducedProducer(ImmutableMap<K, Producer<V>> contributingMap) {
+    super(contributingMap);
   }
 
   @Override
@@ -50,7 +46,7 @@ private MapOfProducedProducer(Map<K, Producer<V>> contributingMap) {
     return Futures.transform(
         Futures.allAsList(
             Iterables.transform(
-                contributingMap.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
+                contributingMap().entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
         new Function<List<Map.Entry<K, Produced<V>>>, Map<K, Produced<V>>>() {
           @Override
           public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
@@ -95,40 +91,32 @@ private MapOfProducedProducer(Map<K, Producer<V>> contributingMap) {
   }
 
   /** A builder for {@link MapOfProducedProducer}. */
-  public static final class Builder<K, V> {
-    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder;
-
+  public static final class Builder<K, V> extends AbstractMapProducer.Builder<K, V, Produced<V>> {
     private Builder(int size) {
-      mapBuilder = ImmutableMap.builderWithExpectedSize(size);
-    }
-
-    /** Returns a new {@link MapOfProducedProducer}. */
-    public MapOfProducedProducer<K, V> build() {
-      return new MapOfProducedProducer<>(mapBuilder.build());
+      super(size);
     }
 
-    /** Associates {@code key} with {@code producerOfValue}. */
+    @Override
     public Builder<K, V> put(K key, Producer<V> producerOfValue) {
-      checkNotNull(key, "key");
-      checkNotNull(producerOfValue, "producer of value");
-      mapBuilder.put(key, producerOfValue);
+      super.put(key, producerOfValue);
       return this;
     }
 
-    /** Associates {@code key} with {@code providerOfValue}. */
+    @Override
     public Builder<K, V> put(K key, Provider<V> providerOfValue) {
-      checkNotNull(key, "key");
-      checkNotNull(providerOfValue, "provider of value");
-      mapBuilder.put(key, producerFromProvider(providerOfValue));
+      super.put(key, providerOfValue);
       return this;
     }
 
-    // TODO(b/118630627): make this accept MapOfProducedProducer<K, V>, and change all framework
-    // fields to be of that type so we don't need an unsafe cast
-    /** Adds contributions from a super-implementation of a component into this builder. */
+    @Override
     public Builder<K, V> putAll(Producer<Map<K, Produced<V>>> mapOfProducedProducer) {
-      mapBuilder.putAll(((MapOfProducedProducer<K, V>) mapOfProducedProducer).contributingMap);
+      super.putAll(mapOfProducedProducer);
       return this;
     }
+
+    /** Returns a new {@link MapOfProducedProducer}. */
+    public MapOfProducedProducer<K, V> build() {
+      return new MapOfProducedProducer<>(mapBuilder.build());
+    }
   }
 }
diff --git a/java/dagger/producers/internal/MapOfProducerProducer.java b/java/dagger/producers/internal/MapOfProducerProducer.java
index ad57c99a8..064cf7499 100644
--- a/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -16,10 +16,8 @@
 
 package dagger.producers.internal;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.producers.internal.Producers.entryPointViewOf;
 import static dagger.producers.internal.Producers.nonCancellationPropagatingViewOf;
-import static dagger.producers.internal.Producers.producerFromProvider;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
@@ -34,52 +32,42 @@
  * A {@link Producer} implementation used to implement {@link Map} bindings. This factory returns an
  * immediate future of {@code Map<K, Producer<V>>} when calling {@link #get}.
  */
-public final class MapOfProducerProducer<K, V> extends AbstractProducer<Map<K, Producer<V>>> {
-  private final ImmutableMap<K, Producer<V>> contributingMap;
-
+public final class MapOfProducerProducer<K, V> extends AbstractMapProducer<K, V, Producer<V>> {
   /** Returns a new {@link Builder}. */
   public static <K, V> Builder<K, V> builder(int size) {
     return new Builder<>(size);
   }
 
   private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
-    this.contributingMap = contributingMap;
+    super(contributingMap);
   }
 
   @Override
   public ListenableFuture<Map<K, Producer<V>>> compute() {
-    return Futures.<Map<K, Producer<V>>>immediateFuture(contributingMap);
+    return Futures.<Map<K, Producer<V>>>immediateFuture(contributingMap());
   }
 
   /** A builder for {@link MapOfProducerProducer} */
-  public static final class Builder<K, V> {
-    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder;
-
+  public static final class Builder<K, V> extends AbstractMapProducer.Builder<K, V, Producer<V>> {
     private Builder(int size) {
-      mapBuilder = ImmutableMap.builderWithExpectedSize(size);
+      super(size);
     }
 
-    /** Associates {@code key} with {@code producerOfValue}. */
+    @Override
     public Builder<K, V> put(K key, Producer<V> producerOfValue) {
-      checkNotNull(key, "key");
-      checkNotNull(producerOfValue, "producer of value");
-      mapBuilder.put(key, producerOfValue);
+      super.put(key, producerOfValue);
       return this;
     }
 
-    /** Associates {@code key} with {@code providerOfValue}. */
+    @Override
     public Builder<K, V> put(K key, Provider<V> providerOfValue) {
-      checkNotNull(key, "key");
-      checkNotNull(providerOfValue, "provider of value");
-      mapBuilder.put(key, producerFromProvider(providerOfValue));
+      super.put(key, providerOfValue);
       return this;
     }
 
-    // TODO(b/118630627): make this accept MapOfProducerProducer<K, V>, and change all framework
-    // fields to be of that type so we don't need an unsafe cast
-    /** Adds contributions from a super-implementation of a component into this builder. */
-    public Builder<K, V> putAll(Producer<Map<K, Producer<V>>> mapProducerProducer) {
-      mapBuilder.putAll(((MapOfProducerProducer<K, V>) mapProducerProducer).contributingMap);
+    @Override
+    public Builder<K, V> putAll(Producer<Map<K, Producer<V>>> mapOfProducerProducer) {
+      super.putAll(mapOfProducerProducer);
       return this;
     }
 
@@ -104,7 +92,7 @@ private Builder(int size) {
   private Producer<Map<K, Producer<V>>> newTransformedValuesView(
       Function<Producer<V>, Producer<V>> valueTransformationFunction) {
     return dagger.producers.Producers.<Map<K, Producer<V>>>immediateProducer(
-        ImmutableMap.copyOf(Maps.transformValues(contributingMap, valueTransformationFunction)));
+        ImmutableMap.copyOf(Maps.transformValues(contributingMap(), valueTransformationFunction)));
   }
 
   @SuppressWarnings("unchecked")
diff --git a/java/dagger/producers/internal/MapProducer.java b/java/dagger/producers/internal/MapProducer.java
index 9cc000b40..8caeb45cb 100644
--- a/java/dagger/producers/internal/MapProducer.java
+++ b/java/dagger/producers/internal/MapProducer.java
@@ -16,9 +16,7 @@
 
 package dagger.producers.internal;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
-import static dagger.producers.internal.Producers.producerFromProvider;
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
@@ -36,11 +34,9 @@
  * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a
  * {@code Map<K, V>} which is populated by calls to the delegate {@link Producer#get} methods.
  */
-public final class MapProducer<K, V> extends AbstractProducer<Map<K, V>> {
-  private final ImmutableMap<K, Producer<V>> contributingMap;
-
+public final class MapProducer<K, V> extends AbstractMapProducer<K, V, V> {
   private MapProducer(ImmutableMap<K, Producer<V>> contributingMap) {
-    this.contributingMap = contributingMap;
+    super(contributingMap);
   }
 
   /** Returns a new {@link Builder}. */
@@ -49,34 +45,26 @@ private MapProducer(ImmutableMap<K, Producer<V>> contributingMap) {
   }
 
   /** A builder for {@link MapProducer} */
-  public static final class Builder<K, V> {
-    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder;
-
+  public static final class Builder<K, V> extends AbstractMapProducer.Builder<K, V, V> {
     private Builder(int size) {
-      mapBuilder = ImmutableMap.builderWithExpectedSize(size);
+      super(size);
     }
 
-    /** Associates {@code key} with {@code producerOfValue}. */
+    @Override
     public Builder<K, V> put(K key, Producer<V> producerOfValue) {
-      checkNotNull(key, "key");
-      checkNotNull(producerOfValue, "producer of value");
-      mapBuilder.put(key, producerOfValue);
+      super.put(key, producerOfValue);
       return this;
     }
 
-    /** Associates {@code key} with {@code providerOfValue}. */
+    @Override
     public Builder<K, V> put(K key, Provider<V> providerOfValue) {
-      checkNotNull(key, "key");
-      checkNotNull(providerOfValue, "provider of value");
-      mapBuilder.put(key, producerFromProvider(providerOfValue));
+      super.put(key, providerOfValue);
       return this;
     }
 
-    // TODO(b/118630627): make this accept MapProducer<K, V>, and change all framework fields to be
-    // of that type so we don't need an unsafe cast
-    /** Adds contributions from a super-implementation of a component into this builder. */
+    @Override
     public Builder<K, V> putAll(Producer<Map<K, V>> mapProducer) {
-      mapBuilder.putAll(((MapProducer<K, V>) mapProducer).contributingMap);
+      super.putAll(mapProducer);
       return this;
     }
 
@@ -89,14 +77,17 @@ private Builder(int size) {
   @Override
   protected ListenableFuture<Map<K, V>> compute() {
     final List<ListenableFuture<Map.Entry<K, V>>> listOfEntries = new ArrayList<>();
-    for (final Entry<K, Producer<V>> entry : contributingMap.entrySet()) {
+    for (final Entry<K, Producer<V>> entry : contributingMap().entrySet()) {
       listOfEntries.add(
-          Futures.transform(entry.getValue().get(), new Function<V, Entry<K, V>>() {
-            @Override
-            public Entry<K, V> apply(V computedValue) {
-              return Maps.immutableEntry(entry.getKey(), computedValue);
-            }
-          }, directExecutor()));
+          Futures.transform(
+              entry.getValue().get(),
+              new Function<V, Entry<K, V>>() {
+                @Override
+                public Entry<K, V> apply(V computedValue) {
+                  return Maps.immutableEntry(entry.getKey(), computedValue);
+                }
+              },
+              directExecutor()));
     }
 
     return Futures.transform(
