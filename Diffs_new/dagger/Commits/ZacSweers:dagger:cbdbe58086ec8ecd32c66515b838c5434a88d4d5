diff --git a/java/dagger/internal/codegen/AnyBindingMethodValidator.java b/java/dagger/internal/codegen/AnyBindingMethodValidator.java
index 354a4f878..23393b628 100644
--- a/java/dagger/internal/codegen/AnyBindingMethodValidator.java
+++ b/java/dagger/internal/codegen/AnyBindingMethodValidator.java
@@ -20,8 +20,8 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.ErrorMessages.tooManyBindingMethodAnnotations;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
+import static java.util.stream.Collectors.joining;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -100,7 +100,12 @@ boolean wasAlreadyValidated(ExecutableElement method) {
         break;
 
       default:
-        report.addError(tooManyBindingMethodAnnotations(method, methodAnnotations()), method);
+        report.addError(
+            String.format(
+                "%s is annotated with more than one of (%s)",
+                method.getSimpleName(),
+                methodAnnotations().stream().map(Class::getCanonicalName).collect(joining(", "))),
+            method);
         break;
     }
     return report.build();
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index a9767df95..95eb167a2 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -27,9 +27,6 @@
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
-import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.abstractModuleHasInstanceBindingMethods;
 import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.internal.codegen.RequestKinds.extractKeyType;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
@@ -305,7 +302,7 @@ private void validateModules(BindingGraph graph) {
         if (module.moduleElement().getModifiers().contains(Modifier.ABSTRACT)) {
           for (ContributionBinding binding : module.bindings()) {
             if (binding.requiresModuleInstance()) {
-              report(graph).addError(abstractModuleHasInstanceBindingMethods(module));
+              report(graph).addError(abstractModuleHasInstanceBindingMethodsError(module));
               break;
             }
           }
@@ -313,6 +310,24 @@ private void validateModules(BindingGraph graph) {
       }
     }
 
+    private String abstractModuleHasInstanceBindingMethodsError(ModuleDescriptor module) {
+      String methodAnnotations;
+      switch (module.kind()) {
+        case MODULE:
+          methodAnnotations = "@Provides";
+          break;
+        case PRODUCER_MODULE:
+          methodAnnotations = "@Provides or @Produces";
+          break;
+        default:
+          throw new AssertionError(module.kind());
+      }
+      return String.format(
+          "%s is abstract and has instance %s methods. Consider making the methods static or "
+              + "including a non-abstract subclass of the module instead.",
+          module.moduleElement(), methodAnnotations);
+    }
+
     private void validateBuilders(BindingGraph graph) {
       ComponentDescriptor componentDesc = graph.componentDescriptor();
       if (!componentDesc.builderSpec().isPresent()) {
@@ -576,7 +591,7 @@ protected void visitContributionBinding(
       @SuppressWarnings("resource") // Appendable is a StringBuilder.
       private void reportDependsOnProductionExecutor() {
         reportErrorAtEntryPoint(
-            DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatCurrentDependencyRequestKey());
+            "%s may not depend on the production executor", formatCurrentDependencyRequestKey());
       }
 
       // TODO(cgruber): Provide a hint for the start and end of the cycle.
@@ -591,7 +606,7 @@ private void reportDependencyCycle() {
                     cycleBindings.addAll(resolvedBindings.contributionBindings()));
         reportErrorAtEntryPoint(
             owningGraph(cycleBindings.build()),
-            CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+            "Found a dependency cycle:\n%s",
             formatDependencyTrace());
       }
 
diff --git a/java/dagger/internal/codegen/BindingMethodValidator.java b/java/dagger/internal/codegen/BindingMethodValidator.java
index 7a764f082..3c18ebe73 100644
--- a/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -18,25 +18,6 @@
 
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_ANY;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEYS;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
@@ -49,7 +30,7 @@
 import static javax.lang.model.type.TypeKind.VOID;
 
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
+import com.google.errorprone.annotations.FormatMethod;
 import com.google.errorprone.annotations.OverridingMethodsMustInvokeSuper;
 import dagger.MapKey;
 import dagger.Provides;
@@ -57,6 +38,7 @@
 import dagger.multibindings.IntoMap;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
+import java.util.Formatter;
 import java.util.HashMap;
 import java.util.Map;
 import javax.inject.Qualifier;
@@ -126,12 +108,25 @@ protected BindingMethodValidator(
     this.exceptionSuperclass = exceptionSuperclass;
     this.allowsMultibindings = allowsMultibindings;
   }
-  
-  /** The annotation that identifies methods validated by this object. */
-  Class<? extends Annotation> methodAnnotation() {
+
+  /** The annotation that identifies binding methods validated by this object. */
+  final Class<? extends Annotation> methodAnnotation() {
     return methodAnnotation;
   }
 
+  /**
+   * Returns an error message of the form "@<i>annotation</i> methods <i>rule</i>", where
+   * <i>rule</i> comes from calling {@link String#format(String, Object...)} on {@code ruleFormat}
+   * and the other arguments.
+   */
+  @FormatMethod
+  protected final String bindingMethods(String ruleFormat, Object... args) {
+    return new Formatter()
+        .format("@%s methods ", methodAnnotation.getSimpleName())
+        .format(ruleFormat, args)
+        .toString();
+  }
+
   /** Returns a {@link ValidationReport} for {@code method}. */
   final ValidationReport<ExecutableElement> validate(ExecutableElement method) {
     return reentrantComputeIfAbsent(cache, method, this::validateUncached);
@@ -165,8 +160,8 @@ private void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> b
     if (!isAnyAnnotationPresent(
         builder.getSubject().getEnclosingElement(), enclosingElementAnnotations)) {
       builder.addError(
-          formatErrorMessage(
-              BINDING_METHOD_NOT_IN_MODULE,
+          bindingMethods(
+              "can only be present within a @%s",
               enclosingElementAnnotations
                   .stream()
                   .map(Class::getSimpleName)
@@ -177,14 +172,14 @@ private void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> b
   /** Adds an error if the method is generic. */
   private void checkTypeParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getTypeParameters().isEmpty()) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+      builder.addError(bindingMethods("may not have type parameters"));
     }
   }
 
   /** Adds an error if the method is private. */
   private void checkNotPrivate(ValidationReport.Builder<ExecutableElement> builder) {
     if (builder.getSubject().getModifiers().contains(PRIVATE)) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE));
+      builder.addError(bindingMethods("cannot be private"));
     }
   }
 
@@ -194,13 +189,13 @@ private void checkAbstractness(ValidationReport.Builder<ExecutableElement> build
     switch (abstractness) {
       case MUST_BE_ABSTRACT:
         if (!isAbstract) {
-          builder.addError(formatErrorMessage(BINDING_METHOD_NOT_ABSTRACT));
+          builder.addError(bindingMethods("must be abstract"));
         }
         break;
 
       case MUST_BE_CONCRETE:
         if (isAbstract) {
-          builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+          builder.addError(bindingMethods("cannot be abstract"));
         }
         break;
 
@@ -251,7 +246,7 @@ protected void checkKeyType(
       ValidationReport.Builder<ExecutableElement> builder, TypeMirror keyType) {
     TypeKind kind = keyType.getKind();
     if (kind.equals(VOID)) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+      builder.addError(bindingMethods("must return a value (not void)"));
     } else if (!(kind.isPrimitive()
         || kind.equals(DECLARED)
         || kind.equals(ARRAY)
@@ -262,7 +257,7 @@ protected void checkKeyType(
 
   /** The error message when a non-{@code void} binding method returns a bad type. */
   protected String badReturnTypeMessage() {
-    return formatErrorMessage(BINDING_METHOD_RETURN_TYPE);
+    return bindingMethods("must return a primitive, an array, a type variable, or a declared type");
   }
 
   /**
@@ -282,7 +277,7 @@ protected final void checkSetValuesType(
     } else {
       SetType setType = SetType.from(type);
       if (setType.isRawType()) {
-        builder.addError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+        builder.addError(bindingMethods("annotated with @ElementsIntoSet cannot return a raw Set"));
       } else {
         checkKeyType(builder, setType.elementType());
       }
@@ -302,7 +297,7 @@ protected void checkQualifiers(ValidationReport.Builder<ExecutableElement> build
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(builder.getSubject());
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(BINDING_METHOD_MULTIPLE_QUALIFIERS, builder.getSubject(), qualifier);
+        builder.addError("Cannot use more than one @Qualifier", builder.getSubject(), qualifier);
       }
     }
   }
@@ -320,16 +315,16 @@ protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder)
     if (ContributionType.fromBindingMethod(builder.getSubject()).equals(ContributionType.MAP)) {
       switch (mapKeys.size()) {
         case 0:
-          builder.addError(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY));
+          builder.addError(bindingMethods("of type map must declare a map key"));
           break;
         case 1:
           break;
         default:
-          builder.addError(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEYS));
+          builder.addError(bindingMethods("may not have more than one map key"));
           break;
       }
     } else if (!mapKeys.isEmpty()) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY));
+      builder.addError(bindingMethods("of non map type cannot declare a map key"));
     }
   }
 
@@ -347,7 +342,7 @@ protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> bu
     if (multibindingAnnotations.size() > 1) {
       for (AnnotationMirror annotation : multibindingAnnotations) {
         builder.addError(
-            formatErrorMessage(MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD),
+            bindingMethods("cannot have more than one multibinding annotation"),
             builder.getSubject(),
             annotation);
       }
@@ -361,35 +356,23 @@ protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> bu
     }
     if (usesProvidesType && !multibindingAnnotations.isEmpty()) {
       builder.addError(
-          formatErrorMessage(MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM),
-          builder.getSubject());
+          "@Provides.type cannot be used with multibinding annotations", builder.getSubject());
     }
   }
 
   /** Adds an error if the method returns a {@linkplain FrameworkTypes framework type}. */
   protected void checkFrameworkType(ValidationReport.Builder<ExecutableElement> builder) {
     if (FrameworkTypes.isFrameworkType(builder.getSubject().getReturnType())) {
-      builder.addError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+      builder.addError(bindingMethods("must not return framework types"));
     }
   }
 
-  /**
-   * Formats an error message whose first {@code %s} parameter should be replaced with the simple
-   * name of the method annotation.
-   */
-  protected String formatErrorMessage(String format, Object... otherParameters) {
-    return otherParameters.length == 0
-        ? String.format(format, methodAnnotation.getSimpleName())
-        : String.format(
-            format, Lists.asList(methodAnnotation.getSimpleName(), otherParameters).toArray());
-  }
-
   /**
    * The error message when an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method
    * returns a bad type.
    */
   protected String badSetValuesTypeMessage() {
-    return formatErrorMessage(BINDING_METHOD_SET_VALUES_RETURN_SET);
+    return bindingMethods("annotated with @ElementsIntoSet must return a Set");
   }
 
   /** An abstract/concrete restriction on methods. */
@@ -399,39 +382,53 @@ protected String badSetValuesTypeMessage() {
   }
 
   /**
-   * The exception class that all {@code throws}-declared throwables must extend, other than
-   * {@link Error}.
+   * The exception class that all {@code throws}-declared throwables must extend, other than {@link
+   * Error}.
    */
   protected enum ExceptionSuperclass {
     /** Methods may not declare any throwable types. */
     NO_EXCEPTIONS {
+      @Override
+      protected String errorMessage(BindingMethodValidator validator) {
+        return validator.bindingMethods("may not throw");
+      }
+
       @Override
       protected void checkThrows(
           BindingMethodValidator validator, ValidationReport.Builder<ExecutableElement> builder) {
         if (!builder.getSubject().getThrownTypes().isEmpty()) {
-          builder.addError(validator.formatErrorMessage(BINDING_METHOD_THROWS_ANY));
+          builder.addError(validator.bindingMethods("may not throw"));
           return;
         }
       }
     },
 
     /** Methods may throw checked or unchecked exceptions or errors. */
-    EXCEPTION(Exception.class, BINDING_METHOD_THROWS),
+    EXCEPTION(Exception.class) {
+      @Override
+      protected String errorMessage(BindingMethodValidator validator) {
+        return validator.bindingMethods(
+            "may only throw unchecked exceptions or exceptions subclassing Exception");
+      }
+    },
 
     /** Methods may throw unchecked exceptions or errors. */
-    RUNTIME_EXCEPTION(RuntimeException.class, BINDING_METHOD_THROWS_CHECKED),
+    RUNTIME_EXCEPTION(RuntimeException.class) {
+      @Override
+      protected String errorMessage(BindingMethodValidator validator) {
+        return validator.bindingMethods("may only throw unchecked exceptions");
+      }
+    },
     ;
 
     private final Class<? extends Exception> superclass;
-    private final String errorMessage;
 
-    private ExceptionSuperclass() {
-      this(null, null);
+    ExceptionSuperclass() {
+      this(null);
     }
 
-    private ExceptionSuperclass(Class<? extends Exception> superclass, String errorMessage) {
+    ExceptionSuperclass(Class<? extends Exception> superclass) {
       this.superclass = superclass;
-      this.errorMessage = errorMessage;
     }
 
     /**
@@ -448,11 +445,13 @@ protected void checkThrows(
       for (TypeMirror thrownType : builder.getSubject().getThrownTypes()) {
         if (!validator.types.isSubtype(thrownType, exceptionSupertype)
             && !validator.types.isSubtype(thrownType, errorType)) {
-          builder.addError(validator.formatErrorMessage(errorMessage));
+          builder.addError(errorMessage(validator));
           break;
         }
       }
     }
+
+    protected abstract String errorMessage(BindingMethodValidator validator);
   }
 
   /** Whether to check multibinding annotations. */
diff --git a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index a500eb817..87ddbf772 100644
--- a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -21,9 +21,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_IN_INVALID_COMPONENT;
-import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_ONE_PARAMETER;
 import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
@@ -80,7 +77,8 @@
         report.addError("@BindsInstance methods must be abstract");
       }
       if (method.getParameters().size() != 1) {
-        report.addError(BINDS_INSTANCE_ONE_PARAMETER);
+        report.addError(
+            "@BindsInstance methods should have exactly one parameter for the bound type");
       } else {
         VariableElement parameter = getOnlyElement(method.getParameters());
         if (FrameworkTypes.isFrameworkType(parameter.asType())) {
@@ -91,13 +89,17 @@
       if (isAnyAnnotationPresent(enclosingType, MODULE_ANNOTATIONS)) {
         report.addError(
             String.format(
-                BINDS_INSTANCE_IN_MODULE, simpleName(getModuleAnnotation(enclosingType).get())));
+                "@BindsInstance methods should not be included in @%ss. Did you mean @Binds?",
+                simpleName(getModuleAnnotation(enclosingType).get())));
       }
       if (isAnyAnnotationPresent(enclosingType, COMPONENT_ANNOTATIONS)) {
         AnnotationMirror componentAnnotation =
             getComponentOrSubcomponentAnnotation(enclosingType).get();
         report.addError(
-            String.format(BINDS_INSTANCE_IN_INVALID_COMPONENT, simpleName(componentAnnotation)));
+            String.format(
+                "@BindsInstance methods should not be included in @%1$ss. "
+                    + "Did you mean to put it in a @%1$s.Builder?",
+                simpleName(componentAnnotation)));
       }
       report.build().printMessagesTo(messager);
     }
diff --git a/java/dagger/internal/codegen/BindsMethodValidator.java b/java/dagger/internal/codegen/BindsMethodValidator.java
index 84d1bdcc5..78909e84e 100644
--- a/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -20,8 +20,6 @@
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
-import static dagger.internal.codegen.ErrorMessages.BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
@@ -71,14 +69,20 @@ private void checkParameters(ValidationReport.Builder<ExecutableElement> builder
       TypeMirror rightHandSide = parameter.asType();
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
       if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
-        builder.addError(BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET);
+        builder.addError(
+            "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter");
       }
 
       if (!bindsTypeChecker.isAssignable(rightHandSide, leftHandSide, contributionType)) {
-        builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);
+        // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
+        // right-hand-side might not be assignable to the left-hand-side, but still compatible with
+        // Set.addAll(Collection<? extends E>)
+        builder.addError("@Binds methods' parameter type must be assignable to the return type");
       }
     } else {
-      builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);
+      builder.addError(
+          "@Binds methods must have exactly one parameter, "
+              + "whose type is assignable to the return type");
     }
   }
 
diff --git a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
index 1d9772eff..1210ed6d6 100644
--- a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -19,8 +19,6 @@
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;
-import static dagger.internal.codegen.ErrorMessages.BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
@@ -68,13 +66,15 @@ protected void checkKeyType(
             getQualifiers(builder.getSubject()).stream().findFirst(), keyType, types)
         && !injectedConstructors(MoreElements.asType(MoreTypes.asDeclared(keyType).asElement()))
             .isEmpty()) {
-      builder.addError(BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE);
+      builder.addError(
+          "@BindsOptionalOf methods cannot return unqualified types that have an @Inject-"
+              + "annotated constructor because those are always present");
     }
   }
 
   private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getParameters().isEmpty()) {
-      builder.addError(BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER);
+      builder.addError("@BindsOptionalOf methods cannot have parameters");
     }
   }
 }
diff --git a/java/dagger/internal/codegen/CanReleaseReferencesValidator.java b/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
index 85b8bac93..5c79dab0a 100644
--- a/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
+++ b/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
@@ -18,7 +18,6 @@
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static dagger.internal.codegen.ErrorMessages.CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION;
 import static java.lang.annotation.RetentionPolicy.SOURCE;
 
 import dagger.releasablereferences.CanReleaseReferences;
@@ -52,7 +51,7 @@ private void checkNoSourceRetention(
             retention -> {
               if (getRetentionPolicy(retention).equals(SOURCE)) {
                 report.addError(
-                    CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION,
+                    "@CanReleaseReferences annotations must not have SOURCE retention",
                     report.getSubject(),
                     retention);
               }
diff --git a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
index 2ad1cd646..f781a8986 100644
--- a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -68,7 +67,7 @@ static CodeBlock maybeCheckForNull(
             "$T.checkNotNull($L, $S)",
             Preconditions.class,
             invocation,
-            CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD)
+            "Cannot return null from a non-@Nullable component method")
         : invocation;
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index eee833911..89c8195d9 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -25,7 +25,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
-import static dagger.internal.codegen.ErrorMessages.COMPONENT_ANNOTATED_REUSABLE;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -124,7 +123,10 @@ public ComponentValidationReport validate(
 
     Optional<AnnotationMirror> reusableAnnotation = getAnnotationMirror(subject, Reusable.class);
     if (reusableAnnotation.isPresent()) {
-      builder.addError(COMPONENT_ANNOTATED_REUSABLE, subject, reusableAnnotation.get());
+      builder.addError(
+          "@Reusable cannot be applied to components or subcomponents",
+          subject,
+          reusableAnnotation.get());
     }
 
     DeclaredType subjectType = MoreTypes.asDeclared(subject.asType());
diff --git a/java/dagger/internal/codegen/DuplicateBindingsValidation.java b/java/dagger/internal/codegen/DuplicateBindingsValidation.java
index 6074d38fe..7c8686145 100644
--- a/java/dagger/internal/codegen/DuplicateBindingsValidation.java
+++ b/java/dagger/internal/codegen/DuplicateBindingsValidation.java
@@ -22,7 +22,6 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSetMultimap;
 import static dagger.internal.codegen.DuplicateBindingsValidation.SourceAndRequest.indexEdgesBySourceAndRequest;
-import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.internal.codegen.Optionals.emptiesLast;
 import static java.util.Comparator.comparing;
@@ -160,7 +159,7 @@ private void formatDeclarations(
       int indentLevel,
       Iterable<? extends BindingDeclaration> bindingDeclarations) {
     bindingDeclarationFormatter.formatIndentedList(
-        builder, ImmutableList.copyOf(bindingDeclarations), indentLevel, DUPLICATE_SIZE_LIMIT);
+        builder, ImmutableList.copyOf(bindingDeclarations), indentLevel);
     builder.append('\n');
   }
 
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 742349cde..fcc31a5e9 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -16,20 +16,9 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
-import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
-import static java.util.stream.Collectors.joining;
-
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
-import dagger.multibindings.Multibinds;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ForReleasableReferences;
-import java.lang.annotation.Annotation;
-import java.util.Collection;
 import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
@@ -38,231 +27,13 @@
  * The collection of error messages to be reported back to users.
  */
 final class ErrorMessages {
-  static final int DUPLICATE_SIZE_LIMIT = 10;
-
-  /*
-   * JSR-330 errors
-   *
-   * These are errors that are explicitly outlined in the JSR-330 APIs
-   */
-
-  /* constructors */
-  static final String MULTIPLE_INJECT_CONSTRUCTORS =
-      "Types may only contain one @Inject constructor.";
-
-  /* fields */
-  static final String FINAL_INJECT_FIELD = "@Inject fields may not be final";
-
-  /* methods */
-  static final String ABSTRACT_INJECT_METHOD = "Methods with @Inject may not be abstract.";
-  static final String GENERIC_INJECT_METHOD =
-      "Methods with @Inject may not declare type parameters.";
-
-  /* qualifiers */
-  static final String MULTIPLE_QUALIFIERS =
-      "A single injection site may not use more than one @Qualifier.";
-
-  /* scope */
-  static final String MULTIPLE_SCOPES = "A single binding may not declare more than one @Scope.";
-
-  /*
-   * Dagger errors
-   *
-   * These are errors that arise due to restrictions imposed by the dagger implementation.
-   */
-
-  /* constructors */
-  static final String INJECT_ON_PRIVATE_CONSTRUCTOR =
-      "Dagger does not support injection into private constructors";
-  static final String INJECT_CONSTRUCTOR_ON_INNER_CLASS =
-      "@Inject constructors are invalid on inner classes. Did you mean to make the class static?";
-  static final String INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS =
-      "@Inject is nonsense on the constructor of an abstract class";
-  static final String QUALIFIER_ON_INJECT_CONSTRUCTOR =
-      "@Qualifier annotations are not allowed on @Inject constructors.";
-  static final String SCOPE_ON_INJECT_CONSTRUCTOR =
-      "@Scope annotations are not allowed on @Inject constructors. Annotate the class instead.";
-  static final String CHECKED_EXCEPTIONS_ON_CONSTRUCTORS =
-      "Dagger does not support checked exceptions on @Inject constructors.";
-
-  /* fields */
-  static final String PRIVATE_INJECT_FIELD =
-      "Dagger does not support injection into private fields";
-
-  static final String STATIC_INJECT_FIELD =
-      "Dagger does not support injection into static fields";
-
-  /* methods */
-  static final String PRIVATE_INJECT_METHOD =
-      "Dagger does not support injection into private methods";
-
-  static final String STATIC_INJECT_METHOD =
-      "Dagger does not support injection into static methods";
-
-  /* all */
-  static final String INJECT_INTO_PRIVATE_CLASS =
-      "Dagger does not support injection into private classes";
-
-  /*
-   * Configuration errors
-   *
-   * These are errors that relate specifically to the Dagger configuration API (@Module, @Provides,
-   * etc.)
-   */
-  static final String COMPONENT_ANNOTATED_REUSABLE =
-      "@Reusable cannot be applied to components or subcomponents.";
-
-  static final String BINDING_METHOD_RETURN_TYPE =
-      "@%s methods must return a primitive, an array, a type variable, or a declared type.";
-
-  static final String BINDING_METHOD_THROWS_CHECKED =
-      "@%s methods may only throw unchecked exceptions";
-
-  static final String PRODUCES_METHOD_NULLABLE =
-      "@Nullable on @Produces methods does not do anything.";
-
-  static final String PRODUCES_METHOD_RETURN_TYPE =
-      "@Produces methods must return a primitive, an array, a type variable, or a declared type, "
-          + "or a ListenableFuture of one of those types.";
-
-  static final String PRODUCES_METHOD_RAW_FUTURE =
-      "@Produces methods cannot return a raw ListenableFuture.";
-
-  static final String BINDING_METHOD_SET_VALUES_RAW_SET =
-      "@%s methods of type set values cannot return a raw Set";
-
-  static final String BINDING_METHOD_SET_VALUES_RETURN_SET =
-      "@%s methods of type set values must return a Set";
-
-  static final String PRODUCES_METHOD_SET_VALUES_RETURN_SET =
-      "@Produces methods of type set values must return a Set or ListenableFuture of Set";
-
-  static final String PRODUCES_METHOD_SCOPE = "@Produces methods may not have scope annotations.";
-
-  static final String BINDING_METHOD_THROWS =
-      "@%s methods may only throw unchecked exceptions or exceptions subclassing Exception";
-
-  static final String BINDING_METHOD_THROWS_ANY = "@%s methods may not throw";
-
-  static final String BINDING_METHOD_MUST_RETURN_A_VALUE =
-      "@%s methods must return a value (not void).";
-
-  static final String BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES =
-      "@%s methods must not return framework types.";
-
-  static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
-
-  static final String BINDING_METHOD_NOT_ABSTRACT = "@%s methods must be abstract";
-
-  static final String BINDING_METHOD_PRIVATE = "@%s methods cannot be private";
-
-  static final String BINDING_METHOD_TYPE_PARAMETER =
-      "@%s methods may not have type parameters.";
-
-  // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
-  // right-hand-side might not be assignable to the left-hand-side, but still compatible with
-  // Set.addAll(Collection<? extends E>)
-  static final String BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER =
-      "@Binds methods must have only one parameter whose type is assignable to the return type";
-
-  static final String BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER =
-      "@BindsOptionalOf methods must not have parameters";
-
-  static final String BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE =
-      "@BindsOptionalOf methods cannot "
-          + "return unqualified types that have an @Inject-annotated constructor because those are "
-          + "always present";
-
-  static final String BINDING_METHOD_NOT_IN_MODULE = "@%s methods can only be present within a @%s";
-
-  static final String BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET =
-      "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter";
-
-  static final String BINDING_METHOD_NOT_MAP_HAS_MAP_KEY =
-      "@%s methods of non map type cannot declare a map key";
-
-  static final String BINDING_METHOD_WITH_NO_MAP_KEY =
-      "@%s methods of type map must declare a map key";
-
-  static final String BINDING_METHOD_WITH_MULTIPLE_MAP_KEYS =
-      "@%s methods may not have more than one @MapKey-marked annotation";
-
-  static final String BINDING_METHOD_WITH_SAME_NAME =
-      "Cannot have more than one @%s method with the same name in a single module";
-
-  static final String INCOMPATIBLE_MODULE_METHODS =
-      "A @%1$s may not contain both non-static @%2$s methods and abstract @Binds or @Multibinds "
-          + "declarations";
-
-  static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT =
-      "Modules with type parameters must be abstract";
-
-  static final String REFERENCED_MODULE_NOT_ANNOTATED =
-      "%s is listed as a module, but is not annotated with %s";
-
-  static final String REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS =
-      "%s is listed as a module, but has type parameters";
-
-  static final String PROVIDES_METHOD_OVERRIDES_ANOTHER =
-      "@%s methods may not override another method. Overrides: %s";
-
-  static final String METHOD_OVERRIDES_PROVIDES_METHOD =
-      "@%s methods may not be overridden in modules. Overrides: %s";
-
-  static final String BINDING_METHOD_MULTIPLE_QUALIFIERS =
-      "Cannot use more than one @Qualifier";
-
-  /* mapKey errors */
-  static final String MAPKEY_WITHOUT_MEMBERS = "Map key annotations must have members";
-
-  static final String UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS=
-      "Map key annotations with unwrapped values must have exactly one member";
-
-  static final String UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER =
-      "Map key annotations with unwrapped values cannot use arrays";
-
-  /* producer errors */
-  static final String DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT =
-      "%s may not depend on the production executor.";
-
-  private static final String PROVISION_MAY_NOT_DEPEND_ON_PRODUCER_TYPE_FORMAT =
-      "%s may only be injected in @Produces methods.";
 
   static String provisionMayNotDependOnProducerType(TypeMirror type) {
     return String.format(
-        PROVISION_MAY_NOT_DEPEND_ON_PRODUCER_TYPE_FORMAT,
+        "%s may only be injected in @Produces methods",
         MoreTypes.asTypeElement(type).getSimpleName());
   }
 
-  static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "Found a dependency cycle:\n%s";
-
-  static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD =
-      "Cannot return null from a non-@Nullable component method";
-
-  static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD =
-      "Cannot return null from a non-@Nullable @Provides method";
-
-  /* Multibinding messages */
-  static final String MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD =
-      "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods";
-
-  static final String MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD =
-      "Multiple multibinding annotations cannot be placed on the same %s method";
-
-  static final String MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM =
-      "@%s.type cannot be used with multibinding annotations";
-
-  /* BindsInstance messages. */
-  static final String BINDS_INSTANCE_IN_MODULE =
-      "@BindsInstance methods should not be included in @%ss. Did you mean @Binds?";
-
-  static final String BINDS_INSTANCE_IN_INVALID_COMPONENT =
-      "@BindsInstance methods should not be included in @%1$ss. "
-          + "Did you mean to put it in a @%1$s.Builder?";
-
-  static final String BINDS_INSTANCE_ONE_PARAMETER =
-      "@BindsInstance methods should have exactly one parameter for the bound type";
-
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
       case COMPONENT:
@@ -278,63 +49,6 @@ static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     }
   }
 
-  static final String CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION =
-      "@CanReleaseReferences annotations must not have SOURCE retention";
-
-  static String forReleasableReferencesValueNotAScope(TypeElement scopeType) {
-    return forReleasableReferencesValueNeedsAnnotation(
-        scopeType,
-        String.format(
-            "@%s and @%s",
-            javax.inject.Scope.class.getCanonicalName(),
-            CanReleaseReferences.class.getCanonicalName()));
-  }
-
-  static String forReleasableReferencesValueCannotReleaseReferences(TypeElement scopeType) {
-    return forReleasableReferencesValueNeedsAnnotation(
-        scopeType, "@" + CanReleaseReferences.class.getCanonicalName());
-  }
-
-  private static String forReleasableReferencesValueNeedsAnnotation(
-      TypeElement scopeType, String annotations) {
-    return String.format(
-        "The value of @%s must be a reference-releasing scope. "
-            + "Did you mean to annotate %s with %s? Or did you mean to use a different class here?",
-        ForReleasableReferences.class.getSimpleName(), scopeType.getQualifiedName(), annotations);
-  }
-
-  /**
-   * Returns an error message for a method that has more than one binding method annotation.
-   *
-   * @param methodAnnotations the valid method annotations, only one of which may annotate the
-   *     method
-   */
-  static String tooManyBindingMethodAnnotations(
-      ExecutableElement method, Collection<Class<? extends Annotation>> methodAnnotations) {
-    return String.format(
-        "%s is annotated with more than one of (%s)",
-        method.getSimpleName(),
-        methodAnnotations.stream().map(Class::getCanonicalName).collect(joining(", ")));
-  }
-
-  static String abstractModuleHasInstanceBindingMethods(ModuleDescriptor module) {
-    String methodAnnotations;
-    switch (module.kind()) {
-      case MODULE:
-        methodAnnotations = "@Provides";
-        break;
-      case PRODUCER_MODULE:
-        methodAnnotations = "@Provides or @Produces";
-        break;
-      default:
-        throw new AssertionError(module.kind());
-    }
-    return String.format(
-        "%s is abstract and has instance %s methods. Consider making the methods static or "
-            + "including a non-abstract subclass of the module instead.",
-        module.moduleElement(), methodAnnotations);
-  }
-
   static class ComponentBuilderMessages {
     static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
 
@@ -501,47 +215,5 @@ protected String process(String s) {
     }
   }
 
-  /** Error messages related to {@link Multibinds @Multibinds} methods. */
-  static final class MultibindsMessages {
-    static final String METHOD_MUST_RETURN_MAP_OR_SET =
-        "@%s methods must return Map<K, V> or Set<T>";
-
-    static final String PARAMETERS = "@%s methods cannot have parameters";
-
-    private MultibindsMessages() {}
-  }
-
-  static class ModuleMessages {
-    static String moduleSubcomponentsIncludesBuilder(TypeElement moduleSubcomponentsAttribute) {
-      TypeElement subcomponentType =
-          MoreElements.asType(moduleSubcomponentsAttribute.getEnclosingElement());
-      return String.format(
-          "%s is a @%s.Builder. Did you mean to use %s?",
-          moduleSubcomponentsAttribute.getQualifiedName(),
-          simpleName(getSubcomponentAnnotation(subcomponentType).get()),
-          subcomponentType.getQualifiedName());
-    }
-
-    static String moduleSubcomponentsIncludesNonSubcomponent(
-        TypeElement moduleSubcomponentsAttribute) {
-      return moduleSubcomponentsAttribute.getQualifiedName()
-          + " is not a @Subcomponent or @ProductionSubcomponent";
-    }
-
-    static String moduleSubcomponentsDoesntHaveBuilder(
-        TypeElement subcomponent, AnnotationMirror moduleAnnotation) {
-      return String.format(
-          "%s doesn't have a @%s.Builder, which is required when used with @%s.subcomponents",
-          subcomponent.getQualifiedName(),
-          simpleName(getSubcomponentAnnotation(subcomponent).get()),
-          simpleName(moduleAnnotation));
-    }
-  }
-
-  //TODO(cgruber): Extract Formatter and do something less stringy.
-  static String format(AnnotationMirror annotation) {
-    return DiagnosticFormatting.stripCommonTypePrefixes(annotation.toString());
-  }
-
   private ErrorMessages() {}
 }
diff --git a/java/dagger/internal/codegen/FactoryGenerator.java b/java/dagger/internal/codegen/FactoryGenerator.java
index 01dcd9e03..3e34d3a6d 100644
--- a/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/java/dagger/internal/codegen/FactoryGenerator.java
@@ -27,7 +27,6 @@
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
-import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkFieldUsages;
@@ -303,6 +302,6 @@ static CodeBlock checkNotNullProvidesMethod(CodeBlock providesMethodInvocation)
         "$T.checkNotNull($L, $S)",
         Preconditions.class,
         providesMethodInvocation,
-        CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+        "Cannot return null from a non-@Nullable @Provides method");
   }
 }
diff --git a/java/dagger/internal/codegen/ForReleasableReferencesValidator.java b/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
index 452cb24cf..df8d3b969 100644
--- a/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
+++ b/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
@@ -19,8 +19,6 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
-import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueCannotReleaseReferences;
-import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueNotAScope;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.Scopes.scope;
 import static dagger.model.Scope.isScope;
@@ -29,6 +27,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
+import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
 import java.lang.annotation.Annotation;
 import java.util.Set;
@@ -81,4 +80,26 @@
         .forEach(report -> report.printMessagesTo(messager));
     return ImmutableSet.of();
   }
+
+  private static String forReleasableReferencesValueNotAScope(TypeElement scopeType) {
+    return forReleasableReferencesValueNeedsAnnotation(
+        scopeType,
+        String.format(
+            "@%s and @%s",
+            javax.inject.Scope.class.getCanonicalName(),
+            CanReleaseReferences.class.getCanonicalName()));
+  }
+
+  private static String forReleasableReferencesValueCannotReleaseReferences(TypeElement scopeType) {
+    return forReleasableReferencesValueNeedsAnnotation(
+        scopeType, "@" + CanReleaseReferences.class.getCanonicalName());
+  }
+
+  private static String forReleasableReferencesValueNeedsAnnotation(
+      TypeElement scopeType, String annotations) {
+    return String.format(
+        "The value of @%s must be a reference-releasing scope. "
+            + "Did you mean to annotate %s with %s? Or did you mean to use a different class here?",
+        ForReleasableReferences.class.getSimpleName(), scopeType.getQualifiedName(), annotations);
+  }
 }
diff --git a/java/dagger/internal/codegen/Formatter.java b/java/dagger/internal/codegen/Formatter.java
index 176477e06..674f2cb40 100644
--- a/java/dagger/internal/codegen/Formatter.java
+++ b/java/dagger/internal/codegen/Formatter.java
@@ -31,6 +31,7 @@
 
   static final String INDENT = "    ";
   static final String DOUBLE_INDENT = INDENT + INDENT;
+  private static final int LIST_LIMIT = 10;
 
   /**
    * Performs the transformation of an object into a string representation.
@@ -51,26 +52,15 @@ public final String apply(T object) {
     return format(object);
   }
 
-  /**
-   * Formats {@code items}, one per line. Stops after {@code limit} items.
-   */
+  /** Formats {@code items}, one per line. Stops after {@value #LIST_LIMIT} items. */
   public void formatIndentedList(
-      StringBuilder builder, Iterable<? extends T> items, int indentLevel, int limit) {
-    formatIndentedList(
-        builder, indentLevel, Iterables.limit(items, limit), Iterables.skip(items, limit));
-  }
-
-  private void formatIndentedList(
-      StringBuilder builder,
-      int indentLevel,
-      Iterable<? extends T> firstItems,
-      Iterable<? extends T> restOfItems) {
-    for (T item : firstItems) {
+      StringBuilder builder, Iterable<? extends T> items, int indentLevel) {
+    for (T item : Iterables.limit(items, LIST_LIMIT)) {
       builder.append('\n');
       appendIndent(builder, indentLevel);
       builder.append(format(item));
     }
-    int numberOfOtherItems = Iterables.size(restOfItems);
+    int numberOfOtherItems = Iterables.size(items) - LIST_LIMIT;
     if (numberOfOtherItems > 0) {
       builder.append('\n');
       appendIndent(builder, indentLevel);
diff --git a/java/dagger/internal/codegen/InjectValidator.java b/java/dagger/internal/codegen/InjectValidator.java
index 68d69bc54..4d6c89b03 100644
--- a/java/dagger/internal/codegen/InjectValidator.java
+++ b/java/dagger/internal/codegen/InjectValidator.java
@@ -17,24 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.Accessibility.isElementAccessibleFromOwnPackage;
-import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.CHECKED_EXCEPTIONS_ON_CONSTRUCTORS;
-import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
-import static dagger.internal.codegen.ErrorMessages.SCOPE_ON_INJECT_CONSTRUCTOR;
-import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
@@ -48,11 +30,13 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.ValidationReport.Builder;
 import dagger.model.Scope;
 import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
@@ -103,24 +87,26 @@ InjectValidator whenGeneratingCode() {
     ValidationReport.Builder<TypeElement> builder =
         ValidationReport.about(MoreElements.asType(constructorElement.getEnclosingElement()));
     if (constructorElement.getModifiers().contains(PRIVATE)) {
-      builder.addError(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
+      builder.addError(
+          "Dagger does not support injection into private constructors", constructorElement);
     }
 
     for (AnnotationMirror qualifier : getQualifiers(constructorElement)) {
-      builder.addError(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);
+      builder.addError(
+          "@Qualifier annotations are not allowed on @Inject constructors",
+          constructorElement,
+          qualifier);
     }
 
     for (Scope scope : scopesOf(constructorElement)) {
-      builder.addError(SCOPE_ON_INJECT_CONSTRUCTOR, constructorElement, scope.scopeAnnotation());
+      builder.addError(
+          "@Scope annotations are not allowed on @Inject constructors; annotate the class instead",
+          constructorElement,
+          scope.scopeAnnotation());
     }
 
     for (VariableElement parameter : constructorElement.getParameters()) {
-      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
-      if (qualifiers.size() > 1) {
-        for (AnnotationMirror qualifier : qualifiers) {
-          builder.addError(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
-        }
-      }
+      checkMultipleQualifiers(constructorElement, parameter, builder);
       if (FrameworkTypes.isProducerType(parameter.asType())) {
         builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
       }
@@ -128,44 +114,45 @@ InjectValidator whenGeneratingCode() {
 
     if (throwsCheckedExceptions(constructorElement)) {
       builder.addItem(
-          CHECKED_EXCEPTIONS_ON_CONSTRUCTORS,
+          "Dagger does not support checked exceptions on @Inject constructors",
           privateAndStaticInjectionDiagnosticKind.orElse(
               compilerOptions.privateMemberValidationKind()),
           constructorElement);
     }
 
+    checkInjectIntoPrivateClass(constructorElement, builder);
+
     TypeElement enclosingElement =
         MoreElements.asType(constructorElement.getEnclosingElement());
-    Set<Modifier> typeModifiers = enclosingElement.getModifiers();
-
-    if (!Accessibility.isElementAccessibleFromOwnPackage(enclosingElement)) {
-      builder.addItem(
-          INJECT_INTO_PRIVATE_CLASS,
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.privateMemberValidationKind()),
-          constructorElement);
-    }
 
+    Set<Modifier> typeModifiers = enclosingElement.getModifiers();
     if (typeModifiers.contains(ABSTRACT)) {
-      builder.addError(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
+      builder.addError(
+          "@Inject is nonsense on the constructor of an abstract class", constructorElement);
     }
 
     if (enclosingElement.getNestingKind().isNested()
         && !typeModifiers.contains(STATIC)) {
-      builder.addError(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
+      builder.addError(
+          "@Inject constructors are invalid on inner classes. "
+              + "Did you mean to make the class static?",
+          constructorElement);
     }
 
     // This is computationally expensive, but probably preferable to a giant index
     ImmutableSet<ExecutableElement> injectConstructors = injectedConstructors(enclosingElement);
 
     if (injectConstructors.size() > 1) {
-      builder.addError(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
+      builder.addError("Types may only contain one @Inject constructor", constructorElement);
     }
 
     ImmutableSet<Scope> scopes = scopesOf(enclosingElement);
     if (scopes.size() > 1) {
       for (Scope scope : scopes) {
-        builder.addError(MULTIPLE_SCOPES, enclosingElement, scope.scopeAnnotation());
+        builder.addError(
+            "A single binding may not declare more than one @Scope",
+            enclosingElement,
+            scope.scopeAnnotation());
       }
     }
 
@@ -176,12 +163,12 @@ InjectValidator whenGeneratingCode() {
     ValidationReport.Builder<VariableElement> builder = ValidationReport.about(fieldElement);
     Set<Modifier> modifiers = fieldElement.getModifiers();
     if (modifiers.contains(FINAL)) {
-      builder.addError(FINAL_INJECT_FIELD, fieldElement);
+      builder.addError("@Inject fields may not be final", fieldElement);
     }
 
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
-          PRIVATE_INJECT_FIELD,
+          "Dagger does not support injection into private fields",
           privateAndStaticInjectionDiagnosticKind.orElse(
               compilerOptions.privateMemberValidationKind()),
           fieldElement);
@@ -189,18 +176,13 @@ InjectValidator whenGeneratingCode() {
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
-          STATIC_INJECT_FIELD,
+          "Dagger does not support injection into static fields",
           privateAndStaticInjectionDiagnosticKind.orElse(
               compilerOptions.staticMemberValidationKind()),
           fieldElement);
     }
 
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
-      }
-    }
+    checkMultipleQualifiers(fieldElement, fieldElement, builder);
 
     if (FrameworkTypes.isProducerType(fieldElement.asType())) {
       builder.addError(provisionMayNotDependOnProducerType(fieldElement.asType()), fieldElement);
@@ -213,12 +195,12 @@ InjectValidator whenGeneratingCode() {
     ValidationReport.Builder<ExecutableElement> builder = ValidationReport.about(methodElement);
     Set<Modifier> modifiers = methodElement.getModifiers();
     if (modifiers.contains(ABSTRACT)) {
-      builder.addError(ABSTRACT_INJECT_METHOD, methodElement);
+      builder.addError("Methods with @Inject may not be abstract", methodElement);
     }
 
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
-          PRIVATE_INJECT_METHOD,
+          "Dagger does not support injection into private methods",
           privateAndStaticInjectionDiagnosticKind.orElse(
               compilerOptions.privateMemberValidationKind()),
           methodElement);
@@ -226,23 +208,18 @@ InjectValidator whenGeneratingCode() {
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
-          STATIC_INJECT_METHOD,
+          "Dagger does not support injection into static methods",
           privateAndStaticInjectionDiagnosticKind.orElse(
               compilerOptions.staticMemberValidationKind()),
           methodElement);
     }
 
     if (!methodElement.getTypeParameters().isEmpty()) {
-      builder.addError(GENERIC_INJECT_METHOD, methodElement);
+      builder.addError("Methods with @Inject may not declare type parameters", methodElement);
     }
 
     for (VariableElement parameter : methodElement.getParameters()) {
-      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
-      if (qualifiers.size() > 1) {
-        for (AnnotationMirror qualifier : qualifiers) {
-          builder.addError(MULTIPLE_QUALIFIERS, methodElement, qualifier);
-        }
-      }
+      checkMultipleQualifiers(methodElement, parameter, builder);
       if (FrameworkTypes.isProducerType(parameter.asType())) {
         builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
       }
@@ -275,12 +252,8 @@ InjectValidator whenGeneratingCode() {
       }
     }
 
-    if (hasInjectedMembers && !isElementAccessibleFromOwnPackage(typeElement)) {
-      builder.addItem(
-          INJECT_INTO_PRIVATE_CLASS,
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.privateMemberValidationKind()),
-          typeElement);
+    if (hasInjectedMembers) {
+      checkInjectIntoPrivateClass(typeElement, builder);
     }
     TypeMirror superclass = typeElement.getSuperclass();
     if (!superclass.getKind().equals(TypeKind.NONE)) {
@@ -330,4 +303,31 @@ private boolean throwsCheckedExceptions(ExecutableElement methodElement) {
     }
     return false;
   }
+
+  // TODO(dpb,ronshapiro): Use this on AnyBindingMethodValidator, or a DependencyRequestValidator.
+  // Currently, @Provides and @Produces methods with multiple qualifiers on a dependency will crash
+  // the compiler.
+  private void checkMultipleQualifiers(
+      Element errorElement, Element qualifiedElement, ValidationReport.Builder<?> builder) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(qualifiedElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addError(
+            "A single injection site may not use more than one @Qualifier",
+            errorElement,
+            qualifier);
+      }
+    }
+  }
+
+  private void checkInjectIntoPrivateClass(Element element, Builder<TypeElement> builder) {
+    if (!Accessibility.isElementAccessibleFromOwnPackage(
+        DaggerElements.closestEnclosingTypeElement(element))) {
+      builder.addItem(
+          "Dagger does not support injection into private classes",
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.privateMemberValidationKind()),
+          element);
+    }
+  }
 }
diff --git a/java/dagger/internal/codegen/MapKeyValidator.java b/java/dagger/internal/codegen/MapKeyValidator.java
index a1a69b912..e9027ba10 100644
--- a/java/dagger/internal/codegen/MapKeyValidator.java
+++ b/java/dagger/internal/codegen/MapKeyValidator.java
@@ -16,9 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.ErrorMessages.MAPKEY_WITHOUT_MEMBERS;
-import static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER;
-import static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import dagger.MapKey;
@@ -46,12 +43,13 @@
     ValidationReport.Builder<Element> builder = ValidationReport.about(element);
     List<ExecutableElement> members = methodsIn(((TypeElement) element).getEnclosedElements());
     if (members.isEmpty()) {
-      builder.addError(MAPKEY_WITHOUT_MEMBERS, element);
+      builder.addError("Map key annotations must have members", element);
     } else if (element.getAnnotation(MapKey.class).unwrapValue()) {
       if (members.size() > 1) {
-        builder.addError(UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS, element);
+        builder.addError(
+            "Map key annotations with unwrapped values must have exactly one member", element);
       } else if (members.get(0).getReturnType().getKind() == TypeKind.ARRAY) {
-        builder.addError(UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER, element);
+        builder.addError("Map key annotations with unwrapped values cannot use arrays", element);
       }
     } else if (autoAnnotationIsMissing()) {
       builder.addError(
diff --git a/java/dagger/internal/codegen/MapMultibindingValidation.java b/java/dagger/internal/codegen/MapMultibindingValidation.java
index 1f963717a..0c6893336 100644
--- a/java/dagger/internal/codegen/MapMultibindingValidation.java
+++ b/java/dagger/internal/codegen/MapMultibindingValidation.java
@@ -19,7 +19,6 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
 import static javax.tools.Diagnostic.Kind.ERROR;
@@ -135,8 +134,7 @@ private String inconsistentMapKeyAnnotationTypesErrorMessage(
         .forEach(
             (annotationType, contributions) -> {
               message.append('\n').append(INDENT).append(annotationType.get()).append(':');
-              bindingDeclarationFormatter.formatIndentedList(
-                  message, contributions, 2, DUPLICATE_SIZE_LIMIT);
+              bindingDeclarationFormatter.formatIndentedList(message, contributions, 2);
             });
     return message.toString();
   }
@@ -145,8 +143,7 @@ private String duplicateMapKeyErrorMessage(
       Set<ContributionBinding> contributionsForOneMapKey, Key mapBindingKey) {
     StringBuilder message =
         new StringBuilder("The same map key is bound more than once for ").append(mapBindingKey);
-    bindingDeclarationFormatter.formatIndentedList(
-        message, contributionsForOneMapKey, 1, DUPLICATE_SIZE_LIMIT);
+    bindingDeclarationFormatter.formatIndentedList(message, contributionsForOneMapKey, 1);
     return message.toString();
   }
 }
diff --git a/java/dagger/internal/codegen/MethodSignatureFormatter.java b/java/dagger/internal/codegen/MethodSignatureFormatter.java
index 893aa97d5..6ffee05d0 100644
--- a/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -71,7 +71,7 @@ public String format(ExecutableElement method, Optional<DeclaredType> container)
         if (i > 0) {
           builder.append(' ');
         }
-        builder.append(ErrorMessages.format(annotationIterator.next()));
+        builder.append(formatAnnotation(annotationIterator.next()));
       }
       builder.append(' ');
     }
@@ -99,7 +99,7 @@ private static void appendParameter(StringBuilder builder, VariableElement param
     getQualifier(parameter)
         .ifPresent(
             qualifier -> {
-              builder.append(ErrorMessages.format(qualifier)).append(' ');
+              builder.append(formatAnnotation(qualifier)).append(' ');
             });
     builder.append(nameOfType(type));
   }
@@ -107,4 +107,8 @@ private static void appendParameter(StringBuilder builder, VariableElement param
   private static String nameOfType(TypeMirror type) {
     return stripCommonTypePrefixes(type.toString());
   }
+
+  private static String formatAnnotation(AnnotationMirror annotation) {
+    return stripCommonTypePrefixes(annotation.toString());
+  }
 }
diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index eadcfe732..89715eaf0 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -26,20 +26,12 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
-import static dagger.internal.codegen.ErrorMessages.INCOMPATIBLE_MODULE_METHODS;
-import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
-import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsDoesntHaveBuilder;
-import static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsIncludesBuilder;
-import static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsIncludesNonSubcomponent;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;
-import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
-import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
+import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
 import static dagger.internal.codegen.MoreAnnotationValues.asType;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static java.util.EnumSet.noneOf;
@@ -208,7 +200,8 @@ void addKnownModules(Collection<TypeElement> modules) {
         EnumSet.of(ModuleMethodKind.ABSTRACT_DECLARATION, ModuleMethodKind.INSTANCE_BINDING))) {
       builder.addError(
           String.format(
-              INCOMPATIBLE_MODULE_METHODS,
+              "A @%s may not contain both non-static @%s methods and "
+                  + "abstract @Binds or @Multibinds declarations",
               moduleKind.moduleAnnotation().getSimpleName(),
               moduleKind.methodAnnotation().getSimpleName()));
     }
@@ -264,6 +257,22 @@ public Void visitDeclared(DeclaredType declaredType, Void aVoid) {
     }
   }
 
+  private static String moduleSubcomponentsIncludesNonSubcomponent(TypeElement notSubcomponent) {
+    return notSubcomponent.getQualifiedName()
+        + " is not a @Subcomponent or @ProductionSubcomponent";
+  }
+
+  private static String moduleSubcomponentsIncludesBuilder(
+      TypeElement moduleSubcomponentsAttribute) {
+    TypeElement subcomponentType =
+        MoreElements.asType(moduleSubcomponentsAttribute.getEnclosingElement());
+    return String.format(
+        "%s is a @%s.Builder. Did you mean to use %s?",
+        moduleSubcomponentsAttribute.getQualifiedName(),
+        simpleName(getSubcomponentAnnotation(subcomponentType).get()),
+        subcomponentType.getQualifiedName());
+  }
+
   private static void validateSubcomponentHasBuilder(
       TypeElement subcomponentAttribute,
       AnnotationMirror moduleAnnotation,
@@ -277,6 +286,15 @@ private static void validateSubcomponentHasBuilder(
         moduleAnnotation);
   }
 
+  private static String moduleSubcomponentsDoesntHaveBuilder(
+      TypeElement subcomponent, AnnotationMirror moduleAnnotation) {
+    return String.format(
+        "%s doesn't have a @%s.Builder, which is required when used with @%s.subcomponents",
+        subcomponent.getQualifiedName(),
+        simpleName(getSubcomponentAnnotation(subcomponent).get()),
+        simpleName(moduleAnnotation));
+  }
+
   enum ModuleMethodKind {
     ABSTRACT_DECLARATION,
     INSTANCE_BINDING,
@@ -299,7 +317,7 @@ private void validateModifiers(
     // This coupled with the check for abstract modules in ComponentValidator guarantees that
     // only modules without type parameters are referenced from @Component(modules={...}).
     if (!subject.getTypeParameters().isEmpty() && !subject.getModifiers().contains(ABSTRACT)) {
-      builder.addError(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT, subject);
+      builder.addError("Modules with type parameters must be abstract", subject);
     }
   }
 
@@ -313,7 +331,8 @@ private void validateMethodsWithSameName(
         for (ExecutableElement offendingMethod : entry.getValue()) {
           builder.addError(
               String.format(
-                  BINDING_METHOD_WITH_SAME_NAME, moduleKind.methodAnnotation().getSimpleName()),
+                  "Cannot have more than one @%s method with the same name in a single module",
+                  moduleKind.methodAnnotation().getSimpleName()),
               offendingMethod);
         }
       }
@@ -373,11 +392,12 @@ public Void visitDeclared(DeclaredType t, Void p) {
                   TypeElement module = MoreElements.asType(t.asElement());
                   if (!t.getTypeArguments().isEmpty()) {
                     reportError(
-                        REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS, module.getQualifiedName());
+                        "%s is listed as a module, but has type parameters",
+                        module.getQualifiedName());
                   }
                   if (!isAnyAnnotationPresent(module, validModuleAnnotations)) {
                     reportError(
-                        REFERENCED_MODULE_NOT_ANNOTATED,
+                        "%s is listed as a module, but is not annotated with %s",
                         module.getQualifiedName(),
                         (validModuleAnnotations.size() > 1 ? "one of " : "")
                             + validModuleAnnotations
@@ -439,7 +459,7 @@ private void validateProvidesOverrides(
             failedMethods.add(providesMethod);
             builder.addError(
                 String.format(
-                    PROVIDES_METHOD_OVERRIDES_ANOTHER,
+                    "@%s methods may not override another method. Overrides: %s",
                     moduleKind.methodAnnotation().getSimpleName(),
                     methodSignatureFormatter.format(superclassMethod)),
                 providesMethod);
@@ -453,7 +473,7 @@ private void validateProvidesOverrides(
               failedMethods.add(method);
               builder.addError(
                   String.format(
-                      METHOD_OVERRIDES_PROVIDES_METHOD,
+                      "@%s methods may not be overridden in modules. Overrides: %s",
                       moduleKind.methodAnnotation().getSimpleName(),
                       methodSignatureFormatter.format(superclassMethod)),
                   method);
diff --git a/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java b/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
index f646b5c91..4f9c31d95 100644
--- a/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
+++ b/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
@@ -18,7 +18,6 @@
 
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
-import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.common.collect.ImmutableSet;
@@ -67,7 +66,10 @@
       if (!isAnyAnnotationPresent(element, VALID_BINDING_ANNOTATIONS)) {
         AnnotationMirror annotation = getAnnotationMirror(entry.getValue(), entry.getKey()).get();
         messager.printMessage(
-            Kind.ERROR, MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD, element, annotation);
+            Kind.ERROR,
+            "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods",
+            element,
+            annotation);
       }
     }
     return ImmutableSet.of();
diff --git a/java/dagger/internal/codegen/MultibindsMethodValidator.java b/java/dagger/internal/codegen/MultibindsMethodValidator.java
index f780e9423..bfac2839a 100644
--- a/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -19,8 +19,6 @@
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;
-import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
-import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.PARAMETERS;
 import static dagger.internal.codegen.FrameworkTypes.isFrameworkType;
 
 import com.google.auto.common.MoreTypes;
@@ -58,7 +56,7 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
 
   private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getParameters().isEmpty()) {
-      builder.addError(formatErrorMessage(PARAMETERS));
+      builder.addError(bindingMethods("cannot have parameters"));
     }
   }
 
@@ -67,7 +65,7 @@ private void checkParameters(ValidationReport.Builder<ExecutableElement> builder
   protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
     if (!isPlainMap(builder.getSubject().getReturnType())
         && !isPlainSet(builder.getSubject().getReturnType())) {
-      builder.addError(formatErrorMessage(METHOD_MUST_RETURN_MAP_OR_SET));
+      builder.addError(bindingMethods("must return Map<K, V> or Set<T>"));
     }
   }
 
diff --git a/java/dagger/internal/codegen/ProducesMethodValidator.java b/java/dagger/internal/codegen/ProducesMethodValidator.java
index a49336fd1..2245dff30 100644
--- a/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -20,11 +20,6 @@
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.EXCEPTION;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_NULLABLE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SCOPE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.Scopes.scopesOf;
 
 import com.google.auto.common.MoreTypes;
@@ -68,20 +63,21 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
   // TODO(beder): Properly handle nullable with producer methods.
   private void checkNullable(ValidationReport.Builder<ExecutableElement> builder) {
     if (ConfigurationAnnotations.getNullableType(builder.getSubject()).isPresent()) {
-      builder.addWarning(PRODUCES_METHOD_NULLABLE);
+      builder.addWarning("@Nullable on @Produces methods does not do anything");
     }
   }
 
   /** Adds an error if a {@link Produces @Produces} method has a scope annotation. */
   private void checkScope(ValidationReport.Builder<ExecutableElement> builder) {
     if (!scopesOf(builder.getSubject()).isEmpty()) {
-      builder.addError(PRODUCES_METHOD_SCOPE);
+      builder.addError("@Produces methods may not have scope annotations");
     }
   }
 
   @Override
   protected String badReturnTypeMessage() {
-    return formatErrorMessage(PRODUCES_METHOD_RETURN_TYPE);
+    return "@Produces methods can return only a primitive, an array, a type variable, "
+        + "a declared type, or a ListenableFuture of one of those types";
   }
 
   /**
@@ -115,7 +111,7 @@ protected void checkSetValuesType(ValidationReport.Builder<ExecutableElement> bu
 
   @Override
   protected String badSetValuesTypeMessage() {
-    return PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+    return "@Produces methods of type set values must return a Set or ListenableFuture of Set";
   }
 
   private static Optional<TypeMirror> unwrapListenableFuture(
@@ -123,7 +119,7 @@ protected String badSetValuesTypeMessage() {
     if (MoreTypes.isType(type) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
       DeclaredType declaredType = MoreTypes.asDeclared(type);
       if (declaredType.getTypeArguments().isEmpty()) {
-        reportBuilder.addError(PRODUCES_METHOD_RAW_FUTURE);
+        reportBuilder.addError("@Produces methods cannot return a raw ListenableFuture");
         return Optional.empty();
       } else {
         return Optional.of((TypeMirror) getOnlyElement(declaredType.getTypeArguments()));
diff --git a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java b/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
index a8567173d..07c07859e 100644
--- a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
+++ b/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
@@ -18,6 +18,7 @@
 
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import com.google.common.collect.ImmutableList;
 import dagger.Module;
@@ -26,6 +27,7 @@
 import dagger.producers.ProducerModule;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
 import java.util.Collection;
 import javax.inject.Qualifier;
 import org.junit.Ignore;
@@ -132,7 +134,7 @@ public void intoMap_multipleMapKeys() {
     assertThatMethod(
             "@Binds @IntoMap @IntKey(1) @LongKey(2L) abstract Object manyMapKeys(String string);")
         .importing(IntKey.class, LongKey.class)
-        .hasError("may not have more than one @MapKey-marked annotation");
+        .hasError("may not have more than one map key");
   }
 
   private DaggerModuleMethodSubject assertThatMethod(String method) {
@@ -140,8 +142,10 @@ private DaggerModuleMethodSubject assertThatMethod(String method) {
   }
 
   @Qualifier
+  @Retention(RUNTIME)
   public @interface Qualifier1 {}
 
   @Qualifier
+  @Retention(RUNTIME)
   public @interface Qualifier2 {}
 }
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index eb79921c2..45b14c379 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -18,12 +18,13 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
-import static dagger.internal.codegen.CodeBlocks.stringLiteral;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
 import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_COMPONENT_METHOD;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Joiner;
@@ -33,7 +34,6 @@
 import com.google.common.collect.Sets;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
 import dagger.MembersInjector;
 import java.io.IOException;
 import java.io.Writer;
@@ -67,11 +67,6 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
     this.compilerMode = compilerMode;
   }
 
-  private static final CodeBlock NPE_FROM_COMPONENT_METHOD =
-      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-  private static final CodeBlock NPE_FROM_PROVIDES_METHOD =
-      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-
   @Test public void doubleBindingFromResolvedModules() {
     JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
         "package test;",
@@ -2028,7 +2023,7 @@ public void scopeAnnotationOnInjectConstructorNotValid() {
         daggerCompiler().withOptions(compilerMode.javacopts()).compile(aScope, aClass);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("@Scope annotations are not allowed on @Inject constructors.")
+        .hadErrorContaining("@Scope annotations are not allowed on @Inject constructors")
         .inFile(aClass)
         .onLine(6);
   }
diff --git a/javatests/dagger/internal/codegen/GeneratedLines.java b/javatests/dagger/internal/codegen/GeneratedLines.java
index 1b56c3a87..2d79e4a47 100644
--- a/javatests/dagger/internal/codegen/GeneratedLines.java
+++ b/javatests/dagger/internal/codegen/GeneratedLines.java
@@ -44,9 +44,8 @@ private static boolean isBeforeJava9() {
   }
 
   public static final CodeBlock NPE_FROM_PROVIDES_METHOD =
-      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+      stringLiteral("Cannot return null from a non-@Nullable @Provides method");
 
   public static final CodeBlock NPE_FROM_COMPONENT_METHOD =
-      stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-
+      stringLiteral("Cannot return null from a non-@Nullable component method");
 }
diff --git a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
index d4f5b6340..c11d04fbc 100644
--- a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -374,7 +374,7 @@ public void reusableNotAllowedOnComponent() {
     Compilation compilation = daggerCompiler().compile(someComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents.")
+        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents")
         .inFile(someComponent)
         .onLine(6);
   }
@@ -395,7 +395,7 @@ public void reusableNotAllowedOnSubcomponent() {
     Compilation compilation = daggerCompiler().compile(someSubcomponent);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents.")
+        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents")
         .inFile(someSubcomponent)
         .onLine(6);
   }
diff --git a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index a044d0975..21de94a06 100644
--- a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -21,22 +21,6 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.CHECKED_EXCEPTIONS_ON_CONSTRUCTORS;
-import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
-import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
-import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 
@@ -92,7 +76,7 @@
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(INJECT_ON_PRIVATE_CONSTRUCTOR)
+        .hadErrorContaining("Dagger does not support injection into private constructors")
         .inFile(file)
         .onLine(6);
   }
@@ -111,7 +95,9 @@
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(INJECT_CONSTRUCTOR_ON_INNER_CLASS)
+        .hadErrorContaining(
+            "@Inject constructors are invalid on inner classes. "
+                + "Did you mean to make the class static?")
         .inFile(file)
         .onLine(7);
   }
@@ -128,7 +114,7 @@
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS)
+        .hadErrorContaining("@Inject is nonsense on the constructor of an abstract class")
         .inFile(file)
         .onLine(6);
   }
@@ -555,8 +541,14 @@
         "}");
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).inFile(file).onLine(6);
-    assertThat(compilation).hadErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).inFile(file).onLine(8);
+    assertThat(compilation)
+        .hadErrorContaining("Types may only contain one @Inject constructor")
+        .inFile(file)
+        .onLine(6);
+    assertThat(compilation)
+        .hadErrorContaining("Types may only contain one @Inject constructor")
+        .inFile(file)
+        .onLine(8);
   }
 
   @Test public void multipleQualifiersOnInjectConstructorParameter() {
@@ -570,9 +562,11 @@
         "}");
     Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
-
     // for whatever reason, javac only reports the error once on the constructor
-    assertThat(compilation).hadErrorContaining(MULTIPLE_QUALIFIERS).inFile(file).onLine(6);
+    assertThat(compilation)
+        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void injectConstructorOnClassWithMultipleScopes() {
@@ -586,8 +580,16 @@
         "}");
     Compilation compilation = daggerCompiler().compile(file, SCOPE_A, SCOPE_B);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MULTIPLE_SCOPES).inFile(file).onLine(5).atColumn(1);
-    assertThat(compilation).hadErrorContaining(MULTIPLE_SCOPES).inFile(file).onLine(5).atColumn(9);
+    assertThat(compilation)
+        .hadErrorContaining("A single binding may not declare more than one @Scope")
+        .inFile(file)
+        .onLine(5)
+        .atColumn(1);
+    assertThat(compilation)
+        .hadErrorContaining("A single binding may not declare more than one @Scope")
+        .inFile(file)
+        .onLine(5)
+        .atColumn(9);
   }
 
   @Test public void injectConstructorWithQualifier() {
@@ -605,11 +607,11 @@
     Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR)
+        .hadErrorContaining("@Qualifier annotations are not allowed on @Inject constructors")
         .inFile(file)
         .onLine(7);
     assertThat(compilation)
-        .hadErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR)
+        .hadErrorContaining("@Qualifier annotations are not allowed on @Inject constructors")
         .inFile(file)
         .onLine(8);
   }
@@ -626,7 +628,7 @@
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS)
+        .hadErrorContaining("Dagger does not support checked exceptions on @Inject constructors")
         .inFile(file)
         .onLine(6);
   }
@@ -644,7 +646,7 @@
         daggerCompiler().withOptions("-Adagger.privateMemberValidation=WARNING").compile(file);
     assertThat(compilation).succeeded();
     assertThat(compilation)
-        .hadWarningContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS)
+        .hadWarningContaining("Dagger does not support checked exceptions on @Inject constructors")
         .inFile(file)
         .onLine(6);
   }
@@ -662,7 +664,10 @@
         "}");
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(INJECT_INTO_PRIVATE_CLASS).inFile(file).onLine(7);
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into private classes")
+        .inFile(file)
+        .onLine(7);
   }
 
   @Test public void privateInjectClassWarning() {
@@ -679,7 +684,10 @@
     Compilation compilation =
         daggerCompiler().withOptions("-Adagger.privateMemberValidation=WARNING").compile(file);
     assertThat(compilation).succeeded();
-    assertThat(compilation).hadWarningContaining(INJECT_INTO_PRIVATE_CLASS).inFile(file).onLine(7);
+    assertThat(compilation)
+        .hadWarningContaining("Dagger does not support injection into private classes")
+        .inFile(file)
+        .onLine(7);
   }
 
   @Test public void nestedInPrivateInjectClassError() {
@@ -697,7 +705,10 @@
         "}");
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(INJECT_INTO_PRIVATE_CLASS).inFile(file).onLine(8);
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into private classes")
+        .inFile(file)
+        .onLine(8);
   }
 
   @Test public void nestedInPrivateInjectClassWarning() {
@@ -716,7 +727,10 @@
     Compilation compilation =
         daggerCompiler().withOptions("-Adagger.privateMemberValidation=WARNING").compile(file);
     assertThat(compilation).succeeded();
-    assertThat(compilation).hadWarningContaining(INJECT_INTO_PRIVATE_CLASS).inFile(file).onLine(8);
+    assertThat(compilation)
+        .hadWarningContaining("Dagger does not support injection into private classes")
+        .inFile(file)
+        .onLine(8);
   }
 
   @Test public void finalInjectField() {
@@ -730,7 +744,10 @@
         "}");
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(FINAL_INJECT_FIELD).inFile(file).onLine(6);
+    assertThat(compilation)
+        .hadErrorContaining("@Inject fields may not be final")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void privateInjectFieldError() {
@@ -744,7 +761,10 @@
         "}");
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(PRIVATE_INJECT_FIELD).inFile(file).onLine(6);
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into private fields")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void privateInjectFieldWarning() {
@@ -772,7 +792,10 @@
         "}");
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(STATIC_INJECT_FIELD).inFile(file).onLine(6);
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into static fields")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void staticInjectFieldWarning() {
@@ -801,12 +824,12 @@
     Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(MULTIPLE_QUALIFIERS)
+        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6)
         .atColumn(11);
     assertThat(compilation)
-        .hadErrorContaining(MULTIPLE_QUALIFIERS)
+        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6)
         .atColumn(23);
@@ -823,7 +846,10 @@
         "}");
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(ABSTRACT_INJECT_METHOD).inFile(file).onLine(6);
+    assertThat(compilation)
+        .hadErrorContaining("Methods with @Inject may not be abstract")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void privateInjectMethodError() {
@@ -837,7 +863,10 @@
         "}");
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(PRIVATE_INJECT_METHOD).inFile(file).onLine(6);
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into private methods")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void privateInjectMethodWarning() {
@@ -865,7 +894,10 @@
         "}");
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(STATIC_INJECT_METHOD).inFile(file).onLine(6);
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into static methods")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void staticInjectMethodWarning() {
@@ -893,7 +925,10 @@
         "}");
     Compilation compilation = daggerCompiler().compile(file);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(GENERIC_INJECT_METHOD).inFile(file).onLine(6);
+    assertThat(compilation)
+        .hadErrorContaining("Methods with @Inject may not declare type parameters")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void multipleQualifiersOnInjectMethodParameter() {
@@ -907,7 +942,10 @@
         "}");
     Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(MULTIPLE_QUALIFIERS).inFile(file).onLine(6);
+    assertThat(compilation)
+        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void injectConstructorDependsOnProduced() {
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
index 86cab871d..547ad4ea8 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
@@ -26,7 +26,6 @@
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -47,9 +46,6 @@ public MapBindingExpressionTest(CompilerMode compilerMode) {
     this.compilerMode = compilerMode;
   }
 
-  public static final CodeBlock NPE_FROM_PROVIDES =
-      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-
   @Test
   public void mapBindings() {
     JavaFileObject mapModuleFile = JavaFileObjects.forSourceLines("test.MapModule",
diff --git a/javatests/dagger/internal/codegen/MembersInjectionTest.java b/javatests/dagger/internal/codegen/MembersInjectionTest.java
index 6d297f64d..2a7fd2194 100644
--- a/javatests/dagger/internal/codegen/MembersInjectionTest.java
+++ b/javatests/dagger/internal/codegen/MembersInjectionTest.java
@@ -23,7 +23,6 @@
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
 import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 import static javax.tools.StandardLocation.CLASS_OUTPUT;
@@ -972,7 +971,10 @@ public void fieldInjectionForShadowedMember() {
         "}");
     Compilation compilation = daggerCompiler().withOptions(compilerMode.javacopts()).compile(file);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(INJECT_INTO_PRIVATE_CLASS).inFile(file).onLine(6);
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into private classes")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void privateNestedClassWarning() {
@@ -992,7 +994,10 @@ public void fieldInjectionForShadowedMember() {
                 compilerMode.javacopts().append("-Adagger.privateMemberValidation=WARNING"))
             .compile(file);
     assertThat(compilation).succeeded();
-    assertThat(compilation).hadWarningContaining(INJECT_INTO_PRIVATE_CLASS).inFile(file).onLine(6);
+    assertThat(compilation)
+        .hadWarningContaining("Dagger does not support injection into private classes")
+        .inFile(file)
+        .onLine(6);
   }
 
   @Test public void privateSuperclassIsOkIfNotInjectedInto() {
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 88c4c67aa..3c1931b9e 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -23,26 +23,13 @@
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
-import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.NPE_FROM_PROVIDES_METHOD;
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -55,9 +42,6 @@
       JavaFileObjects.forSourceLines(
           "test.Nullable", "package test;", "public @interface Nullable {}");
 
-  private static final CodeBlock NPE_LITERAL =
-      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-
   // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have
   // for @Inject
 
@@ -71,73 +55,79 @@ private String formatModuleErrorMessage(String msg) {
 
   @Test public void providesMethodNotInModule() {
     assertThatMethodInUnannotatedClass("@Provides String provideString() { return null; }")
-        .hasError(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
+        .hasError(formatModuleErrorMessage("@%s methods can only be present within a @%s"));
   }
 
   @Test public void providesMethodAbstract() {
     assertThatModuleMethod("@Provides abstract String abstractMethod();")
-        .hasError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+        .hasError(formatErrorMessage("@%s methods cannot be abstract"));
   }
 
   @Test public void providesMethodPrivate() {
     assertThatModuleMethod("@Provides private String privateMethod() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_PRIVATE));
+        .hasError(formatErrorMessage("@%s methods cannot be private"));
   }
 
   @Test public void providesMethodReturnVoid() {
     assertThatModuleMethod("@Provides void voidMethod() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+        .hasError(formatErrorMessage("@%s methods must return a value (not void)"));
   }
 
   @Test
   public void providesMethodReturnsProvider() {
     assertThatModuleMethod("@Provides Provider<String> provideProvider() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void providesMethodReturnsLazy() {
     assertThatModuleMethod("@Provides Lazy<String> provideLazy() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void providesMethodReturnsMembersInjector() {
     assertThatModuleMethod("@Provides MembersInjector<String> provideMembersInjector() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void providesMethodReturnsProducer() {
     assertThatModuleMethod("@Provides Producer<String> provideProducer() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void providesMethodReturnsProduced() {
     assertThatModuleMethod("@Provides Produced<String> provideProduced() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test public void providesMethodWithTypeParameter() {
     assertThatModuleMethod("@Provides <T> String typeParameter() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+        .hasError(formatErrorMessage("@%s methods may not have type parameters"));
   }
 
   @Test public void providesMethodSetValuesWildcard() {
     assertThatModuleMethod("@Provides @ElementsIntoSet Set<?> provideWildcard() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_RETURN_TYPE));
+        .hasError(
+            formatErrorMessage(
+                "@%s methods must return a primitive, an array, a type variable, "
+                    + "or a declared type"));
   }
 
   @Test public void providesMethodSetValuesRawSet() {
     assertThatModuleMethod("@Provides @ElementsIntoSet Set provideSomething() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+        .hasError(
+            formatErrorMessage(
+                "@%s methods annotated with @ElementsIntoSet cannot return a raw Set"));
   }
 
   @Test public void providesMethodSetValuesNotASet() {
     assertThatModuleMethod(
             "@Provides @ElementsIntoSet List<String> provideStrings() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RETURN_SET));
+        .hasError(
+            formatErrorMessage("@%s methods annotated with @ElementsIntoSet must return a Set"));
   }
 
   @Test public void modulesWithTypeParamsMustBeAbstract() {
@@ -151,7 +141,7 @@ public void providesMethodReturnsProduced() {
     Compilation compilation = daggerCompiler().compile(moduleFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT)
+        .hadErrorContaining("Modules with type parameters must be abstract")
         .inFile(moduleFile)
         .onLine(6);
   }
@@ -172,9 +162,8 @@ public void providesMethodReturnsProduced() {
         .withAdditionalSources(parent)
         .hasError(
             String.format(
-                ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD,
-                "Provides",
-                "@Provides String test.Parent.foo()"));
+                "@%s methods may not be overridden in modules. Overrides: %s",
+                "Provides", "@Provides String test.Parent.foo()"));
   }
 
   @Test public void provideOverriddenByProvide() {
@@ -193,9 +182,8 @@ public void providesMethodReturnsProduced() {
         .withAdditionalSources(parent)
         .hasError(
             String.format(
-                ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
-                "Provides",
-                "@Provides String test.Parent.foo()"));
+                "@%s methods may not override another method. Overrides: %s",
+                "Provides", "@Provides String test.Parent.foo()"));
   }
 
   @Test public void providesOverridesNonProvides() {
@@ -213,9 +201,8 @@ public void providesMethodReturnsProduced() {
         .withAdditionalSources(parent)
         .hasError(
             String.format(
-                ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
-                "Provides",
-                "String test.Parent.foo()"));
+                "@%s methods may not override another method. Overrides: %s",
+                "Provides", "String test.Parent.foo()"));
   }
 
   @Test public void validatesIncludedModules() {
@@ -231,7 +218,8 @@ public void providesMethodReturnsProduced() {
     assertThat(compilation)
         .hadErrorContaining(
             String.format(
-                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED, "java.lang.Void", "@Module"));
+                "%s is listed as a module, but is not annotated with %s",
+                "java.lang.Void", "@Module"));
   }
 
   @Test public void singleProvidesMethodNoArgs() {
@@ -277,7 +265,8 @@ public void providesMethodReturnsProduced() {
             "  }",
             "",
             "  public static String proxyProvideString(TestModule instance) {",
-            "    return Preconditions.checkNotNull(instance.provideString(), " + NPE_LITERAL + ");",
+            "    return Preconditions.checkNotNull(",
+            "        instance.provideString(), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     assertAbout(javaSource()).that(moduleFile)
@@ -495,7 +484,7 @@ public void providesMethodReturnsProduced() {
             "  public static List<Object> proxyProvideObjects(",
             "      TestModule instance, Object a, Object b, MembersInjector<X> xInjector) {",
             "    return Preconditions.checkNotNull(",
-            "        instance.provideObjects(a, b, xInjector), " + NPE_LITERAL + ");",
+            "        instance.provideObjects(a, b, xInjector), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     assertAbout(javaSources()).that(
@@ -550,7 +539,9 @@ public void providesMethodReturnsProduced() {
             "  }",
             "",
             "  public static String proxyProvideString(TestModule instance) {",
-            "    return Preconditions.checkNotNull(instance.provideString(), " + NPE_LITERAL + ");",
+            "    return Preconditions.checkNotNull(instance.provideString(), "
+                + NPE_FROM_PROVIDES_METHOD
+                + ");",
             "  }",
             "}");
     assertAbout(javaSource()).that(moduleFile)
@@ -609,7 +600,7 @@ public void providesMethodReturnsProduced() {
             "",
             "  public static List<List<?>> proxyProvideWildcardList(TestModule instance) {",
             "    return Preconditions.checkNotNull(",
-            "        instance.provideWildcardList(), " + NPE_LITERAL + ");",
+            "        instance.provideWildcardList(), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     assertAbout(javaSource()).that(moduleFile)
@@ -665,7 +656,7 @@ public void providesMethodReturnsProduced() {
             "",
             "  public static Set<String> proxyProvideStrings(TestModule instance) {",
             "    return Preconditions.checkNotNull(",
-            "        instance.provideStrings(), " + NPE_LITERAL + ");",
+            "        instance.provideStrings(), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     assertAbout(javaSource()).that(moduleFile)
@@ -694,11 +685,15 @@ public void providesMethodReturnsProduced() {
     Compilation compilation = daggerCompiler().compile(moduleFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME))
+        .hadErrorContaining(
+            formatErrorMessage(
+                "Cannot have more than one @%s method with the same name in a single module"))
         .inFile(moduleFile)
         .onLine(8);
     assertThat(compilation)
-        .hadErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME))
+        .hadErrorContaining(
+            formatErrorMessage(
+                "Cannot have more than one @%s method with the same name in a single module"))
         .inFile(moduleFile)
         .onLine(12);
   }
@@ -726,11 +721,11 @@ public void providesMethodThrowsChecked() {
     Compilation compilation = daggerCompiler().compile(moduleFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))
+        .hadErrorContaining(formatErrorMessage("@%s methods may only throw unchecked exceptions"))
         .inFile(moduleFile)
         .onLine(8);
     assertThat(compilation)
-        .hadErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))
+        .hadErrorContaining(formatErrorMessage("@%s methods may only throw unchecked exceptions"))
         .inFile(moduleFile)
         .onLine(12);
   }
@@ -789,7 +784,7 @@ public void privateModule() {
     Compilation compilation = daggerCompiler().compile(moduleFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("Modules cannot be private.")
+        .hadErrorContaining("Modules cannot be private")
         .inFile(moduleFile)
         .onLine(6);
   }
@@ -810,7 +805,7 @@ public void enclosedInPrivateModule() {
     Compilation compilation = daggerCompiler().compile(moduleFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("Modules cannot be enclosed in private types.")
+        .hadErrorContaining("Modules cannot be enclosed in private types")
         .inFile(moduleFile)
         .onLine(7);
   }
@@ -974,7 +969,8 @@ public void genericSubclassedModule() {
             "",
             "  public static <A extends CharSequence, B, C extends Number & Comparable<C>> List<B>",
             "      proxyProvideListB(ParentModule<A, B, C> instance, B b) {",
-            "    return Preconditions.checkNotNull(instance.provideListB(b), " + NPE_LITERAL + ");",
+            "    return Preconditions.checkNotNull(",
+            "        instance.provideListB(b), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     JavaFileObject bElementFactory =
@@ -1019,7 +1015,7 @@ public void genericSubclassedModule() {
             "      B proxyProvideBElement(",
             "          ParentModule<A, B, C> instance, B b) {",
             "    return Preconditions.checkNotNull(",
-            "        instance.provideBElement(b), " + NPE_LITERAL + ");",
+            "        instance.provideBElement(b), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     JavaFileObject bEntryFactory =
@@ -1064,7 +1060,7 @@ public void genericSubclassedModule() {
             "      B proxyProvideBEntry(",
             "          ParentModule<A, B, C> instance, B b) {",
             "    return Preconditions.checkNotNull(",
-            "        instance.provideBEntry(b), " + NPE_LITERAL + ");",
+            "        instance.provideBEntry(b), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     JavaFileObject numberFactory =
@@ -1100,7 +1096,8 @@ public void genericSubclassedModule() {
             "  }",
             "",
             "  public static Number proxyProvideNumber(ChildNumberModule instance) {",
-            "    return Preconditions.checkNotNull(instance.provideNumber(), " + NPE_LITERAL + ");",
+            "    return Preconditions.checkNotNull(",
+            "        instance.provideNumber(), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     JavaFileObject integerFactory =
@@ -1137,7 +1134,7 @@ public void genericSubclassedModule() {
             "",
             "  public static Integer proxyProvideInteger(ChildIntegerModule instance) {",
             "    return Preconditions.checkNotNull(",
-            "        instance.provideInteger(), " + NPE_LITERAL + ");",
+            "        instance.provideInteger(), " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
     assertAbout(javaSources())
@@ -1211,7 +1208,7 @@ public void genericSubclassedModule() {
             "",
             "  public static Map<String, Number> proxyProvideMapStringNumber() {",
             "    return Preconditions.checkNotNull(ParameterizedModule.provideMapStringNumber(),",
-            "        " + NPE_LITERAL + ");",
+            "        " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
 
@@ -1245,7 +1242,7 @@ public void genericSubclassedModule() {
             "",
             "  public static Object proxyProvideNonGenericType() {",
             "    return Preconditions.checkNotNull(ParameterizedModule.provideNonGenericType(),",
-            "        " + NPE_LITERAL + ");",
+            "        " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
 
@@ -1286,7 +1283,7 @@ public void genericSubclassedModule() {
             "  public static String proxyProvideNonGenericTypeWithDeps(Object o) {",
             "    return Preconditions.checkNotNull(",
             "        ParameterizedModule.provideNonGenericTypeWithDeps(o),",
-            "        " + NPE_LITERAL + ");",
+            "        " + NPE_FROM_PROVIDES_METHOD + ");",
             "  }",
             "}");
 
@@ -1318,7 +1315,7 @@ public void genericSubclassedModule() {
         "}");
     Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(BINDING_METHOD_MULTIPLE_QUALIFIERS);
+    assertThat(compilation).hadErrorContaining("Cannot use more than one @Qualifier");
   }
 
   @Test public void providerDependsOnProduced() {
diff --git a/javatests/dagger/internal/codegen/MultibindingTest.java b/javatests/dagger/internal/codegen/MultibindingTest.java
index a2d38b928..23ce61438 100644
--- a/javatests/dagger/internal/codegen/MultibindingTest.java
+++ b/javatests/dagger/internal/codegen/MultibindingTest.java
@@ -51,8 +51,7 @@ public void providesWithTwoMultibindingAnnotations_failsToCompile() {
     Compilation compilation = daggerCompiler().compile(module);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(
-            "Multiple multibinding annotations cannot be placed on the same Provides method")
+        .hadErrorContaining("@Provides methods cannot have more than one multibinding annotation")
         .inFile(module)
         .onLine(10);
   }
diff --git a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
index 136e45063..4da7f6b5e 100644
--- a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
@@ -24,7 +24,6 @@
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -45,9 +44,6 @@ public OptionalBindingRequestFulfillmentTest(CompilerMode compilerMode) {
     this.compilerMode = compilerMode;
   }
 
-  public static final CodeBlock NPE_FROM_PROVIDES =
-      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-
   @Test
   public void inlinedOptionalBindings() {
     JavaFileObject module =
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 2242560ed..eec32f72d 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -23,25 +23,14 @@
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
 import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatProductionModuleMethod;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SCOPE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import java.lang.annotation.Retention;
 import javax.inject.Qualifier;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -61,88 +50,95 @@ private String formatModuleErrorMessage(String msg) {
 
   @Test public void producesMethodNotInModule() {
     assertThatMethodInUnannotatedClass("@Produces String produceString() { return null; }")
-        .hasError(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
+        .hasError(formatModuleErrorMessage("@%s methods can only be present within a @%s"));
   }
 
   @Test public void producesMethodAbstract() {
     assertThatProductionModuleMethod("@Produces abstract String produceString();")
-        .hasError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+        .hasError(formatErrorMessage("@%s methods cannot be abstract"));
   }
 
   @Test public void producesMethodPrivate() {
     assertThatProductionModuleMethod("@Produces private String produceString() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_PRIVATE));
+        .hasError(formatErrorMessage("@%s methods cannot be private"));
   }
 
   @Test public void producesMethodReturnVoid() {
     assertThatProductionModuleMethod("@Produces void produceNothing() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+        .hasError(formatErrorMessage("@%s methods must return a value (not void)"));
   }
 
   @Test
   public void producesProvider() {
     assertThatProductionModuleMethod("@Produces Provider<String> produceProvider() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void producesLazy() {
     assertThatProductionModuleMethod("@Produces Lazy<String> produceLazy() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void producesMembersInjector() {
     assertThatProductionModuleMethod(
             "@Produces MembersInjector<String> produceMembersInjector() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void producesProducer() {
     assertThatProductionModuleMethod("@Produces Producer<String> produceProducer() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test
   public void producesProduced() {
     assertThatProductionModuleMethod("@Produces Produced<String> produceProduced() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+        .hasError(formatErrorMessage("@%s methods must not return framework types"));
   }
 
   @Test public void producesMethodReturnRawFuture() {
     assertThatProductionModuleMethod("@Produces ListenableFuture produceRaw() {}")
         .importing(ListenableFuture.class)
-        .hasError(PRODUCES_METHOD_RAW_FUTURE);
+        .hasError("@Produces methods cannot return a raw ListenableFuture");
   }
 
   @Test public void producesMethodReturnWildcardFuture() {
     assertThatProductionModuleMethod("@Produces ListenableFuture<?> produceRaw() {}")
         .importing(ListenableFuture.class)
-        .hasError(PRODUCES_METHOD_RETURN_TYPE);
+        .hasError(
+            "@Produces methods can return only a primitive, an array, a type variable, "
+                + "a declared type, or a ListenableFuture of one of those types");
   }
 
   @Test public void producesMethodWithTypeParameter() {
     assertThatProductionModuleMethod("@Produces <T> String produceString() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+        .hasError(formatErrorMessage("@%s methods may not have type parameters"));
   }
 
   @Test public void producesMethodSetValuesWildcard() {
     assertThatProductionModuleMethod(
             "@Produces @ElementsIntoSet Set<?> produceWildcard() { return null; }")
-        .hasError(PRODUCES_METHOD_RETURN_TYPE);
+        .hasError(
+            "@Produces methods can return only a primitive, an array, a type variable, "
+                + "a declared type, or a ListenableFuture of one of those types");
   }
 
   @Test public void producesMethodSetValuesRawSet() {
     assertThatProductionModuleMethod(
             "@Produces @ElementsIntoSet Set produceSomething() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+        .hasError(
+            formatErrorMessage(
+                "@%s methods annotated with @ElementsIntoSet cannot return a raw Set"));
   }
 
   @Test public void producesMethodSetValuesNotASet() {
     assertThatProductionModuleMethod(
             "@Produces @ElementsIntoSet List<String> produceStrings() { return null; }")
-        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+        .hasError(
+            "@Produces methods of type set values must return a Set or ListenableFuture of Set");
   }
 
   @Test public void producesMethodSetValuesWildcardInFuture() {
@@ -150,14 +146,18 @@ public void producesProduced() {
             "@Produces @ElementsIntoSet "
                 + "ListenableFuture<Set<?>> produceWildcard() { return null; }")
         .importing(ListenableFuture.class)
-        .hasError(PRODUCES_METHOD_RETURN_TYPE);
+        .hasError(
+            "@Produces methods can return only a primitive, an array, a type variable, "
+                + "a declared type, or a ListenableFuture of one of those types");
   }
 
   @Test public void producesMethodSetValuesFutureRawSet() {
     assertThatProductionModuleMethod(
             "@Produces @ElementsIntoSet ListenableFuture<Set> produceSomething() { return null; }")
         .importing(ListenableFuture.class)
-        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+        .hasError(
+            formatErrorMessage(
+                "@%s methods annotated with @ElementsIntoSet cannot return a raw Set"));
   }
 
   @Test public void producesMethodSetValuesFutureNotASet() {
@@ -165,7 +165,8 @@ public void producesProduced() {
             "@Produces @ElementsIntoSet "
                 + "ListenableFuture<List<String>> produceStrings() { return null; }")
         .importing(ListenableFuture.class)
-        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+        .hasError(
+            "@Produces methods of type set values must return a Set or ListenableFuture of Set");
   }
 
   @Test public void multipleProducesMethodsWithSameName() {
@@ -185,7 +186,8 @@ public void producesProduced() {
         "    return \"\";",
         "  }",
         "}");
-    String errorMessage = String.format(BINDING_METHOD_WITH_SAME_NAME, "Produces");
+    String errorMessage =
+        "Cannot have more than one @Produces method with the same name in a single module";
     Compilation compilation = daggerCompiler().compile(moduleFile);
     assertThat(compilation).failed();
     assertThat(compilation).hadErrorContaining(errorMessage).inFile(moduleFile).onLine(8);
@@ -202,7 +204,7 @@ public void producesMethodThrowsThrowable() {
 
   @Test public void producesMethodWithScope() {
     assertThatProductionModuleMethod("@Produces @Singleton String str() { return \"\"; }")
-        .hasError(PRODUCES_METHOD_SCOPE);
+        .hasError("@Produces methods may not have scope annotations");
   }
 
   @Test
@@ -219,7 +221,7 @@ public void privateModule() {
     Compilation compilation = daggerCompiler().compile(moduleFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("Modules cannot be private.")
+        .hadErrorContaining("Modules cannot be private")
         .inFile(moduleFile)
         .onLine(6);
   }
@@ -240,7 +242,7 @@ public void enclosedInPrivateModule() {
     Compilation compilation = daggerCompiler().compile(moduleFile);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("Modules cannot be enclosed in private types.")
+        .hadErrorContaining("Modules cannot be enclosed in private types")
         .inFile(moduleFile)
         .onLine(7);
   }
@@ -263,10 +265,7 @@ public void includesNonModule() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            String.format(
-                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
-                "X",
-                "one of @Module, @ProducerModule"));
+            "X is listed as a module, but is not annotated with one of @Module, @ProducerModule");
   }
 
   @Test
@@ -503,12 +502,14 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
     assertThatProductionModuleMethod(
             "@Produces @QualifierA @QualifierB abstract String produceString() { return null; }")
         .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
-        .hasError(BINDING_METHOD_MULTIPLE_QUALIFIERS);
+        .hasError("Cannot use more than one @Qualifier");
   }
-  
+
   @Qualifier
+  @Retention(RUNTIME)
   public @interface QualifierA {}
 
   @Qualifier
+  @Retention(RUNTIME)
   public @interface QualifierB {}
 }
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
index 0a5de8dd6..046061689 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
@@ -25,7 +25,6 @@
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -46,9 +45,6 @@ public SetBindingRequestFulfillmentTest(CompilerMode compilerMode) {
     this.compilerMode = compilerMode;
   }
 
-  public static final CodeBlock NPE_FROM_PROVIDES =
-      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-
   @Test
   public void setBindings() {
     JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index 32ddf8d52..0274d96d2 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -23,7 +23,6 @@
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
 import java.util.Collection;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -44,9 +43,6 @@ public SetBindingRequestFulfillmentWithGuavaTest(CompilerMode compilerMode) {
     this.compilerMode = compilerMode;
   }
 
-  public static final CodeBlock NPE_FROM_PROVIDES =
-      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-
   @Test
   public void setBindings() {
     JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
