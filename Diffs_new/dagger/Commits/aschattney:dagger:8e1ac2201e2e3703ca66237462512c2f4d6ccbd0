diff --git a/compiler/src/main/java/dagger/internal/codegen/AppConfigProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/AppConfigProcessingStep.java
index 4d4b19c27..2ec191061 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AppConfigProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AppConfigProcessingStep.java
@@ -15,7 +15,7 @@
 /**
  * Created by Andy on 26.05.2017.
  */
-public class AppConfigProcessingStep implements BasicAnnotationProcessor.ProcessingStep{
+public class AppConfigProcessingStep implements BasicProcessor.ProcessingStep {
 
     private final Messager messager;
     private final Elements elements;
@@ -35,7 +35,7 @@ public AppConfigProcessingStep(Messager messager, Elements elements, Types types
     }
 
     @Override
-    public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> set) {
+    public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> set, boolean anyElementsRejected) {
         final Set<Element> elements = set.get(Config.class);
         validator.validate(elements).printMessagesTo(messager);
         return ImmutableSet.of();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BasicProcessor.java b/compiler/src/main/java/dagger/internal/codegen/BasicProcessor.java
new file mode 100644
index 000000000..c33ac127f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BasicProcessor.java
@@ -0,0 +1,516 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.SuperficialValidation.validateElement;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.transform;
+import static com.google.common.collect.Multimaps.filterKeys;
+import static javax.lang.model.element.ElementKind.PACKAGE;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.common.base.Ascii;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.SetMultimap;
+import com.google.common.collect.Sets;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ErrorType;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleElementVisitor6;
+
+/**
+ * An abstract {@link Processor} implementation that defers processing of {@link Element}s to later
+ * rounds if they cannot be processed.
+ *
+ * <p>Subclasses put their processing logic in {@link ProcessingStep} implementations. The
+ * steps are passed to the processor by returning them in the {@link #initSteps()} method, and can
+ * access the {@link ProcessingEnvironment} using {@link #processingEnv}.
+ *
+ * Any logic that needs to happen once per round can be specified by overriding
+ * {@link #postRound(RoundEnvironment, boolean)}.
+ *
+ * <h3>Ill-formed elements are deferred</h3>
+ * Any annotated element whose nearest enclosing type is not well-formed is deferred, and not passed
+ * to any {@code ProcessingStep}. This helps processors to avoid many common pitfalls, such as
+ * {@link ErrorType} instances, {@link ClassCastException}s and badly coerced types.
+ *
+ * <p>A non-package element is considered well-formed if its type, type parameters, parameters,
+ * default values, supertypes, annotations, and enclosed elements are. Package elements are treated
+ * similarly, except that their enclosed elements are not validated. See
+ * {@link SuperficialValidation#validateElement(Element)} for details.
+ *
+ * <p>The primary disadvantage to this validation is that any element that forms a circular
+ * dependency with a type generated by another {@code BasicAnnotationProcessor} will never compile
+ * because the element will never be fully complete. All such compilations will fail with an error
+ * message on the offending type that describes the issue.
+ *
+ * <h3>Each {@code ProcessingStep} can defer elements</h3>
+ *
+ * <p>Each {@code ProcessingStep} can defer elements by including them in the set returned by
+ * {@link ProcessingStep#process(SetMultimap)}; elements deferred by a step will be passed back to
+ * that step in a later round of processing.
+ *
+ * <p>This feature is useful when one processor may depend on code generated by another,
+ * independent processor, in a way that isn't caught by the well-formedness check described above.
+ * For example, if an element {@code A} cannot be processed because processing it depends on the
+ * existence of some class {@code B}, then {@code A} should be deferred until a later round of
+ * processing, when {@code B} will have been generated by another processor.
+ *
+ * <p>If {@code A} directly references {@code B}, then the well-formedness check will correctly
+ * defer processing of {@code A} until {@code B} has been generated.
+ *
+ * <p>However, if {@code A} references {@code B} only indirectly (for example, from within a method
+ * body), then the well-formedness check will not defer processing {@code A}, but a processing step
+ * can reject {@code A}.
+ */
+public abstract class BasicProcessor extends AbstractProcessor {
+
+    private final Set<ElementName> deferredElementNames = new LinkedHashSet<>();
+    private final SetMultimap<ProcessingStep, ElementName> elementsDeferredBySteps =
+            LinkedHashMultimap.create();
+    private final String processorName = getClass().getCanonicalName();
+
+    private Elements elements;
+    private Messager messager;
+    private ImmutableList<? extends ProcessingStep> steps;
+
+    @Override
+    public final synchronized void init(ProcessingEnvironment processingEnv) {
+        super.init(processingEnv);
+        this.elements = processingEnv.getElementUtils();
+        this.messager = processingEnv.getMessager();
+        this.steps = ImmutableList.copyOf(initSteps());
+    }
+
+    /**
+     * Creates {@linkplain BasicAnnotationProcessor#ProcessingStep processing steps} for this processor.
+     * {@link #processingEnv} is guaranteed to be set when this method is invoked.
+     */
+    protected abstract Iterable<? extends ProcessingStep> initSteps();
+
+    /**
+     * An optional hook for logic to be executed at the end of each round.
+     *
+     * @deprecated use {@link #postRound(RoundEnvironment, boolean)} instead
+     */
+    @Deprecated
+    protected void postProcess() {}
+
+    /** An optional hook for logic to be executed at the end of each round. */
+    protected void postRound(RoundEnvironment roundEnv) {
+        if (!roundEnv.processingOver()) {
+            postProcess();
+        }
+    }
+
+    private ImmutableSet<? extends Class<? extends Annotation>> getSupportedAnnotationClasses() {
+        checkState(steps != null);
+        ImmutableSet.Builder<Class<? extends Annotation>> builder = ImmutableSet.builder();
+        for (ProcessingStep step : steps) {
+            builder.addAll(step.annotations());
+        }
+        return builder.build();
+    }
+
+    /**
+     * Returns the set of supported annotation types as a  collected from registered
+     * {@linkplain BasicAnnotationProcessor#ProcessingStep processing steps}.
+     */
+    @Override
+    public final ImmutableSet<String> getSupportedAnnotationTypes() {
+        ImmutableSet.Builder<String> builder = ImmutableSet.builder();
+        for (Class<? extends Annotation> annotationClass : getSupportedAnnotationClasses()) {
+            builder.add(annotationClass.getCanonicalName());
+        }
+        return builder.build();
+    }
+
+    @Override
+    public final boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+        checkState(elements != null);
+        checkState(messager != null);
+        checkState(steps != null);
+
+        ImmutableMap<String, Optional<? extends Element>> deferredElements = deferredElements();
+
+        deferredElementNames.clear();
+
+        // If this is the last round, report all of the missing elements
+        if (roundEnv.processingOver()) {
+            postRound(roundEnv);
+            reportMissingElements(deferredElements, elementsDeferredBySteps.values());
+            return false;
+        }
+
+        process(validElements(deferredElements, roundEnv));
+
+        postRound(roundEnv);
+
+        return false;
+    }
+
+    /**
+     * Returns the previously deferred elements.
+     */
+    private ImmutableMap<String, Optional<? extends Element>> deferredElements() {
+        ImmutableMap.Builder<String, Optional<? extends Element>> deferredElements =
+                ImmutableMap.builder();
+        for (ElementName elementName : deferredElementNames) {
+            deferredElements.put(elementName.name(), elementName.getElement(elements));
+        }
+        return deferredElements.build();
+    }
+
+    private void reportMissingElements(
+            Map<String, ? extends Optional<? extends Element>> missingElements,
+            Collection<ElementName> missingElementNames) {
+        if (!missingElementNames.isEmpty()) {
+            ImmutableMap.Builder<String, Optional<? extends Element>> allMissingElements =
+                    ImmutableMap.builder();
+            allMissingElements.putAll(missingElements);
+            for (ElementName missingElement : missingElementNames) {
+                if (!missingElements.containsKey(missingElement.name())) {
+                    allMissingElements.put(missingElement.name(), missingElement.getElement(elements));
+                }
+            }
+            missingElements = allMissingElements.build();
+        }
+        for (Entry<String, ? extends Optional<? extends Element>> missingElementEntry :
+                missingElements.entrySet()) {
+            Optional<? extends Element> missingElement = missingElementEntry.getValue();
+            if (missingElement.isPresent()) {
+                processingEnv
+                        .getMessager()
+                        .printMessage(
+                                ERROR,
+                                processingErrorMessage(
+                                        "this " + Ascii.toLowerCase(missingElement.get().getKind().name())),
+                                missingElement.get());
+            } else {
+                processingEnv
+                        .getMessager()
+                        .printMessage(ERROR, processingErrorMessage(missingElementEntry.getKey()));
+            }
+        }
+    }
+
+    private String processingErrorMessage(String target) {
+        return String.format(
+                "%s was unable to process %s because not all of its dependencies could be resolved. Check "
+                        + "for compilation errors or a circular dependency with generated code.",
+                processorName,
+                target);
+    }
+
+    /**
+     * Returns the valid annotated elements contained in all of the deferred elements. If none are
+     * found for a deferred element, defers it again.
+     */
+    private ImmutableSetMultimap<Class<? extends Annotation>, Element> validElements(
+            ImmutableMap<String, Optional<? extends Element>> deferredElements,
+            RoundEnvironment roundEnv) {
+        ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element>
+                deferredElementsByAnnotationBuilder = ImmutableSetMultimap.builder();
+        for (Entry<String, Optional<? extends Element>> deferredTypeElementEntry :
+                deferredElements.entrySet()) {
+            Optional<? extends Element> deferredElement = deferredTypeElementEntry.getValue();
+            if (deferredElement.isPresent()) {
+                findAnnotatedElements(
+                        deferredElement.get(),
+                        getSupportedAnnotationClasses(),
+                        deferredElementsByAnnotationBuilder);
+            } else {
+                deferredElementNames.add(ElementName.forTypeName(deferredTypeElementEntry.getKey()));
+            }
+        }
+
+        ImmutableSetMultimap<Class<? extends Annotation>, Element> deferredElementsByAnnotation =
+                deferredElementsByAnnotationBuilder.build();
+
+        ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element> validElements =
+                ImmutableSetMultimap.builder();
+
+        Set<ElementName> validElementNames = new LinkedHashSet<ElementName>();
+
+        // Look at the elements we've found and the new elements from this round and validate them.
+        for (Class<? extends Annotation> annotationClass : getSupportedAnnotationClasses()) {
+            // This should just call roundEnv.getElementsAnnotatedWith(Class) directly, but there is a bug
+            // in some versions of eclipse that cause that method to crash.
+            TypeElement annotationType = elements.getTypeElement(annotationClass.getCanonicalName());
+            Set<? extends Element> elementsAnnotatedWith =
+                    (annotationType == null)
+                            ? ImmutableSet.<Element>of()
+                            : roundEnv.getElementsAnnotatedWith(annotationType);
+            for (Element annotatedElement :
+                    Sets.union(elementsAnnotatedWith, deferredElementsByAnnotation.get(annotationClass))) {
+                if (annotatedElement.getKind().equals(PACKAGE)) {
+                    PackageElement annotatedPackageElement = (PackageElement) annotatedElement;
+                    ElementName annotatedPackageName =
+                            ElementName.forPackageName(annotatedPackageElement.getQualifiedName().toString());
+                    boolean validPackage =
+                            validElementNames.contains(annotatedPackageName)
+                                    || (!deferredElementNames.contains(annotatedPackageName)
+                                    && validateElement(annotatedPackageElement));
+                    if (validPackage) {
+                        validElements.put(annotationClass, annotatedPackageElement);
+                        validElementNames.add(annotatedPackageName);
+                    } else {
+                        deferredElementNames.add(annotatedPackageName);
+                    }
+                } else {
+                    TypeElement enclosingType = getEnclosingType(annotatedElement);
+                    ElementName enclosingTypeName =
+                            ElementName.forTypeName(enclosingType.getQualifiedName().toString());
+                    boolean validEnclosingType =
+                            validElementNames.contains(enclosingTypeName)
+                                    || (!deferredElementNames.contains(enclosingTypeName)
+                                    && validateElement(enclosingType));
+                    if (validEnclosingType) {
+                        validElements.put(annotationClass, annotatedElement);
+                        validElementNames.add(enclosingTypeName);
+                    } else {
+                        deferredElementNames.add(enclosingTypeName);
+                    }
+                }
+            }
+        }
+
+        return validElements.build();
+    }
+
+    /** Processes the valid elements, including those previously deferred by each step. */
+    private void process(ImmutableSetMultimap<Class<? extends Annotation>, Element> validElements) {
+        boolean rejectedAnyElements = false;
+        for (ProcessingStep step : steps) {
+            ImmutableSetMultimap<Class<? extends Annotation>, Element> stepElements =
+                    new ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element>()
+                            .putAll(indexByAnnotation(elementsDeferredBySteps.get(step)))
+                            .putAll(filterKeys(validElements, Predicates.<Object>in(step.annotations())))
+                            .build();
+            if (stepElements.isEmpty()) {
+                elementsDeferredBySteps.removeAll(step);
+            } else {
+                Set<? extends Element> rejectedElements = step.process(stepElements, rejectedAnyElements);
+                if (rejectedElements.isEmpty() && !rejectedAnyElements) {
+                    rejectedAnyElements = true;
+                }
+                elementsDeferredBySteps.replaceValues(
+                        step,
+                        transform(
+                                rejectedElements,
+                                new Function<Element, ElementName>() {
+                                    @Override
+                                    public ElementName apply(Element element) {
+                                        return ElementName.forAnnotatedElement(element);
+                                    }
+                                }));
+            }
+        }
+    }
+
+    private ImmutableSetMultimap<Class<? extends Annotation>, Element> indexByAnnotation(
+            Set<ElementName> annotatedElements) {
+        ImmutableSet<? extends Class<? extends Annotation>> supportedAnnotationClasses =
+                getSupportedAnnotationClasses();
+        ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element> deferredElements =
+                ImmutableSetMultimap.builder();
+        for (ElementName elementName : annotatedElements) {
+            Optional<? extends Element> element = elementName.getElement(elements);
+            if (element.isPresent()) {
+                findAnnotatedElements(element.get(), supportedAnnotationClasses, deferredElements);
+            }
+        }
+        return deferredElements.build();
+    }
+
+    /**
+     * Adds {@code element} and its enclosed elements to {@code annotatedElements} if they are
+     * annotated with any annotations in {@code annotationClasses}. Does not traverse to member types
+     * of {@code element}, so that if {@code Outer} is passed in the example below, looking for
+     * {@code @X}, then {@code Outer}, {@code Outer.foo}, and {@code Outer.foo()} will be added to the
+     * multimap, but neither {@code Inner} nor its members will.
+     *
+     * <pre><code>
+     *   {@literal @}X class Outer {
+     *     {@literal @}X Object foo;
+     *     {@literal @}X void foo() {}
+     *     {@literal @}X static class Inner {
+     *       {@literal @}X Object bar;
+     *       {@literal @}X void bar() {}
+     *     }
+     *   }
+     * </code></pre>
+     */
+    private static void findAnnotatedElements(
+            Element element,
+            ImmutableSet<? extends Class<? extends Annotation>> annotationClasses,
+            ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element> annotatedElements) {
+        for (Element enclosedElement : element.getEnclosedElements()) {
+            if (!enclosedElement.getKind().isClass() && !enclosedElement.getKind().isInterface()) {
+                findAnnotatedElements(enclosedElement, annotationClasses, annotatedElements);
+            }
+        }
+
+        // element.getEnclosedElements() does NOT return parameter elements
+        if (element instanceof ExecutableElement) {
+            for (Element parameterElement : ((ExecutableElement) element).getParameters()) {
+                findAnnotatedElements(parameterElement, annotationClasses, annotatedElements);
+            }
+        }
+        for (Class<? extends Annotation> annotationClass : annotationClasses) {
+            if (isAnnotationPresent(element, annotationClass)) {
+                annotatedElements.put(annotationClass, element);
+            }
+        }
+    }
+
+    /**
+     * Returns the nearest enclosing {@link TypeElement} to the current element, throwing
+     * an {@link IllegalArgumentException} if the provided {@link Element} is a
+     * {@link PackageElement} or is otherwise not enclosed by a type.
+     */
+    // TODO(cgruber) move to MoreElements and make public.
+    private static TypeElement getEnclosingType(Element element) {
+        return element.accept(new SimpleElementVisitor6<TypeElement, Void>() {
+            @Override protected TypeElement defaultAction(Element e, Void p) {
+                return e.getEnclosingElement().accept(this, p);
+            }
+
+            @Override public TypeElement visitType(TypeElement e, Void p) {
+                return e;
+            }
+
+            @Override public TypeElement visitPackage(PackageElement e, Void p) {
+                throw new IllegalArgumentException();
+            }
+        }, null);
+    }
+
+    /**
+     * A package or type name.
+     *
+     * <p>It's unfortunate that we have to track types and packages separately, but since there are
+     * two different methods to look them up in {@link Elements}, we end up with a lot of parallel
+     * logic. :(
+     *
+     * <p>Packages declared (and annotated) in {@code package-info.java} are tracked as deferred
+     * packages, type elements are tracked directly, and all other elements are tracked via their
+     * nearest enclosing type.
+     */
+    private static final class ElementName {
+        private enum Kind {
+            PACKAGE_NAME,
+            TYPE_NAME,
+        }
+
+        private final Kind kind;
+        private final String name;
+
+        private ElementName(Kind kind, String name) {
+            this.kind = checkNotNull(kind);
+            this.name = checkNotNull(name);
+        }
+
+        /**
+         * An {@link ElementName} for a package.
+         */
+        static ElementName forPackageName(String packageName) {
+            return new ElementName(Kind.PACKAGE_NAME, packageName);
+        }
+
+        /**
+         * An {@link ElementName} for a type.
+         */
+        static ElementName forTypeName(String typeName) {
+            return new ElementName(Kind.TYPE_NAME, typeName);
+        }
+
+        /**
+         * An {@link ElementName} for an annotated element. If {@code element} is a package, uses the
+         * fully qualified name of the package. If it's a type, uses its fully qualified name.
+         * Otherwise, uses the fully-qualified name of the nearest enclosing type.
+         */
+        static ElementName forAnnotatedElement(Element element) {
+            return element.getKind() == PACKAGE
+                    ? ElementName.forPackageName(((PackageElement) element).getQualifiedName().toString())
+                    : ElementName.forTypeName(getEnclosingType(element).getQualifiedName().toString());
+        }
+
+        /**
+         * The fully-qualified name of the element.
+         */
+        String name() {
+            return name;
+        }
+
+        /**
+         * The {@link Element} whose fully-qualified name is {@link #name()}. Absent if the relevant
+         * method on {@link Elements} returns {@code null}.
+         */
+        Optional<? extends Element> getElement(Elements elements) {
+            return Optional.fromNullable(
+                    kind == Kind.PACKAGE_NAME
+                            ? elements.getPackageElement(name)
+                            : elements.getTypeElement(name));
+        }
+
+        @Override
+        public boolean equals(Object object) {
+            if (!(object instanceof ElementName)) {
+                return false;
+            }
+
+            ElementName that = (ElementName) object;
+            return this.kind == that.kind && this.name.equals(that.name);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(kind, name);
+        }
+    }
+
+    public interface ProcessingStep {
+        Set<? extends Class<? extends Annotation>> annotations();
+        Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> var1, boolean rejectedAnyElements);
+    }
+
+}
\ No newline at end of file
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodProcessingStep.java
index cc1e164db..210fe79f2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingMethodProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodProcessingStep.java
@@ -29,7 +29,7 @@
 import javax.lang.model.element.ExecutableElement;
 
 /** A step that validates all binding methods that were not validated while processing modules. */
-final class BindingMethodProcessingStep implements ProcessingStep {
+final class BindingMethodProcessingStep implements BasicProcessor.ProcessingStep {
 
   private final Messager messager;
   private final AnyBindingMethodValidator anyBindingMethodValidator;
@@ -47,7 +47,7 @@
 
   @Override
   public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
     for (ExecutableElement method : methodsIn(elementsByAnnotation.values())) {
       checkArgument(
           anyBindingMethodValidator.isBindingMethod(method),
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index 8165da85e..5aaf728a7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -46,7 +46,7 @@
  * Processing step that validates that the {@code BindsInstance} annotation is applied to the
  * correct elements.
  */
-final class BindsInstanceProcessingStep implements ProcessingStep {
+final class BindsInstanceProcessingStep implements BasicProcessor.ProcessingStep {
 
   private static final ImmutableSet<Class<? extends Annotation>> COMPONENT_ANNOTATIONS =
       Stream.of(ComponentDescriptor.Kind.values())
@@ -70,7 +70,7 @@
 
   @Override
   public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
     for (Element element : elementsByAnnotation.get(BindsInstance.class)) {
       ExecutableElement method = MoreElements.asExecutable(element);
       ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(method);
diff --git a/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java
index 52a31c166..4dce09afb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java
@@ -34,7 +34,7 @@
  * Processes annotations annotated with {@link CanReleaseReferences}. For each one that is not also
  * a {@link Scope}, generates a class that can create instances at runtime.
  */
-final class CanReleaseReferencesProcessingStep implements ProcessingStep {
+final class CanReleaseReferencesProcessingStep implements BasicProcessor.ProcessingStep {
 
   private final Messager messager;
   private final CanReleaseReferencesValidator canReleaseReferencesValidator;
@@ -56,7 +56,7 @@
 
   @Override
   public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
     for (TypeElement annotatedElement :
         typesIn(elementsByAnnotation.get(CanReleaseReferences.class))) {
       ValidationReport<TypeElement> report =
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 44f8b81cf..3fb51ebc6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -45,7 +45,7 @@
  *
  * @author Gregory Kick
  */
-final class ComponentProcessingStep implements ProcessingStep {
+final class ComponentProcessingStep implements BasicProcessor.ProcessingStep {
   private final ComponentDescriptor.Kind componentKind;
   private final Messager messager;
   private final ComponentValidator componentValidator;
@@ -101,7 +101,7 @@
 
   @Override
   public final ImmutableSet<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
 
     if (appClass == null) {
       final Set<Element> elements = elementsByAnnotation.get(Config.class);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 9c2189428..e3ac7b8b0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -44,7 +44,7 @@
  * @since 2.0
  */
 @AutoService(Processor.class)
-public final class ComponentProcessor extends BasicAnnotationProcessor {
+public final class ComponentProcessor extends BasicProcessor {
 
   private TestRegistry testRegistry = new TestRegistry();
 
@@ -75,64 +75,53 @@ public SourceVersion getSupportedSourceVersion() {
     KeyFormatter keyFormatter = new KeyFormatter();
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     BindingDeclarationFormatter bindingDeclarationFormatter =
-        new BindingDeclarationFormatter(methodSignatureFormatter, keyFormatter);
+            new BindingDeclarationFormatter(methodSignatureFormatter, keyFormatter);
     DependencyRequestFormatter dependencyRequestFormatter =
-        new DependencyRequestFormatter(types, elements);
+            new DependencyRequestFormatter(types, elements);
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
     InjectValidator injectValidator = new InjectValidator(types, elements, compilerOptions);
     InjectValidator injectValidatorWhenGeneratingCode = injectValidator.whenGeneratingCode();
-/*
-    ModuleValidator moduleValidator =
-        new ModuleValidator(types, elements, methodSignatureFormatter);
-    BuilderValidator builderValidator = new BuilderValidator(elements, types);
-    ComponentValidator subcomponentValidator =
-        ComponentValidator.createForSubcomponent(
-                elements, types, moduleValidator, builderValidator);
-    ComponentValidator componentValidator =
-        ComponentValidator.createForComponent(
-                elements, types, moduleValidator, subcomponentValidator, builderValidator);
-    MapKeyValidator mapKeyValidator = new MapKeyValidator();
-*/
+
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
     BindsMethodValidator bindsMethodValidator = new BindsMethodValidator(elements, types);
     MultibindsMethodValidator multibindsMethodValidator =
-        new MultibindsMethodValidator(elements, types);
+            new MultibindsMethodValidator(elements, types);
     MultibindingsMethodValidator multibindingsMethodValidator =
-        new MultibindingsMethodValidator(elements, types);
+            new MultibindingsMethodValidator(elements, types);
     BindsOptionalOfMethodValidator bindsOptionalOfMethodValidator =
-        new BindsOptionalOfMethodValidator(elements, types);
+            new BindsOptionalOfMethodValidator(elements, types);
     AnyBindingMethodValidator anyBindingMethodValidator =
-        new AnyBindingMethodValidator(
-            providesMethodValidator,
-            producesMethodValidator,
-            bindsMethodValidator,
-            multibindsMethodValidator,
-            bindsOptionalOfMethodValidator);
+            new AnyBindingMethodValidator(
+                    providesMethodValidator,
+                    producesMethodValidator,
+                    bindsMethodValidator,
+                    multibindsMethodValidator,
+                    bindsOptionalOfMethodValidator);
     MultibindingsValidator multibindingsValidator =
-        new MultibindingsValidator(
-                elements,
-                types,
-            keyFactory,
-            keyFormatter,
-            methodSignatureFormatter,
-            multibindingsMethodValidator);
+            new MultibindingsValidator(
+                    elements,
+                    types,
+                    keyFactory,
+                    keyFormatter,
+                    methodSignatureFormatter,
+                    multibindingsMethodValidator);
     ModuleValidator moduleValidator =
-        new ModuleValidator(
-            types,
-            elements,
-            anyBindingMethodValidator,
-            multibindingsValidator,
-            methodSignatureFormatter);
+            new ModuleValidator(
+                    types,
+                    elements,
+                    anyBindingMethodValidator,
+                    multibindingsValidator,
+                    methodSignatureFormatter);
     BuilderValidator builderValidator = new BuilderValidator(elements, types);
     ComponentValidator subcomponentValidator =
-        ComponentValidator.createForSubcomponent(
-            elements, types, moduleValidator, builderValidator);
+            ComponentValidator.createForSubcomponent(
+                    elements, types, moduleValidator, builderValidator);
     ComponentValidator componentValidator =
-        ComponentValidator.createForComponent(
-            elements, types, moduleValidator, subcomponentValidator, builderValidator);
+            ComponentValidator.createForComponent(
+                    elements, types, moduleValidator, subcomponentValidator, builderValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
 
     StubGenerator stubGenerator = new StubGenerator(filer, elements, types);
@@ -140,32 +129,32 @@ public SourceVersion getSupportedSourceVersion() {
     multipleGenerator = new MultipleSourceFileGenerator<>(filer, elements, Arrays.asList(stubGenerator, factoryGenerator));
     membersInjectorGenerator = new MembersInjectorGenerator(filer, elements, injectValidatorWhenGeneratingCode);
     ComponentGenerator componentGenerator =
-        new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
+            new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
     ProducerFactoryGenerator producerFactoryGenerator =
-        new ProducerFactoryGenerator(filer, elements, compilerOptions);
+            new ProducerFactoryGenerator(filer, elements, compilerOptions);
     MonitoringModuleGenerator monitoringModuleGenerator =
-        new MonitoringModuleGenerator(filer, elements);
+            new MonitoringModuleGenerator(filer, elements);
     ProductionExecutorModuleGenerator productionExecutorModuleGenerator =
-        new ProductionExecutorModuleGenerator(filer, elements);
+            new ProductionExecutorModuleGenerator(filer, elements);
 
     DependencyRequest.Factory dependencyRequestFactory =
-        new DependencyRequest.Factory(keyFactory);
+            new DependencyRequest.Factory(keyFactory);
     ProvisionBinding.Factory provisionBindingFactory =
-        new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
+            new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
     ProductionBinding.Factory productionBindingFactory =
-        new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);
+            new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);
     MultibindingDeclaration.Factory multibindingDeclarationFactory =
-        new MultibindingDeclaration.Factory(elements, types, keyFactory);
+            new MultibindingDeclaration.Factory(elements, types, keyFactory);
     SubcomponentDeclaration.Factory subcomponentDeclarationFactory =
-        new SubcomponentDeclaration.Factory(keyFactory);
+            new SubcomponentDeclaration.Factory(keyFactory);
 
     MembersInjectionBinding.Factory membersInjectionBindingFactory =
-        new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
+            new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
 
     DelegateDeclaration.Factory bindingDelegateDeclarationFactory =
-        new DelegateDeclaration.Factory(types, keyFactory, dependencyRequestFactory);
+            new DelegateDeclaration.Factory(types, keyFactory, dependencyRequestFactory);
     OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory =
-        new OptionalBindingDeclaration.Factory(keyFactory);
+            new OptionalBindingDeclaration.Factory(keyFactory);
 
     injectBindingRegistry = new InjectBindingRegistry(
             elements,
@@ -178,14 +167,14 @@ public SourceVersion getSupportedSourceVersion() {
             compilerOptions);
 
     ModuleDescriptor.Factory moduleDescriptorFactory =
-        new ModuleDescriptor.Factory(
-                elements,
-            provisionBindingFactory,
-            productionBindingFactory,
-            multibindingDeclarationFactory,
-            bindingDelegateDeclarationFactory,
-            subcomponentDeclarationFactory,
-            optionalBindingDeclarationFactory);
+            new ModuleDescriptor.Factory(
+                    elements,
+                    provisionBindingFactory,
+                    productionBindingFactory,
+                    multibindingDeclarationFactory,
+                    bindingDelegateDeclarationFactory,
+                    subcomponentDeclarationFactory,
+                    optionalBindingDeclarationFactory);
 
     ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
             elements, types, dependencyRequestFactory, moduleDescriptorFactory);
@@ -198,74 +187,74 @@ public SourceVersion getSupportedSourceVersion() {
             productionBindingFactory);
 
     AnnotationCreatorGenerator annotationCreatorGenerator =
-        new AnnotationCreatorGenerator(filer, elements);
+            new AnnotationCreatorGenerator(filer, elements);
     UnwrappedMapKeyGenerator unwrappedMapKeyGenerator =
-        new UnwrappedMapKeyGenerator(filer, elements);
+            new UnwrappedMapKeyGenerator(filer, elements);
     CanReleaseReferencesValidator canReleaseReferencesValidator =
-        new CanReleaseReferencesValidator();
+            new CanReleaseReferencesValidator();
     ComponentHierarchyValidator componentHierarchyValidator =
-        new ComponentHierarchyValidator(compilerOptions, elements);
+            new ComponentHierarchyValidator(compilerOptions, elements);
     BindingGraphValidator bindingGraphValidator =
-        new BindingGraphValidator(
-                elements,
-                types,
-            compilerOptions,
-            injectValidatorWhenGeneratingCode,
-            injectBindingRegistry,
-            bindingDeclarationFormatter,
-            methodSignatureFormatter,
-            dependencyRequestFormatter,
-            keyFormatter,
-            keyFactory);
+            new BindingGraphValidator(
+                    elements,
+                    types,
+                    compilerOptions,
+                    injectValidatorWhenGeneratingCode,
+                    injectBindingRegistry,
+                    bindingDeclarationFormatter,
+                    methodSignatureFormatter,
+                    dependencyRequestFormatter,
+                    keyFormatter,
+                    keyFactory);
 
     return ImmutableList.of(
-        new AppConfigProcessingStep(messager, elements, types, new AppConfig.Validator(elements, types)),
-        new MapKeyProcessingStep(
-                messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
-        new ForReleasableReferencesValidator(messager),
-        new CanReleaseReferencesProcessingStep(
-                messager, canReleaseReferencesValidator, annotationCreatorGenerator),
-        new InjectProcessingStep(injectBindingRegistry),
-        new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
-        new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
-        new MultibindingAnnotationsProcessingStep(messager),
-        new BindsInstanceProcessingStep(messager),
-        moduleProcessingStep(
-                messager,
-            moduleValidator,
-            provisionBindingFactory,
-            this.multipleGenerator),
-        new ComponentProcessingStep(
-            ComponentDescriptor.Kind.COMPONENT,
-                messager,
-            componentValidator,
-            subcomponentValidator,
-            builderValidator,
-            componentHierarchyValidator,
-            bindingGraphValidator,
-                componentDescriptorFactory,
-                bindingGraphFactory,
-            componentGenerator),
-        producerModuleProcessingStep(
-                messager,
-            moduleValidator,
-            provisionBindingFactory,
-            multipleGenerator,
-            productionBindingFactory,
-            producerFactoryGenerator),
-        new ComponentProcessingStep(
-            ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
-                messager,
-            componentValidator,
-            subcomponentValidator,
-            builderValidator,
-            componentHierarchyValidator,
-            bindingGraphValidator,
-            componentDescriptorFactory,
-            bindingGraphFactory,
-            componentGenerator),
-        new MultibindingsProcessingStep(messager, multibindingsValidator),
-        new BindingMethodProcessingStep(messager, anyBindingMethodValidator),
+            new AppConfigProcessingStep(messager, elements, types, new AppConfig.Validator(elements, types)),
+            new MapKeyProcessingStep(
+                    messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
+            new ForReleasableReferencesValidator(messager),
+            new CanReleaseReferencesProcessingStep(
+                    messager, canReleaseReferencesValidator, annotationCreatorGenerator),
+            new InjectProcessingStep(injectBindingRegistry),
+            new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
+            new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
+            new MultibindingAnnotationsProcessingStep(messager),
+            new BindsInstanceProcessingStep(messager),
+            moduleProcessingStep(
+                    messager,
+                    moduleValidator,
+                    provisionBindingFactory,
+                    this.multipleGenerator),
+            new ComponentProcessingStep(
+                    ComponentDescriptor.Kind.COMPONENT,
+                    messager,
+                    componentValidator,
+                    subcomponentValidator,
+                    builderValidator,
+                    componentHierarchyValidator,
+                    bindingGraphValidator,
+                    componentDescriptorFactory,
+                    bindingGraphFactory,
+                    componentGenerator),
+            producerModuleProcessingStep(
+                    messager,
+                    moduleValidator,
+                    provisionBindingFactory,
+                    multipleGenerator,
+                    productionBindingFactory,
+                    producerFactoryGenerator),
+            new ComponentProcessingStep(
+                    ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
+                    messager,
+                    componentValidator,
+                    subcomponentValidator,
+                    builderValidator,
+                    componentHierarchyValidator,
+                    bindingGraphValidator,
+                    componentDescriptorFactory,
+                    bindingGraphFactory,
+                    componentGenerator),
+            new MultibindingsProcessingStep(messager, multibindingsValidator),
+            new BindingMethodProcessingStep(messager, anyBindingMethodValidator),
             new InjectorProcessingStep(
                     types,
                     messager,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java b/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
index b21b5e09e..e7d61ac76 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
@@ -38,7 +38,7 @@
 import javax.lang.model.element.TypeElement;
 
 /** Validates uses of {@link ForReleasableReferences @ForReleasableReferences}. */
-final class ForReleasableReferencesValidator implements ProcessingStep {
+final class ForReleasableReferencesValidator implements BasicProcessor.ProcessingStep {
 
   private final Messager messager;
 
@@ -71,7 +71,7 @@
 
   @Override
   public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
     elementsByAnnotation
         .get(ForReleasableReferences.class)
         .stream()
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 2343589f0..2abc3ed7c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -35,7 +35,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+final class InjectProcessingStep implements BasicProcessor.ProcessingStep {
   private final InjectBindingRegistry injectBindingRegistry;
 
   InjectProcessingStep(InjectBindingRegistry factoryRegistrar) {
@@ -49,7 +49,7 @@
 
   @Override
   public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
     ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
     // TODO(gak): add some error handling for bad source files
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
index f2a57e7c3..94a76d397 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
@@ -23,7 +23,7 @@
 import java.util.function.Function;
 import java.util.stream.Collectors;
 
-public class InjectorProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+public class InjectorProcessingStep implements BasicProcessor.ProcessingStep {
 
     private Types types;
     private final Messager messager;
@@ -68,7 +68,11 @@ public InjectorProcessingStep(Types types, Messager messager,
     }
 
     @Override
-    public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
+
+        if(anyElementsRejected) {
+            return ImmutableSet.of();
+        }
 
         final Iterator<Element> it = elementsByAnnotation.get(Config.class).iterator();
         if (!it.hasNext()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 1ce870a54..4ff20e8b3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -220,9 +220,9 @@ public ClassName getDelegateTypeName() {
       if (mapKey.isPresent()) {
         mapValue = mapKey.get().getElementValues().entrySet().stream()
                 .filter(e -> e.getKey().getSimpleName().toString().equals("value"))
-                .map(e -> e.getValue().getValue().toString().replace(".", "_"))
+                .map(e -> Util.extractClassName(e.getValue().getValue().toString().replace(".class", "")))
                 .findFirst();
-        simpleMapKeyName = MoreAnnotationMirrors.simpleName(qualifier.get()).toString();
+        simpleMapKeyName = MoreAnnotationMirrors.simpleName(mapKey.get()).toString();
         if (mapValue.isPresent()) {
           simpleMapValueName = mapValue.get();
         }
@@ -282,9 +282,9 @@ public String getDelegateFieldName() {
       if (mapKey.isPresent()) {
         mapValue = mapKey.get().getElementValues().entrySet().stream()
                 .filter(e -> e.getKey().getSimpleName().contentEquals("value"))
-                .map(e -> e.getValue().getValue().toString().replace(".", "_"))
+                .map(e -> Util.extractClassName(e.getValue().getValue().toString().replace(".class", "")))
                 .findFirst();
-        simpleMapKeyName = MoreAnnotationMirrors.simpleName(qualifier.get()).toString();
+        simpleMapKeyName = MoreAnnotationMirrors.simpleName(mapKey.get()).toString();
         if (mapValue.isPresent()) {
           simpleMapValueName = mapValue.get();
         }
@@ -324,13 +324,11 @@ protected String transformValue(String simpleMapValueName, StringBuilder sb) {
     }
 
     private boolean hasMapKeyAnnotation(AnnotationMirror o) {
-      return o.getAnnotationType().getAnnotationMirrors().stream()
-              .anyMatch(annotation -> annotation.getAnnotationType().toString().equals(MapKey.class.getName()));
+      return MoreElements.isAnnotationPresent(o.getAnnotationType().asElement(), MapKey.class);
     }
 
     private boolean hasQualifierAnnotation(AnnotationMirror o) {
-      return o.getAnnotationType().getAnnotationMirrors().stream()
-              .anyMatch(annotation -> annotation.getAnnotationType().toString().equals(Qualifier.class.getName()));
+      return MoreElements.isAnnotationPresent(o.getAnnotationType().asElement(), Qualifier.class);
     }
 
     private static String getCapitalizedAnnotationValue(AnnotationMirror annotation) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
index 241e61771..bbcbad44f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -41,7 +41,7 @@
  * @author Chenying Hou
  * @since 2.0
  */
-public class MapKeyProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+public class MapKeyProcessingStep implements BasicProcessor.ProcessingStep {
   private final Messager messager;
   private final Types types;
   private final MapKeyValidator mapKeyValidator;
@@ -68,7 +68,7 @@
 
   @Override
   public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
     for (TypeElement mapKeyAnnotationType : typesIn(elementsByAnnotation.get(MapKey.class))) {
       ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(mapKeyAnnotationType);
       mapKeyReport.printMessagesTo(messager);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 80150627c..9c0ca8765 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -40,7 +40,7 @@
  * A {@link ProcessingStep} that validates module classes and generates factories for binding
  * methods.
  */
-final class ModuleProcessingStep implements ProcessingStep {
+final class ModuleProcessingStep implements BasicProcessor.ProcessingStep {
 
   /**
    * A {@link ProcessingStep} for {@code @Module} classes that generates factories for
@@ -110,7 +110,7 @@ static ModuleProcessingStep producerModuleProcessingStep(
 
   @Override
   public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
     List<TypeElement> modules = typesIn(elementsByAnnotation.values());
     moduleValidator.addKnownModules(modules);
     for (TypeElement module : modules) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
index 1bd095e29..d850881c0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
@@ -31,7 +31,7 @@
  * A processing step that is responsible for generating a special module for a
  * {@link ProductionComponent} or {@link ProductionSubcomponent}.
  */
-final class MonitoringModuleProcessingStep implements ProcessingStep {
+final class MonitoringModuleProcessingStep implements BasicProcessor.ProcessingStep {
   private final Messager messager;
   private final MonitoringModuleGenerator monitoringModuleGenerator;
 
@@ -48,7 +48,7 @@
 
   @Override
   public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
     for (Element element : elementsByAnnotation.values()) {
       monitoringModuleGenerator.generate(MoreElements.asType(element), messager);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
index df977c235..501a64ce8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
@@ -41,7 +41,7 @@
  * Processing step that verifies that {@link IntoSet}, {@link ElementsIntoSet} and {@link IntoMap}
  * are not present on invalid elements.
  */
-final class MultibindingAnnotationsProcessingStep implements ProcessingStep {
+final class MultibindingAnnotationsProcessingStep implements BasicProcessor.ProcessingStep {
 
   private static final ImmutableSet<Class<? extends Annotation>> VALID_BINDING_ANNOTATIONS =
       ImmutableSet.of(Provides.class, Produces.class, Binds.class);
@@ -59,7 +59,7 @@
 
   @Override
   public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
     for (Entry<Class<? extends Annotation>, Element> entry : elementsByAnnotation.entries()) {
       Element element = entry.getValue();
       if (!isAnyAnnotationPresent(element, VALID_BINDING_ANNOTATIONS)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
index a52d5cd7b..6cf8c1bcd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
@@ -32,7 +32,7 @@
  * Valdiates types annotated with {@link Multibindings @Multibindings} that haven't already been
  * validated while processing their enclosing modules.
  */
-class MultibindingsProcessingStep implements ProcessingStep {
+class MultibindingsProcessingStep implements BasicProcessor.ProcessingStep {
   private final Messager messager;
   private final MultibindingsValidator multibindingsValidator;
 
@@ -48,7 +48,7 @@
 
   @Override
   public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
     for (TypeElement element : typesIn(elementsByAnnotation.values())) {
       if (!multibindingsValidator.wasAlreadyValidated(element)) {
         multibindingsValidator.validate(element).printMessagesTo(messager);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
index d508a51e8..7ab8d6a03 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
@@ -31,7 +31,7 @@
  * A processing step that is responsible for generating a special module for a
  * {@link ProductionComponent} or {@link ProductionSubcomponent}.
  */
-final class ProductionExecutorModuleProcessingStep implements ProcessingStep {
+final class ProductionExecutorModuleProcessingStep implements BasicProcessor.ProcessingStep {
   private final Messager messager;
   private final ProductionExecutorModuleGenerator productionExecutorModuleGenerator;
 
@@ -48,7 +48,7 @@
 
   @Override
   public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
     for (Element element : elementsByAnnotation.values()) {
       productionExecutorModuleGenerator.generate(MoreElements.asType(element), messager);
     }
diff --git a/core/src/main/java/dagger/di/ComponentBuilder.java b/core/src/main/java/dagger/di/ComponentBuilder.java
index c199b6feb..972ec8306 100644
--- a/core/src/main/java/dagger/di/ComponentBuilder.java
+++ b/core/src/main/java/dagger/di/ComponentBuilder.java
@@ -16,13 +16,28 @@ public ComponentBuilder(Map<Class<?>, Provider<P>> builders) {
                                                                                              A injectable,
                                                                                              Config<A, C, T> config) {
         T builder = (T) builders.get(injectable.getClass()).get();
-        C component = config.configure(builder);
+        C component = config.configure(builder).build();
+        component.injectMembers(injectable);
+        return component;
+    }
+
+    public <A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> C getComponent(Class<T> clazz,
+                                                                                             A injectable) {
+        T builder = (T) builders.get(injectable.getClass()).get();
+        C component = builder.build();
+        component.injectMembers(injectable);
+        return component;
+    }
+
+    public <A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> C getComponent(A injectable) {
+        T builder = (T) builders.get(injectable.getClass()).get();
+        C component = builder.build();
         component.injectMembers(injectable);
         return component;
     }
 
     public interface Config<A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> {
-        C configure(T builder);
+        T configure(T builder);
     }
 
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java
index e3f4634ad..8395cf4f6 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java
@@ -20,8 +20,12 @@
 
 import android.app.Application;
 import android.location.LocationManager;
+import dagger.AllowStubGeneration;
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.StringKey;
+
 import javax.inject.Singleton;
 
 /**
@@ -46,4 +50,12 @@ public DemoApplicationModule(Application application) {
   @Provides @Singleton LocationManager provideLocationManager() {
     return (LocationManager) application.getSystemService(LOCATION_SERVICE);
   }
+
+  @Provides
+  @StringKey("BLA")
+  @AllowStubGeneration
+  @IntoMap
+  public String prov() {
+    return "";
+  }
 }
