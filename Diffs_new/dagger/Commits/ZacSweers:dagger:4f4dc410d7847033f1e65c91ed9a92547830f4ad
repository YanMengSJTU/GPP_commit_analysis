diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index e7b6b6053..7f0481a03 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -95,6 +95,7 @@ java_library(
         "Expression.java",
         "FeatureStatus.java",
         "Formatter.java",
+        "ForwardingCompilerOptions.java",
         "FrameworkTypes.java",
         "InjectionAnnotations.java",
         "Keys.java",
@@ -105,6 +106,7 @@ java_library(
         "MoreAnnotationValues.java",
         "MultibindingAnnotations.java",
         "OptionalType.java",
+        "ProcessingEnvironmentCompilerOptions.java",
         "ProcessingOptions.java",
         "RequestKinds.java",
         "Scopes.java",
diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index bae025a9b..2109989f9 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -16,41 +16,12 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Iterables.concat;
-import static com.google.common.collect.Sets.immutableEnumSet;
-import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.FeatureStatus.DISABLED;
-import static dagger.internal.codegen.FeatureStatus.ENABLED;
-import static dagger.internal.codegen.ValidationType.ERROR;
-import static dagger.internal.codegen.ValidationType.NONE;
-import static dagger.internal.codegen.ValidationType.WARNING;
-import static java.util.EnumSet.allOf;
-
-import com.google.auto.value.AutoValue;
-import com.google.common.base.Ascii;
-import com.google.common.collect.ImmutableSet;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.CheckReturnValue;
 import com.squareup.javapoet.AnnotationSpec;
 import dagger.internal.GenerationOptions;
-import dagger.producers.Produces;
-import java.util.Arrays;
-import java.util.EnumSet;
-import java.util.Map;
-import java.util.Set;
-import java.util.function.BiConsumer;
-import java.util.stream.Stream;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.annotation.processing.Processor;
 import javax.lang.model.element.TypeElement;
 import javax.tools.Diagnostic;
-import javax.tools.Diagnostic.Kind;
 
 /** A collection of options that dictate how the compiler will run. */
-@AutoValue
 abstract class CompilerOptions {
   abstract boolean usesProducers();
 
@@ -70,7 +41,7 @@
 
   abstract Diagnostic.Kind nullableValidationKind();
 
-  boolean doCheckForNulls() {
+  final boolean doCheckForNulls() {
     return nullableValidationKind().equals(Diagnostic.Kind.ERROR);
   }
 
@@ -97,369 +68,33 @@ boolean doCheckForNulls() {
 
   abstract boolean useGradleIncrementalProcessing();
 
-  abstract ValidationType moduleBindingValidationType();
-
   /** Returns the binding {@link ValidationType} for the element. */
-  ValidationType moduleBindingValidationType(TypeElement element) {
-    return moduleBindingValidationType();
-  }
-
-  abstract ImmutableSet<String> javacOptions();
+  abstract ValidationType moduleBindingValidationType(TypeElement element);
 
   abstract Diagnostic.Kind moduleHasDifferentScopesDiagnosticKind();
 
   abstract ValidationType explicitBindingConflictsWithInjectValidationType();
 
-  static Builder builder() {
-    return new AutoValue_CompilerOptions.Builder()
-        .javacOptions(ImmutableSet.of())
-        .headerCompilation(false)
-        .useGradleIncrementalProcessing(false);
-  }
-
-  static CompilerOptions create(ProcessingEnvironment processingEnv) {
-    Builder builder = new AutoValue_CompilerOptions.Builder()
-        .javacOptions(processingEnv.getOptions().keySet());
-    for (Option option : concat(allOf(Feature.class), allOf(Validation.class))) {
-      option.set(builder, processingEnv);
-    }
-    return builder.build();
-  }
-
-  abstract Builder toBuilder();
-
   /**
    * Creates a new {@link CompilerOptions} from the serialized {@link GenerationOptions} of a base
    * component implementation.
    */
-  CompilerOptions withGenerationOptions(GenerationOptions generationOptions) {
-    return toBuilder().fastInit(generationOptions.fastInit()).build();
+  final CompilerOptions withGenerationOptions(GenerationOptions generationOptions) {
+    return new ForwardingCompilerOptions(this) {
+      @Override
+      public boolean fastInit() {
+        return generationOptions.fastInit();
+      }
+    };
   }
 
   /**
-   * Returns an {@link GenerationOptions} annotation that serializes any options for this
-   * compilation that should be reused in future compilations.
+   * Returns a {@link GenerationOptions} annotation that serializes any options for this compilation
+   * that should be reused in future compilations.
    */
-  AnnotationSpec toGenerationOptionsAnnotation() {
+  final AnnotationSpec toGenerationOptionsAnnotation() {
     return AnnotationSpec.builder(GenerationOptions.class)
         .addMember("fastInit", "$L", fastInit())
         .build();
   }
-
-  @AutoValue.Builder
-  @CanIgnoreReturnValue
-  interface Builder {
-    Builder javacOptions(Set<String> javacOptions);
-
-    Builder usesProducers(boolean usesProduces);
-
-    Builder headerCompilation(boolean headerCompilation);
-
-    Builder fastInit(boolean fastInit);
-
-    Builder formatGeneratedSource(boolean formatGeneratedSource);
-
-    Builder writeProducerNameInToken(boolean writeProducerNameInToken);
-
-    Builder nullableValidationKind(Diagnostic.Kind kind);
-
-    Builder privateMemberValidationKind(Diagnostic.Kind kind);
-
-    Builder staticMemberValidationKind(Diagnostic.Kind kind);
-
-    Builder ignorePrivateAndStaticInjectionForComponent(
-        boolean ignorePrivateAndStaticInjectionForComponent);
-
-    Builder scopeCycleValidationType(ValidationType type);
-
-    Builder warnIfInjectionFactoryNotGeneratedUpstream(
-        boolean warnIfInjectionFactoryNotGeneratedUpstream);
-
-    Builder aheadOfTimeSubcomponents(boolean aheadOfTimeSubcomponents);
-
-    Builder useGradleIncrementalProcessing(boolean enabled);
-
-    Builder moduleBindingValidationType(ValidationType validationType);
-
-    Builder moduleHasDifferentScopesDiagnosticKind(Diagnostic.Kind kind);
-
-    Builder explicitBindingConflictsWithInjectValidationType(ValidationType validationType);
-
-    @CheckReturnValue
-    CompilerOptions build();
-  }
-
-  /** An option that can be set into {@link CompilerOptions}. */
-  private interface Option<T extends Enum<T>> {
-
-    /** Sets the appropriate property on a {@link CompilerOptions.Builder}. */
-    void set(Builder builder, ProcessingEnvironment processingEnvironment);
-
-    /**
-     * {@code true} if {@link #toString()} represents a {@linkplain Processor#getSupportedOptions()
-     * supported command line option}.
-     */
-    default boolean useCommandLineOption() {
-      return true;
-    }
-
-    /** The default value for this option. */
-    T defaultValue();
-
-    /** The valid values for this option. */
-    Set<T> validValues();
-  }
-
-  /** A feature that can be enabled or disabled. */
-  private enum Feature implements Option<FeatureStatus> {
-    HEADER_COMPILATION(Builder::headerCompilation) {
-      @Override
-      boolean isEnabled(ProcessingEnvironment processingEnvironment) {
-        return processingEnvironment.getOptions().containsKey(toString());
-      }
-
-      @Override
-      public String toString() {
-        return "experimental_turbine_hjar";
-      }
-    },
-
-    FAST_INIT(Builder::fastInit),
-
-    EXPERIMENTAL_ANDROID_MODE((builder, ignoredValue) -> {}) {
-      @Override
-      public void set(Builder builder, ProcessingEnvironment processingEnvironment) {
-        noLongerRecognizedWarning(processingEnvironment);
-      }
-    },
-
-    FORMAT_GENERATED_SOURCE(Builder::formatGeneratedSource, ENABLED),
-
-    WRITE_PRODUCER_NAME_IN_TOKEN(Builder::writeProducerNameInToken),
-
-    WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM(
-        Builder::warnIfInjectionFactoryNotGeneratedUpstream),
-
-    IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT(
-        Builder::ignorePrivateAndStaticInjectionForComponent),
-
-    EXPERIMENTAL_AHEAD_OF_TIME_SUBCOMPONENTS(Builder::aheadOfTimeSubcomponents),
-
-    FLOATING_BINDS_METHODS((builder, ignoredValue) -> {}) {
-      @Override
-      public void set(Builder builder, ProcessingEnvironment processingEnvironment) {
-        noLongerRecognizedWarning(processingEnvironment);
-      }
-    },
-
-    USE_GRADLE_INCREMENTAL_PROCESSING(Builder::useGradleIncrementalProcessing) {
-      @Override
-      boolean isEnabled(ProcessingEnvironment processingEnvironment) {
-        return processingEnvironment.getOptions().containsKey(toString());
-      }
-
-      @Override
-      public String toString() {
-        return "dagger.gradle.incremental";
-      }
-    },
-
-    USES_PRODUCERS(Builder::usesProducers) {
-      @Override
-      boolean isEnabled(ProcessingEnvironment processingEnvironment) {
-        return processingEnvironment
-                .getElementUtils()
-                .getTypeElement(Produces.class.getCanonicalName())
-            != null;
-      }
-
-      @Override
-      public boolean useCommandLineOption() {
-        return false;
-      }
-    },
-    ;
-
-    final OptionParser<FeatureStatus> parser = new OptionParser<>(this);
-    final FeatureStatus defaultValue;
-    final BiConsumer<Builder, Boolean> setter;
-
-    Feature(BiConsumer<Builder, Boolean> setter) {
-      this(setter, DISABLED);
-    }
-
-    Feature(BiConsumer<Builder, Boolean> setter, FeatureStatus defaultValue) {
-      this.setter = setter;
-      this.defaultValue = defaultValue;
-    }
-
-    @Override
-    public FeatureStatus defaultValue() {
-      return defaultValue;
-    }
-
-    @Override
-    public Set<FeatureStatus> validValues() {
-      return EnumSet.allOf(FeatureStatus.class);
-    }
-
-    @Override
-    public void set(Builder builder, ProcessingEnvironment processingEnvironment) {
-      setter.accept(builder, isEnabled(processingEnvironment));
-    }
-
-    boolean isEnabled(ProcessingEnvironment processingEnvironment) {
-      return parser.parse(processingEnvironment).equals(ENABLED);
-    }
-
-    @Override
-    public String toString() {
-      return optionName(name());
-    }
-
-    void noLongerRecognizedWarning(ProcessingEnvironment processingEnvironment) {
-      if (processingEnvironment.getOptions().containsKey(toString())) {
-          processingEnvironment
-            .getMessager()
-            .printMessage(
-                Diagnostic.Kind.WARNING,
-                toString() + " is no longer a recognized option by Dagger");
-      }
-    }
-
-  }
-
-  /** The diagnostic kind or validation type for a kind of validation. */
-  private enum Validation implements Option<ValidationType> {
-    DISABLE_INTER_COMPONENT_SCOPE_VALIDATION(Builder::scopeCycleValidationType),
-
-    NULLABLE_VALIDATION(kindSetter(Builder::nullableValidationKind), ERROR, WARNING) {
-    },
-
-    PRIVATE_MEMBER_VALIDATION(kindSetter(Builder::privateMemberValidationKind), ERROR, WARNING),
-
-    STATIC_MEMBER_VALIDATION(kindSetter(Builder::staticMemberValidationKind), ERROR, WARNING),
-
-    /** Whether to validate partial binding graphs associated with modules. */
-    MODULE_BINDING_VALIDATION(Builder::moduleBindingValidationType, NONE, ERROR, WARNING),
-
-    /**
-     * How to report conflicting scoped bindings when validating partial binding graphs associated
-     * with modules.
-     */
-    MODULE_HAS_DIFFERENT_SCOPES_VALIDATION(
-        kindSetter(Builder::moduleHasDifferentScopesDiagnosticKind), ERROR, WARNING),
-
-    /**
-     * How to report that an explicit binding in a subcomponent conflicts with an {@code @Inject}
-     * constructor used in an ancestor component.
-     */
-    EXPLICIT_BINDING_CONFLICTS_WITH_INJECT(
-        Builder::explicitBindingConflictsWithInjectValidationType, WARNING, ERROR, NONE),
-    ;
-
-    final OptionParser<ValidationType> parser = new OptionParser<>(this);
-
-    static BiConsumer<Builder, ValidationType> kindSetter(
-        BiConsumer<Builder, Diagnostic.Kind> setter) {
-      return (builder, validationType) ->
-          setter.accept(builder, validationType.diagnosticKind().get());
-    }
-
-    final ValidationType defaultType;
-    final ImmutableSet<ValidationType> validTypes;
-    final BiConsumer<Builder, ValidationType> setter;
-
-    Validation(BiConsumer<Builder, ValidationType> setter) {
-      this(setter, ERROR, WARNING, NONE);
-    }
-
-    Validation(
-        BiConsumer<Builder, ValidationType> setter,
-        ValidationType defaultType,
-        ValidationType... moreValidTypes) {
-      this.setter = setter;
-      this.defaultType = defaultType;
-      this.validTypes = immutableEnumSet(defaultType, moreValidTypes);
-    }
-
-    @Override
-    public ValidationType defaultValue() {
-      return defaultType;
-    }
-
-    @Override
-    public Set<ValidationType> validValues() {
-      return validTypes;
-    }
-
-    @Override
-    public void set(Builder builder, ProcessingEnvironment processingEnvironment) {
-      setter.accept(builder, parser.parse(processingEnvironment));
-    }
-
-    @Override
-    public String toString() {
-      return optionName(name());
-    }
-  }
-
-  private static String optionName(String enumName) {
-    return "dagger." + UPPER_UNDERSCORE.to(LOWER_CAMEL, enumName);
-  }
-
-  static ImmutableSet<String> supportedOptions() {
-    return Stream.<Option<?>[]>of(Feature.values(), Validation.values())
-        .flatMap(Arrays::stream)
-        .filter(Option::useCommandLineOption)
-        .map(Option::toString)
-        .collect(toImmutableSet());
-  }
-
-  /** A parser for an {@link Option}. */
-  private static class OptionParser<T extends Enum<T>> {
-    private final Option<T> option;
-
-    OptionParser(Option<T> option) {
-      this.option = checkNotNull(option);
-    }
-
-    /**
-     * Returns the value for this option as set on the command line, or the default value if not.
-     */
-    T parse(ProcessingEnvironment processingEnvironment) {
-      String key = option.toString();
-      Map<String, String> options = processingEnvironment.getOptions();
-      if (options.containsKey(key)) {
-        String stringValue = options.get(key);
-        if (stringValue == null) {
-          processingEnvironment
-              .getMessager()
-              .printMessage(Diagnostic.Kind.ERROR, "Processor option -A" + key + " needs a value");
-        } else {
-          try {
-            T value = Enum.valueOf(valueClass(), Ascii.toUpperCase(stringValue));
-            if (option.validValues().contains(value)) {
-              return value;
-            }
-          } catch (IllegalArgumentException e) {
-            // handled below
-          }
-          processingEnvironment
-              .getMessager()
-              .printMessage(
-                  Diagnostic.Kind.ERROR,
-                  String.format(
-                      "Processor option -A%s may only have the values %s "
-                          + "(case insensitive), found: %s",
-                      key, option.validValues(), stringValue));
-        }
-      }
-      return option.defaultValue();
-    }
-
-    private Class<T> valueClass() {
-      return option.defaultValue().getDeclaringClass();
-    }
-  }
 }
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index 6b137b3c8..cb3ff9ca4 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -92,7 +92,7 @@ public SourceVersion getSupportedSourceVersion() {
   @Override
   public Set<String> getSupportedOptions() {
     ImmutableSet.Builder<String> options = ImmutableSet.builder();
-    options.addAll(CompilerOptions.supportedOptions());
+    options.addAll(ProcessingEnvironmentCompilerOptions.supportedOptions());
     options.addAll(bindingGraphPlugins.allSupportedOptions());
     if (compilerOptions.useGradleIncrementalProcessing()) {
       options.add("org.gradle.annotation.processing.isolating");
diff --git a/java/dagger/internal/codegen/ForwardingCompilerOptions.java b/java/dagger/internal/codegen/ForwardingCompilerOptions.java
new file mode 100644
index 000000000..2272d3598
--- /dev/null
+++ b/java/dagger/internal/codegen/ForwardingCompilerOptions.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import javax.lang.model.element.TypeElement;
+import javax.tools.Diagnostic;
+
+/** A {@link CompilerOptions} object that delegates to another one. */
+class ForwardingCompilerOptions extends CompilerOptions {
+
+  private final CompilerOptions delegate;
+
+  ForwardingCompilerOptions(CompilerOptions delegate) {
+    this.delegate = checkNotNull(delegate);
+  }
+
+  @Override
+  boolean usesProducers() {
+    return delegate.usesProducers();
+  }
+
+  @Override
+  boolean fastInit() {
+    return delegate.fastInit();
+  }
+
+  @Override
+  boolean formatGeneratedSource() {
+    return delegate.formatGeneratedSource();
+  }
+
+  @Override
+  boolean writeProducerNameInToken() {
+    return delegate.writeProducerNameInToken();
+  }
+
+  @Override
+  Diagnostic.Kind nullableValidationKind() {
+    return delegate.nullableValidationKind();
+  }
+
+  @Override
+  Diagnostic.Kind privateMemberValidationKind() {
+    return delegate.privateMemberValidationKind();
+  }
+
+  @Override
+  Diagnostic.Kind staticMemberValidationKind() {
+    return delegate.staticMemberValidationKind();
+  }
+
+  @Override
+  boolean ignorePrivateAndStaticInjectionForComponent() {
+    return delegate.ignorePrivateAndStaticInjectionForComponent();
+  }
+
+  @Override
+  ValidationType scopeCycleValidationType() {
+    return delegate.scopeCycleValidationType();
+  }
+
+  @Override
+  boolean warnIfInjectionFactoryNotGeneratedUpstream() {
+    return delegate.warnIfInjectionFactoryNotGeneratedUpstream();
+  }
+
+  @Override
+  boolean headerCompilation() {
+    return delegate.headerCompilation();
+  }
+
+  @Override
+  boolean aheadOfTimeSubcomponents() {
+    return delegate.aheadOfTimeSubcomponents();
+  }
+
+  @Override
+  boolean useGradleIncrementalProcessing() {
+    return delegate.useGradleIncrementalProcessing();
+  }
+
+  @Override
+  ValidationType moduleBindingValidationType(TypeElement element) {
+    return delegate.moduleBindingValidationType(element);
+  }
+
+  @Override
+  Diagnostic.Kind moduleHasDifferentScopesDiagnosticKind() {
+    return delegate.moduleHasDifferentScopesDiagnosticKind();
+  }
+
+  @Override
+  ValidationType explicitBindingConflictsWithInjectValidationType() {
+    return delegate.explicitBindingConflictsWithInjectValidationType();
+  }
+}
diff --git a/java/dagger/internal/codegen/JavacPluginModule.java b/java/dagger/internal/codegen/JavacPluginModule.java
index 44f11fdcb..7f55573fd 100644
--- a/java/dagger/internal/codegen/JavacPluginModule.java
+++ b/java/dagger/internal/codegen/JavacPluginModule.java
@@ -30,6 +30,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
@@ -41,21 +42,87 @@
 abstract class JavacPluginModule {
   @Provides
   static CompilerOptions compilerOptions() {
-    return CompilerOptions.builder()
-        .usesProducers(true)
-        .writeProducerNameInToken(true)
-        .nullableValidationKind(NOTE)
-        .privateMemberValidationKind(NOTE)
-        .staticMemberValidationKind(NOTE)
-        .ignorePrivateAndStaticInjectionForComponent(false)
-        .scopeCycleValidationType(NONE)
-        .warnIfInjectionFactoryNotGeneratedUpstream(false)
-        .fastInit(false)
-        .aheadOfTimeSubcomponents(false)
-        .moduleBindingValidationType(NONE)
-        .moduleHasDifferentScopesDiagnosticKind(NOTE)
-        .explicitBindingConflictsWithInjectValidationType(NONE)
-        .build();
+    return new CompilerOptions() {
+      @Override
+      boolean usesProducers() {
+        return true;
+      }
+
+      @Override
+      boolean fastInit() {
+        return false;
+      }
+
+      @Override
+      boolean formatGeneratedSource() {
+        return false;
+      }
+
+      @Override
+      boolean writeProducerNameInToken() {
+        return true;
+      }
+
+      @Override
+      Diagnostic.Kind nullableValidationKind() {
+        return NOTE;
+      }
+
+      @Override
+      Diagnostic.Kind privateMemberValidationKind() {
+        return NOTE;
+      }
+
+      @Override
+      Diagnostic.Kind staticMemberValidationKind() {
+        return NOTE;
+      }
+
+      @Override
+      boolean ignorePrivateAndStaticInjectionForComponent() {
+        return false;
+      }
+
+      @Override
+      ValidationType scopeCycleValidationType() {
+        return NONE;
+      }
+
+      @Override
+      boolean warnIfInjectionFactoryNotGeneratedUpstream() {
+        return false;
+      }
+
+      @Override
+      boolean headerCompilation() {
+        return false;
+      }
+
+      @Override
+      boolean aheadOfTimeSubcomponents() {
+        return false;
+      }
+
+      @Override
+      boolean useGradleIncrementalProcessing() {
+        return false;
+      }
+
+      @Override
+      ValidationType moduleBindingValidationType(TypeElement element) {
+        return NONE;
+      }
+
+      @Override
+      Diagnostic.Kind moduleHasDifferentScopesDiagnosticKind() {
+        return NOTE;
+      }
+
+      @Override
+      ValidationType explicitBindingConflictsWithInjectValidationType() {
+        return NONE;
+      }
+    };
   }
 
   @Binds
diff --git a/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java b/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java
new file mode 100644
index 000000000..8cd104fae
--- /dev/null
+++ b/java/dagger/internal/codegen/ProcessingEnvironmentCompilerOptions.java
@@ -0,0 +1,392 @@
+/*
+ * Copyright (C) 2019 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.FeatureStatus.DISABLED;
+import static dagger.internal.codegen.FeatureStatus.ENABLED;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.EXPERIMENTAL_AHEAD_OF_TIME_SUBCOMPONENTS;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.EXPERIMENTAL_ANDROID_MODE;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.FAST_INIT;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.FLOATING_BINDS_METHODS;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.FORMAT_GENERATED_SOURCE;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Feature.WRITE_PRODUCER_NAME_IN_TOKEN;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.KeyOnlyOption.HEADER_COMPILATION;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.KeyOnlyOption.USE_GRADLE_INCREMENTAL_PROCESSING;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.DISABLE_INTER_COMPONENT_SCOPE_VALIDATION;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.EXPLICIT_BINDING_CONFLICTS_WITH_INJECT;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.MODULE_BINDING_VALIDATION;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.MODULE_HAS_DIFFERENT_SCOPES_VALIDATION;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.NULLABLE_VALIDATION;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.PRIVATE_MEMBER_VALIDATION;
+import static dagger.internal.codegen.ProcessingEnvironmentCompilerOptions.Validation.STATIC_MEMBER_VALIDATION;
+import static dagger.internal.codegen.ValidationType.ERROR;
+import static dagger.internal.codegen.ValidationType.NONE;
+import static dagger.internal.codegen.ValidationType.WARNING;
+
+import com.google.common.base.Ascii;
+import com.google.common.collect.ImmutableSet;
+import dagger.producers.Produces;
+import java.util.Arrays;
+import java.util.EnumSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Stream;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.TypeElement;
+import javax.tools.Diagnostic;
+
+final class ProcessingEnvironmentCompilerOptions extends CompilerOptions {
+  /** Returns a valid {@link CompilerOptions} parsed from the processing environment. */
+  static CompilerOptions create(ProcessingEnvironment processingEnvironment) {
+    return new ProcessingEnvironmentCompilerOptions(processingEnvironment).checkValid();
+  }
+
+  private final ProcessingEnvironment processingEnvironment;
+
+  private ProcessingEnvironmentCompilerOptions(ProcessingEnvironment processingEnvironment) {
+    this.processingEnvironment = processingEnvironment;
+  }
+
+  @Override
+  boolean usesProducers() {
+    return processingEnvironment.getElementUtils().getTypeElement(Produces.class.getCanonicalName())
+        != null;
+  }
+
+  @Override
+  boolean headerCompilation() {
+    return isEnabled(HEADER_COMPILATION);
+  }
+
+  @Override
+  boolean fastInit() {
+    return isEnabled(FAST_INIT);
+  }
+
+  @Override
+  boolean formatGeneratedSource() {
+    return isEnabled(FORMAT_GENERATED_SOURCE);
+  }
+
+  @Override
+  boolean writeProducerNameInToken() {
+    return isEnabled(WRITE_PRODUCER_NAME_IN_TOKEN);
+  }
+
+  @Override
+  Diagnostic.Kind nullableValidationKind() {
+    return diagnosticKind(NULLABLE_VALIDATION);
+  }
+
+  @Override
+  Diagnostic.Kind privateMemberValidationKind() {
+    return diagnosticKind(PRIVATE_MEMBER_VALIDATION);
+  }
+
+  @Override
+  Diagnostic.Kind staticMemberValidationKind() {
+    return diagnosticKind(STATIC_MEMBER_VALIDATION);
+  }
+
+  @Override
+  boolean ignorePrivateAndStaticInjectionForComponent() {
+    return isEnabled(IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT);
+  }
+
+  @Override
+  ValidationType scopeCycleValidationType() {
+    return validationType(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION);
+  }
+
+  @Override
+  boolean warnIfInjectionFactoryNotGeneratedUpstream() {
+    return isEnabled(WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM);
+  }
+
+  @Override
+  boolean aheadOfTimeSubcomponents() {
+    return isEnabled(EXPERIMENTAL_AHEAD_OF_TIME_SUBCOMPONENTS);
+  }
+
+  @Override
+  boolean useGradleIncrementalProcessing() {
+    return isEnabled(USE_GRADLE_INCREMENTAL_PROCESSING);
+  }
+
+  @Override
+  ValidationType moduleBindingValidationType(TypeElement element) {
+    return moduleBindingValidationType();
+  }
+
+  private ValidationType moduleBindingValidationType() {
+    return validationType(MODULE_BINDING_VALIDATION);
+  }
+
+  @Override
+  Diagnostic.Kind moduleHasDifferentScopesDiagnosticKind() {
+    return diagnosticKind(MODULE_HAS_DIFFERENT_SCOPES_VALIDATION);
+  }
+
+  @Override
+  ValidationType explicitBindingConflictsWithInjectValidationType() {
+    return validationType(EXPLICIT_BINDING_CONFLICTS_WITH_INJECT);
+  }
+
+  private boolean isEnabled(BooleanOption booleanOption) {
+    return booleanOption.isEnabled(processingEnvironment);
+  }
+
+  private ValidationType validationType(Validation validation) {
+    return validation.parse(processingEnvironment);
+  }
+
+  private Diagnostic.Kind diagnosticKind(Validation validation) {
+    return validationType(validation).diagnosticKind().get();
+  }
+
+  @SuppressWarnings("CheckReturnValue")
+  private ProcessingEnvironmentCompilerOptions checkValid() {
+    for (KeyOnlyOption keyOnlyOption : KeyOnlyOption.values()) {
+      isEnabled(keyOnlyOption);
+    }
+    for (Feature feature : Feature.values()) {
+      isEnabled(feature);
+    }
+    for (Validation validation : Validation.values()) {
+      validationType(validation);
+    }
+    noLongerRecognized(EXPERIMENTAL_ANDROID_MODE);
+    noLongerRecognized(FLOATING_BINDS_METHODS);
+    return this;
+  }
+
+  private void noLongerRecognized(CommandLineOption commandLineOption) {
+    if (processingEnvironment.getOptions().containsKey(commandLineOption.toString())) {
+      processingEnvironment
+          .getMessager()
+          .printMessage(
+              Diagnostic.Kind.WARNING,
+              commandLineOption.toString() + " is no longer recognized by Dagger");
+    }
+  }
+
+  /** An option that can be set on the command line. */
+  private interface CommandLineOption<T> {
+    /** The default value for this option. */
+    T defaultValue();
+
+    /** The valid values for this option. */
+    Set<T> validValues();
+
+    /** The key of the option (appears after "-A"). */
+    @Override
+    String toString();
+  }
+
+  /** An option that is enabled or not. */
+  private interface BooleanOption {
+    /** Returns {@code true} if the option is enabled. */
+    boolean isEnabled(ProcessingEnvironment processingEnvironment);
+  }
+
+  enum KeyOnlyOption implements BooleanOption {
+    HEADER_COMPILATION {
+      @Override
+      public String toString() {
+        return "experimental_turbine_hjar";
+      }
+    },
+
+    USE_GRADLE_INCREMENTAL_PROCESSING {
+      @Override
+      public String toString() {
+        return "dagger.gradle.incremental";
+      }
+    },
+    ;
+
+    @Override
+    public boolean isEnabled(ProcessingEnvironment processingEnvironment) {
+      return processingEnvironment.getOptions().containsKey(toString());
+    }
+  }
+
+  /**
+   * A feature that can be enabled or disabled on the command line by setting {@code -Akey=ENABLED}
+   * or {@code -Akey=DISABLED}.
+   */
+  enum Feature implements CommandLineOption<FeatureStatus>, BooleanOption {
+    FAST_INIT,
+
+    EXPERIMENTAL_ANDROID_MODE,
+
+    FORMAT_GENERATED_SOURCE(ENABLED),
+
+    WRITE_PRODUCER_NAME_IN_TOKEN,
+
+    WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM,
+
+    IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT,
+
+    EXPERIMENTAL_AHEAD_OF_TIME_SUBCOMPONENTS,
+
+    FLOATING_BINDS_METHODS,
+    ;
+
+    final FeatureStatus defaultValue;
+
+    Feature() {
+      this(DISABLED);
+    }
+
+    Feature(FeatureStatus defaultValue) {
+      this.defaultValue = defaultValue;
+    }
+
+    @Override
+    public FeatureStatus defaultValue() {
+      return defaultValue;
+    }
+
+    @Override
+    public Set<FeatureStatus> validValues() {
+      return EnumSet.allOf(FeatureStatus.class);
+    }
+
+    @Override
+    public boolean isEnabled(ProcessingEnvironment processingEnvironment) {
+      return parseOption(this, processingEnvironment).equals(ENABLED);
+    }
+
+    @Override
+    public String toString() {
+      return optionName(name());
+    }
+  }
+
+  /** The diagnostic kind or validation type for a kind of validation. */
+  enum Validation implements CommandLineOption<ValidationType> {
+    DISABLE_INTER_COMPONENT_SCOPE_VALIDATION(),
+
+    NULLABLE_VALIDATION(ERROR, WARNING),
+
+    PRIVATE_MEMBER_VALIDATION(ERROR, WARNING),
+
+    STATIC_MEMBER_VALIDATION(ERROR, WARNING),
+
+    /** Whether to validate partial binding graphs associated with modules. */
+    MODULE_BINDING_VALIDATION(NONE, ERROR, WARNING),
+
+    /**
+     * How to report conflicting scoped bindings when validating partial binding graphs associated
+     * with modules.
+     */
+    MODULE_HAS_DIFFERENT_SCOPES_VALIDATION(ERROR, WARNING),
+
+    /**
+     * How to report that an explicit binding in a subcomponent conflicts with an {@code @Inject}
+     * constructor used in an ancestor component.
+     */
+    EXPLICIT_BINDING_CONFLICTS_WITH_INJECT(WARNING, ERROR, NONE),
+    ;
+
+    final ValidationType defaultType;
+    final ImmutableSet<ValidationType> validTypes;
+
+    Validation() {
+      this(ERROR, WARNING, NONE);
+    }
+
+    Validation(ValidationType defaultType, ValidationType... moreValidTypes) {
+      this.defaultType = defaultType;
+      this.validTypes = immutableEnumSet(defaultType, moreValidTypes);
+    }
+
+    @Override
+    public ValidationType defaultValue() {
+      return defaultType;
+    }
+
+    @Override
+    public Set<ValidationType> validValues() {
+      return validTypes;
+    }
+
+    @Override
+    public String toString() {
+      return optionName(name());
+    }
+
+    ValidationType parse(ProcessingEnvironment processingEnvironment) {
+      return parseOption(this, processingEnvironment);
+    }
+  }
+
+  private static String optionName(String enumName) {
+    return "dagger." + UPPER_UNDERSCORE.to(LOWER_CAMEL, enumName);
+  }
+
+  /** The supported command-line options. */
+  static ImmutableSet<String> supportedOptions() {
+    return Stream.<Object[]>of(KeyOnlyOption.values(), Feature.values(), Validation.values())
+        .flatMap(Arrays::stream)
+        .map(Object::toString)
+        .collect(toImmutableSet());
+  }
+
+  /** Returns the value for the option as set on the command line, or the default value if not. */
+  private static <T extends Enum<T>> T parseOption(
+      CommandLineOption<T> commandLineOption, ProcessingEnvironment processingEnvironment) {
+    String key = commandLineOption.toString();
+    Map<String, String> options = processingEnvironment.getOptions();
+    if (options.containsKey(key)) {
+      String stringValue = options.get(key);
+      if (stringValue == null) {
+        processingEnvironment
+            .getMessager()
+            .printMessage(Diagnostic.Kind.ERROR, "Processor option -A" + key + " needs a value");
+      } else {
+        try {
+          T value =
+              Enum.valueOf(
+                  commandLineOption.defaultValue().getDeclaringClass(),
+                  Ascii.toUpperCase(stringValue));
+          if (commandLineOption.validValues().contains(value)) {
+            return value;
+          }
+        } catch (IllegalArgumentException e) {
+          // handled below
+        }
+        processingEnvironment
+            .getMessager()
+            .printMessage(
+                Diagnostic.Kind.ERROR,
+                String.format(
+                    "Processor option -A%s may only have the values %s "
+                        + "(case insensitive), found: %s",
+                    key, commandLineOption.validValues(), stringValue));
+      }
+    }
+    return commandLineOption.defaultValue();
+  }
+}
diff --git a/java/dagger/internal/codegen/ProcessingEnvironmentModule.java b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
index b5cbc81ba..532256dbc 100644
--- a/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
+++ b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
@@ -78,7 +78,7 @@ DaggerElements daggerElements() {
   @Provides
   @Reusable // to avoid parsing options more than once
   CompilerOptions compilerOptions() {
-    return CompilerOptions.create(processingEnvironment);
+    return ProcessingEnvironmentCompilerOptions.create(processingEnvironment);
   }
 
   @Provides
