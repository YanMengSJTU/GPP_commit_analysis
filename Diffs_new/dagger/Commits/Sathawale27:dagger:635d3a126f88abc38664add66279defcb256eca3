diff --git a/java/dagger/Reusable.java b/java/dagger/Reusable.java
index 4fd4b7da1..f2419d596 100644
--- a/java/dagger/Reusable.java
+++ b/java/dagger/Reusable.java
@@ -29,7 +29,7 @@
  * <p>{@code @Reusable} is useful when you want to limit the number of provisions of a type, but
  * there is no specific lifetime over which there must be only one instance.
  *
- * @see <a href="https://google.github.io/dagger/users-guide.html#reusable-scope">Reusable Scope</a>
+ * @see <a href="https://google.github.io/dagger/users-guide#reusable-scope">Reusable Scope</a>
  */
 @Documented
 @Beta
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index a804cff1d..26c26d8a5 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -227,6 +227,7 @@ java_library(
         "GeneratedComponentModel.java",
         "GwtCompatibility.java",
         "ImmediateFutureBindingExpression.java",
+        "InaccessibleMapKeyProxyGenerator.java",
         "InjectionMethods.java",
         "InjectionOrProvisionProviderCreationExpression.java",
         "InstanceFactoryCreationExpression.java",
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
index 808bd9627..58ef85858 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -408,7 +408,7 @@ ContributionBinding delegateBinding(
    * Returns a {@link dagger.model.BindingKind#DELEGATE} binding used when there is no binding that
    * satisfies the {@code @Binds} declaration.
    */
-  ContributionBinding missingDelegateBinding(DelegateDeclaration delegateDeclaration) {
+  ContributionBinding unresolvedDelegateBinding(DelegateDeclaration delegateDeclaration) {
     return buildDelegateBinding(
         ProvisionBinding.builder().scope(uniqueScopeOf(delegateDeclaration.bindingElement().get())),
         delegateDeclaration,
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 8cdc35f03..6647eb6c2 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -509,7 +509,7 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
     private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDeclaration) {
       Key delegateKey = delegateDeclaration.delegateRequest().key();
       if (cycleStack.contains(delegateKey)) {
-        return bindingFactory.missingDelegateBinding(delegateDeclaration);
+        return bindingFactory.unresolvedDelegateBinding(delegateDeclaration);
       }
 
       ResolvedBindings resolvedDelegate;
@@ -529,7 +529,7 @@ private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDe
         // is needed.
         // TODO(gak): revisit how we model missing delegates if/when we clean up how we model
         // binding declarations
-        return bindingFactory.missingDelegateBinding(delegateDeclaration);
+        return bindingFactory.unresolvedDelegateBinding(delegateDeclaration);
       }
       // It doesn't matter which of these is selected, since they will later on produce a
       // duplicate binding error.
diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index f649c7a24..e8fb60eeb 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -37,7 +37,7 @@
    *
    * <p><b>Warning: Do Not use! This flag is for internal, experimental use only!</b>
    *
-   * <p> Issues related to this flag will not be supported. This flag could break your build, cause
+   * <p>Issues related to this flag will not be supported. This flag could break your build, cause
    * memory leaks in your app, or cause other unknown issues at runtime.
    *
    * <p>If enabled, the generated code will attempt to more aggressively inline creation logic for
@@ -47,7 +47,9 @@
    * classloading on Android, these trade-offs are potentially advantageous.
    */
   abstract boolean experimentalAndroidMode();
+
   abstract boolean writeProducerNameInToken();
+
   abstract Diagnostic.Kind nullableValidationKind();
 
   boolean doCheckForNulls() {
@@ -55,10 +57,15 @@ boolean doCheckForNulls() {
   }
 
   abstract Diagnostic.Kind privateMemberValidationKind();
+
   abstract Diagnostic.Kind staticMemberValidationKind();
+
   abstract boolean ignorePrivateAndStaticInjectionForComponent();
+
   abstract ValidationType scopeCycleValidationType();
+
   abstract boolean warnIfInjectionFactoryNotGeneratedUpstream();
+
   abstract boolean headerCompilation();
 
   static Builder builder() {
@@ -70,37 +77,48 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, DaggerElement
         .usesProducers(elements.getTypeElement(Produces.class) != null)
         .headerCompilation(processingEnv.getOptions().containsKey(HEADER_COMPILATION))
         .experimentalAndroidMode(
-            experimentalAndroidMode(processingEnv).equals(FeatureStatus.ENABLED))
+            experimentalAndroidModeFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
         .writeProducerNameInToken(
-            writeProducerNameInToken(processingEnv).equals(FeatureStatus.ENABLED))
+            writeProducerNameInTokenFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
         .nullableValidationKind(nullableValidationType(processingEnv).diagnosticKind().get())
         .privateMemberValidationKind(
             privateMemberValidationType(processingEnv).diagnosticKind().get())
         .staticMemberValidationKind(
             staticMemberValidationType(processingEnv).diagnosticKind().get())
         .ignorePrivateAndStaticInjectionForComponent(
-            ignorePrivateAndStaticInjectionForComponent(processingEnv)
+            ignorePrivateAndStaticInjectionForComponentFeatureStatus(processingEnv)
                 .equals(FeatureStatus.DISABLED))
         .scopeCycleValidationType(scopeValidationType(processingEnv))
         .warnIfInjectionFactoryNotGeneratedUpstream(
-            warnIfInjectionFactoryNotGeneratedUpstream(processingEnv).equals(FeatureStatus.ENABLED))
+            warnIfInjectionFactoryNotGeneratedUpstreamFeatureStatus(processingEnv)
+                .equals(FeatureStatus.ENABLED))
         .build();
   }
 
   @AutoValue.Builder
   interface Builder {
     Builder usesProducers(boolean usesProduces);
+
     Builder headerCompilation(boolean headerCompilation);
+
     Builder experimentalAndroidMode(boolean experimentalAndroidMode);
+
     Builder writeProducerNameInToken(boolean writeProducerNameInToken);
+
     Builder nullableValidationKind(Diagnostic.Kind kind);
+
     Builder privateMemberValidationKind(Diagnostic.Kind kind);
+
     Builder staticMemberValidationKind(Diagnostic.Kind kind);
+
     Builder ignorePrivateAndStaticInjectionForComponent(
         boolean ignorePrivateAndStaticInjectionForComponent);
+
     Builder scopeCycleValidationType(ValidationType type);
+
     Builder warnIfInjectionFactoryNotGeneratedUpstream(
         boolean warnIfInjectionFactoryNotGeneratedUpstream);
+
     CompilerOptions build();
   }
 
@@ -123,8 +141,8 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
       "dagger.warnIfInjectionFactoryNotGeneratedUpstream";
 
   /**
-   * If true, Dagger will generate factories and components even if some members-injected types
-   * have private or static {@code @Inject}-annotated members.
+   * If true, Dagger will generate factories and components even if some members-injected types have
+   * private or static {@code @Inject}-annotated members.
    *
    * <p>This defaults to false, and should only ever be enabled by the TCK tests. Disabling this
    * validation could lead to generating code that does not compile.
@@ -144,7 +162,8 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
           WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
           IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT);
 
-  private static FeatureStatus experimentalAndroidMode(ProcessingEnvironment processingEnv) {
+  private static FeatureStatus experimentalAndroidModeFeatureStatus(
+      ProcessingEnvironment processingEnv) {
     return valueOf(
         processingEnv,
         EXPERIMENTAL_ANDROID_MODE,
@@ -152,7 +171,8 @@ private static FeatureStatus experimentalAndroidMode(ProcessingEnvironment proce
         EnumSet.allOf(FeatureStatus.class));
   }
 
-  private static FeatureStatus writeProducerNameInToken(ProcessingEnvironment processingEnv) {
+  private static FeatureStatus writeProducerNameInTokenFeatureStatus(
+      ProcessingEnvironment processingEnv) {
     return valueOf(
         processingEnv,
         WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
@@ -192,7 +212,7 @@ private static ValidationType staticMemberValidationType(ProcessingEnvironment p
         EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
   }
 
-  private static FeatureStatus ignorePrivateAndStaticInjectionForComponent(
+  private static FeatureStatus ignorePrivateAndStaticInjectionForComponentFeatureStatus(
       ProcessingEnvironment processingEnv) {
     return valueOf(
         processingEnv,
@@ -201,7 +221,7 @@ private static FeatureStatus ignorePrivateAndStaticInjectionForComponent(
         EnumSet.allOf(FeatureStatus.class));
   }
 
-  private static FeatureStatus warnIfInjectionFactoryNotGeneratedUpstream(
+  private static FeatureStatus warnIfInjectionFactoryNotGeneratedUpstreamFeatureStatus(
       ProcessingEnvironment processingEnv) {
     return valueOf(
         processingEnv,
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index a164dd644..234b8c412 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -233,12 +233,8 @@ private BindingExpression getBindingExpression(Key key, RequestKind requestKind)
       }
       return expressions.get(key, requestKind);
     }
-    return parent
-        .map(p -> p.getBindingExpression(key, requestKind))
-        .orElseThrow(
-            () ->
-                new IllegalStateException(
-                    String.format("no expression found for %s-%s", key, requestKind)));
+    checkArgument(parent.isPresent(), "no expression found for %s-%s", key, requestKind);
+    return parent.get().getBindingExpression(key, requestKind);
   }
 
   /** Creates a binding expression. */
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index 7df8a4d80..dbeea6565 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -64,7 +64,7 @@
       BindingGraph graph) {
     GeneratedComponentModel generatedComponentModel = GeneratedComponentModel.forComponent(name);
     SubcomponentNames subcomponentNames = new SubcomponentNames(graph, keyFactory);
-    OptionalFactories optionalFactories = new OptionalFactories();
+    OptionalFactories optionalFactories = new OptionalFactories(generatedComponentModel);
     Optional<ComponentBuilder> builder =
         ComponentBuilder.create(name, graph, subcomponentNames, elements, types);
     ComponentRequirementFields componentRequirementFields =
@@ -170,9 +170,6 @@ private ComponentWriter(
     addSubcomponents();
     addConstructor();
 
-    if (graph.componentDescriptor().kind().isTopLevel()) {
-      optionalFactories.addMembers(generatedComponentModel);
-    }
     done = true;
     return generatedComponentModel.generate();
   }
diff --git a/java/dagger/internal/codegen/DaggerKythePlugin.java b/java/dagger/internal/codegen/DaggerKythePlugin.java
index d479cfd03..eedd909f1 100644
--- a/java/dagger/internal/codegen/DaggerKythePlugin.java
+++ b/java/dagger/internal/codegen/DaggerKythePlugin.java
@@ -20,9 +20,9 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.collect.ImmutableSet.toImmutableSet;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.devtools.kythe.analyzers.base.EdgeKind.DEFINES_BINDING;
+import static com.google.devtools.kythe.analyzers.base.EdgeKind.PARAM;
 import static com.google.devtools.kythe.analyzers.base.EdgeKind.REF;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
@@ -36,18 +36,18 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.service.AutoService;
-import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableList;
 import com.google.devtools.kythe.analyzers.base.CorpusPath;
-import com.google.devtools.kythe.analyzers.base.EdgeKind;
 import com.google.devtools.kythe.analyzers.base.EntrySet;
 import com.google.devtools.kythe.analyzers.base.FactEmitter;
 import com.google.devtools.kythe.analyzers.base.KytheEntrySets;
+import com.google.devtools.kythe.analyzers.base.KytheEntrySets.NodeBuilder;
+import com.google.devtools.kythe.analyzers.base.NodeKind;
 import com.google.devtools.kythe.analyzers.java.Plugin;
 import com.google.devtools.kythe.proto.Storage.VName;
 import com.google.devtools.kythe.util.Span;
 import com.sun.source.tree.Tree;
 import com.sun.tools.javac.api.JavacTrees;
-import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.model.JavacElements;
 import com.sun.tools.javac.model.JavacTypes;
 import com.sun.tools.javac.tree.JCTree;
@@ -62,6 +62,7 @@
 import dagger.MembersInjector;
 import dagger.Provides;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.multibindings.Multibinds;
@@ -96,6 +97,7 @@
   @Inject BindingFactory bindingFactory;
   @Inject DelegateDeclaration.Factory delegateDeclarationFactory;
   @Inject MultibindingDeclaration.Factory multibindingDeclarationFactory;
+  @Inject OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory;
   @Inject SubcomponentDeclaration.Factory subcomponentDeclarationFactory;
   @Inject KeyFactory keyFactory;
   @Inject DaggerTypes types;
@@ -159,12 +161,8 @@ public Void visitMethodDef(JCMethodDecl tree, Void p) {
         addBindingDeclarationEdge(
             multibindingDeclarationFactory.forMultibindsMethod(element, enclosingType));
       } else if (isAnnotationPresent(element, BindsOptionalOf.class)) {
-        Key key = keyFactory.forBindsOptionalOfMethod(element, enclosingType);
-        for (Class<?> optionalClass : optionalClasses()) {
-          Key wrappedOptionalKey =
-              key.toBuilder().type(types.wrapType(key.type(), optionalClass)).build();
-          addBindingDeclarationEdge(wrappedOptionalKey, element);
-        }
+        addOptionalBindingDeclarationEdge(
+            optionalBindingDeclarationFactory.forMethod(element, enclosingType));
       } else if (isAnnotationPresent(element, BindsInstance.class)) {
         VariableElement parameter = getOnlyElement(element.getParameters());
         Key key = Key.builder(parameter.asType()).qualifier(getQualifier(parameter)).build();
@@ -179,6 +177,14 @@ private void addNodesForGraph(BindingGraph graph) {
         graph.componentDescriptor().componentMethods()) {
       componentMethod.dependencyRequest().ifPresent(this::addDependencyEdge);
     }
+
+    graph
+        .contributionBindings()
+        .values()
+        .stream()
+        .flatMap(resolvedBindings -> resolvedBindings.contributionBindings().stream())
+        .filter(binding -> binding.kind().equals(BindingKind.OPTIONAL))
+        .forEach(this::addOptionalBindingJoinsEdge);
   }
 
   private void addBindingAndDependencyEdges(Binding binding) {
@@ -191,16 +197,13 @@ private void addBindingDeclarationEdge(BindingDeclaration declaration) {
   }
 
   /**
-   * Adds a {@code defines/binding} edge between {@code bindingElement} and the node for {@code
-   * key}.
+   * Adds a {@code defines/binding} edge from {@code bindingElement} to the node for {@code key}.
    */
   private void addBindingDeclarationEdge(Key key, Element bindingElement) {
     if (hasTypeVariable(key.type())) {
       return;
     }
-    EntrySet bindingAnchor =
-        entrySets.newAnchorAndEmit(fileVName, bindingElementSpan(bindingElement), null);
-
+    EntrySet bindingAnchor = anchor(bindingElementSpan(bindingElement));
     entrySets.emitEdge(bindingAnchor, DEFINES_BINDING, keyNode(key));
   }
 
@@ -213,16 +216,15 @@ private Span bindingElementSpan(Element bindingElement) {
   }
 
   /**
-   * Adds a {@code ref} edge between {@code dependencyRequest} and it's {@link
-   * DependencyRequest#key() key's} node.
+   * Adds a {@code ref} edge from {@code dependencyRequest} to its {@link DependencyRequest#key()
+   * key's} node.
    */
   private void addDependencyEdge(DependencyRequest dependencyRequest) {
     if (!dependencyRequest.requestElement().isPresent()
         || hasTypeVariable(dependencyRequest.key().type())) {
       return;
     }
-    EntrySet dependencyRequestAnchor =
-        entrySets.newAnchorAndEmit(fileVName, dependencyRequestSpan(dependencyRequest), null);
+    EntrySet dependencyRequestAnchor = anchor(dependencyRequestSpan(dependencyRequest));
     entrySets.emitEdge(dependencyRequestAnchor, REF, keyNode(dependencyRequest.key()));
   }
 
@@ -231,57 +233,108 @@ private Span dependencyRequestSpan(DependencyRequest dependency) {
     return span(requestElement.getSimpleName(), trees.getTree(requestElement));
   }
 
+  /**
+   * Adds a {@code defines/binding} edge from {@code declaration}'s {@link
+   * OptionalBindingDeclaration#bindingElement()} to {@link #bindsOptionalOfKeyNode(Key)}. When a
+   * binding is resolved to {@code declaration}, a {@code /dagger/joins} edge will be added from the
+   * binding's key to the {@link #bindsOptionalOfKeyNode(Key)}. Kythe's post-processing will "merge"
+   * the {@code /dagger/joins} edge so that tools see edges from the {@code @BindsOptionalOf} method
+   * directly to the dependency requests that are resolved by this declaration and the bindings (if
+   * any) that satisfy it.
+   *
+   * <p>This process is used because {@code @BindsOptionalOf} methods may bind several binding keys,
+   * some of which may reference optional types (like {@link com.google.common.base.Optional}) that
+   * are not present in the current compilation, but will be when a component is resolved.
+   */
+  private void addOptionalBindingDeclarationEdge(OptionalBindingDeclaration declaration) {
+    EntrySet declarationAnchor = anchor(bindingElementSpan(declaration.bindingElement().get()));
+    entrySets.emitEdge(
+        declarationAnchor, DEFINES_BINDING, bindsOptionalOfKeyNode(declaration.key()));
+  }
+
+  /**
+   * Adds a {@code /dagger/joins} edge from {@code binding}'s key to the synthetic
+   * {@code @BindsOptionalOf} node created in {@link
+   * #addOptionalBindingDeclarationEdge(OptionalBindingDeclaration)}.
+   */
+  private void addOptionalBindingJoinsEdge(ContributionBinding binding) {
+    emitDaggerJoinsEdge(
+        keyNode(binding.key()),
+        bindsOptionalOfKeyNode(keyFactory.unwrapOptional(binding.key()).get()));
+  }
+
+  /** A synthetic node for a {@link BindsOptionalOf} method. */
+  private EntrySet bindsOptionalOfKeyNode(Key key) {
+    EntrySet node = newInjectNode("key", String.format("@BindsOptionalOf %s", formatKey(key)));
+    entrySets.emitEdge(node, PARAM, bindsOptionalOfTypeApplication(key), 0);
+    addEdgeFromKeyToQualifier(node, key);
+    return node;
+  }
+
+  private EntrySet bindsOptionalOfTypeApplication(Key optionalBindingDeclarationKey) {
+    EntrySet genericBindsOptionalOfNode = newNode(NodeKind.ABS, "abs for @BindsOptionalOf");
+    EntrySet bindsOptionalOfTypeVariable = newNode(NodeKind.ABS_VAR, "absvar for @BindsOptionalOf");
+    entrySets.emitEdge(genericBindsOptionalOfNode, PARAM, bindsOptionalOfTypeVariable, 0);
+
+    return entrySets.newTApplyAndEmit(
+        genericBindsOptionalOfNode.getVName(),
+        hasTypeVariable(optionalBindingDeclarationKey.type())
+            ? ImmutableList.of() /* // TODO(ronshapiro): should this have a /dagger/joins edge?
+             Or should it reuse bindsOptionalOfTypeVariable?*/
+            : ImmutableList.of(keys.vname(optionalBindingDeclarationKey)));
+  }
+
   private Span span(Name name, JCTree tree) {
     return kytheGraph.findIdentifier(name, tree.getPreferredPosition()).get();
   }
 
   private EntrySet keyNode(Key key) {
-    EntrySet keyNode = newNode("key", formatKey(key));
+    EntrySet keyNode = newInjectNode("key", formatKey(key));
 
-    entrySets.emitEdge(keyNode.getVName(), EdgeKind.PARAM, keys.vname(key), 0);
-    key.qualifier()
-        .ifPresent(
-            qualifier -> {
-              entrySets.emitEdge(
-                  keyNode.getVName(), EdgeKind.PARAM, qualifierNode(qualifier).getVName(), 1);
-            });
+    entrySets.emitEdge(keyNode.getVName(), PARAM, keys.vname(key), 0);
+    addEdgeFromKeyToQualifier(keyNode, key);
 
     return keyNode;
   }
 
-  private EntrySet qualifierNode(AnnotationMirror qualifier) {
-    return newNode("qualifier", formatAnnotation(qualifier));
+  private void addEdgeFromKeyToQualifier(EntrySet source, Key key) {
+    key.qualifier()
+        .map(qualifier -> newInjectNode("qualifier", formatAnnotation(qualifier)))
+        .ifPresent(qualifier -> entrySets.emitEdge(source, PARAM, qualifier, 1));
   }
 
-  private EntrySet newNode(String nodeKind, String format) {
-    EntrySet node = entrySets
-        .newNode("inject/" + nodeKind)
-        .setCorpusPath(corpusPath)
-        .setSignature(String.format("inject_%s:%s", nodeKind, format))
-        .build();
-    node.emit(emitter);
-    return node;
+  /** Adds a new node in the {@code inject/} namespace. */
+  private EntrySet newInjectNode(String nodeKind, String format) {
+    return completeNodeAndEmit(
+        entrySets
+            .newNode("inject/" + nodeKind)
+            .setSignature(String.format("inject_%s:%s", nodeKind, format)));
   }
 
-  private ImmutableSet<Class<?>> optionalClasses() {
-    // TODO(user): Can the plugin infrastructure be modified to guarantee certain types are
-    // always available to plugins via kytheGraph.getNode() even if they haven't been scanned yet?
-    return ImmutableSet.of(java.util.Optional.class, com.google.common.base.Optional.class)
-        .stream()
-        .filter(this::isClassAvailable)
-        .collect(toImmutableSet());
+  private EntrySet newNode(NodeKind nodeKind, String signature) {
+    return completeNodeAndEmit(entrySets.newNode(nodeKind).setSignature(signature));
   }
 
-  private boolean isClassAvailable(Class<?> clazz) {
-    return kytheGraph
-        .getNode((Symbol) elements.getTypeElement(clazz.getCanonicalName()))
-        .isPresent();
+  private EntrySet completeNodeAndEmit(NodeBuilder nodeBuilder) {
+    EntrySet node = nodeBuilder.setCorpusPath(corpusPath).build();
+    node.emit(emitter);
+    return node;
+  }
+
+  private EntrySet anchor(Span location) {
+    return entrySets.newAnchorAndEmit(fileVName, location, null);
   }
 
   private Element getElement(Tree tree) {
     return trees.getElement(trees.getPath(compilationUnit, tree));
   }
 
+  private void emitDaggerJoinsEdge(EntrySet source, EntrySet target) {
+    new EntrySet.Builder(source.getVName(), "/dagger/joins", target.getVName())
+        .build()
+        .emit(emitter);
+  }
+
   @Override
   public void run(
       JCCompilationUnit compilationUnit, KytheEntrySets entrySets, KytheGraph kytheGraph) {
diff --git a/java/dagger/internal/codegen/FactoryGenerator.java b/java/dagger/internal/codegen/FactoryGenerator.java
index d08e2fad5..de5a8a7c0 100644
--- a/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/java/dagger/internal/codegen/FactoryGenerator.java
@@ -28,7 +28,6 @@
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
-import static dagger.internal.codegen.MapKeys.mapKeyFactoryMethod;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkFieldUsages;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
@@ -119,7 +118,6 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
     ProvisionMethod.create(binding, compilerOptions).ifPresent(factoryBuilder::addMethod);
     gwtIncompatibleAnnotation(binding).ifPresent(factoryBuilder::addAnnotation);
-    mapKeyFactoryMethod(binding, types).ifPresent(factoryBuilder::addMethod);
 
     return factoryBuilder;
   }
diff --git a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
new file mode 100644
index 000000000..b8c255bcd
--- /dev/null
+++ b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
+import java.util.Optional;
+import javax.annotation.processing.Filer;
+import javax.inject.Inject;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+
+/**
+ * Generates a class that exposes a non-{@code public} {@link ContributionBinding#mapKey()} @MapKey}
+ * annotation.
+ */
+final class InaccessibleMapKeyProxyGenerator extends SourceFileGenerator<ContributionBinding> {
+  private final DaggerTypes types;
+
+  @Inject
+  InaccessibleMapKeyProxyGenerator(
+      Filer filer, DaggerTypes types, DaggerElements elements, SourceVersion sourceVersion) {
+    super(filer, elements, sourceVersion);
+    this.types = types;
+  }
+
+  @Override
+  ClassName nameGeneratedType(ContributionBinding binding) {
+    return MapKeys.mapKeyProxyClassName(binding);
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(ContributionBinding binding) {
+    return binding.bindingElement();
+  }
+
+  @Override
+  Optional<TypeSpec.Builder> write(ClassName generatedName, ContributionBinding binding) {
+    return MapKeys.mapKeyFactoryMethod(binding, types)
+        .map(
+            method ->
+                classBuilder(generatedName)
+                    .addModifiers(PUBLIC, FINAL)
+                    .addMethod(constructorBuilder().addModifiers(PRIVATE).build())
+                    .addMethod(method));
+  }
+}
diff --git a/java/dagger/internal/codegen/KeyVNameFactory.java b/java/dagger/internal/codegen/KeyVNameFactory.java
index e22c7a14a..9849b0a69 100644
--- a/java/dagger/internal/codegen/KeyVNameFactory.java
+++ b/java/dagger/internal/codegen/KeyVNameFactory.java
@@ -84,7 +84,11 @@ public VName visitDeclared(DeclaredType declaredType, Key key) {
       // the *type*? Also, this seems to return null for all boxed primitive types if boxed
       // primitive is not mentioned in the compilation (i.e. if you @Provides int and then request
       // int from a binding, but never java.lang.Integer) - we have to synthesize those
-      VName rawType = kytheGraph.getNode(classSymbol).get().getVName();
+      VName rawType =
+          kytheGraph
+              .getNode(classSymbol)
+              .orElseThrow(() -> new TypeNotPresentException(classSymbol.toString(), null))
+              .getVName();
       if (classSymbol.getTypeParameters().isEmpty()) {
         return rawType;
       }
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index 7521b4428..8a1f70360 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -22,6 +22,7 @@
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
@@ -98,8 +99,9 @@ Expression getDependencyExpression(ClassName requestingClass) {
         instantiation
             .add("$T.", isImmutableMapAvailable ? ImmutableMap.class : MapBuilder.class)
             .add(maybeTypeParameters(requestingClass));
-        if (isImmutableMapAvailable) {
-          // TODO(ronshapiro): builderWithExpectedSize
+        if (isImmutableMapBuilderWithExpectedSizeAvailable()) {
+          instantiation.add("builderWithExpectedSize($L)", dependencies.size());
+        } else if (isImmutableMapAvailable) {
           instantiation.add("builder()");
         } else {
           instantiation.add("newMapBuilder($L)", dependencies.size());
@@ -147,6 +149,15 @@ private CodeBlock maybeTypeParameters(ClassName requestingClass) {
         : CodeBlock.of("");
   }
 
+  private boolean isImmutableMapBuilderWithExpectedSizeAvailable() {
+    if (isImmutableMapAvailable()) {
+      return methodsIn(elements.getTypeElement(ImmutableMap.class).getEnclosedElements())
+          .stream()
+          .anyMatch(method -> method.getSimpleName().contentEquals("builderWithExpectedSize"));
+    }
+    return false;
+  }
+
   private boolean isImmutableMapAvailable() {
     return elements.getTypeElement(ImmutableMap.class) != null;
   }
diff --git a/java/dagger/internal/codegen/MapKeys.java b/java/dagger/internal/codegen/MapKeys.java
index ad7e5e62a..d0a80e05c 100644
--- a/java/dagger/internal/codegen/MapKeys.java
+++ b/java/dagger/internal/codegen/MapKeys.java
@@ -22,11 +22,12 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.MapKeyAccessibility.isMapKeyPubliclyAccessible;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.elementBasedClassName;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
@@ -149,7 +150,7 @@ static CodeBlock getMapKeyExpression(ContributionBinding binding, ClassName requ
     return MapKeyAccessibility.isMapKeyAccessibleFrom(
             mapKeyAnnotation, requestingClass.packageName())
         ? directMapKeyExpression(mapKeyAnnotation)
-        : CodeBlock.of("$T.mapKey()", generatedClassNameForBinding(binding));
+        : CodeBlock.of("$T.create()", mapKeyProxyClassName(binding));
   }
 
   /**
@@ -177,8 +178,18 @@ private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
   }
 
   /**
-   * A {@code static mapKey()} method to be added to generated factories when the {@code @MapKey}
-   * annotation is not publicly accessible.
+   * Returns the {@link ClassName} in which {@link #mapKeyFactoryMethod(ContributionBinding, Types)}
+   * is generated.
+   */
+  static ClassName mapKeyProxyClassName(ContributionBinding binding) {
+    return elementBasedClassName(
+        MoreElements.asExecutable(binding.bindingElement().get()), "MapKey");
+  }
+
+  /**
+   * A {@code static create()} method to be added to {@link
+   * #mapKeyProxyClassName(ContributionBinding)} when the {@code @MapKey} annotation is not publicly
+   * accessible.
    */
   static Optional<MethodSpec> mapKeyFactoryMethod(ContributionBinding binding, Types types) {
     return binding
@@ -186,7 +197,7 @@ private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
         .filter(mapKey -> !isMapKeyPubliclyAccessible(mapKey))
         .map(
             mapKey ->
-                methodBuilder("mapKey")
+                methodBuilder("create")
                     .addModifiers(PUBLIC, STATIC)
                     .returns(TypeName.get(mapKeyType(mapKey, types)))
                     .addStatement("return $L", directMapKeyExpression(mapKey))
diff --git a/java/dagger/internal/codegen/ModuleProcessingStep.java b/java/dagger/internal/codegen/ModuleProcessingStep.java
index b67a399b2..5e6609bfe 100644
--- a/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -24,8 +24,10 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
+import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.DelegateDeclaration.Factory;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
@@ -47,6 +49,8 @@
   private final BindingFactory bindingFactory;
   private final FactoryGenerator factoryGenerator;
   private final ProducerFactoryGenerator producerFactoryGenerator;
+  private final InaccessibleMapKeyProxyGenerator inaccessibleMapKeyProxyGenerator;
+  private final DelegateDeclaration.Factory delegateDeclarationFactory;
   private final Set<TypeElement> processedModuleElements = Sets.newLinkedHashSet();
 
   @Inject
@@ -55,12 +59,16 @@
       ModuleValidator moduleValidator,
       BindingFactory bindingFactory,
       FactoryGenerator factoryGenerator,
-      ProducerFactoryGenerator producerFactoryGenerator) {
+      ProducerFactoryGenerator producerFactoryGenerator,
+      InaccessibleMapKeyProxyGenerator inaccessibleMapKeyProxyGenerator,
+      Factory delegateDeclarationFactory) {
     this.messager = messager;
     this.moduleValidator = moduleValidator;
     this.bindingFactory = bindingFactory;
     this.factoryGenerator = factoryGenerator;
     this.producerFactoryGenerator = producerFactoryGenerator;
+    this.inaccessibleMapKeyProxyGenerator = inaccessibleMapKeyProxyGenerator;
+    this.delegateDeclarationFactory = delegateDeclarationFactory;
   }
 
   @Override
@@ -87,12 +95,24 @@ private void processModule(TypeElement module) {
     if (report.isClean()) {
       for (ExecutableElement method : methodsIn(module.getEnclosedElements())) {
         if (isAnnotationPresent(method, Provides.class)) {
-          factoryGenerator.generate(bindingFactory.providesMethodBinding(method, module), messager);
+          generate(factoryGenerator, bindingFactory.providesMethodBinding(method, module));
         } else if (isAnnotationPresent(method, Produces.class)) {
-          producerFactoryGenerator.generate(
-              bindingFactory.producesMethodBinding(method, module), messager);
+          generate(producerFactoryGenerator, bindingFactory.producesMethodBinding(method, module));
+        } else if (isAnnotationPresent(method, Binds.class)) {
+          inaccessibleMapKeyProxyGenerator.generate(bindsMethodBinding(module, method), messager);
         }
       }
     }
   }
+
+  private <B extends ContributionBinding> void generate(
+      SourceFileGenerator<B> generator, B binding) {
+    generator.generate(binding, messager);
+    inaccessibleMapKeyProxyGenerator.generate(binding, messager);
+  }
+
+  private ContributionBinding bindsMethodBinding(TypeElement module, ExecutableElement method) {
+    return bindingFactory.unresolvedDelegateBinding(
+        delegateDeclarationFactory.create(method, module));
+  }
 }
diff --git a/java/dagger/internal/codegen/OptionalFactories.java b/java/dagger/internal/codegen/OptionalFactories.java
index 498ec3594..3297823d0 100644
--- a/java/dagger/internal/codegen/OptionalFactories.java
+++ b/java/dagger/internal/codegen/OptionalFactories.java
@@ -67,6 +67,11 @@
 /** The nested class and static methods required by the component to implement optional bindings. */
 // TODO(dpb): Name members simply if a component uses only one of Guava or JDK Optional.
 final class OptionalFactories {
+  private final GeneratedComponentModel generatedComponentModel;
+
+  OptionalFactories(GeneratedComponentModel generatedComponentModel) {
+    this.generatedComponentModel = generatedComponentModel;
+  }
 
   /**
    * The factory classes that implement {@code Provider<Optional<T>>} or {@code
@@ -105,7 +110,12 @@ CodeBlock absentOptionalProvider(ContributionBinding binding) {
     return CodeBlock.of(
         "$N()",
         absentOptionalProviderMethods.computeIfAbsent(
-            optionalKind, this::absentOptionalProviderMethod));
+            optionalKind,
+            kind -> {
+              MethodSpec method = absentOptionalProviderMethod(kind);
+              generatedComponentModel.addMethod(ABSENT_OPTIONAL_METHOD, method);
+              return method;
+            }));
   }
 
   /**
@@ -129,7 +139,12 @@ private MethodSpec absentOptionalProviderMethod(OptionalKind optionalKind) {
             "$1T provider = ($1T) $2N;",
             providerOf(optionalKind.of(typeVariable)),
             absentOptionalProviderFields.computeIfAbsent(
-                optionalKind, this::absentOptionalProviderField))
+                optionalKind,
+                kind -> {
+                  FieldSpec field = absentOptionalProviderField(kind);
+                  generatedComponentModel.addField(ABSENT_OPTIONAL_FIELD, field);
+                  return field;
+                }))
         .addCode("return provider;")
         .build();
   }
@@ -235,7 +250,12 @@ CodeBlock presentOptionalFactory(ContributionBinding binding, CodeBlock delegate
     return CodeBlock.of(
         "$N.of($L)",
         presentFactoryClasses.computeIfAbsent(
-            PresentFactorySpec.of(binding), this::presentOptionalFactoryClass),
+            PresentFactorySpec.of(binding),
+            spec -> {
+              TypeSpec type = presentOptionalFactoryClass(spec);
+              generatedComponentModel.addType(PRESENT_FACTORY, type);
+              return type;
+            }),
         delegateFactory);
   }
 
@@ -243,20 +263,55 @@ private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
     FieldSpec delegateField =
         FieldSpec.builder(spec.delegateType(), "delegate", PRIVATE, FINAL).build();
     ParameterSpec delegateParameter = ParameterSpec.builder(delegateField.type, "delegate").build();
+    return classBuilder(spec.factoryClassName())
+        .addTypeVariable(spec.typeVariable())
+        .addModifiers(PRIVATE, STATIC, FINAL)
+        .addSuperinterface(spec.factoryType())
+        .addJavadoc(
+            "A {@code $T} that uses a delegate {@code $T}.", spec.factoryType(), delegateField.type)
+        .addField(delegateField)
+        .addMethod(
+            constructorBuilder()
+                .addModifiers(PRIVATE)
+                .addParameter(delegateParameter)
+                .addCode(
+                    "this.$N = $T.checkNotNull($N);",
+                    delegateField,
+                    Preconditions.class,
+                    delegateParameter)
+                .build())
+        .addMethod(presentOptionalFactoryGetMethod(spec, delegateField))
+        .addMethod(
+            methodBuilder("of")
+                .addModifiers(PRIVATE, STATIC)
+                .addTypeVariable(spec.typeVariable())
+                .returns(spec.factoryType())
+                .addParameter(delegateParameter)
+                .addCode(
+                    "return new $L<$T>($N);",
+                    spec.factoryClassName(),
+                    spec.typeVariable(),
+                    delegateParameter)
+                .build())
+        .build();
+  }
 
+  private MethodSpec presentOptionalFactoryGetMethod(
+      PresentFactorySpec spec, FieldSpec delegateField) {
     MethodSpec.Builder getMethodBuilder =
         methodBuilder("get").addAnnotation(Override.class).addModifiers(PUBLIC);
+
     switch (spec.bindingType()) {
       case PROVISION:
-        getMethodBuilder
+        return getMethodBuilder
             .returns(spec.optionalType())
             .addCode(
                 "return $L;",
                 spec.optionalKind()
                     .presentExpression(
                         FrameworkType.PROVIDER.to(
-                            spec.valueKind(), CodeBlock.of("$N", delegateField))));
-        break;
+                            spec.valueKind(), CodeBlock.of("$N", delegateField))))
+            .build();
 
       case PRODUCTION:
         getMethodBuilder.returns(listenableFutureOf(spec.optionalType()));
@@ -264,75 +319,45 @@ private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
         switch (spec.valueKind()) {
           case FUTURE: // return a ListenableFuture<Optional<ListenableFuture<T>>>
           case PRODUCER: // return a ListenableFuture<Optional<Producer<T>>>
-            getMethodBuilder.addCode(
-                "return $T.immediateFuture($L);",
-                Futures.class,
-                spec.optionalKind()
-                    .presentExpression(
-                        FrameworkType.PRODUCER.to(
-                            spec.valueKind(), CodeBlock.of("$N", delegateField))));
-            break;
+            return getMethodBuilder
+                .addCode(
+                    "return $T.immediateFuture($L);",
+                    Futures.class,
+                    spec.optionalKind()
+                        .presentExpression(
+                            FrameworkType.PRODUCER.to(
+                                spec.valueKind(), CodeBlock.of("$N", delegateField))))
+                .build();
 
           case INSTANCE: // return a ListenableFuture<Optional<T>>
-            getMethodBuilder.addCode(
-                "return $L;",
-                transformFutureToOptional(
-                    spec.optionalKind(),
-                    spec.typeVariable(),
-                    CodeBlock.of("$N.get()", delegateField)));
-            break;
+            return getMethodBuilder
+                .addCode(
+                    "return $L;",
+                    transformFutureToOptional(
+                        spec.optionalKind(),
+                        spec.typeVariable(),
+                        CodeBlock.of("$N.get()", delegateField)))
+                .build();
 
           case PRODUCED: // return a ListenableFuture<Optional<Produced<T>>>
-            getMethodBuilder.addCode(
-                "return $L;",
-                transformFutureToOptional(
-                    spec.optionalKind(),
-                    spec.valueType(),
-                    CodeBlock.of(
-                        "$T.createFutureProduced($N.get())", Producers.class, delegateField)));
-            break;
+            return getMethodBuilder
+                .addCode(
+                    "return $L;",
+                    transformFutureToOptional(
+                        spec.optionalKind(),
+                        spec.valueType(),
+                        CodeBlock.of(
+                            "$T.createFutureProduced($N.get())", Producers.class, delegateField)))
+                .build();
 
           default:
             throw new UnsupportedOperationException(
                 spec.factoryType() + " objects are not supported");
         }
-        break;
 
       default:
         throw new AssertionError(spec.bindingType());
     }
-
-    return classBuilder(spec.factoryClassName())
-        .addTypeVariable(spec.typeVariable())
-        .addModifiers(PRIVATE, STATIC, FINAL)
-        .addSuperinterface(spec.factoryType())
-        .addJavadoc(
-            "A {@code $T} that uses a delegate {@code $T}.", spec.factoryType(), delegateField.type)
-        .addField(delegateField)
-        .addMethod(
-            constructorBuilder()
-                .addModifiers(PRIVATE)
-                .addParameter(delegateParameter)
-                .addCode(
-                    "this.$N = $T.checkNotNull($N);",
-                    delegateField,
-                    Preconditions.class,
-                    delegateParameter)
-                .build())
-        .addMethod(getMethodBuilder.build())
-        .addMethod(
-            methodBuilder("of")
-                .addModifiers(PRIVATE, STATIC)
-                .addTypeVariable(spec.typeVariable())
-                .returns(spec.factoryType())
-                .addParameter(delegateParameter)
-                .addCode(
-                    "return new $L<$T>($N);",
-                    spec.factoryClassName(),
-                    spec.typeVariable(),
-                    delegateParameter)
-                .build())
-        .build();
   }
 
   /**
@@ -363,16 +388,4 @@ private static CodeBlock transformFutureToOptional(
             .build(),
         MoreExecutors.class);
   }
-
-  /**
-   * Adds classes and methods required by previous calls to {@link
-   * #absentOptionalProvider(ContributionBinding)} and {@link
-   * #presentOptionalFactory(ContributionBinding, CodeBlock)} to the top-level {@code component}.
-   */
-  void addMembers(GeneratedComponentModel generatedComponentModel) {
-    generatedComponentModel.addTypes(PRESENT_FACTORY, presentFactoryClasses.values());
-    generatedComponentModel.addMethods(
-        ABSENT_OPTIONAL_METHOD, absentOptionalProviderMethods.values());
-    generatedComponentModel.addFields(ABSENT_OPTIONAL_FIELD, absentOptionalProviderFields.values());
-  }
 }
diff --git a/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 33c77bd71..6d292cfc5 100644
--- a/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -24,7 +24,6 @@
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
-import static dagger.internal.codegen.MapKeys.mapKeyFactoryMethod;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
@@ -71,13 +70,11 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * Generates {@link Producer} implementations from {@link ProductionBinding} instances.
  */
 final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
-  private final Types types;
   private final CompilerOptions compilerOptions;
 
   @Inject
@@ -85,10 +82,8 @@
       Filer filer,
       Elements elements,
       SourceVersion sourceVersion,
-      Types types,
       CompilerOptions compilerOptions) {
     super(filer, elements, sourceVersion);
-    this.types = types;
     this.compilerOptions = compilerOptions;
   }
 
@@ -231,7 +226,6 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     factoryBuilder.addMethod(executeMethodBuilder.build());
 
     gwtIncompatibleAnnotation(binding).ifPresent(factoryBuilder::addAnnotation);
-    mapKeyFactoryMethod(binding, types).ifPresent(factoryBuilder::addMethod);
 
     // TODO(gak): write a sensible toString
     return Optional.of(factoryBuilder);
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
index 860df769b..2409541c0 100644
--- a/java/dagger/internal/codegen/SetBindingExpression.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -19,6 +19,7 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
@@ -97,7 +98,9 @@ Expression getDependencyExpression(ClassName requestingClass) {
         instantiation
             .add("$T.", isImmutableSetAvailable ? ImmutableSet.class : SetBuilder.class)
             .add(maybeTypeParameter(requestingClass));
-        if (isImmutableSetAvailable) {
+        if (isImmutableSetBuilderWithExpectedSizeAvailable()) {
+          instantiation.add("builderWithExpectedSize($L)", binding.dependencies().size());
+        } else if (isImmutableSetAvailable) {
           instantiation.add("builder()");
         } else {
           instantiation.add("newSetBuilder($L)", binding.dependencies().size());
@@ -153,6 +156,15 @@ private boolean isSingleValue(DependencyRequest dependency) {
         .equals(ContributionType.SET);
   }
 
+  private boolean isImmutableSetBuilderWithExpectedSizeAvailable() {
+    if (isImmutableSetAvailable()) {
+      return methodsIn(elements.getTypeElement(ImmutableSet.class).getEnclosedElements())
+          .stream()
+          .anyMatch(method -> method.getSimpleName().contentEquals("builderWithExpectedSize"));
+    }
+    return false;
+  }
+
   private boolean isImmutableSetAvailable() {
     return elements.getTypeElement(ImmutableSet.class) != null;
   }
diff --git a/java/dagger/internal/codegen/SourceFiles.java b/java/dagger/internal/codegen/SourceFiles.java
index b36493f9d..b97fc764b 100644
--- a/java/dagger/internal/codegen/SourceFiles.java
+++ b/java/dagger/internal/codegen/SourceFiles.java
@@ -40,6 +40,7 @@
 import static java.util.Comparator.comparing;
 import static javax.lang.model.SourceVersion.isName;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
@@ -67,6 +68,8 @@
 import javax.inject.Provider;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 
@@ -184,19 +187,12 @@ static ClassName generatedClassNameForBinding(Binding binding) {
       case PROVISION:
       case PRODUCTION:
         ContributionBinding contribution = (ContributionBinding) binding;
-        checkArgument(contribution.bindingTypeElement().isPresent());
-        ClassName enclosingClassName = ClassName.get(contribution.bindingTypeElement().get());
         switch (contribution.kind()) {
           case INJECTION:
           case PROVISION:
           case PRODUCTION:
-            return enclosingClassName
-                .topLevelClassName()
-                .peerClass(
-                    classFileName(enclosingClassName)
-                        + "_"
-                        + factoryPrefix(contribution)
-                        + "Factory");
+            return elementBasedClassName(
+                MoreElements.asExecutable(binding.bindingElement().get()), "Factory");
 
           default:
             throw new AssertionError();
@@ -211,6 +207,25 @@ static ClassName generatedClassNameForBinding(Binding binding) {
     }
   }
 
+  /**
+   * Calculates an appropriate {@link ClassName} for a generated class that is based on {@code
+   * element}, appending {@code suffix} at the end.
+   *
+   * <p>This will always return a {@linkplain ClassName#topLevelClassName() top level class name},
+   * even if {@code element}'s enclosing class is a nested type.
+   */
+  static ClassName elementBasedClassName(ExecutableElement element, String suffix) {
+    ClassName enclosingClassName =
+        ClassName.get(MoreElements.asType(element.getEnclosingElement()));
+    String methodName =
+        element.getKind().equals(ElementKind.CONSTRUCTOR)
+            ? ""
+            : LOWER_CAMEL.to(UPPER_CAMEL, element.getSimpleName().toString());
+    return ClassName.get(
+        enclosingClassName.packageName(),
+        classFileName(enclosingClassName) + "_" + methodName + suffix);
+  }
+
   static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
     ClassName className = generatedClassNameForBinding(binding);
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
@@ -280,21 +295,6 @@ static ClassName mapFactoryClassName(ContributionBinding binding) {
     }
   }
 
-  private static String factoryPrefix(ContributionBinding binding) {
-    switch (binding.kind()) {
-      case INJECTION:
-        return "";
-
-      case PROVISION:
-      case PRODUCTION:
-        return CaseFormat.LOWER_CAMEL.to(
-            UPPER_CAMEL, binding.bindingElement().get().getSimpleName().toString());
-
-      default:
-        throw new IllegalArgumentException();
-    }
-  }
-
   static ImmutableList<TypeVariableName> bindingTypeElementTypeVariableNames(Binding binding) {
     if (binding instanceof ContributionBinding) {
       ContributionBinding contributionBinding = (ContributionBinding) binding;
diff --git a/java/dagger/internal/codegen/bootstrap_compiler_deploy.jar b/java/dagger/internal/codegen/bootstrap_compiler_deploy.jar
index 0485fa274..ad9761de4 100644
Binary files a/java/dagger/internal/codegen/bootstrap_compiler_deploy.jar and b/java/dagger/internal/codegen/bootstrap_compiler_deploy.jar differ
diff --git a/javatests/dagger/functional/multibindings/BindsInaccessibleMapKey.java b/javatests/dagger/functional/multibindings/BindsInaccessibleMapKey.java
new file mode 100644
index 000000000..6256812ea
--- /dev/null
+++ b/javatests/dagger/functional/multibindings/BindsInaccessibleMapKey.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multibindings;
+
+import dagger.Component;
+import dagger.functional.multibindings.subpackage.BindsInaccessibleMapKeyModule;
+import java.util.Map;
+
+// b/73820357
+@Component(modules = BindsInaccessibleMapKeyModule.class)
+interface BindsInaccessibleMapKey {
+  Map<Class<?>, Object> mapWithAnInaccessibleMapKey();
+}
diff --git a/javatests/dagger/functional/multibindings/subpackage/BindsInaccessibleMapKeyModule.java b/javatests/dagger/functional/multibindings/subpackage/BindsInaccessibleMapKeyModule.java
new file mode 100644
index 000000000..62df4ae4a
--- /dev/null
+++ b/javatests/dagger/functional/multibindings/subpackage/BindsInaccessibleMapKeyModule.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multibindings.subpackage;
+
+import dagger.Binds;
+import dagger.Module;
+import dagger.multibindings.ClassKey;
+import dagger.multibindings.IntoMap;
+import javax.inject.Inject;
+
+@Module
+public abstract class BindsInaccessibleMapKeyModule {
+  @Binds
+  @IntoMap
+  @ClassKey(Inaccessible.class)
+  abstract Object bindInaccessibleMapKey(Inaccessible inaccessible);
+
+  static class Inaccessible {
+    @Inject Inaccessible() {}
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index a66e594f5..d6968b427 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -330,13 +330,6 @@ public void mapBindingsWithInaccessibleKeys() {
                 "test.DaggerTestComponent",
                 "package test;",
                 "",
-                "import mapkeys.MapKeys;",
-                "import mapkeys.MapModule_ClassKeyFactory;",
-                "import mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory;",
-                "import mapkeys.MapModule_ComplexKeyWithInaccessibleArrayValueFactory;",
-                "import mapkeys.MapModule_ComplexKeyWithInaccessibleValueFactory;",
-                "import mapkeys.MapModule_EnumKeyFactory;",
-                "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private Provider<Map<Class<?>, Integer>> mapOfClassOfAndIntegerProvider;",
@@ -349,31 +342,31 @@ public void mapBindingsWithInaccessibleKeys() {
                 "",
                 "  private Map getMapOfPackagePrivateEnumAndInteger() {",
                 "    return ImmutableMap.of(",
-                "        MapModule_EnumKeyFactory.mapKey(), MapModule.enumKey());",
+                "        MapModule_EnumKeyMapKey.create(), MapModule.enumKey());",
                 "  }",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
                 "  private void initialize(final Builder builder) {",
                 "    this.mapOfClassOfAndIntegerProvider =",
                 "        MapFactory.<Class<?>, Integer>builder(1)",
-                "            .put(MapModule_ClassKeyFactory.mapKey(),",
+                "            .put(MapModule_ClassKeyMapKey.create(),",
                 "                 MapModule_ClassKeyFactory.create())",
                 "            .build();",
                 "    this.mapOfPackagePrivateEnumAndIntegerProvider =",
                 "        MapFactory.builder(1)",
-                "            .put(MapModule_EnumKeyFactory.mapKey(), ",
+                "            .put(MapModule_EnumKeyMapKey.create(), ",
                 "                 (Provider) MapModule_EnumKeyFactory.create())",
                 "            .build();",
                 "    this.mapOfComplexKeyAndIntegerProvider =",
                 "       MapFactory.<MapKeys.ComplexKey, Integer>builder(3)",
                 "          .put(",
-                "             MapModule_ComplexKeyWithInaccessibleValueFactory.mapKey(),",
+                "             MapModule_ComplexKeyWithInaccessibleValueMapKey.create(),",
                 "             MapModule_ComplexKeyWithInaccessibleValueFactory.create())",
                 "          .put(",
-                "             MapModule_ComplexKeyWithInaccessibleArrayValueFactory.mapKey(),",
+                "             MapModule_ComplexKeyWithInaccessibleArrayValueMapKey.create(),",
                 "             MapModule_ComplexKeyWithInaccessibleArrayValueFactory.create())",
                 "          .put(",
-                "             MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory.mapKey(),",
+                "             MapModule_ComplexKeyWithInaccessibleAnnotationValueMapKey.create(),",
                 "             MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory.create())",
                 "          .build();",
                 "  }",
@@ -381,7 +374,7 @@ public void mapBindingsWithInaccessibleKeys() {
                 "  @Override",
                 "  public Map<Class<?>, Integer> classKey() {",
                 "    return ImmutableMap.<Class<?>, Integer>of(",
-                "        MapModule_ClassKeyFactory.mapKey(), MapModule.classKey());",
+                "        MapModule_ClassKeyMapKey.create(), MapModule.classKey());",
                 "  }",
                 "",
                 "  @Override",
@@ -402,11 +395,11 @@ public void mapBindingsWithInaccessibleKeys() {
                 "  @Override",
                 "  public Map<MapKeys.ComplexKey, Integer> complexKey() {",
                 "    return ImmutableMap.<MapKeys.ComplexKey, Integer>of(",
-                "        MapModule_ComplexKeyWithInaccessibleValueFactory.mapKey(),",
+                "        MapModule_ComplexKeyWithInaccessibleValueMapKey.create(),",
                 "        MapModule.complexKeyWithInaccessibleValue(),",
-                "        MapModule_ComplexKeyWithInaccessibleArrayValueFactory.mapKey(),",
+                "        MapModule_ComplexKeyWithInaccessibleArrayValueMapKey.create(),",
                 "        MapModule.complexKeyWithInaccessibleArrayValue(),",
-                "        MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory.mapKey(),",
+                "        MapModule_ComplexKeyWithInaccessibleAnnotationValueMapKey.create(),",
                 "        MapModule.complexKeyWithInaccessibleAnnotationValue());",
                 "  }",
                 "",
@@ -417,23 +410,15 @@ public void mapBindingsWithInaccessibleKeys() {
                 "}"));
     assertThat(compilation)
         .generatedSourceFile(
-            "mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory")
+            "mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueMapKey")
         .containsElementsIn(
             JavaFileObjects.forSourceLines(
-                "mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory",
+                "mapkeys.MapModule_ComplexKeyWithInaccessibleAnnotationValueMapKey",
                 "package mapkeys;",
                 "",
                 GENERATED_ANNOTATION,
-                "public final class",
-                "    MapModule_ComplexKeyWithInaccessibleAnnotationValueFactory",
-                "        implements Factory<Integer> {",
-                "",
-                "  @Override",
-                "  public Integer get() {",
-                "    return MapModule.complexKeyWithInaccessibleAnnotationValue();",
-                "  }",
-                "",
-                "  public static MapKeys.ComplexKey mapKey() {",
+                "public final class MapModule_ComplexKeyWithInaccessibleAnnotationValueMapKey {",
+                "  public static MapKeys.ComplexKey create() {",
                 "    return MapKeys_ComplexKeyCreator.createComplexKey(",
                 "        new Class[] {String.class},",
                 "        String.class,",
@@ -441,20 +426,15 @@ public void mapBindingsWithInaccessibleKeys() {
                 "  }",
                 "}"));
     assertThat(compilation)
-        .generatedSourceFile("mapkeys.MapModule_ClassKeyFactory")
+        .generatedSourceFile("mapkeys.MapModule_ClassKeyMapKey")
         .containsElementsIn(
             JavaFileObjects.forSourceLines(
-                "mapkeys.MapModule_ClassKeyFactory",
+                "mapkeys.MapModule_ClassKeyMapKey",
                 "package mapkeys;",
                 "",
                 GENERATED_ANNOTATION,
-                "public final class MapModule_ClassKeyFactory implements Factory<Integer> {",
-                "  @Override",
-                "  public Integer get() {",
-                "    return MapModule.classKey();",
-                "  }",
-                "",
-                "  public static Class<?> mapKey() {",
+                "public final class MapModule_ClassKeyMapKey {",
+                "  public static Class<?> create() {",
                 "    return MapKeys.Inaccessible.class;",
                 "  }",
                 "}"));
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
index 0d0e050fa..b17472914 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
@@ -173,7 +173,7 @@ public void mapBindings() {
                 "",
                 "    @Override",
                 "    public Map<Long, Long> longs() {",
-                "      return ImmutableMap.<Long, Long>builder()",
+                "      return ImmutableMap.<Long, Long>builderWithExpectedSize(6)",
                 "          .put(0L, MapModule.provideLong0())",
                 "          .put(1L, MapModule.provideLong1())",
                 "          .put(2L, MapModule.provideLong2())",
@@ -185,7 +185,7 @@ public void mapBindings() {
                 "",
                 "    @Override",
                 "    public Map<Long, Provider<Long>> providerLongs() {",
-                "      return ImmutableMap.<Long, Provider<Long>>builder()",
+                "      return ImmutableMap.<Long, Provider<Long>>builderWithExpectedSize(6)",
                 "          .put(0L, MapModule_ProvideLong0Factory.create())",
                 "          .put(1L, MapModule_ProvideLong1Factory.create())",
                 "          .put(2L, MapModule_ProvideLong2Factory.create())",
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index d321f48bd..32ddf8d52 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -107,7 +107,7 @@ public void setBindings() {
             "public final class DaggerTestComponent implements TestComponent {",
             "  @Override",
             "  public Set<String> strings() {",
-            "    return ImmutableSet.<String>builder()",
+            "    return ImmutableSet.<String>builderWithExpectedSize(2)",
             "        .addAll(EmptySetModule_EmptySetFactory.proxyEmptySet())",
             "        .add(SetModule_StringFactory.proxyString())",
             "        .build();",
