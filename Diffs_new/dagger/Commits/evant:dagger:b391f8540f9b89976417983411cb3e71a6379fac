diff --git a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
index aeb37357a..a5c664b56 100644
--- a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
+++ b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
@@ -66,7 +66,7 @@ public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter
   }
 
   private boolean isDispatchingAndroidInjector(BindingNode node) {
-    Key key = node.binding().key();
+    Key key = node.key();
     return MoreTypes.isTypeOf(DispatchingAndroidInjector.class, key.type())
         && !key.qualifier().isPresent();
   }
@@ -129,7 +129,7 @@ private void validateMapKeyUniqueness(
         .filter(
             node -> {
               TypeMirror valueType =
-                  MoreTypes.asDeclared(node.binding().key().type()).getTypeArguments().get(1);
+                  MoreTypes.asDeclared(node.key().type()).getTypeArguments().get(1);
               if (!MoreTypes.isTypeOf(Provider.class, valueType)
                   || !valueType.getKind().equals(TypeKind.DECLARED)) {
                 return false;
diff --git a/java/dagger/example/spi/BindingGraphVisualizer.java b/java/dagger/example/spi/BindingGraphVisualizer.java
index 43a8ca009..01b5c42d4 100644
--- a/java/dagger/example/spi/BindingGraphVisualizer.java
+++ b/java/dagger/example/spi/BindingGraphVisualizer.java
@@ -33,6 +33,8 @@
 import dagger.model.BindingGraph.ChildFactoryMethodEdge;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
+import dagger.model.BindingGraph.MaybeBindingNode;
+import dagger.model.BindingGraph.MissingBindingNode;
 import dagger.model.BindingGraph.Node;
 import dagger.model.BindingGraph.SubcomponentBuilderBindingEdge;
 import dagger.model.BindingKind;
@@ -278,25 +280,34 @@ UUID nodeId(Node node) {
 
     DotNode dotNode(Node node) {
       DotNode dotNode = new DotNode(nodeId(node));
-      if (node instanceof BindingNode) {
-        dagger.model.Binding binding = ((BindingNode) node).binding();
-        if (binding.kind().equals(BindingKind.MEMBERS_INJECTION)) {
-          dotNode.addAttributeFormat("label", "inject(%s)", binding.key());
-        } else if (binding.isProduction()) {
-          dotNode.addAttributeFormat("label", "@Produces %s", binding.key());
-        } else {
-          dotNode.addAttribute("label", binding.key());
-        }
+      if (node instanceof MaybeBindingNode) {
         dotNode.addAttribute("tooltip", "");
         if (bindingGraph.entryPointBindingNodes().contains(node)) {
           dotNode.addAttribute("penwidth", 3);
         }
+        if (node instanceof BindingNode) {
+          dotNode.addAttribute("label", label((BindingNode) node));
+        }
+        if (node instanceof MissingBindingNode) {
+          dotNode.addAttributeFormat(
+              "label", "missing binding for %s", ((MissingBindingNode) node).key());
+        }
       } else {
         dotNode.addAttribute("style", "invis").addAttribute("shape", "point");
       }
       return dotNode;
     }
 
+    private String label(BindingNode bindingNode) {
+      if (bindingNode.binding().kind().equals(BindingKind.MEMBERS_INJECTION)) {
+        return String.format("inject(%s)", bindingNode.key());
+      } else if (bindingNode.binding().isProduction()) {
+        return String.format("@Produces %s", bindingNode.key());
+      } else {
+        return bindingNode.key().toString();
+      }
+    }
+
     private static String clusterName(ComponentPath owningComponentPath) {
       return "cluster" + owningComponentPath;
     }
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index c8bca9785..d60087ee1 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -118,7 +118,7 @@ protected void visitComponent(BindingGraph graph) {
               && node.componentPath().equals(currentComponent.componentPath())) {
             network.addEdge(
                 node,
-                subcomponentNode(node.binding().key().type(), graph),
+                subcomponentNode(node.key().type(), graph),
                 subcomponentBuilderBindingEdge(subcomponentDeclaringModules(resolvedBindings)));
           }
         }
diff --git a/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
index 01aed7f75..73da6c9fc 100644
--- a/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
+++ b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
@@ -54,22 +54,17 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
     Key productionImplementationExecutorKey = keyFactory.forProductionImplementationExecutor();
     Key productionExecutorKey = keyFactory.forProductionExecutor();
 
-    bindingGraph
-        .bindingNodes(productionExecutorKey)
-        .stream()
+    bindingGraph.bindingNodes(productionExecutorKey).stream()
         .flatMap(
             productionExecutorBinding ->
                 bindingGraph.predecessors(productionExecutorBinding).stream())
         .flatMap(instancesOf(BindingNode.class))
-        .filter(binding -> !binding.binding().key().equals(productionImplementationExecutorKey))
+        .filter(binding -> !binding.key().equals(productionImplementationExecutorKey))
         .forEach(binding -> reportError(diagnosticReporter, binding));
   }
 
   private void reportError(DiagnosticReporter diagnosticReporter, BindingNode bindingNode) {
     diagnosticReporter.reportBinding(
-        ERROR,
-        bindingNode,
-        "%s may not depend on the production executor",
-        bindingNode.binding().key());
+        ERROR, bindingNode, "%s may not depend on the production executor", bindingNode.key());
   }
 }
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index a1184de1e..3560fe543 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -20,10 +20,10 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Predicates.equalTo;
 import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Iterables.filter;
 import static com.google.common.collect.Iterables.indexOf;
 import static com.google.common.collect.Iterables.transform;
 import static com.google.common.collect.Lists.asList;
+import static com.google.common.collect.Sets.filter;
 import static dagger.internal.codegen.DaggerElements.DECLARATION_ORDER;
 import static dagger.internal.codegen.DaggerElements.elementEncloses;
 import static dagger.internal.codegen.DaggerElements.elementToString;
@@ -40,7 +40,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Sets;
 import com.google.common.collect.Table;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.FormatMethod;
@@ -50,13 +49,13 @@
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
+import dagger.model.BindingGraph.MaybeBindingNode;
 import dagger.model.BindingGraph.Node;
 import dagger.model.ComponentPath;
 import dagger.model.DependencyRequest;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
 import java.util.Comparator;
-import java.util.Map;
 import java.util.Set;
 import java.util.function.Function;
 import javax.annotation.processing.Messager;
@@ -118,7 +117,7 @@ DiagnosticReporterImpl reporter(BindingGraph graph, BindingGraphPlugin plugin) {
                 transform(types.supertypes(component.asType()), type -> asTypeElement(type)));
 
     /** The shortest path (value) from an entry point (column) to a binding (row). */
-    private final Table<BindingNode, DependencyEdge, ImmutableList<Node>> shortestPaths =
+    private final Table<MaybeBindingNode, DependencyEdge, ImmutableList<Node>> shortestPaths =
         HashBasedTable.create();
 
     private final BindingGraph graph;
@@ -161,7 +160,7 @@ public void reportComponent(
     // TODO(ronshapiro): should this also include the binding element?
     @Override
     public void reportBinding(
-        Diagnostic.Kind diagnosticKind, BindingNode bindingNode, String message) {
+        Diagnostic.Kind diagnosticKind, MaybeBindingNode bindingNode, String message) {
       StringBuilder messageBuilder = new StringBuilder(message);
       appendEntryPointsAndOneTrace(messageBuilder, bindingNode);
       printMessage(diagnosticKind, messageBuilder, rootComponent);
@@ -170,7 +169,7 @@ public void reportBinding(
     @Override
     public void reportBinding(
         Diagnostic.Kind diagnosticKind,
-        BindingNode bindingNode,
+        MaybeBindingNode bindingNode,
         String messageFormat,
         Object firstArg,
         Object... moreArgs) {
@@ -238,7 +237,7 @@ private void appendEntryPointsAndOneTrace(
      * Appends the dependency trace to {@code bindingNode} from one of the entry points from which
      * it is reachable, and any remaining entry points, to {@code message}.
      */
-    private void appendEntryPointsAndOneTrace(StringBuilder message, BindingNode bindingNode) {
+    private void appendEntryPointsAndOneTrace(StringBuilder message, MaybeBindingNode bindingNode) {
       ImmutableSet<DependencyEdge> entryPoints =
           graph.entryPointEdgesDependingOnBindingNode(bindingNode);
       // Show the full dependency trace for one entry point.
@@ -288,16 +287,11 @@ private void appendEntryPointsAndOneTrace(StringBuilder message, BindingNode bin
     }
 
     // TODO(ronshapiro): Adding a DependencyPath type to dagger.model could be useful, i.e.
-    // bindingGraph.shortestPathFromEntryPoint(DependencyEdge, BindingNode)
+    // bindingGraph.shortestPathFromEntryPoint(DependencyEdge, MaybeBindingNode)
     private void appendDependencyTrace(
-        StringBuilder message, DependencyEdge entryPoint, BindingNode bindingNode) {
+        StringBuilder message, DependencyEdge entryPoint, MaybeBindingNode bindingNode) {
       checkArgument(entryPoint.isEntryPoint());
-      Node entryPointBinding = graph.incidentNodes(entryPoint).target();
-      ImmutableList<Node> shortestBindingPath =
-          shortestPath(
-              node -> Sets.filter(graph.successors(node), BindingNode.class::isInstance),
-              entryPointBinding,
-              bindingNode);
+      ImmutableList<Node> shortestBindingPath = shortestPathFromEntryPoint(entryPoint, bindingNode);
       verify(
           !shortestBindingPath.isEmpty(),
           "no dependency path from %s to %s in %s",
@@ -364,24 +358,21 @@ private StringBuilder insertBracketPrefix(StringBuilder messageBuilder, String p
      * Returns a comparator that puts entry points whose shortest dependency path to {@code
      * bindingNode} is shortest first.
      */
-    private Comparator<DependencyEdge> shortestDependencyPathFirst(BindingNode bindingNode) {
-      Map<DependencyEdge, ImmutableList<Node>> shortestPathsToBinding =
-          shortestPaths.row(bindingNode);
-      return comparing(
-          entryPoint ->
-              shortestPathsToBinding
-                  .computeIfAbsent(
-                      entryPoint, computeShortestPathToBindingFromEntryNode(bindingNode))
-                  .size());
+    private Comparator<DependencyEdge> shortestDependencyPathFirst(MaybeBindingNode bindingNode) {
+      return comparing(entryPoint -> shortestPathFromEntryPoint(entryPoint, bindingNode).size());
     }
 
-    private Function<DependencyEdge, ImmutableList<Node>> computeShortestPathToBindingFromEntryNode(
-        BindingNode bindingNode) {
-      return entryPoint ->
-          shortestPath(
-              node -> filter(graph.successors(node), successor -> successor instanceof BindingNode),
-              graph.incidentNodes(entryPoint).target(),
-              bindingNode);
+    private ImmutableList<Node> shortestPathFromEntryPoint(
+        DependencyEdge entryPoint, MaybeBindingNode bindingNode) {
+      return shortestPaths
+          .row(bindingNode)
+          .computeIfAbsent(
+              entryPoint,
+              ep ->
+                  shortestPath(
+                      node -> filter(graph.successors(node), MaybeBindingNode.class::isInstance),
+                      graph.incidentNodes(ep).target(),
+                      bindingNode));
     }
 
     /**
diff --git a/java/dagger/internal/codegen/InjectBindingValidation.java b/java/dagger/internal/codegen/InjectBindingValidation.java
index 373a37f73..baf7abc2d 100644
--- a/java/dagger/internal/codegen/InjectBindingValidation.java
+++ b/java/dagger/internal/codegen/InjectBindingValidation.java
@@ -53,7 +53,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
   private void validateInjectionBinding(BindingNode node, DiagnosticReporter diagnosticReporter) {
     ValidationReport<TypeElement> typeReport =
-        injectValidator.validateType(MoreTypes.asTypeElement(node.binding().key().type()));
+        injectValidator.validateType(MoreTypes.asTypeElement(node.key().type()));
     for (Item item : typeReport.allItems()) {
       diagnosticReporter.reportBinding(item.kind(), node, item.message());
     }
diff --git a/java/dagger/internal/codegen/MapMultibindingValidation.java b/java/dagger/internal/codegen/MapMultibindingValidation.java
index 0c6893336..b2d50a041 100644
--- a/java/dagger/internal/codegen/MapMultibindingValidation.java
+++ b/java/dagger/internal/codegen/MapMultibindingValidation.java
@@ -91,8 +91,7 @@ private void checkForDuplicateMapKeys(
         diagnosticReporter.reportBinding(
             ERROR,
             multiboundMapBindingNode,
-            duplicateMapKeyErrorMessage(
-                contributionsForOneMapKey, multiboundMapBindingNode.binding().key()));
+            duplicateMapKeyErrorMessage(contributionsForOneMapKey, multiboundMapBindingNode.key()));
       }
     }
   }
@@ -109,7 +108,7 @@ private void checkForInconsistentMapKeyAnnotationTypes(
           ERROR,
           multiboundMapBindingNode,
           inconsistentMapKeyAnnotationTypesErrorMessage(
-              contributionsByMapKeyAnnotationType, multiboundMapBindingNode.binding().key()));
+              contributionsByMapKeyAnnotationType, multiboundMapBindingNode.key()));
     }
   }
 
diff --git a/java/dagger/internal/codegen/MembersInjectionBindingValidation.java b/java/dagger/internal/codegen/MembersInjectionBindingValidation.java
index e68ecdfc7..0ce55fca3 100644
--- a/java/dagger/internal/codegen/MembersInjectionBindingValidation.java
+++ b/java/dagger/internal/codegen/MembersInjectionBindingValidation.java
@@ -66,10 +66,10 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
   private Optional<TypeMirror> membersInjectedType(BindingNode bindingNode) {
     switch (bindingNode.binding().kind()) {
       case MEMBERS_INJECTION:
-        return Optional.of(bindingNode.binding().key().type());
+        return Optional.of(bindingNode.key().type());
 
       case MEMBERS_INJECTOR:
-        return Optional.of(types.unwrapType(bindingNode.binding().key().type()));
+        return Optional.of(types.unwrapType(bindingNode.key().type()));
 
       default:
         return Optional.empty();
diff --git a/java/dagger/internal/codegen/NullableBindingValidation.java b/java/dagger/internal/codegen/NullableBindingValidation.java
index 9ff791f62..648922b5f 100644
--- a/java/dagger/internal/codegen/NullableBindingValidation.java
+++ b/java/dagger/internal/codegen/NullableBindingValidation.java
@@ -49,7 +49,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
             compilerOptions.nullableValidationKind(),
             dependencyEdge,
             nullableToNonNullable(
-                bindingNode.binding().key().toString(),
+                bindingNode.key().toString(),
                 bindingNode.toString())); // will include the @Nullable
       }
     }
diff --git a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidation.java b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidation.java
index f7584210b..2f3de94e9 100644
--- a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidation.java
+++ b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidation.java
@@ -111,6 +111,6 @@ private String dependencyErrorMessage(
       DependencyEdge dependencyOnProduction, BindingGraph bindingGraph) {
     return String.format(
         "%s is a provision, which cannot depend on a production.",
-        bindingRequestingDependency(dependencyOnProduction, bindingGraph).binding().key());
+        bindingRequestingDependency(dependencyOnProduction, bindingGraph).key());
   }
 }
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 56ac7ff40..8c59f3b76 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -85,7 +85,7 @@
   /** Returns the binding nodes for a key. */
   public ImmutableSet<BindingNode> bindingNodes(Key key) {
     return nodeStream(BindingNode.class)
-        .filter(node -> node.binding().key().equals(key))
+        .filter(node -> node.key().equals(key))
         .collect(toImmutableSet());
   }
 
@@ -166,19 +166,19 @@ public ComponentNode rootComponentNode() {
     return entryPointEdgeStream().collect(toImmutableSet());
   }
 
-  /** Returns the binding nodes for bindings that directly satisfy entry points. */
-  public ImmutableSet<BindingNode> entryPointBindingNodes() {
+  /** Returns the binding nodes or missing binding nodes that directly satisfy entry points. */
+  public ImmutableSet<MaybeBindingNode> entryPointBindingNodes() {
     return entryPointEdgeStream()
-        .map(edge -> (BindingNode) incidentNodes(edge).target())
+        .map(edge -> (MaybeBindingNode) incidentNodes(edge).target())
         .collect(toImmutableSet());
   }
 
   /**
-   * Returns the edges for entry points that transitively depend on a binding. Never returns an
-   * empty set.
+   * Returns the edges for entry points that transitively depend on a binding or missing binding for
+   * a key. Never returns an empty set.
    */
   public ImmutableSet<DependencyEdge> entryPointEdgesDependingOnBindingNode(
-      BindingNode bindingNode) {
+      MaybeBindingNode bindingNode) {
     ImmutableNetwork<Node, DependencyEdge> dependencyGraph = dependencyGraph();
     Network<Node, DependencyEdge> subgraphDependingOnBindingNode =
         inducedSubgraph(
@@ -328,11 +328,28 @@ public String toString() {
     ComponentPath componentPath();
   }
 
+  /**
+   * A node in the binding graph that is either a {@link BindingNode} or a {@link
+   * MissingBindingNode}.
+   */
+  public interface MaybeBindingNode extends Node {
+
+    /** The component that owns the binding, or in which the binding is missing. */
+    @Override
+    ComponentPath componentPath();
+
+    /** The key of the binding, or for which there is no binding. */
+    Key key();
+
+    /** The binding, or empty if missing. */
+    Optional<Binding> maybeBinding();
+  }
+
   /**
    * A <b>binding node</b> in the binding graph. If a binding is owned by more than one component,
    * there is one binding node for that binding for every owning component.
    */
-  public interface BindingNode extends Node {
+  public interface BindingNode extends MaybeBindingNode {
 
     /** The component that owns the {@link #binding()}. */
     @Override
@@ -340,11 +357,21 @@ public String toString() {
 
     /** The binding. */
     Binding binding();
+
+    @Override
+    default Key key() {
+      return binding().key();
+    }
+
+    @Override
+    default Optional<Binding> maybeBinding() {
+      return Optional.of(binding());
+    }
   }
 
   /** A node in the binding graph that represents a missing binding for a key in a component. */
   @AutoValue
-  public abstract static class MissingBindingNode implements Node {
+  public abstract static class MissingBindingNode implements MaybeBindingNode {
     static MissingBindingNode create(ComponentPath component, Key key) {
       return new AutoValue_BindingGraph_MissingBindingNode(component, key);
     }
@@ -357,7 +384,12 @@ static MissingBindingNode create(ComponentPath component, Key key) {
     public abstract Key key();
 
     @Override
-    public String toString() {
+    public final Optional<Binding> maybeBinding() {
+      return Optional.empty();
+    }
+
+    @Override
+    public final String toString() {
       return String.format("missing binding for %s in %s", key(), componentPath());
     }
   }
diff --git a/java/dagger/model/testing/BindingGraphSubject.java b/java/dagger/model/testing/BindingGraphSubject.java
index 66d3c3627..d88f93d27 100644
--- a/java/dagger/model/testing/BindingGraphSubject.java
+++ b/java/dagger/model/testing/BindingGraphSubject.java
@@ -96,10 +96,8 @@ private BindingNodeSubject bindingWithKeyString(String keyString) {
   }
 
   private ImmutableSet<BindingNode> getBindingNodes(String keyString) {
-    return actual()
-        .bindingNodes()
-        .stream()
-        .filter(node -> node.binding().key().toString().equals(keyString))
+    return actual().bindingNodes().stream()
+        .filter(node -> node.key().toString().equals(keyString))
         .collect(toImmutableSet());
   }
 
@@ -139,12 +137,10 @@ public void dependsOnBindingWithKey(String qualifier, String type) {
     }
 
     private void dependsOnBindingWithKeyString(String keyString) {
-      if (actualBindingGraph()
-          .successors(actual())
-          .stream()
+      if (actualBindingGraph().successors(actual()).stream()
           .filter(node -> node instanceof BindingNode)
           .map(node -> (BindingNode) node)
-          .noneMatch(node -> node.binding().key().toString().equals(keyString))) {
+          .noneMatch(node -> node.key().toString().equals(keyString))) {
         fail("has successor with key", keyString);
       }
     }
diff --git a/java/dagger/spi/DiagnosticReporter.java b/java/dagger/spi/DiagnosticReporter.java
index d4b0d7a75..8c15149d6 100644
--- a/java/dagger/spi/DiagnosticReporter.java
+++ b/java/dagger/spi/DiagnosticReporter.java
@@ -18,15 +18,17 @@
 
 import com.google.errorprone.annotations.FormatMethod;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ChildFactoryMethodEdge;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.MaybeBindingNode;
 import javax.tools.Diagnostic;
 
 /**
  * An object that {@link BindingGraphPlugin}s can use to report diagnostics while visiting a {@link
  * BindingGraph}.
+ *
+ * <p>Note: This API is still experimental and will change.
  */
 public interface DiagnosticReporter {
   /**
@@ -48,19 +50,19 @@ void reportComponent(
       Object... moreArgs);
 
   /**
-   * Reports a diagnostic for a binding. Includes information about how the binding is reachable
-   * from entry points.
+   * Reports a diagnostic for a binding or missing binding. Includes information about how the
+   * binding is reachable from entry points.
    */
-  void reportBinding(Diagnostic.Kind diagnosticKind, BindingNode bindingNode, String message);
+  void reportBinding(Diagnostic.Kind diagnosticKind, MaybeBindingNode bindingNode, String message);
 
   /**
-   * Reports a diagnostic for a binding. Includes information about how the binding is reachable
-   * from entry points.
+   * Reports a diagnostic for a binding or missing binding. Includes information about how the
+   * binding is reachable from entry points.
    */
   @FormatMethod
   void reportBinding(
       Diagnostic.Kind diagnosticKind,
-      BindingNode bindingNode,
+      MaybeBindingNode bindingNode,
       String messageFormat,
       Object firstArg,
       Object... moreArgs);
diff --git a/javatests/dagger/spi/FailingPlugin.java b/javatests/dagger/spi/FailingPlugin.java
index e8bd6a446..bb9604c12 100644
--- a/javatests/dagger/spi/FailingPlugin.java
+++ b/javatests/dagger/spi/FailingPlugin.java
@@ -43,10 +43,8 @@ public void initOptions(Map<String, String> options) {
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
     if (options.containsKey("error_on_binding")) {
       String key = options.get("error_on_binding");
-      bindingGraph
-          .bindingNodes()
-          .stream()
-          .filter(node -> node.binding().key().toString().equals(key))
+      bindingGraph.bindingNodes().stream()
+          .filter(node -> node.key().toString().equals(key))
           .forEach(node -> diagnosticReporter.reportBinding(ERROR, node, "Bad %s!", "Binding"));
     }
 
