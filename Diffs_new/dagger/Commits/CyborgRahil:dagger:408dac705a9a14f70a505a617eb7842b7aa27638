diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index aa7f461dd..2ac5dbe29 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -35,6 +35,7 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ListMultimap;
+import com.google.common.collect.Maps;
 import com.google.common.collect.MultimapBuilder;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
@@ -458,7 +459,8 @@ void addModifiableBindingMethod(
       TypeMirror returnType,
       MethodSpec methodSpec,
       boolean finalized) {
-    modifiableBindingMethods.addMethod(type, request, returnType, methodSpec, finalized);
+    modifiableBindingMethods.addNewModifiableMethod(
+        type, request, returnType, methodSpec, finalized);
     methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, methodSpec);
   }
 
@@ -473,12 +475,13 @@ void registerModifiableBindingMethod(
       TypeMirror returnType,
       MethodSpec methodSpec,
       boolean finalized) {
-    modifiableBindingMethods.addMethod(type, request, returnType, methodSpec, finalized);
+    modifiableBindingMethods.addNewModifiableMethod(
+        type, request, returnType, methodSpec, finalized);
   }
 
   /** Adds the implementation for the given {@link ModifiableBindingMethod} to the component. */
   void addImplementedModifiableBindingMethod(ModifiableBindingMethod method) {
-    modifiableBindingMethods.methodImplemented(method);
+    modifiableBindingMethods.addReimplementedMethod(method);
     methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, method.methodSpec());
   }
 
@@ -632,18 +635,20 @@ boolean hasInitializations() {
    * Returns the {@link ModifiableBindingMethod}s for this subcomponent implementation and its
    * superclasses.
    */
-  ImmutableList<ModifiableBindingMethod> getModifiableBindingMethods() {
-    ImmutableList.Builder<ModifiableBindingMethod> modifiableBindingMethodsBuilder =
-        ImmutableList.builder();
+  ImmutableMap<BindingRequest, ModifiableBindingMethod> getModifiableBindingMethods() {
+    Map<BindingRequest, ModifiableBindingMethod> modifiableBindingMethodsBuilder =
+        new LinkedHashMap<>();
     if (superclassImplementation.isPresent()) {
-      ImmutableList<ModifiableBindingMethod> superclassModifiableBindingMethods =
-          superclassImplementation.get().getModifiableBindingMethods();
-      superclassModifiableBindingMethods.stream()
-          .filter(method -> !modifiableBindingMethods.finalized(method))
-          .forEach(modifiableBindingMethodsBuilder::add);
+      modifiableBindingMethodsBuilder.putAll(
+          Maps.filterValues(
+              superclassImplementation.get().getModifiableBindingMethods(),
+              // filters the modifiable methods of a superclass that are finalized in this component
+              method -> !modifiableBindingMethods.finalized(method)));
     }
-    modifiableBindingMethodsBuilder.addAll(modifiableBindingMethods.getNonFinalizedMethods());
-    return modifiableBindingMethodsBuilder.build();
+    // replace superclass modifiable binding methods with any that are defined in this component
+    // implementation
+    modifiableBindingMethodsBuilder.putAll(modifiableBindingMethods.getNonFinalizedMethods());
+    return ImmutableMap.copyOf(modifiableBindingMethodsBuilder);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index bac07d7b1..8930921e0 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -757,7 +757,7 @@ protected void addInterfaceMethods() {
         ComponentImplementation superclassImplementation =
             componentImplementation.superclassImplementation().get();
         for (ModifiableBindingMethod superclassModifiableBindingMethod :
-            superclassImplementation.getModifiableBindingMethods()) {
+            superclassImplementation.getModifiableBindingMethods().values()) {
           bindingExpressions
               .modifiableBindingExpressions()
               .possiblyReimplementedMethod(superclassModifiableBindingMethod)
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index eb699e587..0f67cc01e 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -111,6 +111,7 @@ ModifiableBindingType registerComponentMethodIfModifiable(
           : Optional.of(
               reimplementedMethod(
                   modifiableBindingMethod,
+                  newModifiableBindingType,
                   new PrunedConcreteMethodBindingExpression(),
                   componentImplementation.isAbstract()));
     }
@@ -134,6 +135,7 @@ ModifiableBindingType registerComponentMethodIfModifiable(
       return Optional.of(
           reimplementedMethod(
               modifiableBindingMethod,
+              newModifiableBindingType,
               bindingExpressions.getBindingExpression(request),
               markMethodFinal));
     }
@@ -146,11 +148,12 @@ ModifiableBindingType registerComponentMethodIfModifiable(
    */
   private ModifiableBindingMethod reimplementedMethod(
       ModifiableBindingMethod supertypeMethod,
+      ModifiableBindingType newModifiableBindingType,
       BindingExpression bindingExpression,
       boolean markMethodFinal) {
     MethodSpec baseMethod = supertypeMethod.methodSpec();
-    return ModifiableBindingMethod.implement(
-        supertypeMethod,
+    return supertypeMethod.reimplement(
+        newModifiableBindingType,
         MethodSpec.methodBuilder(baseMethod.name)
             .addModifiers(baseMethod.modifiers.contains(PUBLIC) ? PUBLIC : PROTECTED)
             .addModifiers(markMethodFinal ? ImmutableSet.of(FINAL) : ImmutableSet.of())
diff --git a/java/dagger/internal/codegen/ModifiableBindingMethods.java b/java/dagger/internal/codegen/ModifiableBindingMethods.java
index 8aadf6a1a..55dd1ef13 100644
--- a/java/dagger/internal/codegen/ModifiableBindingMethods.java
+++ b/java/dagger/internal/codegen/ModifiableBindingMethods.java
@@ -17,20 +17,17 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
-import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
 import com.squareup.javapoet.MethodSpec;
 import java.util.Map;
 import java.util.Optional;
-import java.util.Set;
 import javax.lang.model.type.TypeMirror;
 
 /**
@@ -44,32 +41,35 @@
  */
 final class ModifiableBindingMethods {
   private final Map<BindingRequest, ModifiableBindingMethod> methods = Maps.newLinkedHashMap();
-  private final Set<BindingRequest> finalizedMethods = Sets.newHashSet();
 
-  /** Register a method encapsulating a modifiable binding. */
-  void addMethod(
+  /** Registers a new method encapsulating a modifiable binding. */
+  void addNewModifiableMethod(
       ModifiableBindingType type,
       BindingRequest request,
       TypeMirror returnType,
       MethodSpec method,
       boolean finalized) {
     checkArgument(type.isModifiable());
-    if (finalized) {
-      finalizedMethods.add(request);
-    }
-    ModifiableBindingMethod modifiableMethod =
-        ModifiableBindingMethod.create(type, request, returnType, method, finalized);
-    ModifiableBindingMethod previousMethod = methods.put(request, modifiableMethod);
+    addMethod(ModifiableBindingMethod.create(type, request, returnType, method, finalized));
+  }
+
+  /** Registers a reimplemented modifiable method. */
+  void addReimplementedMethod(ModifiableBindingMethod method) {
+    addMethod(method);
+  }
+
+  private void addMethod(ModifiableBindingMethod method) {
+    ModifiableBindingMethod previousMethod = methods.put(method.request(), method);
     verify(
         previousMethod == null,
         "registering %s but %s is already registered for the same binding request",
-        modifiableMethod,
+        method,
         previousMethod);
   }
 
   /** Returns all {@link ModifiableBindingMethod}s that have not been marked as finalized. */
-  ImmutableList<ModifiableBindingMethod> getNonFinalizedMethods() {
-    return methods.values().stream().filter(m -> !m.finalized()).collect(toImmutableList());
+  ImmutableMap<BindingRequest, ModifiableBindingMethod> getNonFinalizedMethods() {
+    return ImmutableMap.copyOf(Maps.filterValues(methods, m -> !m.finalized()));
   }
 
   /** Returns the {@link ModifiableBindingMethod} for the given binding if present. */
@@ -82,25 +82,12 @@ void addMethod(
     return ImmutableList.copyOf(methods.values());
   }
 
-  /**
-   * Mark the {@link ModifiableBindingMethod} as having been implemented, thus modifying the
-   * binding.
-   */
-  void methodImplemented(ModifiableBindingMethod method) {
-    if (method.finalized()) {
-      checkState(
-          finalizedMethods.add(method.request()),
-          "Implementing and finalizing a modifiable binding method that has been marked as "
-              + "finalized in the current subcomponent implementation. The binding is for a %s "
-              + "of type %s.",
-          method.request(),
-          method.type());
-    }
-  }
-
   /** Whether a given binding has been marked as finalized. */
+  // TODO(ronshapiro): possibly rename this to something that indicates that the BindingRequest for
+  // `method` has been finalized in *this* component implementation?
   boolean finalized(ModifiableBindingMethod method) {
-    return finalizedMethods.contains(method.request());
+    ModifiableBindingMethod storedMethod = methods.get(method.request());
+    return storedMethod != null && storedMethod.finalized();
   }
 
   @AutoValue
@@ -115,15 +102,13 @@ private static ModifiableBindingMethod create(
           type, request, MoreTypes.equivalence().wrap(returnType), methodSpec, finalized);
     }
 
-    /** Create a {@ModifiableBindingMethod} representing an implementation of an existing method. */
-    static ModifiableBindingMethod implement(
-        ModifiableBindingMethod unimplementedMethod, MethodSpec methodSpec, boolean finalized) {
+    /** Creates a {@ModifiableBindingMethod} that reimplements the current method. */
+    ModifiableBindingMethod reimplement(
+        ModifiableBindingType newModifiableBindingType,
+        MethodSpec newImplementation,
+        boolean finalized) {
       return new AutoValue_ModifiableBindingMethods_ModifiableBindingMethod(
-          unimplementedMethod.type(),
-          unimplementedMethod.request(),
-          unimplementedMethod.returnTypeWrapper(),
-          methodSpec,
-          finalized);
+          newModifiableBindingType, request(), returnTypeWrapper(), newImplementation, finalized);
     }
 
     abstract ModifiableBindingType type();
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java
index 4d026cdb7..c92beb3e9 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsMultibindingsTest.java
@@ -881,6 +881,166 @@ public void setMultibinding_requestedAsInstanceInLeaf_requestedAsFrameworkInstan
         .hasSourceEquivalentTo(generatedAncestor);
   }
 
+  @Test
+  public void missingMultibindingInLeaf_onlyContributionsInAncestor_notReModifiedInRoot() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  Set<Object> set();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.GenerationOptions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATION_OPTIONS_ANNOTATION,
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Object onlyContribution() {",
+            "    return new Object();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.internal.GenerationOptions;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATION_OPTIONS_ANNOTATION,
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public Set<Object> set() {",
+            "      return ImmutableSet.<Object>of(",
+            "          AncestorModule_OnlyContributionFactory.onlyContribution());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Root {",
+            "  Ancestor ancestor();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot() {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Ancestor ancestor() {",
+            "    return new AncestorImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot();",
+            "    }",
+            "  }",
+            "",
+            "  protected final class AncestorImpl extends DaggerAncestor {",
+            "    private AncestorImpl() {}",
+            "",
+            "    @Override",
+            "    public Leaf leaf() {",
+            "      return new LeafImpl();",
+            "    }",
+            "",
+            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      private LeafImpl() {}",
+            // This tests a regression case where Dagger used to reimplement Leaf.set(), even though
+            // there were no new contributions, because the state change from missing -> 
+            // multibinding wasn't properly recorded
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
   @Test
   public void setMultibindings_contributionsInLeafAndAncestor_frameworkInstances() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
