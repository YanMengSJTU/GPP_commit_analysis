diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index aa9310f5b..ef08f95bd 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -739,11 +739,18 @@ private ModuleDescriptor descriptorForProductionExecutorModule(
     }
   }
 
+  /**
+   * No-argument methods defined on {@link Object} that are ignored for contribution.
+   */
+  private static final ImmutableSet<String> NON_CONTRIBUTING_OBJECT_METHOD_NAMES =
+      ImmutableSet.of("toString", "hashCode", "clone", "getClass");
+
   static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
     return method.getParameters().isEmpty()
         && !method.getReturnType().getKind().equals(VOID)
         && !elements.getTypeElement(Object.class.getCanonicalName())
-            .equals(method.getEnclosingElement());
+            .equals(method.getEnclosingElement())
+        && !NON_CONTRIBUTING_OBJECT_METHOD_NAMES.contains(method.getSimpleName().toString());
   }
 
   static boolean isComponentProductionMethod(Elements elements, ExecutableElement method) {
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index bf4784cb1..08946fdec 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -1924,6 +1924,204 @@ public void testDefaultPackage() {
         .hasSourceEquivalentTo(generatedComponent);
   }
 
+  @Test public void ignoresDependencyMethodsFromObject() {
+    JavaFileObject injectedTypeFile =
+        JavaFileObjects.forSourceLines(
+            "test.InjectedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class InjectedType {",
+            "  @Inject InjectedType(",
+            "      String stringInjection,",
+            "      int intInjection,",
+            "      AComponent aComponent,",
+            "      Class<AComponent> aClass) {}",
+            "}");
+    JavaFileObject aComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.AComponent",
+            "package test;",
+            "",
+            "class AComponent {",
+            "  String someStringInjection() {",
+            "    return \"injectedString\";",
+            "  }",
+            "",
+            "  int someIntInjection() {",
+            "    return 123;",
+            "  }",
+            "",
+            "  Class<AComponent> someClassInjection() {",
+            "    return AComponent.class;",
+            "  }",
+            "",
+            "  @Override",
+            "  public String toString() {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Override",
+            "  public int hashCode() {",
+            "    return 456;",
+            "  }",
+            "",
+            "  @Override",
+            "  public AComponent clone() {",
+            "    return null;",
+            "  }",
+            "}");
+    JavaFileObject bComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.AComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = AComponent.class)",
+            "interface BComponent {",
+            "  InjectedType injectedType();",
+            "}");
+    JavaFileObject generatedComponent;
+    switch (compilerMode) {
+      case EXPERIMENTAL_ANDROID:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerBComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerBComponent implements BComponent {",
+                "  private AComponent aComponent;",
+                "",
+                "  private DaggerBComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static BComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.aComponent = builder.aComponent;",
+                "  }",
+                "",
+                "  @Override",
+                "  public InjectedType injectedType() {",
+                "    return new InjectedType(",
+                "        Preconditions.checkNotNull(",
+                "            aComponent.someStringInjection(),",
+                "            \"Cannot return null from a non-@Nullable component method\"),",
+                "        aComponent.someIntInjection(),",
+                "        aComponent,",
+                "        Preconditions.checkNotNull(",
+                "            aComponent.someClassInjection(),",
+                "            \"Cannot return null from a non-@Nullable component method\"));",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private AComponent aComponent;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public BComponent build() {",
+                "      if (aComponent == null) {",
+                "        throw new IllegalStateException(",
+                "            AComponent.class.getCanonicalName() + \" must be set\");",
+                "      }",
+                "      return new DaggerBComponent(this);",
+                "    }",
+                "",
+                "    public Builder aComponent(AComponent aComponent) {",
+                "      this.aComponent = Preconditions.checkNotNull(aComponent);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+        break;
+      default:
+        generatedComponent =
+            JavaFileObjects.forSourceLines(
+                "test.DaggerBComponent",
+                "package test;",
+                "",
+                "import dagger.internal.Preconditions;",
+                "import javax.annotation.Generated;",
+                "",
+                GENERATED_ANNOTATION,
+                "public final class DaggerBComponent implements BComponent {",
+                "  private AComponent aComponent;",
+                "",
+                "  private DaggerBComponent(Builder builder) {",
+                "    initialize(builder);",
+                "  }",
+                "",
+                "  public static Builder builder() {",
+                "    return new Builder();",
+                "  }",
+                "",
+                "  public static BComponent create() {",
+                "    return new Builder().build();",
+                "  }",
+                "",
+                "  @SuppressWarnings(\"unchecked\")",
+                "  private void initialize(final Builder builder) {",
+                "    this.aComponent = builder.aComponent;",
+                "  }",
+                "",
+                "  @Override",
+                "  public InjectedType injectedType() {",
+                "    return new InjectedType(",
+                "        Preconditions.checkNotNull(",
+                "            aComponent.someStringInjection(),",
+                "            \"Cannot return null from a non-@Nullable component method\"),",
+                "        aComponent.someIntInjection(),",
+                "        aComponent,",
+                "        Preconditions.checkNotNull(",
+                "            aComponent.someClassInjection(),",
+                "            \"Cannot return null from a non-@Nullable component method\"));",
+                "  }",
+                "",
+                "  public static final class Builder {",
+                "    private AComponent aComponent;",
+                "",
+                "    private Builder() {}",
+                "",
+                "    public BComponent build() {",
+                "      if (aComponent == null) {",
+                "        throw new IllegalStateException(",
+                "            AComponent.class.getCanonicalName() + \" must be set\");",
+                "      }",
+                "      return new DaggerBComponent(this);",
+                "    }",
+                "",
+                "    public Builder aComponent(AComponent aComponent) {",
+                "      this.aComponent = Preconditions.checkNotNull(aComponent);",
+                "      return this;",
+                "    }",
+                "  }",
+                "}");
+    }
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(injectedTypeFile, aComponentFile, bComponentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerBComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
   @Test public void resolutionOrder() {
     JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
         "package test;",
