diff --git a/java/dagger/producers/ProductionComponent.java b/java/dagger/producers/ProductionComponent.java
index 9af158838..77530b6f9 100644
--- a/java/dagger/producers/ProductionComponent.java
+++ b/java/dagger/producers/ProductionComponent.java
@@ -17,12 +17,14 @@
 package dagger.producers;
 
 import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
@@ -31,22 +33,24 @@
  * Annotates an interface or abstract class for which a fully-formed, dependency-injected
  * implementation is to be generated from a set of {@linkplain #modules modules}. The generated
  * class will have the name of the type annotated with {@code @ProductionComponent} prepended with
- * {@code Dagger}.  For example, {@code @ProductionComponent interface MyComponent {...}} will
+ * {@code Dagger}. For example, {@code @ProductionComponent interface MyComponent {...}} will
  * produce an implementation named {@code DaggerMyComponent}.
  *
  * <p>Each {@link Produces} method that contributes to the component will be called at most once per
- * component instance, no matter how many times that binding is used as a dependency.
- * TODO(beder): Decide on how scope works for producers.
+ * component instance, no matter how many times that binding is used as a dependency. TODO(beder):
+ * Decide on how scope works for producers.
  *
  * <h2>Component methods</h2>
  *
  * <p>Every type annotated with {@code @ProductionComponent} must contain at least one abstract
  * component method. Component methods must represent {@linkplain Producer production}.
  *
- * Production methods have no arguments and return either a {@link ListenableFuture} or
- * {@link Producer} of a type that is {@link Inject injected}, {@link Provides provided}, or
- * {@link Produces produced}. Each may have a {@link Qualifier} annotation as well. The following
- * are all valid production method declarations: <pre><code>
+ * <p>Production methods have no arguments and return either a {@link ListenableFuture} or {@link
+ * Producer} of a type that is {@link Inject injected}, {@link Provides provided}, or {@link
+ * Produces produced}. Each may have a {@link Qualifier} annotation as well. The following are all
+ * valid production method declarations:
+ *
+ * <pre><code>
  *   {@literal ListenableFuture<SomeType>} getSomeType();
  *   {@literal Producer<Set<SomeType>>} getSomeTypes();
  *   {@literal @Response ListenableFuture<Html>} getResponse();
@@ -60,9 +64,9 @@
  * and if the downstream producer injects a {@code Produced<T>}, then the downstream producer will
  * be run with the exception stored in the {@code Produced<T>}.
  *
- * <p>If a non-execution exception is thrown (e.g., an {@code InterruptedException} or
- * {@code CancellationException}), then exception is handled as in
- * {@link com.google.common.util.concurrent.Futures#transform}.
+ * <p>If a non-execution exception is thrown (e.g., an {@code InterruptedException} or {@code
+ * CancellationException}), then exception is handled as in {@link
+ * com.google.common.util.concurrent.Futures#transform}.
  * <!-- TODO(beder): Explain this more thoroughly, and update the javadocs of those utilities. -->
  *
  * <h2>Executor</h2>
@@ -74,6 +78,7 @@
  *
  * @since 2.0
  */
+@Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.
 @Documented
 @Target(TYPE)
 @Beta
