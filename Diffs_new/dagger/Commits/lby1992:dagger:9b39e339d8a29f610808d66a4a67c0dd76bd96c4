diff --git a/README.md b/README.md
index 2de25f580..a0f90563e 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 # Dagger 2
 
-[![Maven Central][mavenbadge-svg]][mavenbadge]
+[![Maven Central][mavenbadge-svg]][mavencentral]
 
 A fast dependency injector for Android and Java.
 
@@ -46,7 +46,7 @@ Given the following `WORKSPACE` definition, you can reference dagger via
 
 ```python
 http_archive(
-    name = "com_google_dagger"
+    name = "com_google_dagger",
     urls = ["https://github.com/google/dagger/archive/dagger-<version>.zip"],
 )
 ```
@@ -192,7 +192,7 @@ gradle.projectsEvaluated {
 
 If you do not use maven, gradle, ivy, or other build systems that consume
 maven-style binary artifacts, they can be downloaded directly via the
-[Maven Central Repository][mavensearch].
+[Maven Central Repository][mavencentral].
 
 Developer snapshots are available from Sonatype's
 [snapshot repository][dagger-snap], and are built on a clean build of
@@ -229,8 +229,7 @@ install a copy in your local maven repository with the version `LOCAL-SNAPSHOT`.
 [gaktalk]: https://www.youtube.com/watch?v=oK_XtfXPkqw
 [latestapi]: https://google.github.io/dagger/api/latest/
 [mavenbadge-svg]: https://maven-badges.herokuapp.com/maven-central/com.google.dagger/dagger/badge.svg
-[mavenbadge]: https://maven-badges.herokuapp.com/maven-central/com.google.dagger/dagger
-[mavensearch]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.google.dagger%22
+[mavencentral]: https://search.maven.org/artifact/com.google.dagger/dagger
 [project]: http://github.com/google/dagger/
 [proposal]: https://github.com/square/dagger/issues/366
 [square]: http://github.com/square/dagger/
diff --git a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
index 0e08debb3..aeb37357a 100644
--- a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
+++ b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
@@ -47,8 +47,6 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * Validates that the two maps that {@link DispatchingAndroidInjector} injects have logically
@@ -58,9 +56,6 @@
  */
 @AutoService(BindingGraphPlugin.class)
 public final class DuplicateAndroidInjectorsChecker implements BindingGraphPlugin {
-  private Types types;
-  private Elements elements;
-
   @Override
   public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
     for (BindingNode node : graph.bindingNodes()) {
@@ -160,14 +155,4 @@ private void validateMapKeyUniqueness(
   public String pluginName() {
     return "Dagger/Android/DuplicateAndroidInjectors";
   }
-
-  @Override
-  public void initTypes(Types types) {
-    this.types = types;
-  }
-
-  @Override
-  public void initElements(Elements elements) {
-    this.elements = elements;
-  }
 }
diff --git a/java/dagger/internal/SetFactory.java b/java/dagger/internal/SetFactory.java
index 3f3ad0d51..349399b3e 100644
--- a/java/dagger/internal/SetFactory.java
+++ b/java/dagger/internal/SetFactory.java
@@ -101,8 +101,7 @@ private SetFactory(
   }
 
   /**
-   * Returns a {@link Set} whose iteration order is that of the elements given by each of the
-   * providers, which are invoked in the order given at creation.
+   * Returns a {@link Set} that contains the elements given by each of the providers.
    *
    * @throws NullPointerException if any of the delegate {@link Set} instances or elements therein
    *     are {@code null}
diff --git a/java/dagger/internal/codegen/AbstractMethodModifiableBindingExpression.java b/java/dagger/internal/codegen/AbstractMethodModifiableBindingExpression.java
new file mode 100644
index 000000000..8d1efdbaf
--- /dev/null
+++ b/java/dagger/internal/codegen/AbstractMethodModifiableBindingExpression.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.RequestKinds.requestTypeName;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import dagger.model.Key;
+import dagger.model.RequestKind;
+
+/**
+ * A {@link BindingExpression} that invokes a method that encapsulates a binding that cannot be
+ * satisfied when generating the abstract base class implementation of a subcomponent. The
+ * (unimplemented) method is added to the {@link GeneratedComponentModel} when the dependency
+ * expression is requested. The method is overridden when generating the implementation of an
+ * ancestor component.
+ */
+abstract class AbstractMethodModifiableBindingExpression extends BindingExpression {
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ModifiableBindingType modifiableBindingType;
+  private final Key key;
+  private final RequestKind kind;
+  private String methodName;
+
+  AbstractMethodModifiableBindingExpression(
+      GeneratedComponentModel generatedComponentModel,
+      ModifiableBindingType modifiableBindingType,
+      Key key,
+      RequestKind kind) {
+    this.generatedComponentModel = generatedComponentModel;
+    this.modifiableBindingType = modifiableBindingType;
+    this.key = key;
+    this.kind = kind;
+  }
+
+  @Override
+  final Expression getDependencyExpression(ClassName requestingClass) {
+    addUnimplementedMethod();
+    return Expression.create(key.type(), CodeBlock.of("$L()", methodName));
+  }
+
+  private void addUnimplementedMethod() {
+    if (methodName == null) {
+      // Only add the method once in case of repeated references to the missing binding.
+      methodName = chooseMethodName();
+      generatedComponentModel.addModifiableBindingMethod(
+          modifiableBindingType,
+          key,
+          kind,
+          MethodSpec.methodBuilder(methodName)
+              .addModifiers(PUBLIC, ABSTRACT)
+              .returns(requestTypeName(kind, TypeName.get(key.type())))
+              .build());
+    }
+  }
+
+  /** Returns a unique 'getter' method name for the current component. */
+  abstract String chooseMethodName();
+}
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 558ee7d4d..ee0887e8c 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -176,6 +176,7 @@ java_library(
         "ComponentHierarchyValidator.java",
         "ComponentValidator.java",
         "DependencyRequestFormatter.java",
+        "DependencyRequestValidator.java",
         "ForReleasableReferencesValidator.java",
         "InjectValidator.java",
         "MapKeyValidator.java",
@@ -198,8 +199,8 @@ java_library(
 java_library(
     name = "binding_graph_validation",
     srcs = [
-        "BindingCycleValidation.java",
         "BindingGraphValidationModule.java",
+        "DependencyCycleValidation.java",
         "DependsOnProductionExecutorValidator.java",
         "DuplicateBindingsValidation.java",
         "IncompatiblyScopedBindingsValidation.java",
@@ -208,7 +209,7 @@ java_library(
         "MapMultibindingValidation.java",
         "MembersInjectionBindingValidation.java",
         "MissingBindingValidation.java",
-        "NonNullableRequestForNullableBindingValidation.java",
+        "NullableBindingValidation.java",
         "ProvisionDependencyOnProducerBindingValidation.java",
         "SubcomponentFactoryMethodValidation.java",
         "Validation.java",
@@ -226,15 +227,14 @@ java_library(
 java_library(
     name = "writing",
     srcs = [
+        "AbstractMethodModifiableBindingExpression.java",
         "AnnotationCreatorGenerator.java",
         "BindingExpression.java",
         "BindingMethodImplementation.java",
         "ComponentBindingExpressions.java",
         "ComponentBuilder.java",
-        "ComponentGenerator.java",
         "ComponentInstanceBindingExpression.java",
         "ComponentMethodBindingExpression.java",
-        "ComponentModelBuilder.java",
         "ComponentProvisionBindingExpression.java",
         "ComponentRequirementBindingExpression.java",
         "ComponentRequirementField.java",
@@ -243,7 +243,7 @@ java_library(
         "DelegatingFrameworkInstanceCreationExpression.java",
         "DependencyMethodProducerCreationExpression.java",
         "DependencyMethodProviderCreationExpression.java",
-        "DerivedFromProviderBindingExpression.java",
+        "DerivedFromFrameworkInstanceBindingExpression.java",
         "DoubleCheckedMethodImplementation.java",
         "FactoryGenerator.java",
         "FrameworkFieldInitializer.java",
@@ -267,6 +267,8 @@ java_library(
         "MembersInjectorProviderCreationExpression.java",
         "MethodBindingExpression.java",
         "MissingBindingExpression.java",
+        "ModifiableBindingMethods.java",
+        "ModifiableBindingType.java",
         "MonitoringModuleGenerator.java",
         "MonitoringModuleProcessingStep.java",
         "OptionalBindingExpression.java",
@@ -276,7 +278,9 @@ java_library(
         "ProducerCreationExpression.java",
         "ProducerFactoryGenerator.java",
         "ProducerFromProviderCreationExpression.java",
+        "ProducerInstanceBindingExpression.java",
         "ProductionExecutorModuleGenerator.java",
+        "ProviderInstanceBindingExpression.java",
         "ReferenceReleasingManagerFields.java",
         "ReleasableReferenceManagerProviderCreationExpression.java",
         "ReleasableReferenceManagerSetProviderCreationExpression.java",
@@ -310,7 +314,9 @@ java_library(
         "BindingGraphPluginsModule.java",
         "BindingMethodValidatorsModule.java",
         "CanReleaseReferencesProcessingStep.java",
+        "ComponentGenerator.java",
         "ComponentHjarProcessingStep.java",
+        "ComponentModelBuilder.java",
         "ComponentProcessingStep.java",
         "ComponentProcessor.java",
         "DiagnosticReporterFactory.java",
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index d92cd97e0..b15852aa5 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -40,11 +40,11 @@ boolean requiresMethodEncapsulation() {
   /**
    * Returns an expression for the implementation of a component method with the given request.
    *
-   * @param componentName the component that will contain the implemented method
+   * @param component the component that will contain the implemented method
    */
   CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, ClassName componentName) {
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
     // By default, just delegate to #getDependencyExpression().
-    return CodeBlock.of("return $L;", getDependencyExpression(componentName).codeBlock());
+    return CodeBlock.of("return $L;", getDependencyExpression(component.name()).codeBlock());
   }
 }
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index 533f4344b..c8bca9785 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreTypes.asTypeElement;
+import static dagger.internal.codegen.DaggerGraphs.unreachableNodes;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.presentValues;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
@@ -28,6 +29,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.graph.MutableNetwork;
+import com.google.common.graph.Network;
 import com.google.common.graph.NetworkBuilder;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.BindingGraph.BindingNode;
@@ -63,9 +65,26 @@
   dagger.model.BindingGraph convert(BindingGraph rootGraph) {
     Traverser traverser = new Traverser(rootGraph);
     traverser.traverseComponents();
+
+    // When bindings are copied down into child graphs because they transitively depend on local
+    // multibindings or optional bindings, the parent-owned binding is still there. If that
+    // parent-owned binding is not reachable from its component, it doesn't need to be in the graph
+    // because it will never be used. So remove all nodes that are not reachable from the root
+    // component.
+    unreachableNodes(traverser.network.asGraph(), rootComponentNode(traverser.network))
+        .forEach(traverser.network::removeNode);
+
     return BindingGraphProxies.bindingGraph(traverser.network);
   }
 
+  // TODO(dpb): Example of BindingGraph logic applied to derived networks.
+  private ComponentNode rootComponentNode(Network<Node, Edge> network) {
+    return (ComponentNode)
+        Iterables.find(
+            network.nodes(),
+            node -> node instanceof ComponentNode && node.componentPath().atRoot());
+  }
+
   private final class Traverser extends ComponentTreeTraverser {
 
     private final MutableNetwork<Node, Edge> network =
diff --git a/java/dagger/internal/codegen/BindingGraphValidationModule.java b/java/dagger/internal/codegen/BindingGraphValidationModule.java
index 7ed179f63..9dfa285a9 100644
--- a/java/dagger/internal/codegen/BindingGraphValidationModule.java
+++ b/java/dagger/internal/codegen/BindingGraphValidationModule.java
@@ -28,7 +28,7 @@
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin bindingCycle(BindingCycleValidation validation);
+  BindingGraphPlugin dependencyCycle(DependencyCycleValidation validation);
 
   @Binds
   @IntoSet
@@ -68,12 +68,12 @@
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin nullable(NonNullableRequestForNullableBindingValidation validation);
+  BindingGraphPlugin nullableBinding(NullableBindingValidation validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin providerDependsOnProducer(
+  BindingGraphPlugin provisionDependencyOnProducerBinding(
       ProvisionDependencyOnProducerBindingValidation validation);
 
   @Binds
diff --git a/java/dagger/internal/codegen/BindingMethodValidator.java b/java/dagger/internal/codegen/BindingMethodValidator.java
index 8854f13e5..32bc9f0fc 100644
--- a/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -46,6 +46,7 @@
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
@@ -55,6 +56,7 @@
 
   private final DaggerElements elements;
   private final Types types;
+  private final DependencyRequestValidator dependencyRequestValidator;
   private final Class<? extends Annotation> methodAnnotation;
   private final ImmutableSet<? extends Class<? extends Annotation>> enclosingElementAnnotations;
   private final Abstractness abstractness;
@@ -72,6 +74,7 @@
   protected BindingMethodValidator(
       DaggerElements elements,
       Types types,
+      DependencyRequestValidator dependencyRequestValidator,
       Class<? extends Annotation> methodAnnotation,
       Class<? extends Annotation> enclosingElementAnnotation,
       Abstractness abstractness,
@@ -82,6 +85,7 @@ protected BindingMethodValidator(
         types,
         methodAnnotation,
         ImmutableSet.of(enclosingElementAnnotation),
+        dependencyRequestValidator,
         abstractness,
         exceptionSuperclass,
         allowsMultibindings);
@@ -99,6 +103,7 @@ protected BindingMethodValidator(
       Types types,
       Class<? extends Annotation> methodAnnotation,
       Iterable<? extends Class<? extends Annotation>> enclosingElementAnnotations,
+      DependencyRequestValidator dependencyRequestValidator,
       Abstractness abstractness,
       ExceptionSuperclass exceptionSuperclass,
       AllowsMultibindings allowsMultibindings) {
@@ -106,6 +111,7 @@ protected BindingMethodValidator(
     this.types = types;
     this.methodAnnotation = methodAnnotation;
     this.enclosingElementAnnotations = ImmutableSet.copyOf(enclosingElementAnnotations);
+    this.dependencyRequestValidator = dependencyRequestValidator;
     this.abstractness = abstractness;
     this.exceptionSuperclass = exceptionSuperclass;
     this.allowsMultibindings = allowsMultibindings;
@@ -153,6 +159,7 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkMapKeys(builder);
     checkMultibindings(builder);
     checkScopes(builder);
+    checkParameters(builder);
   }
 
   /**
@@ -300,7 +307,10 @@ protected void checkQualifiers(ValidationReport.Builder<ExecutableElement> build
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(builder.getSubject());
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError("Cannot use more than one @Qualifier", builder.getSubject(), qualifier);
+        builder.addError(
+            bindingMethods("may not use more than one @Qualifier"),
+            builder.getSubject(),
+            qualifier);
       }
     }
   }
@@ -374,6 +384,22 @@ protected void checkScopes(ValidationReport.Builder<ExecutableElement> builder)
     }
   }
 
+  /** Adds errors for the method parameters. */
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+    for (VariableElement parameter : builder.getSubject().getParameters()) {
+      checkParameter(builder, parameter);
+    }
+  }
+
+  /**
+   * Adds errors for a method parameter. This implementation reports an error if the parameter has
+   * more than one qualifier.
+   */
+  protected void checkParameter(
+      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
+    dependencyRequestValidator.validateDependencyRequest(builder, parameter, parameter.asType());
+  }
+
   /** Adds an error if the method returns a {@linkplain FrameworkTypes framework type}. */
   protected void checkFrameworkType(ValidationReport.Builder<ExecutableElement> builder) {
     if (FrameworkTypes.isFrameworkType(builder.getSubject().getReturnType())) {
diff --git a/java/dagger/internal/codegen/BindsMethodValidator.java b/java/dagger/internal/codegen/BindsMethodValidator.java
index 78909e84e..a9b15d135 100644
--- a/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
@@ -26,7 +25,6 @@
 import dagger.Binds;
 import dagger.Module;
 import dagger.producers.ProducerModule;
-import java.util.List;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
@@ -41,12 +39,14 @@
   private final BindsTypeChecker bindsTypeChecker;
 
   @Inject
-  BindsMethodValidator(DaggerElements elements, Types types) {
+  BindsMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         Binds.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         RUNTIME_EXCEPTION,
         ALLOWS_MULTIBINDINGS);
@@ -60,29 +60,36 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkParameters(builder);
   }
 
-  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     ExecutableElement method = builder.getSubject();
-    List<? extends VariableElement> parameters = method.getParameters();
-    if (parameters.size() == 1) {
-      VariableElement parameter = getOnlyElement(parameters);
-      TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
-      TypeMirror rightHandSide = parameter.asType();
-      ContributionType contributionType = ContributionType.fromBindingMethod(method);
-      if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
-        builder.addError(
-            "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter");
-      }
-
-      if (!bindsTypeChecker.isAssignable(rightHandSide, leftHandSide, contributionType)) {
-        // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
-        // right-hand-side might not be assignable to the left-hand-side, but still compatible with
-        // Set.addAll(Collection<? extends E>)
-        builder.addError("@Binds methods' parameter type must be assignable to the return type");
-      }
+    if (method.getParameters().size() != 1) {
+      builder.addError(
+          bindingMethods(
+              "must have exactly one parameter, whose type is assignable to the return type"));
     } else {
+      super.checkParameters(builder);
+    }
+  }
+
+  @Override
+  protected void checkParameter(
+      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
+    super.checkParameter(builder, parameter);
+    ExecutableElement method = builder.getSubject();
+    TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
+    TypeMirror rightHandSide = parameter.asType();
+    ContributionType contributionType = ContributionType.fromBindingMethod(method);
+    if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
       builder.addError(
-          "@Binds methods must have exactly one parameter, "
-              + "whose type is assignable to the return type");
+          "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter");
+    }
+
+    if (!bindsTypeChecker.isAssignable(rightHandSide, leftHandSide, contributionType)) {
+      // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
+      // right-hand-side might not be assignable to the left-hand-side, but still compatible with
+      // Set.addAll(Collection<? extends E>)
+      builder.addError("@Binds methods' parameter type must be assignable to the return type");
     }
   }
 
diff --git a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
index dfb84ab69..c12dd78d7 100644
--- a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -42,12 +42,14 @@
   private final Types types;
 
   @Inject
-  BindsOptionalOfMethodValidator(DaggerElements elements, Types types) {
+  BindsOptionalOfMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         BindsOptionalOf.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         NO_EXCEPTIONS,
         NO_MULTIBINDINGS);
@@ -74,7 +76,8 @@ protected void checkKeyType(
     }
   }
 
-  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getParameters().isEmpty()) {
       builder.addError("@BindsOptionalOf methods cannot have parameters");
     }
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 92c0233ec..3516812b6 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
@@ -30,6 +31,7 @@
 import static dagger.model.BindingKind.DELEGATE;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
 import static dagger.model.BindingKind.MULTIBOUND_SET;
+import static javax.lang.model.element.Modifier.PUBLIC;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.HashBasedTable;
@@ -40,6 +42,7 @@
 import com.squareup.javapoet.MethodSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
@@ -234,18 +237,66 @@ Expression getDependencyArgumentExpression(
     return dependencyExpression;
   }
 
-  /** Returns the implementation of a component method. */
-  MethodSpec getComponentMethod(ComponentMethodDescriptor componentMethod) {
+  /**
+   * Returns the implementation of a component method. Returns {@link Optional#empty} if the
+   * component method implementation should not be emitted.
+   */
+  Optional<MethodSpec> getComponentMethod(ComponentMethodDescriptor componentMethod) {
     checkArgument(componentMethod.dependencyRequest().isPresent());
     DependencyRequest dependencyRequest = componentMethod.dependencyRequest().get();
-    return MethodSpec.overriding(
+    MethodSpec.Builder methodBuilder =
+        MethodSpec.overriding(
             componentMethod.methodElement(),
             MoreTypes.asDeclared(graph.componentType().asType()),
-            types)
-        .addCode(
-            getBindingExpression(dependencyRequest.key(), dependencyRequest.kind())
-                .getComponentMethodImplementation(componentMethod, generatedComponentModel.name()))
-        .build();
+            types);
+
+    ModifiableBindingType type =
+        getModifiableBindingType(dependencyRequest.key(), dependencyRequest.kind());
+    if (type.isModifiable()) {
+      generatedComponentModel.registerModifiableBindingMethod(
+          type, dependencyRequest.key(), dependencyRequest.kind(), methodBuilder.build());
+      if (!type.hasBaseClassImplementation()) {
+        // A component method should not be emitted if it encapsulates a modifiable binding that
+        // cannot be satisfied by the abstract base class implementation of a subcomponent.
+        checkState(
+            !generatedComponentModel.supermodel().isPresent(),
+            "Attempting to generate a component method in a subtype of the abstract subcomponent "
+                + "base class.");
+        return Optional.empty();
+      }
+    }
+
+    return Optional.of(
+        methodBuilder
+            .addCode(
+                getBindingExpression(dependencyRequest.key(), dependencyRequest.kind())
+                    .getComponentMethodImplementation(componentMethod, generatedComponentModel))
+            .build());
+  }
+
+  /**
+   * Returns the implementation of a method encapsulating a modifiable binding in a supertype
+   * implementation of this subcomponent. Returns {@link Optional#empty()} when the binding cannot
+   * or should not be modified by the current binding graph. This is only relevant for ahead-of-time
+   * subcomponents.
+   */
+  Optional<MethodSpec> getModifiableBindingMethod(ModifiableBindingMethod modifiableBindingMethod) {
+    if (shouldOverrideModifiableBindingMethod(modifiableBindingMethod)) {
+      Expression bindingExpression =
+          getDependencyExpression(
+              modifiableBindingMethod.key(),
+              modifiableBindingMethod.kind(),
+              generatedComponentModel.name());
+      MethodSpec baseMethod = modifiableBindingMethod.baseMethod();
+      return Optional.of(
+          MethodSpec.methodBuilder(baseMethod.name)
+              .addModifiers(PUBLIC)
+              .returns(baseMethod.returnType)
+              .addAnnotation(Override.class)
+              .addStatement("return $L", bindingExpression.codeBlock())
+              .build());
+    }
+    return Optional.empty();
   }
 
   private BindingExpression getBindingExpression(Key key, RequestKind requestKind) {
@@ -253,11 +304,13 @@ private BindingExpression getBindingExpression(Key key, RequestKind requestKind)
       return expressions.get(key, requestKind);
     }
     Optional<BindingExpression> expression = Optional.empty();
-    if (resolvedInThisComponent(key, requestKind)) {
+    ModifiableBindingType modifiableBindingType = getModifiableBindingType(key, requestKind);
+    if (modifiableBindingType.isModifiable()) {
+      expression =
+          Optional.of(createModifiableBindingExpression(modifiableBindingType, key, requestKind));
+    } else if (resolvedInThisComponent(key, requestKind)) {
       ResolvedBindings resolvedBindings = graph.resolvedBindings(requestKind, key);
       expression = Optional.of(createBindingExpression(resolvedBindings, requestKind));
-    } else if (!resolvableBinding(key, requestKind) && generatedComponentModel.isAbstract()) {
-      expression = Optional.of(new MissingBindingExpression(key));
     }
     if (expression.isPresent()) {
       expressions.put(key, requestKind, expression.get());
@@ -270,9 +323,6 @@ private BindingExpression getBindingExpression(Key key, RequestKind requestKind)
   /** Creates a binding expression. */
   private BindingExpression createBindingExpression(
       ResolvedBindings resolvedBindings, RequestKind requestKind) {
-    if (generatedInstanceForAbstractSubcomponent(resolvedBindings)) {
-      return new GeneratedInstanceBindingExpression(resolvedBindings);
-    }
     switch (resolvedBindings.bindingType()) {
       case MEMBERS_INJECTION:
         checkArgument(requestKind.equals(RequestKind.MEMBERS_INJECTION));
@@ -282,7 +332,12 @@ private BindingExpression createBindingExpression(
         return provisionBindingExpression(resolvedBindings, requestKind);
 
       case PRODUCTION:
-        return frameworkInstanceBindingExpression(resolvedBindings, requestKind);
+        if (requestKind.equals(RequestKind.PRODUCER)) {
+          return frameworkInstanceBindingExpression(resolvedBindings);
+        } else {
+          return new DerivedFromFrameworkInstanceBindingExpression(
+              resolvedBindings, requestKind, this, types);
+        }
 
       default:
         throw new AssertionError(resolvedBindings);
@@ -290,13 +345,81 @@ private BindingExpression createBindingExpression(
   }
 
   /**
-   * Returns true if the binding exposes an instance of a generated type, but no concrete
-   * implementation of that type is available.
+   * Creates a binding expression for a binding that may be modified across implementations of a
+   * subcomponent. This is only relevant for ahead-of-time subcomponents.
+   */
+  private BindingExpression createModifiableBindingExpression(
+      ModifiableBindingType type, Key key, RequestKind requestKind) {
+    switch (type) {
+      case GENERATED_INSTANCE:
+        ResolvedBindings resolvedBindings = graph.resolvedBindings(requestKind, key);
+        return new GeneratedInstanceBindingExpression(
+            generatedComponentModel, resolvedBindings, requestKind);
+      case MISSING:
+        return new MissingBindingExpression(generatedComponentModel, key, requestKind);
+      default:
+        throw new IllegalStateException(
+            String.format(
+                "Building binding expression for unsupported ModifiableBindingType [%s].", type));
+    }
+  }
+
+  /**
+   * The reason why a binding may need to be modified across implementations of a subcomponent, if
+   * at all. This is only relevant for ahead-of-time subcomponents.
+   */
+  private ModifiableBindingType getModifiableBindingType(Key key, RequestKind requestKind) {
+    if (!compilerOptions.aheadOfTimeSubcomponents()) {
+      return ModifiableBindingType.NONE;
+    }
+
+    // When generating a final (concrete) implementation of a (sub)component the binding is no
+    // longer considered modifiable. It cannot be further modified by a subclass implementation.
+    if (!generatedComponentModel.isAbstract()) {
+      return ModifiableBindingType.NONE;
+    }
+
+    if (resolvedInThisComponent(key, requestKind)) {
+      ResolvedBindings resolvedBindings = graph.resolvedBindings(requestKind, key);
+      if (resolvedBindings.contributionBindings().isEmpty()) {
+        // TODO(ronshapiro): Confirm whether a resolved binding must have a single contribution
+        // binding.
+        return ModifiableBindingType.NONE;
+      }
+
+      ContributionBinding binding = resolvedBindings.contributionBinding();
+      if (binding.requiresGeneratedInstance()) {
+        return ModifiableBindingType.GENERATED_INSTANCE;
+      }
+    } else if (!resolvableBinding(key, requestKind)) {
+      return ModifiableBindingType.MISSING;
+    }
+
+    // TODO(b/72748365): Add support for remaining types.
+    return ModifiableBindingType.NONE;
+  }
+
+  /**
+   * Returns true if the current binding graph can, and should, modify a binding by overriding a
+   * modfiable binding method. This is only relevant for ahead-of-time subcomponents.
    */
-  private boolean generatedInstanceForAbstractSubcomponent(ResolvedBindings resolvedBindings) {
-    return !resolvedBindings.contributionBindings().isEmpty()
-        && resolvedBindings.contributionBinding().requiresGeneratedInstance()
-        && generatedComponentModel.isAbstract();
+  private boolean shouldOverrideModifiableBindingMethod(
+      ModifiableBindingMethod modifiableBindingMethod) {
+    switch (modifiableBindingMethod.type()) {
+      case GENERATED_INSTANCE:
+        return !generatedComponentModel.isAbstract();
+      case MISSING:
+        // TODO(b/72748365): investigate beder@'s comment about having intermediate component
+        // ancestors satisfy missing bindings of their children with their own missing binding
+        // methods so that we can minimize the cases where we need to reach into doubly-nested
+        // descendant component implementations
+        return resolvableBinding(modifiableBindingMethod.key(), modifiableBindingMethod.kind());
+      default:
+        throw new IllegalStateException(
+            String.format(
+                "Overriding modifiable binding method with unsupported ModifiableBindingType [%s].",
+                modifiableBindingMethod.type()));
+    }
   }
 
   /**
@@ -325,7 +448,7 @@ private boolean resolvedInThisComponent(Key key, RequestKind requestKind) {
    * or a {@link dagger.producers.Producer} for production bindings.
    */
   private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
-      ResolvedBindings resolvedBindings, RequestKind requestKind) {
+      ResolvedBindings resolvedBindings) {
     // TODO(user): Consider merging the static factory creation logic into CreationExpressions?
     Optional<MemberSelect> staticMethod =
         useStaticFactoryCreation(resolvedBindings.contributionBinding())
@@ -335,17 +458,23 @@ private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
         resolvedBindings.scope().isPresent()
             ? scope(resolvedBindings, frameworkInstanceCreationExpression(resolvedBindings))
             : frameworkInstanceCreationExpression(resolvedBindings);
-    return new FrameworkInstanceBindingExpression(
-        resolvedBindings,
-        requestKind,
-        this,
-        resolvedBindings.bindingType().frameworkType(),
+    FrameworkInstanceSupplier frameworkInstanceSupplier =
         staticMethod.isPresent()
             ? staticMethod::get
             : new FrameworkFieldInitializer(
-                generatedComponentModel, resolvedBindings, frameworkInstanceCreationExpression),
-        types,
-        elements);
+                generatedComponentModel, resolvedBindings, frameworkInstanceCreationExpression);
+
+    FrameworkType frameworkType = resolvedBindings.bindingType().frameworkType();
+    switch (frameworkType) {
+      case PROVIDER:
+        return new ProviderInstanceBindingExpression(
+            resolvedBindings, frameworkInstanceSupplier, types, elements);
+      case PRODUCER:
+        return new ProducerInstanceBindingExpression(
+            resolvedBindings, frameworkInstanceSupplier, types, elements);
+      default:
+        throw new AssertionError("invalid framework type: " + frameworkType);
+    }
   }
 
   private FrameworkInstanceCreationExpression scope(
@@ -463,10 +592,11 @@ private BindingExpression provisionBindingExpression(
       case LAZY:
       case PRODUCED:
       case PROVIDER_OF_LAZY:
-        return new DerivedFromProviderBindingExpression(resolvedBindings, requestKind, this, types);
+        return new DerivedFromFrameworkInstanceBindingExpression(
+            resolvedBindings, requestKind, this, types);
 
       case PRODUCER:
-        return producerFromProviderBindingExpression(resolvedBindings, requestKind);
+        return producerFromProviderBindingExpression(resolvedBindings);
 
       case FUTURE:
         return new ImmediateFutureBindingExpression(resolvedBindings, this, types);
@@ -498,13 +628,13 @@ private BindingExpression providerBindingExpression(ResolvedBindings resolvedBin
     } else if (compilerOptions.fastInit()
         && frameworkInstanceCreationExpression(resolvedBindings).useInnerSwitchingProvider()
         && !(instanceBindingExpression(resolvedBindings)
-        instanceof DerivedFromProviderBindingExpression)) {
+            instanceof DerivedFromFrameworkInstanceBindingExpression)) {
       return wrapInMethod(
           resolvedBindings,
           RequestKind.PROVIDER,
           innerSwitchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
     }
-    return frameworkInstanceBindingExpression(resolvedBindings, RequestKind.PROVIDER);
+    return frameworkInstanceBindingExpression(resolvedBindings);
   }
 
   /**
@@ -512,13 +642,10 @@ private BindingExpression providerBindingExpression(ResolvedBindings resolvedBin
    * provision binding.
    */
   private FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
-      ResolvedBindings resolvedBindings, RequestKind requestKind) {
+      ResolvedBindings resolvedBindings) {
     checkArgument(resolvedBindings.bindingType().frameworkType().equals(FrameworkType.PROVIDER));
-    return new FrameworkInstanceBindingExpression(
+    return new ProducerInstanceBindingExpression(
         resolvedBindings,
-        requestKind,
-        this,
-        FrameworkType.PRODUCER,
         new FrameworkFieldInitializer(
             generatedComponentModel,
             resolvedBindings,
@@ -551,7 +678,7 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
           ? wrapInMethod(resolvedBindings, RequestKind.INSTANCE, directInstanceExpression)
           : directInstanceExpression;
     }
-    return new DerivedFromProviderBindingExpression(
+    return new DerivedFromFrameworkInstanceBindingExpression(
         resolvedBindings, RequestKind.INSTANCE, this, types);
   }
 
diff --git a/java/dagger/internal/codegen/ComponentBuilder.java b/java/dagger/internal/codegen/ComponentBuilder.java
index a9f6aff16..d4ad5fd5f 100644
--- a/java/dagger/internal/codegen/ComponentBuilder.java
+++ b/java/dagger/internal/codegen/ComponentBuilder.java
@@ -101,6 +101,7 @@ private static boolean hasBuilder(ComponentDescriptor component) {
     private final TypeSpec.Builder builder;
     private final GeneratedComponentModel generatedComponentModel;
     private final ClassName builderName;
+    private final SubcomponentNames subcomponentNames;
     private final Elements elements;
     private final Types types;
 
@@ -121,6 +122,7 @@ private static boolean hasBuilder(ComponentDescriptor component) {
         builder = classBuilder(builderName);
       }
       this.graph = graph;
+      this.subcomponentNames = subcomponentNames;
       this.elements = elements;
       this.types = types;
     }
@@ -132,7 +134,7 @@ ComponentBuilder create() {
         } else {
           builder.addModifiers(PRIVATE);
         }
-        addSupertype(builder, builderSpec().get().builderDefinitionType());
+        setSupertype();
       } else {
         builder.addModifiers(PUBLIC).addMethod(constructorBuilder().addModifiers(PRIVATE).build());
       }
@@ -155,6 +157,27 @@ ComponentBuilder create() {
       return new ComponentBuilder(builder.build(), builderName, builderFields);
     }
 
+    /** Set the superclass being extended or interface being implemented for this builder. */
+    private void setSupertype() {
+      if (generatedComponentModel.supermodel().isPresent()) {
+        // If there's a superclass, extend the Builder defined there.
+        GeneratedComponentModel subcomponentSupermodel = generatedComponentModel.supermodel().get();
+        if (subcomponentSupermodel.isNested()) {
+          // If the subcomponent superclass is nested we're overriding the builder that was
+          // defined as a peer of the superclass.
+          builder.superclass(
+              subcomponentSupermodel
+                  .name()
+                  .peerClass(subcomponentNames.get(graph.componentDescriptor()) + "Builder"));
+        } else {
+          // Otherwise we're extending the builder defined inside the subcomponent definition.
+          builder.superclass(subcomponentSupermodel.name().nestedClass("Builder"));
+        }
+      } else {
+        addSupertype(builder, builderSpec().get().builderDefinitionType());
+      }
+    }
+
     /**
      * Computes fields for each of the {@linkplain BindingGraph#componentRequirements component
      * requirements}. Regardless of builder spec, there is always one field per requirement.
diff --git a/java/dagger/internal/codegen/ComponentGenerator.java b/java/dagger/internal/codegen/ComponentGenerator.java
index 4420d6332..1dc14b933 100644
--- a/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/java/dagger/internal/codegen/ComponentGenerator.java
@@ -36,6 +36,7 @@
   private final DaggerElements elements;
   private final KeyFactory keyFactory;
   private final CompilerOptions compilerOptions;
+  private final BindingGraphFactory bindingGraphFactory;
 
   @Inject
   ComponentGenerator(
@@ -44,12 +45,14 @@
       SourceVersion sourceVersion,
       DaggerTypes types,
       KeyFactory keyFactory,
-      CompilerOptions compilerOptions) {
+      CompilerOptions compilerOptions,
+      BindingGraphFactory bindingGraphFactory) {
     super(filer, elements, sourceVersion);
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.compilerOptions = compilerOptions;
+    this.bindingGraphFactory = bindingGraphFactory;
   }
 
   @Override
@@ -71,7 +74,13 @@ static ClassName componentName(TypeElement componentDefinitionType) {
   Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
     return Optional.of(
         ComponentModelBuilder.buildComponentModel(
-                types, elements, keyFactory, compilerOptions, componentName, input)
+                types,
+                elements,
+                keyFactory,
+                compilerOptions,
+                componentName,
+                input,
+                bindingGraphFactory)
             .generate());
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index 2a53a223c..760c73523 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -45,7 +45,7 @@
 
   @Override
   protected CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, ClassName componentName) {
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
     // There could be several methods on the component for the same request key and kind.
     // Only one should use the BindingMethodImplementation; the others can delegate that one. So
     // use methodImplementation.body() only if componentMethod equals the method for this instance.
@@ -55,10 +55,9 @@ protected CodeBlock getComponentMethodImplementation(
     // for the parent and the child. Only the parent's should use the BindingMethodImplementation;
     // the child's can delegate to the parent. So use methodImplementation.body() only if
     // componentName equals the component for this instance.
-    return componentMethod.equals(this.componentMethod)
-            && componentName.equals(generatedComponentModel.name())
+    return componentMethod.equals(this.componentMethod) && component.equals(generatedComponentModel)
         ? methodImplementation.body()
-        : super.getComponentMethodImplementation(componentMethod, componentName);
+        : super.getComponentMethodImplementation(componentMethod, component);
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/ComponentModelBuilder.java b/java/dagger/internal/codegen/ComponentModelBuilder.java
index be99cfe8b..d3a387276 100644
--- a/java/dagger/internal/codegen/ComponentModelBuilder.java
+++ b/java/dagger/internal/codegen/ComponentModelBuilder.java
@@ -48,11 +48,11 @@
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import java.util.List;
 import java.util.Optional;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.util.Elements;
 
 /** Builds the model for an implementation of a component or subcomponent. */
 abstract class ComponentModelBuilder {
@@ -62,7 +62,8 @@ static GeneratedComponentModel buildComponentModel(
       KeyFactory keyFactory,
       CompilerOptions compilerOptions,
       ClassName name,
-      BindingGraph graph) {
+      BindingGraph graph,
+      BindingGraphFactory bindingGraphFactory) {
     GeneratedComponentModel generatedComponentModel;
     if (graph.componentDescriptor().kind().isTopLevel()) {
       generatedComponentModel = GeneratedComponentModel.forComponent(name);
@@ -90,28 +91,35 @@ static GeneratedComponentModel buildComponentModel(
           compilerOptions.aheadOfTimeSubcomponents(),
           "Calling 'buildComponentModel()' on %s when not generating ahead-of-time subcomponents.",
           graph.componentDescriptor().componentDefinitionType());
-      return new BaseSubcomponentModelBuilder(
+      return new AbstractSubcomponentModelBuilder(
+              Optional.empty(), /* parent */
               types,
               elements,
+              keyFactory,
               graph,
               generatedComponentModel,
               subcomponentNames,
               optionalFactories,
               bindingExpressions,
               componentRequirementFields,
-              builder)
+              builder,
+              bindingGraphFactory,
+              compilerOptions)
           .build();
     } else {
       return new RootComponentModelBuilder(
               types,
               elements,
+              keyFactory,
               graph,
               generatedComponentModel,
               subcomponentNames,
               optionalFactories,
               bindingExpressions,
               componentRequirementFields,
-              builder)
+              builder,
+              bindingGraphFactory,
+              compilerOptions)
           .build();
     }
   }
@@ -138,8 +146,74 @@ private GeneratedComponentModel buildSubcomponentModel(BindingGraph childGraph)
         .build();
   }
 
-  private final Elements elements;
+  private GeneratedComponentModel buildAbstractInnerSubcomponentModel(BindingGraph childGraph) {
+    ClassName childName =
+        generatedComponentModel
+            .name()
+            .nestedClass(subcomponentNames.get(childGraph.componentDescriptor()) + "Impl");
+    GeneratedComponentModel supermodel =
+        getSubcomponentSupermodel(childGraph.componentDescriptor());
+    GeneratedComponentModel childModel =
+        GeneratedComponentModel.forAbstractSubcomponent(childName, supermodel);
+    Optional<ComponentBuilder> childBuilder =
+        ComponentBuilder.create(childModel, childGraph, subcomponentNames, elements, types);
+    ComponentRequirementFields childComponentRequirementFields =
+        componentRequirementFields.forChildComponent(childGraph, childModel, childBuilder);
+    ComponentBindingExpressions childBindingExpressions =
+        bindingExpressions.forChildComponent(
+            childGraph, childModel, childComponentRequirementFields);
+    return new AbstractSubcomponentModelBuilder(
+            Optional.of(this),
+            types,
+            elements,
+            keyFactory,
+            childGraph,
+            childModel,
+            subcomponentNames,
+            optionalFactories,
+            childBindingExpressions,
+            childComponentRequirementFields,
+            childBuilder,
+            bindingGraphFactory,
+            compilerOptions)
+        .build();
+  }
+
+  private GeneratedComponentModel getSubcomponentSupermodel(ComponentDescriptor subcomponent) {
+    // If the current model is for a subcomponent that has a defined supermodel, that supermodel
+    // should contain a reference to a model for `subcomponent`
+    if (generatedComponentModel.supermodel().isPresent()) {
+      Optional<GeneratedComponentModel> supermodel =
+          generatedComponentModel.supermodel().get().subcomponentModel(subcomponent);
+      checkState(
+          supermodel.isPresent(),
+          "Attempting to generate an implementation of a subcomponent [%s] whose parent is a "
+              + "subcomponent [%s], but whose supermodel is not present on the parent's "
+              + "supermodel.",
+          subcomponent.componentDefinitionType(),
+          graph.componentType());
+      return supermodel.get();
+    }
+
+    // Otherwise, the enclosing component is top-level, so we must generate the supermodel for the
+    // subcomponent. We do so by building the model for the abstract base class for the
+    // subcomponent. This is done by truncating the binding graph at the subcomponent.
+    BindingGraph truncatedBindingGraph = bindingGraphFactory.create(subcomponent);
+    return buildComponentModel(
+        // TODO(ronshapiro): extract a factory class here so that we don't need to pass around
+        // types, elements, keyFactory, etc...
+        types,
+        elements,
+        keyFactory,
+        compilerOptions,
+        ComponentGenerator.componentName(truncatedBindingGraph.componentType()),
+        truncatedBindingGraph,
+        bindingGraphFactory);
+  }
+
+  private final DaggerElements elements;
   private final DaggerTypes types;
+  private final KeyFactory keyFactory;
   private final BindingGraph graph;
   private final SubcomponentNames subcomponentNames;
   private final ComponentBindingExpressions bindingExpressions;
@@ -147,20 +221,26 @@ private GeneratedComponentModel buildSubcomponentModel(BindingGraph childGraph)
   private final GeneratedComponentModel generatedComponentModel;
   private final OptionalFactories optionalFactories;
   private final Optional<ComponentBuilder> builder;
+  private final BindingGraphFactory bindingGraphFactory;
+  private final CompilerOptions compilerOptions;
   private boolean done;
 
   private ComponentModelBuilder(
       DaggerTypes types,
-      Elements elements,
+      DaggerElements elements,
+      KeyFactory keyFactory,
       BindingGraph graph,
       GeneratedComponentModel generatedComponentModel,
       SubcomponentNames subcomponentNames,
       OptionalFactories optionalFactories,
       ComponentBindingExpressions bindingExpressions,
       ComponentRequirementFields componentRequirementFields,
-      Optional<ComponentBuilder> builder) {
+      Optional<ComponentBuilder> builder,
+      BindingGraphFactory bindingGraphFactory,
+      CompilerOptions compilerOptions) {
     this.types = types;
     this.elements = elements;
+    this.keyFactory = keyFactory;
     this.graph = graph;
     this.subcomponentNames = subcomponentNames;
     this.generatedComponentModel = generatedComponentModel;
@@ -168,6 +248,8 @@ private ComponentModelBuilder(
     this.bindingExpressions = bindingExpressions;
     this.componentRequirementFields = componentRequirementFields;
     this.builder = builder;
+    this.bindingGraphFactory = bindingGraphFactory;
+    this.compilerOptions = compilerOptions;
   }
 
   /**
@@ -180,7 +262,7 @@ protected final GeneratedComponentModel build() {
         !done,
         "ComponentModelBuilder has already built the GeneratedComponentModel for [%s].",
         generatedComponentModel.name());
-    generatedComponentModel.addSupertype(graph.componentType());
+    setSupertype();
     builder.map(ComponentBuilder::typeSpec).ifPresent(this::addBuilderClass);
 
     getLocalAndInheritedMethods(
@@ -196,6 +278,15 @@ protected final GeneratedComponentModel build() {
     return generatedComponentModel;
   }
 
+  /** Set the supertype for this generated class. */
+  private void setSupertype() {
+    if (generatedComponentModel.supermodel().isPresent()) {
+      generatedComponentModel.addSuperclass(generatedComponentModel.supermodel().get().name());
+    } else {
+      generatedComponentModel.addSupertype(graph.componentType());
+    }
+  }
+
   /**
    * Adds {@code builder} as a nested builder class. Root components and subcomponents will nest
    * this in different classes.
@@ -205,7 +296,7 @@ protected final GeneratedComponentModel build() {
   /** Adds component factory methods. */
   protected abstract void addFactoryMethods();
 
-  private void addInterfaceMethods() {
+  protected void addInterfaceMethods() {
     /* Each component method may have been declared by several supertypes. We want to implement only
      * one method for each distinct signature.*/
     ImmutableListMultimap<MethodSignature, ComponentMethodDescriptor> componentMethodsBySignature =
@@ -213,8 +304,9 @@ private void addInterfaceMethods() {
     for (List<ComponentMethodDescriptor> methodsWithSameSignature :
         Multimaps.asMap(componentMethodsBySignature).values()) {
       ComponentMethodDescriptor anyOneMethod = methodsWithSameSignature.stream().findAny().get();
-      generatedComponentModel.addMethod(
-          COMPONENT_METHOD, bindingExpressions.getComponentMethod(anyOneMethod));
+      bindingExpressions
+          .getComponentMethod(anyOneMethod)
+          .ifPresent(method -> generatedComponentModel.addMethod(COMPONENT_METHOD, method));
     }
   }
 
@@ -223,9 +315,13 @@ private MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
         method, MoreTypes.asDeclared(graph.componentType().asType()), types);
   }
 
-  protected void addSubcomponents() {
+  private void addSubcomponents() {
     for (BindingGraph subgraph : graph.subgraphs()) {
-      generatedComponentModel.addSubcomponent(buildSubcomponentModel(subgraph));
+      generatedComponentModel.addSubcomponent(
+          subgraph.componentDescriptor(),
+          generatedComponentModel.isAbstract()
+              ? buildAbstractInnerSubcomponentModel(subgraph)
+              : buildSubcomponentModel(subgraph));
     }
   }
 
@@ -242,6 +338,16 @@ private void addConstructor() {
             .addModifiers(generatedComponentModel.isAbstract() ? PROTECTED : PRIVATE)
             .addParameters(constructorParameters);
 
+    if (generatedComponentModel.supermodel().isPresent()) {
+      constructor.addStatement(
+          CodeBlock.of(
+              "super($L)",
+              constructorParameters
+                  .stream()
+                  .map(param -> CodeBlock.of("$N", param))
+                  .collect(toParametersCodeBlock())));
+    }
+
     ImmutableList<ParameterSpec> initializeParameters = initializeParameters();
     CodeBlock initializeParametersCodeBlock =
         constructorParameters
@@ -294,24 +400,30 @@ private void addConstructor() {
   private static final class RootComponentModelBuilder extends ComponentModelBuilder {
     RootComponentModelBuilder(
         DaggerTypes types,
-        Elements elements,
+        DaggerElements elements,
+        KeyFactory keyFactory,
         BindingGraph graph,
         GeneratedComponentModel generatedComponentModel,
         SubcomponentNames subcomponentNames,
         OptionalFactories optionalFactories,
         ComponentBindingExpressions bindingExpressions,
         ComponentRequirementFields componentRequirementFields,
-        Optional<ComponentBuilder> builder) {
+        Optional<ComponentBuilder> builder,
+        BindingGraphFactory bindingGraphFactory,
+        CompilerOptions compilerOptions) {
       super(
           types,
           elements,
+          keyFactory,
           graph,
           generatedComponentModel,
           subcomponentNames,
           optionalFactories,
           bindingExpressions,
           componentRequirementFields,
-          builder);
+          builder,
+          bindingGraphFactory,
+          compilerOptions);
     }
 
     @Override
@@ -358,7 +470,10 @@ private boolean canInstantiateAllRequirements() {
     }
   }
 
-  /** Builds the model for a nested subcomponent. */
+  /**
+   * Builds the model for a nested subcomponent. This is used when ahead-of-time components are not
+   * enabled (current default mode).
+   */
   private static final class SubComponentModelBuilder extends ComponentModelBuilder {
     private final ComponentModelBuilder parent;
 
@@ -372,13 +487,16 @@ private boolean canInstantiateAllRequirements() {
       super(
           parent.types,
           parent.elements,
+          parent.keyFactory,
           graph,
           generatedComponentModel,
           parent.subcomponentNames,
           parent.optionalFactories,
           bindingExpressions,
           componentRequirementFields,
-          builder);
+          builder,
+          parent.bindingGraphFactory,
+          parent.compilerOptions);
       this.parent = parent;
     }
 
@@ -413,36 +531,52 @@ private DeclaredType parentType() {
     }
   }
 
-  /** Builds the model for a top-level abstract base implementation of a subcomponent. */
-  private static final class BaseSubcomponentModelBuilder extends ComponentModelBuilder {
+  /** Builds the model for abstract implementations of a subcomponent. */
+  private static final class AbstractSubcomponentModelBuilder extends ComponentModelBuilder {
+    private final Optional<ComponentModelBuilder> parent;
     private final GeneratedComponentModel generatedComponentModel;
+    private final ComponentBindingExpressions bindingExpressions;
 
-    BaseSubcomponentModelBuilder(
+    AbstractSubcomponentModelBuilder(
+        Optional<ComponentModelBuilder> parent,
         DaggerTypes types,
-        Elements elements,
+        DaggerElements elements,
+        KeyFactory keyFactory,
         BindingGraph graph,
         GeneratedComponentModel generatedComponentModel,
         SubcomponentNames subcomponentNames,
         OptionalFactories optionalFactories,
         ComponentBindingExpressions bindingExpressions,
         ComponentRequirementFields componentRequirementFields,
-        Optional<ComponentBuilder> builder) {
+        Optional<ComponentBuilder> builder,
+        BindingGraphFactory bindingGraphFactory,
+        CompilerOptions compilerOptions) {
       super(
           types,
           elements,
+          keyFactory,
           graph,
           generatedComponentModel,
           subcomponentNames,
           optionalFactories,
           bindingExpressions,
           componentRequirementFields,
-          builder);
+          builder,
+          bindingGraphFactory,
+          compilerOptions);
+      this.parent = parent;
       this.generatedComponentModel = generatedComponentModel;
+      this.bindingExpressions = bindingExpressions;
     }
 
     @Override
     protected void addBuilderClass(TypeSpec builder) {
-      generatedComponentModel.addType(SUBCOMPONENT, builder);
+      if (parent.isPresent()) {
+        // If an inner implementation of a subcomponent the builder is a peer class.
+        parent.get().generatedComponentModel.addType(SUBCOMPONENT, builder);
+      } else {
+        generatedComponentModel.addType(SUBCOMPONENT, builder);
+      }
     }
 
     @Override
@@ -451,8 +585,24 @@ protected void addFactoryMethods() {
     }
 
     @Override
-    protected void addSubcomponents() {
-      // TODO(b/72748365): Implement abstract inner subcomponents.
+    protected void addInterfaceMethods() {
+      if (generatedComponentModel.supermodel().isPresent()) {
+        // Since we're overriding a subcomponent implementation we add to its implementation given
+        // an expanded binding graph.
+
+        // Override modifiable binding methods.
+        for (ModifiableBindingMethod modifiableBindingMethod :
+            generatedComponentModel.getModifiableBindingMethods()) {
+          bindingExpressions
+              .getModifiableBindingMethod(modifiableBindingMethod)
+              .ifPresent(
+                  method ->
+                      generatedComponentModel.addImplementedModifiableBindingMethod(
+                          modifiableBindingMethod, method));
+        }
+      } else {
+        super.addInterfaceMethods();
+      }
     }
   }
 
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index 671f0857a..3ed0ae801 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -82,6 +82,7 @@
   private final Types types;
   private final ModuleValidator moduleValidator;
   private final BuilderValidator builderValidator;
+  private final DependencyRequestValidator dependencyRequestValidator;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFactory dependencyRequestFactory;
 
@@ -91,12 +92,14 @@
       Types types,
       ModuleValidator moduleValidator,
       BuilderValidator builderValidator,
+      DependencyRequestValidator dependencyRequestValidator,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFactory dependencyRequestFactory) {
     this.elements = elements;
     this.types = types;
     this.moduleValidator = moduleValidator;
     this.builderValidator = builderValidator;
+    this.dependencyRequestValidator = dependencyRequestValidator;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFactory = dependencyRequestFactory;
   }
@@ -199,7 +202,8 @@ public ComponentValidationReport validate(
                 switch (parameters.size()) {
                   case 0:
                     // no parameters means that it is a provision method
-                    // basically, there are no restrictions here.  \o/
+                    dependencyRequestValidator.validateDependencyRequest(
+                        report, method, returnType);
                     break;
                   case 1:
                     // one parameter means that it's a members injection method
diff --git a/java/dagger/internal/codegen/DaggerGraphs.java b/java/dagger/internal/codegen/DaggerGraphs.java
index f0471da49..e9f384247 100644
--- a/java/dagger/internal/codegen/DaggerGraphs.java
+++ b/java/dagger/internal/codegen/DaggerGraphs.java
@@ -16,9 +16,14 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.collect.Sets.difference;
+import static com.google.common.graph.Graphs.reachableNodes;
+
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.graph.Graph;
 import com.google.common.graph.SuccessorsFunction;
+import dagger.model.BindingGraph.Node;
 import java.util.ArrayDeque;
 import java.util.HashMap;
 import java.util.Map;
@@ -85,5 +90,10 @@
     return ImmutableList.of();
   }
 
+  /** Returns the nodes in a graph that are not reachable from a node. */
+  static ImmutableSet<Node> unreachableNodes(Graph<Node> graph, Node node) {
+    return ImmutableSet.copyOf(difference(graph.nodes(), reachableNodes(graph, node)));
+  }
+
   private DaggerGraphs() {}
 }
diff --git a/java/dagger/internal/codegen/DaggerTypes.java b/java/dagger/internal/codegen/DaggerTypes.java
index 40f3b4188..a0f352ff2 100644
--- a/java/dagger/internal/codegen/DaggerTypes.java
+++ b/java/dagger/internal/codegen/DaggerTypes.java
@@ -23,6 +23,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.graph.Traverser;
 import com.google.common.util.concurrent.FluentFuture;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.ClassName;
@@ -65,6 +66,14 @@
     return Optional.ofNullable(MoreTypes.nonObjectSuperclass(types, elements, type).orNull());
   }
 
+  /**
+   * Returns the {@linkplain #directSupertypes(TypeMirror) supertype}s of a type in breadth-first
+   * order.
+   */
+  Iterable<TypeMirror> supertypes(TypeMirror type) {
+    return Traverser.<TypeMirror>forGraph(this::directSupertypes).breadthFirst(type);
+  }
+
   /**
    * Returns {@code type}'s single type argument.
    *
diff --git a/java/dagger/internal/codegen/BindingCycleValidation.java b/java/dagger/internal/codegen/DependencyCycleValidation.java
similarity index 96%
rename from java/dagger/internal/codegen/BindingCycleValidation.java
rename to java/dagger/internal/codegen/DependencyCycleValidation.java
index ed61c36b6..5e91fac1a 100644
--- a/java/dagger/internal/codegen/BindingCycleValidation.java
+++ b/java/dagger/internal/codegen/DependencyCycleValidation.java
@@ -55,19 +55,19 @@
 import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
 
-/** Reports errors for binding cycles. */
-final class BindingCycleValidation implements BindingGraphPlugin {
+/** Reports errors for dependency cycles. */
+final class DependencyCycleValidation implements BindingGraphPlugin {
 
   private final DependencyRequestFormatter dependencyRequestFormatter;
 
   @Inject
-  BindingCycleValidation(DependencyRequestFormatter dependencyRequestFormatter) {
+  DependencyCycleValidation(DependencyRequestFormatter dependencyRequestFormatter) {
     this.dependencyRequestFormatter = dependencyRequestFormatter;
   }
 
   @Override
   public String pluginName() {
-    return "Dagger/BindingCycle";
+    return "Dagger/DependencyCycle";
   }
 
   @Override
@@ -291,7 +291,7 @@ int size() {
       ImmutableSet.Builder<EndpointPair<N>> shifted = ImmutableSet.builder();
       shifted.addAll(skip(endpointPairs(), startIndex));
       shifted.addAll(limit(endpointPairs(), size() - startIndex));
-      return new AutoValue_BindingCycleValidation_Cycle<>(shifted.build());
+      return new AutoValue_DependencyCycleValidation_Cycle<>(shifted.build());
     }
 
     @Override
@@ -310,7 +310,7 @@ public final String toString() {
       for (int i = 0; i < nodes.size() - 1; i++) {
         cycle.add(EndpointPair.ordered(nodes.get(i), nodes.get(i + 1)));
       }
-      return new AutoValue_BindingCycleValidation_Cycle<>(cycle.build());
+      return new AutoValue_DependencyCycleValidation_Cycle<>(cycle.build());
     }
   }
 }
diff --git a/java/dagger/internal/codegen/DependencyRequestValidator.java b/java/dagger/internal/codegen/DependencyRequestValidator.java
new file mode 100644
index 000000000..eb9642215
--- /dev/null
+++ b/java/dagger/internal/codegen/DependencyRequestValidator.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.RequestKinds.extractKeyType;
+import static dagger.internal.codegen.RequestKinds.getRequestKind;
+import static javax.lang.model.type.TypeKind.WILDCARD;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+/** Validation for dependency requests. */
+final class DependencyRequestValidator {
+  @Inject
+  DependencyRequestValidator() {}
+
+  /**
+   * Adds an error if the given dependency request has more than one qualifier annotation or is a
+   * non-instance request with a wildcard type.
+   */
+  void validateDependencyRequest(
+      ValidationReport.Builder<?> report, Element requestElement, TypeMirror requestType) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(requestElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        report.addError(
+            "A single dependency request may not use more than one @Qualifier",
+            requestElement,
+            qualifier);
+      }
+    }
+
+    TypeMirror keyType = extractKeyType(getRequestKind(requestType), requestType);
+    if (keyType.getKind().equals(WILDCARD)) {
+      // TODO(ronshapiro): Explore creating this message using RequestKinds.
+      report.addError(
+          "Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, "
+              + "or Produced<T> when T is a wildcard type such as "
+              + keyType,
+          requestElement);
+    }
+  }
+
+  /**
+   * Adds an error if the given dependency request is for a {@link dagger.producers.Producer} or
+   * {@link dagger.producers.Produced}.
+   *
+   * <p>Only call this when processing a provision binding.
+   */
+  // TODO(dpb): Should we disallow Producer entry points in non-production components?
+  void checkNotProducer(ValidationReport.Builder<?> report, VariableElement requestElement) {
+    TypeMirror requestType = requestElement.asType();
+    if (FrameworkTypes.isProducerType(requestType)) {
+      report.addError(
+          String.format(
+              "%s may only be injected in @Produces methods",
+              MoreTypes.asTypeElement(requestType).getSimpleName()),
+          requestElement);
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/DerivedFromProviderBindingExpression.java b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
similarity index 78%
rename from java/dagger/internal/codegen/DerivedFromProviderBindingExpression.java
rename to java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
index 2dfa992f5..86a1ba903 100644
--- a/java/dagger/internal/codegen/DerivedFromProviderBindingExpression.java
+++ b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
@@ -22,31 +22,33 @@
 import dagger.model.Key;
 import dagger.model.RequestKind;
 
-/** A binding expression that depends on the expression for the {@link RequestKind#PROVIDER}. */
-final class DerivedFromProviderBindingExpression extends BindingExpression {
+/** A binding expression that depends on a framework instance. */
+final class DerivedFromFrameworkInstanceBindingExpression extends BindingExpression {
 
   private final Key key;
   private final RequestKind requestKind;
+  private final FrameworkType frameworkType;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final DaggerTypes types;
 
-  DerivedFromProviderBindingExpression(
+  DerivedFromFrameworkInstanceBindingExpression(
       ResolvedBindings resolvedBindings,
       RequestKind requestKind,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types) {
     this.key = resolvedBindings.key();
     this.requestKind = checkNotNull(requestKind);
+    this.frameworkType = resolvedBindings.bindingType().frameworkType();
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.types = checkNotNull(types);
   }
 
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
-    return FrameworkType.PROVIDER.to(
+    return frameworkType.to(
         requestKind,
         componentBindingExpressions.getDependencyExpression(
-            key, RequestKind.PROVIDER, requestingClass),
+            key, frameworkType.requestKind(), requestingClass),
         types);
   }
 }
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index 0695d81c2..9a469f1ef 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -16,17 +16,32 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreTypes.asTypeElement;
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Predicates.equalTo;
 import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.filter;
+import static com.google.common.collect.Iterables.indexOf;
+import static com.google.common.collect.Iterables.transform;
 import static com.google.common.collect.Lists.asList;
+import static dagger.internal.codegen.DaggerElements.DECLARATION_ORDER;
 import static dagger.internal.codegen.DaggerElements.elementEncloses;
 import static dagger.internal.codegen.DaggerElements.elementToString;
 import static dagger.internal.codegen.DaggerGraphs.shortestPath;
+import static java.util.Collections.min;
+import static java.util.Comparator.comparing;
+import static java.util.Comparator.comparingInt;
 
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Function;
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.collect.HashBasedTable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
+import com.google.common.collect.Table;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.FormatMethod;
 import dagger.model.BindingGraph;
@@ -36,9 +51,12 @@
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
 import dagger.model.BindingGraph.Node;
+import dagger.model.ComponentPath;
 import dagger.model.DependencyRequest;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
+import java.util.Comparator;
+import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
@@ -50,12 +68,14 @@
 // TODO(ronshapiro): If multiple plugins print errors on the same node/edge, should we condense the
 // messages and only print the dependency trace once?
 final class DiagnosticReporterFactory {
+  private final DaggerTypes types;
   private final Messager messager;
   private final DependencyRequestFormatter dependencyRequestFormatter;
 
   @Inject
   DiagnosticReporterFactory(
-      Messager messager, DependencyRequestFormatter dependencyRequestFormatter) {
+      DaggerTypes types, Messager messager, DependencyRequestFormatter dependencyRequestFormatter) {
+    this.types = types;
     this.messager = messager;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
 
@@ -66,11 +86,26 @@ DiagnosticReporterImpl reporter(BindingGraph graph, BindingGraphPlugin plugin) {
     return new DiagnosticReporterImpl(graph, plugin.pluginName());
   }
 
+  private static <K, V> Function<K, V> memoize(Function<K, V> uncached) {
+    return CacheBuilder.newBuilder().build(CacheLoader.from(uncached));
+  }
+
   /**
    * A {@link DiagnosticReporter} that keeps track of which {@linkplain Diagnostic.Kind kinds} of
    * diagnostics were reported.
    */
   final class DiagnosticReporterImpl implements DiagnosticReporter {
+
+    /** A cached function from type to all of its supertypes in breadth-first order. */
+    private final Function<TypeElement, Iterable<TypeElement>> supertypes =
+        memoize(
+            component ->
+                transform(types.supertypes(component.asType()), type -> asTypeElement(type)));
+
+    /** The shortest path (value) from an entry point (column) to a binding (row). */
+    private final Table<BindingNode, DependencyEdge, ImmutableList<Node>> shortestPaths =
+        HashBasedTable.create();
+
     private final BindingGraph graph;
     private final String plugin;
     private final TypeElement rootComponent;
@@ -92,9 +127,7 @@ DiagnosticReporterImpl reporter(BindingGraph graph, BindingGraphPlugin plugin) {
     public void reportComponent(
         Diagnostic.Kind diagnosticKind, ComponentNode componentNode, String messageFormat) {
       StringBuilder messageBuilder = new StringBuilder(messageFormat);
-      if (!componentNode.componentPath().currentComponent().equals(rootComponent)) {
-        appendComponentPath(messageBuilder, componentNode);
-      }
+      appendComponentPathUnlessAtRoot(messageBuilder, componentNode);
       printMessage(diagnosticKind, messageBuilder, rootComponent);
     }
 
@@ -110,12 +143,13 @@ public void reportComponent(
           diagnosticKind, componentNode, formatMessage(messageFormat, firstArg, moreArgs));
     }
 
+    // TODO(ronshapiro): should this also include the binding element?
     @Override
     public void reportBinding(
         Diagnostic.Kind diagnosticKind, BindingNode bindingNode, String message) {
-      // TODO(ronshapiro): should this also include the binding element?
-      reportAtEntryPointsWithDependencyTrace(
-          diagnosticKind, new StringBuilder(message), bindingNode);
+      StringBuilder messageBuilder = new StringBuilder(message);
+      appendEntryPointsAndOneTrace(messageBuilder, bindingNode);
+      printMessage(diagnosticKind, messageBuilder, rootComponent);
     }
 
     @Override
@@ -132,15 +166,8 @@ public void reportBinding(
     public void reportDependency(
         Diagnostic.Kind diagnosticKind, DependencyEdge dependencyEdge, String message) {
       StringBuilder messageBuilder = new StringBuilder(message);
-      dependencyRequestFormatter.appendFormatLine(
-          messageBuilder, dependencyEdge.dependencyRequest());
-
-      if (dependencyEdge.isEntryPoint()) {
-        printAtEntryPoint(diagnosticKind, messageBuilder, dependencyEdge);
-      } else {
-        BindingNode sourceNode = (BindingNode) graph.incidentNodes(dependencyEdge).source();
-        reportAtEntryPointsWithDependencyTrace(diagnosticKind, messageBuilder, sourceNode);
-      }
+      appendEntryPointsAndOneTrace(messageBuilder, dependencyEdge);
+      printMessage(diagnosticKind, messageBuilder, rootComponent);
     }
 
     @Override
@@ -179,23 +206,76 @@ private String formatMessage(String messageFormat, Object firstArg, Object[] mor
     }
 
     /**
-     * For each entry point that depends on {@code targetNode}, appends the {@link
-     * #dependencyTrace(DependencyEdge, BindingNode)} to the binding onto {@code message} and prints
-     * to the messager.
+     * Appends the dependency trace to {@code dependencyEdge} from one of the entry points from
+     * which it is reachable, and any remaining entry points, to {@code message}.
+     */
+    private void appendEntryPointsAndOneTrace(
+        StringBuilder message, DependencyEdge dependencyEdge) {
+      if (dependencyEdge.isEntryPoint()) {
+        appendEntryPoint(message, dependencyEdge);
+      } else { // it's part of a binding
+        dependencyRequestFormatter.appendFormatLine(message, dependencyEdge.dependencyRequest());
+        appendEntryPointsAndOneTrace(message, (BindingNode) source(dependencyEdge));
+      }
+    }
+
+    /**
+     * Appends the dependency trace to {@code bindingNode} from one of the entry points from which
+     * it is reachable, and any remaining entry points, to {@code message}.
      */
-    private void reportAtEntryPointsWithDependencyTrace(
-        Diagnostic.Kind diagnosticKind, CharSequence message, BindingNode bindingNode) {
-      for (DependencyEdge entryPoint : graph.entryPointEdgesDependingOnBindingNode(bindingNode)) {
-        printAtEntryPoint(
-            diagnosticKind,
-            new StringBuilder(message).append(dependencyTrace(entryPoint, bindingNode)),
-            entryPoint);
+    private void appendEntryPointsAndOneTrace(StringBuilder message, BindingNode bindingNode) {
+      ImmutableSet<DependencyEdge> entryPoints =
+          graph.entryPointEdgesDependingOnBindingNode(bindingNode);
+      // Show the full dependency trace for one entry point.
+      DependencyEdge entryPointForTrace =
+          min(
+              entryPoints,
+              // prefer entry points in components closest to the root
+              rootComponentFirst()
+                  // then prefer entry points with a short dependency path to the error
+                  .thenComparing(shortestDependencyPathFirst(bindingNode))
+                  // then prefer entry points declared in the component to those declared in a
+                  // supertype
+                  .thenComparing(nearestComponentSupertypeFirst())
+                  // finally prefer entry points declared first in their enclosing type
+                  .thenComparing(requestElementDeclarationOrder()));
+      appendDependencyTrace(message, entryPointForTrace, bindingNode);
+
+      // List the remaining entry points, showing which component they're in.
+      if (entryPoints.size() > 1) {
+        message.append("\nThe following other entry points also depend on it:");
+        entryPoints
+            .stream()
+            .filter(entryPoint -> !entryPoint.equals(entryPointForTrace))
+            .sorted(
+                // start with entry points in components closest to the root
+                rootComponentFirst()
+                    // then list entry points declared in the component before those declared in a
+                    // supertype
+                    .thenComparing(nearestComponentSupertypeFirst())
+                    // finally list entry points in declaration order in their declaring type
+                    .thenComparing(requestElementDeclarationOrder()))
+            .forEachOrdered(
+                entryPoint -> {
+                  message.append("\n    ");
+                  Element requestElement = entryPoint.dependencyRequest().requestElement().get();
+                  message.append(elementToString(requestElement));
+
+                  // For entry points declared in subcomponents or supertypes of the root component,
+                  // append the component path to make clear to the user which component it's in.
+                  ComponentPath componentPath = source(entryPoint).componentPath();
+                  if (!componentPath.atRoot()
+                      || !requestElement.getEnclosingElement().equals(rootComponent)) {
+                    message.append(String.format(" [%s]", componentPath));
+                  }
+                });
       }
     }
 
     // TODO(ronshapiro): Adding a DependencyPath type to dagger.model could be useful, i.e.
     // bindingGraph.shortestPathFromEntryPoint(DependencyEdge, BindingNode)
-    private CharSequence dependencyTrace(DependencyEdge entryPoint, BindingNode bindingNode) {
+    private void appendDependencyTrace(
+        StringBuilder message, DependencyEdge entryPoint, BindingNode bindingNode) {
       checkArgument(entryPoint.isEntryPoint());
       Node entryPointBinding = graph.incidentNodes(entryPoint).target();
       ImmutableList<Node> shortestBindingPath =
@@ -210,8 +290,8 @@ private CharSequence dependencyTrace(DependencyEdge entryPoint, BindingNode bind
           bindingNode,
           graph);
 
-      StringBuilder trace =
-          new StringBuilder(shortestBindingPath.size() * 100 /* a guess heuristic */);
+      message.ensureCapacity(
+          message.capacity() + shortestBindingPath.size() * 100 /* a guess heuristic */);
       for (int i = shortestBindingPath.size() - 1; i > 0; i--) {
         Set<Edge> dependenciesBetween =
             graph.edgesConnecting(shortestBindingPath.get(i - 1), shortestBindingPath.get(i));
@@ -219,27 +299,19 @@ private CharSequence dependencyTrace(DependencyEdge entryPoint, BindingNode bind
             // If a binding requests a key more than once, any of them should be fine to get to
             // the shortest path
             ((DependencyEdge) Iterables.get(dependenciesBetween, 0)).dependencyRequest();
-        dependencyRequestFormatter.appendFormatLine(trace, dependencyRequest);
+        dependencyRequestFormatter.appendFormatLine(message, dependencyRequest);
       }
-      dependencyRequestFormatter.appendFormatLine(trace, entryPoint.dependencyRequest());
-      return trace;
+      appendEntryPoint(message, entryPoint);
     }
 
-    /**
-     * Prints {@code message} at {@code entryPoint}'s element if it is defined in the {@code
-     * rootComponent}, otherwise at the root component.
-     */
-    private void printAtEntryPoint(
-        Diagnostic.Kind diagnosticKind, CharSequence message, DependencyEdge entryPoint) {
+    private void appendEntryPoint(StringBuilder message, DependencyEdge entryPoint) {
       checkArgument(entryPoint.isEntryPoint());
-      Element entryPointElement = entryPoint.dependencyRequest().requestElement().get();
+      dependencyRequestFormatter.appendFormatLine(message, entryPoint.dependencyRequest());
+      appendComponentPathUnlessAtRoot(message, source(entryPoint));
+    }
 
-      StringBuilder messageBuilder = new StringBuilder(message);
-      Node component = graph.incidentNodes(entryPoint).source();
-      if (!component.equals(graph.rootComponentNode())) {
-        appendComponentPath(messageBuilder, component);
-      }
-      printMessage(diagnosticKind, messageBuilder, entryPointElement);
+    private Node source(Edge edge) {
+      return graph.incidentNodes(edge).source();
     }
 
     private void printMessage(
@@ -254,14 +326,83 @@ private void printMessage(
       messager.printMessage(diagnosticKind, insertBracketPrefix(message, plugin), elementToReport);
     }
 
-    @CanIgnoreReturnValue
-    private StringBuilder appendComponentPath(StringBuilder message, Node node) {
-      return message.append("\ncomponent path: ").append(node.componentPath());
+    private void appendComponentPathUnlessAtRoot(StringBuilder message, Node node) {
+      if (!node.componentPath().equals(graph.rootComponentNode().componentPath())) {
+        message.append(String.format(" [%s]", node.componentPath()));
+      }
     }
 
     @CanIgnoreReturnValue
     private StringBuilder insertBracketPrefix(StringBuilder messageBuilder, String prefix) {
       return messageBuilder.insert(0, String.format("[%s] ", prefix));
     }
+
+    /**
+     * Returns a comparator that sorts entry points in components whose paths from the root are
+     * shorter first.
+     */
+    private Comparator<DependencyEdge> rootComponentFirst() {
+      return comparingInt(entryPoint -> source(entryPoint).componentPath().components().size());
+    }
+
+    /**
+     * Returns a comparator that puts entry points whose shortest dependency path to {@code
+     * bindingNode} is shortest first.
+     */
+    private Comparator<DependencyEdge> shortestDependencyPathFirst(BindingNode bindingNode) {
+      Map<DependencyEdge, ImmutableList<Node>> shortestPathsToBinding =
+          shortestPaths.row(bindingNode);
+      return comparing(
+          entryPoint ->
+              shortestPathsToBinding
+                  .computeIfAbsent(
+                      entryPoint, computeShortestPathToBindingFromEntryNode(bindingNode))
+                  .size());
+    }
+
+    private Function<DependencyEdge, ImmutableList<Node>> computeShortestPathToBindingFromEntryNode(
+        BindingNode bindingNode) {
+      return entryPoint ->
+          shortestPath(
+              node -> filter(graph.successors(node), successor -> successor instanceof BindingNode),
+              graph.incidentNodes(entryPoint).target(),
+              bindingNode);
+    }
+
+    /**
+     * Returns a comparator that sorts entry points in by the distance of the type that declares
+     * them from the type of the component that contains them.
+     *
+     * <p>For instance, an entry point declared directly in the component type would sort before one
+     * declared in a direct supertype, which would sort before one declared in a supertype of a
+     * supertype.
+     */
+    private Comparator<DependencyEdge> nearestComponentSupertypeFirst() {
+      return comparingInt(
+          entryPoint ->
+              indexOf(
+                  supertypes.apply(componentContainingEntryPoint(entryPoint)),
+                  equalTo(typeDeclaringEntryPoint(entryPoint))));
+    }
+
+    private TypeElement componentContainingEntryPoint(DependencyEdge entryPoint) {
+      return source(entryPoint).componentPath().currentComponent();
+    }
+
+    private TypeElement typeDeclaringEntryPoint(DependencyEdge entryPoint) {
+      return MoreElements.asType(
+          entryPoint.dependencyRequest().requestElement().get().getEnclosingElement());
+    }
+
+    /**
+     * Returns a comparator that sorts entry points in the order in which they were declared in
+     * their declaring type.
+     *
+     * <p>Only useful to compare entry points declared in the same type.
+     */
+    private Comparator<DependencyEdge> requestElementDeclarationOrder() {
+      return comparing(
+          entryPoint -> entryPoint.dependencyRequest().requestElement().get(), DECLARATION_ORDER);
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/DuplicateBindingsValidation.java b/java/dagger/internal/codegen/DuplicateBindingsValidation.java
index 7c8686145..39460d295 100644
--- a/java/dagger/internal/codegen/DuplicateBindingsValidation.java
+++ b/java/dagger/internal/codegen/DuplicateBindingsValidation.java
@@ -144,7 +144,7 @@ private String incompatibleBindingsMessage(
 
     Set<BindingNode> uniqueBindings =
         Sets.filter(duplicateBindings, binding -> !binding.equals(multibinding));
-    message.append(INDENT).append("Unique bindings and declarations:");
+    message.append('\n').append(INDENT).append("Unique bindings and declarations:");
     formatDeclarations(
         message,
         2,
@@ -160,7 +160,6 @@ private void formatDeclarations(
       Iterable<? extends BindingDeclaration> bindingDeclarations) {
     bindingDeclarationFormatter.formatIndentedList(
         builder, ImmutableList.copyOf(bindingDeclarations), indentLevel);
-    builder.append('\n');
   }
 
   private ImmutableSet<BindingDeclaration> declarations(
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 95d66951b..909b4f5ab 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
@@ -28,12 +27,6 @@
  */
 final class ErrorMessages {
 
-  static String provisionMayNotDependOnProducerType(TypeMirror type) {
-    return String.format(
-        "%s may only be injected in @Produces methods",
-        MoreTypes.asTypeElement(type).getSimpleName());
-  }
-
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
       case COMPONENT:
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index b5016819c..0bfb42709 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -22,80 +22,49 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
-import dagger.model.RequestKind;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
-/** A binding expression that uses an instance of a {@link FrameworkType}. */
-final class FrameworkInstanceBindingExpression extends BindingExpression {
+/** A binding expression that uses a {@link FrameworkType} field. */
+abstract class FrameworkInstanceBindingExpression extends BindingExpression {
   private final ResolvedBindings resolvedBindings;
-  private final RequestKind requestKind;
-  private final ComponentBindingExpressions componentBindingExpressions;
   private final FrameworkInstanceSupplier frameworkInstanceSupplier;
-  private final FrameworkType frameworkType;
   private final DaggerTypes types;
   private final Elements elements;
 
   FrameworkInstanceBindingExpression(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
-      ComponentBindingExpressions componentBindingExpressions,
-      FrameworkType frameworkType,
       FrameworkInstanceSupplier frameworkInstanceSupplier,
       DaggerTypes types,
       Elements elements) {
     this.resolvedBindings = checkNotNull(resolvedBindings);
-    this.requestKind = checkNotNull(requestKind);
-    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
-    this.frameworkType = checkNotNull(frameworkType);
     this.frameworkInstanceSupplier = checkNotNull(frameworkInstanceSupplier);
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
   }
 
   /**
-   * The expression for the framework instance for this binding. If the instance comes from a
-   * component field, it will be {@link GeneratedComponentModel#addInitialization(CodeBlock)
-   * initialized} and {@link GeneratedComponentModel#addField(GeneratedComponentModel.FieldSpecKind,
-   * FieldSpec) added} to the component the first time this method is invoked.
+   * The expression for the framework instance for this binding. The field will be {@link
+   * GeneratedComponentModel#addInitialization(CodeBlock) initialized} and {@link
+   * GeneratedComponentModel#addField(GeneratedComponentModel.FieldSpecKind, FieldSpec) added} to
+   * the component the first time this method is invoked.
    */
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
-    if (requestKind.equals(frameworkRequestKind())) {
-      MemberSelect memberSelect = frameworkInstanceSupplier.memberSelect();
-      TypeMirror contributedType = resolvedBindings.contributionBinding().contributedType();
-      TypeMirror expressionType =
-          frameworkInstanceSupplier.specificType().isPresent()
-                  || isTypeAccessibleFrom(contributedType, requestingClass.packageName())
-                  || isInlinedFactoryCreation(memberSelect)
-              ? types.wrapType(contributedType, resolvedBindings.frameworkClass())
-              : rawFrameworkType();
-      return Expression.create(expressionType, memberSelect.getExpressionFor(requestingClass));
-    }
-
-    // The following expressions form a composite with the expression for the framework type. For
-    // example, the expression for RequestKind.LAZY is a composite of the expression for a
-    // RequestKind.PROVIDER (the framework type):
-    //    lazyExpression = DoubleCheck.lazy(providerExpression);
-    return frameworkType.to(
-        requestKind,
-        componentBindingExpressions.getDependencyExpression(
-            resolvedBindings.key(), frameworkRequestKind(), requestingClass),
-        types);
+    MemberSelect memberSelect = frameworkInstanceSupplier.memberSelect();
+    TypeMirror contributedType = resolvedBindings.contributionBinding().contributedType();
+    TypeMirror expressionType =
+        frameworkInstanceSupplier.specificType().isPresent()
+                || isTypeAccessibleFrom(contributedType, requestingClass.packageName())
+                || isInlinedFactoryCreation(memberSelect)
+            ? types.wrapType(contributedType, resolvedBindings.frameworkClass())
+            : rawFrameworkType();
+    return Expression.create(expressionType, memberSelect.getExpressionFor(requestingClass));
   }
 
-  /** Returns the request kind that matches the framework type. */
-  private RequestKind frameworkRequestKind() {
-    switch (frameworkType) {
-      case PROVIDER:
-        return RequestKind.PROVIDER;
-      case PRODUCER:
-        return RequestKind.PRODUCER;
-      default:
-        throw new AssertionError(frameworkType);
-    }
-  }
+  /** Returns the framework type for the binding. */
+  protected abstract FrameworkType frameworkType();
 
   /**
    * Returns {@code true} if a factory is created inline each time it is requested. For example, in
diff --git a/java/dagger/internal/codegen/FrameworkType.java b/java/dagger/internal/codegen/FrameworkType.java
index 8f5fcf767..2d4b4e16f 100644
--- a/java/dagger/internal/codegen/FrameworkType.java
+++ b/java/dagger/internal/codegen/FrameworkType.java
@@ -40,6 +40,11 @@
 enum FrameworkType {
   /** A {@link Provider}. */
   PROVIDER {
+    @Override
+    RequestKind requestKind() {
+      return RequestKind.PROVIDER;
+    }
+
     @Override
     CodeBlock to(RequestKind requestKind, CodeBlock from) {
       switch (requestKind) {
@@ -97,6 +102,11 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
 
   /** A {@link Producer}. */
   PRODUCER {
+    @Override
+    RequestKind requestKind() {
+      return RequestKind.PRODUCER;
+    }
+
     @Override
     CodeBlock to(RequestKind requestKind, CodeBlock from) {
       switch (requestKind) {
@@ -133,6 +143,11 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
   // TODO(ronshapiro): Remove this once MembersInjectionBinding no longer extends Binding
   /** A {@link MembersInjector}. */
   MEMBERS_INJECTOR {
+    @Override
+    RequestKind requestKind() {
+      return RequestKind.MEMBERS_INJECTION;
+    }
+
     @Override
     CodeBlock to(RequestKind requestKind, CodeBlock from) {
       throw new UnsupportedOperationException(requestKind.toString());
@@ -145,6 +160,9 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
   },
   ;
 
+  /** Returns the {@link RequestKind} matching this framework type. */
+  abstract RequestKind requestKind();
+
   /**
    * Returns a {@link CodeBlock} that evaluates to a requested object given an expression that
    * evaluates to an instance of this framework type.
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 01d986b06..6b21c5ef5 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -16,6 +16,10 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -33,9 +37,15 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.ReferenceReleasingProviderManager;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.model.Key;
+import dagger.model.RequestKind;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.Optional;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.NestingKind;
@@ -91,7 +101,15 @@
     MEMBERS_INJECTION_METHOD,
 
     /** A static method that always returns an absent {@code Optional} value for the binding. */
-    ABSENT_OPTIONAL_METHOD
+    ABSENT_OPTIONAL_METHOD,
+
+    /**
+     * A method that encapsulates a modifiable binding. A binding is modifiable if it can change
+     * across implementations of a subcomponent. This is only relevant for ahead-of-time
+     * subcomponents.
+     */
+    MODIFIABLE_BINDING_METHOD,
+    ;
   }
 
   /** A type of nested class that this component model can generate. */
@@ -112,6 +130,8 @@
   private final ClassName name;
   private final NestingKind nestingKind;
   private final boolean isAbstract;
+  private final Optional<GeneratedComponentModel> supermodel;
+  private final Map<TypeElement, GeneratedComponentModel> subcomponentModels = new HashMap<>();
   private final TypeSpec.Builder component;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
@@ -123,24 +143,52 @@
   private final ListMultimap<TypeSpecKind, TypeSpec> typeSpecsMap =
       MultimapBuilder.enumKeys(TypeSpecKind.class).arrayListValues().build();
   private final List<Supplier<TypeSpec>> switchingProviderSupplier = new ArrayList<>();
+  private final ModifiableBindingMethods modifiableBindingMethods = new ModifiableBindingMethods();
 
-  private GeneratedComponentModel(ClassName name, NestingKind nestingKind, Modifier... modifiers) {
+  private GeneratedComponentModel(
+      ClassName name,
+      NestingKind nestingKind,
+      Optional<GeneratedComponentModel> supermodel,
+      Modifier... modifiers) {
     this.name = name;
     this.nestingKind = nestingKind;
     this.isAbstract = Arrays.asList(modifiers).contains(ABSTRACT);
+    this.supermodel = supermodel;
     this.component = classBuilder(name).addModifiers(modifiers);
   }
 
+  /** Create a model for a root component. */
   static GeneratedComponentModel forComponent(ClassName name) {
-    return new GeneratedComponentModel(name, NestingKind.TOP_LEVEL, PUBLIC, FINAL);
+    return new GeneratedComponentModel(
+        name, NestingKind.TOP_LEVEL, Optional.empty(), /* supermodel */ PUBLIC, FINAL);
   }
 
+  /**
+   * Create a model for a subcomponent. This is for concrete subcomponents implementations when not
+   * generating ahead-of-time subcomponents.
+   */
   static GeneratedComponentModel forSubcomponent(ClassName name) {
-    return new GeneratedComponentModel(name, NestingKind.MEMBER, PRIVATE, FINAL);
+    return new GeneratedComponentModel(
+        name, NestingKind.MEMBER, Optional.empty(), /* supermodel */ PRIVATE, FINAL);
   }
 
+  /**
+   * Create a model for the top-level abstract subcomponent implementation when generating
+   * ahead-of-time subcomponents.
+   */
   static GeneratedComponentModel forBaseSubcomponent(ClassName name) {
-    return new GeneratedComponentModel(name, NestingKind.TOP_LEVEL, PUBLIC, ABSTRACT);
+    return new GeneratedComponentModel(
+        name, NestingKind.TOP_LEVEL, Optional.empty(), /* supermodel */ PUBLIC, ABSTRACT);
+  }
+
+  /**
+   * Create a model for an inner abstract implementation of a subcomponent. This is applicable when
+   * generating ahead-of-time subcomponents.
+   */
+  static GeneratedComponentModel forAbstractSubcomponent(
+      ClassName name, GeneratedComponentModel supermodel) {
+    return new GeneratedComponentModel(
+        name, NestingKind.MEMBER, Optional.of(supermodel), PUBLIC, ABSTRACT);
   }
 
   /** Returns the name of the component. */
@@ -158,6 +206,16 @@ boolean isAbstract() {
     return isAbstract;
   }
 
+  /** Returns the model of this model's superclass. */
+  Optional<GeneratedComponentModel> supermodel() {
+    return supermodel;
+  }
+
+  /** Returns the model of the child subcomponent. */
+  Optional<GeneratedComponentModel> subcomponentModel(ComponentDescriptor subcomponent) {
+    return Optional.ofNullable(subcomponentModels.get(subcomponent.componentDefinitionType()));
+  }
+
   /** Returns {@code true} if {@code type} is accessible from the generated component. */
   boolean isTypeAccessible(TypeMirror type) {
     return isTypeAccessibleFrom(type, name.packageName());
@@ -168,6 +226,15 @@ void addSupertype(TypeElement supertype) {
     TypeSpecs.addSupertype(component, supertype);
   }
 
+  /** Adds the given super class to the subcomponent. */
+  void addSuperclass(ClassName className) {
+    checkState(
+        supermodel.isPresent(),
+        "Setting the supertype for model [%s] as a class when model has no supermodel.",
+        name);
+    component.superclass(className);
+  }
+
   // TODO(dpb): Consider taking FieldSpec, and returning identical FieldSpec with unique name?
   /** Adds the given field to the component. */
   void addField(FieldSpecKind fieldKind, FieldSpec fieldSpec) {
@@ -190,6 +257,34 @@ void addMethods(MethodSpecKind methodKind, Iterable<MethodSpec> methodSpecs) {
     methodSpecsMap.putAll(methodKind, methodSpecs);
   }
 
+  /**
+   * Adds the given method to the component. In this case, the method represents an encapsulation of
+   * a modifiable binding between implementations of a subcomponent. This is only relevant for
+   * ahead-of-time subcomponents.
+   */
+  void addModifiableBindingMethod(
+      ModifiableBindingType type, Key key, RequestKind kind, MethodSpec methodSpec) {
+    modifiableBindingMethods.addMethod(type, key, kind, methodSpec);
+    methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, methodSpec);
+  }
+
+  /**
+   * Registers a known method as encapsulating a modifiable binding without adding the method to the
+   * current component. This is relevant when a method of a different type, such as a component
+   * method, encapsulates a modifiable binding.
+   */
+  void registerModifiableBindingMethod(
+      ModifiableBindingType type, Key key, RequestKind kind, MethodSpec methodSpec) {
+    modifiableBindingMethods.addMethod(type, key, kind, methodSpec);
+  }
+
+  /** Adds the implementation for the given {@link ModifiableBindingMethod} to the component. */
+  void addImplementedModifiableBindingMethod(
+      ModifiableBindingMethod method, MethodSpec methodSpec) {
+    modifiableBindingMethods.methodImplemented(method);
+    methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, methodSpec);
+  }
+
   /** Adds the given type to the component. */
   void addType(TypeSpecKind typeKind, TypeSpec typeSpec) {
     typeSpecsMap.put(typeKind, typeSpec);
@@ -200,8 +295,10 @@ void addTypes(TypeSpecKind typeKind, Iterable<TypeSpec> typeSpecs) {
     typeSpecsMap.putAll(typeKind, typeSpecs);
   }
 
-  void addSubcomponent(GeneratedComponentModel subcomponentModel) {
-    // TODO(user): Hold a reference to each subcomponent model.
+  /** Adds the type generated from the given subcomponent model. */
+  void addSubcomponent(
+      ComponentDescriptor subcomponent, GeneratedComponentModel subcomponentModel) {
+    subcomponentModels.put(subcomponent.componentDefinitionType(), subcomponentModel);
     addType(TypeSpecKind.SUBCOMPONENT, subcomponentModel.generate().build());
   }
 
@@ -225,6 +322,21 @@ String getUniqueMethodName(String name) {
     return componentMethodNames.getUniqueName(name);
   }
 
+  /**
+   * Returns a new, unique method name for a "getter" method exposing this binding and binding kind
+   * for this component.
+   */
+  String getUniqueGetterMethodName(ContributionBinding binding, RequestKind requestKind) {
+    // TODO(user): Use a better name for @MapKey binding instances.
+    // TODO(user): Include the binding method as part of the method name.
+    String bindingName = LOWER_CAMEL.to(UPPER_CAMEL, BindingVariableNamer.name(binding));
+    String kindName =
+        requestKind.equals(RequestKind.INSTANCE)
+            ? ""
+            : UPPER_UNDERSCORE.to(UPPER_CAMEL, requestKind.name());
+    return getUniqueMethodName("get" + bindingName + kindName);
+  }
+
   /** Claims a new method name for the component. Does nothing if method name already exists. */
   void claimMethodName(Name name) {
     componentMethodNames.claim(name);
@@ -235,6 +347,24 @@ void claimMethodName(Name name) {
     return ImmutableList.copyOf(initializations);
   }
 
+  /**
+   * Returns the {@link ModifiableBindingMethod}s for this subcomponent implementation and its
+   * superclasses.
+   */
+  ImmutableList<ModifiableBindingMethod> getModifiableBindingMethods() {
+    ImmutableList.Builder<ModifiableBindingMethod> modifiableBindingMethodsBuilder =
+        ImmutableList.builder();
+    if (supermodel.isPresent()) {
+      ImmutableList<ModifiableBindingMethod> superclassModifiableBindingMethods =
+          supermodel.get().getModifiableBindingMethods();
+      superclassModifiableBindingMethods.stream()
+          .filter(method -> !modifiableBindingMethods.isFinalized(method))
+          .forEach(modifiableBindingMethodsBuilder::add);
+    }
+    modifiableBindingMethodsBuilder.addAll(modifiableBindingMethods.getMethods());
+    return modifiableBindingMethodsBuilder.build();
+  }
+
   /** Generates the component and returns the resulting {@link TypeSpec.Builder}. */
   TypeSpec.Builder generate() {
     fieldSpecsMap.asMap().values().forEach(component::addFields);
diff --git a/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java b/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
index 112154433..dffa052f6 100644
--- a/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
@@ -16,28 +16,36 @@
 
 package dagger.internal.codegen;
 
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import dagger.model.Key;
+import dagger.model.RequestKind;
 
 /**
- * A {@link BindingExpression} that invokes a method that encapsulates a binding that requires an
- * instance of a generated type. This expression is used in abstract implementations of a
- * subcomponent when there are no concrete definitions of generated types available. The
- * (unimplemented) method is added to the {@code GeneratedComponentModel} when this dependency
- * expression is requested. The method is overridden when generating the concrete implementation of
- * an ancestor component.
+ * An {@link AbstractMethodModifiableBindingExpression} for a binding that requires an instance of a
+ * generated type. This expression is used in abstract implementations of a subcomponent when there
+ * are no concrete definitions of generated types available. The (unimplemented) method is added to
+ * the {@code GeneratedComponentModel} when this dependency expression is requested. The method is
+ * overridden when generating the concrete implementation of an ancestor component.
  */
-final class GeneratedInstanceBindingExpression extends BindingExpression {
-  private final Key key;
+final class GeneratedInstanceBindingExpression extends AbstractMethodModifiableBindingExpression {
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ContributionBinding binding;
+  private final RequestKind requestKind;
 
-  GeneratedInstanceBindingExpression(ResolvedBindings resolvedBindings) {
-    this.key = resolvedBindings.key();
+  GeneratedInstanceBindingExpression(
+      GeneratedComponentModel generatedComponentModel,
+      ResolvedBindings resolvedBindings,
+      RequestKind requestKind) {
+    super(
+        generatedComponentModel,
+        ModifiableBindingType.GENERATED_INSTANCE,
+        resolvedBindings.key(),
+        requestKind);
+    this.generatedComponentModel = generatedComponentModel;
+    this.binding = resolvedBindings.contributionBinding();
+    this.requestKind = requestKind;
   }
 
   @Override
-  final Expression getDependencyExpression(ClassName requestingClass) {
-    // TODO(b/72748365): Implement method encapsulating binding to invoke in this expression.
-    return Expression.create(key.type(), CodeBlock.of("null"));
+  String chooseMethodName() {
+    return generatedComponentModel.getUniqueGetterMethodName(binding, requestKind);
   }
 }
diff --git a/java/dagger/internal/codegen/InjectValidator.java b/java/dagger/internal/codegen/InjectValidator.java
index 4d6c89b03..b912fcbcd 100644
--- a/java/dagger/internal/codegen/InjectValidator.java
+++ b/java/dagger/internal/codegen/InjectValidator.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.Scopes.scopesOf;
@@ -46,6 +45,7 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
+import javax.tools.Diagnostic.Kind;
 
 /**
  * A {@linkplain ValidationReport validator} for {@link Inject}-annotated elements and the types
@@ -55,21 +55,28 @@
   private final Types types;
   private final DaggerElements elements;
   private final CompilerOptions compilerOptions;
+  private final DependencyRequestValidator dependencyRequestValidator;
   private final Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind;
 
   @Inject
-  InjectValidator(Types types, DaggerElements elements, CompilerOptions compilerOptions) {
-    this(types, elements, compilerOptions, Optional.empty());
+  InjectValidator(
+      Types types,
+      DaggerElements elements,
+      DependencyRequestValidator dependencyRequestValidator,
+      CompilerOptions compilerOptions) {
+    this(types, elements, compilerOptions, dependencyRequestValidator, Optional.empty());
   }
 
   private InjectValidator(
       Types types,
       DaggerElements elements,
       CompilerOptions compilerOptions,
-      Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind) {
+      DependencyRequestValidator dependencyRequestValidator,
+      Optional<Kind> privateAndStaticInjectionDiagnosticKind) {
     this.types = types;
     this.elements = elements;
     this.compilerOptions = compilerOptions;
+    this.dependencyRequestValidator = dependencyRequestValidator;
     this.privateAndStaticInjectionDiagnosticKind = privateAndStaticInjectionDiagnosticKind;
   }
 
@@ -79,7 +86,12 @@ private InjectValidator(
    */
   InjectValidator whenGeneratingCode() {
     return compilerOptions.ignorePrivateAndStaticInjectionForComponent()
-        ? new InjectValidator(types, elements, compilerOptions, Optional.of(Diagnostic.Kind.ERROR))
+        ? new InjectValidator(
+            types,
+            elements,
+            compilerOptions,
+            dependencyRequestValidator,
+            Optional.of(Diagnostic.Kind.ERROR))
         : this;
   }
 
@@ -106,10 +118,7 @@ InjectValidator whenGeneratingCode() {
     }
 
     for (VariableElement parameter : constructorElement.getParameters()) {
-      checkMultipleQualifiers(constructorElement, parameter, builder);
-      if (FrameworkTypes.isProducerType(parameter.asType())) {
-        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
-      }
+      validateDependencyRequest(builder, parameter);
     }
 
     if (throwsCheckedExceptions(constructorElement)) {
@@ -182,11 +191,7 @@ InjectValidator whenGeneratingCode() {
           fieldElement);
     }
 
-    checkMultipleQualifiers(fieldElement, fieldElement, builder);
-
-    if (FrameworkTypes.isProducerType(fieldElement.asType())) {
-      builder.addError(provisionMayNotDependOnProducerType(fieldElement.asType()), fieldElement);
-    }
+    validateDependencyRequest(builder, fieldElement);
 
     return builder.build();
   }
@@ -219,15 +224,18 @@ InjectValidator whenGeneratingCode() {
     }
 
     for (VariableElement parameter : methodElement.getParameters()) {
-      checkMultipleQualifiers(methodElement, parameter, builder);
-      if (FrameworkTypes.isProducerType(parameter.asType())) {
-        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
-      }
+      validateDependencyRequest(builder, parameter);
     }
 
     return builder.build();
   }
 
+  private void validateDependencyRequest(
+      ValidationReport.Builder<?> builder, VariableElement parameter) {
+    dependencyRequestValidator.validateDependencyRequest(builder, parameter, parameter.asType());
+    dependencyRequestValidator.checkNotProducer(builder, parameter);
+  }
+
   ValidationReport<TypeElement> validateMembersInjectionType(TypeElement typeElement) {
     // TODO(beder): This element might not be currently compiled, so this error message could be
     // left in limbo. Find an appropriate way to display the error message in that case.
@@ -304,22 +312,6 @@ private boolean throwsCheckedExceptions(ExecutableElement methodElement) {
     return false;
   }
 
-  // TODO(dpb,ronshapiro): Use this on AnyBindingMethodValidator, or a DependencyRequestValidator.
-  // Currently, @Provides and @Produces methods with multiple qualifiers on a dependency will crash
-  // the compiler.
-  private void checkMultipleQualifiers(
-      Element errorElement, Element qualifiedElement, ValidationReport.Builder<?> builder) {
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(qualifiedElement);
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(
-            "A single injection site may not use more than one @Qualifier",
-            errorElement,
-            qualifier);
-      }
-    }
-  }
-
   private void checkInjectIntoPrivateClass(Element element, Builder<TypeElement> builder) {
     if (!Accessibility.isElementAccessibleFromOwnPackage(
         DaggerElements.closestEnclosingTypeElement(element))) {
diff --git a/java/dagger/internal/codegen/KytheBindingGraphFactory.java b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
index 1af20601c..28b724fbe 100644
--- a/java/dagger/internal/codegen/KytheBindingGraphFactory.java
+++ b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
@@ -111,21 +111,17 @@ static CompilerOptions createCompilerOptions() {
   private static BindingGraphFactory createBindingGraphFactory(
       DaggerTypes types, DaggerElements elements, CompilerOptions compilerOptions) {
     KeyFactory keyFactory = new KeyFactory(types, elements);
-    DependencyRequestFactory dependencyRequestFactory =
-        new DependencyRequestFactory(keyFactory, types);
-    Messager messager = new NullMessager();
 
     BindingFactory bindingFactory =
-        new BindingFactory(types, elements, keyFactory, dependencyRequestFactory);
-
-    InjectValidator injectMethodValidator = new InjectValidator(types, elements, compilerOptions);
+        new BindingFactory(
+            types, elements, keyFactory, new DependencyRequestFactory(keyFactory, types));
 
     InjectBindingRegistry injectBindingRegistry =
         new InjectBindingRegistryImpl(
             elements,
             types,
-            messager,
-            injectMethodValidator,
+            new NullMessager(),
+            new InjectValidator(types, elements, new DependencyRequestValidator(), compilerOptions),
             keyFactory,
             bindingFactory,
             compilerOptions);
diff --git a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
index 32992e73b..a22b1dd5a 100644
--- a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
+++ b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
@@ -49,7 +49,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
   // better suited as a method on MembersInjectionMethods
   @Override
   protected CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, ClassName componentName) {
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
     ExecutableElement methodElement = componentMethod.methodElement();
     ParameterSpec parameter = ParameterSpec.get(getOnlyElement(methodElement.getParameters()));
 
diff --git a/java/dagger/internal/codegen/MissingBindingExpression.java b/java/dagger/internal/codegen/MissingBindingExpression.java
index 197c388c6..dbc95e9a6 100644
--- a/java/dagger/internal/codegen/MissingBindingExpression.java
+++ b/java/dagger/internal/codegen/MissingBindingExpression.java
@@ -16,26 +16,41 @@
 
 package dagger.internal.codegen;
 
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+
+import com.google.auto.common.MoreTypes;
 import dagger.model.Key;
+import dagger.model.RequestKind;
 
 /**
- * A {@link BindingExpression} that invokes a method that encapsulates a binding that is missing
- * when generating the abstract base class implementation of a subcomponent. The (unimplemented)
- * method is added to the {@link GeneratedComponentModel} when the dependency expression is
- * requested. The method is overridden when generating the implementation of an ancestor component.
+ * A {@link AbstractMethodModifiableBindingExpression} for a binding that is missing when generating
+ * the abstract base class implementation of a subcomponent. The (unimplemented) method is added to
+ * the {@link GeneratedComponentModel} when the dependency expression is requested. The method is
+ * overridden when generating the implementation of an ancestor component.
  */
-final class MissingBindingExpression extends BindingExpression {
+final class MissingBindingExpression extends AbstractMethodModifiableBindingExpression {
+  private final GeneratedComponentModel generatedComponentModel;
   private final Key key;
+  private final RequestKind kind;
 
-  MissingBindingExpression(Key key) {
+  MissingBindingExpression(
+      GeneratedComponentModel generatedComponentModel, Key key, RequestKind kind) {
+    super(generatedComponentModel, ModifiableBindingType.MISSING, key, kind);
+    this.generatedComponentModel = generatedComponentModel;
     this.key = key;
+    this.kind = kind;
   }
 
   @Override
-  final Expression getDependencyExpression(ClassName requestingClass) {
-    // TODO(b/72748365): Implement method encapsulating binding to invoke in this expression.
-    return Expression.create(key.type(), CodeBlock.of("null"));
+  String chooseMethodName() {
+    return generatedComponentModel.getUniqueMethodName(
+        "get"
+            + LOWER_CAMEL.to(UPPER_CAMEL, simpleVariableName(MoreTypes.asTypeElement(key.type())))
+            + (kind.equals(RequestKind.INSTANCE)
+                ? ""
+                : UPPER_UNDERSCORE.to(UPPER_CAMEL, kind.name())));
   }
 }
diff --git a/java/dagger/internal/codegen/MissingBindingValidation.java b/java/dagger/internal/codegen/MissingBindingValidation.java
index 811c5624a..b3c597cbd 100644
--- a/java/dagger/internal/codegen/MissingBindingValidation.java
+++ b/java/dagger/internal/codegen/MissingBindingValidation.java
@@ -20,6 +20,7 @@
 import static com.google.auto.common.MoreTypes.asTypeElement;
 import static com.google.auto.common.MoreTypes.isType;
 import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
@@ -97,25 +98,19 @@ private void reportMissingBinding(
   private String missingBindingErrorMessage(DependencyEdge edge, BindingGraph graph) {
     Key key = edge.dependencyRequest().key();
     StringBuilder errorMessage = new StringBuilder();
-    // TODO(dpb): Check for wildcard injection somewhere else first?
-    if (key.type().getKind().equals(TypeKind.WILDCARD)) {
-      // TODO(ronshapiro): Explore creating this message using RequestKinds.
-      errorMessage
-          .append("Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, ")
-          .append("or Produced<T> when T is a wildcard type such as ")
-          .append(key);
-    } else {
-      // TODO(ronshapiro): replace "provided" with "satisfied"?
-      errorMessage.append(key).append(" cannot be provided without ");
-      if (isValidImplicitProvisionKey(key, types)) {
-        errorMessage.append("an @Inject constructor or ");
-      }
-      errorMessage.append("an @Provides-"); // TODO(dpb): s/an/a
-      if (dependencyCanBeProduction(edge, graph)) {
-        errorMessage.append(" or @Produces-");
-      }
-      errorMessage.append("annotated method.");
+    // Wildcards should have already been checked by DependencyRequestValidator.
+    verify(
+        !key.type().getKind().equals(TypeKind.WILDCARD), "unexpected wildcard request: %s", edge);
+    // TODO(ronshapiro): replace "provided" with "satisfied"?
+    errorMessage.append(key).append(" cannot be provided without ");
+    if (isValidImplicitProvisionKey(key, types)) {
+      errorMessage.append("an @Inject constructor or ");
+    }
+    errorMessage.append("an @Provides-"); // TODO(dpb): s/an/a
+    if (dependencyCanBeProduction(edge, graph)) {
+      errorMessage.append(" or @Produces-");
     }
+    errorMessage.append("annotated method.");
     if (isValidMembersInjectionKey(key) && typeHasInjectionSites(key)) {
       errorMessage.append(
           " This type supports members injection but cannot be implicitly provided.");
diff --git a/java/dagger/internal/codegen/ModifiableBindingMethods.java b/java/dagger/internal/codegen/ModifiableBindingMethods.java
new file mode 100644
index 000000000..766031be3
--- /dev/null
+++ b/java/dagger/internal/codegen/ModifiableBindingMethods.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkState;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.squareup.javapoet.MethodSpec;
+import dagger.model.Key;
+import dagger.model.RequestKind;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * A registry for those methods which each wrap a binding whose definition may be modified across
+ * each class in the class hierarchy implementing a subcomponent. Subcomponent implementations are
+ * spread across a class hierarchy when generating ahead-of-time subcomponents. There is one
+ * subcomponent implementation class for each of the subcomponent's ancestor components. An instance
+ * of {@link ModifiableBindingMethod} is associated with a single class in this hierarchy. For a
+ * given subcomponent implementation class we can use the {@link ModifiableBindingMethod}s of its
+ * superclasses to know what binding methods to attempt to modify.
+ */
+final class ModifiableBindingMethods {
+  private final Map<KeyAndKind, ModifiableBindingMethod> methods = Maps.newHashMap();
+  private final Set<KeyAndKind> finalizedMethods = Sets.newHashSet();
+
+  /** Register a method encapsulating a modifiable binding. */
+  void addMethod(
+      ModifiableBindingType type, Key key, RequestKind kind, MethodSpec unimplementedMethod) {
+    KeyAndKind keyAndKind = KeyAndKind.create(key, kind);
+    checkState(
+        !finalizedMethods.contains(keyAndKind),
+        "Adding a modifiable binding method for a binding that has been marked as finalized for "
+            + "the current subcomponent implementation. The binding is for a %s-%s of type %s.",
+        key,
+        kind,
+        type);
+    methods.put(keyAndKind, ModifiableBindingMethod.create(type, key, kind, unimplementedMethod));
+  }
+
+  /** Returns all {@link ModifiableBindingMethod}s. */
+  ImmutableList<ModifiableBindingMethod> getMethods() {
+    // We will never add a modifiable binding method and mark it as having been finalized in the
+    // same instance of ModifiableBindingMethods, so there's no need to filter `methods` by
+    // `finalizedMethods`.
+    return ImmutableList.copyOf(methods.values());
+  }
+
+  /**
+   * Mark the {@link ModifiableBindingMethod} as having been implemented, thus modifying the
+   * binding. For those bindings that are finalized when modified, mark the binding as finalized,
+   * meaning it should no longer be modified.
+   */
+  void methodImplemented(ModifiableBindingMethod method) {
+    if (method.type().finalizedOnModification()) {
+      KeyAndKind keyAndKind = KeyAndKind.create(method.key(), method.kind());
+      checkState(
+          !methods.containsKey(keyAndKind),
+          "Indicating a modifiable binding method is finalized when it was registered as "
+              + "modifiable for the current subcomponent implementation. The binding is for a "
+              + "%s-%s of type %s.",
+          method.key(),
+          method.kind(),
+          method.type());
+      finalizedMethods.add(keyAndKind);
+    }
+  }
+
+  /** Whether a given binding has been marked as finalized. */
+  boolean isFinalized(ModifiableBindingMethod method) {
+    return finalizedMethods.contains(KeyAndKind.create(method.key(), method.kind()));
+  }
+
+  @AutoValue
+  abstract static class ModifiableBindingMethod {
+    private static ModifiableBindingMethod create(
+        ModifiableBindingType type, Key key, RequestKind kind, MethodSpec unimplementedMethod) {
+      return new AutoValue_ModifiableBindingMethods_ModifiableBindingMethod(
+          type, key, kind, unimplementedMethod);
+    }
+
+    abstract ModifiableBindingType type();
+
+    abstract Key key();
+
+    abstract RequestKind kind();
+
+    abstract MethodSpec baseMethod();
+  }
+
+  @AutoValue
+  abstract static class KeyAndKind {
+    private static KeyAndKind create(Key key, RequestKind kind) {
+      return new AutoValue_ModifiableBindingMethods_KeyAndKind(key, kind);
+    }
+
+    abstract Key key();
+
+    abstract RequestKind kind();
+  }
+}
diff --git a/java/dagger/internal/codegen/ModifiableBindingType.java b/java/dagger/internal/codegen/ModifiableBindingType.java
new file mode 100644
index 000000000..db8f723b4
--- /dev/null
+++ b/java/dagger/internal/codegen/ModifiableBindingType.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+
+/**
+ * A label for a binding indicating whether, and how, it may be redefined across implementations of
+ * a subcomponent.
+ *
+ * <p>A subcomponent has multiple implementations only when generating ahead-of-time subcomponents.
+ * Specifically, each subcomponent type in a component hierarchy is implemented as an abstract
+ * class, and descendent components are implemented as abstract inner classes. A consequence of this
+ * is that a given subcomponent has an implementation for each ancestor component. Each
+ * implementation represents a different sub-binding-graph of the full subcomponent. A binding is
+ * modifiable if it's definition may change depending on the characteristics of its ancestor
+ * components.
+ */
+enum ModifiableBindingType {
+  /** A binding that is not modifiable */
+  NONE,
+
+  /**
+   * A binding that is missing when generating the abstract base class implementation of a
+   * subcomponent.
+   */
+  MISSING,
+
+  /**
+   * A binding that requires an instance of a generated type. These binding are modifiable in the
+   * sense that they are encapsulated in a method when they are first required, possibly in an
+   * abstract implementation of a subcomponent, where, in general, no concrete instances of
+   * generated types are available, and the method is satisfied in a final concrete implementation.
+   */
+  GENERATED_INSTANCE,
+
+  /**
+   * Multibindings may have contributions come from any ancestor component. Therefore, each
+   * implementation of a subcomponent may have newly available contributions, and so the binding
+   * method is reimplemented with each subcomponent implementation.
+   */
+  MULTIBINDING,
+
+  /**
+   * A Optional binding that may be empty when looking at a partial binding graph, but bound to a
+   * value when considering the complete binding graph, thus modifiable across subcomponent
+   * implementations.
+   */
+  OPTIONAL,
+
+  /**
+   * If a binding is defined according to an {@code @Inject} annotated constructor on the object it
+   * is valid for that binding to be redefined a single time by an {@code @Provides} annotated
+   * module method. It is possible that the {@code @Provides} binding isn't available in a partial
+   * binding graph, but becomes available when considering a more complete binding graph, therefore
+   * such bindings are modifiable across subcomponent implementations.
+   */
+  INJECTION,
+  ;
+
+  private static final ImmutableSet<ModifiableBindingType> TYPES_FINALIZED_ON_MODIFICATION =
+      ImmutableSet.of(MISSING, GENERATED_INSTANCE, OPTIONAL, INJECTION);
+  private static final ImmutableSet<ModifiableBindingType> TYPES_WITH_BASE_CLASS_IMPLEMENTATIONS =
+      ImmutableSet.of(MULTIBINDING, OPTIONAL, INJECTION);
+
+  boolean isModifiable() {
+    return !equals(NONE);
+  }
+
+  /**
+   * Returns true if the modifiable binding should not be further modified once it's base
+   * implementation has been overridden. For example, a missing or optional binding may only be
+   * satisfied once in a subcomponent implementation class hierarchy, but a multibinding may be
+   * modified with every implementation of a subcomponent.
+   */
+  boolean finalizedOnModification() {
+    return TYPES_FINALIZED_ON_MODIFICATION.contains(this);
+  }
+
+  /**
+   * Returns true if the method encapsulating the modifiable binding should have a concrete
+   * implementation in the abstract base class for a subcomponent.
+   */
+  boolean hasBaseClassImplementation() {
+    return TYPES_WITH_BASE_CLASS_IMPLEMENTATIONS.contains(this);
+  }
+}
diff --git a/java/dagger/internal/codegen/MultibindsMethodValidator.java b/java/dagger/internal/codegen/MultibindsMethodValidator.java
index bfac2839a..8e8765d08 100644
--- a/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -36,12 +36,14 @@
 
   /** Creates a validator for {@link Multibinds @Multibinds} methods. */
   @Inject
-  MultibindsMethodValidator(DaggerElements elements, Types types) {
+  MultibindsMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         Multibinds.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         NO_EXCEPTIONS,
         NO_MULTIBINDINGS);
@@ -54,7 +56,8 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkParameters(builder);
   }
 
-  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getParameters().isEmpty()) {
       builder.addError(bindingMethods("cannot have parameters"));
     }
diff --git a/java/dagger/internal/codegen/NonNullableRequestForNullableBindingValidation.java b/java/dagger/internal/codegen/NullableBindingValidation.java
similarity index 94%
rename from java/dagger/internal/codegen/NonNullableRequestForNullableBindingValidation.java
rename to java/dagger/internal/codegen/NullableBindingValidation.java
index 6734824fd..9ff791f62 100644
--- a/java/dagger/internal/codegen/NonNullableRequestForNullableBindingValidation.java
+++ b/java/dagger/internal/codegen/NullableBindingValidation.java
@@ -32,12 +32,12 @@
  * Reports errors or warnings (depending on the {@code -Adagger.nullableValidation} value) for each
  * non-nullable dependency request that is satisfied by a nullable binding.
  */
-final class NonNullableRequestForNullableBindingValidation implements BindingGraphPlugin {
+final class NullableBindingValidation implements BindingGraphPlugin {
 
   private final CompilerOptions compilerOptions;
 
   @Inject
-  NonNullableRequestForNullableBindingValidation(CompilerOptions compilerOptions) {
+  NullableBindingValidation(CompilerOptions compilerOptions) {
     this.compilerOptions = compilerOptions;
   }
 
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index e19f9b853..bd9243739 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -16,9 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
@@ -56,7 +53,7 @@
   protected void addMethod() {
     if (methodName == null) {
       // Have to set methodName field before implementing the method in order to handle recursion.
-      methodName = chooseMethodName();
+      methodName = generatedComponentModel.getUniqueGetterMethodName(binding, requestKind);
       // TODO(user): Fix the order that these generated methods are written to the component.
       generatedComponentModel.addMethod(
           PRIVATE_METHOD,
@@ -73,23 +70,4 @@ protected String methodName() {
     checkState(methodName != null, "addMethod() must be called before methodName()");
     return methodName;
   }
-
-  private String chooseMethodName() {
-    // TODO(user): Use a better name for @MapKey binding instances.
-    // TODO(user): Include the binding method as part of the method name.
-    return generatedComponentModel.getUniqueMethodName(
-        "get" + bindingName() + dependencyKindName());
-  }
-
-  /** Returns the canonical method name suffix for the binding. */
-  private String bindingName() {
-    return LOWER_CAMEL.to(UPPER_CAMEL, BindingVariableNamer.name(binding));
-  }
-
-  /** Returns a canonical method name suffix for the request kind. */
-  private String dependencyKindName() {
-    return requestKind.equals(RequestKind.INSTANCE)
-        ? ""
-        : UPPER_UNDERSCORE.to(UPPER_CAMEL, requestKind.name());
-  }
 }
diff --git a/java/dagger/internal/codegen/ProducerInstanceBindingExpression.java b/java/dagger/internal/codegen/ProducerInstanceBindingExpression.java
new file mode 100644
index 000000000..e4481c2eb
--- /dev/null
+++ b/java/dagger/internal/codegen/ProducerInstanceBindingExpression.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import javax.lang.model.util.Elements;
+
+/** Binding expression for producer instances. */
+final class ProducerInstanceBindingExpression extends FrameworkInstanceBindingExpression {
+
+  ProducerInstanceBindingExpression(
+      ResolvedBindings resolvedBindings,
+      FrameworkInstanceSupplier frameworkInstanceSupplier,
+      DaggerTypes types,
+      Elements elements) {
+    super(
+        resolvedBindings,
+        frameworkInstanceSupplier,
+        types,
+        elements);
+  }
+
+  @Override
+  protected FrameworkType frameworkType() {
+    return FrameworkType.PRODUCER;
+  }
+}
diff --git a/java/dagger/internal/codegen/ProducesMethodValidator.java b/java/dagger/internal/codegen/ProducesMethodValidator.java
index 52ffd672e..5a043da4c 100644
--- a/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -41,10 +41,12 @@
 final class ProducesMethodValidator extends BindingMethodValidator {
 
   @Inject
-  ProducesMethodValidator(DaggerElements elements, Types types) {
+  ProducesMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
+        dependencyRequestValidator,
         Produces.class,
         ProducerModule.class,
         MUST_BE_CONCRETE,
diff --git a/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java b/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java
new file mode 100644
index 000000000..1f277ac66
--- /dev/null
+++ b/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import javax.lang.model.util.Elements;
+
+/** Binding expression for provider instances. */
+final class ProviderInstanceBindingExpression extends FrameworkInstanceBindingExpression {
+
+  ProviderInstanceBindingExpression(
+      ResolvedBindings resolvedBindings,
+      FrameworkInstanceSupplier frameworkInstanceSupplier,
+      DaggerTypes types,
+      Elements elements) {
+    super(
+        resolvedBindings,
+        frameworkInstanceSupplier,
+        types,
+        elements);
+  }
+
+  @Override
+  protected FrameworkType frameworkType() {
+    return FrameworkType.PROVIDER;
+  }
+}
diff --git a/java/dagger/internal/codegen/ProvidesMethodValidator.java b/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 8f7cf1a17..c4d409f14 100644
--- a/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -19,7 +19,6 @@
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
-import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
@@ -35,30 +34,33 @@
  */
 final class ProvidesMethodValidator extends BindingMethodValidator {
 
+  private final DependencyRequestValidator dependencyRequestValidator;
+
   @Inject
-  ProvidesMethodValidator(DaggerElements elements, Types types) {
+  ProvidesMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         Provides.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_CONCRETE,
         RUNTIME_EXCEPTION,
         ALLOWS_MULTIBINDINGS);
+    this.dependencyRequestValidator = dependencyRequestValidator;
   }
 
   @Override
   protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
     super.checkMethod(builder);
-    checkDependsOnProducers(builder);
   }
 
   /** Adds an error if a {@link Provides @Provides} method depends on a producer type. */
-  private void checkDependsOnProducers(ValidationReport.Builder<ExecutableElement> builder) {
-    for (VariableElement parameter : builder.getSubject().getParameters()) {
-      if (FrameworkTypes.isProducerType(parameter.asType())) {
-        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
-      }
-    }
+  @Override
+  protected void checkParameter(
+      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
+    super.checkParameter(builder, parameter);
+    dependencyRequestValidator.checkNotProducer(builder, parameter);
   }
 }
diff --git a/java/dagger/internal/codegen/ResolvedBindings.java b/java/dagger/internal/codegen/ResolvedBindings.java
index 4aadf633a..001df1924 100644
--- a/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/java/dagger/internal/codegen/ResolvedBindings.java
@@ -22,6 +22,7 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
 import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -77,6 +78,15 @@
    */
   abstract ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations();
 
+  // Computing the hash code is an expensive operation.
+  @Memoized
+  @Override
+  public abstract int hashCode();
+
+  // Suppresses ErrorProne warning that hashCode was overridden w/o equals
+  @Override
+  public abstract boolean equals(Object other);
+
   /**
    * All bindings for {@link #key()}, indexed by the component in which the binding was resolved.
    */
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 9b1294205..56ac7ff40 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -17,6 +17,7 @@
 package dagger.model;
 
 import static com.google.common.base.MoreObjects.toStringHelper;
+import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Sets.intersection;
 import static com.google.common.graph.Graphs.inducedSubgraph;
 import static com.google.common.graph.Graphs.reachableNodes;
@@ -172,15 +173,20 @@ public ComponentNode rootComponentNode() {
         .collect(toImmutableSet());
   }
 
-  /** Returns the edges for entry points that transitively depend on a binding. */
+  /**
+   * Returns the edges for entry points that transitively depend on a binding. Never returns an
+   * empty set.
+   */
   public ImmutableSet<DependencyEdge> entryPointEdgesDependingOnBindingNode(
       BindingNode bindingNode) {
     ImmutableNetwork<Node, DependencyEdge> dependencyGraph = dependencyGraph();
     Network<Node, DependencyEdge> subgraphDependingOnBindingNode =
         inducedSubgraph(
             dependencyGraph, reachableNodes(transpose(dependencyGraph).asGraph(), bindingNode));
-    return ImmutableSet.copyOf(
-        intersection(entryPointEdges(), subgraphDependingOnBindingNode.edges()));
+    ImmutableSet<DependencyEdge> entryPointEdges =
+        intersection(entryPointEdges(), subgraphDependingOnBindingNode.edges()).immutableCopy();
+    verify(!entryPointEdges.isEmpty(), "No entry points depend on binding %s", bindingNode);
+    return entryPointEdges;
   }
 
   // TODO(dpb): Make public. Cache.
diff --git a/java/dagger/model/Key.java b/java/dagger/model/Key.java
index daeb35a94..e543d2ab0 100644
--- a/java/dagger/model/Key.java
+++ b/java/dagger/model/Key.java
@@ -88,6 +88,32 @@ public final TypeMirror type() {
   @Override
   public abstract int hashCode();
 
+  // We are modifying what would be the AutoValue-generated equals() method to stick in a check for
+  // hashCode() equality before other properties. Profiling indicated that Key equality is called in
+  // numerous places and it cannot be @Memoized, but hashCode() can be. Because so many other value
+  // types use Key, their equality is dependant on Key's. Inserting the check removed Key.equals()
+  // from the profile.
+  // The main equality bottleneck in calculating the equality is in MoreTypes.equivalence()'s
+  // equality checker. It's possible that we can avoid this by tuning that method. Perhaps we can
+  // also avoid the issue entirely by interning all Keys
+  // TODO(ronshapiro): consider creating an AutoValue extension that can generate this code on its
+  // own
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true;
+    }
+    if (o instanceof Key) {
+      Key that = (Key) o;
+      return (this.hashCode() == that.hashCode())
+          && (this.wrappedQualifier().equals(that.wrappedQualifier()))
+          && (this.wrappedType().equals(that.wrappedType()))
+          && (this.multibindingContributionIdentifier()
+              .equals(that.multibindingContributionIdentifier()));
+    }
+    return false;
+  }
+
   @Override
   public final String toString() {
     return Joiner.on(' ')
diff --git a/java/dagger/producers/internal/SetOfProducedProducer.java b/java/dagger/producers/internal/SetOfProducedProducer.java
index 60ccc7cc4..40833e5c2 100644
--- a/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -101,15 +101,14 @@ private SetOfProducedProducer(
   }
 
   /**
-   * Returns a future {@link Set} of {@link Produced} values whose iteration order is that of the
-   * elements given by each of the producers, which are invoked in the order given at creation.
+   * Returns a future {@link Set} of {@link Produced} elements given by each of the producers.
    *
    * <p>If any of the delegate collections, or any elements therein, are null, then that
    * corresponding {@code Produced} element will fail with a NullPointerException.
    *
    * <p>Canceling this future will attempt to cancel all of the component futures; but if any of the
-   * delegate futures fail or are canceled, this future succeeds, with the appropriate failed
-   * {@link Produced}.
+   * delegate futures fail or are canceled, this future succeeds, with the appropriate failed {@link
+   * Produced}.
    *
    * @throws NullPointerException if any of the delegate producers return null
    */
diff --git a/java/dagger/producers/internal/SetProducer.java b/java/dagger/producers/internal/SetProducer.java
index 12e196771..4577db991 100644
--- a/java/dagger/producers/internal/SetProducer.java
+++ b/java/dagger/producers/internal/SetProducer.java
@@ -109,8 +109,7 @@ private SetProducer(
   }
 
   /**
-   * Returns a future {@link Set} whose iteration order is that of the elements given by each of the
-   * producers, which are invoked in the order given at creation.
+   * Returns a future {@link Set} that contains the elements given by each of the producers.
    *
    * <p>If any of the delegate collections, or any elements therein, are null, then this future will
    * fail with a NullPointerException.
diff --git a/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
index 8f1a5290b..d08bf0b78 100644
--- a/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
+++ b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
@@ -171,7 +171,7 @@ public void mapKeyDoesntMatchCoreType() {
                 + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
     assertThat(compilation)
         .hadErrorContaining(
-            "test.FooActivity.Builder does not implement " + "AndroidInjector<test.BazFragment>")
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BazFragment>")
         .inFile(module)
         .onLine(LINES_BEFORE_METHOD + 3);
   }
diff --git a/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
index 76167511e..8cd1979ee 100644
--- a/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
+++ b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
@@ -98,7 +98,7 @@ public void conflictingMapKeys() {
     assertThat(compilation)
         .hadErrorContaining("Multiple injector factories bound for the same type")
         .inFile(component)
-        .onLineContaining("dispatchingInjector()");
+        .onLineContaining("interface TestComponent");
     assertThat(compilation).hadErrorContaining("classKey(test.TestInjectorFactory)");
     assertThat(compilation).hadErrorContaining("stringKey(test.TestInjectorFactory)");
     assertThat(compilation).hadErrorCount(1);
diff --git a/javatests/dagger/functional/cycle/DoubleCheckCycleTest.java b/javatests/dagger/functional/cycle/DoubleCheckCycleTest.java
index 4eaf2d924..05162c2b2 100644
--- a/javatests/dagger/functional/cycle/DoubleCheckCycleTest.java
+++ b/javatests/dagger/functional/cycle/DoubleCheckCycleTest.java
@@ -17,11 +17,26 @@
 package dagger.functional.cycle;
 
 import static com.google.common.truth.Truth.assertThat;
+import static java.lang.Thread.State.BLOCKED;
+import static java.lang.Thread.State.WAITING;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static org.junit.Assert.fail;
 
-import dagger.functional.cycle.DoubleCheckCycles.FailingReentrantModule;
-import dagger.functional.cycle.DoubleCheckCycles.NonReentrantModule;
-import dagger.functional.cycle.DoubleCheckCycles.ReentrantModule;
+import com.google.common.util.concurrent.SettableFuture;
+import com.google.common.util.concurrent.Uninterruptibles;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import java.lang.annotation.Retention;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+import javax.inject.Singleton;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -30,47 +45,195 @@
 public class DoubleCheckCycleTest {
   // TODO(b/77916397): Migrate remaining tests in DoubleCheckTest to functional tests in this class.
 
+  /** A qualifier for a reentrant scoped binding. */
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface Reentrant {}
+
+  /** A module to be overridden in each test. */
+  @Module
+  static class OverrideModule {
+    @Provides
+    @Singleton
+    Object provideObject() {
+      throw new IllegalStateException("This method should be overridden in tests");
+    }
+
+    @Provides
+    @Singleton
+    @Reentrant
+    Object provideReentrantObject(@Reentrant Provider<Object> provider) {
+      throw new IllegalStateException("This method should be overridden in tests");
+    }
+  }
+
+  @Singleton
+  @Component(modules = OverrideModule.class)
+  interface TestComponent {
+    Object getObject();
+    @Reentrant Object getReentrantObject();
+  }
+
   @Test
   public void testNonReentrant() {
-    NonReentrantModule module = new NonReentrantModule();
-    DoubleCheckCycles.TestComponent component =
-        DaggerDoubleCheckCycles_TestComponent.builder().nonReentrantModule(module).build();
-
-    assertThat(module.callCount).isEqualTo(0);
-    Object first = component.getNonReentrant();
-    assertThat(module.callCount).isEqualTo(1);
-    Object second = component.getNonReentrant();
-    assertThat(module.callCount).isEqualTo(1);
+    AtomicInteger callCount = new AtomicInteger(0);
+
+    // Provides a non-reentrant binding. The provides method should only be called once.
+    DoubleCheckCycleTest.TestComponent component =
+        DaggerDoubleCheckCycleTest_TestComponent.builder()
+            .overrideModule(
+                new OverrideModule() {
+                  @Override Object provideObject() {
+                    callCount.getAndIncrement();
+                    return new Object();
+                  }
+                })
+            .build();
+
+    assertThat(callCount.get()).isEqualTo(0);
+    Object first = component.getObject();
+    assertThat(callCount.get()).isEqualTo(1);
+    Object second = component.getObject();
+    assertThat(callCount.get()).isEqualTo(1);
     assertThat(first).isSameAs(second);
   }
 
   @Test
   public void testReentrant() {
-    ReentrantModule module = new ReentrantModule();
-    DoubleCheckCycles.TestComponent component =
-        DaggerDoubleCheckCycles_TestComponent.builder().reentrantModule(module).build();
-
-    assertThat(module.callCount).isEqualTo(0);
-    Object first = component.getReentrant();
-    assertThat(module.callCount).isEqualTo(2);
-    Object second = component.getReentrant();
-    assertThat(module.callCount).isEqualTo(2);
+    AtomicInteger callCount = new AtomicInteger(0);
+
+    // Provides a reentrant binding. Even though it's scoped, the provides method is called twice.
+    // In this case, we allow it since the same instance is returned on the second call.
+    DoubleCheckCycleTest.TestComponent component =
+        DaggerDoubleCheckCycleTest_TestComponent.builder()
+            .overrideModule(
+                new OverrideModule() {
+                  @Override Object provideReentrantObject(Provider<Object> provider) {
+                    if (callCount.incrementAndGet() == 1) {
+                      return provider.get();
+                    }
+                    return new Object();
+                  }
+                })
+            .build();
+
+    assertThat(callCount.get()).isEqualTo(0);
+    Object first = component.getReentrantObject();
+    assertThat(callCount.get()).isEqualTo(2);
+    Object second = component.getReentrantObject();
+    assertThat(callCount.get()).isEqualTo(2);
     assertThat(first).isSameAs(second);
   }
 
   @Test
   public void testFailingReentrant() {
-    FailingReentrantModule module = new FailingReentrantModule();
-    DoubleCheckCycles.TestComponent component =
-        DaggerDoubleCheckCycles_TestComponent.builder().failingReentrantModule(module).build();
+    AtomicInteger callCount = new AtomicInteger(0);
+
+    // Provides a failing reentrant binding. Even though it's scoped, the provides method is called
+    // twice. In this case we throw an exception since a different instance is provided on the
+    // second call.
+    DoubleCheckCycleTest.TestComponent component =
+        DaggerDoubleCheckCycleTest_TestComponent.builder()
+            .overrideModule(
+                new OverrideModule() {
+                  @Override Object provideReentrantObject(Provider<Object> provider) {
+                    if (callCount.incrementAndGet() == 1) {
+                      provider.get();
+                      return new Object();
+                    }
+                    return new Object();
+                  }
+                })
+            .build();
 
-    assertThat(module.callCount).isEqualTo(0);
+    assertThat(callCount.get()).isEqualTo(0);
     try {
-      component.getFailingReentrant();
+      component.getReentrantObject();
       fail("Expected IllegalStateException");
     } catch (IllegalStateException e) {
       assertThat(e).hasMessageThat().contains("Scoped provider was invoked recursively");
     }
-    assertThat(module.callCount).isEqualTo(2);
+    assertThat(callCount.get()).isEqualTo(2);
+  }
+
+  @Test(timeout = 5000)
+  public void testGetFromMultipleThreads() throws Exception {
+    AtomicInteger callCount = new AtomicInteger(0);
+    AtomicInteger requestCount = new AtomicInteger(0);
+    SettableFuture<Object> future = SettableFuture.create();
+
+    // Provides a non-reentrant binding. In this case, we return a SettableFuture so that we can
+    // control when the provides method returns.
+    DoubleCheckCycleTest.TestComponent component =
+        DaggerDoubleCheckCycleTest_TestComponent.builder()
+            .overrideModule(
+                new OverrideModule() {
+                  @Override
+                  Object provideObject() {
+                    callCount.incrementAndGet();
+                    try {
+                      return Uninterruptibles.getUninterruptibly(future);
+                    } catch (ExecutionException e) {
+                      throw new RuntimeException(e);
+                    }
+                  }
+                })
+            .build();
+
+    int numThreads = 10;
+    CountDownLatch remainingTasks = new CountDownLatch(numThreads);
+    List<Thread> tasks = new ArrayList<>(numThreads);
+    List<Object> values = Collections.synchronizedList(new ArrayList<>(numThreads));
+
+    // Set up multiple threads that call component.getObject().
+    for (int i = 0; i < numThreads; i++) {
+      tasks.add(
+          new Thread(
+              () -> {
+                requestCount.incrementAndGet();
+                values.add(component.getObject());
+                remainingTasks.countDown();
+              }));
+    }
+
+    // Check initial conditions
+    assertThat(remainingTasks.getCount()).isEqualTo(10);
+    assertThat(requestCount.get()).isEqualTo(0);
+    assertThat(callCount.get()).isEqualTo(0);
+    assertThat(values).isEmpty();
+
+    // Start all threads
+    tasks.forEach(Thread::start);
+
+    // Wait for all threads to wait/block.
+    long waiting = 0;
+    while (waiting != numThreads) {
+      waiting =
+          tasks.stream()
+              .map(Thread::getState)
+              .filter(state -> state == WAITING || state == BLOCKED)
+              .count();
+    }
+
+    // Check the intermediate state conditions.
+    // * All 10 threads should have requested the binding, but none should have finished.
+    // * Only 1 thread should have reached the provides method.
+    // * None of the threads should have set a value (since they are waiting for future to be set).
+    assertThat(remainingTasks.getCount()).isEqualTo(10);
+    assertThat(requestCount.get()).isEqualTo(10);
+    assertThat(callCount.get()).isEqualTo(1);
+    assertThat(values).isEmpty();
+
+    // Set the future and wait on all remaining threads to finish.
+    Object futureValue = new Object();
+    future.set(futureValue);
+    remainingTasks.await();
+
+    // Check the final state conditions.
+    // All values should be set now, and they should all be equal to the same instance.
+    assertThat(remainingTasks.getCount()).isEqualTo(0);
+    assertThat(requestCount.get()).isEqualTo(10);
+    assertThat(callCount.get()).isEqualTo(1);
+    assertThat(values).isEqualTo(Collections.nCopies(numThreads, futureValue));
   }
 }
diff --git a/javatests/dagger/functional/cycle/DoubleCheckCycles.java b/javatests/dagger/functional/cycle/DoubleCheckCycles.java
deleted file mode 100644
index bffb9f77c..000000000
--- a/javatests/dagger/functional/cycle/DoubleCheckCycles.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.cycle;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import java.lang.annotation.Retention;
-import javax.inject.Provider;
-import javax.inject.Qualifier;
-import javax.inject.Singleton;
-
-/**
- * A functional test for scoped providers that recursively call {@link Provider#get()} during
- * construction (b/28829473).
- */
-interface DoubleCheckCycles {
-
-  /** A qualifier for a non-reentrant scoped binding. */
-  @Qualifier
-  @Retention(RUNTIME)
-  @interface NonReentrant {}
-
-  /** Provides a non-reentrant scoped binding. The provides method should only be called once. */
-  @Module
-  final class NonReentrantModule {
-    int callCount;
-
-    @Provides
-    @Singleton
-    @NonReentrant
-    Object provideNonReentrant() {
-      callCount++;
-      return new Object();
-    }
-  }
-
-  /** A qualifier for a reentrant scoped binding. */
-  @Qualifier
-  @Retention(RUNTIME)
-  @interface Reentrant {}
-
-  /**
-   * Provides a reentrant scoped binding. The provides method is actually called twice even though
-   * it's scoped, but we allow this since the same instance is returned both times.
-   */
-  @Module
-  final class ReentrantModule {
-    int callCount;
-
-    @Provides
-    @Singleton
-    @Reentrant
-    Object provideReentrant(@Reentrant Provider<Object> provider) {
-      callCount++;
-      if (callCount == 1) {
-        return provider.get();
-      }
-      return new Object();
-    }
-  }
-
-  /** A qualifier for a failing reentrant scoped binding. */
-  @Qualifier
-  @Retention(RUNTIME)
-  @interface FailingReentrant {}
-
-  /**
-   * Provides a failing reentrant scoped binding. Similar to the other reentrant module, the
-   * provides method is called twice. However, in this case we throw since a different instance is
-   * provided for each call.
-   */
-  @Module
-  final class FailingReentrantModule {
-    int callCount;
-
-    @Provides
-    @Singleton
-    @FailingReentrant
-    Object provideFailingReentrantA(@FailingReentrant Provider<Object> provider) {
-      callCount++;
-      if (callCount == 1) {
-        provider.get();
-        return new Object();
-      }
-      return new Object();
-    }
-  }
-
-  @Singleton
-  @Component(modules = {
-    NonReentrantModule.class,
-    ReentrantModule.class,
-    FailingReentrantModule.class,
-  })
-  interface TestComponent {
-    @NonReentrant Object getNonReentrant();
-    @Reentrant Object getReentrant();
-    @FailingReentrant Object getFailingReentrant();
-  }
-}
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index ac1b7cdbf..9baa04d38 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -115,11 +115,6 @@ public void subcomponent_MissingBinding() {
             GENERATED_ANNOTATION,
             "public abstract class DaggerChild implements Child {",
             "  protected DaggerChild() {}",
-            "",
-            "  @Override",
-            "  public String string() {",
-            "    return null;",
-            "  }",
             "}");
     Compilation compilation =
         daggerCompiler()
@@ -131,6 +126,428 @@ public void subcomponent_MissingBinding() {
         .hasSourceEquivalentTo(generatedSubcomponent);
   }
 
+  @Test
+  public void subcomponent_MissingBindingsSatisfiedByParentAndGrandparent() {
+    JavaFileObject greatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface GreatGrandchild {",
+            "  String string();",
+            "  int number();",
+            "}");
+
+    JavaFileObject generatedGreatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGreatGrandchild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
+            "  protected DaggerGreatGrandchild() {}",
+            "}");
+
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  GreatGrandchild greatGrandchild();",
+            "}");
+
+    JavaFileObject grandchildModule =
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class GrandchildModule {",
+            "  @Provides static String provideString() { return \"hurp\"; }",
+            "}");
+
+    JavaFileObject generatedGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandchild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandchild implements Grandchild {",
+            "  protected DaggerGrandchild() {}",
+            "",
+            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
+            "    protected GreatGrandchildImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public String string() {",
+            "      return GrandchildModule_ProvideStringFactory.proxyProvideString();",
+            "    }",
+            "  }",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides static int provideInt() { return -1; }",
+            "}");
+
+    JavaFileObject generatedChild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
+            "    protected GrandchildImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    public abstract class GreatGrandchildImpl extends",
+            "        DaggerGrandchild.GreatGrandchildImpl {",
+            "      protected GreatGrandchildImpl() {",
+            "        super();",
+            "      }",
+            "",
+            "      @Override",
+            "      public int number() {",
+            "        return ChildModule.provideInt();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(greatGrandchild, grandchild, grandchildModule, child, childModule);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGreatGrandchild")
+        .hasSourceEquivalentTo(generatedGreatGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandchild")
+        .hasSourceEquivalentTo(generatedGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedChild);
+  }
+
+  @Test
+  public void subcomponent_MissingBindingThatLeadsToNewMissingBinding() {
+    JavaFileObject greatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface GreatGrandchild {",
+            "  String string();",
+            "}");
+
+    JavaFileObject generatedGreatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGreatGrandchild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
+            "  protected DaggerGreatGrandchild() {}",
+            "}");
+
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  GreatGrandchild greatGrandchild();",
+            "}");
+
+    JavaFileObject grandchildModule =
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class GrandchildModule {",
+            "  @Provides static String provideString(int number) { return \"hurp\"; }",
+            "}");
+
+    JavaFileObject generatedGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandchild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandchild implements Grandchild {",
+            "  protected DaggerGrandchild() {}",
+            "",
+            "  private String getString() {",
+            "    return GrandchildModule_ProvideStringFactory.proxyProvideString(getInteger());",
+            "  }",
+            "",
+            "  public abstract Integer getInteger();",
+            "",
+            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
+            "    protected GreatGrandchildImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public String string() {",
+            "      return DaggerGrandchild.this.getString();",
+            "    }",
+            "  }",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides static int provideInt() { return -1; }",
+            "}");
+
+    JavaFileObject generatedChild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
+            "    protected GrandchildImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Integer getInteger() {",
+            "      return ChildModule.provideInt();",
+            "    }",
+            "",
+            // TODO(b/72748365): can this class be elided if it's totally empty?
+            "    public abstract class GreatGrandchildImpl extends",
+            "        DaggerGrandchild.GreatGrandchildImpl {",
+            "      protected GreatGrandchildImpl() {",
+            "        super();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(greatGrandchild, grandchild, grandchildModule, child, childModule);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGreatGrandchild")
+        .hasSourceEquivalentTo(generatedGreatGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandchild")
+        .hasSourceEquivalentTo(generatedGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedChild);
+  }
+
+  @Test
+  public void subcomponent_MissingBindingInBothDescendentsAndSatisfiedByParent() {
+    JavaFileObject greatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface GreatGrandchild {",
+            "  String string();",
+            "}");
+
+    JavaFileObject generatedGreatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGreatGrandchild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
+            "  protected DaggerGreatGrandchild() {}",
+            "}");
+
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "  GreatGrandchild greatGrandchild();",
+            "  String string();",
+            "}");
+
+    JavaFileObject generatedGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandchild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandchild implements Grandchild {",
+            "  protected DaggerGrandchild() {}",
+            "",
+            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
+            "    protected GreatGrandchildImpl() {",
+            "      super();",
+            "    }",
+            "  }",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides static String provideString() { return \"hurp\"; }",
+            "}");
+
+    JavaFileObject generatedChild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
+            "    protected GrandchildImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public String string() {",
+            "      return ChildModule_ProvideStringFactory.proxyProvideString();",
+            "    }",
+            "",
+            "    public abstract class GreatGrandchildImpl extends",
+            "        DaggerGrandchild.GreatGrandchildImpl {",
+            "      protected GreatGrandchildImpl() {",
+            "        super();",
+            "      }",
+            "",
+            "      @Override",
+            "      public String string() {",
+            "        return ChildModule_ProvideStringFactory.proxyProvideString();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(greatGrandchild, grandchild, child, childModule);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGreatGrandchild")
+        .hasSourceEquivalentTo(generatedGreatGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandchild")
+        .hasSourceEquivalentTo(generatedGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedChild);
+  }
+
   @Test
   public void subcomponent_BuilderAndGeneratedInstanceBinding() {
     JavaFileObject grandchild =
@@ -212,9 +629,17 @@ public void subcomponent_BuilderAndGeneratedInstanceBinding() {
             "public abstract class DaggerChild implements Child {",
             "  protected DaggerChild() {}",
             "",
-            "  @Override",
-            "  public Grandchild.Builder grandchild() {",
-            "    return null;",
+            "  protected abstract class GrandchildBuilder extends DaggerGrandchild.Builder {",
+            "    @Override",
+            "    public GrandchildBuilder module(GrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
+            "    protected GrandchildImpl(GrandchildBuilder builder) {",
+            "      super(builder);",
+            "    }",
             "  }",
             "}");
     Compilation compilation =
@@ -229,4 +654,158 @@ public void subcomponent_BuilderAndGeneratedInstanceBinding() {
         .generatedSourceFile("test.DaggerChild")
         .hasSourceEquivalentTo(generatedChild);
   }
+
+  @Test
+  public void simpleDeepComponentHierarchy() {
+    JavaFileObject greatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GreatGrandchildModule.class)",
+            "interface GreatGrandchild {",
+            "  Integer i();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder module(GreatGrandchildModule module);",
+            "",
+            "    GreatGrandchild build();",
+            "  }",
+            "}");
+
+    JavaFileObject greatGrandchildModule =
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class GreatGrandchildModule {",
+            "  @Provides static Integer provideInteger() { return 0; }",
+            "}");
+
+    JavaFileObject generatedGreatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGreatGrandchild",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
+            "  protected DaggerGreatGrandchild(Builder builder) {}",
+            "",
+            "  @Override",
+            "  public Integer i() {",
+            "    return GreatGrandchildModule_ProvideIntegerFactory.proxyProvideInteger();",
+            "  }",
+            "",
+            "  protected abstract static class Builder implements GreatGrandchild.Builder {",
+            "",
+            "    @Override",
+            "    public Builder module(GreatGrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "  GreatGrandchild.Builder greatGrandchild();",
+            "}");
+
+    JavaFileObject generatedGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandchild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandchild implements Grandchild {",
+            "  protected DaggerGrandchild() {}",
+            "",
+            "  protected abstract class GreatGrandchildBuilder extends",
+            "      DaggerGreatGrandchild.Builder {",
+            "    @Override",
+            "    public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
+            "    protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
+            "      super(builder);",
+            "    }",
+            "  }",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+
+    JavaFileObject generatedChild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
+            "    protected GrandchildImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    protected abstract class GreatGrandchildBuilder",
+            "        extends DaggerGrandchild.GreatGrandchildBuilder {",
+            "      @Override",
+            "      public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
+            "        return this;",
+            "      }",
+            "    }",
+            "",
+            "    public abstract class GreatGrandchildImpl extends",
+            "        DaggerGrandchild.GreatGrandchildImpl {",
+            "      protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
+            "        super(builder);",
+            "      }",
+            "    }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(child, grandchild, greatGrandchild, greatGrandchildModule);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGreatGrandchild")
+        .hasSourceEquivalentTo(generatedGreatGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandchild")
+        .hasSourceEquivalentTo(generatedGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedChild);
+  }
 }
diff --git a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java b/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
index 07c07859e..479e8031c 100644
--- a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
+++ b/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
@@ -92,13 +92,21 @@ public void returnsVoid() {
   }
 
   @Test
-  public void tooManyQualifiers() {
+  public void tooManyQualifiersOnMethod() {
     assertThatMethod(
             "@Binds @Qualifier1 @Qualifier2 abstract String tooManyQualifiers(String impl);")
         .importing(Qualifier1.class, Qualifier2.class)
         .hasError("more than one @Qualifier");
   }
 
+  @Test
+  public void tooManyQualifiersOnParameter() {
+    assertThatMethod(
+            "@Binds abstract String tooManyQualifiers(@Qualifier1 @Qualifier2 String impl);")
+        .importing(Qualifier1.class, Qualifier2.class)
+        .hasError("more than one @Qualifier");
+  }
+
   @Test
   public void noParameters() {
     assertThatMethod("@Binds abstract Object noParameters();").hasError("one parameter");
diff --git a/javatests/dagger/internal/codegen/BindsMissingDelegateValidationTest.java b/javatests/dagger/internal/codegen/BindsMissingDelegateValidationTest.java
new file mode 100644
index 000000000..28b75beaf
--- /dev/null
+++ b/javatests/dagger/internal/codegen/BindsMissingDelegateValidationTest.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests that errors are reported correctly when a {@code @Binds} method's delegate (the type of its
+ * parameter) is missing.
+ */
+@RunWith(JUnit4.class)
+public class BindsMissingDelegateValidationTest {
+  @Test
+  public void bindsMissingDelegate() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "",
+            "@Component(modules = C.TestModule.class)",
+            "interface C {",
+            "  Object object();",
+            "",
+            "  static class NotBound {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule {",
+            "    @Binds abstract Object bindObject(NotBound notBound);",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.C.NotBound cannot be provided")
+        .inFile(component)
+        .onLineContaining("interface C");
+  }
+
+  @Test
+  public void bindsMissingDelegate_duplicateBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Component(modules = C.TestModule.class)",
+            "interface C {",
+            "  Object object();",
+            "",
+            "  static class NotBound {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule {",
+            "    @Binds abstract Object bindObject(NotBound notBound);",
+            "    @Provides static Object provideObject() { return new Object(); }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    // Some javacs report only the first error for each source line.
+    // Assert that one of the expected errors is reported.
+    assertThat(compilation)
+        .hadErrorContainingMatch(
+            "\\Qtest.C.NotBound cannot be provided\\E|"
+                + message(
+                    "\\Qjava.lang.Object is bound multiple times:",
+                    "    @Binds Object test.C.TestModule.bindObject(test.C.NotBound)",
+                    "    @Provides Object test.C.TestModule.provideObject()\\E"))
+        .inFile(component)
+        .onLineContaining("interface C");
+  }
+
+  @Test
+  public void bindsMissingDelegate_setBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Component(modules = C.TestModule.class)",
+            "interface C {",
+            "  Set<Object> objects();",
+            "",
+            "  static class NotBound {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule {",
+            "    @Binds @IntoSet abstract Object bindObject(NotBound notBound);",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.C.NotBound cannot be provided")
+        .inFile(component)
+        .onLineContaining("interface C");
+  }
+
+  @Test
+  public void bindsMissingDelegate_mapBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Component(modules = C.TestModule.class)",
+            "interface C {",
+            "  Map<String, Object> objects();",
+            "",
+            "  static class NotBound {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule {",
+            "    @Binds @IntoMap @StringKey(\"key\")",
+            "    abstract Object bindObject(NotBound notBound);",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.C.NotBound cannot be provided")
+        .inFile(component)
+        .onLineContaining("interface C");
+  }
+
+  @Test
+  public void bindsMissingDelegate_mapBinding_sameKey() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Component(modules = C.TestModule.class)",
+            "interface C {",
+            "  Map<String, Object> objects();",
+            "",
+            "  static class NotBound {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule {",
+            "    @Binds @IntoMap @StringKey(\"key\")",
+            "    abstract Object bindObject(NotBound notBound);",
+            "",
+            "    @Provides @IntoMap @StringKey(\"key\")",
+            "    static Object provideObject() { return new Object(); }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    // Some javacs report only the first error for each source line.
+    assertThat(compilation)
+        .hadErrorContainingMatch(
+            "\\Qtest.C.NotBound cannot be provided\\E|"
+                + "\\Qsame map key is bound more than once\\E")
+        .inFile(component)
+        .onLineContaining("interface C");
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index f140cbf5c..43603c3e8 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -2184,7 +2184,7 @@ public void bindsToDuplicateBinding_bindsKeyIsNotDuplicated() {
     assertThat(compilation)
         .hadErrorContaining("java.lang.String is bound multiple times")
         .inFile(component)
-        .onLineContaining("Object notDuplicated();");
+        .onLineContaining("interface TestComponent");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/ComponentValidationTest.java b/javatests/dagger/internal/codegen/ComponentValidationTest.java
index 5a84052b9..2208b4a18 100644
--- a/javatests/dagger/internal/codegen/ComponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/ComponentValidationTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
@@ -201,4 +202,158 @@ public void moduleInDependencies() {
         .hadErrorContaining("test.TestModule is a module, which cannot be a component dependency");
   }
 
+  @Test
+  public void componentDependencyMustNotCycle_Direct() {
+    JavaFileObject shortLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentShort",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = ComponentShort.class)",
+            "interface ComponentShort {",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(shortLifetime);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentShort contains a cycle in its component dependencies:",
+                "    test.ComponentShort"));
+  }
+
+  @Test
+  public void componentDependencyMustNotCycle_Indirect() {
+    JavaFileObject longLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentLong",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = ComponentMedium.class)",
+            "interface ComponentLong {",
+            "}");
+    JavaFileObject mediumLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentMedium",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = ComponentLong.class)",
+            "interface ComponentMedium {",
+            "}");
+    JavaFileObject shortLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentShort",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = ComponentMedium.class)",
+            "interface ComponentShort {",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(longLifetime, mediumLifetime, shortLifetime);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentLong contains a cycle in its component dependencies:",
+                "    test.ComponentLong",
+                "    test.ComponentMedium",
+                "    test.ComponentLong"))
+        .inFile(longLifetime);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentMedium contains a cycle in its component dependencies:",
+                "    test.ComponentMedium",
+                "    test.ComponentLong",
+                "    test.ComponentMedium"))
+        .inFile(mediumLifetime);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentShort contains a cycle in its component dependencies:",
+                "    test.ComponentMedium",
+                "    test.ComponentLong",
+                "    test.ComponentMedium",
+                "    test.ComponentShort"))
+        .inFile(shortLifetime);
+  }
+
+  @Test
+  public void abstractModuleWithInstanceMethod() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides int i() { return 1; }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  int i();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("TestModule is abstract and has instance @Provides methods")
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void abstractModuleWithInstanceMethod_subclassedIsAllowed() {
+    JavaFileObject abstractModule =
+        JavaFileObjects.forSourceLines(
+            "test.AbstractModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class AbstractModule {",
+            "  @Provides int i() { return 1; }",
+            "}");
+    JavaFileObject subclassedModule =
+        JavaFileObjects.forSourceLines(
+            "test.SubclassedModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "class SubclassedModule extends AbstractModule {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = SubclassedModule.class)",
+            "interface TestComponent {",
+            "  int i();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(abstractModule, subclassedModule, component);
+    assertThat(compilation).succeeded();
+  }
 }
diff --git a/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java b/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java
index ea904474b..7ffd922a3 100644
--- a/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java
+++ b/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java
@@ -72,8 +72,8 @@ public void covariantType() {
         .hadErrorContaining(
             message(
                 "conflicting entry point declarations:",
-                "Long test.Base1.foo()",
-                "Number test.Base2.foo()"))
+                "    Long test.Base1.foo()",
+                "    Number test.Base2.foo()"))
         .inFile(component)
         .onLineContaining("interface TestComponent ");
   }
@@ -120,8 +120,8 @@ public void covariantTypeFromGenericSupertypes() {
         .hadErrorContaining(
             message(
                 "conflicting entry point declarations:",
-                "Long test.Base1.foo()",
-                "Number test.Base2.foo()"))
+                "    Long test.Base1.foo()",
+                "    Number test.Base2.foo()"))
         .inFile(component)
         .onLineContaining("interface TestComponent ");
   }
@@ -171,8 +171,8 @@ public void differentQualifier() {
         .hadErrorContaining(
             message(
                 "conflicting entry point declarations:",
-                "Object test.Base1.foo()",
-                "@Named(\"foo\") Object test.Base2.foo()"))
+                "    Object test.Base1.foo()",
+                "    @Named(\"foo\") Object test.Base2.foo()"))
         .inFile(component)
         .onLineContaining("interface TestComponent ");
   }
diff --git a/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java b/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
new file mode 100644
index 000000000..9fcaeacf7
--- /dev/null
+++ b/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
@@ -0,0 +1,651 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class DependencyCycleValidationTest {
+  @Test public void cyclicDependency() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  static class A {",
+        "    @Inject A(C cParam) {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject B(A aParam) {}",
+        "  }",
+        "",
+        "  static class C {",
+        "    @Inject C(B bParam) {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface CComponent {",
+        "    C getC();",
+        "  }",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.A.<init>(cParam)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is provided at",
+                "        test.Outer.CComponent.getC()"))
+        .inFile(component)
+        .onLineContaining("interface CComponent");
+  }
+
+  @Test public void cyclicDependencyNotIncludingEntryPoint() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(C cParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D(C cParam) {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface DComponent {",
+            "    D getD();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.A.<init>(cParam)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is injected at",
+                "        test.Outer.D.<init>(cParam)",
+                "    test.Outer.D is provided at",
+                "        test.Outer.DComponent.getD()"))
+        .inFile(component)
+        .onLineContaining("interface DComponent");
+  }
+
+  @Test
+  public void cyclicDependencyNotBrokenByMapBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(Map<String, C> cMap) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  @Component(modules = CModule.class)",
+            "  interface CComponent {",
+            "    C getC();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides @IntoMap",
+            "    @StringKey(\"C\")",
+            "    static C c(C c) {",
+            "      return c;",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.CModule.c(c)",
+                "    java.util.Map<java.lang.String,test.Outer.C> is injected at",
+                "        test.Outer.A.<init>(cMap)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is provided at",
+                "        test.Outer.CComponent.getC()"))
+        .inFile(component)
+        .onLineContaining("interface CComponent");
+  }
+
+  @Test
+  public void cyclicDependencyWithSetBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(Set<C> cSet) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  @Component(modules = CModule.class)",
+            "  interface CComponent {",
+            "    C getC();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides @IntoSet",
+            "    static C c(C c) {",
+            "      return c;",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.CModule.c(c)",
+                "    java.util.Set<test.Outer.C> is injected at",
+                "        test.Outer.A.<init>(cSet)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is provided at",
+                "        test.Outer.CComponent.getC()"))
+        .inFile(component)
+        .onLineContaining("interface CComponent");
+  }
+
+  @Test
+  public void falsePositiveCyclicDependencyIndirectionDetected() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(C cParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D(Provider<C> cParam) {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface DComponent {",
+            "    D getD();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.A.<init>(cParam)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    javax.inject.Provider<test.Outer.C> is injected at",
+                "        test.Outer.D.<init>(cParam)",
+                "    test.Outer.D is provided at",
+                "        test.Outer.DComponent.getD()"))
+        .inFile(component)
+        .onLineContaining("interface DComponent");
+  }
+
+  @Test
+  public void cyclicDependencyInSubcomponents() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Parent {",
+            "  Child.Builder child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = CycleModule.class)",
+            "interface Child {",
+            "  Grandchild.Builder grandchild();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "  String entry();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Grandchild build();",
+            "  }",
+            "}");
+    JavaFileObject cycleModule =
+        JavaFileObjects.forSourceLines(
+            "test.CycleModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class CycleModule {",
+            "  @Provides static Object object(String string) {",
+            "    return string;",
+            "  }",
+            "",
+            "  @Provides static String string(Object object) {",
+            "    return object.toString();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, cycleModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    java.lang.String is injected at",
+                "        test.CycleModule.object(string)",
+                "    java.lang.Object is injected at",
+                "        test.CycleModule.string(object)",
+                "    java.lang.String is provided at",
+                "        test.Grandchild.entry()"))
+        .inFile(parent)
+        .onLineContaining("interface Parent");
+  }
+
+  @Test
+  public void cyclicDependencyInSubcomponentsWithChildren() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Parent {",
+            "  Child.Builder child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = CycleModule.class)",
+            "interface Child {",
+            "  String entry();",
+            "",
+            "  Grandchild grandchild();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "}");
+    // Grandchild has no entry point that depends on the cycle. http://b/111317986
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Grandchild build();",
+            "  }",
+            "}");
+    JavaFileObject cycleModule =
+        JavaFileObjects.forSourceLines(
+            "test.CycleModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class CycleModule {",
+            "  @Provides static Object object(String string) {",
+            "    return string;",
+            "  }",
+            "",
+            "  @Provides static String string(Object object) {",
+            "    return object.toString();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, cycleModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    java.lang.String is injected at",
+                "        test.CycleModule.object(string)",
+                "    java.lang.Object is injected at",
+                "        test.CycleModule.string(object)",
+                "    java.lang.String is provided at",
+                "        test.Child.entry() [test.Parent → test.Child]"))
+        .inFile(parent)
+        .onLineContaining("interface Parent");
+  }
+
+  @Test
+  public void circularBindsMethods() {
+    JavaFileObject qualifier =
+        JavaFileObjects.forSourceLines(
+            "test.SomeQualifier",
+            "package test;",
+            "",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Qualifier @interface SomeQualifier {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Binds abstract Object bindUnqualified(@SomeQualifier Object qualified);",
+            "  @Binds @SomeQualifier abstract Object bindQualified(Object unqualified);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Object unqualified();",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(qualifier, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    java.lang.Object is injected at",
+                "        test.TestModule.bindQualified(unqualified)",
+                "    @test.SomeQualifier java.lang.Object is injected at",
+                "        test.TestModule.bindUnqualified(qualified)",
+                "    java.lang.Object is provided at",
+                "        test.TestComponent.unqualified()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void selfReferentialBinds() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Binds abstract Object bindToSelf(Object sameKey);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Object selfReferential();",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    java.lang.Object is injected at",
+                "        test.TestModule.bindToSelf(sameKey)",
+                "    java.lang.Object is provided at",
+                "        test.TestComponent.selfReferential()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void cycleFromMembersInjectionMethod_WithSameKeyAsMembersInjectionMethod() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class A {",
+            "  @Inject A() {}",
+            "  @Inject B b;",
+            "}");
+    JavaFileObject b =
+        JavaFileObjects.forSourceLines(
+            "test.B",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class B {",
+            "  @Inject B() {}",
+            "  @Inject A a;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.CycleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface CycleComponent {",
+            "  void inject(A a);",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(a, b, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.B is injected at",
+                "        test.A.b",
+                "    test.A is injected at",
+                "        test.B.a",
+                "    test.B is injected at",
+                "        test.A.b",
+                "    test.A is injected at",
+                "        test.CycleComponent.inject(test.A)"))
+        .inFile(component)
+        .onLineContaining("interface CycleComponent");
+  }
+
+  @Test
+  public void longCycleMaskedByShortBrokenCycles() {
+    JavaFileObject cycles =
+        JavaFileObjects.forSourceLines(
+            "test.Cycles",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "import dagger.Component;",
+            "",
+            "final class Cycles {",
+            "  static class A {",
+            "    @Inject A(Provider<A> aProvider, B b) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(Provider<B> bProvider, A a) {}",
+            "  }",
+            "",
+            "  @Component",
+            "  interface C {",
+            "    A a();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(cycles);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Found a dependency cycle:")
+        .inFile(cycles)
+        .onLineContaining("interface C");
+  }
+}
diff --git a/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java b/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java
new file mode 100644
index 000000000..232445785
--- /dev/null
+++ b/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java
@@ -0,0 +1,757 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class DuplicateBindingsValidationTest {
+  @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  interface B {}",
+        "",
+        "  @Module",
+        "  static class AModule {",
+        "    @Provides String provideString() { return \"\"; }",
+        "    @Provides A provideA(String s) { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = AModule.class)",
+        "  interface Parent {",
+        "    A getA();",
+        "  }",
+        "",
+        "  @Module",
+        "  static class BModule {",
+        "    @Provides B provideB(A a) { return new B() {}; }",
+        "  }",
+        "",
+        "  @Component(dependencies = Parent.class, modules = { BModule.class, AModule.class})",
+        "  interface Child {",
+        "    B getB();",
+        "  }",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.AModule.provideA(String)",
+                "    test.Outer.A test.Outer.Parent.getA()"))
+        .inFile(component)
+        .onLineContaining("interface Child");
+  }
+
+  @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  @Module",
+        "  static class Module1 {",
+        "    @Provides A provideA1() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module2 {",
+        "    @Provides String provideString() { return \"\"; }",
+        "    @Provides A provideA2(String s) { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = { Module1.class, Module2.class})",
+        "  interface TestComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.Module1.provideA1()",
+                "    @Provides test.Outer.A test.Outer.Module2.provideA2(String)"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void duplicateExplicitBindings_ProvidesVsBinds() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  interface A {}",
+            "",
+            "  static final class B implements A {",
+            "    @Inject B() {}",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module1 {",
+            "    @Provides A provideA1() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static abstract class Module2 {",
+            "    @Binds abstract A bindA2(B b);",
+            "  }",
+            "",
+            "  @Component(modules = { Module1.class, Module2.class})",
+            "  interface TestComponent {",
+            "    A getA();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.Module1.provideA1()",
+                "    @Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void duplicateExplicitBindings_multibindingsAndExplicitSets() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.HashSet;",
+            "import java.util.Set;",
+            "import javax.inject.Qualifier;",
+            "",
+            "final class Outer {",
+            "  @Qualifier @interface SomeQualifier {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule1 {",
+            "    @Provides @IntoSet static String stringSetElement() { return \"\"; }",
+            "",
+            "    @Binds",
+            "    @IntoSet abstract String bindStringSetElement(@SomeQualifier String value);",
+            "",
+            "    @Provides @SomeQualifier",
+            "    static String provideSomeQualifiedString() { return \"\"; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class TestModule2 {",
+            "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
+            "  }",
+            "",
+            "  @Component(modules = { TestModule1.class, TestModule2.class })",
+            "  interface TestComponent {",
+            "    Set<String> getStringSet();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Set<java.lang.String> has incompatible bindings or declarations:",
+                "    Set bindings and declarations:",
+                "        @Binds @dagger.multibindings.IntoSet String "
+                    + "test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier "
+                    + "String)",
+                "        @Provides @dagger.multibindings.IntoSet String "
+                    + "test.Outer.TestModule1.stringSetElement()",
+                "    Unique bindings and declarations:",
+                "        @Provides Set<String> test.Outer.TestModule2.stringSet()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void duplicateExplicitBindings_multibindingsAndExplicitMaps() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.HashMap;",
+            "import java.util.Map;",
+            "import javax.inject.Qualifier;",
+            "",
+            "final class Outer {",
+            "  @Qualifier @interface SomeQualifier {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule1 {",
+            "    @Provides @IntoMap",
+            "    @StringKey(\"foo\")",
+            "    static String stringMapEntry() { return \"\"; }",
+            "",
+            "    @Binds @IntoMap @StringKey(\"bar\")",
+            "    abstract String bindStringMapEntry(@SomeQualifier String value);",
+            "",
+            "    @Provides @SomeQualifier",
+            "    static String provideSomeQualifiedString() { return \"\"; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class TestModule2 {",
+            "    @Provides Map<String, String> stringMap() {",
+            "      return new HashMap<String, String>();",
+            "    }",
+            "  }",
+            "",
+            "  @Component(modules = { TestModule1.class, TestModule2.class })",
+            "  interface TestComponent {",
+            "    Map<String, String> getStringMap();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+                    + "or declarations:",
+                "    Map bindings and declarations:",
+                "        @Binds @dagger.multibindings.IntoMap "
+                    + "@dagger.multibindings.StringKey(\"bar\") String"
+                    + " test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier "
+                    + "String)",
+                "        @Provides @dagger.multibindings.IntoMap "
+                    + "@dagger.multibindings.StringKey(\"foo\") String"
+                    + " test.Outer.TestModule1.stringMapEntry()",
+                "    Unique bindings and declarations:",
+                "        @Provides Map<String,String> test.Outer.TestModule2.stringMap()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Set() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.HashSet;",
+            "import java.util.Set;",
+            "",
+            "final class Outer {",
+            "  @Module",
+            "  abstract static class TestModule1 {",
+            "    @Multibinds abstract Set<String> stringSet();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class TestModule2 {",
+            "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
+            "  }",
+            "",
+            "  @Component(modules = { TestModule1.class, TestModule2.class })",
+            "  interface TestComponent {",
+            "    Set<String> getStringSet();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Set<java.lang.String> has incompatible bindings or declarations:",
+                "    Set bindings and declarations:",
+                "        @dagger.multibindings.Multibinds Set<String> "
+                    + "test.Outer.TestModule1.stringSet()",
+                "    Unique bindings and declarations:",
+                "        @Provides Set<String> test.Outer.TestModule2.stringSet()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Map() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.HashMap;",
+            "import java.util.Map;",
+            "",
+            "final class Outer {",
+            "  @Module",
+            "  abstract static class TestModule1 {",
+            "    @Multibinds abstract Map<String, String> stringMap();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class TestModule2 {",
+            "    @Provides Map<String, String> stringMap() {",
+            "      return new HashMap<String, String>();",
+            "    }",
+            "  }",
+            "",
+            "  @Component(modules = { TestModule1.class, TestModule2.class })",
+            "  interface TestComponent {",
+            "    Map<String, String> getStringMap();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+                    + "or declarations:",
+                "    Map bindings and declarations:",
+                "        @dagger.multibindings.Multibinds Map<String,String> "
+                    + "test.Outer.TestModule1.stringMap()",
+                "    Unique bindings and declarations:",
+                "        @Provides Map<String,String> test.Outer.TestModule2.stringMap()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test public void duplicateBindings_TruncateAfterLimit() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  interface A {}",
+            "",
+            "  @Module",
+            "  static class Module01 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module02 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module03 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module04 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module05 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module06 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module07 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module08 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module09 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module10 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module11 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module12 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Component(modules = {",
+            "    Module01.class,",
+            "    Module02.class,",
+            "    Module03.class,",
+            "    Module04.class,",
+            "    Module05.class,",
+            "    Module06.class,",
+            "    Module07.class,",
+            "    Module08.class,",
+            "    Module09.class,",
+            "    Module10.class,",
+            "    Module11.class,",
+            "    Module12.class",
+            "  })",
+            "  interface TestComponent {",
+            "    A getA();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.Module01.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module02.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module03.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module04.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module05.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module06.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module07.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module08.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module09.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module10.provideA()",
+                "    and 2 others"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void childBindingConflictsWithParent() {
+    JavaFileObject aComponent =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Component(modules = A.AModule.class)",
+            "interface A {",
+            "  Object conflict();",
+            "",
+            "  B b();",
+            "",
+            "  @Module",
+            "  static class AModule {",
+            "    @Provides static Object abConflict() {",
+            "      return \"a\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject bComponent =
+        JavaFileObjects.forSourceLines(
+            "test.B",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = B.BModule.class)",
+            "interface B {",
+            "  Object conflict();",
+            "",
+            "  @Module",
+            "  static class BModule {",
+            "    @Provides static Object abConflict() {",
+            "      return \"b\";",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(aComponent, bComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.A.AModule.abConflict()",
+                "    @Provides Object test.B.BModule.abConflict()"))
+        .inFile(aComponent)
+        .onLineContaining("interface A {");
+  }
+
+  @Test
+  public void grandchildBindingConflictsWithGrandparent() {
+    JavaFileObject aComponent =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Component(modules = A.AModule.class)",
+            "interface A {",
+            "  Object conflict();",
+            "",
+            "  B b();",
+            "",
+            "  @Module",
+            "  static class AModule {",
+            "    @Provides static Object acConflict() {",
+            "      return \"a\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject bComponent =
+        JavaFileObjects.forSourceLines(
+            "test.B",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface B {",
+            "  C c();",
+            "}");
+    JavaFileObject cComponent =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = C.CModule.class)",
+            "interface C {",
+            "  Object conflict();",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides static Object acConflict() {",
+            "      return \"c\";",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.A.AModule.acConflict()",
+                "    @Provides Object test.C.CModule.acConflict()"))
+        .inFile(aComponent)
+        .onLineContaining("interface A {");
+  }
+
+  @Test
+  public void grandchildBindingConflictsWithChild() {
+    JavaFileObject aComponent =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface A {",
+            "  B b();",
+            "}");
+    JavaFileObject bComponent =
+        JavaFileObjects.forSourceLines(
+            "test.B",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = B.BModule.class)",
+            "interface B {",
+            "  Object conflict();",
+            "",
+            "  C c();",
+            "",
+            "  @Module",
+            "  static class BModule {",
+            "    @Provides static Object bcConflict() {",
+            "      return \"b\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject cComponent =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = C.CModule.class)",
+            "interface C {",
+            "  Object conflict();",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides static Object bcConflict() {",
+            "      return \"c\";",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.B.BModule.bcConflict()",
+                "    @Provides Object test.C.CModule.bcConflict()"))
+        .inFile(aComponent)
+        .onLineContaining("interface A {");
+  }
+
+  @Test
+  public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning() {
+    JavaFileObject parentConflictsWithChild =
+        JavaFileObjects.forSourceLines(
+            "test.ParentConflictsWithChild",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.annotation.Nullable;",
+            "",
+            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
+            "interface ParentConflictsWithChild {",
+            "  Child child();",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
+            "    @Provides @Nullable static Object nullableParentChildConflict() {",
+            "      return \"parent\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = Child.ChildModule.class)",
+            "interface Child {",
+            "  Object parentChildConflictThatViolatesNullability();",
+            "",
+            "  @Module",
+            "  static class ChildModule {",
+            "    @Provides static Object nonNullableParentChildConflict() {",
+            "      return \"child\";",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(parentConflictsWithChild, child);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.Child.ChildModule.nonNullableParentChildConflict()",
+                "    @Provides @javax.annotation.Nullable Object"
+                    + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()"))
+        .inFile(parentConflictsWithChild)
+        .onLine(9);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
index bd7ccb744..2e7aa7d2a 100644
--- a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
@@ -62,13 +63,15 @@
         "  @Provides long integer() { return 0L; }",
         "  @Provides float floatingPoint() { return 0.0f; }",
         "}");
-    String errorMessage =
-        "test.MyComponent (unscoped) may not reference scoped bindings:\n"
-            + "      @Singleton class test.ScopedType\n"
-            + "      @Provides @Singleton String test.ScopedModule.string()";
+
     Compilation compilation = daggerCompiler().compile(componentFile, typeFile, moduleFile);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.MyComponent (unscoped) may not reference scoped bindings:",
+                "    @Singleton class test.ScopedType",
+                "    @Provides @Singleton String test.ScopedModule.string()"));
   }
 
   @Test // b/79859714
@@ -146,8 +149,10 @@ public void bindsWithChildScope_inParentModule_notAllowed() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "test.Parent scoped with @Singleton may not reference bindings with different scopes:\n"
-                + "      @Binds @test.ChildScope test.Foo test.ParentModule.bind(test.FooImpl)");
+            message(
+                "test.Parent scoped with @Singleton may not reference bindings with different "
+                    + "scopes:",
+                "    @Binds @test.ChildScope test.Foo test.ParentModule.bind(test.FooImpl)"));
   }
 
   @Test public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
@@ -203,17 +208,20 @@ public void bindsWithChildScope_inParentModule_notAllowed() {
         "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
         "  @Provides @Per(MyComponent.class) boolean bool() { return false; }", // incompatible
         "}");
-    String errorMessage =
-        "test.MyComponent scoped with @Singleton "
-            + "may not reference bindings with different scopes:\n"
-            + "      @test.PerTest class test.ScopedType\n"
-            + "      @Provides @test.PerTest String test.ScopedModule.string()\n"
-            + "      @Provides @test.Per(test.MyComponent.class) boolean test.ScopedModule.bool()";
+
     Compilation compilation =
         daggerCompiler()
             .compile(componentFile, scopeFile, scopeWithAttribute, typeFile, moduleFile);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.MyComponent scoped with @Singleton "
+                    + "may not reference bindings with different scopes:",
+                "    @test.PerTest class test.ScopedType",
+                "    @Provides @test.PerTest String test.ScopedModule.string()",
+                "    @Provides @test.Per(test.MyComponent.class) boolean "
+                    + "test.ScopedModule.bool()"));
   }
 
   @Test public void componentWithScopeMayDependOnOnlyOneScopedComponent() {
@@ -276,16 +284,19 @@ public void bindsWithChildScope_inParentModule_notAllowed() {
         "interface SimpleScopedComponent {",
         "  SimpleType.A type();",
         "}");
-    String errorMessage =
-        "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped component:\n"
-        + "      @Singleton test.SingletonComponentA\n"
-        + "      @Singleton test.SingletonComponentB";
+
     Compilation compilation =
         daggerCompiler()
             .compile(
                 type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped "
+                    + "component:",
+                "    @Singleton test.SingletonComponentA",
+                "    @Singleton test.SingletonComponentB"));
   }
 
   @Test public void componentWithoutScopeCannotDependOnScopedComponent() {
@@ -318,12 +329,14 @@ public void bindsWithChildScope_inParentModule_notAllowed() {
         "interface UnscopedComponent {",
         "  SimpleType type();",
         "}");
-    String errorMessage =
-        "test.UnscopedComponent (unscoped) cannot depend on scoped components:\n"
-        + "      @Singleton test.ScopedComponent";
+
     Compilation compilation = daggerCompiler().compile(type, scopedComponent, unscopedComponent);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.UnscopedComponent (unscoped) cannot depend on scoped components:",
+                "    @Singleton test.ScopedComponent"));
   }
 
   @Test public void componentWithSingletonScopeMayNotDependOnOtherScope() {
@@ -363,13 +376,15 @@ public void bindsWithChildScope_inParentModule_notAllowed() {
         "interface SingletonComponent {",
         "  SimpleType type();",
         "}");
-    String errorMessage =
-        "This @Singleton component cannot depend on scoped components:\n"
-        + "      @test.SimpleScope test.SimpleScopedComponent";
+
     Compilation compilation =
         daggerCompiler().compile(type, simpleScope, simpleScoped, singletonScoped);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "This @Singleton component cannot depend on scoped components:",
+                "    @test.SimpleScope test.SimpleScopedComponent"));
   }
 
   @Test public void componentScopeAncestryMustNotCycle() {
@@ -426,15 +441,18 @@ public void bindsWithChildScope_inParentModule_notAllowed() {
         "interface ComponentShort {",
         "  SimpleType type();",
         "}");
-    String errorMessage =
-        "test.ComponentShort depends on scoped components in a non-hierarchical scope ordering:\n"
-        + "      @test.ScopeA test.ComponentLong\n"
-        + "      @test.ScopeB test.ComponentMedium\n"
-        + "      @test.ScopeA test.ComponentShort";
+
     Compilation compilation =
         daggerCompiler().compile(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentShort depends on scoped components in a non-hierarchical scope "
+                    + "ordering:",
+                "    @test.ScopeA test.ComponentLong",
+                "    @test.ScopeB test.ComponentMedium",
+                "    @test.ScopeA test.ComponentShort"));
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
deleted file mode 100644
index 2abceae51..000000000
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ /dev/null
@@ -1,2871 +0,0 @@
-/*
- * Copyright (C) 2014 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.Compiler.javac;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.NonNullableRequestForNullableBindingValidation.nullableToNonNullable;
-import static dagger.internal.codegen.TestUtils.message;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class GraphValidationTest {
-  private static final JavaFileObject NULLABLE =
-      JavaFileObjects.forSourceLines(
-          "test.Nullable", // force one-string-per-line format
-          "package test;",
-          "",
-          "public @interface Nullable {}");
-
-  @Test public void componentOnConcreteClass() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface MyComponent {",
-        "  Foo getFoo();",
-        "}");
-    JavaFileObject injectable = JavaFileObjects.forSourceLines("test.Foo",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class Foo {",
-        "  @Inject Foo(Bar bar) {}",
-        "}");
-    JavaFileObject nonInjectable = JavaFileObjects.forSourceLines("test.Bar",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "interface Bar {}");
-    Compilation compilation = daggerCompiler().compile(component, injectable, nonInjectable);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
-        .inFile(component)
-        .onLine(7);
-  }
-
-  @Test public void componentProvisionWithNoDependencyChain() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestClass",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Qualifier;",
-            "",
-            "final class TestClass {",
-            "  @Qualifier @interface Q {}",
-            "  interface A {}",
-            "",
-            "  @Component()",
-            "  interface AComponent {",
-            "    A getA();",
-            "    @Q A qualifiedA();",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "test.TestClass.A cannot be provided without an @Provides-annotated method.")
-        .inFile(component)
-        .onLine(12);
-    assertThat(compilation)
-        .hadErrorContaining(
-            "@test.TestClass.Q test.TestClass.A "
-                + "cannot be provided without an @Provides-annotated method.")
-        .inFile(component)
-        .onLine(13);
-  }
-
-  @Test public void constructorInjectionWithoutAnnotation() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class TestClass {",
-        "  static class A {",
-        "    A() {}",
-        "  }",
-        "",
-        "  @Component()",
-        "  interface AComponent {",
-        "    A getA();",
-        "  }",
-        "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Inject constructor or an "
-            + "@Provides-annotated method.";
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(15);
-  }
-
-  @Test public void membersInjectWithoutProvision() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class TestClass {",
-        "  static class A {",
-        "    @Inject A() {}",
-        "  }",
-        "",
-        "  static class B {",
-        "    @Inject A a;",
-        "  }",
-        "",
-        "  @Component()",
-        "  interface AComponent {",
-        "    B getB();",
-        "  }",
-        "}");
-    String expectedError =
-        "test.TestClass.B cannot be provided without an @Inject constructor or an "
-            + "@Provides-annotated method. This type supports members injection but cannot be "
-            + "implicitly provided.";
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(19);
-  }
-
-  @Test
-  public void membersInjectDependsOnUnboundedType() {
-    JavaFileObject injectsUnboundedType =
-        JavaFileObjects.forSourceLines(
-            "test.InjectsUnboundedType",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import java.util.ArrayList;",
-            "import javax.inject.Inject;",
-            "",
-            "class InjectsUnboundedType {",
-            "  @Inject MembersInjector<ArrayList<?>> listInjector;",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  void injectsUnboundedType(InjectsUnboundedType injects);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(injectsUnboundedType, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            Joiner.on('\n')
-                .join(
-                    "Cannot inject members into types with unbounded type arguments: "
-                        + "java.util.ArrayList<?>",
-                    "      dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
-                    "          test.InjectsUnboundedType.listInjector",
-                    "      test.InjectsUnboundedType is injected at",
-                    "          test.TestComponent.injectsUnboundedType(test.InjectsUnboundedType)"))
-        .inFile(component)
-        .onLine(7);
-  }
-
-  @Ignore // TODO(b/77220343)
-  @Test
-  public void membersInjectPrimitive() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  void inject(int primitive);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("Cannot inject members into int")
-        .inFile(component)
-        .onLineContaining("void inject(int primitive);");
-  }
-
-  @Ignore // TODO(b/77220343)
-  @Test
-  public void membersInjectArray() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  void inject(Object[] array);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("Cannot inject members into java.lang.Object[]")
-        .inFile(component)
-        .onLineContaining("void inject(Object[] array);");
-  }
-
-  @Ignore // TODO(b/77220343)
-  @Test
-  public void membersInjectorOfArray() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.MembersInjector;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  MembersInjector<Object[]> objectArrayInjector();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("Cannot inject members into java.lang.Object[]")
-        .inFile(component)
-        .onLineContaining("objectArrayInjector();");
-  }
-
-  @Test
-  public void membersInjectRawType() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import java.util.Set;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  void inject(Set rawSet);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("Cannot inject members into raw type java.util.Set");
-  }
-
-  @Test
-  public void staticFieldInjection() {
-    JavaFileObject injected =
-        JavaFileObjects.forSourceLines(
-            "test.Injected",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "final class Injected {",
-            "  @Inject static Object object;",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  void inject(Injected injected);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(injected, component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("static fields").inFile(injected).onLine(6);
-  }
-
-  @Test public void cyclicDependency() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class Outer {",
-        "  static class A {",
-        "    @Inject A(C cParam) {}",
-        "  }",
-        "",
-        "  static class B {",
-        "    @Inject B(A aParam) {}",
-        "  }",
-        "",
-        "  static class C {",
-        "    @Inject C(B bParam) {}",
-        "  }",
-        "",
-        "  @Component()",
-        "  interface CComponent {",
-        "    C getC();",
-        "  }",
-        "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is provided at",
-                "          test.Outer.CComponent.getC()");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(23);
-  }
-
-  @Test public void cyclicDependencyNotIncludingEntryPoint() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(C cParam) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(A aParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(B bParam) {}",
-            "  }",
-            "",
-            "  static class D {",
-            "    @Inject D(C cParam) {}",
-            "  }",
-            "",
-            "  @Component()",
-            "  interface DComponent {",
-            "    D getD();",
-            "  }",
-            "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is injected at",
-                "          test.Outer.D.<init>(cParam)",
-                "      test.Outer.D is provided at",
-                "          test.Outer.DComponent.getD()");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(27);
-  }
-
-  @Test
-  public void cyclicDependencyNotBrokenByMapBinding() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.MapKey;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import java.util.Map;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(Map<String, C> cMap) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(A aParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(B bParam) {}",
-            "  }",
-            "",
-            "  @Component(modules = CModule.class)",
-            "  interface CComponent {",
-            "    C getC();",
-            "  }",
-            "",
-            "  @Module",
-            "  static class CModule {",
-            "    @Provides @IntoMap",
-            "    @StringKey(\"C\")",
-            "    static C c(C c) {",
-            "      return c;",
-            "    }",
-            "  }",
-            "",
-            "  @MapKey",
-            "  @interface StringKey {",
-            "    String value();",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "Found a dependency cycle:",
-                "test.Outer.C is injected at",
-                "    test.Outer.CModule.c(c)",
-                "java.util.Map<java.lang.String,test.Outer.C> is injected at",
-                "    test.Outer.A.<init>(cMap)",
-                "test.Outer.A is injected at",
-                "    test.Outer.B.<init>(aParam)",
-                "test.Outer.B is injected at",
-                "    test.Outer.C.<init>(bParam)",
-                "test.Outer.C is provided at",
-                "    test.Outer.CComponent.getC()"))
-        .inFile(component)
-        .onLineContaining("C getC();");
-  }
-
-  @Test
-  public void cyclicDependencyWithSetBinding() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Set;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(Set<C> cSet) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(A aParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(B bParam) {}",
-            "  }",
-            "",
-            "  @Component(modules = CModule.class)",
-            "  interface CComponent {",
-            "    C getC();",
-            "  }",
-            "",
-            "  @Module",
-            "  static class CModule {",
-            "    @Provides @IntoSet",
-            "    static C c(C c) {",
-            "      return c;",
-            "    }",
-            "  }",
-            "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.CModule.c(c)",
-                "      java.util.Set<test.Outer.C> is injected at",
-                "          test.Outer.A.<init>(cSet)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is provided at",
-                "          test.Outer.CComponent.getC()");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(25);
-  }
-
-  @Test
-  public void falsePositiveCyclicDependencyIndirectionDetected() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(C cParam) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(A aParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(B bParam) {}",
-            "  }",
-            "",
-            "  static class D {",
-            "    @Inject D(Provider<C> cParam) {}",
-            "  }",
-            "",
-            "  @Component()",
-            "  interface DComponent {",
-            "    D getD();",
-            "  }",
-            "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      javax.inject.Provider<test.Outer.C> is injected at",
-                "          test.Outer.D.<init>(cParam)",
-                "      test.Outer.D is provided at",
-                "          test.Outer.DComponent.getD()");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(28);
-  }
-
-  @Test
-  public void cyclicDependencyInSubcomponents() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "test.Parent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface Parent {",
-            "  Child.Builder child();",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = CycleModule.class)",
-            "interface Child {",
-            "  Grandchild.Builder grandchild();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Child build();",
-            "  }",
-            "}");
-    JavaFileObject grandchild =
-        JavaFileObjects.forSourceLines(
-            "test.Grandchild",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Grandchild {",
-            "  String entry();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Grandchild build();",
-            "  }",
-            "}");
-    JavaFileObject cycleModule =
-        JavaFileObjects.forSourceLines(
-            "test.CycleModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class CycleModule {",
-            "  @Provides static Object object(String string) {",
-            "    return string;",
-            "  }",
-            "",
-            "  @Provides static String string(Object object) {",
-            "    return object.toString();",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, cycleModule);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "[test.Grandchild.entry()] Found a dependency cycle:",
-                "java.lang.String is injected at",
-                "    test.CycleModule.object(string)",
-                "java.lang.Object is injected at",
-                "    test.CycleModule.string(object)",
-                "java.lang.String is provided at",
-                "    test.Grandchild.entry()"))
-        .inFile(parent)
-        .onLineContaining("interface Parent");
-  }
-
-  @Test
-  public void cyclicDependencyInSubcomponentsWithChildren() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "test.Parent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface Parent {",
-            "  Child.Builder child();",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = CycleModule.class)",
-            "interface Child {",
-            "  String entry();",
-            "",
-            "  Grandchild grandchild();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Child build();",
-            "  }",
-            "}");
-    // Grandchild has no entry point that depends on the cycle. http://b/111317986
-    JavaFileObject grandchild =
-        JavaFileObjects.forSourceLines(
-            "test.Grandchild",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Grandchild {",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Grandchild build();",
-            "  }",
-            "}");
-    JavaFileObject cycleModule =
-        JavaFileObjects.forSourceLines(
-            "test.CycleModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class CycleModule {",
-            "  @Provides static Object object(String string) {",
-            "    return string;",
-            "  }",
-            "",
-            "  @Provides static String string(Object object) {",
-            "    return object.toString();",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, cycleModule);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "[test.Child.entry()] Found a dependency cycle:",
-                "java.lang.String is injected at",
-                "    test.CycleModule.object(string)",
-                "java.lang.Object is injected at",
-                "    test.CycleModule.string(object)",
-                "java.lang.String is provided at",
-                "    test.Child.entry()"))
-        .inFile(parent)
-        .onLineContaining("interface Parent");
-  }
-
-  @Test
-  public void circularBindsMethods() {
-    JavaFileObject qualifier =
-        JavaFileObjects.forSourceLines(
-            "test.SomeQualifier",
-            "package test;",
-            "",
-            "import javax.inject.Qualifier;",
-            "",
-            "@Qualifier @interface SomeQualifier {}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Binds abstract Object bindUnqualified(@SomeQualifier Object qualified);",
-            "  @Binds @SomeQualifier abstract Object bindQualified(Object unqualified);",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  Object unqualified();",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(qualifier, module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "Found a dependency cycle:",
-                "java.lang.Object is injected at",
-                "    test.TestModule.bindQualified(unqualified)",
-                "@test.SomeQualifier java.lang.Object is injected at",
-                "    test.TestModule.bindUnqualified(qualified)",
-                "java.lang.Object is provided at",
-                "    test.TestComponent.unqualified()"))
-        .inFile(component)
-        .onLineContaining("unqualified();");
-  }
-
-  @Test
-  public void selfReferentialBinds() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Binds abstract Object bindToSelf(Object sameKey);",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  Object selfReferential();",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "Found a dependency cycle:\n"
-                + "      java.lang.Object is injected at\n"
-                + "          test.TestModule.bindToSelf(sameKey)\n"
-                + "      java.lang.Object is provided at\n"
-                + "          test.TestComponent.selfReferential()")
-        .inFile(component)
-        .onLine(7);
-  }
-
-  @Test
-  public void cycleFromMembersInjectionMethod_WithSameKeyAsMembersInjectionMethod() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class A {",
-            "  @Inject A() {}",
-            "  @Inject B b;",
-            "}");
-    JavaFileObject b =
-        JavaFileObjects.forSourceLines(
-            "test.B",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class B {",
-            "  @Inject B() {}",
-            "  @Inject A a;",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.CycleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface CycleComponent {",
-            "  void inject(A a);",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(a, b, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            Joiner.on('\n')
-                .join(
-                    "Found a dependency cycle:",
-                    "      test.B is injected at",
-                    "          test.A.b",
-                    "      test.A is injected at",
-                    "          test.B.a",
-                    "      test.B is injected at",
-                    "          test.A.b",
-                    "      test.A is injected at",
-                    "          test.CycleComponent.inject(test.A)"))
-        .inFile(component)
-        .onLineContaining("void inject(A a);");
-  }
-
-  @Test
-  public void longCycleMaskedByShortBrokenCycles() {
-    JavaFileObject cycles =
-        JavaFileObjects.forSourceLines(
-            "test.Cycles",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "import dagger.Component;",
-            "",
-            "final class Cycles {",
-            "  static class A {",
-            "    @Inject A(Provider<A> aProvider, B b) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(Provider<B> bProvider, A a) {}",
-            "  }",
-            "",
-            "  @Component",
-            "  interface C {",
-            "    A a();",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(cycles);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("Found a dependency cycle:")
-        .inFile(cycles)
-        .onLineContaining("A a();");
-  }
-
-  @Test
-  public void missingBindingWithSameKeyAsMembersInjectionMethod() {
-    JavaFileObject self =
-        JavaFileObjects.forSourceLines(
-            "test.Self",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "class Self {",
-            "  @Inject Provider<Self> selfProvider;",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.SelfComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface SelfComponent {",
-            "  void inject(Self target);",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(self, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("test.Self cannot be provided without an @Inject constructor")
-        .inFile(component)
-        .onLineContaining("void inject(Self target);");
-  }
-
-  @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "final class Outer {",
-        "  interface A {}",
-        "",
-        "  interface B {}",
-        "",
-        "  @Module",
-        "  static class AModule {",
-        "    @Provides String provideString() { return \"\"; }",
-        "    @Provides A provideA(String s) { return new A() {}; }",
-        "  }",
-        "",
-        "  @Component(modules = AModule.class)",
-        "  interface Parent {",
-        "    A getA();",
-        "  }",
-        "",
-        "  @Module",
-        "  static class BModule {",
-        "    @Provides B provideB(A a) { return new B() {}; }",
-        "  }",
-        "",
-        "  @Component(dependencies = Parent.class, modules = { BModule.class, AModule.class})",
-        "  interface Child {",
-        "    B getB();",
-        "  }",
-        "}");
-
-    String expectedError =
-        message(
-            "test.Outer.A is bound multiple times:",
-            "@Provides test.Outer.A test.Outer.AModule.provideA(String)",
-            "test.Outer.A test.Outer.Parent.getA()");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(30);
-  }
-
-  @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class Outer {",
-        "  interface A {}",
-        "",
-        "  @Module",
-        "  static class Module1 {",
-        "    @Provides A provideA1() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module2 {",
-        "    @Provides String provideString() { return \"\"; }",
-        "    @Provides A provideA2(String s) { return new A() {}; }",
-        "  }",
-        "",
-        "  @Component(modules = { Module1.class, Module2.class})",
-        "  interface TestComponent {",
-        "    A getA();",
-        "  }",
-        "}");
-
-    String expectedError = "test.Outer.A is bound multiple times:\n"
-        + "      @Provides test.Outer.A test.Outer.Module1.provideA1()\n"
-        + "      @Provides test.Outer.A test.Outer.Module2.provideA2(String)";
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(24);
-  }
-
-  @Test
-  public void duplicateExplicitBindings_ProvidesVsBinds() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  interface A {}",
-            "",
-            "  static final class B implements A {",
-            "    @Inject B() {}",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module1 {",
-            "    @Provides A provideA1() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static abstract class Module2 {",
-            "    @Binds abstract A bindA2(B b);",
-            "  }",
-            "",
-            "  @Component(modules = { Module1.class, Module2.class})",
-            "  interface TestComponent {",
-            "    A getA();",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "test.Outer.A is bound multiple times:",
-                    "@Provides test.Outer.A test.Outer.Module1.provideA1()",
-                    "@Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
-        .inFile(component)
-        .onLine(28);
-  }
-
-  @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Binds;",
-        "import dagger.Component;",
-        "import dagger.MapKey;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.MapKey;",
-        "import dagger.multibindings.IntoMap;",
-        "import dagger.multibindings.IntoSet;",
-        "import java.util.HashMap;",
-        "import java.util.HashSet;",
-        "import java.util.Map;",
-        "import java.util.Set;",
-        "import javax.inject.Qualifier;",
-        "",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "final class Outer {",
-        "  @MapKey(unwrapValue = true)",
-        "  @interface StringKey {",
-        "    String value();",
-        "  }",
-        "",
-        "  @Qualifier @interface SomeQualifier {}",
-        "",
-        "  @Module",
-        "  abstract static class TestModule1 {",
-        "    @Provides @IntoMap",
-        "    @StringKey(\"foo\")",
-        "    static String stringMapEntry() { return \"\"; }",
-        "",
-        "    @Binds @IntoMap @StringKey(\"bar\")",
-        "    abstract String bindStringMapEntry(@SomeQualifier String value);",
-        "",
-        "    @Provides @IntoSet static String stringSetElement() { return \"\"; }",
-        "    @Binds @IntoSet abstract String bindStringSetElement(@SomeQualifier String value);",
-        "",
-        "    @Provides @SomeQualifier static String provideSomeQualifiedString() { return \"\"; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class TestModule2 {",
-        "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
-        "",
-        "    @Provides Map<String, String> stringMap() {",
-        "      return new HashMap<String, String>();",
-        "    }",
-        "  }",
-        "",
-        "  @Component(modules = { TestModule1.class, TestModule2.class })",
-        "  interface TestComponent {",
-        "    Set<String> getStringSet();",
-        "    Map<String, String> getStringMap();",
-        "  }",
-        "}");
-
-    String expectedSetError =
-        message(
-            "java.util.Set<java.lang.String> has incompatible bindings or declarations:",
-            "Set bindings and declarations:",
-            "    @Binds @dagger.multibindings.IntoSet String "
-                + "test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier String)",
-            "    @Provides @dagger.multibindings.IntoSet String "
-                + "test.Outer.TestModule1.stringSetElement()",
-            "Unique bindings and declarations:",
-            "    @Provides Set<String> test.Outer.TestModule2.stringSet()");
-
-    String expectedMapError =
-        message(
-            "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
-                + "or declarations:",
-            "Map bindings and declarations:",
-            "    @Binds @dagger.multibindings.IntoMap "
-                + "@test.Outer.StringKey(\"bar\") String"
-                + " test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier String)",
-            "    @Provides @dagger.multibindings.IntoMap "
-                + "@test.Outer.StringKey(\"foo\") String"
-                + " test.Outer.TestModule1.stringMapEntry()",
-            "Unique bindings and declarations:",
-            "    @Provides Map<String,String> test.Outer.TestModule2.stringMap()");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedSetError).inFile(component).onLine(52);
-    assertThat(compilation).hadErrorContaining(expectedMapError).inFile(component).onLine(53);
-  }
-
-  @Test
-  public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.HashMap;",
-            "import java.util.HashSet;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "final class Outer {",
-            "  @Module",
-            "  abstract static class TestModule1 {",
-            "    @Multibinds abstract Map<String, String> stringMap();",
-            "    @Multibinds abstract Set<String> stringSet();",
-            "  }",
-            "",
-            "  @Module",
-            "  static class TestModule2 {",
-            "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
-            "",
-            "    @Provides Map<String, String> stringMap() {",
-            "      return new HashMap<String, String>();",
-            "    }",
-            "  }",
-            "",
-            "  @Component(modules = { TestModule1.class, TestModule2.class })",
-            "  interface TestComponent {",
-            "    Set<String> getStringSet();",
-            "    Map<String, String> getStringMap();",
-            "  }",
-            "}");
-
-    String expectedSetError =
-        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
-            + "      Set bindings and declarations:\n"
-            + "          @dagger.multibindings.Multibinds Set<String> "
-            + "test.Outer.TestModule1.stringSet()\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
-
-    String expectedMapError =
-        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
-            + "or declarations:\n"
-            + "      Map bindings and declarations:\n"
-            + "          @dagger.multibindings.Multibinds Map<String,String> "
-            + "test.Outer.TestModule1.stringMap()\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedSetError).inFile(component).onLine(32);
-    assertThat(compilation).hadErrorContaining(expectedMapError).inFile(component).onLine(33);
-  }
-
-  @Test public void duplicateBindings_TruncateAfterLimit() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  interface A {}",
-            "",
-            "  @Module",
-            "  static class Module01 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module02 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module03 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module04 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module05 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module06 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module07 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module08 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module09 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module10 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module11 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module12 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Component(modules = {",
-            "    Module01.class,",
-            "    Module02.class,",
-            "    Module03.class,",
-            "    Module04.class,",
-            "    Module05.class,",
-            "    Module06.class,",
-            "    Module07.class,",
-            "    Module08.class,",
-            "    Module09.class,",
-            "    Module10.class,",
-            "    Module11.class,",
-            "    Module12.class",
-            "  })",
-            "  interface TestComponent {",
-            "    A getA();",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "test.Outer.A is bound multiple times:",
-                "@Provides test.Outer.A test.Outer.Module01.provideA()",
-                "@Provides test.Outer.A test.Outer.Module02.provideA()",
-                "@Provides test.Outer.A test.Outer.Module03.provideA()",
-                "@Provides test.Outer.A test.Outer.Module04.provideA()",
-                "@Provides test.Outer.A test.Outer.Module05.provideA()",
-                "@Provides test.Outer.A test.Outer.Module06.provideA()",
-                "@Provides test.Outer.A test.Outer.Module07.provideA()",
-                "@Provides test.Outer.A test.Outer.Module08.provideA()",
-                "@Provides test.Outer.A test.Outer.Module09.provideA()",
-                "@Provides test.Outer.A test.Outer.Module10.provideA()",
-                "and 2 others"))
-        .inFile(component)
-        .onLineContaining("getA();");
-  }
-
-  @Test public void longChainOfDependencies() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestClass",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Lazy;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Named;",
-            "import javax.inject.Provider;",
-            "",
-            "final class TestClass {",
-            "  interface A {}",
-            "",
-            "  static class B {",
-            "    @Inject B(A a) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject B b;",
-            "    @Inject C(X x) {}",
-            "  }",
-            "",
-            "  interface D { }",
-            "",
-            "  static class DImpl implements D {",
-            "    @Inject DImpl(C c, B b) {}",
-            "  }",
-            "",
-            "  static class X {",
-            "    @Inject X() {}",
-            "  }",
-            "",
-            "  @Module",
-            "  static class DModule {",
-            "    @Provides @Named(\"slim shady\") D d(X x1, DImpl impl, X x2) { return impl; }",
-            "  }",
-            "",
-            "  @Component(modules = { DModule.class })",
-            "  interface AComponent {",
-            "    @Named(\"slim shady\") D getFoo();",
-            "    C injectC(C c);",
-            "    Provider<C> cProvider();",
-            "    Lazy<C> lazyC();",
-            "    Provider<Lazy<C>> lazyCProvider();",
-            "  }",
-            "}");
-    String errorText = "test.TestClass.A cannot be provided without an @Provides-annotated method.";
-    String firstError =
-        message(
-            errorText,
-            "test.TestClass.A is injected at",
-            "    test.TestClass.B.<init>(a)",
-            "test.TestClass.B is injected at",
-            "    test.TestClass.DImpl.<init>(…, b)",
-            "test.TestClass.DImpl is injected at",
-            "    test.TestClass.DModule.d(…, impl, …)",
-            "@javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
-            "    test.TestClass.AComponent.getFoo()");
-    String otherErrorFormat =
-        message(
-            errorText,
-            "test.TestClass.A is injected at",
-            "    test.TestClass.B.<init>(a)",
-            "test.TestClass.B is injected at",
-            "    test.TestClass.C.b",
-            "test.TestClass.C is %s at",
-            "    test.TestClass.AComponent.%s");
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(firstError)
-        .inFile(component)
-        .onLineContaining("getFoo();");
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(otherErrorFormat, "injected", "injectC(test.TestClass.C)"))
-        .inFile(component)
-        .onLineContaining("injectC(C c);");
-    assertThat(compilation)
-        .hadErrorContaining(String.format(otherErrorFormat, "provided", "cProvider()"))
-        .inFile(component)
-        .onLineContaining("cProvider();");
-    assertThat(compilation)
-        .hadErrorContaining(String.format(otherErrorFormat, "provided", "lazyC()"))
-        .inFile(component)
-        .onLineContaining("lazyC();");
-    assertThat(compilation)
-        .hadErrorContaining(String.format(otherErrorFormat, "provided", "lazyCProvider()"))
-        .inFile(component)
-        .onLineContaining("lazyCProvider();");
-  }
-
-  @Test
-  public void bindsMethodAppearsInTrace() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "TestComponent",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  TestInterface testInterface();",
-            "}");
-    JavaFileObject interfaceFile =
-        JavaFileObjects.forSourceLines("TestInterface", "interface TestInterface {}");
-    JavaFileObject implementationFile =
-        JavaFileObjects.forSourceLines(
-            "TestImplementation",
-            "import javax.inject.Inject;",
-            "",
-            "final class TestImplementation implements TestInterface {",
-            "  @Inject TestImplementation(String missingBinding) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "TestModule",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "interface TestModule {",
-            "  @Binds abstract TestInterface bindTestInterface(TestImplementation implementation);",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(component, module, interfaceFile, implementationFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "java.lang.String cannot be provided without an @Inject constructor or an "
-                        + "@Provides-annotated method.",
-                    "java.lang.String is injected at",
-                    "    TestImplementation.<init>(missingBinding)",
-                    "TestImplementation is injected at",
-                    "    TestModule.bindTestInterface(implementation)",
-                    "TestInterface is provided at",
-                    "    TestComponent.testInterface()"))
-        .inFile(component)
-        .onLine(5);
-  }
-
-  @Test
-  public void bindsMissingRightHandSide() {
-    JavaFileObject duplicates =
-        JavaFileObjects.forSourceLines(
-            "test.Duplicates",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.multibindings.IntKey;",
-            "import dagger.multibindings.IntoSet;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.LongKey;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "interface Duplicates {",
-            "",
-            "  interface BoundTwice {}",
-            "",
-            "  class BoundImpl implements BoundTwice {",
-            "    @Inject BoundImpl() {}",
-            "  }",
-            "",
-            "  class NotBound implements BoundTwice {}",
-            "",
-            "  @Module",
-            "  abstract class DuplicatesModule {",
-            "    @Binds abstract BoundTwice bindWithResolvedKey(BoundImpl impl);",
-            "    @Binds abstract BoundTwice bindWithUnresolvedKey(NotBound notBound);",
-            "",
-            "    @Binds abstract Object bindObject(NotBound notBound);",
-            "",
-            "    @Binds @IntoSet abstract BoundTwice bindWithUnresolvedKey_set(NotBound notBound);",
-            "",
-            "    @Binds @IntoMap @IntKey(1)",
-            "    abstract BoundTwice bindWithUnresolvedKey_intMap(NotBound notBound);",
-            "",
-            "    @Provides @IntoMap @LongKey(2L)",
-            "    static BoundTwice provideWithUnresolvedKey_longMap(BoundImpl impl) {",
-            "      return impl;",
-            "    }",
-            "    @Binds @IntoMap @LongKey(2L)",
-            "    abstract BoundTwice bindWithUnresolvedKey_longMap(NotBound notBound);",
-            "  }",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.C",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import java.util.Set;",
-            "import java.util.Map;",
-            "import test.Duplicates.BoundTwice;",
-            "",
-            "@Component(modules = Duplicates.DuplicatesModule.class)",
-            "interface C {",
-            "  BoundTwice boundTwice();",
-            "  Object object();",
-            "  Set<BoundTwice> set();",
-            "  Map<Integer, BoundTwice> intMap();",
-            "  Map<Long, BoundTwice> longMap();",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(duplicates, component);
-    assertThat(compilation).failed();
-    // Some javacs report only the first error for each source line.
-    // Assert that one of the expected errors is reported.
-    assertThat(compilation)
-        .hadErrorContainingMatch(
-            "\\Qtest.Duplicates.NotBound cannot be provided\\E|"
-                + message(
-                    "\\Qtest.Duplicates.BoundTwice is bound multiple times:",
-                    "@Binds test.Duplicates.BoundTwice "
-                        + "test.Duplicates.DuplicatesModule"
-                        + ".bindWithResolvedKey(test.Duplicates.BoundImpl)",
-                    "@Binds test.Duplicates.BoundTwice "
-                        + "test.Duplicates.DuplicatesModule"
-                        + ".bindWithUnresolvedKey(test.Duplicates.NotBound)"))
-        .inFile(component)
-        .onLineContaining("boundTwice();");
-    assertThat(compilation)
-        .hadErrorContaining("test.Duplicates.NotBound cannot be provided")
-        .inFile(component)
-        .onLineContaining("object();");
-    assertThat(compilation)
-        .hadErrorContaining("test.Duplicates.NotBound cannot be provided")
-        .inFile(component)
-        .onLineContaining("set();");
-    assertThat(compilation)
-        .hadErrorContaining("test.Duplicates.NotBound cannot be provided")
-        .inFile(component)
-        .onLineContaining("intMap();");
-    // Some javacs report only the first error for each source line.
-    // Assert that one of the expected errors is reported.
-    assertThat(compilation)
-        .hadErrorContainingMatch(
-            "test\\.Duplicates\\.NotBound cannot be provided|same map key is bound more than once")
-        .inFile(component)
-        .onLineContaining("longMap();");
-  }
-
-  @Test public void resolvedParametersInDependencyTrace() {
-    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class Generic<T> {",
-        "  @Inject Generic(T t) {}",
-        "}");
-    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import java.util.List;",
-        "",
-        "final class TestClass {",
-        "  @Inject TestClass(List list) {}",
-        "}");
-    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class UsesTest {",
-        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  UsesTest usesTest();",
-        "}");
-    String expectedMsg =
-        Joiner.on("\n")
-            .join(
-                "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      java.util.List is injected at",
-                "          test.TestClass.<init>(list)",
-                "      test.TestClass is injected at",
-                "          test.Generic.<init>(t)",
-                "      test.Generic<test.TestClass> is injected at",
-                "          test.UsesTest.<init>(genericTestClass)",
-                "      test.UsesTest is provided at",
-                "          test.TestComponent.usesTest()");
-    Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedMsg);
-  }
-
-  @Test public void resolvedVariablesInDependencyTrace() {
-    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class Generic<T> {",
-        "  @Inject T t;",
-        "  @Inject Generic() {}",
-        "}");
-    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import java.util.List;",
-        "",
-        "final class TestClass {",
-        "  @Inject TestClass(List list) {}",
-        "}");
-    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class UsesTest {",
-        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  UsesTest usesTest();",
-        "}");
-    String expectedMsg =
-        Joiner.on("\n")
-            .join(
-                "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      java.util.List is injected at",
-                "          test.TestClass.<init>(list)",
-                "      test.TestClass is injected at",
-                "          test.Generic.t",
-                "      test.Generic<test.TestClass> is injected at",
-                "          test.UsesTest.<init>(genericTestClass)",
-                "      test.UsesTest is provided at",
-                "          test.TestComponent.usesTest()");
-    Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedMsg);
-  }
-
-  @Test public void nullCheckForConstructorParameters() {
-    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject A(String string) {}",
-        "}");
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "@dagger.Module",
-        "final class TestModule {",
-        "  @Nullable @Provides String provideString() { return null; }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  A a();",
-        "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-
-    // but if we disable the validation, then it compiles fine.
-    Compilation compilation2 =
-        javac()
-            .withOptions("-Adagger.nullableValidation=WARNING")
-            .withProcessors(new ComponentProcessor())
-            .compile(NULLABLE, a, module, component);
-    assertThat(compilation2).succeeded();
-  }
-
-  @Test public void nullCheckForMembersInjectParam() {
-    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject A() {}",
-        "  @Inject void register(String string) {}",
-        "}");
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "@dagger.Module",
-        "final class TestModule {",
-        "  @Nullable @Provides String provideString() { return null; }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  A a();",
-        "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-
-    // but if we disable the validation, then it compiles fine.
-    Compilation compilation2 =
-        javac()
-            .withOptions("-Adagger.nullableValidation=WARNING")
-            .withProcessors(new ComponentProcessor())
-            .compile(NULLABLE, a, module, component);
-    assertThat(compilation2).succeeded();
-  }
-
-  @Test public void nullCheckForVariable() {
-    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject String string;",
-        "  @Inject A() {}",
-        "}");
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "@dagger.Module",
-        "final class TestModule {",
-        "  @Nullable @Provides String provideString() { return null; }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  A a();",
-        "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-
-    // but if we disable the validation, then it compiles fine.
-    Compilation compilation2 =
-        javac()
-            .withOptions("-Adagger.nullableValidation=WARNING")
-            .withProcessors(new ComponentProcessor())
-            .compile(NULLABLE, a, module, component);
-    assertThat(compilation2).succeeded();
-  }
-
-  @Test public void nullCheckForComponentReturn() {
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "@dagger.Module",
-        "final class TestModule {",
-        "  @Nullable @Provides String provideString() { return null; }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  String string();",
-        "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-
-    // but if we disable the validation, then it compiles fine.
-    Compilation compilation2 =
-        javac()
-            .withOptions("-Adagger.nullableValidation=WARNING")
-            .withProcessors(new ComponentProcessor())
-            .compile(NULLABLE, module, component);
-    assertThat(compilation2).succeeded();
-  }
-
-  @Test
-  public void nullCheckForOptionalInstance() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import javax.inject.Inject;",
-            "",
-            "final class A {",
-            "  @Inject A(Optional<String> optional) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "@dagger.Module",
-            "abstract class TestModule {",
-            "  @Nullable @Provides static String provideString() { return null; }",
-            "  @BindsOptionalOf abstract String optionalString();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  A a();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-  }
-
-  @Test
-  public void nullCheckForOptionalProvider() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "final class A {",
-            "  @Inject A(Optional<Provider<String>> optional) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "@dagger.Module",
-            "abstract class TestModule {",
-            "  @Nullable @Provides static String provideString() { return null; }",
-            "  @BindsOptionalOf abstract String optionalString();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  A a();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).succeeded();
-  }
-
-  @Test
-  public void nullCheckForOptionalLazy() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import dagger.Lazy;",
-            "import javax.inject.Inject;",
-            "",
-            "final class A {",
-            "  @Inject A(Optional<Lazy<String>> optional) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "@dagger.Module",
-            "abstract class TestModule {",
-            "  @Nullable @Provides static String provideString() { return null; }",
-            "  @BindsOptionalOf abstract String optionalString();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  A a();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).succeeded();
-  }
-
-  @Test
-  public void nullCheckForOptionalProviderOfLazy() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import dagger.Lazy;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "final class A {",
-            "  @Inject A(Optional<Provider<Lazy<String>>> optional) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "@dagger.Module",
-            "abstract class TestModule {",
-            "  @Nullable @Provides static String provideString() { return null; }",
-            "  @BindsOptionalOf abstract String optionalString();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  A a();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).succeeded();
-  }
-
-  @Test public void componentDependencyMustNotCycle_Direct() {
-    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(dependencies = ComponentShort.class)",
-        "interface ComponentShort {",
-        "}");
-    String errorMessage =
-        "test.ComponentShort contains a cycle in its component dependencies:\n"
-            + "      test.ComponentShort";
-    Compilation compilation = daggerCompiler().compile(shortLifetime);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
-  }
-
-  @Test public void componentDependencyMustNotCycle_Indirect() {
-    JavaFileObject longLifetime = JavaFileObjects.forSourceLines("test.ComponentLong",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(dependencies = ComponentMedium.class)",
-        "interface ComponentLong {",
-        "}");
-    JavaFileObject mediumLifetime = JavaFileObjects.forSourceLines("test.ComponentMedium",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(dependencies = ComponentLong.class)",
-        "interface ComponentMedium {",
-        "}");
-    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(dependencies = ComponentMedium.class)",
-        "interface ComponentShort {",
-        "}");
-    String longErrorMessage =
-        "test.ComponentLong contains a cycle in its component dependencies:\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong";
-    String mediumErrorMessage =
-        "test.ComponentMedium contains a cycle in its component dependencies:\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium";
-    String shortErrorMessage =
-        "test.ComponentShort contains a cycle in its component dependencies:\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentShort";
-    Compilation compilation = daggerCompiler().compile(longLifetime, mediumLifetime, shortLifetime);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(longErrorMessage).inFile(longLifetime);
-    assertThat(compilation).hadErrorContaining(mediumErrorMessage).inFile(mediumLifetime);
-    assertThat(compilation).hadErrorContaining(shortErrorMessage).inFile(shortLifetime);
-  }
-
-  @Test
-  public void childBindingConflictsWithParent() {
-    JavaFileObject aComponent =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Component(modules = A.AModule.class)",
-            "interface A {",
-            "  Object conflict();",
-            "",
-            "  B b();",
-            "",
-            "  @Module",
-            "  static class AModule {",
-            "    @Provides static Object abConflict() {",
-            "      return \"a\";",
-            "    }",
-            "  }",
-            "}");
-    JavaFileObject bComponent =
-        JavaFileObjects.forSourceLines(
-            "test.B",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = B.BModule.class)",
-            "interface B {",
-            "  Object conflict();",
-            "",
-            "  @Module",
-            "  static class BModule {",
-            "    @Provides static Object abConflict() {",
-            "      return \"b\";",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(aComponent, bComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "[test.B.conflict()] java.lang.Object is bound multiple times:",
-                "@Provides Object test.A.AModule.abConflict()",
-                "@Provides Object test.B.BModule.abConflict()"))
-        .inFile(aComponent)
-        .onLineContaining("interface A {");
-  }
-
-  @Test
-  public void grandchildBindingConflictsWithGrandparent() {
-    JavaFileObject aComponent =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Component(modules = A.AModule.class)",
-            "interface A {",
-            "  Object conflict();",
-            "",
-            "  B b();",
-            "",
-            "  @Module",
-            "  static class AModule {",
-            "    @Provides static Object acConflict() {",
-            "      return \"a\";",
-            "    }",
-            "  }",
-            "}");
-    JavaFileObject bComponent =
-        JavaFileObjects.forSourceLines(
-            "test.B",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface B {",
-            "  C c();",
-            "}");
-    JavaFileObject cComponent =
-        JavaFileObjects.forSourceLines(
-            "test.C",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = C.CModule.class)",
-            "interface C {",
-            "  Object conflict();",
-            "",
-            "  @Module",
-            "  static class CModule {",
-            "    @Provides static Object acConflict() {",
-            "      return \"c\";",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "[test.C.conflict()] java.lang.Object is bound multiple times:",
-                "@Provides Object test.A.AModule.acConflict()",
-                "@Provides Object test.C.CModule.acConflict()"))
-        .inFile(aComponent)
-        .onLineContaining("interface A {");
-  }
-
-  @Test
-  public void grandchildBindingConflictsWithChild() {
-    JavaFileObject aComponent =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface A {",
-            "  B b();",
-            "}");
-    JavaFileObject bComponent =
-        JavaFileObjects.forSourceLines(
-            "test.B",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = B.BModule.class)",
-            "interface B {",
-            "  Object conflict();",
-            "",
-            "  C c();",
-            "",
-            "  @Module",
-            "  static class BModule {",
-            "    @Provides static Object bcConflict() {",
-            "      return \"b\";",
-            "    }",
-            "  }",
-            "}");
-    JavaFileObject cComponent =
-        JavaFileObjects.forSourceLines(
-            "test.C",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = C.CModule.class)",
-            "interface C {",
-            "  Object conflict();",
-            "",
-            "  @Module",
-            "  static class CModule {",
-            "    @Provides static Object bcConflict() {",
-            "      return \"c\";",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "[test.C.conflict()] java.lang.Object is bound multiple times:",
-                "@Provides Object test.B.BModule.bcConflict()",
-                "@Provides Object test.C.CModule.bcConflict()"))
-        .inFile(aComponent)
-        .onLineContaining("interface A {");
-  }
-
-  @Test
-  public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning() {
-    JavaFileObject parentConflictsWithChild =
-        JavaFileObjects.forSourceLines(
-            "test.ParentConflictsWithChild",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.annotation.Nullable;",
-            "",
-            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
-            "interface ParentConflictsWithChild {",
-            "  Child child();",
-            "",
-            "  @Module",
-            "  static class ParentModule {",
-            "    @Provides @Nullable static Object nullableParentChildConflict() {",
-            "      return \"parent\";",
-            "    }",
-            "  }",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = Child.ChildModule.class)",
-            "interface Child {",
-            "  Object parentChildConflictThatViolatesNullability();",
-            "",
-            "  @Module",
-            "  static class ChildModule {",
-            "    @Provides static Object nonNullableParentChildConflict() {",
-            "      return \"child\";",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation =
-        javac()
-            .withOptions("-Adagger.nullableValidation=WARNING")
-            .withProcessors(new ComponentProcessor())
-            .compile(parentConflictsWithChild, child);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "[test.Child.parentChildConflictThatViolatesNullability()] "
-                    + "java.lang.Object is bound multiple times:",
-                "@Provides Object test.Child.ChildModule.nonNullableParentChildConflict()",
-                "@Provides @javax.annotation.Nullable Object"
-                    + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()"))
-        .inFile(parentConflictsWithChild)
-        .onLine(9);
-  }
-
-  @Test
-  public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "Parent",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = ParentModule.class)",
-            "interface Parent {",
-            "  Child child();",
-            "}");
-    JavaFileObject parentModule =
-        JavaFileObjects.forSourceLines(
-            "ParentModule",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class ParentModule {",
-            "  @Provides static Object needsString(String string) {",
-            "    return \"needs string: \" + string;",
-            "  }",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "Child",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  String string();",
-            "  Object needsString();",
-            "}");
-    JavaFileObject childModule =
-        JavaFileObjects.forSourceLines(
-            "ChildModule",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class ChildModule {",
-            "  @Provides static String string() {",
-            "    return \"child string\";",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(parent, parentModule, child, childModule);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("[Child.needsString()] java.lang.String cannot be provided")
-        .inFile(parent)
-        .onLine(4);
-  }
-
-  @Test
-  public void multibindingContributionBetweenAncestorComponentAndEntrypointComponent() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "Parent",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = ParentModule.class)",
-            "interface Parent {",
-            "  Child child();",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "Child",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  Grandchild grandchild();",
-            "}");
-    JavaFileObject grandchild =
-        JavaFileObjects.forSourceLines(
-            "Grandchild",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Grandchild {",
-            "  Object object();",
-            "}");
-
-    JavaFileObject parentModule =
-        JavaFileObjects.forSourceLines(
-            "ParentModule",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class ParentModule {",
-            "  @Provides static Object dependsOnSet(Set<String> strings) {",
-            "    return \"needs strings: \" + strings;",
-            "  }",
-            "",
-            "  @Provides @IntoSet static String contributesToSet() {",
-            "    return \"parent string\";",
-            "  }",
-            "",
-            "  @Provides int missingDependency(double dub) {",
-            "    return 4;",
-            "  }",
-            "}");
-    JavaFileObject childModule =
-        JavaFileObjects.forSourceLines(
-            "ChildModule",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class ChildModule {",
-            "  @Provides @IntoSet static String contributesToSet(int i) {",
-            "    return \"\" + i;",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(parent, parentModule, child, childModule, grandchild);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("[Grandchild.object()] java.lang.Double cannot be provided")
-        .inFile(parent)
-        .onLine(4);
-  }
-
-  @Test
-  public void missingReleasableReferenceManager() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@BadMetadata",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject otherScope =
-        JavaFileObjects.forSourceLines(
-            "test.OtherScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface OtherScope {}");
-    JavaFileObject yetAnotherScope =
-        JavaFileObjects.forSourceLines(
-            "test.YetAnotherScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface YetAnotherScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-    JavaFileObject badMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.BadMetadata", // force one-string-per-line format
-            "package test;",
-            "",
-            "@interface BadMetadata {}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "",
-            "@TestScope",
-            "@YetAnotherScope",
-            "@Component",
-            "interface TestComponent {",
-            "  @ForReleasableReferences(OtherScope.class)",
-            "  ReleasableReferenceManager otherManager();",
-            "",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
-            "",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  TypedReleasableReferenceManager<BadMetadata> badManager();",
-            "}");
-    Compilation compilation =
-        daggerCompiler()
-            .compile(testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.OtherScope.class) "
-                + "dagger.releasablereferences.ReleasableReferenceManager "
-                + "because no component in test.TestComponent's component hierarchy is annotated "
-                + "with @test.OtherScope. "
-                + "The available reference-releasing scopes are "
-                + "[@test.TestScope, @test.YetAnotherScope].")
-        .inFile(component)
-        .onLine(13);
-    assertThat(compilation)
-        .hadErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
-                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.TestMetadata> "
-                + "because test.TestScope is not annotated with @test.TestMetadata")
-        .inFile(component)
-        .onLine(16);
-    assertThat(compilation)
-        .hadErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
-                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.BadMetadata> "
-                + "because test.BadMetadata is not annotated with "
-                + "@dagger.releasablereferences.CanReleaseReferences")
-        .inFile(component)
-        .onLine(19);
-  }
-
-  @Test
-  public void releasableReferenceManagerConflict() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@TestMetadata",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides @ForReleasableReferences(TestScope.class)",
-            "  static ReleasableReferenceManager rrm() {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Provides @ForReleasableReferences(TestScope.class)",
-            "  static TypedReleasableReferenceManager<TestMetadata> typedRrm() {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Provides",
-            "  static Set<ReleasableReferenceManager> rrmSet() {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Provides",
-            "  static Set<TypedReleasableReferenceManager<TestMetadata>> typedRrmSet() {",
-            "    return null;",
-            "  }",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@TestScope",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  ReleasableReferenceManager testManager();",
-            "",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
-            "",
-            "  Set<ReleasableReferenceManager> managers();",
-            "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(testScope, testMetadata, testModule, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                message(
-                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager is bound multiple times:",
-                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager test.TestModule.rrm()",
-                    "binding for "
-                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager from the scope declaration"),
-                "dagger.releasablereferences"))
-        .inFile(component)
-        .onLine(13);
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                message(
-                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "is bound multiple times:",
-                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "test.TestModule.typedRrm()",
-                    "binding for "
-                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "from the scope declaration"),
-                "dagger.releasablereferences"))
-        .inFile(component)
-        .onLine(16);
-    assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
-                    + "is bound multiple times:",
-                "@Provides "
-                    + "Set<dagger.releasablereferences.ReleasableReferenceManager> "
-                    + "test.TestModule.rrmSet()",
-                "Dagger-generated binding for "
-                    + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
-        .inFile(component)
-        .onLine(18);
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                message(
-                    "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
-                        + "is bound multiple times:",
-                    "@Provides "
-                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
-                        + "test.TestModule.typedRrmSet()",
-                    "Dagger-generated binding for "
-                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
-                "dagger.releasablereferences"))
-        .inFile(component)
-        .onLine(19);
-  }
-
-  @Test
-  public void abstractModuleWithInstanceMethod() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides int i() { return 1; }",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  int i();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("TestModule is abstract and has instance @Provides methods")
-        .inFile(component)
-        .onLineContaining("interface TestComponent");
-  }
-
-  @Test
-  public void abstractModuleWithInstanceMethod_subclassedIsAllowed() {
-    JavaFileObject abstractModule =
-        JavaFileObjects.forSourceLines(
-            "test.AbstractModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class AbstractModule {",
-            "  @Provides int i() { return 1; }",
-            "}");
-    JavaFileObject subclassedModule =
-        JavaFileObjects.forSourceLines(
-            "test.SubclassedModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "class SubclassedModule extends AbstractModule {}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = SubclassedModule.class)",
-            "interface TestComponent {",
-            "  int i();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(abstractModule, subclassedModule, component);
-    assertThat(compilation).succeeded();
-  }
-
-}
diff --git a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 21de94a06..a852752e2 100644
--- a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -564,7 +564,7 @@
     assertThat(compilation).failed();
     // for whatever reason, javac only reports the error once on the constructor
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6);
   }
@@ -824,12 +824,12 @@
     Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6)
         .atColumn(11);
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6)
         .atColumn(23);
@@ -943,7 +943,7 @@
     Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6);
   }
diff --git a/javatests/dagger/internal/codegen/MembersInjectionTest.java b/javatests/dagger/internal/codegen/MembersInjectionTest.java
index cc78863a9..bb6029fab 100644
--- a/javatests/dagger/internal/codegen/MembersInjectionTest.java
+++ b/javatests/dagger/internal/codegen/MembersInjectionTest.java
@@ -1017,7 +1017,8 @@ public void fieldInjectionForShadowedMember() {
     assertThat(compilation).succeeded();
   }
 
-  @Test public void rawFrameworkTypes() {
+  @Test
+  public void rawFrameworkTypeField() {
     JavaFileObject file =
         JavaFileObjects.forSourceLines(
             "test.RawFrameworkTypes",
@@ -1031,25 +1032,45 @@ public void fieldInjectionForShadowedMember() {
             "  @Inject Provider fieldWithRawProvider;",
             "}",
             "",
+            "@Component",
+            "interface C {",
+            "  void inject(RawProviderField rawProviderField);",
+            "}");
+
+    Compilation compilation = daggerCompiler().withOptions(compilerMode.javacopts()).compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("javax.inject.Provider cannot be provided")
+        .inFile(file)
+        .onLineContaining("interface C");
+  }
+
+  @Test
+  public void rawFrameworkTypeParameter() {
+    JavaFileObject file =
+        JavaFileObjects.forSourceLines(
+            "test.RawFrameworkTypes",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
             "class RawProviderParameter {",
             "  @Inject void methodInjection(Provider rawProviderParameter) {}",
             "}",
             "",
             "@Component",
             "interface C {",
-            "  void inject(RawProviderField rawProviderField);",
             "  void inject(RawProviderParameter rawProviderParameter);",
             "}");
+
     Compilation compilation = daggerCompiler().withOptions(compilerMode.javacopts()).compile(file);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("javax.inject.Provider cannot be provided")
         .inFile(file)
-        .onLine(17);
-    assertThat(compilation)
-        .hadErrorContaining("javax.inject.Provider cannot be provided")
-        .inFile(file)
-        .onLine(18);
+        .onLineContaining("interface C");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/MembersInjectionValidationTest.java b/javatests/dagger/internal/codegen/MembersInjectionValidationTest.java
new file mode 100644
index 000000000..f8e41e98a
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MembersInjectionValidationTest.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MembersInjectionValidationTest {
+  @Test
+  public void membersInjectDependsOnUnboundedType() {
+    JavaFileObject injectsUnboundedType =
+        JavaFileObjects.forSourceLines(
+            "test.InjectsUnboundedType",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import java.util.ArrayList;",
+            "import javax.inject.Inject;",
+            "",
+            "class InjectsUnboundedType {",
+            "  @Inject MembersInjector<ArrayList<?>> listInjector;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void injectsUnboundedType(InjectsUnboundedType injects);",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(injectsUnboundedType, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Cannot inject members into types with unbounded type arguments: "
+                    + "java.util.ArrayList<?>",
+                "    dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
+                "        test.InjectsUnboundedType.listInjector",
+                "    test.InjectsUnboundedType is injected at",
+                "        test.TestComponent.injectsUnboundedType(test.InjectsUnboundedType)"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Ignore // TODO(b/77220343)
+  @Test
+  public void membersInjectPrimitive() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(int primitive);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into int")
+        .inFile(component)
+        .onLineContaining("void inject(int primitive);");
+  }
+
+  @Ignore // TODO(b/77220343)
+  @Test
+  public void membersInjectArray() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(Object[] array);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into java.lang.Object[]")
+        .inFile(component)
+        .onLineContaining("void inject(Object[] array);");
+  }
+
+  @Ignore // TODO(b/77220343)
+  @Test
+  public void membersInjectorOfArray() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MembersInjector;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  MembersInjector<Object[]> objectArrayInjector();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into java.lang.Object[]")
+        .inFile(component)
+        .onLineContaining("objectArrayInjector();");
+  }
+
+  @Test
+  public void membersInjectRawType() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Set;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(Set rawSet);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("Cannot inject members into raw type java.util.Set");
+  }
+
+  @Test
+  public void staticFieldInjection() {
+    JavaFileObject injected =
+        JavaFileObjects.forSourceLines(
+            "test.Injected",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Injected {",
+            "  @Inject static Object object;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(Injected injected);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(injected, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("static fields").inFile(injected).onLine(6);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MissingBindingValidationTest.java b/javatests/dagger/internal/codegen/MissingBindingValidationTest.java
new file mode 100644
index 000000000..9a677a4d2
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MissingBindingValidationTest.java
@@ -0,0 +1,609 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MissingBindingValidationTest {
+  @Test
+  public void dependOnInterface() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface MyComponent {",
+        "  Foo getFoo();",
+        "}");
+    JavaFileObject injectable = JavaFileObjects.forSourceLines("test.Foo",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Foo {",
+        "  @Inject Foo(Bar bar) {}",
+        "}");
+    JavaFileObject nonInjectable = JavaFileObjects.forSourceLines("test.Bar",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "interface Bar {}");
+    Compilation compilation = daggerCompiler().compile(component, injectable, nonInjectable);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
+        .inFile(component)
+        .onLineContaining("interface MyComponent");
+  }
+
+  @Test
+  public void entryPointDependsOnInterface() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  @Component()",
+            "  interface AComponent {",
+            "    A getA();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "[Dagger/MissingBinding] test.TestClass.A cannot be provided "
+                + "without an @Provides-annotated method.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
+  }
+
+  @Test
+  public void entryPointDependsOnQualifiedInterface() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Qualifier;",
+            "",
+            "final class TestClass {",
+            "  @Qualifier @interface Q {}",
+            "  interface A {}",
+            "",
+            "  @Component()",
+            "  interface AComponent {",
+            "    @Q A qualifiedA();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "[Dagger/MissingBinding] @test.TestClass.Q test.TestClass.A cannot be provided "
+                + "without an @Provides-annotated method.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
+  }
+
+  @Test public void constructorInjectionWithoutAnnotation() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static class A {",
+        "    A() {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A cannot be provided without an @Inject constructor or an "
+                + "@Provides-annotated method.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
+  }
+
+  @Test public void membersInjectWithoutProvision() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    B getB();",
+        "  }",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.B cannot be provided without an @Inject constructor or an "
+                + "@Provides-annotated method. This type supports members injection but cannot be "
+                + "implicitly provided.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
+  }
+
+  @Test
+  public void missingBindingWithSameKeyAsMembersInjectionMethod() {
+    JavaFileObject self =
+        JavaFileObjects.forSourceLines(
+            "test.Self",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "class Self {",
+            "  @Inject Provider<Self> selfProvider;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.SelfComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface SelfComponent {",
+            "  void inject(Self target);",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(self, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.Self cannot be provided without an @Inject constructor")
+        .inFile(component)
+        .onLineContaining("interface SelfComponent");
+  }
+
+  @Test
+  public void genericInjectClassWithWildcardDependencies() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Foo<? extends Number> foo();",
+            "}");
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Foo<T> {",
+            "  @Inject Foo(T t) {}",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component, foo);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.Foo<? extends java.lang.Number> cannot be provided "
+                + "without an @Provides-annotated method");
+  }
+
+  @Test public void longChainOfDependencies() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Lazy;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Named;",
+            "import javax.inject.Provider;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  static class B {",
+            "    @Inject B(A a) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject B b;",
+            "    @Inject C(X x) {}",
+            "  }",
+            "",
+            "  interface D { }",
+            "",
+            "  static class DImpl implements D {",
+            "    @Inject DImpl(C c, B b) {}",
+            "  }",
+            "",
+            "  static class X {",
+            "    @Inject X() {}",
+            "  }",
+            "",
+            "  @Module",
+            "  static class DModule {",
+            "    @Provides @Named(\"slim shady\") D d(X x1, DImpl impl, X x2) { return impl; }",
+            "  }",
+            "",
+            "  @Component(modules = { DModule.class })",
+            "  interface AComponent {",
+            "    @Named(\"slim shady\") D getFoo();",
+            "    C injectC(C c);",
+            "    Provider<C> cProvider();",
+            "    Lazy<C> lazyC();",
+            "    Provider<Lazy<C>> lazyCProvider();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.TestClass.A cannot be provided without an @Provides-annotated method.",
+                "    test.TestClass.A is injected at",
+                "        test.TestClass.B.<init>(a)",
+                "    test.TestClass.B is injected at",
+                "        test.TestClass.C.b",
+                "    test.TestClass.C is injected at",
+                "        test.TestClass.AComponent.injectC(test.TestClass.C)",
+                "The following other entry points also depend on it:",
+                "    test.TestClass.AComponent.getFoo()",
+                "    test.TestClass.AComponent.cProvider()",
+                "    test.TestClass.AComponent.lazyC()",
+                "    test.TestClass.AComponent.lazyCProvider()"))
+        .inFile(component)
+        .onLineContaining("interface AComponent");
+  }
+
+  @Test
+  public void bindsMethodAppearsInTrace() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "TestComponent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestInterface testInterface();",
+            "}");
+    JavaFileObject interfaceFile =
+        JavaFileObjects.forSourceLines("TestInterface", "interface TestInterface {}");
+    JavaFileObject implementationFile =
+        JavaFileObjects.forSourceLines(
+            "TestImplementation",
+            "import javax.inject.Inject;",
+            "",
+            "final class TestImplementation implements TestInterface {",
+            "  @Inject TestImplementation(String missingBinding) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "TestModule",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Binds abstract TestInterface bindTestInterface(TestImplementation implementation);",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(component, module, interfaceFile, implementationFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.lang.String cannot be provided without an @Inject constructor or an "
+                    + "@Provides-annotated method.",
+                "    java.lang.String is injected at",
+                "        TestImplementation.<init>(missingBinding)",
+                "    TestImplementation is injected at",
+                "        TestModule.bindTestInterface(implementation)",
+                "    TestInterface is provided at",
+                "        TestComponent.testInterface()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test public void resolvedParametersInDependencyTrace() {
+    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class Generic<T> {",
+        "  @Inject Generic(T t) {}",
+        "}");
+    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import java.util.List;",
+        "",
+        "final class TestClass {",
+        "  @Inject TestClass(List list) {}",
+        "}");
+    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class UsesTest {",
+        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  UsesTest usesTest();",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "    java.util.List is injected at",
+                "        test.TestClass.<init>(list)",
+                "    test.TestClass is injected at",
+                "        test.Generic.<init>(t)",
+                "    test.Generic<test.TestClass> is injected at",
+                "        test.UsesTest.<init>(genericTestClass)",
+                "    test.UsesTest is provided at",
+                "        test.TestComponent.usesTest()"));
+  }
+
+  @Test public void resolvedVariablesInDependencyTrace() {
+    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class Generic<T> {",
+        "  @Inject T t;",
+        "  @Inject Generic() {}",
+        "}");
+    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import java.util.List;",
+        "",
+        "final class TestClass {",
+        "  @Inject TestClass(List list) {}",
+        "}");
+    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class UsesTest {",
+        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  UsesTest usesTest();",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "    java.util.List is injected at",
+                "        test.TestClass.<init>(list)",
+                "    test.TestClass is injected at",
+                "        test.Generic.t",
+                "    test.Generic<test.TestClass> is injected at",
+                "        test.UsesTest.<init>(genericTestClass)",
+                "    test.UsesTest is provided at",
+                "        test.TestComponent.usesTest()"));
+  }
+
+  @Test
+  public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "Parent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "ParentModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides static Object needsString(String string) {",
+            "    return \"needs string: \" + string;",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "Child",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  String string();",
+            "  Object needsString();",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "ChildModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides static String string() {",
+            "    return \"child string\";",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(parent, parentModule, child, childModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContainingMatch(
+            "(?s)\\Qjava.lang.String cannot be provided\\E.*\\QChild.needsString()\\E")
+        .inFile(parent)
+        .onLineContaining("interface Parent");
+  }
+
+  @Test
+  public void multibindingContributionBetweenAncestorComponentAndEntrypointComponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "Parent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "Child",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "Grandchild",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "  Object object();",
+            "}");
+
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "ParentModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides static Object dependsOnSet(Set<String> strings) {",
+            "    return \"needs strings: \" + strings;",
+            "  }",
+            "",
+            "  @Provides @IntoSet static String contributesToSet() {",
+            "    return \"parent string\";",
+            "  }",
+            "",
+            "  @Provides int missingDependency(double dub) {",
+            "    return 4;",
+            "  }",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "ChildModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides @IntoSet static String contributesToSet(int i) {",
+            "    return \"\" + i;",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(parent, parentModule, child, childModule, grandchild);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContainingMatch(
+            "(?s)\\Qjava.lang.Double cannot be provided\\E.*"
+                + "\\QGrandchild.object() [Parent → Child → Grandchild]\\E$")
+        .inFile(parent)
+        .onLineContaining("interface Parent");
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index c030266b2..ca9cc9550 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -213,13 +213,12 @@ public void providesMethodReturnsProduced() {
         "",
         "@Module(includes = Void.class)",
         "class TestModule {}");
+
     Compilation compilation = daggerCompiler().compile(module);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            String.format(
-                "%s is listed as a module, but is not annotated with %s",
-                "java.lang.Void", "@Module"));
+            "java.lang.Void is listed as a module, but is not annotated with @Module");
   }
 
   @Test public void singleProvidesMethodNoArgs() {
@@ -1301,14 +1300,13 @@ public void genericSubclassedModule() {
           "",
           "@Qualifier @interface QualifierB {}");
 
-  @Test public void providesMethodMultipleQualifiers() {
+  @Test
+  public void providesMethodMultipleQualifiersOnMethod() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
         "import dagger.Module;",
         "import dagger.Provides;",
-        "import javax.annotation.Nullable;",
-        "import javax.inject.Singleton;",
         "",
         "@Module",
         "final class TestModule {",
@@ -1318,7 +1316,53 @@ public void genericSubclassedModule() {
         "}");
     Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("Cannot use more than one @Qualifier");
+    assertThat(compilation).hadErrorContaining("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void providesMethodMultipleQualifiersOnParameter() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides static String provideString(@QualifierA @QualifierB Object object) {",
+            "    return \"foo\";",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void providesMethodWildcardDependency() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides static String provideString(Provider<? extends Number> numberProvider) {",
+            "    return \"foo\";",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, or Produced<T> "
+                + "when T is a wildcard type such as ? extends java.lang.Number");
   }
 
   private static final JavaFileObject SCOPE_A =
diff --git a/javatests/dagger/internal/codegen/MultibindingTest.java b/javatests/dagger/internal/codegen/MultibindingTest.java
index 23ce61438..fb156cd57 100644
--- a/javatests/dagger/internal/codegen/MultibindingTest.java
+++ b/javatests/dagger/internal/codegen/MultibindingTest.java
@@ -134,7 +134,7 @@ public void concreteBindingForMultibindingAlias() {
             "java.util.Map<java.lang.String,java.lang.String> "
                 + "cannot be provided without an @Provides-annotated method")
         .inFile(component)
-        .onLineContaining("mapOfStringToString()");
+        .onLineContaining("interface TestComponent");
   }
 
   @Test
@@ -186,8 +186,7 @@ public void produceConcreteSet_andRequestSetOfProduced() {
             "java.util.Set<dagger.producers.Produced<java.lang.String>> "
                 + "cannot be provided without an @Provides- or @Produces-annotated method")
         .inFile(component)
-        .onLineContaining("setOfProduced()");
-
+        .onLineContaining("interface TestComponent");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/MultibindsValidatorTest.java b/javatests/dagger/internal/codegen/MultibindsValidatorTest.java
index 6f642f603..cdd74df0d 100644
--- a/javatests/dagger/internal/codegen/MultibindsValidatorTest.java
+++ b/javatests/dagger/internal/codegen/MultibindsValidatorTest.java
@@ -141,7 +141,7 @@ public void overqualifiedSet() {
                 + "abstract Set<Object> tooManyQualifiersSet();")
         .withDeclaration(moduleDeclaration)
         .importing(SomeQualifier.class, OtherQualifier.class)
-        .hasError("Cannot use more than one @Qualifier");
+        .hasError("may not use more than one @Qualifier");
   }
 
   @Test
@@ -151,7 +151,7 @@ public void overqualifiedMap() {
                 + "abstract Map<String, Object> tooManyQualifiersMap();")
         .withDeclaration(moduleDeclaration)
         .importing(SomeQualifier.class, OtherQualifier.class)
-        .hasError("Cannot use more than one @Qualifier");
+        .hasError("may not use more than one @Qualifier");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/NullableBindingValidationTest.java b/javatests/dagger/internal/codegen/NullableBindingValidationTest.java
new file mode 100644
index 000000000..4b5429ede
--- /dev/null
+++ b/javatests/dagger/internal/codegen/NullableBindingValidationTest.java
@@ -0,0 +1,390 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.NullableBindingValidation.nullableToNonNullable;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class NullableBindingValidationTest {
+  private static final JavaFileObject NULLABLE =
+      JavaFileObjects.forSourceLines(
+          "test.Nullable", // force one-string-per-line format
+          "package test;",
+          "",
+          "public @interface Nullable {}");
+
+  @Test public void nullCheckForConstructorParameters() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(String string) {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, a, module, component);
+    assertThat(compilation2).succeeded();
+  }
+
+  @Test public void nullCheckForMembersInjectParam() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "  @Inject void register(String string) {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, a, module, component);
+    assertThat(compilation2).succeeded();
+  }
+
+  @Test public void nullCheckForVariable() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject String string;",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, a, module, component);
+    assertThat(compilation2).succeeded();
+  }
+
+  @Test public void nullCheckForComponentReturn() {
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  String string();",
+        "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, module, component);
+    assertThat(compilation2).succeeded();
+  }
+
+  @Test
+  public void nullCheckForOptionalInstance() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<String> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+  }
+
+  @Test
+  public void nullCheckForOptionalProvider() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Provider<String>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).succeeded();
+  }
+
+  @Test
+  public void nullCheckForOptionalLazy() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.Lazy;",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Lazy<String>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).succeeded();
+  }
+
+  @Test
+  public void nullCheckForOptionalProviderOfLazy() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.Lazy;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Provider<Lazy<String>>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).succeeded();
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 5169ced35..cd9a97779 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -466,11 +466,32 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
         .generatesSources(factoryFile);
   }
 
-  @Test public void producesMethodMultipleQualifiers() {
+  @Test
+  public void producesMethodMultipleQualifiersOnMethod() {
+    assertThatProductionModuleMethod(
+            "@Produces @QualifierA @QualifierB static String produceString() { return null; }")
+        .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
+        .hasError("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void producesMethodMultipleQualifiersOnParameter() {
     assertThatProductionModuleMethod(
-            "@Produces @QualifierA @QualifierB abstract String produceString() { return null; }")
+            "@Produces static String produceString(@QualifierA @QualifierB Object input) "
+                + "{ return null; }")
         .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
-        .hasError("Cannot use more than one @Qualifier");
+        .hasError("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void producesMethodWildcardDependency() {
+    assertThatProductionModuleMethod(
+            "@Produces static String produceString(Provider<? extends Number> numberProvider) "
+                + "{ return null; }")
+        .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
+        .hasError(
+            "Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, or Produced<T> "
+                + "when T is a wildcard type such as ? extends java.lang.Number");
   }
 
   @Qualifier
diff --git a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
index 1ea56dbe1..1029c1cd5 100644
--- a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -80,7 +80,7 @@
             "test.Bar cannot be provided without an @Inject constructor or an @Provides- or "
                 + "@Produces-annotated method.")
         .inFile(component)
-        .onLine(8);
+        .onLineContaining("interface MyComponent");
   }
 
   @Test public void componentProductionWithNoDependencyChain() {
@@ -98,11 +98,15 @@
         "    ListenableFuture<A> getA();",
         "  }",
         "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated method.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(11);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated "
+                + "method.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
   }
 
   @Test public void provisionDependsOnProduction() {
@@ -139,11 +143,13 @@
         "    ListenableFuture<A> getA();",
         "  }",
         "}");
-    String expectedError =
-        "test.TestClass.A is a provision, which cannot depend on a production.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(30);
+    assertThat(compilation)
+        .hadErrorContaining("test.TestClass.A is a provision, which cannot depend on a production.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
   }
 
   @Test public void provisionEntryPointDependsOnProduction() {
@@ -172,11 +178,14 @@
             "    A getA();",
             "  }",
             "}");
-    String expectedError =
-        "test.TestClass.A is a provision entry-point, which cannot depend on a production.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(20);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A is a provision entry-point, which cannot depend on a production.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
   }
 
   @Test
@@ -234,7 +243,7 @@ public void providingMultibindingWithProductions() {
     assertThat(compilation)
         .hadErrorContaining("test.TestClass.A is a provision, which cannot depend on a production")
         .inFile(component)
-        .onLine(43);
+        .onLineContaining("interface AComponent");
   }
 
   @Test
@@ -278,11 +287,14 @@ public void monitoringDependsOnUnboundType() {
             "    ListenableFuture<String> getString();",
             "  }",
             "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Provides-annotated method.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(34);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A cannot be provided without an @Provides-annotated method.")
+        .inFile(component)
+        .onLineContaining("interface StringComponent");
   }
 
   @Test
@@ -329,13 +341,16 @@ public void monitoringDependsOnProduction() {
             "    ListenableFuture<String> getString();",
             "  }",
             "}");
-    String expectedError =
-        "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory>"
-            + " test.TestClass.MonitoringModule#monitorFactory is a provision,"
-            + " which cannot depend on a production.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(37);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory>"
+                + " test.TestClass.MonitoringModule#monitorFactory is a provision,"
+                + " which cannot depend on a production.")
+        .inFile(component)
+        .onLineContaining("interface StringComponent");
   }
 
   @Test
@@ -376,7 +391,10 @@ public void cycleNotBrokenByMap() {
             "}");
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component, module);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("cycle").inFile(component).onLine(8);
+    assertThat(compilation)
+        .hadErrorContaining("cycle")
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
   }
 
   @Test
@@ -418,7 +436,10 @@ public void cycleNotBrokenByProducerMap() {
             "}");
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component, module);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("cycle").inFile(component).onLine(8);
+    assertThat(compilation)
+        .hadErrorContaining("cycle")
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
   }
   
   @Test
diff --git a/javatests/dagger/internal/codegen/ReleasableReferenceManagerValidationTest.java b/javatests/dagger/internal/codegen/ReleasableReferenceManagerValidationTest.java
new file mode 100644
index 000000000..ad039cad3
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ReleasableReferenceManagerValidationTest.java
@@ -0,0 +1,490 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ReleasableReferenceManagerValidationTest {
+  @Test
+  public void missingReleasableReferenceManager() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@BadMetadata",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject otherScope =
+        JavaFileObjects.forSourceLines(
+            "test.OtherScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface OtherScope {}");
+    JavaFileObject yetAnotherScope =
+        JavaFileObjects.forSourceLines(
+            "test.YetAnotherScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface YetAnotherScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+    JavaFileObject badMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.BadMetadata", // force one-string-per-line format
+            "package test;",
+            "",
+            "@interface BadMetadata {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponents",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "",
+            "interface TestComponents {",
+            "  @TestScope",
+            "  @YetAnotherScope",
+            "  @Component",
+            "  interface WrongScopeComponent {",
+            "    @ForReleasableReferences(OtherScope.class)",
+            "    ReleasableReferenceManager otherManager();",
+            "  }",
+            "",
+            "  @TestScope",
+            "  @YetAnotherScope",
+            "  @Component",
+            "  interface WrongMetadataComponent {",
+            "    @ForReleasableReferences(TestScope.class)",
+            "    TypedReleasableReferenceManager<TestMetadata> wrongMetadata();",
+            "  }",
+            "",
+            "  @TestScope",
+            "  @YetAnotherScope",
+            "  @Component",
+            "  interface BadMetadataComponent {",
+            "    @ForReleasableReferences(TestScope.class)",
+            "    TypedReleasableReferenceManager<BadMetadata> badManager();",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.OtherScope.class) "
+                + "dagger.releasablereferences.ReleasableReferenceManager "
+                + "because no component in test.TestComponents.WrongScopeComponent's "
+                + "component hierarchy is annotated with @test.OtherScope. "
+                + "The available reference-releasing scopes are "
+                + "[@test.TestScope, @test.YetAnotherScope].")
+        .inFile(component)
+        .onLineContaining("interface WrongScopeComponent");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
+                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.TestMetadata> "
+                + "because test.TestScope is not annotated with @test.TestMetadata")
+        .inFile(component)
+        .onLineContaining("interface WrongMetadataComponent");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
+                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.BadMetadata> "
+                + "because test.BadMetadata is not annotated with "
+                + "@dagger.releasablereferences.CanReleaseReferences")
+        .inFile(component)
+        .onLineContaining("interface BadMetadataComponent");
+  }
+
+  @Test
+  public void releasableReferenceManagerConflict_ReleasableReferenceManager() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@TestMetadata",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides @ForReleasableReferences(TestScope.class)",
+            "  static ReleasableReferenceManager rrm() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "",
+            "@TestScope",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  ReleasableReferenceManager testManager();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(testScope, testMetadata, testModule, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                message(
+                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager is bound multiple times:",
+                    "    @Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager test.TestModule.rrm()",
+                    "    binding for "
+                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager from the scope declaration"),
+                "dagger.releasablereferences"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void releasableReferenceManagerConflict_TypedReleasableReferenceManager() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@TestMetadata",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides @ForReleasableReferences(TestScope.class)",
+            "  static TypedReleasableReferenceManager<TestMetadata> typedRrm() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "",
+            "@TestScope",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(testScope, testMetadata, testModule, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                message(
+                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "is bound multiple times:",
+                    "    @Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "test.TestModule.typedRrm()",
+                    "    binding for "
+                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "from the scope declaration"),
+                "dagger.releasablereferences"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void releasableReferenceManagerConflict_SetOfReleasableReferenceManager() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@TestMetadata",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides",
+            "  static Set<ReleasableReferenceManager> rrmSet() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@TestScope",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Set<ReleasableReferenceManager> managers();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(testScope, testMetadata, testModule, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
+                    + "is bound multiple times:",
+                "    @Provides "
+                    + "Set<dagger.releasablereferences.ReleasableReferenceManager> "
+                    + "test.TestModule.rrmSet()",
+                "    Dagger-generated binding for "
+                    + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void releasableReferenceManagerConflict_SetOfTypedReleasableReferenceManagers() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@TestMetadata",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides",
+            "  static Set<TypedReleasableReferenceManager<TestMetadata>> typedRrmSet() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@TestScope",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(testScope, testMetadata, testModule, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                message(
+                    "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
+                        + "is bound multiple times:",
+                    "    @Provides "
+                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
+                        + "test.TestModule.typedRrmSet()",
+                    "    Dagger-generated binding for "
+                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
+                "dagger.releasablereferences"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+}
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index a829ec3d5..3cfed6971 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -18,8 +18,8 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
 
-import com.google.common.base.Joiner;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -719,15 +719,17 @@ public void testMultipleSettersPerBoundInstanceTypeFails() {
             "    @BindsInstance void set2(String s);",
             "  }",
             "}");
+
     Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "[test.ChildComponent.s()] java.lang.String is bound multiple times:",
-                    "@BindsInstance void test.ChildComponent.Builder.set1(String)",
-                    "@BindsInstance void test.ChildComponent.Builder.set2(String)"))
+            message(
+                "java.lang.String is bound multiple times:",
+                "    @BindsInstance void test.ChildComponent.Builder.set1(String)",
+                "    @BindsInstance void test.ChildComponent.Builder.set2(String)",
+                "    java.lang.String is provided at",
+                "        test.ChildComponent.s() [test.ParentComponent → test.ChildComponent]"))
         .inFile(componentFile)
         .onLineContaining("interface ParentComponent {");
   }
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index 1842fb2fb..212e62aae 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -309,11 +309,10 @@ public void factoryMethod_grandchild() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "[test.ChildComponent.getString()] "
-                + "java.lang.Integer cannot be provided without an @Inject constructor or an "
+            "java.lang.Integer cannot be provided without an @Inject constructor or an "
                 + "@Provides-annotated method")
         .inFile(componentFile)
-        .onLine(6);
+        .onLineContaining("interface TestComponent");
   }
 
   @Test public void subcomponentOnConcreteType() {
diff --git a/javatests/dagger/internal/codegen/TestUtils.java b/javatests/dagger/internal/codegen/TestUtils.java
index c7191d3ea..c02a5f934 100644
--- a/javatests/dagger/internal/codegen/TestUtils.java
+++ b/javatests/dagger/internal/codegen/TestUtils.java
@@ -21,10 +21,10 @@
 /** Utility methods useful for codegen tests. */
 final class TestUtils {
 
-  private static final Joiner MESSAGE_JOINER = Joiner.on("\n      ");
+  private static final Joiner MESSAGE_JOINER = Joiner.on("\n  ");
 
   /**
-   * Returns the lines joined by newline plus the standard indent. Useful for passing to {@link
+   * Returns the lines joined by newline plus two spaces. Useful for passing to {@link
    * com.google.testing.compile.CompilationSubject#hadErrorContaining(String)}, etc.
    */
   static String message(String... lines) {
diff --git a/javatests/dagger/spi/SpiPluginTest.java b/javatests/dagger/spi/SpiPluginTest.java
index d9d479b38..fd4d9d9fe 100644
--- a/javatests/dagger/spi/SpiPluginTest.java
+++ b/javatests/dagger/spi/SpiPluginTest.java
@@ -63,12 +63,12 @@ public void dependencyTraceAtBinding() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Binding!",
-                "      test.Foo is provided at",
-                "          test.TestComponent.foo()"))
+                "    test.Foo is provided at",
+                "        test.TestComponent.foo()"))
         .inFile(component)
-        .onLineContaining("Foo foo();");
+        .onLineContaining("interface TestComponent");
   }
 
   @Test
@@ -151,64 +151,49 @@ public void dependencyTraceAtDependencyRequest() {
 
     assertThat(compilationFactory.compilationWithErrorOnDependency("entryPoint"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
-        .onLineContaining("EntryPoint entryPoint();");
+        .onLineContaining("interface TestComponent");
     assertThat(compilationFactory.compilationWithErrorOnDependency("dup1"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.EntryPoint.<init>(…, dup1, …)",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.Duplicated is injected at",
+                "        test.EntryPoint.<init>(…, dup1, …)",
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
-        .onLineContaining("EntryPoint entryPoint();");
+        .onLineContaining("interface TestComponent");
     assertThat(compilationFactory.compilationWithErrorOnDependency("dup2"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.EntryPoint.<init>(…, dup2)",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.Duplicated is injected at",
+                "        test.EntryPoint.<init>(…, dup2)",
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
-        .onLineContaining("EntryPoint entryPoint();");
-    // Note that this compilation results in one error being reported twice since there are
-    // two entry points that depend on test.Foo
+        .onLineContaining("interface TestComponent");
+
     Compilation inFooDepCompilation =
         compilationFactory.compilationWithErrorOnDependency("inFooDep");
     assertThat(inFooDepCompilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.Foo.<init>(inFooDep)",
-                "      test.Foo is injected at",
-                "          test.EntryPoint.<init>(foo, …)",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.Duplicated is injected at",
+                "        test.Foo.<init>(inFooDep)",
+                "    test.Foo is injected at",
+                "        test.EntryPoint.<init>(foo, …)",
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()",
+                "The following other entry points also depend on it:",
+                "    test.TestComponent.chain()"))
         .inFile(component)
-        .onLineContaining("EntryPoint entryPoint();");
-    assertThat(inFooDepCompilation)
-        .hadErrorContaining(
-            lines(
-                "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.Foo.<init>(inFooDep)",
-                "      test.Foo is injected at",
-                "          test.Chain3.<init>(foo)",
-                "      test.Chain3 is injected at",
-                "          test.Chain2.<init>(chain)",
-                "      test.Chain2 is injected at",
-                "          test.Chain1.<init>(chain)",
-                "      test.Chain1 is provided at",
-                "          test.TestComponent.chain()"))
-        .inFile(component)
-        .onLineContaining("Chain1 chain();");
+        .onLineContaining("interface TestComponent");
   }
 
   @Test
@@ -260,25 +245,26 @@ public void dependencyTraceAtDependencyRequest_subcomponents() {
         new CompilationFactory(component, subcomponent, foo, entryPoint);
     assertThat(compilationFactory.compilationWithErrorOnDependency("childEntryPoint"))
         .hadErrorContaining(
-            lines(
-                "[FailingPlugin] [test.TestSubcomponent.childEntryPoint()] Bad Dependency!",
-                "      test.EntryPoint is provided at",
-                "          test.TestSubcomponent.childEntryPoint()",
-                "  component path: test.TestComponent → test.TestSubcomponent"))
+            message(
+                "[FailingPlugin] Bad Dependency!",
+                "    test.EntryPoint is provided at",
+                "        test.TestSubcomponent.childEntryPoint()"
+                    + " [test.TestComponent → test.TestSubcomponent]"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
     assertThat(compilationFactory.compilationWithErrorOnDependency("foo"))
         .hadErrorContaining(
-            lines(
-                "[FailingPlugin] [test.TestSubcomponent.childEntryPoint()] Bad Dependency!",
-                "      test.Foo is injected at",
-                "          test.EntryPoint.<init>(foo)",
-                "      test.EntryPoint is provided at",
-                "          test.TestSubcomponent.childEntryPoint()",
-                // TODO(ronshapiro): Maybe make the component path resemble a stack trace:
-                //     test.TestSubcomponent is a child of
-                //         test.TestComponent
-                "  component path: test.TestComponent → test.TestSubcomponent"))
+            // TODO(ronshapiro): Maybe make the component path resemble a stack trace:
+            //     test.TestSubcomponent is a child of
+            //         test.TestComponent
+            // TODO(dpb): Or invert the order: Child → Parent
+            message(
+                "[FailingPlugin] Bad Dependency!",
+                "    test.Foo is injected at",
+                "        test.EntryPoint.<init>(foo)",
+                "    test.EntryPoint is provided at",
+                "        test.TestSubcomponent.childEntryPoint() "
+                    + "[test.TestComponent → test.TestSubcomponent]"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -338,9 +324,7 @@ public void errorOnSubcomponent() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
-                "[FailingPlugin] Bad Subcomponent!",
-                "  component path: test.TestComponent → test.TestSubcomponent"))
+            "[FailingPlugin] Bad Subcomponent! [test.TestComponent → test.TestSubcomponent]")
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -446,27 +430,19 @@ public void shortestPathToBindingExistsThroughSubcomponentBuilder() {
                 subcomponentModule);
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Binding!",
-                "      test.ExposedOnSubcomponent is injected at",
-                "          test.Chain3.<init>(exposedOnSubcomponent)",
-                "      test.Chain3 is injected at",
-                "          test.Chain2.<init>(chain)",
-                "      test.Chain2 is injected at",
-                "          test.Chain1.<init>(chain)",
-                "      test.Chain1 is provided at",
-                "          test.TestComponent.chain()"))
-        .inFile(component)
-        .onLineContaining("Chain1 chain();");
-    assertThat(compilation)
-        .hadErrorContaining(
-            lines(
-                // TODO(ronshapiro): should this error be reported if it's already been reported at
-                // an ancestor component?
-                "[FailingPlugin] [test.TestSubcomponent.exposedOnSubcomponent()] Bad Binding!",
-                "      test.ExposedOnSubcomponent is provided at",
-                "          test.TestSubcomponent.exposedOnSubcomponent()",
-                "  component path: test.TestComponent → test.TestSubcomponent"))
+                "    test.ExposedOnSubcomponent is injected at",
+                "        test.Chain3.<init>(exposedOnSubcomponent)",
+                "    test.Chain3 is injected at",
+                "        test.Chain2.<init>(chain)",
+                "    test.Chain2 is injected at",
+                "        test.Chain1.<init>(chain)",
+                "    test.Chain1 is provided at",
+                "        test.TestComponent.chain()",
+                "The following other entry points also depend on it:",
+                "    test.TestSubcomponent.exposedOnSubcomponent() "
+                    + "[test.TestComponent → test.TestSubcomponent]"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -490,7 +466,7 @@ private Compilation compilationWithErrorOnDependency(String dependencySimpleName
     }
   }
 
-  private static String lines(String... lines) {
-    return Joiner.on('\n').join(lines);
+  private static String message(String... lines) {
+    return Joiner.on("\n  ").join(lines);
   }
 }
diff --git a/util/deploy-to-maven-central.sh b/util/deploy-to-maven-central.sh
index ab7733a42..87dff6aff 100755
--- a/util/deploy-to-maven-central.sh
+++ b/util/deploy-to-maven-central.sh
@@ -37,10 +37,6 @@ cd gh-pages
 unzip ../bazel-bin/user-docs.jar -d api/$version_name
 rm -rf api/$version_name/META-INF/
 git add api/$version_name
-sed -i -r \
-  s/"2\.[[:digit:]]+(-rc[[:digit:]]+)?"/"${version_name}"/g \
-  _layouts/default.html
-git add _layouts/default.html
 git commit -m "$version_name docs"
 git push origin gh-pages
 cd ..
