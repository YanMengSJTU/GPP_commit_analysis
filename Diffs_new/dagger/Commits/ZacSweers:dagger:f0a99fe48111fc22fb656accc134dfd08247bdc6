diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index b0fcc2378..b3a789370 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -37,7 +37,6 @@
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
@@ -55,10 +54,8 @@
   private final ComponentBindingExpressions bindingExpressions;
   protected final ComponentRequirementFields componentRequirementFields;
   protected final GeneratedComponentModel generatedComponentModel;
-  private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
   private final MembersInjectionMethods membersInjectionMethods;
   protected final List<MethodSpec> interfaceMethods = new ArrayList<>();
-  private final BindingExpression.Factory bindingExpressionFactory;
   private final ComponentRequirementField.Factory componentRequirementFieldFactory;
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   private final OptionalFactories optionalFactories;
@@ -80,8 +77,7 @@
       SubcomponentNames subcomponentNames,
       OptionalFactories optionalFactories,
       ComponentBindingExpressions bindingExpressions,
-      ComponentRequirementFields componentRequirementFields,
-      ReferenceReleasingManagerFields referenceReleasingManagerFields) {
+      ComponentRequirementFields componentRequirementFields) {
     this.types = types;
     this.elements = elements;
     this.compilerOptions = compilerOptions;
@@ -100,41 +96,28 @@
       builderFields = ImmutableMap.of();
     }
     this.componentRequirementFields = componentRequirementFields;
-    this.referenceReleasingManagerFields = referenceReleasingManagerFields;
-    this.membersInjectionMethods =
-        new MembersInjectionMethods(
-            generatedComponentModel, bindingExpressions, graph, elements, types);
-    // TODO(user): move factories into ComponentBindingExpressions.
-    this.bindingExpressionFactory =
-        new BindingExpression.Factory(
-            compilerOptions,
-            bindingExpressions,
-            componentRequirementFields,
-            membersInjectionMethods,
-            referenceReleasingManagerFields,
-            generatedComponentModel,
-            subcomponentNames,
-            graph,
-            types,
-            elements,
-            optionalFactories);
+    // TODO(user): Remove membersInjectionMethods field once we have another way to order methods.
+    this.membersInjectionMethods = bindingExpressions.membersInjectionMethods();
     this.componentRequirementFieldFactory =
         new ComponentRequirementField.Factory(generatedComponentModel, builderFields);
   }
 
   protected AbstractComponentWriter(
-      AbstractComponentWriter parent, ClassName name, BindingGraph graph) {
+      AbstractComponentWriter parent,
+      GeneratedComponentModel generatedComponentModel,
+      BindingGraph graph,
+      ComponentRequirementFields componentRequirementFields) {
     this(
         parent.types,
         parent.elements,
         parent.compilerOptions,
         graph,
-        GeneratedComponentModel.forSubcomponent(name),
+        generatedComponentModel,
         parent.subcomponentNames,
         parent.optionalFactories,
-        parent.bindingExpressions.forChildComponent(),
-        parent.componentRequirementFields.forChildComponent(),
-        parent.referenceReleasingManagerFields);
+        parent.bindingExpressions.forChildComponent(
+            graph, generatedComponentModel, componentRequirementFields),
+        componentRequirementFields);
   }
 
   /**
@@ -154,7 +137,6 @@ protected AbstractComponentWriter(
         .forEach(method -> generatedComponentModel.claimMethodName(method.getSimpleName()));
 
     addFactoryMethods();
-    createBindingExpressions();
     createComponentRequirementFields();
     implementInterfaceMethods();
     addSubcomponents();
@@ -193,35 +175,9 @@ protected final ClassName builderName() {
     return builder.name();
   }
 
-  /**
-   * Adds component factory methods.
-   */
+  /** Adds component factory methods. */
   protected abstract void addFactoryMethods();
 
-  private void createBindingExpressions() {
-    graph.resolvedBindings().values().forEach(this::createBindingExpression);
-  }
-
-  private void createBindingExpression(ResolvedBindings resolvedBindings) {
-    // If the binding can be satisfied with a static method call without dependencies or state,
-    // no field is necessary.
-    // TODO(ronshapiro): can these be merged into bindingExpressionFactory.forResolvedBindings()?
-    Optional<BindingExpression> staticBindingExpression =
-        bindingExpressionFactory.forStaticMethod(resolvedBindings);
-    if (staticBindingExpression.isPresent()) {
-      bindingExpressions.addBindingExpression(staticBindingExpression.get());
-      return;
-    }
-
-    // No field needed if there are no owned bindings.
-    if (resolvedBindings.ownedBindings().isEmpty()) {
-      return;
-    }
-
-    // TODO(gak): get rid of the field for unscoped delegated bindings
-    bindingExpressions.addBindingExpression(bindingExpressionFactory.forField(resolvedBindings));
-  }
-
   private void createComponentRequirementFields() {
     builderFields
         .keySet()
@@ -256,14 +212,7 @@ private void implementInterfaceMethods() {
 
   private void addSubcomponents() {
     for (BindingGraph subgraph : graph.subgraphs()) {
-      ComponentMethodDescriptor componentMethodDescriptor =
-          graph.componentDescriptor()
-              .subcomponentsByFactoryMethod()
-              .inverse()
-              .get(subgraph.componentDescriptor());
-      SubcomponentWriter subcomponent =
-          new SubcomponentWriter(this, Optional.ofNullable(componentMethodDescriptor), subgraph);
-      generatedComponentModel.addType(subcomponent.write().build());
+      generatedComponentModel.addType(new SubcomponentWriter(this, subgraph).write().build());
     }
   }
 
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 567d08866..ee6b09a3e 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -18,23 +18,10 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
-import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
-import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_SET;
-import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
-import static javax.lang.model.element.Modifier.PRIVATE;
 
-import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import java.util.EnumSet;
-import java.util.Optional;
-import javax.lang.model.util.Elements;
 
 /** A factory of code expressions used to access a single binding in a component. */
 abstract class BindingExpression {
@@ -67,261 +54,4 @@ CodeBlock getComponentMethodImplementation(
     CodeBlock expression = getDependencyExpression(request.kind(), requestingClass).codeBlock();
     return CodeBlock.of("return $L;", expression);
   }
-
-  /** Factory for building a {@link BindingExpression}. */
-  static final class Factory {
-    // TODO(user): Consider using PrivateMethodBindingExpression for other/all BEs?
-    private static final ImmutableSet<ContributionBinding.Kind> PRIVATE_METHOD_KINDS =
-        ImmutableSet.copyOf(
-            EnumSet.of(SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP, INJECTION, PROVISION));
-
-    private final CompilerOptions compilerOptions;
-    private final ComponentBindingExpressions componentBindingExpressions;
-    private final ComponentRequirementFields componentRequirementFields;
-    private final MembersInjectionMethods membersInjectionMethods;
-    private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
-    private final GeneratedComponentModel generatedComponentModel;
-    private final SubcomponentNames subcomponentNames;
-    private final BindingGraph graph;
-    private final DaggerTypes types;
-    private final Elements elements;
-    private final OptionalFactories optionalFactories;
-
-    Factory(
-        CompilerOptions compilerOptions,
-        ComponentBindingExpressions componentBindingExpressions,
-        ComponentRequirementFields componentRequirementFields,
-        MembersInjectionMethods membersInjectionMethods,
-        ReferenceReleasingManagerFields referenceReleasingManagerFields,
-        GeneratedComponentModel generatedComponentModel,
-        SubcomponentNames subcomponentNames,
-        BindingGraph graph,
-        DaggerTypes types,
-        Elements elements,
-        OptionalFactories optionalFactories) {
-      this.compilerOptions = checkNotNull(compilerOptions);
-      this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
-      this.componentRequirementFields = checkNotNull(componentRequirementFields);
-      this.membersInjectionMethods = checkNotNull(membersInjectionMethods);
-      this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
-      this.generatedComponentModel = checkNotNull(generatedComponentModel);
-      this.subcomponentNames = checkNotNull(subcomponentNames);
-      this.graph = checkNotNull(graph);
-      this.types = checkNotNull(types);
-      this.elements = checkNotNull(elements);
-      this.optionalFactories = checkNotNull(optionalFactories);
-    }
-
-    /** Creates a binding expression for a field. */
-    BindingExpression forField(ResolvedBindings resolvedBindings) {
-      FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.empty());
-      return create(
-          resolvedBindings,
-          MemberSelect.localField(generatedComponentModel.name(), fieldSpec.name),
-          Optional.of(newFrameworkFieldInitializer(fieldSpec, resolvedBindings)));
-    }
-
-    /** Creates a binding expression for a static method call. */
-    Optional<BindingExpression> forStaticMethod(ResolvedBindings resolvedBindings) {
-      return staticMemberSelect(resolvedBindings)
-          .map(memberSelect -> create(resolvedBindings, memberSelect, Optional.empty()));
-    }
-
-    /**
-     * Adds a field representing the resolved bindings, optionally forcing it to use a particular
-     * binding type (instead of the type the resolved bindings would typically use).
-     */
-    private FieldSpec generateFrameworkField(
-        ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
-      boolean useRawType =
-          !isTypeAccessibleFrom(
-              resolvedBindings.key().type(), generatedComponentModel.name().packageName());
-
-      FrameworkField contributionBindingField =
-          FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);
-      FieldSpec.Builder contributionField =
-          FieldSpec.builder(
-              useRawType
-                  ? contributionBindingField.type().rawType
-                  : contributionBindingField.type(),
-              generatedComponentModel.getUniqueFieldName(contributionBindingField.name()));
-      contributionField.addModifiers(PRIVATE);
-      if (useRawType) {
-        contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
-      }
-
-      return contributionField.build();
-    }
-
-    private FrameworkFieldInitializer newFrameworkFieldInitializer(
-        FieldSpec fieldSpec, ResolvedBindings resolvedBindings) {
-      return new FrameworkFieldInitializer(
-          fieldSpec,
-          resolvedBindings,
-          subcomponentNames,
-          generatedComponentModel,
-          componentBindingExpressions,
-          componentRequirementFields,
-          referenceReleasingManagerFields,
-          compilerOptions,
-          graph,
-          optionalFactories);
-    }
-
-    private BindingExpression create(
-        ResolvedBindings resolvedBindings,
-        MemberSelect memberSelect,
-        Optional<FrameworkFieldInitializer> frameworkFieldInitializer) {
-      FrameworkInstanceBindingExpression frameworkInstanceBindingExpression =
-          FrameworkInstanceBindingExpression.create(
-              resolvedBindings, memberSelect, frameworkFieldInitializer, types, elements);
-
-      switch (resolvedBindings.bindingType()) {
-        case MEMBERS_INJECTION:
-          return new MembersInjectionBindingExpression(
-              frameworkInstanceBindingExpression,
-              generatedComponentModel,
-              membersInjectionMethods);
-        case PROVISION:
-          return provisionBindingExpression(frameworkInstanceBindingExpression);
-        default:
-          return frameworkInstanceBindingExpression;
-      }
-    }
-
-    private BindingExpression provisionBindingExpression(
-        FrameworkInstanceBindingExpression frameworkInstanceBindingExpression) {
-      BindingExpression bindingExpression =
-          new ProviderOrProducerBindingExpression(
-              frameworkInstanceBindingExpression,
-              producerFromProviderBindingExpression(frameworkInstanceBindingExpression));
-
-      BindingExpression inlineBindingExpression =
-          inlineProvisionBindingExpression(bindingExpression);
-
-      ResolvedBindings resolvedBindings = frameworkInstanceBindingExpression.resolvedBindings();
-      if (usePrivateMethod(resolvedBindings.contributionBinding())) {
-        return new PrivateMethodBindingExpression(
-            resolvedBindings,
-            generatedComponentModel,
-            inlineBindingExpression,
-            referenceReleasingManagerFields,
-            compilerOptions,
-            types,
-            elements);
-      }
-
-      return inlineBindingExpression;
-    }
-
-    private FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
-        FrameworkInstanceBindingExpression providerBindingExpression) {
-      ResolvedBindings resolvedBindings = providerBindingExpression.resolvedBindings();
-      FieldSpec producerField =
-          generateFrameworkField(resolvedBindings, Optional.of(TypeNames.PRODUCER));
-      return providerBindingExpression.producerFromProvider(
-          MemberSelect.localField(generatedComponentModel.name(), producerField.name),
-          newFrameworkFieldInitializer(producerField, resolvedBindings).forProducerFromProvider());
-    }
-
-    private BindingExpression inlineProvisionBindingExpression(
-        BindingExpression bindingExpression) {
-      ProvisionBinding provisionBinding =
-          (ProvisionBinding) bindingExpression.resolvedBindings().contributionBinding();
-      switch (provisionBinding.bindingKind()) {
-        case COMPONENT:
-          return new ComponentInstanceBindingExpression(
-              bindingExpression, provisionBinding, generatedComponentModel.name(), types);
-
-        case COMPONENT_DEPENDENCY:
-          return new BoundInstanceBindingExpression(
-              bindingExpression,
-              ComponentRequirement.forDependency(provisionBinding.key().type()),
-              componentRequirementFields,
-              types);
-
-        case COMPONENT_PROVISION:
-          return new ComponentProvisionBindingExpression(
-              bindingExpression,
-              provisionBinding,
-              graph,
-              componentRequirementFields,
-              compilerOptions,
-              types);
-
-        case SUBCOMPONENT_BUILDER:
-          return new SubcomponentBuilderBindingExpression(
-              bindingExpression,
-              provisionBinding,
-              subcomponentNames.get(bindingExpression.resolvedBindings().bindingKey()),
-              types);
-
-        case SYNTHETIC_MULTIBOUND_SET:
-          return new SetBindingExpression(
-              provisionBinding,
-              graph,
-              componentBindingExpressions,
-              bindingExpression,
-              types,
-              elements);
-
-        case SYNTHETIC_MULTIBOUND_MAP:
-          return new MapBindingExpression(
-              provisionBinding,
-              graph,
-              componentBindingExpressions,
-              bindingExpression,
-              types,
-              elements);
-
-        case SYNTHETIC_OPTIONAL_BINDING:
-          return new OptionalBindingExpression(
-              provisionBinding, bindingExpression, componentBindingExpressions, types);
-
-        case SYNTHETIC_DELEGATE_BINDING:
-          return DelegateBindingExpression.create(
-              graph, bindingExpression, componentBindingExpressions, types, elements);
-
-        case BUILDER_BINDING:
-          return new BoundInstanceBindingExpression(
-              bindingExpression,
-              ComponentRequirement.forBinding(provisionBinding),
-              componentRequirementFields,
-              types);
-
-        case INJECTION:
-        case PROVISION:
-          if (canUseSimpleMethod(provisionBinding)) {
-            return new SimpleMethodBindingExpression(
-                compilerOptions,
-                provisionBinding,
-                bindingExpression,
-                componentBindingExpressions,
-                membersInjectionMethods,
-                componentRequirementFields,
-                types,
-                elements);
-          }
-          // fall through
-
-        default:
-          return bindingExpression;
-      }
-    }
-
-    private boolean usePrivateMethod(ContributionBinding binding) {
-      return (!binding.scope().isPresent() || compilerOptions.experimentalAndroidMode())
-          && PRIVATE_METHOD_KINDS.contains(binding.bindingKind());
-    }
-
-    private boolean canUseSimpleMethod(ContributionBinding binding) {
-      // Use the inlined form when in experimentalAndroidMode, as PrivateMethodBindingExpression
-      // implements scoping directly
-      // TODO(user): Also inline releasable references in experimentalAndroidMode
-      return !binding.scope().isPresent()
-          || (compilerOptions.experimentalAndroidMode()
-              && !referenceReleasingManagerFields.requiresReleasableReferences(
-                  binding.scope().get()));
-    }
-  }
 }
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index f54bbe641..0bb4bf71d 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -16,18 +16,28 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_SET;
+import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
+import static javax.lang.model.element.Modifier.PRIVATE;
 
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Optional;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
+import javax.lang.model.util.Elements;
 
 /** A central repository of code expressions used to access any binding available to a component. */
 final class ComponentBindingExpressions {
@@ -36,21 +46,80 @@
   // HierarchicalComponentMap<K, V>, or perhaps this use a flattened ImmutableMap, built from its
   // parents? If so, maybe make BindingExpression.Factory create it.
 
-  /**
-   * A list of binding expression maps. The first element contains the bindings owned by this
-   * component; the second contains the bindings owned by its parent; and so on.
-   */
-  private final ImmutableList<Map<BindingKey, BindingExpression>> bindingExpressionsMaps;
-  private final Types types;
+  private final Optional<ComponentBindingExpressions> parent;
+  private final BindingGraph graph;
+  private final DaggerTypes types;
+  private final BindingExpressionFactory bindingExpressionFactory;
+  private final Map<BindingKey, BindingExpression> bindingExpressionsMap = new HashMap<>();
+
+  ComponentBindingExpressions(
+      BindingGraph graph,
+      GeneratedComponentModel generatedComponentModel,
+      SubcomponentNames subcomponentNames,
+      ComponentRequirementFields componentRequirementFields,
+      OptionalFactories optionalFactories,
+      DaggerTypes types,
+      Elements elements,
+      CompilerOptions compilerOptions) {
+    this(
+        Optional.empty(),
+        graph,
+        generatedComponentModel,
+        subcomponentNames,
+        componentRequirementFields,
+        new ReferenceReleasingManagerFields(graph, generatedComponentModel),
+        optionalFactories,
+        types,
+        elements,
+        compilerOptions);
+  }
 
   private ComponentBindingExpressions(
-      ImmutableList<Map<BindingKey, BindingExpression>> bindingExpressionsMaps, Types types) {
-    this.bindingExpressionsMaps = bindingExpressionsMaps;
+      Optional<ComponentBindingExpressions> parent,
+      BindingGraph graph,
+      GeneratedComponentModel generatedComponentModel,
+      SubcomponentNames subcomponentNames,
+      ComponentRequirementFields componentRequirementFields,
+      ReferenceReleasingManagerFields referenceReleasingManagerFields,
+      OptionalFactories optionalFactories,
+      DaggerTypes types,
+      Elements elements,
+      CompilerOptions compilerOptions) {
+    this.parent = parent;
+    this.graph = graph;
     this.types = types;
+    this.bindingExpressionFactory =
+        new BindingExpressionFactory(
+            graph,
+            generatedComponentModel,
+            subcomponentNames,
+            this,
+            componentRequirementFields,
+            referenceReleasingManagerFields,
+            optionalFactories,
+            types,
+            elements,
+            compilerOptions);
   }
 
-  ComponentBindingExpressions(Types types) {
-    this(ImmutableList.of(newBindingExpressionMap()), types);
+  /**
+   * Returns a new object representing the bindings available from a child component of this one.
+   */
+  ComponentBindingExpressions forChildComponent(
+      BindingGraph childGraph,
+      GeneratedComponentModel childComponentModel,
+      ComponentRequirementFields childComponentRequirementFields) {
+    return new ComponentBindingExpressions(
+        Optional.of(this),
+        childGraph,
+        childComponentModel,
+        bindingExpressionFactory.subcomponentNames,
+        childComponentRequirementFields,
+        bindingExpressionFactory.referenceReleasingManagerFields,
+        bindingExpressionFactory.optionalFactories,
+        bindingExpressionFactory.types,
+        bindingExpressionFactory.elements,
+        bindingExpressionFactory.compilerOptions);
   }
 
   /**
@@ -132,32 +201,286 @@ CodeBlock getComponentMethodImplementation(
   }
 
   private BindingExpression getBindingExpression(BindingKey bindingKey) {
-    for (Map<BindingKey, BindingExpression> bindingExpressionsMap : bindingExpressionsMaps) {
-      BindingExpression expression = bindingExpressionsMap.get(bindingKey);
-      if (expression != null) {
-        return expression;
-      }
+    if (graph.resolvedBindings().containsKey(bindingKey)
+        && !graph.resolvedBindings().get(bindingKey).ownedBindings().isEmpty()) {
+      return bindingExpressionsMap.computeIfAbsent(bindingKey, this::createBindingExpression);
     }
-    throw new IllegalStateException("no binding expression found for " + bindingKey);
+    return parent
+        .map(p -> p.getBindingExpression(bindingKey))
+        .orElseThrow(
+            () -> new IllegalStateException("no binding expression found for " + bindingKey));
   }
 
-  /** Adds a binding expression for a single binding owned by this component. */
-  void addBindingExpression(BindingExpression bindingExpression) {
-    bindingExpressionsMaps
-        .get(0)
-        .put(bindingExpression.resolvedBindings().bindingKey(), bindingExpression);
+  private BindingExpression createBindingExpression(BindingKey bindingKey) {
+    return bindingExpressionFactory.create(graph.resolvedBindings().get(bindingKey));
   }
 
-  /**
-   * Returns a new object representing the bindings available from a child component of this one.
-   */
-  ComponentBindingExpressions forChildComponent() {
-    return new ComponentBindingExpressions(
-        FluentIterable.of(newBindingExpressionMap()).append(bindingExpressionsMaps).toList(),
-        types);
+  // This is only made visibile to keep the correct order of methods in the generated component.
+  // TODO(user): remove this method after removing the dependency from AbstractComponentWriter.
+  MembersInjectionMethods membersInjectionMethods() {
+    return bindingExpressionFactory.membersInjectionMethods;
   }
 
-  private static Map<BindingKey, BindingExpression> newBindingExpressionMap() {
-    return new HashMap<>();
+  /** Factory for building a {@link BindingExpression}. */
+  private static final class BindingExpressionFactory {
+    // TODO(user): Consider using PrivateMethodBindingExpression for other/all BEs?
+    private static final ImmutableSet<ContributionBinding.Kind> PRIVATE_METHOD_KINDS =
+        ImmutableSet.copyOf(
+            EnumSet.of(SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP, INJECTION, PROVISION));
+
+    private final BindingGraph graph;
+    private final GeneratedComponentModel generatedComponentModel;
+    private final ComponentBindingExpressions componentBindingExpressions;
+    private final ComponentRequirementFields componentRequirementFields;
+    private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
+    private final SubcomponentNames subcomponentNames;
+    private final OptionalFactories optionalFactories;
+    private final CompilerOptions compilerOptions;
+    private final DaggerTypes types;
+    private final Elements elements;
+    private final MembersInjectionMethods membersInjectionMethods;
+
+    BindingExpressionFactory(
+        BindingGraph graph,
+        GeneratedComponentModel generatedComponentModel,
+        SubcomponentNames subcomponentNames,
+        ComponentBindingExpressions componentBindingExpressions,
+        ComponentRequirementFields componentRequirementFields,
+        ReferenceReleasingManagerFields referenceReleasingManagerFields,
+        OptionalFactories optionalFactories,
+        DaggerTypes types,
+        Elements elements,
+        CompilerOptions compilerOptions) {
+      this.graph = graph;
+      this.generatedComponentModel = checkNotNull(generatedComponentModel);
+      this.subcomponentNames = checkNotNull(subcomponentNames);
+      this.componentBindingExpressions = componentBindingExpressions;
+      this.componentRequirementFields = checkNotNull(componentRequirementFields);
+      this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
+      this.optionalFactories = checkNotNull(optionalFactories);
+      this.types = types;
+      this.elements = checkNotNull(elements);
+      this.compilerOptions = checkNotNull(compilerOptions);
+      this.membersInjectionMethods =
+          new MembersInjectionMethods(
+              generatedComponentModel, componentBindingExpressions, graph, elements, types);
+    }
+
+    /** Creates a binding expression */
+    BindingExpression create(ResolvedBindings resolvedBindings) {
+      return forStaticMethod(resolvedBindings).orElseGet(() -> forField(resolvedBindings));
+    }
+
+    /** Creates a binding expression for a field. */
+    private BindingExpression forField(ResolvedBindings resolvedBindings) {
+      FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.empty());
+      return internalCreate(
+          resolvedBindings,
+          MemberSelect.localField(generatedComponentModel.name(), fieldSpec.name),
+          Optional.of(newFrameworkFieldInitializer(fieldSpec, resolvedBindings)));
+    }
+
+    /** Creates a binding expression for a static method call. */
+    private Optional<BindingExpression> forStaticMethod(ResolvedBindings resolvedBindings) {
+      return staticMemberSelect(resolvedBindings)
+          .map(memberSelect -> internalCreate(resolvedBindings, memberSelect, Optional.empty()));
+    }
+
+    /**
+     * Adds a field representing the resolved bindings, optionally forcing it to use a particular
+     * binding type (instead of the type the resolved bindings would typically use).
+     */
+    private FieldSpec generateFrameworkField(
+        ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
+      boolean useRawType =
+          !isTypeAccessibleFrom(
+              resolvedBindings.key().type(), generatedComponentModel.name().packageName());
+
+      FrameworkField contributionBindingField =
+          FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);
+      FieldSpec.Builder contributionField =
+          FieldSpec.builder(
+              useRawType
+                  ? contributionBindingField.type().rawType
+                  : contributionBindingField.type(),
+              generatedComponentModel.getUniqueFieldName(contributionBindingField.name()));
+      contributionField.addModifiers(PRIVATE);
+      if (useRawType) {
+        contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
+      }
+
+      return contributionField.build();
+    }
+
+    private FrameworkFieldInitializer newFrameworkFieldInitializer(
+        FieldSpec fieldSpec, ResolvedBindings resolvedBindings) {
+      return new FrameworkFieldInitializer(
+          fieldSpec,
+          resolvedBindings,
+          subcomponentNames,
+          generatedComponentModel,
+          componentBindingExpressions,
+          componentRequirementFields,
+          referenceReleasingManagerFields,
+          compilerOptions,
+          graph,
+          optionalFactories);
+    }
+
+    private BindingExpression internalCreate(
+        ResolvedBindings resolvedBindings,
+        MemberSelect memberSelect,
+        Optional<FrameworkFieldInitializer> frameworkFieldInitializer) {
+      FrameworkInstanceBindingExpression frameworkInstanceBindingExpression =
+          FrameworkInstanceBindingExpression.create(
+              resolvedBindings, memberSelect, frameworkFieldInitializer, types, elements);
+
+       switch (resolvedBindings.bindingType()) {
+        case MEMBERS_INJECTION:
+          return new MembersInjectionBindingExpression(
+              frameworkInstanceBindingExpression,
+              generatedComponentModel,
+              membersInjectionMethods);
+        case PROVISION:
+          return provisionBindingExpression(frameworkInstanceBindingExpression);
+        default:
+          return frameworkInstanceBindingExpression;
+      }
+    }
+
+    private BindingExpression provisionBindingExpression(
+        FrameworkInstanceBindingExpression frameworkInstanceBindingExpression) {
+      BindingExpression bindingExpression =
+          new ProviderOrProducerBindingExpression(
+              frameworkInstanceBindingExpression,
+              producerFromProviderBindingExpression(frameworkInstanceBindingExpression));
+
+      BindingExpression inlineBindingExpression =
+          inlineProvisionBindingExpression(bindingExpression);
+
+      ResolvedBindings resolvedBindings = frameworkInstanceBindingExpression.resolvedBindings();
+      if (usePrivateMethod(resolvedBindings.contributionBinding())) {
+        return new PrivateMethodBindingExpression(
+            resolvedBindings,
+            generatedComponentModel,
+            inlineBindingExpression,
+            referenceReleasingManagerFields,
+            compilerOptions,
+            types,
+            elements);
+      }
+
+      return inlineBindingExpression;
+    }
+
+    private FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
+        FrameworkInstanceBindingExpression providerBindingExpression) {
+      ResolvedBindings resolvedBindings = providerBindingExpression.resolvedBindings();
+      FieldSpec producerField =
+          generateFrameworkField(resolvedBindings, Optional.of(TypeNames.PRODUCER));
+      return providerBindingExpression.producerFromProvider(
+          MemberSelect.localField(generatedComponentModel.name(), producerField.name),
+          newFrameworkFieldInitializer(producerField, resolvedBindings).forProducerFromProvider());
+    }
+
+    private BindingExpression inlineProvisionBindingExpression(
+        BindingExpression bindingExpression) {
+      ProvisionBinding provisionBinding =
+          (ProvisionBinding) bindingExpression.resolvedBindings().contributionBinding();
+      switch (provisionBinding.bindingKind()) {
+        case COMPONENT:
+          return new ComponentInstanceBindingExpression(
+              bindingExpression, provisionBinding, generatedComponentModel.name(), types);
+
+        case COMPONENT_DEPENDENCY:
+          return new BoundInstanceBindingExpression(
+              bindingExpression,
+              ComponentRequirement.forDependency(provisionBinding.key().type()),
+              componentRequirementFields,
+              types);
+
+        case COMPONENT_PROVISION:
+          return new ComponentProvisionBindingExpression(
+              bindingExpression,
+              provisionBinding,
+              graph,
+              componentRequirementFields,
+              compilerOptions,
+              types);
+
+        case SUBCOMPONENT_BUILDER:
+          return new SubcomponentBuilderBindingExpression(
+              bindingExpression,
+              provisionBinding,
+              subcomponentNames.get(bindingExpression.resolvedBindings().bindingKey()),
+              types);
+
+        case SYNTHETIC_MULTIBOUND_SET:
+          return new SetBindingExpression(
+              provisionBinding,
+              graph,
+              componentBindingExpressions,
+              bindingExpression,
+              types,
+              elements);
+
+        case SYNTHETIC_MULTIBOUND_MAP:
+          return new MapBindingExpression(
+              provisionBinding,
+              graph,
+              componentBindingExpressions,
+              bindingExpression,
+              types,
+              elements);
+
+        case SYNTHETIC_OPTIONAL_BINDING:
+          return new OptionalBindingExpression(
+              provisionBinding, bindingExpression, componentBindingExpressions, types);
+
+        case SYNTHETIC_DELEGATE_BINDING:
+          return DelegateBindingExpression.create(
+              graph, bindingExpression, componentBindingExpressions, types, elements);
+
+        case BUILDER_BINDING:
+          return new BoundInstanceBindingExpression(
+              bindingExpression,
+              ComponentRequirement.forBinding(provisionBinding),
+              componentRequirementFields,
+              types);
+
+        case INJECTION:
+        case PROVISION:
+          if (canUseSimpleMethod(provisionBinding)) {
+            return new SimpleMethodBindingExpression(
+                compilerOptions,
+                provisionBinding,
+                bindingExpression,
+                componentBindingExpressions,
+                membersInjectionMethods,
+                componentRequirementFields,
+                types,
+                elements);
+          }
+          // fall through
+
+        default:
+          return bindingExpression;
+      }
+    }
+
+    private boolean usePrivateMethod(ContributionBinding binding) {
+      return (!binding.scope().isPresent() || compilerOptions.experimentalAndroidMode())
+          && PRIVATE_METHOD_KINDS.contains(binding.bindingKind());
+    }
+
+    private boolean canUseSimpleMethod(ContributionBinding binding) {
+      // Use the inlined form when in experimentalAndroidMode, as PrivateMethodBindingExpression
+      // implements scoping directly
+      // TODO(user): Also inline releasable references in experimentalAndroidMode
+      return !binding.scope().isPresent()
+          || (compilerOptions.experimentalAndroidMode()
+              && !referenceReleasingManagerFields.requiresReleasableReferences(
+                  binding.scope().get()));
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index 38b8dc7f1..a672f3552 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -38,29 +38,52 @@
       ClassName name,
       BindingGraph graph) {
     GeneratedComponentModel generatedComponentModel = GeneratedComponentModel.forComponent(name);
+    SubcomponentNames subcomponentNames = new SubcomponentNames(graph, keyFactory);
+    ComponentRequirementFields componentRequirementFields = new ComponentRequirementFields();
+    OptionalFactories optionalFactories = new OptionalFactories();
+    ComponentBindingExpressions bindingExpressions =
+        new ComponentBindingExpressions(
+            graph,
+            generatedComponentModel,
+            subcomponentNames,
+            componentRequirementFields,
+            optionalFactories,
+            types,
+            elements,
+            compilerOptions);
     return new ComponentWriter(
-            types, elements, keyFactory, compilerOptions, graph, generatedComponentModel)
+            types,
+            elements,
+            compilerOptions,
+            graph,
+            generatedComponentModel,
+            subcomponentNames,
+            bindingExpressions,
+            componentRequirementFields,
+            optionalFactories)
         .write();
   }
 
   private ComponentWriter(
       DaggerTypes types,
       Elements elements,
-      KeyFactory keyFactory,
       CompilerOptions compilerOptions,
       BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel) {
+      GeneratedComponentModel generatedComponentModel,
+      SubcomponentNames subcomponentNames,
+      ComponentBindingExpressions bindingExpressions,
+      ComponentRequirementFields componentRequirementFields,
+      OptionalFactories optionalFactories) {
     super(
         types,
         elements,
         compilerOptions,
         graph,
         generatedComponentModel,
-        new SubcomponentNames(graph, keyFactory),
-        new OptionalFactories(),
-        new ComponentBindingExpressions(types),
-        new ComponentRequirementFields(),
-        new ReferenceReleasingManagerFields(graph, generatedComponentModel));
+        subcomponentNames,
+        optionalFactories,
+        bindingExpressions,
+        componentRequirementFields);
   }
 
   private void addBuilderFactoryMethod() {
diff --git a/java/dagger/internal/codegen/SubcomponentWriter.java b/java/dagger/internal/codegen/SubcomponentWriter.java
index e7413daee..3548e7f47 100644
--- a/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -58,20 +58,29 @@
    */
   private final Optional<ComponentMethodDescriptor> subcomponentFactoryMethod;
 
-  SubcomponentWriter(
-      AbstractComponentWriter parent,
-      Optional<ComponentMethodDescriptor> subcomponentFactoryMethod,
-      BindingGraph subgraph) {
-    super(parent, subcomponentName(parent, subgraph), subgraph);
+  SubcomponentWriter(AbstractComponentWriter parent, BindingGraph graph) {
+    super(
+        parent,
+        subcomponentModel(parent, graph),
+        graph,
+        parent.componentRequirementFields.forChildComponent());
     this.parent = parent;
-    this.subcomponentFactoryMethod = subcomponentFactoryMethod;
+    this.subcomponentFactoryMethod =
+        Optional.ofNullable(
+            parent
+                .graph
+                .componentDescriptor()
+                .subcomponentsByFactoryMethod()
+                .inverse()
+                .get(graph.componentDescriptor()));
   }
 
-  private static ClassName subcomponentName(AbstractComponentWriter parent, BindingGraph subgraph) {
-    return parent
-        .generatedComponentModel
-        .name()
-        .nestedClass(parent.subcomponentNames.get(subgraph.componentDescriptor()) + "Impl");
+  private static GeneratedComponentModel subcomponentModel(
+      AbstractComponentWriter parent, BindingGraph graph) {
+    ClassName parentName = parent.generatedComponentModel.name();
+    ClassName name =
+        parentName.nestedClass(parent.subcomponentNames.get(graph.componentDescriptor()) + "Impl");
+    return GeneratedComponentModel.forSubcomponent(name);
   }
 
   private ExecutableType resolvedSubcomponentFactoryMethod() {
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index a9e9e6e6e..f2665a999 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -413,8 +413,10 @@ public void simpleComponent() {
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestClass_SimpleComponent",
                 "    implements TestClass.SimpleComponent {",
-                "  private Provider<Executor> executorProvider;",
+                // TODO(user): Fix the order of the fields. This happens because the field name
+                // is created before the field is written in ComponentBindingExpression.
                 "  private Provider<Executor> executorProvider2;",
+                "  private Provider<Executor> executorProvider;",
                 "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
                 "  private Provider<ProductionComponentMonitor> monitorProvider;",
                 "  private Provider<TestClass.B> bProvider;",
@@ -430,30 +432,30 @@ public void simpleComponent() {
                 "  }",
                 "",
                 "  public static TestClass.SimpleComponent create() {",
-                "    return new Builder().build()",
+                "    return new Builder().build();",
                 "  }",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
                 "  private void initialize(final Builder builder) {",
-                "    this.executorProvider =",
+                "    this.executorProvider2 =",
                 "        TestClass_BModule_ExecutorFactory.create(builder.bModule);",
-                "     this.executorProvider2 =",
-                "         DoubleCheck.provider(",
-                "             TestClass_SimpleComponent_ProductionExecutorModule_ExecutorFactory",
-                "                 .create(executorProvider));",
+                "    this.executorProvider =",
+                "        DoubleCheck.provider(",
+                "            TestClass_SimpleComponent_ProductionExecutorModule_ExecutorFactory",
+                "                .create(executorProvider2));",
                 "    this.simpleComponentProvider = ",
                 "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
                 "    this.monitorProvider =",
                 "        DoubleCheck.provider(",
                 "            TestClass_SimpleComponent_MonitoringModule_MonitorFactory.create(",
                 "                simpleComponentProvider,",
-                "                SetFactory.<ProductionComponentMonitor.Factory>empty());",
+                "                SetFactory.<ProductionComponentMonitor.Factory>empty()));",
                 "    this.bProvider = TestClass_BModule_BFactory.create(",
                 "        builder.bModule, TestClass_C_Factory.create());",
                 "    this.bProducer = Producers.producerFromProvider(bProvider);",
                 "    this.aProducer = new TestClass_AModule_AFactory(",
                 "        builder.aModule,",
-                "        executorProvider2,",
+                "        executorProvider,",
                 "        monitorProvider,",
                 "        bProducer);",
                 "  }",
@@ -467,8 +469,7 @@ public void simpleComponent() {
                 "    private TestClass.BModule bModule;",
                 "    private TestClass.AModule aModule;",
                 "",
-                "    private Builder() {",
-                "    }",
+                "    private Builder() {}",
                 "",
                 "    public TestClass.SimpleComponent build() {",
                 "      if (bModule == null) {",
@@ -493,10 +494,11 @@ public void simpleComponent() {
                 "    @Deprecated",
                 "    public Builder testClass_SimpleComponent_ProductionExecutorModule(",
                 "        TestClass_SimpleComponent_ProductionExecutorModule",
-                "        testClass_SimpleComponent_ProductionExecutorModule) {",
+                "            testClass_SimpleComponent_ProductionExecutorModule) {",
                 "      Preconditions.checkNotNull(testClass_SimpleComponent_ProductionExecutorModule);",
                 "      return this;",
                 "    }",
+                "  }",
                 "}");
     }
     assertAbout(javaSource())
