diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 9fa342227..f33057ffd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -97,6 +97,7 @@
    * {@link MembersInjector} implementations to initialize properly.
    */
   abstract ImmutableList<FrameworkKey> initializationOrdering();
+  
 
   static final class Factory {
     private final Elements elements;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 3842b7130..3dafc2e70 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -265,7 +265,9 @@ public String apply(TypeElement input) {
       Key key = frameworkKey.key();
       if (frameworkKey.frameworkClass().equals(Provider.class)) {
         Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
-        if (ProvisionBinding.isSetBindingCollection(bindings)) {
+        boolean setBinding;
+        boolean mapBinding;
+        if ((setBinding = ProvisionBinding.isSetBindingCollection(bindings)) == true) {
           ImmutableList.Builder<String> setFactoryParameters = ImmutableList.builder();
           for (ProvisionBinding binding : bindings) {
             setFactoryParameters.add(initializeFactoryForBinding(
@@ -274,7 +276,7 @@ public String apply(TypeElement input) {
           writer.emitStatement("this.%s = SetFactory.create(%n%s)",
               providerNames.get(key),
               Joiner.on(",\n").join(setFactoryParameters.build()));
-        } else if (ProvisionBinding.isMapBindingCollection(bindings)) {
+        } else if ((mapBinding = ProvisionBinding.isMapBindingCollection(bindings)) == true) {
           ImmutableList.Builder<String> mapFactoryParameters = ImmutableList.builder();
           for (ProvisionBinding binding : bindings) {
             mapFactoryParameters.add(initializeFactoryForBinding(
@@ -283,7 +285,7 @@ public String apply(TypeElement input) {
           writer.emitStatement("this.%s = MapProviderFactory.create(%n%s)",
               providerNames.get(key),
               Joiner.on(",\n").join(mapFactoryParameters.build()));
-        } else {
+        } else if (ProvisionBinding.isNotACollection(setBinding, mapBinding, bindings)) {
           ProvisionBinding binding = Iterables.getOnlyElement(bindings);
           writer.emitStatement("this.%s = %s",
               providerNames.get(key),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 7d97374e6..21c5ba659 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -59,7 +59,6 @@
 
   @Override
   public synchronized void init(ProcessingEnvironment processingEnv) {
-    System.out.println("Entering componentprocessor init");
     super.init(processingEnv);
 
     Messager messager = processingEnv.getMessager();
@@ -120,7 +119,6 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
 
   @Override
   public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-    System.out.println("Entering componentProcessor process");
     for (ProcessingStep processingStep : processingSteps) {
       System.out.println("Begin to process processingStep: " + processingStep.toString());
       processingStep.process(annotations, roundEnv);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 3fc086fd3..a0ef9e502 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -145,6 +145,7 @@ Key forProvidesMethod(ExecutableElement e) {
         case MAP:
           ImmutableSet<? extends AnnotationMirror> annotationmirrors = getMapKey(e);
           Map<? extends ExecutableElement, ? extends AnnotationValue> map = annotationmirrors.iterator().next().getElementValues();
+          //Support String and Enum map key type
           AnnotationValueVisitor<Object, Void> mapKeyVisitor = 
               new SimpleAnnotationValueVisitor6<Object, Void>() {
             @Override public TypeElement visitEnumConstant(VariableElement c, Void p) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index fcece97b2..683f593a5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -94,30 +94,53 @@ static boolean isSetBindingCollection(Iterable<ProvisionBinding> bindings) {
     checkArgument(iterator.hasNext(), "no bindings");
     ProvisionBinding temp = iterator.next();
     boolean setBinding = SET_BINDING_TYPES.contains(temp.provisionType());
-    boolean mapBinding = MAP_BINDING_TYPES.contains(temp.provisionType());
-    while (iterator.hasNext() && !mapBinding) {
-      checkArgument(setBinding,
-          "more than one binding present, but found a non-map or non-set binding");
-      checkArgument(SET_BINDING_TYPES.contains(iterator.next().provisionType()),
-          "more than one binding present, but found a non-map or non-set binding");
+    if (setBinding) {
+      while (iterator.hasNext()) {
+        checkArgument(setBinding,
+            "more than one binding present, but found a non-set binding");
+        checkArgument(SET_BINDING_TYPES.contains(iterator.next().provisionType()),
+            "more than one binding present, but found a non-set binding");
+      }
     }
     return setBinding;
   }
-  
+
+  /**
+   * Returns {@code true} if the given bindings are all contributors to a map binding.
+   *
+   * @throws IllegalArgumentException if some of the bindings are map bindings and some are not.
+   */
   static boolean isMapBindingCollection(Iterable<ProvisionBinding> bindings) {
     checkNotNull(bindings);
     Iterator<ProvisionBinding> iterator = bindings.iterator();
     checkArgument(iterator.hasNext(), "no bindings");
     ProvisionBinding temp = iterator.next();
     boolean mapBinding = MAP_BINDING_TYPES.contains(temp.provisionType());
-    while (iterator.hasNext()) {
-      checkArgument(mapBinding,
-          "more than one binding present, but found a non-map or set binding");
-      checkArgument(MAP_BINDING_TYPES.contains(iterator.next().provisionType()),
-          "more than one binding present, but found a non-map or set binding");
+    if (mapBinding) {
+      while (iterator.hasNext()) {
+        checkArgument(mapBinding,
+            "more than one binding present, but found a non-map binding");
+        checkArgument(MAP_BINDING_TYPES.contains(iterator.next().provisionType()),
+            "more than one binding present, but found a non-map binding");
+      }
     }
     return mapBinding;
   }
+  
+  /**
+   * Returns {@code true} if the given bindings is not a collection.
+   *
+   * @throws IllegalArgumentException if the bindings in the collection are not supported in Dagger.
+   */
+  static boolean isNotACollection(boolean setBinding, boolean mapBinding, Iterable<ProvisionBinding> bindings) {
+    Iterator<ProvisionBinding> iterator = bindings.iterator();
+    ProvisionBinding temp = iterator.next();
+    if (iterator.hasNext()) {
+      checkArgument(mapBinding || setBinding,
+          "more than one binding present, but found a invalid binding");
+    }
+    return !(mapBinding || setBinding);
+  }
 
   static final class Factory {
     private final Elements elements;
