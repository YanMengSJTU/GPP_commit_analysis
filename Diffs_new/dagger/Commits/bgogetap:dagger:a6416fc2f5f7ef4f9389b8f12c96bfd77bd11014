diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 782eb2e9f..133a59cb8 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -75,7 +75,7 @@
   // TODO(dpb): Make all these fields private after refactoring is complete.
   protected final Elements elements;
   protected final DaggerTypes types;
-  protected final Key.Factory keyFactory;
+  protected final KeyFactory keyFactory;
   protected final CompilerOptions compilerOptions;
   protected final ClassName name;
   protected final BindingGraph graph;
@@ -111,7 +111,7 @@
   AbstractComponentWriter(
       DaggerTypes types,
       Elements elements,
-      Key.Factory keyFactory,
+      KeyFactory keyFactory,
       CompilerOptions compilerOptions,
       ClassName name,
       BindingGraph graph,
@@ -154,7 +154,7 @@
   }
 
   private static ImmutableMap<BindingKey, String> childComponentNames(
-      Key.Factory keyFactory, ImmutableMap<ComponentDescriptor, String> subcomponentNames) {
+      KeyFactory keyFactory, ImmutableMap<ComponentDescriptor, String> subcomponentNames) {
     ImmutableMap.Builder<BindingKey, String> builder = ImmutableMap.builder();
     subcomponentNames.forEach(
         (component, name) -> {
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 73db97676..e36747957 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -117,6 +117,7 @@ java_library(
         "FrameworkTypes.java",
         "InjectBindingRegistry.java",
         "Key.java",
+        "KeyFactory.java",
         "MapKeys.java",
         "MapType.java",
         "MembersInjectionBinding.java",
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 19690a58d..813f88b6a 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -212,19 +212,23 @@ TypeElement componentType() {
   }
 
   @Memoized
+  @Override
   public abstract int hashCode();
 
+  @Override // Suppresses ErrorProne warning that hashCode was overridden w/o equals
+  public abstract boolean equals(Object other);
+
   static final class Factory {
     private final Elements elements;
     private final InjectBindingRegistry injectBindingRegistry;
-    private final Key.Factory keyFactory;
+    private final KeyFactory keyFactory;
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
 
     Factory(
         Elements elements,
         InjectBindingRegistry injectBindingRegistry,
-        Key.Factory keyFactory,
+        KeyFactory keyFactory,
         ProvisionBinding.Factory provisionBindingFactory,
         ProductionBinding.Factory productionBindingFactory) {
       this.elements = elements;
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index c89f3c6b2..62bbd6b00 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -136,7 +136,7 @@
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
-  private final Key.Factory keyFactory;
+  private final KeyFactory keyFactory;
 
   BindingGraphValidator(
       Elements elements,
@@ -147,7 +147,7 @@
       BindingDeclarationFormatter bindingDeclarationFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFormatter dependencyRequestFormatter,
-      Key.Factory keyFactory) {
+      KeyFactory keyFactory) {
     this.elements = elements;
     this.types = types;
     this.compilerOptions = compilerOptions;
diff --git a/java/dagger/internal/codegen/ComponentGenerator.java b/java/dagger/internal/codegen/ComponentGenerator.java
index 8d24aa5d6..bd29ab14c 100644
--- a/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/java/dagger/internal/codegen/ComponentGenerator.java
@@ -36,14 +36,14 @@
 final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
   private final DaggerTypes types;
   private final Elements elements;
-  private final Key.Factory keyFactory;
+  private final KeyFactory keyFactory;
   private final CompilerOptions compilerOptions;
 
   ComponentGenerator(
       Filer filer,
       Elements elements,
       DaggerTypes types,
-      Key.Factory keyFactory,
+      KeyFactory keyFactory,
       CompilerOptions compilerOptions) {
     super(filer, elements);
     this.types = types;
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index b8399dbb3..a078f1b45 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -95,7 +95,7 @@ public SourceVersion getSupportedSourceVersion() {
     DependencyRequestFormatter dependencyRequestFormatter =
         new DependencyRequestFormatter(types, elements);
 
-    Key.Factory keyFactory = new Key.Factory(types, elements);
+    KeyFactory keyFactory = new KeyFactory(types, elements);
 
     InjectValidator injectValidator = new InjectValidator(types, elements, compilerOptions);
     InjectValidator injectValidatorWhenGeneratingCode = injectValidator.whenGeneratingCode();
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index 0d24e2b4a..de1840d33 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -51,7 +51,7 @@
   ComponentWriter(
       DaggerTypes types,
       Elements elements,
-      Key.Factory keyFactory,
+      KeyFactory keyFactory,
       CompilerOptions compilerOptions,
       ClassName name,
       BindingGraph graph) {
diff --git a/java/dagger/internal/codegen/DelegateDeclaration.java b/java/dagger/internal/codegen/DelegateDeclaration.java
index c2d3e8d9f..27b233ac8 100644
--- a/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -48,11 +48,11 @@
 
   static final class Factory {
     private final Types types;
-    private final Key.Factory keyFactory;
+    private final KeyFactory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
     Factory(
-        Types types, Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
+        Types types, KeyFactory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
       this.types = types;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
diff --git a/java/dagger/internal/codegen/DependencyRequest.java b/java/dagger/internal/codegen/DependencyRequest.java
index 56b152b81..51b173142 100644
--- a/java/dagger/internal/codegen/DependencyRequest.java
+++ b/java/dagger/internal/codegen/DependencyRequest.java
@@ -207,7 +207,7 @@ BindingKey bindingKey() {
    * Returns {@code true} if {@code requestElement}'s type is a primitive type.
    *
    * <p>Because the {@link #key()} of a {@link DependencyRequest} is {@linkplain
-   * Key.Factory#boxPrimitives(TypeMirror) boxed} to normalize it with other keys, this inspects the
+   * KeyFactory#boxPrimitives(TypeMirror) boxed} to normalize it with other keys, this inspects the
    * {@link #requestElement()} directly.
    */
   boolean requestsPrimitiveType() {
@@ -316,9 +316,9 @@ protected KindAndType defaultAction(TypeMirror otherType, Void p) {
    * which may mean that the type will be generated in a later round of processing.
    */
   static final class Factory {
-    private final Key.Factory keyFactory;
+    private final KeyFactory keyFactory;
 
-    Factory(Key.Factory keyFactory) {
+    Factory(KeyFactory keyFactory) {
       this.keyFactory = keyFactory;
     }
 
diff --git a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
index 3a6e31412..32dadab10 100644
--- a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
+++ b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
@@ -61,7 +61,7 @@
   private final Messager messager;
   private final InjectValidator injectValidator;
   private final InjectValidator injectValidatorWhenGeneratingCode;
-  private final Key.Factory keyFactory;
+  private final KeyFactory keyFactory;
   private final ProvisionBinding.Factory provisionBindingFactory;
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
   private final CompilerOptions compilerOptions;
@@ -155,7 +155,7 @@ private void tryToCacheBinding(B binding) {
       Types types,
       Messager messager,
       InjectValidator injectValidator,
-      Key.Factory keyFactory,
+      KeyFactory keyFactory,
       ProvisionBinding.Factory provisionBindingFactory,
       MembersInjectionBinding.Factory membersInjectionBindingFactory,
       CompilerOptions compilerOptions) {
diff --git a/java/dagger/internal/codegen/Key.java b/java/dagger/internal/codegen/Key.java
index c17993368..4034ccbb3 100644
--- a/java/dagger/internal/codegen/Key.java
+++ b/java/dagger/internal/codegen/Key.java
@@ -16,21 +16,9 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.auto.common.MoreTypes.asExecutable;
-import static com.google.auto.common.MoreTypes.isType;
-import static com.google.auto.common.MoreTypes.isTypeOf;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.MapKeys.getMapKey;
-import static dagger.internal.codegen.MapKeys.mapKeyType;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
-import static dagger.internal.codegen.Optionals.firstPresent;
-import static javax.lang.model.element.ElementKind.METHOD;
 
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
@@ -39,28 +27,9 @@
 import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Joiner;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.Binds;
-import dagger.BindsOptionalOf;
-import dagger.multibindings.Multibinds;
-import dagger.producers.Produced;
-import dagger.producers.Producer;
-import dagger.producers.Production;
-import dagger.producers.internal.ProductionImplementation;
-import dagger.producers.monitoring.ProductionComponentMonitor;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.util.Map;
 import java.util.Optional;
-import java.util.Set;
-import java.util.concurrent.Executor;
-import java.util.stream.Stream;
-import javax.inject.Provider;
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ElementKind;
@@ -68,11 +37,8 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
@@ -304,419 +270,4 @@ public String toString() {
     return ImmutableSetMultimap.copyOf(Multimaps.index(haveKeys, HasKey::key));
   }
 
-  static final class Factory {
-    private final Types types;
-    private final Elements elements;
-    
-    Factory(Types types, Elements elements) {
-      this.types = checkNotNull(types);
-      this.elements = checkNotNull(elements);
-    }
-
-    private TypeElement getClassElement(Class<?> cls) {
-      return elements.getTypeElement(cls.getCanonicalName());
-    }
-
-    private TypeMirror boxPrimitives(TypeMirror type) {
-      return type.getKind().isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
-    }
-
-    private DeclaredType setOf(TypeMirror elementType) {
-      return types.getDeclaredType(getClassElement(Set.class), boxPrimitives(elementType));
-    }
-
-    private DeclaredType mapOf(TypeMirror keyType, TypeMirror valueType) {
-      return types.getDeclaredType(
-          getClassElement(Map.class), boxPrimitives(keyType), boxPrimitives(valueType));
-    }
-
-    /** Returns {@code Map<KeyType, FrameworkType<ValueType>>}. */
-    private TypeMirror mapOfFrameworkType(
-        TypeMirror keyType, TypeElement frameworkType, TypeMirror valueType) {
-      return mapOf(keyType, types.getDeclaredType(frameworkType, boxPrimitives(valueType)));
-    }
-
-    private DeclaredType typedReleasableReferenceManagerOf(DeclaredType metadataType) {
-      return types.getDeclaredType(
-          getClassElement(TypedReleasableReferenceManager.class), metadataType);
-    }
-
-    Key forComponentMethod(ExecutableElement componentMethod) {
-      checkArgument(componentMethod.getKind().equals(METHOD));
-      return forMethod(componentMethod, componentMethod.getReturnType());
-    }
-
-    Key forProductionComponentMethod(ExecutableElement componentMethod) {
-      checkArgument(componentMethod.getKind().equals(METHOD));
-      TypeMirror returnType = componentMethod.getReturnType();
-      TypeMirror keyType =
-          isTypeOf(ListenableFuture.class, returnType)
-              ? getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments())
-              : returnType;
-      return forMethod(componentMethod, keyType);
-    }
-
-    Key forSubcomponentBuilderMethod(
-        ExecutableElement subcomponentBuilderMethod, DeclaredType declaredContainer) {
-      checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
-      ExecutableType resolvedMethod =
-          asExecutable(types.asMemberOf(declaredContainer, subcomponentBuilderMethod));
-      return builder(resolvedMethod.getReturnType()).build();
-    }
-
-    Key forSubcomponentBuilder(TypeMirror builderType) {
-      return builder(builderType).build();
-    }
-
-    Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
-      return forBindingMethod(
-          method, contributingModule, Optional.of(getClassElement(Provider.class)));
-    }
-
-    Key forProducesMethod(ExecutableElement method, TypeElement contributingModule) {
-      return forBindingMethod(
-          method, contributingModule, Optional.of(getClassElement(Producer.class)));
-    }
-
-    /** Returns the key bound by a {@link Binds} method. */
-    Key forBindsMethod(ExecutableElement method, TypeElement contributingModule) {
-      checkArgument(isAnnotationPresent(method, Binds.class));
-      return forBindingMethod(method, contributingModule, Optional.empty());
-    }
-
-    /** Returns the base key bound by a {@link BindsOptionalOf} method. */
-    Key forBindsOptionalOfMethod(ExecutableElement method, TypeElement contributingModule) {
-      checkArgument(isAnnotationPresent(method, BindsOptionalOf.class));
-      return forBindingMethod(method, contributingModule, Optional.empty());
-    }
-
-    private Key forBindingMethod(
-        ExecutableElement method,
-        TypeElement contributingModule,
-        Optional<TypeElement> frameworkType) {
-      checkArgument(method.getKind().equals(METHOD));
-      ExecutableType methodType =
-          MoreTypes.asExecutable(
-              types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), method));
-      ContributionType contributionType = ContributionType.fromBindingMethod(method);
-      TypeMirror returnType = methodType.getReturnType();
-      if (frameworkType.isPresent()
-          && frameworkType.get().equals(getClassElement(Producer.class))
-          && isType(returnType)) {
-        if (isTypeOf(ListenableFuture.class, returnType)) {
-          returnType = getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
-        } else if (contributionType.equals(ContributionType.SET_VALUES)
-            && SetType.isSet(returnType)) {
-          SetType setType = SetType.from(returnType);
-          if (setType.elementsAreTypeOf(ListenableFuture.class)) {
-            returnType =
-                types.getDeclaredType(
-                    getClassElement(Set.class),
-                    setType.unwrappedElementType(ListenableFuture.class));
-          }
-        }
-      }
-      TypeMirror keyType =
-          bindingMethodKeyType(returnType, method, contributionType, frameworkType);
-      Key key = forMethod(method, keyType);
-      return contributionType.equals(ContributionType.UNIQUE)
-          ? key
-          : key.toBuilder()
-              .multibindingContributionIdentifier(
-                  new MultibindingContributionIdentifier(method, contributingModule))
-              .build();
-    }
-
-    /**
-     * Returns the key for a {@link Multibinds @Multibinds} method.
-     *
-     * <p>The key's type is either {@code Set<T>} or {@code Map<K, F<V>>}, where {@code F} is either
-     * {@link Provider} or {@link Producer}, depending on {@code bindingType}.
-     */
-    Key forMultibindsMethod(
-        BindingType bindingType, ExecutableType executableType, ExecutableElement method) {
-      checkArgument(method.getKind().equals(METHOD), "%s must be a method", method);
-      TypeElement factoryType =
-          elements.getTypeElement(bindingType.frameworkClass().getCanonicalName());
-      TypeMirror returnType = executableType.getReturnType();
-      TypeMirror keyType =
-          MapType.isMap(returnType)
-              ? mapOfFrameworkType(
-                  MapType.from(returnType).keyType(),
-                  factoryType,
-                  MapType.from(returnType).valueType())
-              : returnType;
-      return forMethod(method, keyType);
-    }
-
-    private TypeMirror bindingMethodKeyType(
-        TypeMirror returnType,
-        ExecutableElement method,
-        ContributionType contributionType,
-        Optional<TypeElement> frameworkType) {
-      switch (contributionType) {
-        case UNIQUE:
-          return returnType;
-        case SET:
-          return setOf(returnType);
-        case MAP:
-          TypeMirror mapKeyType = mapKeyType(getMapKey(method).get(), types);
-          return frameworkType.isPresent()
-              ? mapOfFrameworkType(mapKeyType, frameworkType.get(), returnType)
-              : mapOf(mapKeyType, returnType);
-        case SET_VALUES:
-          // TODO(gak): do we want to allow people to use "covariant return" here?
-          checkArgument(SetType.isSet(returnType));
-          return returnType;
-        default:
-          throw new AssertionError();
-      }
-    }
-
-    /**
-     * Returns the key for a binding associated with a {@link DelegateDeclaration}.
-     *
-     * If {@code delegateDeclaration} is {@code @IntoMap}, transforms the {@code Map<K, V>} key
-     * from {@link DelegateDeclaration#key()} to {@code Map<K, FrameworkType<V>>}. If {@code
-     * delegateDeclaration} is not a map contribution, its key is returned.
-     */
-    Key forDelegateBinding(
-        DelegateDeclaration delegateDeclaration, Class<?> frameworkType) {
-      return delegateDeclaration.contributionType().equals(ContributionType.MAP)
-          ? wrapMapValue(delegateDeclaration.key(), frameworkType)
-          : delegateDeclaration.key();
-    }
-
-    private Key forMethod(ExecutableElement method, TypeMirror keyType) {
-      return forQualifiedType(getQualifier(method), keyType);
-    }
-
-    Key forInjectConstructorWithResolvedType(TypeMirror type) {
-      return builder(type).build();
-    }
-
-    // TODO(ronshapiro): Remove these conveniences which are simple wrappers around Key.Builder
-    Key forType(TypeMirror type) {
-      return builder(type).build();
-    }
-
-    Key forMembersInjectedType(TypeMirror type) {
-      return builder(type).build();
-    }
-
-    Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-      return builder(boxPrimitives(type)).qualifier(qualifier).build();
-    }
-
-    Key forProductionExecutor() {
-      return builder(getClassElement(Executor.class).asType())
-          .qualifier(getClassElement(Production.class))
-          .build();
-    }
-
-    Key forProductionImplementationExecutor() {
-      return builder(getClassElement(Executor.class).asType())
-          .qualifier(getClassElement(ProductionImplementation.class))
-          .build();
-    }
-
-    Key forProductionComponentMonitor() {
-      return builder(getClassElement(ProductionComponentMonitor.class).asType()).build();
-    }
-
-    /**
-     * If {@code requestKey} is for a {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns keys
-     * for {@code Map<K, Provider<V>>} and {@code Map<K, Producer<V>>} (if Dagger-Producers is on
-     * the classpath).
-     */
-    ImmutableSet<Key> implicitFrameworkMapKeys(Key requestKey) {
-      return Stream.of(
-              implicitMapProviderKeyFrom(requestKey), implicitMapProducerKeyFrom(requestKey))
-          .filter(Optional::isPresent)
-          .map(Optional::get)
-          .collect(toImmutableSet());
-    }
-
-    /**
-     * Optionally extract a {@link Key} for the underlying provision binding(s) if such a valid key
-     * can be inferred from the given key. Specifically, if the key represents a {@link Map}{@code
-     * <K, V>} or {@code Map<K, Producer<V>>}, a key of {@code Map<K, Provider<V>>} will be
-     * returned.
-     */
-    Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
-      return firstPresent(
-          rewrapMapKey(possibleMapKey, Produced.class, Provider.class),
-          wrapMapKey(possibleMapKey, Provider.class));
-    }
-
-    /**
-     * Optionally extract a {@link Key} for the underlying production binding(s) if such a
-     * valid key can be inferred from the given key.  Specifically, if the key represents a
-     * {@link Map}{@code <K, V>} or {@code Map<K, Produced<V>>}, a key of
-     * {@code Map<K, Producer<V>>} will be returned.
-     */
-    Optional<Key> implicitMapProducerKeyFrom(Key possibleMapKey) {
-      return firstPresent(
-          rewrapMapKey(possibleMapKey, Produced.class, Producer.class),
-          wrapMapKey(possibleMapKey, Producer.class));
-    }
-
-    /**
-     * Keys for map contributions from {@link dagger.Provides} and {@link dagger.producers.Produces}
-     * are in the form {@code Map<K, Framework<V>>}, but keys for {@link Binds} methods are just
-     * {@code Map<K, V>} since the framework type is not known until graph resolution. This
-     * translates from the {@code @Provides}/{@code @Produces} format into the {@code @Binds}
-     * format. If {@link Key#type() possibleMapKey.type()} is not a {@code Map<K, Framework<V>>},
-     * returns {@code possibleMapKey}.
-     */
-    Key convertToDelegateKey(Key possibleMapKey) {
-      if (!MapType.isMap(possibleMapKey)) {
-        return possibleMapKey;
-      }
-      MapType mapType = MapType.from(possibleMapKey);
-      TypeMirror wrappedValueType;
-      if (mapType.isRawType()) {
-        return possibleMapKey;
-      } else if (mapType.valuesAreTypeOf(Provider.class)) {
-        wrappedValueType = mapType.unwrappedValueType(Provider.class);
-      } else if (mapType.valuesAreTypeOf(Producer.class)) {
-        wrappedValueType = mapType.unwrappedValueType(Producer.class);
-      } else {
-        return possibleMapKey;
-      }
-      return possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build();
-    }
-
-    /**
-     * Converts a {@link Key} of type {@code Map<K, V>} to {@code Map<K, Provider<V>>}.
-     */
-    private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
-      checkArgument(
-          FrameworkTypes.isFrameworkType(
-              elements.getTypeElement(newWrappingClass.getName()).asType()));
-      return wrapMapKey(key, newWrappingClass).get();
-    }
-
-    /**
-     * If {@code key}'s type is {@code Map<K, CurrentWrappingClass<Bar>>}, returns a key with type
-     * {@code Map<K, NewWrappingClass<Bar>>} with the same qualifier. Otherwise returns {@link
-     * Optional#empty()}.
-     *
-     * <p>Returns {@link Optional#empty()} if {@code newWrappingClass} is not in the classpath.
-     *
-     * @throws IllegalArgumentException if {@code newWrappingClass} is the same as {@code
-     *     currentWrappingClass}
-     */
-    Optional<Key> rewrapMapKey(
-        Key possibleMapKey, Class<?> currentWrappingClass, Class<?> newWrappingClass) {
-      checkArgument(!currentWrappingClass.equals(newWrappingClass));
-      if (MapType.isMap(possibleMapKey)) {
-        MapType mapType = MapType.from(possibleMapKey);
-        if (!mapType.isRawType() && mapType.valuesAreTypeOf(currentWrappingClass)) {
-          TypeElement wrappingElement = getClassElement(newWrappingClass);
-          if (wrappingElement == null) {
-            // This target might not be compiled with Producers, so wrappingClass might not have an
-            // associated element.
-            return Optional.empty();
-          }
-          DeclaredType wrappedValueType =
-              types.getDeclaredType(
-                  wrappingElement, mapType.unwrappedValueType(currentWrappingClass));
-          return Optional.of(
-              possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build());
-        }
-      }
-      return Optional.empty();
-    }
-
-    /**
-     * If {@code key}'s type is {@code Map<K, Foo>} and {@code Foo} is not {@code WrappingClass
-     * <Bar>}, returns a key with type {@code Map<K, WrappingClass<Foo>>} with the same qualifier.
-     * Otherwise returns {@link Optional#empty()}.
-     *
-     * <p>Returns {@link Optional#empty()} if {@code WrappingClass} is not in the classpath.
-     */
-    private Optional<Key> wrapMapKey(Key possibleMapKey, Class<?> wrappingClass) {
-      if (MapType.isMap(possibleMapKey)) {
-        MapType mapType = MapType.from(possibleMapKey);
-        if (!mapType.isRawType() && !mapType.valuesAreTypeOf(wrappingClass)) {
-          TypeElement wrappingElement = getClassElement(wrappingClass);
-          if (wrappingElement == null) {
-            // This target might not be compiled with Producers, so wrappingClass might not have an
-            // associated element.
-            return Optional.empty();
-          }
-          DeclaredType wrappedValueType =
-              types.getDeclaredType(wrappingElement, mapType.valueType());
-          return Optional.of(
-              possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build());
-        }
-      }
-      return Optional.empty();
-    }
-
-    /**
-     * If {@code key}'s type is {@code Set<WrappingClass<Bar>>}, returns a key with type {@code Set
-     * <Bar>} with the same qualifier. Otherwise returns {@link Optional#empty()}.
-     */
-    Optional<Key> unwrapSetKey(Key key, Class<?> wrappingClass) {
-      if (SetType.isSet(key)) {
-        SetType setType = SetType.from(key);
-        if (!setType.isRawType() && setType.elementsAreTypeOf(wrappingClass)) {
-          return Optional.of(
-              key.toBuilder().type(setOf(setType.unwrappedElementType(wrappingClass))).build());
-        }
-      }
-      return Optional.empty();
-    }
-
-    /**
-     * If {@code key}'s type is {@code Optional<T>} for some {@code T}, returns a key with the same
-     * qualifier whose type is {@linkplain DependencyRequest#extractKindAndType(TypeMirror)
-     * extracted} from {@code T}.
-     */
-    Optional<Key> unwrapOptional(Key key) {
-      if (!OptionalType.isOptional(key)) {
-        return Optional.empty();
-      }
-      TypeMirror underlyingType =
-          DependencyRequest.extractKindAndType(OptionalType.from(key).valueType()).type();
-      return Optional.of(key.toBuilder().type(underlyingType).build());
-    }
-
-    /** Returns a key for a {@code @ForReleasableReferences(scope) ReleasableReferenceManager}. */
-    Key forReleasableReferenceManager(Scope scope) {
-      return forQualifiedType(
-          Optional.of(forReleasableReferencesAnnotationMirror(scope)),
-          getClassElement(ReleasableReferenceManager.class).asType());
-    }
-
-    /**
-     * Returns a key for a {@code @ForReleasableReferences(scope)
-     * TypedReleasableReferenceManager<metadataType>}
-     */
-    Key forTypedReleasableReferenceManager(Scope scope, DeclaredType metadataType) {
-      return builder(typedReleasableReferenceManagerOf(metadataType))
-          .qualifier(forReleasableReferencesAnnotationMirror(scope))
-          .build();
-    }
-
-    /** Returns a key for a {@code Set<ReleasableReferenceManager>}. */
-    Key forSetOfReleasableReferenceManagers() {
-      return builder(setOf(getClassElement(ReleasableReferenceManager.class).asType())).build();
-    }
-
-    /** Returns a key for a {@code Set<TypedReleasableReferenceManager<metadataType>}. */
-    Key forSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
-      return forQualifiedType(
-          Optional.empty(), setOf(typedReleasableReferenceManagerOf(metadataType)));
-    }
-
-    private AnnotationMirror forReleasableReferencesAnnotationMirror(Scope scope) {
-      return SimpleAnnotationMirror.of(
-          getClassElement(ForReleasableReferences.class),
-          ImmutableMap.of(
-              "value", new SimpleTypeAnnotationValue(scope.scopeAnnotationElement().asType())));
-    }
-  }
 }
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
new file mode 100644
index 000000000..dc3a1382b
--- /dev/null
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -0,0 +1,475 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asExecutable;
+import static com.google.auto.common.MoreTypes.isType;
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MapKeys.mapKeyType;
+import static dagger.internal.codegen.Optionals.firstPresent;
+import static javax.lang.model.element.ElementKind.METHOD;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Binds;
+import dagger.BindsOptionalOf;
+import dagger.internal.codegen.Key.MultibindingContributionIdentifier;
+import dagger.multibindings.Multibinds;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.Production;
+import dagger.producers.internal.ProductionImplementation;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import java.util.stream.Stream;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/** A factory for {@link Key}s. */
+final class KeyFactory {
+  private final Types types;
+  private final Elements elements;
+
+  KeyFactory(Types types, Elements elements) {
+    this.types = checkNotNull(types);
+    this.elements = checkNotNull(elements);
+  }
+
+  private TypeElement getClassElement(Class<?> cls) {
+    return elements.getTypeElement(cls.getCanonicalName());
+  }
+
+  private TypeMirror boxPrimitives(TypeMirror type) {
+    return type.getKind().isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
+  }
+
+  private DeclaredType setOf(TypeMirror elementType) {
+    return types.getDeclaredType(getClassElement(Set.class), boxPrimitives(elementType));
+  }
+
+  private DeclaredType mapOf(TypeMirror keyType, TypeMirror valueType) {
+    return types.getDeclaredType(
+        getClassElement(Map.class), boxPrimitives(keyType), boxPrimitives(valueType));
+  }
+
+  /** Returns {@code Map<KeyType, FrameworkType<ValueType>>}. */
+  private TypeMirror mapOfFrameworkType(
+      TypeMirror keyType, TypeElement frameworkType, TypeMirror valueType) {
+    return mapOf(keyType, types.getDeclaredType(frameworkType, boxPrimitives(valueType)));
+  }
+
+  private DeclaredType typedReleasableReferenceManagerOf(DeclaredType metadataType) {
+    return types.getDeclaredType(
+        getClassElement(TypedReleasableReferenceManager.class), metadataType);
+  }
+
+  Key forComponentMethod(ExecutableElement componentMethod) {
+    checkArgument(componentMethod.getKind().equals(METHOD));
+    return forMethod(componentMethod, componentMethod.getReturnType());
+  }
+
+  Key forProductionComponentMethod(ExecutableElement componentMethod) {
+    checkArgument(componentMethod.getKind().equals(METHOD));
+    TypeMirror returnType = componentMethod.getReturnType();
+    TypeMirror keyType =
+        isTypeOf(ListenableFuture.class, returnType)
+            ? getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments())
+            : returnType;
+    return forMethod(componentMethod, keyType);
+  }
+
+  Key forSubcomponentBuilderMethod(
+      ExecutableElement subcomponentBuilderMethod, DeclaredType declaredContainer) {
+    checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
+    ExecutableType resolvedMethod =
+        asExecutable(types.asMemberOf(declaredContainer, subcomponentBuilderMethod));
+    return Key.builder(resolvedMethod.getReturnType()).build();
+  }
+
+  Key forSubcomponentBuilder(TypeMirror builderType) {
+    return Key.builder(builderType).build();
+  }
+
+  Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
+    return forBindingMethod(
+        method, contributingModule, Optional.of(getClassElement(Provider.class)));
+  }
+
+  Key forProducesMethod(ExecutableElement method, TypeElement contributingModule) {
+    return forBindingMethod(
+        method, contributingModule, Optional.of(getClassElement(Producer.class)));
+  }
+
+  /** Returns the key bound by a {@link Binds} method. */
+  Key forBindsMethod(ExecutableElement method, TypeElement contributingModule) {
+    checkArgument(isAnnotationPresent(method, Binds.class));
+    return forBindingMethod(method, contributingModule, Optional.empty());
+  }
+
+  /** Returns the base key bound by a {@link BindsOptionalOf} method. */
+  Key forBindsOptionalOfMethod(ExecutableElement method, TypeElement contributingModule) {
+    checkArgument(isAnnotationPresent(method, BindsOptionalOf.class));
+    return forBindingMethod(method, contributingModule, Optional.empty());
+  }
+
+  private Key forBindingMethod(
+      ExecutableElement method,
+      TypeElement contributingModule,
+      Optional<TypeElement> frameworkType) {
+    checkArgument(method.getKind().equals(METHOD));
+    ExecutableType methodType =
+        MoreTypes.asExecutable(
+            types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), method));
+    ContributionType contributionType = ContributionType.fromBindingMethod(method);
+    TypeMirror returnType = methodType.getReturnType();
+    if (frameworkType.isPresent()
+        && frameworkType.get().equals(getClassElement(Producer.class))
+        && isType(returnType)) {
+      if (isTypeOf(ListenableFuture.class, returnType)) {
+        returnType = getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+      } else if (contributionType.equals(ContributionType.SET_VALUES)
+          && SetType.isSet(returnType)) {
+        SetType setType = SetType.from(returnType);
+        if (setType.elementsAreTypeOf(ListenableFuture.class)) {
+          returnType =
+              types.getDeclaredType(
+                  getClassElement(Set.class), setType.unwrappedElementType(ListenableFuture.class));
+        }
+      }
+    }
+    TypeMirror keyType = bindingMethodKeyType(returnType, method, contributionType, frameworkType);
+    Key key = forMethod(method, keyType);
+    return contributionType.equals(ContributionType.UNIQUE)
+        ? key
+        : key.toBuilder()
+            .multibindingContributionIdentifier(
+                new MultibindingContributionIdentifier(method, contributingModule))
+            .build();
+  }
+
+  /**
+   * Returns the key for a {@link Multibinds @Multibinds} method.
+   *
+   * <p>The key's type is either {@code Set<T>} or {@code Map<K, F<V>>}, where {@code F} is either
+   * {@link Provider} or {@link Producer}, depending on {@code bindingType}.
+   */
+  Key forMultibindsMethod(
+      BindingType bindingType, ExecutableType executableType, ExecutableElement method) {
+    checkArgument(method.getKind().equals(METHOD), "%s must be a method", method);
+    TypeElement factoryType =
+        elements.getTypeElement(bindingType.frameworkClass().getCanonicalName());
+    TypeMirror returnType = executableType.getReturnType();
+    TypeMirror keyType =
+        MapType.isMap(returnType)
+            ? mapOfFrameworkType(
+                MapType.from(returnType).keyType(),
+                factoryType,
+                MapType.from(returnType).valueType())
+            : returnType;
+    return forMethod(method, keyType);
+  }
+
+  private TypeMirror bindingMethodKeyType(
+      TypeMirror returnType,
+      ExecutableElement method,
+      ContributionType contributionType,
+      Optional<TypeElement> frameworkType) {
+    switch (contributionType) {
+      case UNIQUE:
+        return returnType;
+      case SET:
+        return setOf(returnType);
+      case MAP:
+        TypeMirror mapKeyType = mapKeyType(getMapKey(method).get(), types);
+        return frameworkType.isPresent()
+            ? mapOfFrameworkType(mapKeyType, frameworkType.get(), returnType)
+            : mapOf(mapKeyType, returnType);
+      case SET_VALUES:
+        // TODO(gak): do we want to allow people to use "covariant return" here?
+        checkArgument(SetType.isSet(returnType));
+        return returnType;
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  /**
+   * Returns the key for a binding associated with a {@link DelegateDeclaration}.
+   *
+   * If {@code delegateDeclaration} is {@code @IntoMap}, transforms the {@code Map<K, V>} key
+   * from {@link DelegateDeclaration#key()} to {@code Map<K, FrameworkType<V>>}. If {@code
+   * delegateDeclaration} is not a map contribution, its key is returned.
+   */
+  Key forDelegateBinding(DelegateDeclaration delegateDeclaration, Class<?> frameworkType) {
+    return delegateDeclaration.contributionType().equals(ContributionType.MAP)
+        ? wrapMapValue(delegateDeclaration.key(), frameworkType)
+        : delegateDeclaration.key();
+  }
+
+  private Key forMethod(ExecutableElement method, TypeMirror keyType) {
+    return forQualifiedType(getQualifier(method), keyType);
+  }
+
+  Key forInjectConstructorWithResolvedType(TypeMirror type) {
+    return Key.builder(type).build();
+  }
+
+  // TODO(ronshapiro): Remove these conveniences which are simple wrappers around Key.Builder
+  Key forType(TypeMirror type) {
+    return Key.builder(type).build();
+  }
+
+  Key forMembersInjectedType(TypeMirror type) {
+    return Key.builder(type).build();
+  }
+
+  Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
+    return Key.builder(boxPrimitives(type)).qualifier(qualifier).build();
+  }
+
+  Key forProductionExecutor() {
+    return Key.builder(getClassElement(Executor.class).asType())
+        .qualifier(getClassElement(Production.class))
+        .build();
+  }
+
+  Key forProductionImplementationExecutor() {
+    return Key.builder(getClassElement(Executor.class).asType())
+        .qualifier(getClassElement(ProductionImplementation.class))
+        .build();
+  }
+
+  Key forProductionComponentMonitor() {
+    return Key.builder(getClassElement(ProductionComponentMonitor.class).asType()).build();
+  }
+
+  /**
+   * If {@code requestKey} is for a {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns keys
+   * for {@code Map<K, Provider<V>>} and {@code Map<K, Producer<V>>} (if Dagger-Producers is on
+   * the classpath).
+   */
+  ImmutableSet<Key> implicitFrameworkMapKeys(Key requestKey) {
+    return Stream.of(implicitMapProviderKeyFrom(requestKey), implicitMapProducerKeyFrom(requestKey))
+        .filter(Optional::isPresent)
+        .map(Optional::get)
+        .collect(toImmutableSet());
+  }
+
+  /**
+   * Optionally extract a {@link Key} for the underlying provision binding(s) if such a valid key
+   * can be inferred from the given key. Specifically, if the key represents a {@link Map}{@code
+   * <K, V>} or {@code Map<K, Producer<V>>}, a key of {@code Map<K, Provider<V>>} will be
+   * returned.
+   */
+  Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
+    return firstPresent(
+        rewrapMapKey(possibleMapKey, Produced.class, Provider.class),
+        wrapMapKey(possibleMapKey, Provider.class));
+  }
+
+  /**
+   * Optionally extract a {@link Key} for the underlying production binding(s) if such a
+   * valid key can be inferred from the given key.  Specifically, if the key represents a
+   * {@link Map}{@code <K, V>} or {@code Map<K, Produced<V>>}, a key of
+   * {@code Map<K, Producer<V>>} will be returned.
+   */
+  Optional<Key> implicitMapProducerKeyFrom(Key possibleMapKey) {
+    return firstPresent(
+        rewrapMapKey(possibleMapKey, Produced.class, Producer.class),
+        wrapMapKey(possibleMapKey, Producer.class));
+  }
+
+  /**
+   * Keys for map contributions from {@link dagger.Provides} and {@link dagger.producers.Produces}
+   * are in the form {@code Map<K, Framework<V>>}, but keys for {@link Binds} methods are just
+   * {@code Map<K, V>} since the framework type is not known until graph resolution. This
+   * translates from the {@code @Provides}/{@code @Produces} format into the {@code @Binds}
+   * format. If {@link Key#type() possibleMapKey.type()} is not a {@code Map<K, Framework<V>>},
+   * returns {@code possibleMapKey}.
+   */
+  Key convertToDelegateKey(Key possibleMapKey) {
+    if (!MapType.isMap(possibleMapKey)) {
+      return possibleMapKey;
+    }
+    MapType mapType = MapType.from(possibleMapKey);
+    TypeMirror wrappedValueType;
+    if (mapType.isRawType()) {
+      return possibleMapKey;
+    } else if (mapType.valuesAreTypeOf(Provider.class)) {
+      wrappedValueType = mapType.unwrappedValueType(Provider.class);
+    } else if (mapType.valuesAreTypeOf(Producer.class)) {
+      wrappedValueType = mapType.unwrappedValueType(Producer.class);
+    } else {
+      return possibleMapKey;
+    }
+    return possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build();
+  }
+
+  /**
+   * Converts a {@link Key} of type {@code Map<K, V>} to {@code Map<K, Provider<V>>}.
+   */
+  private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
+    checkArgument(
+        FrameworkTypes.isFrameworkType(
+            elements.getTypeElement(newWrappingClass.getName()).asType()));
+    return wrapMapKey(key, newWrappingClass).get();
+  }
+
+  /**
+   * If {@code key}'s type is {@code Map<K, CurrentWrappingClass<Bar>>}, returns a key with type
+   * {@code Map<K, NewWrappingClass<Bar>>} with the same qualifier. Otherwise returns {@link
+   * Optional#empty()}.
+   *
+   * <p>Returns {@link Optional#empty()} if {@code newWrappingClass} is not in the classpath.
+   *
+   * @throws IllegalArgumentException if {@code newWrappingClass} is the same as {@code
+   *     currentWrappingClass}
+   */
+  Optional<Key> rewrapMapKey(
+      Key possibleMapKey, Class<?> currentWrappingClass, Class<?> newWrappingClass) {
+    checkArgument(!currentWrappingClass.equals(newWrappingClass));
+    if (MapType.isMap(possibleMapKey)) {
+      MapType mapType = MapType.from(possibleMapKey);
+      if (!mapType.isRawType() && mapType.valuesAreTypeOf(currentWrappingClass)) {
+        TypeElement wrappingElement = getClassElement(newWrappingClass);
+        if (wrappingElement == null) {
+          // This target might not be compiled with Producers, so wrappingClass might not have an
+          // associated element.
+          return Optional.empty();
+        }
+        DeclaredType wrappedValueType =
+            types.getDeclaredType(
+                wrappingElement, mapType.unwrappedValueType(currentWrappingClass));
+        return Optional.of(
+            possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build());
+      }
+    }
+    return Optional.empty();
+  }
+
+  /**
+   * If {@code key}'s type is {@code Map<K, Foo>} and {@code Foo} is not {@code WrappingClass
+   * <Bar>}, returns a key with type {@code Map<K, WrappingClass<Foo>>} with the same qualifier.
+   * Otherwise returns {@link Optional#empty()}.
+   *
+   * <p>Returns {@link Optional#empty()} if {@code WrappingClass} is not in the classpath.
+   */
+  private Optional<Key> wrapMapKey(Key possibleMapKey, Class<?> wrappingClass) {
+    if (MapType.isMap(possibleMapKey)) {
+      MapType mapType = MapType.from(possibleMapKey);
+      if (!mapType.isRawType() && !mapType.valuesAreTypeOf(wrappingClass)) {
+        TypeElement wrappingElement = getClassElement(wrappingClass);
+        if (wrappingElement == null) {
+          // This target might not be compiled with Producers, so wrappingClass might not have an
+          // associated element.
+          return Optional.empty();
+        }
+        DeclaredType wrappedValueType = types.getDeclaredType(wrappingElement, mapType.valueType());
+        return Optional.of(
+            possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build());
+      }
+    }
+    return Optional.empty();
+  }
+
+  /**
+   * If {@code key}'s type is {@code Set<WrappingClass<Bar>>}, returns a key with type {@code Set
+   * <Bar>} with the same qualifier. Otherwise returns {@link Optional#empty()}.
+   */
+  Optional<Key> unwrapSetKey(Key key, Class<?> wrappingClass) {
+    if (SetType.isSet(key)) {
+      SetType setType = SetType.from(key);
+      if (!setType.isRawType() && setType.elementsAreTypeOf(wrappingClass)) {
+        return Optional.of(
+            key.toBuilder().type(setOf(setType.unwrappedElementType(wrappingClass))).build());
+      }
+    }
+    return Optional.empty();
+  }
+
+  /**
+   * If {@code key}'s type is {@code Optional<T>} for some {@code T}, returns a key with the same
+   * qualifier whose type is {@linkplain DependencyRequest#extractKindAndType(TypeMirror)
+   * extracted} from {@code T}.
+   */
+  Optional<Key> unwrapOptional(Key key) {
+    if (!OptionalType.isOptional(key)) {
+      return Optional.empty();
+    }
+    TypeMirror underlyingType =
+        DependencyRequest.extractKindAndType(OptionalType.from(key).valueType()).type();
+    return Optional.of(key.toBuilder().type(underlyingType).build());
+  }
+
+  /** Returns a key for a {@code @ForReleasableReferences(scope) ReleasableReferenceManager}. */
+  Key forReleasableReferenceManager(Scope scope) {
+    return forQualifiedType(
+        Optional.of(forReleasableReferencesAnnotationMirror(scope)),
+        getClassElement(ReleasableReferenceManager.class).asType());
+  }
+
+  /**
+   * Returns a key for a {@code @ForReleasableReferences(scope)
+   * TypedReleasableReferenceManager<metadataType>}
+   */
+  Key forTypedReleasableReferenceManager(Scope scope, DeclaredType metadataType) {
+    return Key.builder(typedReleasableReferenceManagerOf(metadataType))
+        .qualifier(forReleasableReferencesAnnotationMirror(scope))
+        .build();
+  }
+
+  /** Returns a key for a {@code Set<ReleasableReferenceManager>}. */
+  Key forSetOfReleasableReferenceManagers() {
+    return Key.builder(setOf(getClassElement(ReleasableReferenceManager.class).asType())).build();
+  }
+
+  /** Returns a key for a {@code Set<TypedReleasableReferenceManager<metadataType>}. */
+  Key forSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
+    return forQualifiedType(
+        Optional.empty(), setOf(typedReleasableReferenceManagerOf(metadataType)));
+  }
+
+  private AnnotationMirror forReleasableReferencesAnnotationMirror(Scope scope) {
+    return SimpleAnnotationMirror.of(
+        getClassElement(ForReleasableReferences.class),
+        ImmutableMap.of(
+            "value", new SimpleTypeAnnotationValue(scope.scopeAnnotationElement().asType())));
+  }
+}
diff --git a/java/dagger/internal/codegen/MembersInjectionBinding.java b/java/dagger/internal/codegen/MembersInjectionBinding.java
index af5258037..3dd9dd496 100644
--- a/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -141,13 +141,13 @@ int indexAmongAtInjectMembersWithSameSimpleName() {
   static final class Factory {
     private final Elements elements;
     private final DaggerTypes types;
-    private final Key.Factory keyFactory;
+    private final KeyFactory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
     Factory(
         Elements elements,
         DaggerTypes types,
-        Key.Factory keyFactory,
+        KeyFactory keyFactory,
         DependencyRequest.Factory dependencyRequestFactory) {
       this.elements = checkNotNull(elements);
       this.types = checkNotNull(types);
diff --git a/java/dagger/internal/codegen/MultibindingDeclaration.java b/java/dagger/internal/codegen/MultibindingDeclaration.java
index 10c5a1e6f..c35d8cff9 100644
--- a/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -77,14 +77,12 @@
   static final class Factory {
     private final Elements elements;
     private final Types types;
-    private final Key.Factory keyFactory;
-    private final TypeElement objectElement;
+    private final KeyFactory keyFactory;
 
-    Factory(Elements elements, Types types, Key.Factory keyFactory) {
+    Factory(Elements elements, Types types, KeyFactory keyFactory) {
       this.elements = elements;
       this.types = types;
       this.keyFactory = keyFactory;
-      this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
     }
 
     /** A multibinding declaration for a {@link Multibinds @Multibinds} method. */
diff --git a/java/dagger/internal/codegen/OptionalBindingDeclaration.java b/java/dagger/internal/codegen/OptionalBindingDeclaration.java
index 357e621d7..08897ab39 100644
--- a/java/dagger/internal/codegen/OptionalBindingDeclaration.java
+++ b/java/dagger/internal/codegen/OptionalBindingDeclaration.java
@@ -40,9 +40,9 @@
   public abstract Key key();
 
   static class Factory {
-    private final Key.Factory keyFactory;
+    private final KeyFactory keyFactory;
 
-    Factory(Key.Factory keyFactory) {
+    Factory(KeyFactory keyFactory) {
       this.keyFactory = keyFactory;
     }
 
diff --git a/java/dagger/internal/codegen/ProductionBinding.java b/java/dagger/internal/codegen/ProductionBinding.java
index e85cadeb9..7974f7db5 100644
--- a/java/dagger/internal/codegen/ProductionBinding.java
+++ b/java/dagger/internal/codegen/ProductionBinding.java
@@ -127,11 +127,11 @@ private static Builder builder() {
 
   static final class Factory {
     private final Types types;
-    private final Key.Factory keyFactory;
+    private final KeyFactory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
     Factory(
-        Types types, Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
+        Types types, KeyFactory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
       this.types = types;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index cd687ef72..08cdabaa8 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -132,13 +132,13 @@ boolean shouldCheckForNull(CompilerOptions compilerOptions) {
 
   static final class Factory {
     private final Types types;
-    private final Key.Factory keyFactory;
+    private final KeyFactory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
     private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
 
     Factory(
         Types types,
-        Key.Factory keyFactory,
+        KeyFactory keyFactory,
         DependencyRequest.Factory dependencyRequestFactory,
         MembersInjectionBinding.Factory membersInjectionBindingFactory) {
       this.types = types;
diff --git a/java/dagger/internal/codegen/SubcomponentDeclaration.java b/java/dagger/internal/codegen/SubcomponentDeclaration.java
index 6de7c5956..5c6832ae3 100644
--- a/java/dagger/internal/codegen/SubcomponentDeclaration.java
+++ b/java/dagger/internal/codegen/SubcomponentDeclaration.java
@@ -54,9 +54,9 @@
   abstract AnnotationMirror moduleAnnotation();
 
   static class Factory {
-    private final Key.Factory keyFactory;
+    private final KeyFactory keyFactory;
 
-    public Factory(Key.Factory keyFactory) {
+    public Factory(KeyFactory keyFactory) {
       this.keyFactory = keyFactory;
     }
 
diff --git a/javatests/dagger/internal/codegen/KeyTest.java b/javatests/dagger/internal/codegen/KeyTest.java
index 930a52183..42e6fd66c 100644
--- a/javatests/dagger/internal/codegen/KeyTest.java
+++ b/javatests/dagger/internal/codegen/KeyTest.java
@@ -55,12 +55,12 @@
 
   private Elements elements;
   private Types types;
-  private Key.Factory keyFactory;
+  private KeyFactory keyFactory;
 
   @Before public void setUp() {
     this.types = compilationRule.getTypes();
     this.elements = compilationRule.getElements();
-    this.keyFactory = new Key.Factory(types, elements);
+    this.keyFactory = new KeyFactory(types, elements);
   }
 
   @Test public void forInjectConstructorWithResolvedType() {
