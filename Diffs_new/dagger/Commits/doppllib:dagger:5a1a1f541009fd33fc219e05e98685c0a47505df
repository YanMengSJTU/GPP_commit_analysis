diff --git a/core/build.gradle b/core/build.gradle
index 8e9dec973..1a7751f87 100644
--- a/core/build.gradle
+++ b/core/build.gradle
@@ -26,8 +26,8 @@ apply plugin: 'co.doppl.gradle'
 apply plugin: 'maven-publish'
 apply plugin: 'net.ltgt.apt'
 
-sourceCompatibility = 1.7
-targetCompatibility = 1.7
+sourceCompatibility = 1.8
+targetCompatibility = 1.8
 
 def javaCoreVersion = doppl_core_java
 def dopplCoreVersion = doppl_core_doppl
@@ -50,6 +50,10 @@ dependencies {
 
     compile 'javax.inject:javax.inject:1'
     testCompile 'com.google.guava:guava:19.0'
+
+//    testCompile "com.google.auto.value:auto-value:1.5"
+//    testApt         "com.google.auto.value:auto-value:1.5"
+    testApt "com.google.dagger:dagger-compiler:$doppl_dagger_java"
 }
 
 group = 'co.doppl.com.google.dagger'
@@ -65,7 +69,7 @@ test{
 }
 
 dopplConfig {
-
+    javaDebug true
 }
 
 task runIOSTests(type:Exec, dependsOn: 'dopplBuild') {
diff --git a/core/gradle.properties b/core/gradle.properties
index 92a4439e7..28c81fae6 100644
--- a/core/gradle.properties
+++ b/core/gradle.properties
@@ -1,8 +1,8 @@
 #Sun Dec 10 15:09:02 EST 2017
 doppl_core_doppl=0.8.8.0
 doppl_core_java=0.8.8
-doppl_dagger_doppl=2.5.7
-doppl_dagger_java=2.5
+doppl_dagger_doppl=2.14.1.0
+doppl_dagger_java=2.14.1
 doppl_gradle=0.10.7
 doppl_junit_doppl=4.12.0
 doppl_junit_java=4.12
diff --git a/core/src/main/java/dagger/Binds.java b/core/src/main/java/dagger/Binds.java
index 4bdb3e2ba..848619fb7 100644
--- a/core/src/main/java/dagger/Binds.java
+++ b/core/src/main/java/dagger/Binds.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,31 +13,52 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * Annotates <em>abstract</em> methods of a {@link Module} that delegate bindings. For example, to
  * bind {@link java.util.Random} to {@link java.security.SecureRandom} a module could declare the
  * following: {@code @Binds abstract Random bindRandom(SecureRandom secureRandom);}
  *
  * <p>{@code @Binds} methods are a drop-in replacement for {@link Provides} methods that simply
- * return an injected parameter.  Prefer {@code @Binds} because the generated implementation is
+ * return an injected parameter. Prefer {@code @Binds} because the generated implementation is
  * likely to be more efficient.
  *
  * <p>A {@code @Binds} method:
+ *
  * <ul>
- * <li>Must be {@code abstract}.
- * <li>Must have a single parameter whose type is assignable to the return type.  The return type is
- * the bound type and the parameter is the type to which it is bound.
- * <li>May be {@linkplain javax.inject.Scope scoped}.
- * <li>May be {@linkplain javax.inject.Qualifier qualified}.
+ *   <li>Must be {@code abstract}.
+ *   <li>May be {@linkplain javax.inject.Scope scoped}.
+ *   <li>May be {@linkplain javax.inject.Qualifier qualified}.
+ *   <li>Must have a single parameter whose type is assignable to the return type. The return type
+ *       declares the bound type (just as it would for a {@literal @}{@link dagger.Provides} method)
+ *       and the parameter is the type to which it is bound.
+ *       <p>For {@linkplain dagger.multibindings multibindings}, assignability is checked in similar
+ *       ways:
+ *       <dl>
+ *         <dt>{@link dagger.multibindings.IntoSet}
+ *         <dd>The parameter must be assignable to the only parameter of {@link java.util.Set#add}
+ *             when viewed as a member of the return type — the parameter must be assignable to the
+ *             return type.
+ *         <dt>{@link dagger.multibindings.ElementsIntoSet}
+ *         <dd>The parameter must be assignable to the the only parameter of {@link
+ *             java.util.Set#addAll} when viewed as a member of the return type — if the return type
+ *             is {@code Set<E>}, the parameter must be assignable to
+ *            {@code Collection<? extends E>}.
+ *         <dt>{@link dagger.multibindings.IntoMap}
+ *         <dd>The parameter must be assignable to the {@code value} parameter of {@link
+ *             java.util.Map#put} when viewed as a member of a {@link java.util.Map} in which {@code
+ *             V} is bound to the return type — the parameter must be assignable to the return type
+ *       </dl>
+ *
  * </ul>
  */
 @Documented
diff --git a/core/src/main/java/dagger/BindsInstance.java b/core/src/main/java/dagger/BindsInstance.java
new file mode 100644
index 000000000..cd87db8a8
--- /dev/null
+++ b/core/src/main/java/dagger/BindsInstance.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * Marks a method on a component builder or subcomponent builder that allows an instance to be bound
+ * to some type within the component.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   {@literal @Component.Builder}
+ *   interface Builder {
+ *     {@literal @BindsInstance} Builder foo(Foo foo);
+ *     {@literal @BindsInstance} Builder bar({@literal @Blue} Bar bar);
+ *     ...
+ *   }
+ * </pre>
+ *
+ * <p>will allow clients of this builder to pass their own instances of {@code Foo} and {@code Bar},
+ * and those instances can be injected within the component as {@code Foo} or {@code @Blue Bar},
+ * respectively.
+ *
+ * <p>{@code @BindsInstance} methods may not be passed null arguments unless the parameter is
+ * annotated with {@code @Nullable}; in that case, both null and non-null arguments may be passed to
+ * the method.
+ *
+ * <p>{@code @BindsInstance} methods must be called before building the component, unless their
+ * parameter is marked {@code @Nullable}, in which case the component will act as though it was
+ * called with a null argument. Primitives, of course, may not be marked {@code @Nullable}.
+ *
+ * <p>Binding an instance is equivalent to passing an instance to a module constructor and providing
+ * that instance, but is often more efficient. When possible, binding object instances should be
+ * preferred to using module instances.
+ */
+@Documented
+@Retention(RUNTIME)
+@Target(METHOD)
+@Beta
+public @interface BindsInstance {}
diff --git a/core/src/main/java/dagger/BindsOptionalOf.java b/core/src/main/java/dagger/BindsOptionalOf.java
new file mode 100644
index 000000000..9a356ffeb
--- /dev/null
+++ b/core/src/main/java/dagger/BindsOptionalOf.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+
+/**
+ * Annotates methods that declare bindings for {@code Optional} containers of values from bindings
+ * that may or may not be present in the component.
+ *
+ * <p>If a module contains a method declaration like this:
+ *
+ * <pre>
+ * {@literal @BindsOptionalOf} abstract Foo optionalFoo();</pre>
+ *
+ * then any binding in the component can depend on an {@code Optional} of {@code Foo}. If there is
+ * no binding for {@code Foo} in the component, the {@code Optional} will be absent. If there is a
+ * binding for {@code Foo} in the component, the {@code Optional} will be present, and its value
+ * will be the value given by the binding for {@code Foo}.
+ *
+ * <p>A {@code @BindsOptionalOf} method:
+ *
+ * <ul>
+ *   <li>must be {@code abstract}
+ *   <li>may have a {@linkplain Qualifier qualifier} annotation
+ *   <li>must not return {@code void}
+ *   <li>must not have parameters
+ *   <li>must not throw exceptions
+ *   <li>must not return an unqualified type with an {@link Inject @Inject}-annotated constructor,
+ *       since such a type is always present
+ * </ul>
+ *
+ * <p>Other bindings may inject any of:
+ *
+ * <ul>
+ *   <li>{@code Optional<Foo>} (unless there is a {@code @Nullable} binding for {@code Foo}; see
+ *       below)
+ *   <li>{@code Optional<Provider<Foo>>}
+ *   <li>{@code Optional<Lazy<Foo>>}
+ *   <li>{@code Optional<Provider<Lazy<Foo>>>}
+ * </ul>
+ *
+ * <p>If there is a binding for {@code Foo}, and that binding is {@code @Nullable}, then it is a
+ * compile-time error to inject {@code Optional<Foo>}, because {@code Optional} cannot contain
+ * {@code null}. You can always inject the other forms, because {@link Provider} and {@link Lazy}
+ * can always return {@code null} from their {@code get()} methods.
+ *
+ * <p>Explicit bindings for any of the above will conflict with a {@code @BindsOptionalOf} binding.
+ *
+ * <p>If the binding for {@code Foo} is a {@code @Produces} binding, then another {@code @Produces}
+ * binding can depend on any of:
+ *
+ * <ul>
+ *   <li>{@code Optional<Foo>}
+ *       <!-- TODO(dpb): Update this once producers support nullability checks -->
+ *   <li>{@code Optional<Producer<Foo>>}
+ *   <li>{@code Optional<Produced<Foo>>}
+ * </ul>
+ *
+ * <p>You can inject either {@code com.google.common.base.Optional} or {@code java.util.Optional}.
+ */
+@Documented
+@Beta
+@Retention(RUNTIME)
+@Target(METHOD)
+public @interface BindsOptionalOf {}
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index 452edb8a4..25abeda8d 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -24,9 +28,6 @@
 import javax.inject.Scope;
 import javax.inject.Singleton;
 
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * Annotates an interface or abstract class for which a fully-formed, dependency-injected
  * implementation is to be generated from a set of {@linkplain #modules}. The generated class will
@@ -170,9 +171,13 @@
  * inherit the <em>entire</em> binding graph from its parent when it is declared. For that reason,
  * a subcomponent isn't evaluated for completeness until it is associated with a parent.
  *
- * <p>Subcomponents are declared via a factory method on a parent component or subcomponent. The
- * method may have any name, but must return the subcomponent. The factory method's parameters may
- * be any number of the subcomponent's modules, but must at least include those without visible
+ * <p>Subcomponents are declared by listing the class in the {@link Module#subcomponents()}
+ * attribute of one of the parent component's modules. This binds the {@link Subcomponent.Builder}
+ * within the parent component.
+ *
+ * <p>Subcomponents may also be declared via a factory method on a parent component or subcomponent.
+ * The method may have any name, but must return the subcomponent. The factory method's parameters
+ * may be any number of the subcomponent's modules, but must at least include those without visible
  * no-arg constructors. The following is an example of a factory method that creates a
  * request-scoped subcomponent from a singleton-scoped parent: <pre><code>
  *   {@literal @}Singleton {@literal @}Component
diff --git a/core/src/main/java/dagger/Lazy.java b/core/src/main/java/dagger/Lazy.java
index 075c5f405..d4408fa78 100644
--- a/core/src/main/java/dagger/Lazy.java
+++ b/core/src/main/java/dagger/Lazy.java
@@ -1,6 +1,5 @@
 /*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,13 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
 /**
  * A handle to a lazily-computed value. Each {@code Lazy} computes its value on
- * the first call to {@code get()} and remembers that same value for all
+ * the first call to {@link #get()} and remembers that same value for all
  * subsequent calls to {@code get()}.
  *
+ * <p>All implementations are expected to be thread-safe and compute their value at most once.
+ *
  * <h2>Example</h2>
  * The differences between <strong>direct injection</strong>, <strong>provider
  * injection</strong> and <strong>lazy injection</strong> are best demonstrated
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index e41829e1e..89307be15 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,21 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
-import dagger.internal.Beta;
+import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.util.Map;
 
-import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
- * Identifies annotation types that are used to associate keys with values returned by
- * {@linkplain Provides provider methods} in order to compose a {@linkplain
- * dagger.multibindings.IntoMap map}.
+ * Identifies annotation types that are used to associate keys with values returned by {@linkplain
+ * Provides provider methods} in order to compose a {@linkplain dagger.multibindings.IntoMap map}.
  *
  * <p>Every provider method annotated with {@code @Provides} and {@code @IntoMap} must also have an
  * annotation that identifies the key for that map entry. That annotation's type must be annotated
@@ -35,8 +34,8 @@
  *
  * <p>Typically, the key annotation has a single member, whose value is used as the map key.
  *
- * <p>For example, to add an entry to a {@code Map<SomeEnum, Integer>} with key
- * {@code SomeEnum.FOO}, you could use an annotation called {@code @SomeEnumKey}:
+ * <p>For example, to add an entry to a {@code Map<SomeEnum, Integer>} with key {@code
+ * SomeEnum.FOO}, you could use an annotation called {@code @SomeEnumKey}:
  *
  * <pre><code>
  * {@literal @}MapKey
@@ -64,7 +63,7 @@
  *
  * <p>If {@code unwrapValue} is true, the annotation's single member can be any type except an
  * array.
- * 
+ *
  * <p>See {@link dagger.multibindings} for standard unwrapped map key annotations for keys that are
  * boxed primitives, strings, or classes.
  *
@@ -101,13 +100,11 @@
  * <p>(Note that there must be a class {@code MyMapKeyImpl} that implements {@code MyMapKey} in
  * order to call {@link Map#get(Object)} on the provided map.)
  *
- * @see <a href="http://google.github.io/dagger/multibindings#map-multibindings">Map
- *      multibinding</a>
+ * @see <a href="https://google.github.io/dagger/multibindings#map-multibindings">Map multibinding</a>
  */
 @Documented
 @Target(ANNOTATION_TYPE)
 @Retention(RUNTIME)
-@Beta
 public @interface MapKey {
   /**
    * True to use the value of the single member of the annotated annotation as the map key; false
diff --git a/core/src/main/java/dagger/MembersInjector.java b/core/src/main/java/dagger/MembersInjector.java
index d0de7f396..9fb7d26b2 100644
--- a/core/src/main/java/dagger/MembersInjector.java
+++ b/core/src/main/java/dagger/MembersInjector.java
@@ -1,6 +1,5 @@
 /*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2009 Google Inc.
+ * Copyright (C) 2012 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
 /**
@@ -33,9 +33,9 @@
    * Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
    * absence of an injectable constructor.
    *
-   * <p>Whenever the object graph creates an instance, it performs this injection automatically
-   * (after first performing constructor injection), so if you're able to let the object graph
-   * create all your objects for you, you'll never need to use this method.
+   * <p>Whenever a {@link Component} creates an instance, it performs this injection automatically
+   * (after first performing constructor injection), so if you're able to let the component create
+   * all your objects for you, you'll never need to use this method.
    *
    * @param instance into which members are to be injected
    * @throws NullPointerException if {@code instance} is {@code null}
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 05f0f3a6a..862be7aed 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
+import dagger.internal.Beta;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -33,4 +35,14 @@
    * to the object graph.
    */
   Class<?>[] includes() default {};
+
+  /**
+   * Any {@link Subcomponent}- or {@code @ProductionSubcomponent}-annotated classes which should be
+   * children of the component in which this module is installed. A subcomponent may be listed in
+   * more than one module in a component.
+   *
+   * @since 2.7
+   */
+  @Beta
+  Class<?>[] subcomponents() default {};
 }
diff --git a/core/src/main/java/dagger/Multibindings.java b/core/src/main/java/dagger/Multibindings.java
deleted file mode 100644
index b83324df5..000000000
--- a/core/src/main/java/dagger/Multibindings.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-import static java.lang.annotation.ElementType.TYPE;
-
-/**
- * Annotates interfaces that declare multibindings.
- *
- * <p>You can declare that a multibound set or map is bound by nesting a
- * {@code @Multibindings}-annotated interface within a module, with methods that return the sets or
- * maps you want to declare.
- *
- * <p>You do not have to use {@code @Multibindings} for sets or maps that have at least one
- * contribution, but you do have to declare them if they may be empty.
- *
- * <pre><code>
- * {@literal @Module}
- * class MyModule {
- *   {@literal @Multibindings}
- *   interface MyMultibindings {
- *     {@literal Set<Foo>} aSet();
- *     {@literal @MyQualifier Set<Foo>} aQualifiedSet();
- *     {@literal Map<String, Foo>} aMap();
- *     {@literal @MyQualifier Map<String, Foo>} aQualifiedMap();
- *   }
- *
- *   {@literal @Provides}
- *   static Object usesMultibindings(
- *       {@literal Set<Foo>} set, {@literal @MyQualifier Map<String, Foo>} map) {
- *     return …
- *   }
- * }
- * </code></pre>
- *
- * <p>All methods on the interface and any supertypes (except for methods on {@link Object}) are
- * used to declare multibindings. The names of the interface and its methods are ignored. A given
- * set or map multibinding can be declared any number of times without error. Dagger never
- * implements the interface or calls any of its methods.
- *
- * @see <a href="http://google.github.io/dagger/multibindings">Multibindings</a>
- */
-@Documented
-@Target(TYPE)
-@Beta
-public @interface Multibindings {}
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index 7be82c012..de204557b 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -1,6 +1,5 @@
 /*
- * Copyright (C) 2007 Google Inc.
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2007 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,16 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
-import dagger.internal.Beta;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * Annotates methods of a {@linkplain Module module} to create a provider method binding. The
  * method's return type is bound to its returned value. The {@linkplain Component component}
@@ -46,47 +45,4 @@
  */
 @Documented @Target(METHOD) @Retention(RUNTIME)
 public @interface Provides {
-  /** The type of binding into which the return type of the annotated method contributes. */
-  enum Type {
-    /**
-     * The method is the only one which can produce the value for the specified return type. This
-     * is the default behavior.
-     */
-    UNIQUE,
-
-    /**
-     * The method's return type forms the generic type argument of a {@code Set<T>}, and the
-     * returned value is contributed to the set. The object graph will pass dependencies to the
-     * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
-     * immutable.
-     *
-     * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
-     *      multibinding</a>
-     */
-    SET,
-
-    /**
-     * Like {@link #SET}, except the method's return type is {@code Set<T>}, where any values are
-     * contributed to the set. An example use is to provide a default empty set binding, which is
-     * otherwise not possible using {@link #SET}.
-     *
-     * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
-     *      multibinding</a>
-     */
-    SET_VALUES,
-
-    /**
-     * The method's return type forms the type argument for the value of a
-     * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
-     * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
-     * the accumulation of values will be immutable.
-     *
-     * @see <a href="http://google.github.io/dagger/multibindings#map-multibindings">Map
-     *      multibinding</a>
-     */
-    @Beta
-    MAP;
-  }
-
-  Type type() default Type.UNIQUE;
 }
diff --git a/core/src/main/java/dagger/Reusable.java b/core/src/main/java/dagger/Reusable.java
index b7b61d8d1..4fd4b7da1 100644
--- a/core/src/main/java/dagger/Reusable.java
+++ b/core/src/main/java/dagger/Reusable.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,22 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import javax.inject.Scope;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * A scope that indicates that the object returned by a binding may be (but might not be) reused.
  *
  * <p>{@code @Reusable} is useful when you want to limit the number of provisions of a type, but
  * there is no specific lifetime over which there must be only one instance.
  *
- * @see <a href="http://google.github.io/dagger/users-guide.html#reusable-scope">Reusable Scope</a>
+ * @see <a href="https://google.github.io/dagger/users-guide.html#reusable-scope">Reusable Scope</a>
  */
 @Documented
 @Beta
diff --git a/core/src/main/java/dagger/Subcomponent.java b/core/src/main/java/dagger/Subcomponent.java
index 988f17b49..262327e5d 100644
--- a/core/src/main/java/dagger/Subcomponent.java
+++ b/core/src/main/java/dagger/Subcomponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * A subcomponent that inherits the bindings from a parent {@link Component} or
  * {@link Subcomponent}. The details of how to associate a subcomponent with a parent are described
diff --git a/core/src/main/java/dagger/internal/Beta.java b/core/src/main/java/dagger/internal/Beta.java
index a0a82c659..2e97f058e 100644
--- a/core/src/main/java/dagger/internal/Beta.java
+++ b/core/src/main/java/dagger/internal/Beta.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 
-import static java.lang.annotation.RetentionPolicy.SOURCE;
-
 /**
  * Signifies that a public API (public class, method or field) is subject to
  * incompatible changes, or even removal, in a future release. An API bearing
diff --git a/core/src/main/java/dagger/internal/DaggerCollections.java b/core/src/main/java/dagger/internal/DaggerCollections.java
index e317c28b7..3d47a8497 100644
--- a/core/src/main/java/dagger/internal/DaggerCollections.java
+++ b/core/src/main/java/dagger/internal/DaggerCollections.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
 import java.util.ArrayList;
diff --git a/core/src/main/java/dagger/internal/DelegateFactory.java b/core/src/main/java/dagger/internal/DelegateFactory.java
index d1e864d17..4ec047ca8 100644
--- a/core/src/main/java/dagger/internal/DelegateFactory.java
+++ b/core/src/main/java/dagger/internal/DelegateFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
 import javax.inject.Provider;
diff --git a/core/src/main/java/dagger/internal/DoubleCheck.java b/core/src/main/java/dagger/internal/DoubleCheck.java
index ef1708fa9..675a343aa 100644
--- a/core/src/main/java/dagger/internal/DoubleCheck.java
+++ b/core/src/main/java/dagger/internal/DoubleCheck.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
 import dagger.Lazy;
 import javax.inject.Provider;
 
-import static dagger.internal.Preconditions.checkNotNull;
-
 /**
  * A {@link Lazy} and {@link Provider} implementation that memoizes the value returned from a
  * delegate using the double-check idiom described in Item 71 of <i>Effective Java 2</i>.
@@ -50,7 +51,8 @@ public T get() {
           Object currentInstance = instance;
           if (currentInstance != UNINITIALIZED && currentInstance != result) {
             throw new IllegalStateException("Scoped provider was invoked recursively returning "
-                + "different results: " + currentInstance + " & " + result);
+                + "different results: " + currentInstance + " & " + result + ". This is likely "
+                + "due to a circular dependency.");
           }
           instance = result;
           /* Null out the reference to the provider. We are never going to need it again, so we
@@ -63,7 +65,9 @@ public T get() {
   }
 
   /** Returns a {@link Provider} that caches the value from the given delegate provider. */
-  public static <T> Provider<T> provider(Provider<T> delegate) {
+  // This method is declared this way instead of "<T> Provider<T> provider(Provider<T> delegate)"
+  // to work around an Eclipse type inference bug: https://github.com/google/dagger/issues/949.
+  public static <P extends Provider<T>, T> Provider<T> provider(P delegate) {
     checkNotNull(delegate);
     if (delegate instanceof DoubleCheck) {
       /* This should be a rare case, but if we have a scoped @Binds that delegates to a scoped
@@ -74,7 +78,9 @@ public T get() {
   }
 
   /** Returns a {@link Lazy} that caches the value from the given provider. */
-  public static <T> Lazy<T> lazy(Provider<T> provider) {
+  // This method is declared this way instead of "<T> Lazy<T> lazy(Provider<T> delegate)"
+  // to work around an Eclipse type inference bug: https://github.com/google/dagger/issues/949.
+  public static <P extends Provider<T>, T> Lazy<T> lazy(P provider) {
     if (provider instanceof Lazy) {
       @SuppressWarnings("unchecked")
       final Lazy<T> lazy = (Lazy<T>) provider;
diff --git a/core/src/main/java/dagger/internal/Factory.java b/core/src/main/java/dagger/internal/Factory.java
index 8451989ba..4fa0399fa 100644
--- a/core/src/main/java/dagger/internal/Factory.java
+++ b/core/src/main/java/dagger/internal/Factory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
 import dagger.Provides;
diff --git a/core/src/main/java/dagger/internal/GwtIncompatible.java b/core/src/main/java/dagger/internal/GwtIncompatible.java
new file mode 100644
index 000000000..f6100a2d0
--- /dev/null
+++ b/core/src/main/java/dagger/internal/GwtIncompatible.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+/** Marks an element incompatible with GWT. */
+public @interface GwtIncompatible {}
diff --git a/core/src/main/java/dagger/internal/InstanceFactory.java b/core/src/main/java/dagger/internal/InstanceFactory.java
index ca57f71bd..c3d1f5675 100644
--- a/core/src/main/java/dagger/internal/InstanceFactory.java
+++ b/core/src/main/java/dagger/internal/InstanceFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,28 +13,44 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
+import dagger.Lazy;
+
 /**
- * A {@link Factory} implementation that returns a single instance for all invocations of
- * {@link #get}.
+ * A {@link Factory} implementation that returns a single instance for all invocations of {@link
+ * #get}.
  *
  * <p>Note that while this is a {@link Factory} implementation, and thus unscoped, each call to
- * {@link #get} will always return the same instance.  As such, any scoping applied to this factory
- * is redundant and unnecessary.  However, using this with {@link DoubleCheck#provider} is valid and
+ * {@link #get} will always return the same instance. As such, any scoping applied to this factory
+ * is redundant and unnecessary. However, using this with {@link DoubleCheck#provider} is valid and
  * may be desired for testing or contractual guarantees.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-public final class InstanceFactory<T> implements Factory<T> {
+public final class InstanceFactory<T> implements Factory<T>, Lazy<T> {
   public static <T> Factory<T> create(T instance) {
-    if (instance == null) {
-      throw new NullPointerException();
-    }
-    return new InstanceFactory<T>(instance);
+    return new InstanceFactory<T>(checkNotNull(instance, "instance cannot be null"));
+  }
+
+  public static <T> Factory<T> createNullable(T instance) {
+    return instance == null
+        ? InstanceFactory.<T>nullInstanceFactory()
+        : new InstanceFactory<T>(instance);
+  }
+
+  @SuppressWarnings("unchecked") // bivariant implementation
+  private static <T> InstanceFactory<T> nullInstanceFactory() {
+    return (InstanceFactory<T>) NULL_INSTANCE_FACTORY;
   }
 
+  private static final InstanceFactory<Object> NULL_INSTANCE_FACTORY =
+      new InstanceFactory<Object>(null);
+
   private final T instance;
 
   private InstanceFactory(T instance) {
diff --git a/core/src/main/java/dagger/internal/MapBuilder.java b/core/src/main/java/dagger/internal/MapBuilder.java
new file mode 100644
index 000000000..1560491b1
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MapBuilder.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+
+import java.util.Collections;
+import java.util.Map;
+
+/**
+ * A fluent builder class that returns a {@link Map}. Used in component implementations where a map
+ * must be created in one fluent statement for inlined request fulfillments.
+ */
+public final class MapBuilder<K, V> {
+  private final Map<K, V> contributions;
+
+  private MapBuilder(int size) {
+    contributions = newLinkedHashMapWithExpectedSize(size);
+  }
+
+  /**
+   * Creates a new {@link MapBuilder} with {@code size} elements.
+   */
+  public static <K, V> MapBuilder<K, V> newMapBuilder(int size) {
+    return new MapBuilder<>(size);
+  }
+
+  public MapBuilder<K, V> put(K key, V value) {
+    contributions.put(key, value);
+    return this;
+  }
+
+  public Map<K, V> build() {
+    switch (contributions.size()) {
+      case 0:
+        return Collections.emptyMap();
+      default:
+        return Collections.unmodifiableMap(contributions);
+    }
+  }
+}
diff --git a/core/src/main/java/dagger/internal/MapFactory.java b/core/src/main/java/dagger/internal/MapFactory.java
index b0364ba01..b6f925a98 100644
--- a/core/src/main/java/dagger/internal/MapFactory.java
+++ b/core/src/main/java/dagger/internal/MapFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.Preconditions.checkNotNull;
+import static java.util.Collections.unmodifiableMap;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.inject.Provider;
 
-import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
-import static java.util.Collections.unmodifiableMap;
-
 /**
  * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
  * {@code Map<K, V>} when calling {@link #get} (as specified by {@link Factory}).
@@ -31,18 +35,28 @@
  *
  */
 public final class MapFactory<K, V> implements Factory<Map<K, V>> {
+  private static final Provider<Map<Object, Object>> EMPTY =
+      InstanceFactory.create(Collections.emptyMap());
+
   private final Map<K, Provider<V>> contributingMap;
 
-  private MapFactory(Map<K, Provider<V>> map) {
-    this.contributingMap = unmodifiableMap(map);
+  /**
+   * Returns a new {@link Builder}
+   */
+  public static <K, V> Builder<K, V> builder(int size) {
+    return new Builder<>(size);
   }
 
   /**
-   * Returns a new MapFactory.
+   * Returns a factory of an empty map.
    */
-  public static <K, V> MapFactory<K, V> create(Provider<Map<K, Provider<V>>> mapProviderFactory) {
-    Map<K, Provider<V>> map = mapProviderFactory.get();
-    return new MapFactory<K, V>(map);
+  @SuppressWarnings("unchecked") // safe contravariant cast
+  public static <K, V> Provider<Map<K, V>> emptyMapProvider() {
+    return (Provider<Map<K, V>>) (Provider) EMPTY;
+  }
+
+  private MapFactory(Map<K, Provider<V>> map) {
+    this.contributingMap = unmodifiableMap(map);
   }
 
   /**
@@ -57,4 +71,25 @@ private MapFactory(Map<K, Provider<V>> map) {
     }
     return unmodifiableMap(result);
   }
+
+  // TODO(ronshapiro): can we merge the builders? Or maybe just use a (Immutable)MapBuilder?
+  /** A builder for {@link MapFactory}. */
+  public static final class Builder<K, V> {
+    private final LinkedHashMap<K, Provider<V>> map;
+
+    private Builder(int size) {
+      this.map = newLinkedHashMapWithExpectedSize(size);
+    }
+
+    /** Associates {@code key} with {@code providerOfValue}. */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      map.put(checkNotNull(key, "key"), checkNotNull(providerOfValue, "provider"));
+      return this;
+    }
+
+    /** Returns a new {@link MapProviderFactory}. */
+    public MapFactory<K, V> build() {
+      return new MapFactory<>(map);
+    }
+  }
 }
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
index 141a77bf0..2458a3c05 100644
--- a/core/src/main/java/dagger/internal/MapProviderFactory.java
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,43 +13,34 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
-import java.util.Collections;
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.Preconditions.checkNotNull;
+import static java.util.Collections.unmodifiableMap;
+
+import dagger.Lazy;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import javax.inject.Provider;
 
-import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
-import static java.util.Collections.unmodifiableMap;
-
 /**
  * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
  * {@code Map<K, Provider<V>>} when calling {@link #get} (as specified by {@link Factory}).
  *
  * @author Chenying Hou
  * @since 2.0
- *
  */
-public final class MapProviderFactory<K, V> implements Factory<Map<K, Provider<V>>> {
-  private static final MapProviderFactory<Object, Object> EMPTY =
-      new MapProviderFactory<Object, Object>(Collections.<Object, Provider<Object>>emptyMap());
-
+public final class MapProviderFactory<K, V>
+    implements Factory<Map<K, Provider<V>>>, Lazy<Map<K, Provider<V>>> {
   private final Map<K, Provider<V>> contributingMap;
 
   /**
    * Returns a new {@link Builder}
    */
   public static <K, V> Builder<K, V> builder(int size) {
-    return new Builder<K, V>(size);
-  }
-
-  /**
-   * Returns a factory of an empty map.
-   */
-  @SuppressWarnings("unchecked") // safe contravariant cast
-  public static <K, V> MapProviderFactory<K, V> empty() {
-    return (MapProviderFactory<K, V>) EMPTY;
+    return new Builder<>(size);
   }
 
   private MapProviderFactory(Map<K, Provider<V>> contributingMap) {
@@ -66,37 +57,23 @@ private MapProviderFactory(Map<K, Provider<V>> contributingMap) {
     return this.contributingMap;
   }
 
-  /**
-   * A builder to help build the {@link MapProviderFactory}
-   */
+  /** A builder for {@link MapProviderFactory}. */
   public static final class Builder<K, V> {
-    private final LinkedHashMap<K, Provider<V>> mapBuilder;
+    private final LinkedHashMap<K, Provider<V>> map;
 
     private Builder(int size) {
-      // TODO(user): consider which way to initialize mapBuilder is better
-      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
+      this.map = newLinkedHashMapWithExpectedSize(size);
     }
 
-    /**
-     * Returns a new {@link MapProviderFactory}
-     */
-    public MapProviderFactory<K, V> build() {
-      return new MapProviderFactory<K, V>(this.mapBuilder);
-    }
-
-    /**
-     * Associate k with providerOfValue in {@code Builder}
-     */
+    /** Associates {@code key} with {@code providerOfValue}. */
     public Builder<K, V> put(K key, Provider<V> providerOfValue) {
-      if (key == null) {
-        throw new NullPointerException("The key is null");
-      }
-      if (providerOfValue == null) {
-        throw new NullPointerException("The provider of the value is null");
-      }
-
-      this.mapBuilder.put(key, providerOfValue);
+      map.put(checkNotNull(key, "key"), checkNotNull(providerOfValue, "provider"));
       return this;
     }
+
+    /** Returns a new {@link MapProviderFactory}. */
+    public MapProviderFactory<K, V> build() {
+      return new MapProviderFactory<>(map);
+    }
   }
 }
diff --git a/core/src/main/java/dagger/internal/MembersInjectors.java b/core/src/main/java/dagger/internal/MembersInjectors.java
index 5be2b8ee2..08038cee6 100644
--- a/core/src/main/java/dagger/internal/MembersInjectors.java
+++ b/core/src/main/java/dagger/internal/MembersInjectors.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
 import dagger.MembersInjector;
 import javax.inject.Inject;
 
-import static dagger.internal.Preconditions.checkNotNull;
-
 /**
  * Basic {@link MembersInjector} implementations used by the framework.
  *
@@ -27,16 +28,6 @@
  * @since 2.0
  */
 public final class MembersInjectors {
-  /**
-   * Injects members into {@code instance} using {@code membersInjector}.  This method is a
-   * convenience for cases in which you would want to chain members injection, but can't because
-   * {@link MembersInjector#injectMembers} returns {@code void}.
-   */
-  public static <T> T injectMembers(MembersInjector<T> membersInjector, T instance) {
-    membersInjector.injectMembers(instance);
-    return instance;
-  }
-
   /**
    * Returns a {@link MembersInjector} implementation that injects no members
    *
@@ -52,22 +43,9 @@
     INSTANCE;
 
     @Override public void injectMembers(Object instance) {
-      checkNotNull(instance);
+      checkNotNull(instance, "Cannot inject members into a null reference");
     }
   }
 
-  /**
-   * Returns a {@link MembersInjector} that delegates to the {@link MembersInjector} of its
-   * supertype.  This is useful for cases where a type is known not to have its own {@link Inject}
-   * members, but must still inject members on its supertype(s).
-   *
-   * <p>Note that there is no verification that the type being injected does not have {@link Inject}
-   * members, so care should be taken to ensure appropriate use.
-   */
-  @SuppressWarnings("unchecked")
-  public static <T> MembersInjector<T> delegatingTo(MembersInjector<? super T> delegate) {
-    return (MembersInjector<T>) checkNotNull(delegate);
-  }
-
   private MembersInjectors() {}
 }
diff --git a/core/src/main/java/dagger/internal/MemoizedSentinel.java b/core/src/main/java/dagger/internal/MemoizedSentinel.java
new file mode 100644
index 000000000..dd24dcd85
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MemoizedSentinel.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+/** A sentinel used to memoize a scoped binding in a component. */
+public final class MemoizedSentinel {}
diff --git a/core/src/main/java/dagger/internal/Preconditions.java b/core/src/main/java/dagger/internal/Preconditions.java
index 1877cd0eb..7b64da1a5 100644
--- a/core/src/main/java/dagger/internal/Preconditions.java
+++ b/core/src/main/java/dagger/internal/Preconditions.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
 /**
@@ -49,6 +50,40 @@
     return reference;
   }
 
+  /**
+   * Ensures that an object reference passed as a parameter to the calling method is not null.
+   *
+   * @param reference an object reference
+   * @param errorMessageTemplate a template for the exception message should the check fail. The
+   *     message is formed by replacing the single {@code %s} placeholder in the template with
+   *     {@code errorMessageArg}.
+   * @param errorMessageArg the argument to be substituted into the message template. Converted to a
+   *     string using {@link String#valueOf(Object)}, except for {@link Class} objects, which use
+   *     {@link Class#getCanonicalName()}.
+   * @return the non-null reference that was validated
+   * @throws NullPointerException if {@code reference} is null
+   * @throws IllegalArgumentException if {@code errorMessageTemplate} doesn't contain exactly one
+   *     "%s"
+   */
+  public static <T> T checkNotNull(
+      T reference, String errorMessageTemplate, Object errorMessageArg) {
+    if (reference == null) {
+      // Simple implementation of String.format, which is not GWT-compatible
+      if (!errorMessageTemplate.contains("%s")) {
+        throw new IllegalArgumentException("errorMessageTemplate has no format specifiers");
+      }
+      if (errorMessageTemplate.indexOf("%s") != errorMessageTemplate.lastIndexOf("%s")) {
+        throw new IllegalArgumentException(
+            "errorMessageTemplate has more than one format specifier");
+      }
+      String argString =
+          errorMessageArg instanceof Class
+              ? ((Class) errorMessageArg).getCanonicalName()
+              : String.valueOf(errorMessageArg);
+      throw new NullPointerException(errorMessageTemplate.replace("%s", argString));
+    }
+    return reference;
+  }
+
   private Preconditions() {}
 }
-
diff --git a/core/src/main/java/dagger/internal/ProviderOfLazy.java b/core/src/main/java/dagger/internal/ProviderOfLazy.java
index 77d4961dd..23b6afd75 100644
--- a/core/src/main/java/dagger/internal/ProviderOfLazy.java
+++ b/core/src/main/java/dagger/internal/ProviderOfLazy.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
 import dagger.Lazy;
 import javax.inject.Provider;
 
-import static dagger.internal.Preconditions.checkNotNull;
-
 /**
  * A {@link Provider} of {@link Lazy} instances that each delegate to a given {@link Provider}.
  */
diff --git a/core/src/main/java/dagger/internal/ReferenceReleasingProvider.java b/core/src/main/java/dagger/internal/ReferenceReleasingProvider.java
new file mode 100644
index 000000000..30a9cb4b5
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ReferenceReleasingProvider.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import java.lang.ref.WeakReference;
+import javax.inject.Provider;
+
+/**
+ * A {@link Provider} implementation that can exchange its strong reference to the stored object for
+ * a {@link WeakReference}.
+ *
+ * <p>The provider can be in any one of four states at a time:
+ *
+ * <ul>
+ *   <li>In <b>uninitialized</b> state, the provider's strong reference and its weak reference are
+ *       both {@code null}.
+ *   <li>In <b>cleared</b> state, the strong reference is {@code null}, and the weak reference's
+ *       value is {@code null}.
+ *   <li>In <b>strong-reference</b> state, the strong reference refers to the stored object, and the
+ *       weak reference is {@code null}.
+ *   <li>In <b>weak-reference</b> state, the strong reference is {@code null}, and the weak
+ *       reference's value is not {@code null}.
+ * </ul>
+ *
+ * <p>The provider starts in <b>uninitialized</b> state.
+ *
+ * <p>{@link #get()} transitions to <b>strong-reference</b> state when in <b>uninitialized</b> or
+ * <b>cleared</b> state.
+ *
+ * <p>{@link #releaseStrongReference()} transitions to <b>weak-reference</b> state when in
+ * <b>strong-reference</b> state, unless the stored value is {@code null}.
+ *
+ * <p>{@link #restoreStrongReference()} transitions to <b>strong-reference</b> state when in
+ * <b>weak-reference</b> state.
+ *
+ * <p>If garbage collection clears the weak reference while in <b>weak-reference</b> state, the
+ * provider transitions to <b>cleared</b> state.
+ *
+ * <p><img src="doc-files/ReferenceReleasingProvider-statemachine.png">
+ *
+ * @see <a href="https://google.github.io/dagger/users-guide.html#releasable-references">Releasable references</a>
+ */
+@GwtIncompatible
+public final class ReferenceReleasingProvider<T> implements Provider<T> {
+  private static final Object NULL = new Object(); // sentinel used when provider.get() returns null
+
+  private final Provider<T> provider;
+  private volatile Object strongReference;
+  private volatile WeakReference<T> weakReference;
+
+  private ReferenceReleasingProvider(Provider<T> provider) {
+    assert provider != null;
+    this.provider = provider;
+  }
+
+  /**
+   * Releases the strong reference to the object previously returned by {@link #get()}, and creates
+   * a {@link WeakReference} to that object, unless the stored value is {@code null}.
+   */
+  public void releaseStrongReference() {
+    Object value = strongReference;
+    if (value != null && value != NULL) {
+      synchronized (this) {
+        @SuppressWarnings("unchecked") // values other than NULL come from the provider
+        T storedValue = (T) value;
+        weakReference = new WeakReference<T>(storedValue);
+        strongReference = null;
+      }
+    }
+  }
+
+  /**
+   * Restores the strong reference that was previously {@linkplain #releaseStrongReference()
+   * released} if the {@link WeakReference} has not yet been cleared during garbage collection.
+   */
+  public void restoreStrongReference() {
+    Object value = strongReference;
+    if (weakReference != null && value == null) {
+      synchronized (this) {
+        value = strongReference;
+        if (weakReference != null && value == null) {
+          value = weakReference.get();
+          if (value != null) {
+            strongReference = value;
+            weakReference = null;
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Returns the result of calling {@link Provider#get()} on the underlying {@link Provider}.
+   *
+   * <p>Calling {@code get()} in <b>uninitialized</b> or <b>cleared</b> state calls {@code get()}
+   * on the underlying provider, sets the strong reference to the returned value, and returns it,
+   * leaving the provider in <b>strong-reference</b> state.
+   *
+   * <p>Calling {@code get()} in <b>strong-reference</b> state simply returns the strong reference,
+   * leaving the provider in <b>strong-reference</b> state.
+   *
+   * <p>Calling {@code get()} in <b>weak-reference</b> state returns the {@link WeakReference}'s
+   * value, leaving the provider in <b>weak-reference</b> state.
+   */
+  @SuppressWarnings("unchecked") // cast only happens when result comes from the provider
+  @Override
+  public T get() {
+    Object value = currentValue();
+    if (value == null) {
+      synchronized (this) {
+        value = currentValue();
+        if (value == null) {
+          value = provider.get();
+          if (value == null) {
+            value = NULL;
+          }
+          strongReference = value;
+        }
+      }
+    }
+    return value == NULL ? null : (T) value;
+  }
+
+  private Object currentValue() {
+    Object value = strongReference;
+    if (value != null) {
+      return value;
+    }
+    if (weakReference != null) {
+      return weakReference.get();
+    }
+    return null;
+  }
+
+  /**
+   * Returns a {@link Provider} that stores the value from the given delegate provider and is
+   * managed by {@code references}.
+   */
+  public static <T> ReferenceReleasingProvider<T> create(
+      Provider<T> delegate, ReferenceReleasingProviderManager references) {
+    ReferenceReleasingProvider<T> provider =
+        new ReferenceReleasingProvider<T>(checkNotNull(delegate));
+    references.addProvider(provider);
+    return provider;
+  }
+}
diff --git a/core/src/main/java/dagger/internal/ReferenceReleasingProviderManager.java b/core/src/main/java/dagger/internal/ReferenceReleasingProviderManager.java
new file mode 100644
index 000000000..9be7c342a
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ReferenceReleasingProviderManager.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import dagger.releasablereferences.ReleasableReferenceManager;
+import java.lang.annotation.Annotation;
+import java.lang.ref.WeakReference;
+import java.util.Iterator;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+/**
+ * A {@link ReleasableReferenceManager} that forwards calls to a dynamic set of weakly-referenced
+ * {@link ReferenceReleasingProvider}s.
+ *
+ * @see <a href="https://google.github.io/dagger/users-guide.html#releasable-references">Releasable references</a>
+ */
+@GwtIncompatible
+public final class ReferenceReleasingProviderManager implements ReleasableReferenceManager {
+
+  private final Class<? extends Annotation> scope;
+  private final Queue<WeakReference<ReferenceReleasingProvider<?>>> providers =
+      new ConcurrentLinkedQueue<WeakReference<ReferenceReleasingProvider<?>>>();
+
+  public ReferenceReleasingProviderManager(Class<? extends Annotation> scope) {
+    this.scope = checkNotNull(scope);
+  }
+
+  /**
+   * Adds a weak reference to {@code provider}.
+   */
+  public void addProvider(ReferenceReleasingProvider<?> provider) {
+    providers.add(new WeakReference<ReferenceReleasingProvider<?>>(provider));
+  }
+
+  @Override
+  public Class<? extends Annotation> scope() {
+    return scope;
+  }
+
+  /**
+   * {@inheritDoc} Calls {@link ReferenceReleasingProvider#releaseStrongReference()} on all
+   * providers that have been {@linkplain #addProvider(ReferenceReleasingProvider) added} and that
+   * are still weakly referenced.
+   */
+  @Override
+  public void releaseStrongReferences() {
+    execute(Operation.RELEASE);
+  }
+
+  /**
+   * {@inheritDoc} Calls {@link ReferenceReleasingProvider#restoreStrongReference()} on all
+   * providers that have been {@linkplain #addProvider(ReferenceReleasingProvider) added} and that
+   * are still weakly referenced.
+   */
+  @Override
+  public void restoreStrongReferences() {
+    execute(Operation.RESTORE);
+  }
+
+  private void execute(Operation operation) {
+    Iterator<WeakReference<ReferenceReleasingProvider<?>>> iterator = providers.iterator();
+    while (iterator.hasNext()) {
+      ReferenceReleasingProvider<?> provider = iterator.next().get();
+      if (provider == null) {
+        iterator.remove();
+      } else {
+        operation.execute(provider);
+      }
+    }
+  }
+
+  private enum Operation {
+    RELEASE {
+      @Override
+      void execute(ReferenceReleasingProvider<?> provider) {
+        provider.releaseStrongReference();
+      }
+    },
+    RESTORE {
+      @Override
+      void execute(ReferenceReleasingProvider<?> provider) {
+        provider.restoreStrongReference();
+      }
+    },
+    ;
+
+    abstract void execute(ReferenceReleasingProvider<?> provider);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/SetBuilder.java b/core/src/main/java/dagger/internal/SetBuilder.java
new file mode 100644
index 000000000..41a2fc721
--- /dev/null
+++ b/core/src/main/java/dagger/internal/SetBuilder.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * A fluent builder class that returns a {@link Set}. Used in component implementations where a set
+ * must be created in one fluent statement for inlined request fulfillments.
+ */
+public final class SetBuilder<T> {
+  private static final String SET_CONTRIBUTIONS_CANNOT_BE_NULL =
+      "Set contributions cannot be null";
+  private final List<T> contributions;
+
+  private SetBuilder(int estimatedSize) {
+    contributions = new ArrayList<>(estimatedSize);
+  }
+
+  /**
+   * {@code estimatedSize} is the number of bindings which contribute to the set. They may each
+   * provide {@code [0..n)} instances to the set. Because the final size is unknown, {@code
+   * contributions} are collected in a list and only hashed in {@link #build()}.
+   */
+  public static <T> SetBuilder<T> newSetBuilder(int estimatedSize) {
+    return new SetBuilder<T>(estimatedSize);
+  }
+
+  public SetBuilder<T> add(T t) {
+    contributions.add(checkNotNull(t, SET_CONTRIBUTIONS_CANNOT_BE_NULL));
+    return this;
+  }
+
+  public SetBuilder<T> addAll(Collection<? extends T> collection) {
+    for (T item : collection) {
+      checkNotNull(item, SET_CONTRIBUTIONS_CANNOT_BE_NULL);
+    }
+    contributions.addAll(collection);
+    return this;
+  }
+
+  public Set<T> build() {
+    switch (contributions.size()) {
+      case 0:
+        return Collections.emptySet();
+      case 1:
+        return Collections.singleton(contributions.get(0));
+      default:
+        return Collections.unmodifiableSet(new HashSet<>(contributions));
+    }
+  }
+}
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index dd0d92711..b5a2ecd1e 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Set;
-import javax.inject.Provider;
+package dagger.internal;
 
 import static dagger.internal.DaggerCollections.hasDuplicates;
 import static dagger.internal.DaggerCollections.newHashSetWithExpectedSize;
@@ -28,6 +23,12 @@
 import static java.util.Collections.emptySet;
 import static java.util.Collections.unmodifiableSet;
 
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+import javax.inject.Provider;
+
 /**
  * A {@link Factory} implementation used to implement {@link Set} bindings. This factory always
  * returns a new {@link Set} instance for each call to {@link #get} (as required by {@link Factory})
@@ -37,13 +38,7 @@
  * @since 2.0
  */
 public final class SetFactory<T> implements Factory<Set<T>> {
-  private static final Factory<Set<Object>> EMPTY_FACTORY =
-      new Factory<Set<Object>>() {
-        @Override
-        public Set<Object> get() {
-          return emptySet();
-        }
-      };
+  private static final Factory<Set<Object>> EMPTY_FACTORY = InstanceFactory.create(emptySet());
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
   public static <T> Factory<Set<T>> empty() {
diff --git a/core/src/main/java/dagger/internal/SingleCheck.java b/core/src/main/java/dagger/internal/SingleCheck.java
index 3a9a14766..4c8b6c220 100644
--- a/core/src/main/java/dagger/internal/SingleCheck.java
+++ b/core/src/main/java/dagger/internal/SingleCheck.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,47 +13,54 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
 import dagger.Lazy;
 import javax.inject.Provider;
 
-import static dagger.internal.Preconditions.checkNotNull;
-
 /**
- * A {@link Provider} implementation that memoizes the result of a {@link Factory} instance using
+ * A {@link Provider} implementation that memoizes the result of another {@link Provider} using
  * simple lazy initialization, not the double-checked lock pattern.
  */
 public final class SingleCheck<T> implements Provider<T>, Lazy<T> {
   private static final Object UNINITIALIZED = new Object();
 
-  private volatile Factory<T> factory;
+  private volatile Provider<T> provider;
   private volatile Object instance = UNINITIALIZED;
 
-  private SingleCheck(Factory<T> factory) {
-    assert factory != null;
-    this.factory = factory;
+  private SingleCheck(Provider<T> provider) {
+    assert provider != null;
+    this.provider = provider;
   }
 
-  @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
+  @SuppressWarnings("unchecked") // cast only happens when result comes from the delegate provider
   @Override
   public T get() {
-    // factory is volatile and might become null afer the check to instance == UNINITIALIZED
-    // retrieve the factory first, which should not be null if instance is UNINITIALIZED.
+    // provider is volatile and might become null after the check to instance == UNINITIALIZED, so
+    // retrieve the provider first, which should not be null if instance is UNINITIALIZED.
     // This relies upon instance also being volatile so that the reads and writes of both variables
     // cannot be reordered.
-    Factory<T> factoryReference = factory;
+    Provider<T> providerReference = provider;
     if (instance == UNINITIALIZED) {
-      instance = factoryReference.get();
+      instance = providerReference.get();
       // Null out the reference to the provider. We are never going to need it again, so we can make
-      // it eligble for GC.
-      factory = null;
+      // it eligible for GC.
+      provider = null;
     }
     return (T) instance;
   }
 
-  /** Returns a new provider for the given factory. */
-  public static <T> Provider<T> provider(Factory<T> factory) {
-    return new SingleCheck<T>(checkNotNull(factory));
+  /** Returns a {@link Provider} that caches the value from the given delegate provider. */
+  // This method is declared this way instead of "<T> Provider<T> provider(Provider<T> provider)" 
+  // to work around an Eclipse type inference bug: https://github.com/google/dagger/issues/949.
+  public static <P extends Provider<T>, T> Provider<T> provider(P provider) {
+    // If a scoped @Binds delegates to a scoped binding, don't cache the value again.
+    if (provider instanceof SingleCheck || provider instanceof DoubleCheck) {
+      return provider;
+    }
+    return new SingleCheck<T>(checkNotNull(provider));
   }
 }
diff --git a/core/src/main/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java b/core/src/main/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java
new file mode 100644
index 000000000..a1167ef8e
--- /dev/null
+++ b/core/src/main/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.lang.annotation.Annotation;
+
+/**
+ * A {@link TypedReleasableReferenceManager} that decorates another {@link
+ * ReleasableReferenceManager} with a metadata annotation.
+ *
+ * <p>For each scope that requires a {@link ReleasableReferenceManager}, the generated component
+ * implementation has a field that implements that manager. For every {@link
+ * TypedReleasableReferenceManager} that is required for that scope, the component uses this class
+ * to decorate the field with the metadata annotation.
+ *
+ * @param <M> the type of the metadata annotation
+ */
+@GwtIncompatible
+public final class TypedReleasableReferenceManagerDecorator<M extends Annotation>
+    implements TypedReleasableReferenceManager<M> {
+
+  private final ReleasableReferenceManager delegate;
+  private final M metadata;
+
+  /**
+   * Constructs a manager that delegates {@link #releaseStrongReferences()} and {@link
+   * #releaseStrongReferences()} to {@code delegate}.
+   */
+  public TypedReleasableReferenceManagerDecorator(ReleasableReferenceManager delegate, M metadata) {
+    this.delegate = checkNotNull(delegate);
+    this.metadata = checkNotNull(metadata);
+  }
+
+  @Override
+  public Class<? extends Annotation> scope() {
+    return delegate.scope();
+  }
+
+  @Override
+  public M metadata() {
+    return metadata;
+  }
+
+  @Override
+  public void releaseStrongReferences() {
+    delegate.releaseStrongReferences();
+  }
+
+  @Override
+  public void restoreStrongReferences() {
+    delegate.restoreStrongReferences();
+  }
+}
diff --git a/core/src/main/java/dagger/multibindings/ClassKey.java b/core/src/main/java/dagger/multibindings/ClassKey.java
index 52dc16d0d..ac255457c 100644
--- a/core/src/main/java/dagger/multibindings/ClassKey.java
+++ b/core/src/main/java/dagger/multibindings/ClassKey.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,24 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.MapKey;
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-
 /**
  * A {@link MapKey} annotation for maps with {@code Class<?>} keys.
- * 
+ *
  * <p>If your map's keys can be constrained, consider using a custom annotation instead, with a
  * member whose type is {@code Class<? extends Something>}.
  */
-@Beta
 @Documented
 @Target(METHOD)
+@Retention(RUNTIME)
 @MapKey
 public @interface ClassKey {
   Class<?> value();
diff --git a/core/src/main/java/dagger/multibindings/ElementsIntoSet.java b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
index 7e157399f..72cc86d1d 100644
--- a/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
+++ b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,22 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * The method's return type is {@code Set<T>} and all values are contributed to the set. The {@code
  * Set<T>} produced from the accumulation of values will be immutable. An example use is to provide
  * a default empty set binding, which is otherwise not possible using {@link IntoSet}.
  *
- * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
- *      multibinding</a>
+ * @see <a href="https://google.github.io/dagger/multibindings#set-multibindings">Set multibinding</a>
  */
 @Documented
 @Target(METHOD)
diff --git a/core/src/main/java/dagger/multibindings/IntKey.java b/core/src/main/java/dagger/multibindings/IntKey.java
index 766f6dc99..55e79a1bf 100644
--- a/core/src/main/java/dagger/multibindings/IntKey.java
+++ b/core/src/main/java/dagger/multibindings/IntKey.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,19 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.MapKey;
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-
 /** A {@link MapKey} annotation for maps with {@code int} keys. */
-@Beta
 @Documented
 @Target(METHOD)
+@Retention(RUNTIME)
 @MapKey
 public @interface IntKey {
   int value();
diff --git a/core/src/main/java/dagger/multibindings/IntoMap.java b/core/src/main/java/dagger/multibindings/IntoMap.java
index a1e786eca..3066b5801 100644
--- a/core/src/main/java/dagger/multibindings/IntoMap.java
+++ b/core/src/main/java/dagger/multibindings/IntoMap.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,27 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
-import dagger.internal.Beta;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
- * The method's return type forms the type argument for the value of a
- * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
- * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
- * the accumulation of values will be immutable.
+ * The method's return type forms the type argument for the value of a {@code Map<K, Provider<V>>},
+ * and the combination of the annotated key and the returned value is contributed to the map as a
+ * key/value pair. The {@code Map<K, Provider<V>>} produced from the accumulation of values will be
+ * immutable.
  *
- * @see <a href="http://google.github.io/dagger/multibindings#map-multibindings">Map
- *      multibinding</a>
+ * @see <a href="https://google.github.io/dagger/multibindings#map-multibindings">Map multibinding</a>
  */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@Beta
 public @interface IntoMap {}
diff --git a/core/src/main/java/dagger/multibindings/IntoSet.java b/core/src/main/java/dagger/multibindings/IntoSet.java
index a7e3a7cdf..f42860f67 100644
--- a/core/src/main/java/dagger/multibindings/IntoSet.java
+++ b/core/src/main/java/dagger/multibindings/IntoSet.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,23 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
- * The method's return type forms the generic type argument of a {@code Set<T>}, and the
- * returned value is contributed to the set. The object graph will pass dependencies to the
- * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
- * immutable.
+ * The method's return type forms the generic type argument of a {@code Set<T>}, and the returned
+ * value is contributed to the set. The object graph will pass dependencies to the method as
+ * parameters. The {@code Set<T>} produced from the accumulation of values will be immutable.
  *
- * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
- *      multibinding</a>
+ * @see <a href="https://google.github.io/dagger/multibindings#set-multibindings">Set multibinding</a>
  */
 @Documented
 @Target(METHOD)
diff --git a/core/src/main/java/dagger/multibindings/LongKey.java b/core/src/main/java/dagger/multibindings/LongKey.java
index 9d9a40800..71d0fe116 100644
--- a/core/src/main/java/dagger/multibindings/LongKey.java
+++ b/core/src/main/java/dagger/multibindings/LongKey.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,19 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.MapKey;
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-
 /** A {@link MapKey} annotation for maps with {@code long} keys. */
-@Beta
 @Documented
 @Target(METHOD)
+@Retention(RUNTIME)
 @MapKey
 public @interface LongKey {
   long value();
diff --git a/core/src/main/java/dagger/multibindings/Multibinds.java b/core/src/main/java/dagger/multibindings/Multibinds.java
index 48dd94257..1517b2698 100644
--- a/core/src/main/java/dagger/multibindings/Multibinds.java
+++ b/core/src/main/java/dagger/multibindings/Multibinds.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
-import dagger.internal.Beta;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-
 /**
  * Annotates abstract module methods that declare multibindings.
  *
@@ -32,10 +34,10 @@
  *
  * <pre><code>
  *   {@literal @Module} abstract class MyModule {
- *     {@literal @Multibinds Set<Foo> aSet();}
- *     {@literal @Multibinds @MyQualifier Set<Foo> aQualifiedSet();}
- *     {@literal @Multibinds Map<String, Foo> aMap();}
- *     {@literal @Multibinds @MyQualifier Map<String, Foo> aQualifiedMap();}
+ *     {@literal @Multibinds abstract Set<Foo> aSet();}
+ *     {@literal @Multibinds abstract @MyQualifier Set<Foo> aQualifiedSet();}
+ *     {@literal @Multibinds abstract Map<String, Foo> aMap();}
+ *     {@literal @Multibinds abstract @MyQualifier Map<String, Foo> aQualifiedMap();}
  *
  *     {@literal @Provides}
  *     {@literal static Object usesMultibindings(Set<Foo> set, @MyQualifier Map<String, Foo> map}) {
@@ -44,11 +46,11 @@
  *   }</code></pre>
  *
  * <p>A given set or map multibinding can be declared any number of times without error. Dagger
- * never implements calls any {@code @Multibinds} methods.
+ * never implements or calls any {@code @Multibinds} methods.
  *
- * @see <a href="http://google.github.io/dagger/multibindings">Multibindings</a>
+ * @see <a href="https://google.github.io/dagger/multibindings">Multibindings</a>
  */
 @Documented
 @Target(METHOD)
-@Beta
+@Retention(RUNTIME)
 public @interface Multibinds {}
diff --git a/core/src/main/java/dagger/multibindings/StringKey.java b/core/src/main/java/dagger/multibindings/StringKey.java
index 11dcbfaa6..5dad8e3e9 100644
--- a/core/src/main/java/dagger/multibindings/StringKey.java
+++ b/core/src/main/java/dagger/multibindings/StringKey.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,19 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.MapKey;
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-
 /** A {@link MapKey} annotation for maps with {@link String} keys. */
-@Beta
 @Documented
 @Target(METHOD)
+@Retention(RUNTIME)
 @MapKey
 public @interface StringKey {
   String value();
diff --git a/core/src/main/java/dagger/multibindings/package-info.java b/core/src/main/java/dagger/multibindings/package-info.java
index e62974ddb..e806d9ec6 100644
--- a/core/src/main/java/dagger/multibindings/package-info.java
+++ b/core/src/main/java/dagger/multibindings/package-info.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,7 +18,6 @@
  * This package contains the API by which Dagger allows you to bind several objects into a
  * collection that can be injected without depending directly on each of the individual bindings.
  *
- * @see <a href="http://google.github.io/dagger/multibindings">Multibindings in the Dagger
- *      User's Guide</a>
+ * @see <a href="https://google.github.io/dagger/multibindings">Multibindings in the Dagger User's Guide</a>
  */
 package dagger.multibindings;
diff --git a/core/src/main/java/dagger/package-info.java b/core/src/main/java/dagger/package-info.java
index e5cc67f39..99cd44bad 100644
--- a/core/src/main/java/dagger/package-info.java
+++ b/core/src/main/java/dagger/package-info.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,20 +15,19 @@
  */
 
 /**
- * This package contains the public API for the <a href="http://google.github.io/dagger/">Dagger
- * 2</a> dependency injection framework.  By building upon
- * <a href="https://jcp.org/en/jsr/detail?id=330">JSR 330</a>, Dagger 2 provides an
- * annotation-driven API for dependency injection whose implementation is entirely generated at
- * compile time by <a href="http://en.wikipedia.org/wiki/Java_annotation#Processing">annotation
- * processors</a>.
+ * This package contains the public API for the <a href="https://google.github.io/dagger/">Dagger 2</a> dependency
+ * injection framework. By building upon <a href="https://jcp.org/en/jsr/detail?id=330">JSR 330</a>,
+ * Dagger 2 provides an annotation-driven API for dependency injection whose implementation is
+ * entirely generated at compile time by <a
+ * href="http://en.wikipedia.org/wiki/Java_annotation#Processing">annotation processors</a>.
  *
  * <p>The entry point into the API is the {@link Component}, which annotates abstract types for
- * Dagger 2 to implement.  The dependency graph is configured using using annotations such as
- * {@link Module}, {@link Provides} and {@link javax.inject.Inject}.
+ * Dagger 2 to implement. The dependency graph is configured using annotations such as {@link
+ * Module}, {@link Provides} and {@link javax.inject.Inject}.
  *
  * <p>{@code dagger.internal.codegen.ComponentProcessor} is the processor responsible for generating
- * the implementation.  Dagger uses the annotation procesor
- * {@linkplain java.util.ServiceLoader service loader} to automatically configure the processor, so
- * explict build configuration shouldn't be necessary.
+ * the implementation. Dagger uses the annotation procesor {@linkplain java.util.ServiceLoader
+ * service loader} to automatically configure the processor, so explict build configuration
+ * shouldn't be necessary.
  */
 package dagger;
diff --git a/core/src/main/java/dagger/releasablereferences/CanReleaseReferences.java b/core/src/main/java/dagger/releasablereferences/CanReleaseReferences.java
new file mode 100644
index 000000000..a0890af3d
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/CanReleaseReferences.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.releasablereferences;
+
+import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+/**
+ * Annotates {@linkplain javax.inject.Scope scope annotations} to indicate that references to
+ * objects stored within that scope can be <a
+ * href="https://google.github.io/dagger/users-guide.html#releasable-references">released</a> during the lifetime
+ * of the scope.
+ *
+ * <p>A scope can release references if it is annotated with {@code CanReleaseReferences} or if it
+ * is annotated with an annotation that itself is annotated with {@code CanReleaseReferences}.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @CanReleaseReferences}
+ *   {@literal @Scope}
+ *   public {@literal @interface} MyScope {}</pre>
+ *
+ * or:
+ *
+ * <pre>
+ *   {@literal @CanReleaseReferences}
+ *   public {@literal @interface} SomeAnnotation {}
+ *
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @SomeAnnotation}
+ *   {@literal @Scope}
+ *   public {@literal @interface} MyScope {}</pre>
+ *
+ * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
+ * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
+ *
+ * @since 2.8
+ */
+@Beta
+@Documented
+@GwtIncompatible
+@Target(ANNOTATION_TYPE)
+public @interface CanReleaseReferences {}
diff --git a/core/src/main/java/dagger/releasablereferences/ForReleasableReferences.java b/core/src/main/java/dagger/releasablereferences/ForReleasableReferences.java
new file mode 100644
index 000000000..e11adb227
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/ForReleasableReferences.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.releasablereferences;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.inject.Qualifier;
+
+/**
+ * A {@link Qualifier} to inject a {@link ReleasableReferenceManager} or {@link
+ * TypedReleasableReferenceManager} object for a particular scope.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @CanReleaseReferences}
+ *   {@literal @Scope}
+ *   {@literal public @interface} MyScope {}
+ *
+ *   {@literal @CanReleaseReferences}
+ *   {@literal public @interface} MyMetadata {
+ *     int value();
+ *   }
+ *
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @MyMetadata}(15)
+ *   {@literal @Scope}
+ *   {@literal public @interface YourScope} {}
+ *
+ *   class MyClass {
+ *     {@literal @Inject}
+ *     MyClass(
+ *         {@literal @ForReleasableReferences(MyScope.class)}
+ *         ReleasableReferenceManager myScopeReferenceManager,
+ *         {@literal @ForReleasableReferences(YourScope.class)}
+ *         {@literal TypedReleasableReferenceManager<MyMetadata>} yourScopeReferenceManager) {
+ *       // …
+ *     }
+ *   }
+ * </pre>
+ *
+ * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
+ * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
+ *
+ * @see <a href="https://google.github.io/dagger/users-guide.html#releasable-references">Releasable references</a>
+ * @since 2.8
+ */
+@Beta
+@Documented
+@GwtIncompatible
+@Target({FIELD, PARAMETER, METHOD})
+@Retention(RUNTIME)
+@Qualifier
+public @interface ForReleasableReferences {
+  /** The {@linkplain CanReleaseReferences reference-releasing} scope annotation type. */
+  Class<? extends Annotation> value();
+}
diff --git a/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java b/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java
new file mode 100644
index 000000000..0c5acf050
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.releasablereferences;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import java.lang.annotation.Annotation;
+import java.lang.ref.WeakReference;
+import javax.inject.Provider;
+
+/**
+ * An object that can <a href="https://google.github.io/dagger/users-guide.html#releasable-references">release or
+ * restore strong references</a> held in a {@link CanReleaseReferences @CanReleaseReferences} scope.
+ *
+ * <p>Your top-level component can provide a {@link
+ * ForReleasableReferences @ForReleasableReferences(Foo.class)} {@link ReleasableReferenceManager}
+ * object for any {@link CanReleaseReferences @CanReleaseReferences}-annotated scope {@code Foo}
+ * anywhere in your component hierarchy.
+ *
+ * <p>It can also provide a {@code Set<ReleasableReferenceManager>} that contains all such objects.
+ *
+ * <p>Each provider in the {@link CanReleaseReferences @CanReleaseReferences} {@link #scope()} can
+ * be in any one of four states at a time:
+ *
+ * <ul>
+ *   <li>In <b>uninitialized</b> state, the provider's strong reference and its {@link
+ *       WeakReference} are both {@code null}.
+ *   <li>In <b>cleared</b> state, the provider's strong reference is {@code null}, and its {@link
+ *       WeakReference}'s value is {@code null}.
+ *   <li>In <b>strong-reference</b> state, the provider's strong reference refers to the cached
+ *       value, and its {@link WeakReference} is {@code null}.
+ *   <li>In <b>weak-reference</b> state, the provider's strong reference is {@code null}, and its
+ *       {@link WeakReference}'s value is not {@code null}.
+ * </ul>
+ *
+ * <p>All providers within {@link #scope()} start in <b>uninitialized</b> state.
+ *
+ * <p>Calling {@link Provider#get()} on a provider within {@link #scope()} transitions it to
+ * <b>strong-reference</b> state if it was in <b>uninitialized</b> or <b>empty</b> state.
+ *
+ * <p>{@link #releaseStrongReferences()} transitions all providers within {@link #scope()} that are
+ * in <b>strong-reference</b> state to <b>weak-reference</b> state.
+ *
+ * <p>{@link #restoreStrongReferences()} transitions all providers within {@link #scope()} that are
+ * in <b>weak-reference</b> state to <b>strong-reference</b> state.
+ *
+ * <p>If garbage collection clears the {@link WeakReference} for any provider within {@link
+ * #scope()} that is in <b>weak-reference</b> state, that provider transitions to <b>cleared</b>
+ * state.
+ *
+ * <p><img src="doc-files/ReleasableReferenceManager-statemachine.png"
+ * alt="ReleasableReferenceManager state machine">
+ *
+ * <p>This interface is implemented by Dagger.
+ *
+ * @since 2.8
+ */
+@Beta
+@GwtIncompatible
+public interface ReleasableReferenceManager {
+
+  /** The scope whose references are managed by this object. */
+  Class<? extends Annotation> scope();
+
+  /**
+   * Releases the strong references held by all providers in this {@linkplain #scope() scope} to the
+   * objects previously returned by {@link Provider#get()}, leaving only {@link WeakReference}s.
+   *
+   * <p>If any such {@link WeakReference} is cleared during garbage collection, the next call to
+   * that {@link Provider#get()} will execute the underlying binding again, and the provider will
+   * hold a strong reference to the new returned value.
+   *
+   * <p>Calls to {@link Provider#get()} on any such provider return the weakly-referenced object
+   * until the {@link WeakReference} is cleared or {@link #restoreStrongReferences()} is called.
+   */
+  void releaseStrongReferences();
+
+  /**
+   * Restores strong references for all providers in this {@linkplain #scope() scope} that were
+   * previously {@linkplain #releaseStrongReferences() released} but whose {@link WeakReference} has
+   * not yet been cleared during garbage collection.
+   */
+  void restoreStrongReferences();
+}
diff --git a/core/src/main/java/dagger/releasablereferences/TypedReleasableReferenceManager.java b/core/src/main/java/dagger/releasablereferences/TypedReleasableReferenceManager.java
new file mode 100644
index 000000000..aa067c5bb
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/TypedReleasableReferenceManager.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.releasablereferences;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import java.lang.annotation.Annotation;
+
+/**
+ * A {@link ReleasableReferenceManager} for a scope that is annotated with an annotation that itself
+ * is annotated with {@link CanReleaseReferences}. That annotation is available as {@link
+ * #metadata()} and may be useful at runtime to decide when to release references held by the scope.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   {@literal @CanReleaseReferences}
+ *   public {@literal @interface} SomeAnnotation {
+ *     int value();
+ *   }
+ *
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @SomeAnnotation}(15)
+ *   {@literal @Scope}
+ *   public {@literal @interface} MyScope {}
+ *
+ *   // In a component that is (or has a subcomponent) annotated with {@literal @MyScope}:
+ *   {@literal @Inject}
+ *   void manager(
+ *       {@literal @ForReferenceReleasingScope(MyScope.class)}
+ *       {@literal TypedReferenceReleasingScope<SomeAnnotation>} manager) {
+ *     manager.metadata().value(); // returns 15
+ *   }</pre>
+ *
+ * <p>This interface is implemented by Dagger.
+ *
+ * @param <M> the type of the metadata annotation
+ */
+@Beta
+@GwtIncompatible
+public interface TypedReleasableReferenceManager<M extends Annotation>
+    extends ReleasableReferenceManager {
+
+  /**
+   * Returns the annotation on {@link #scope()} that is annotated with {@link CanReleaseReferences}.
+   */
+  M metadata();
+}
diff --git a/core/src/main/java/dagger/releasablereferences/doc-files/ReleasableReferenceManager-statemachine.png b/core/src/main/java/dagger/releasablereferences/doc-files/ReleasableReferenceManager-statemachine.png
new file mode 100644
index 000000000..6400f1d23
Binary files /dev/null and b/core/src/main/java/dagger/releasablereferences/doc-files/ReleasableReferenceManager-statemachine.png differ
diff --git a/core/src/main/java/dagger/releasablereferences/package-info.java b/core/src/main/java/dagger/releasablereferences/package-info.java
new file mode 100644
index 000000000..a306bdbdc
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/package-info.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This package contains the API by which Dagger allows you <a
+ * href="https://google.github.io/dagger/users-guide.html#releasable-references">release references</a> held within
+ * some scopes.
+ *
+ * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
+ * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
+ *
+ * @since 2.8
+ */
+package dagger.releasablereferences;
diff --git a/core/src/test/java/dagger/internal/DoubleCheckTest.java b/core/src/test/java/dagger/internal/DoubleCheckTest.java
index 494c86cc5..6fb8cae3e 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.Uninterruptibles;
 
-import co.touchlab.doppl.testing.DopplHacks;
 import co.touchlab.doppl.utils.PlatformUtils;
 import dagger.Lazy;
 import java.util.List;
@@ -36,10 +39,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assert_;
-import static org.junit.Assert.fail;
-
 @RunWith(JUnit4.class)
 public class DoubleCheckTest {
   @Test
@@ -61,13 +60,7 @@ public void lazy_nullPointerException() {
   }
 
   private static final Provider<Object> DOUBLE_CHECK_OBJECT_PROVIDER =
-      DoubleCheck.provider(
-          new Provider<Object>() {
-            @Override
-            public Object get() {
-              return new Object();
-            }
-          });
+      DoubleCheck.provider(Object::new);
 
   @Test
   public void doubleWrapping_provider() {
@@ -93,23 +86,20 @@ public void get() throws Exception {
     List<Callable<Object>> tasks = Lists.newArrayListWithCapacity(numThreads);
     for (int i = 0; i < numThreads; i++) {
       tasks.add(
-          new Callable<Object>() {
-            @Override
-            public Object call() throws Exception {
-              latch.countDown();
-              return lazy.get();
-            }
+          () -> {
+            latch.countDown();
+            return lazy.get();
           });
     }
 
     List<Future<Object>> futures = executor.invokeAll(tasks);
 
-    assert_().that(provider.provisions.get()).isEqualTo(1);
+    assertThat(provider.provisions.get()).isEqualTo(1);
     Set<Object> results = Sets.newIdentityHashSet();
     for (Future<Object> future : futures) {
       results.add(future.get());
     }
-    assert_().that(results.size()).isEqualTo(1);
+    assertThat(results).hasSize(1);
   }
 
   private static class LatchedProvider implements Provider<Object> {
@@ -131,19 +121,12 @@ public Object get() {
     }
   }
 
-  @Test
-  @DopplHacks//No stack overflow
-  public void reentranceWithoutCondition_throwsStackOverflow() {
+  @Test public void reentranceWithoutCondition_throwsStackOverflow() {
     if(PlatformUtils.isJ2objc())
       return;
     final AtomicReference<Provider<Object>> doubleCheckReference =
-        new AtomicReference<Provider<Object>>();
-    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
-      @Override
-      public Object get() {
-        return doubleCheckReference.get().get();
-      }
-    });
+        new AtomicReference<>();
+    Provider<Object> doubleCheck = DoubleCheck.provider(() -> doubleCheckReference.get().get());
     doubleCheckReference.set(doubleCheck);
     try {
       doubleCheck.get();
@@ -153,39 +136,39 @@ public Object get() {
 
   @Test public void reentranceReturningSameInstance() {
     final AtomicReference<Provider<Object>> doubleCheckReference =
-        new AtomicReference<Provider<Object>>();
+        new AtomicReference<>();
     final AtomicInteger invocationCount = new AtomicInteger();
     final Object object = new Object();
-    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
-     @Override
-      public Object get() {
-         if (invocationCount.incrementAndGet() == 1) {
-          doubleCheckReference.get().get();
-        }
-        return object;
-      }
-    });
+    Provider<Object> doubleCheck = DoubleCheck.provider(() -> {
+        if (invocationCount.incrementAndGet() == 1) {
+         doubleCheckReference.get().get();
+       }
+       return object;
+     });
     doubleCheckReference.set(doubleCheck);
     assertThat(doubleCheck.get()).isSameAs(object);
   }
 
   @Test public void reentranceReturningDifferentInstances_throwsIllegalStateException() {
     final AtomicReference<Provider<Object>> doubleCheckReference =
-        new AtomicReference<Provider<Object>>();
+        new AtomicReference<>();
     final AtomicInteger invocationCount = new AtomicInteger();
-    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
-     @Override
-      public Object get() {
-        if (invocationCount.incrementAndGet() == 1) {
-          doubleCheckReference.get().get();
-        }
-        return new Object();
-      }
-    });
+    Provider<Object> doubleCheck = DoubleCheck.provider(() -> {
+       if (invocationCount.incrementAndGet() == 1) {
+         doubleCheckReference.get().get();
+       }
+       return new Object();
+     });
     doubleCheckReference.set(doubleCheck);
     try {
       doubleCheck.get();
       fail();
     } catch (IllegalStateException expected) {}
   }
+
+  @Test
+  public void instanceFactoryAsLazyDoesNotWrap() {
+    Factory<Object> factory = InstanceFactory.create(new Object());
+    assertThat(DoubleCheck.lazy(factory)).isSameAs(factory);
+  }
 }
diff --git a/core/src/test/java/dagger/internal/InstanceFactoryTest.java b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
index acaf20d79..82b66e687 100644
--- a/core/src/test/java/dagger/internal/InstanceFactoryTest.java
+++ b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,30 +13,31 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
-import org.junit.Rule;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
-
 @RunWith(JUnit4.class)
 public final class InstanceFactoryTest {
-  @Rule public final ExpectedException thrown = ExpectedException.none();
-
   @Test public void instanceFactory() {
     Object instance = new Object();
     Factory<Object> factory = InstanceFactory.create(instance);
-    assert_().that(factory.get()).isEqualTo(instance);
-    assert_().that(factory.get()).isEqualTo(instance);
-    assert_().that(factory.get()).isEqualTo(instance);
+    assertThat(factory.get()).isEqualTo(instance);
+    assertThat(factory.get()).isEqualTo(instance);
+    assertThat(factory.get()).isEqualTo(instance);
   }
 
   @Test public void create_throwsNullPointerException() {
-    thrown.expect(NullPointerException.class);
-    InstanceFactory.create(null);
+    try {
+      InstanceFactory.create(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
   }
 }
diff --git a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
index b4496e926..5598ff223 100644
--- a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
+++ b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -25,8 +28,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
-
 @RunWith(JUnit4.class)
 @SuppressWarnings("unchecked")
 public class MapProviderFactoryTest {
@@ -62,25 +63,18 @@ public void iterationOrder() {
         .put("four", p4)
         .build();
 
-    Map<String, Provider<Integer>> expectedMap = new LinkedHashMap<String, Provider<Integer>>();
+    Map<String, Provider<Integer>> expectedMap = new LinkedHashMap<>();
     expectedMap.put("two", p2);
     expectedMap.put("one", p1);
     expectedMap.put("three", p3);
     expectedMap.put("one", p5);
     expectedMap.put("four", p4);
-    assert_()
-        .that(factory.get().entrySet())
+    assertThat(factory.get().entrySet())
         .containsExactlyElementsIn(expectedMap.entrySet())
         .inOrder();
   }
 
   private static Provider<Integer> incrementingIntegerProvider(int seed) {
-    final AtomicInteger value = new AtomicInteger(seed);
-    return new Provider<Integer>() {
-      @Override
-      public Integer get() {
-        return value.getAndIncrement();
-      }
-    };
+    return new AtomicInteger(seed)::getAndIncrement;
   }
 }
diff --git a/core/src/test/java/dagger/internal/SetBuilderTest.java b/core/src/test/java/dagger/internal/SetBuilderTest.java
new file mode 100644
index 000000000..ac7831234
--- /dev/null
+++ b/core/src/test/java/dagger/internal/SetBuilderTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static org.junit.Assert.fail;
+
+import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class SetBuilderTest {
+  private SetBuilder<String> setBuilder;
+
+  @Before
+  public void setUp() {
+    setBuilder = SetBuilder.newSetBuilder(1);
+  }
+
+  @Test
+  public void addNull() {
+    try {
+      setBuilder.add(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test
+  public void addNullCollection() {
+    try {
+      setBuilder.addAll(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test
+  public void addNullElement() {
+    try {
+      setBuilder.addAll(Arrays.asList("hello", null, "world"));
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+}
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
index af7cb99bf..0032578c6 100644
--- a/core/src/test/java/dagger/internal/SetFactoryTest.java
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.collect.ImmutableSet;
 import java.util.Arrays;
 import java.util.LinkedHashSet;
@@ -27,8 +30,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 @SuppressWarnings("unchecked")
 public class SetFactoryTest {
@@ -37,7 +38,7 @@
   @Test
   public void providerReturnsNull() {
     Factory<Set<Integer>> factory =
-        SetFactory.<Integer>builder(0, 1).addCollectionProvider(providerOf((Set<Integer>) null)).build();
+        SetFactory.<Integer>builder(0, 1).addCollectionProvider(() -> null).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
@@ -45,16 +46,16 @@ public void providerReturnsNull() {
   @Test
   public void providerReturnsNullSet() {
     Factory<Set<Integer>> factory =
-        SetFactory.<Integer>builder(1, 0).addProvider(providerOf((Integer) null)).build();
+        SetFactory.<Integer>builder(1, 0).addProvider(() -> null).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
 
   @Test
   public void providerReturnsSetWithNullElement() {
-    Set<Integer> set = new LinkedHashSet<Integer>(Arrays.asList(1, null, 3));
+    Set<Integer> set = new LinkedHashSet<>(Arrays.asList(1, null, 3));
     Factory<Set<Integer>> factory =
-        SetFactory.<Integer>builder(0, 1).addCollectionProvider(providerOf(set)).build();
+        SetFactory.<Integer>builder(0, 1).addCollectionProvider(() -> set).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
@@ -73,32 +74,13 @@ public void invokesProvidersEveryTime() {
     assertThat(factory.get()).containsExactly(2, 12, 24, 25, 34, 35);
   }
 
-  private static <T> Provider<T> providerOf(final T value) {
-    return new Provider<T>() {
-      @Override
-      public T get() {
-        return value;
-      }
-    };
-  }
-
   private static Provider<Integer> incrementingIntegerProvider(int seed) {
     final AtomicInteger value = new AtomicInteger(seed);
-    return new Provider<Integer>() {
-      @Override
-      public Integer get() {
-        return value.getAndIncrement();
-      }
-    };
+    return value::getAndIncrement;
   }
 
   private static Provider<Set<Integer>> incrementingIntegerSetProvider(int seed) {
     final AtomicInteger value = new AtomicInteger(seed);
-    return new Provider<Set<Integer>>() {
-      @Override
-      public Set<Integer> get() {
-        return ImmutableSet.of(value.getAndIncrement(), value.getAndIncrement());
-      }
-    };
+    return () -> ImmutableSet.of(value.getAndIncrement(), value.getAndIncrement());
   }
 }
diff --git a/core/src/test/java/dagger/internal/SingleCheckTest.java b/core/src/test/java/dagger/internal/SingleCheckTest.java
index 3bc2075cf..0c043fd4c 100644
--- a/core/src/test/java/dagger/internal/SingleCheckTest.java
+++ b/core/src/test/java/dagger/internal/SingleCheckTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+
+import java.util.concurrent.atomic.AtomicInteger;
 import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 /**
  * Tests {@link SingleCheck}.
  */
@@ -34,16 +36,8 @@ public void create_nullPointerException() {
 
   @Test
   public void get() {
-    Provider<Integer> provider =
-        SingleCheck.provider(
-            new Factory<Integer>() {
-              int i = 0;
-
-              @Override
-              public Integer get() {
-                return i++;
-              }
-            });
+    AtomicInteger integer = new AtomicInteger();
+    Provider<Integer> provider = SingleCheck.provider(integer::getAndIncrement);
     assertThat(provider.get()).isEqualTo(0);
     assertThat(provider.get()).isEqualTo(0);
     assertThat(provider.get()).isEqualTo(0);
