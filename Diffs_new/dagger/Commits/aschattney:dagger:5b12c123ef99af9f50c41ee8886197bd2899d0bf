diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java b/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java
index 6918182f4..99ca16dde 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java
@@ -1,20 +1,58 @@
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.CodeBlock;
+import dagger.Component;
+import dagger.Subcomponent;
+
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import java.util.List;
 
 public class BuilderStatement implements InitializationStatement {
 
-    private ComponentDescriptor componentDescriptor;
+    private ComponentDescriptor descriptor;
+    private ComponentDescriptor parentDescriptor;
+    private ExecutableElement providingMethod;
 
-    public BuilderStatement(ComponentDescriptor componentDescriptor) {
-        this.componentDescriptor = componentDescriptor;
+    public BuilderStatement(ComponentDescriptor descriptor, ComponentDescriptor parentDescriptor, ExecutableElement providingMethod) {
+        this.descriptor = descriptor;
+        this.parentDescriptor = parentDescriptor;
+        this.providingMethod = providingMethod;
     }
 
     @Override
     public CodeBlock get() {
-        return CodeBlock.of("$T.builder()", Util.getDaggerComponentClassName(componentDescriptor.componentDefinitionType()));
+        if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            final List<? extends VariableElement> parameters = providingMethod.getParameters();
+            for (VariableElement parameter : parameters) {
+                final TypeElement element = MoreTypes.asTypeElement(parameter.asType());
+                if (isComponentOrSubcomponent(element)) {
+                    final ImmutableSet<ComponentDescriptor.ComponentMethodDescriptor> componentMethodDescriptors = parentDescriptor.componentMethods();
+                    for (ComponentDescriptor.ComponentMethodDescriptor componentMethodDescriptor : componentMethodDescriptors) {
+                        final ExecutableElement executableElement = componentMethodDescriptor.methodElement();
+                        TypeMirror typeToSearch = descriptor.componentDefinitionType().asType();
+                        if (descriptor.builderSpec().isPresent()) {
+                            typeToSearch = descriptor.builderSpec().get().builderDefinitionType().asType();
+                        }
+                        if (executableElement.getReturnType().toString().equals(typeToSearch.toString())) {
+                            return CodeBlock.of("$L.$L()", parameter.getSimpleName().toString(), executableElement.getSimpleName().toString());
+                        }
+                    }
+                }
+            }
+        }
+        return CodeBlock.of("$T.builder()", Util.getDaggerComponentClassName(descriptor.componentDefinitionType()));
     }
 
+    private boolean isComponentOrSubcomponent(TypeElement element) {
+        return MoreElements.isAnnotationPresent(element, Component.class) || MoreElements.isAnnotationPresent(element, Subcomponent.class);
+    }
 
 
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java b/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java
new file mode 100644
index 000000000..53cefe955
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java
@@ -0,0 +1,45 @@
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+
+import javax.lang.model.element.Modifier;
+
+import java.util.HashMap;
+
+import static dagger.internal.codegen.Util.bindingSupportsTestDelegate;
+import static dagger.internal.codegen.Util.getDelegateTypeName;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+public class DelegateInitialization implements InitializationStatement {
+
+    private final BindingGraph graph;
+
+    public DelegateInitialization(BindingGraph graph) {
+        this.graph = graph;
+    }
+
+    @Override
+    public CodeBlock get() {
+        final CodeBlock.Builder codeBuilder = CodeBlock.builder();
+        try {
+            HashMap<Key, String> delegateFieldNames = new HashMap<>();
+            for (ResolvedBindings resolvedBindings : graph.resolvedBindings().values()) {
+                ContributionBinding binding = resolvedBindings.contributionBinding();
+                if (bindingSupportsTestDelegate(binding)) {
+                    final String delegateFieldName = Util.getDelegateFieldName(resolvedBindings.binding().key());
+                    final ClassName delegateType = getDelegateTypeName(resolvedBindings.binding().key());
+                    delegateFieldNames.put(resolvedBindings.key(), delegateFieldName);
+                    final String methodName = "with" + delegateType.simpleName();
+                    codeBuilder.add(".$L($L)", methodName, delegateFieldName);
+                }
+            }
+        }catch(Exception e) {}
+        return codeBuilder.build();
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
index f90f12982..b89dec567 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
@@ -45,13 +45,6 @@ ClassName nameGeneratedType(DI input) {
         Map<Key, String> delegateFieldNames = new HashMap<>();
         Map<Key, ComponentDescriptor> componentDescriptors = new HashMap<>();
         for (InjectorType injectorType : input.getInjectorTypes()) {
-            injectorType.getBindingGraph().resolvedBindings().values().forEach(resolvedBindings -> {
-                if (resolvedBindings.bindingType() == BindingType.PROVISION) {
-                    if (!delegateFieldNames.containsKey(resolvedBindings.key())) {
-                        createDelegateFieldAndMethod(generatedTypeName, builder, resolvedBindings, delegateFieldNames);
-                    }
-                }
-            });
             final Key key = Key.builder(injectorType.getElement().asType()).build();
             componentDescriptors.put(key, injectorType.getComponentDescriptor());
         }
@@ -59,32 +52,8 @@ ClassName nameGeneratedType(DI input) {
         final Map<TypeElement, ProvidingMethodOverrider> methods = input.getMethods();
         for (Map.Entry<TypeElement, ProvidingMethodOverrider> entry : methods.entrySet()) {
             final ProvidingMethodOverrider overrider = entry.getValue();
-            final MethodSpec.Builder methodSpec = MethodSpec.overriding(overrider.getExecutableElement());
-            final List<InitializationStatement> statements = overrider.getStatements();
-            final CodeBlock.Builder codeBuilder = CodeBlock.builder();
-            for (InitializationStatement statement : statements) {
-                codeBuilder.add(statement.get());
-            }
-            methodSpec.addStatement("return $L", codeBuilder.build());
-            builder.addMethod(methodSpec.build());
+            overrider.process(builder, generatedTypeName, delegateFieldNames);
         }
-            /*final MethodSpec.Builder method = MethodSpec.overriding(executableElement);
-            final List<? extends VariableElement> parameters = executableElement.getParameters();
-            Map<Key, VariableElement> map = new HashMap<>();
-            for (VariableElement parameter : parameters) {
-                map.put(Key.builder(parameter.asType()).build(), parameter);
-            }
-            final Key key = Key.builder(executableElement.getReturnType()).build();
-            final ComponentDescriptor componentDescriptor = componentDescriptors.get(key);
-            final CodeBlock.Builder codeBuilder = CodeBlock.builder();
-            codeBuilder.add("$T", Util.getDaggerComponentClassName(componentDescriptor.componentDefinitionType())).add(".builder().");
-            for (ModuleDescriptor moduleDescriptor : componentDescriptor.modules()) {
-                final TypeElement element = moduleDescriptor.moduleElement();
-                codeBuilder.add(Util.lowerCaseFirstLetter(element.getSimpleName().toString()));
-            }
-            codeBuilder.add(".build()");
-            method.addStatement("return $L", codeBuilder.build());
-            builder.addMethod(method.build());*/
 
         return Optional.of(builder);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
index 4c03e5a7e..9cd5e56e1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
@@ -6,11 +6,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
-import dagger.Component;
-import dagger.Injector;
-import dagger.ProvidesComponent;
-import dagger.ProvidesModule;
-import dagger.internal.Preconditions;
+import dagger.*;
 
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
@@ -36,6 +32,7 @@
     private final ComponentDescriptor.Factory componentDescriptorFactory;
     private Map<TypeElement, ExecutableElement> componentMethodMap;
     private Map<TypeElement, ExecutableElement> moduleMethodMap;
+    private Map<TypeElement, ExecutableElement> subcomponentMethodMap;
 
     public InjectorProcessingStep(Types types, Messager messager, InjectorGenerator injectorGenerator, ComponentDescriptor.Kind component, BindingGraph.Factory bindingGraphFactory, ComponentDescriptor.Factory componentDescriptorFactory) {
         this.types = types;
@@ -48,7 +45,7 @@ public InjectorProcessingStep(Types types, Messager messager, InjectorGenerator
 
     @Override
     public Set<? extends Class<? extends Annotation>> annotations() {
-        return ImmutableSet.of(ProvidesComponent.class, ProvidesModule.class, Injector.class, Component.class);
+        return ImmutableSet.of(ProvidesComponent.class, ProvidesSubcomponent.class, ProvidesModule.class, Injector.class, Component.class);
     }
 
     @Override
@@ -61,10 +58,13 @@ public InjectorProcessingStep(Types types, Messager messager, InjectorGenerator
         TypeElement injector = MoreElements.asType(it.next());
 
         this.moduleMethodMap =
-                this.buildProvideModuleMethodMap(elementsByAnnotation.get(ProvidesModule.class));
+                this.buildProvideMethodMap(elementsByAnnotation.get(ProvidesModule.class));
+
+        this.subcomponentMethodMap =
+                this.buildProvideMethodMap(elementsByAnnotation.get(ProvidesSubcomponent.class));
 
         this.componentMethodMap =
-                this.buildProvideModuleMethodMap(elementsByAnnotation.get(ProvidesComponent.class));
+                this.buildProvideMethodMap(elementsByAnnotation.get(ProvidesComponent.class));
 
         final Map<TypeElement, ProvidingMethodOverrider> componentOverriderMap =
                 this.buildProvideComponentMethodMap(elementsByAnnotation.get(ProvidesComponent.class), injector);
@@ -87,7 +87,7 @@ public InjectorProcessingStep(Types types, Messager messager, InjectorGenerator
         return rejectedElements;
     }
 
-    private Map<TypeElement, ExecutableElement> buildProvideModuleMethodMap(Set<Element> elements) {
+    private Map<TypeElement, ExecutableElement> buildProvideMethodMap(Set<Element> elements) {
         return elements.stream()
                 .map(element -> (ExecutableElement) element)
                 .collect(Collectors.toMap(p -> MoreTypes.asTypeElement(p.getReturnType()), Function.identity()));
@@ -103,8 +103,29 @@ private ProvidingMethodOverrider createOverrider(Element element, TypeElement in
         ExecutableElement executableElement = (ExecutableElement) element;
         final TypeElement component = MoreTypes.asTypeElement(executableElement.getReturnType());
         final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
-        List<InitializationStatement> statements = this.createInitializationsStatements(injector, descriptor, this.componentMethodMap, this.moduleMethodMap, toParameterMap(executableElement.getParameters()));
-        return new ProvidingMethodOverrider(component, descriptor, executableElement, statements);
+        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
+        List<InitializationStatement> statements = this.createInitializationsStatements(injector, descriptor, null, this.moduleMethodMap, executableElement, bindingGraph);
+        final ProvidingMethodOverrider componentMethodOverrider = new ProvidingMethodOverrider(component, descriptor, executableElement, statements, bindingGraph);
+        findSubcomponentsToOverride(injector, descriptor, componentMethodOverrider);
+        return componentMethodOverrider;
+    }
+
+    private void findSubcomponentsToOverride(TypeElement injector, ComponentDescriptor descriptor, ProvidingMethodOverrider componentMethodOverrider) {
+        final ImmutableSet<ComponentDescriptor> subcomponents = descriptor.subcomponents();
+        for (ComponentDescriptor subcomponentDescriptor : subcomponents) {
+            final ExecutableElement e = this.subcomponentMethodMap.get(subcomponentDescriptor.componentDefinitionType());
+            if (e == null) {
+                continue;
+            }
+            final TypeElement subcomponentType = MoreTypes.asTypeElement(e.getReturnType());
+            final BindingGraph bindingGraph = bindingGraphFactory.create(subcomponentDescriptor);
+            List<InitializationStatement> s =
+                    this.createInitializationsStatements(injector, subcomponentDescriptor, descriptor, this.moduleMethodMap, e, bindingGraph);
+            final ProvidingMethodOverrider subcomponentOverrider =
+                    new ProvidingMethodOverrider(subcomponentType, subcomponentDescriptor, e, s, bindingGraph);
+            componentMethodOverrider.add(subcomponentOverrider);
+            this.findSubcomponentsToOverride(injector, subcomponentDescriptor, subcomponentOverrider);
+        }
     }
 
     private Map<Key, VariableElement> toParameterMap(List<? extends VariableElement> parameters) {
@@ -114,13 +135,17 @@ private ProvidingMethodOverrider createOverrider(Element element, TypeElement in
 
     private List<InitializationStatement> createInitializationsStatements(TypeElement injector,
                                                                           ComponentDescriptor componentDescriptor,
-                                                                          Map<TypeElement, ExecutableElement> componentMethodMap,
+                                                                          ComponentDescriptor parentDescriptor,
                                                                           Map<TypeElement, ExecutableElement> moduleMethodMap,
-                                                                          Map<Key, VariableElement> providedParams) {
+                                                                          ExecutableElement providingMethod,
+                                                                          BindingGraph bindingGraph) {
+
+        Map<Key, VariableElement> providedParams = toParameterMap(providingMethod.getParameters());
         return ImmutableList.of(
-                new BuilderStatement(componentDescriptor),
+                new BuilderStatement(componentDescriptor, parentDescriptor, providingMethod),
                 new ComponentStatement(this.types, injector, componentDescriptorFactory, componentDescriptor, providedParams),
                 new ModuleStatement(this.types, injector, componentDescriptor, moduleMethodMap, providedParams),
+                new DelegateInitialization(bindingGraph),
                 new FinishBuilderStatement()
         );
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 4b8c07b80..d7535662f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -57,6 +57,8 @@
 import dagger.releasablereferences.ForReleasableReferences;
 import dagger.releasablereferences.ReleasableReferenceManager;
 import dagger.releasablereferences.TypedReleasableReferenceManager;
+
+import java.io.Serializable;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Executor;
@@ -83,10 +85,10 @@
  * @author Gregory Kick
  */
 @AutoValue
-abstract class Key {
+abstract class Key implements Serializable{
 
   /** An object that is associated with a {@link Key}. */
-  interface HasKey {
+  interface HasKey extends Serializable {
     /** The key associated with this object. */
     Key key();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java b/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java
index c7402f531..c48ae0423 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java
@@ -1,6 +1,7 @@
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.Injector;
 import dagger.internal.Preconditions;
@@ -48,44 +49,57 @@ public CodeBlock get() {
         final ImmutableSet<ModuleDescriptor> modules = descriptor.modules();
         for (ModuleDescriptor moduleDescriptor : modules) {
             final TypeElement moduleElement = moduleDescriptor.moduleElement();
-            if (!moduleMethodMap.keySet().contains(moduleElement))
-                throw new IllegalStateException(moduleMethodMap.entrySet().toString() + " | " + moduleElement.toString());
             final ExecutableElement method = moduleMethodMap.get(moduleElement);
-            if (method == null) {
-                throw new IllegalStateException("method is null in moduleMethodMap in ModuleStatement");
+            Map<Key, VariableElement> parameterMap;
+            if (method != null) {
+                parameterMap = buildParameterMapWithProvidingModuleMethod(method);
+            }else {
+                parameterMap = getConstructorParameterMap(moduleElement);
             }
-            final HashMap<String, ExecutableElement> providingMethods = Util.findProvidingMethods(types, injector);
-            final ExecutableElement providingModuleMethod = providingMethods.get(moduleElement.toString());
-            if (providingModuleMethod == null) {
-                throw new IllegalStateException("providingModuleMethod is null in providingMethods in ModuleStatement");
-            }
-            //final Map<Key, VariableElement> constructorParameterMap = getConstructorParameterMap(moduleElement);
-            final Map<Key, VariableElement> parameterMap = getMethodParameterMap(providingModuleMethod);
             final List<CodeBlock> arguments = new ArrayList<>();
-            //if (!constructorParameterMap.isEmpty() || !providedParams.isEmpty())
-            //throw new IllegalStateException(constructorParameterMap.entrySet().toString() + " | "+ providedParams.entrySet().toString());
             for (Map.Entry<Key, VariableElement> entry : parameterMap.entrySet()) {
                 if (resolvesToInjectorType(entry)) {
-                    arguments.add(CodeBlock.of("$L", CodeBlock.of("this")));
-                }else {
+                    arguments.add(CodeBlock.of("$L", "this"));
+                } else {
                     final VariableElement variableElement = providedParams.get(entry.getKey());
                     if (variableElement == null) {
-                        throw new IllegalStateException("parameter is null in providedParams in ModuleStatement");
+                        throw new IllegalStateException("parameter is null in providedParams in ModuleStatement for param:" + entry.getValue().asType().toString() + " in module: " + moduleElement.getSimpleName().toString());
                     }
-                    arguments.add(CodeBlock.of("$L", CodeBlock.of(variableElement.getSimpleName().toString())));
+                    arguments.add(CodeBlock.of("$L", variableElement.getSimpleName().toString()));
                 }
             }
-            codeBuilder.add(".$L(this.$L($L))",
-                    CodeBlock.of(method.getSimpleName().toString()),
-                    CodeBlock.of(providingModuleMethod.getSimpleName().toString()),
-                    makeParametersCodeBlock(arguments));
+
+            String methodName = Util.lowerCaseFirstLetter(moduleElement.getSimpleName().toString());
+
+            if (descriptor.builderSpec().isPresent()) {
+                final ExecutableElement executableElement = descriptor.builderSpec().get().methodMap().get(moduleElement);
+                methodName = executableElement.getSimpleName().toString();
+            }
+
+            if (method != null) {
+                codeBuilder.add(".$L(this.$L($L))",
+                        methodName,
+                        method.getSimpleName().toString(),
+                        makeParametersCodeBlock(arguments)
+                );
+            }else {
+                codeBuilder.add(".$L(new $T($L))",
+                        methodName,
+                        ClassName.get(moduleElement),
+                        makeParametersCodeBlock(arguments)
+                );
+            }
         }
         return codeBuilder.build();
     }
 
+    private Map<Key, VariableElement> buildParameterMapWithProvidingModuleMethod(ExecutableElement providingModuleMethod) {
+        return getMethodParameterMap(providingModuleMethod);
+    }
+
     private boolean resolvesToInjectorType(Map.Entry<Key, VariableElement> entry) {
         final TypeMirror type = entry.getKey().type();
-        return types.isAssignable(type, injector.asType());
+        return types.isAssignable(injector.asType(), type);
     }
 
     private Map<Key, VariableElement> getMethodParameterMap(ExecutableElement element) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java b/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java
index cd660922d..f2e18eb0d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java
@@ -1,10 +1,17 @@
 package dagger.internal.codegen;
 
-import dagger.Component;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
 
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
+
+import static dagger.internal.codegen.Util.createDelegateFieldAndMethod;
 
 /**
  * Created by Andy on 06.05.2017.
@@ -15,12 +22,15 @@
     private final ComponentDescriptor descriptor;
     private final ExecutableElement executableElement;
     private List<InitializationStatement> statements;
+    private BindingGraph bindingGraph;
+    private List<ProvidingMethodOverrider> subcomponentOverriders = new ArrayList<>();
 
-    public ProvidingMethodOverrider(TypeElement component, ComponentDescriptor descriptor, ExecutableElement executableElement, List<InitializationStatement> statements) {
+    public ProvidingMethodOverrider(TypeElement component, ComponentDescriptor descriptor, ExecutableElement executableElement, List<InitializationStatement> statements, BindingGraph bindingGraph) {
         this.component = component;
         this.descriptor = descriptor;
         this.executableElement = executableElement;
         this.statements = statements;
+        this.bindingGraph = bindingGraph;
     }
 
     public TypeElement getComponent() {
@@ -38,4 +48,35 @@ public ExecutableElement getExecutableElement() {
     public List<InitializationStatement> getStatements() {
         return statements;
     }
+
+    public void add(ProvidingMethodOverrider providingMethodOverrider) {
+        subcomponentOverriders.add(providingMethodOverrider);
+    }
+
+    public void process(TypeSpec.Builder builder, ClassName generatedTypeName, Map<Key, String> delegateFieldNames) {
+        for (ProvidingMethodOverrider subcomponentOverrider : subcomponentOverriders) {
+            subcomponentOverrider.process(builder, generatedTypeName, delegateFieldNames);
+        }
+
+        this.getBindingGraph().resolvedBindings().values().forEach(resolvedBindings -> {
+            if (!resolvedBindings.isEmpty() && resolvedBindings.bindingType() == BindingType.PROVISION) {
+                if (!delegateFieldNames.containsKey(resolvedBindings.key())) {
+                    createDelegateFieldAndMethod(generatedTypeName, builder, resolvedBindings, delegateFieldNames);
+                }
+            }
+        });
+
+        final MethodSpec.Builder methodSpec = MethodSpec.overriding(this.getExecutableElement());
+        final List<InitializationStatement> statements = this.getStatements();
+        final CodeBlock.Builder codeBuilder = CodeBlock.builder();
+        for (InitializationStatement statement : statements) {
+            codeBuilder.add(statement.get());
+        }
+        methodSpec.addStatement("return $L", codeBuilder.build());
+        builder.addMethod(methodSpec.build());
+    }
+
+    public BindingGraph getBindingGraph() {
+        return bindingGraph;
+    }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index d55fadcd6..26fb05282 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -116,7 +116,7 @@ private ExecutableType resolvedSubcomponentFactoryMethod() {
 
   @Override
   protected void decorateComponent() {
-    component.addModifiers(PRIVATE, FINAL);
+    component.addModifiers(PUBLIC, FINAL);
     addSupertype(
         component,
         MoreTypes.asTypeElement(
diff --git a/core/src/main/java/dagger/ProvidesSubcomponent.java b/core/src/main/java/dagger/ProvidesSubcomponent.java
new file mode 100644
index 000000000..7aeeceba9
--- /dev/null
+++ b/core/src/main/java/dagger/ProvidesSubcomponent.java
@@ -0,0 +1,13 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target(METHOD)
+@Documented
+public @interface ProvidesSubcomponent {}
diff --git a/core/src/main/java/dagger/Trigger.java b/core/src/main/java/dagger/Trigger.java
new file mode 100644
index 000000000..db560fa89
--- /dev/null
+++ b/core/src/main/java/dagger/Trigger.java
@@ -0,0 +1,15 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target(TYPE)
+@Documented
+public @interface Trigger {
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
index 421cf49e9..f7cccd484 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
@@ -48,7 +48,7 @@ public ApplicationComponent component() {
   @ProvidesComponent
   public AbstractActivityComponent activityComponent(Activity activity) {
     return DaggerAbstractActivityComponent.builder()
-            .activityModule(this.activityModule(activity))
+            .activityModule(new ActivityModule(activity))
             .applicationComponent(this.component())
             .build();
   }
@@ -58,13 +58,4 @@ public FragmentComponent fragmentComponent(AbstractActivityComponent component)
       return null;
   }
 
-  @ProvidesModule
-  public DemoApplicationModule demoApplicationModule() {
-    return new DemoApplicationModule(this);
-  }
-
-  @ProvidesModule
-  public ActivityModule activityModule(Activity activity) {
-    return new ActivityModule(activity);
-  }
 }
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
index 19b78a491..5803188cb 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
@@ -48,7 +48,7 @@
     super.onCreate();
     component = DaggerDemoApplication1_ApplicationComponent.builder()
         .androidModule(new AndroidModule(this))
-
+        .singletonModule(new SingletonModule())
         .build();
     component().inject(this); // As of now, LocationManager should be injected into this.
   }
@@ -58,13 +58,4 @@ public ApplicationComponent component() {
     return component;
   }
 
-  @ProvidesModule
-  public AndroidModule androidModule() {
-    return new AndroidModule(this);
-  }
-
-  @ProvidesModule
-  public SingletonModule singletonModule() {
-    return new SingletonModule();
-  }
 }
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index 44ea3253f..4afc9533f 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -13,14 +13,14 @@
   public interface Coffee {
     CoffeeMaker maker();
     Thermosiphon thermosiphon();
-    Bleu.Builder bleu();
+    Bleu.Builder any();
+    Bleu2.Builder bleu2();
   }
 
   @ActivityScope
   @Subcomponent(modules = {AModule.class})
   public interface Bleu {
     Integer integer();
-    Bleu2.Builder bleu2();
     @Subcomponent.Builder
     interface Builder {
       Builder requestModule(AModule module);
diff --git a/examples/simple/src/main/java/coffee/DependencyInjector.java b/examples/simple/src/main/java/coffee/DependencyInjector.java
index 880d31e4c..c137c29e6 100644
--- a/examples/simple/src/main/java/coffee/DependencyInjector.java
+++ b/examples/simple/src/main/java/coffee/DependencyInjector.java
@@ -3,6 +3,7 @@
 import dagger.Injector;
 import dagger.ProvidesComponent;
 import dagger.ProvidesModule;
+import dagger.ProvidesSubcomponent;
 
 
 @Injector
@@ -15,18 +16,17 @@
                 .build();
     }
 
-    @ProvidesModule
-    public AModule aModule() {
-        return new AModule();
-    }
-
-    @ProvidesModule
-    public BModule bModule() {
-        return new BModule();
+    @ProvidesSubcomponent
+    public CoffeeApp.Bleu bleu(CoffeeApp.Coffee coffee) {
+        return coffee.any()
+                .requestModule(new AModule())
+                .build();
     }
 
-    @ProvidesModule
-    public DripCoffeeModule dripCoffeeModule() {
-        return new DripCoffeeModule();
+    @ProvidesSubcomponent
+    public CoffeeApp.Bleu2 bleu2(CoffeeApp.Coffee bleu) {
+        return bleu.bleu2()
+                .requestModule(new BModule())
+                .build();
     }
 }
