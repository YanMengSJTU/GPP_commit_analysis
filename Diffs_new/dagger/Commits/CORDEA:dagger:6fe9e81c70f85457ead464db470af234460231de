diff --git a/java/dagger/internal/codegen/MethodBindingExpression.java b/java/dagger/internal/codegen/MethodBindingExpression.java
index 86b8787ae..d51fc9866 100644
--- a/java/dagger/internal/codegen/MethodBindingExpression.java
+++ b/java/dagger/internal/codegen/MethodBindingExpression.java
@@ -45,6 +45,17 @@ protected MethodBindingExpression(
 
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
+    if (request.frameworkType().isPresent()) {
+      // Initializing a framework instance that participates in a cycle requires that the underlying
+      // FrameworkInstanceBindingExpression is invoked in order for a cycle to be detected properly.
+      // When a MethodBindingExpression wraps a FrameworkInstanceBindingExpression, the wrapped
+      // expression will only be invoked once to implement the method body. This is a hack to work
+      // around that weirdness - methodImplementation.body() will invoke the framework instance
+      // initialization again in case the field is not fully initialized.
+      // TODO(b/121196706): use a less hacky approach to fix this bug
+      Object unused = methodImplementation.body();
+    }
+    
     addMethod();
     return Expression.create(
         methodImplementation.returnType(),
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 6809edd7d..6714aced7 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -7187,6 +7187,85 @@ public void prunedModuleWithInstanceState() {
         .containsElementsIn(generatedRoot);
   }
 
+  @Test
+  public void modifiableCycles() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class A {",
+            "  @Inject A(B b) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.B",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "class B {",
+            "  @Inject B(Provider<A> a) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  Provider<A> frameworkInstanceCycle();",
+            "}"));
+
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.DelegateFactory;",
+            IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private Provider<A> aProvider;",
+            "  private B_Factory bProvider;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.aProvider = new DelegateFactory<>();",
+            "    this.bProvider = B_Factory.create(frameworkInstanceCycle());",
+            "    DelegateFactory.setDelegate(aProvider, A_Factory.create(getBProvider()));",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<A> frameworkInstanceCycle() {",
+            "    return aProvider;",
+            "  }",
+            "",
+            "  protected Provider getBProvider() {",
+            "    return bProvider;",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+  }
+
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
     for (String className : ancillaryClasses) {
