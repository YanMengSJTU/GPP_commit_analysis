diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index c40035b7f..678637528 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -175,15 +175,27 @@ protected void addInterfaceMethods() {
       ComponentMethodDescriptor anyOneMethod = methodsWithSameSignature.stream().findAny().get();
       MethodSpec methodSpec = bindingExpressions.getComponentMethod(anyOneMethod);
 
-      // If the binding for the component method is modifiable, register it as such.
-      ModifiableBindingType modifiableBindingType =
-          bindingExpressions
-              .modifiableBindingExpressions()
-              .registerComponentMethodIfModifiable(anyOneMethod, methodSpec);
-
-      // If the method should be implemented in this component, implement it.
-      if (modifiableBindingType.hasBaseClassImplementation()) {
-        componentImplementation.addMethod(COMPONENT_METHOD, methodSpec);
+      if (anyOneMethod.dependencyRequest().isPresent()
+          && componentImplementation
+              .getModifiableBindingMethod(bindingRequest(anyOneMethod.dependencyRequest().get()))
+              .isPresent()) {
+        // If there are multiple component methods that are modifiable and for the same binding
+        // request, implement all but one in the base implementation to delegate to the one that
+        // will remain (and be registered) modifiable
+        checkState(componentImplementation.isAbstract() && !componentImplementation.isNested());
+        componentImplementation.addMethod(
+            COMPONENT_METHOD, methodSpec.toBuilder().addModifiers(FINAL).build());
+      } else {
+        // If the binding for the component method is modifiable, register it as such.
+        ModifiableBindingType modifiableBindingType =
+            bindingExpressions
+                .modifiableBindingExpressions()
+                .registerComponentMethodIfModifiable(anyOneMethod, methodSpec);
+
+        // If the method should be implemented in this component, implement it.
+        if (modifiableBindingType.hasBaseClassImplementation()) {
+          componentImplementation.addMethod(COMPONENT_METHOD, methodSpec);
+        }
       }
     }
   }
diff --git a/java/dagger/internal/codegen/ModifiableBindingMethods.java b/java/dagger/internal/codegen/ModifiableBindingMethods.java
index e19abb9d6..8aadf6a1a 100644
--- a/java/dagger/internal/codegen/ModifiableBindingMethods.java
+++ b/java/dagger/internal/codegen/ModifiableBindingMethods.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 
 import com.google.auto.common.MoreTypes;
@@ -56,8 +57,14 @@ void addMethod(
     if (finalized) {
       finalizedMethods.add(request);
     }
-    methods.put(
-        request, ModifiableBindingMethod.create(type, request, returnType, method, finalized));
+    ModifiableBindingMethod modifiableMethod =
+        ModifiableBindingMethod.create(type, request, returnType, method, finalized);
+    ModifiableBindingMethod previousMethod = methods.put(request, modifiableMethod);
+    verify(
+        previousMethod == null,
+        "registering %s but %s is already registered for the same binding request",
+        modifiableMethod,
+        previousMethod);
   }
 
   /** Returns all {@link ModifiableBindingMethod}s that have not been marked as finalized. */
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 8dcf383ca..7285efc33 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -4891,6 +4891,89 @@ public void dependencyExpressionCasting() {
         .containsElementsIn(generatedLeaf);
   }
 
+  @Test
+  public void multipleComponentMethodsForSameBindingRequest() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  String string1();",
+            "  String string2();",
+            "}"));
+
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  @Override",
+            "  public final String string2() {",
+            "    return string1();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .containsElementsIn(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.RootModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "interface RootModule {",
+            "  @Provides",
+            "  static String string() {",
+            "    return new String();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = RootModule.class)",
+            "interface Root {",
+            "  Leaf leaf();",
+            "}"));
+
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  protected final class LeafImpl extends DaggerLeaf {",
+            "    private LeafImpl() {}",
+            "",
+            "    @Override",
+            "    public String string1() {",
+            "      return RootModule_StringFactory.proxyString();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .containsElementsIn(generatedRoot);
+  }
+
   // TODO(ronshapiro): remove copies from AheadOfTimeSubcomponents*Test classes
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
