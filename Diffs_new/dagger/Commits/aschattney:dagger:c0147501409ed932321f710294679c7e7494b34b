diff --git a/compiler/pom.xml b/compiler/pom.xml
index 2d882c934..7ff771fe1 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.8</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>dagger-compiler</artifactId>
@@ -77,13 +77,13 @@
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
-    <dependency>
+    <!--<dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>dagger</artifactId>
       <classifier>tests</classifier>
       <version>${project.version}</version>
       <scope>test</scope>
-    </dependency>
+    </dependency>-->
     <dependency>
       <groupId>com.google.testing.compile</groupId>
       <artifactId>compile-testing</artifactId>
@@ -139,7 +139,7 @@
               <verbose>true</verbose>
             </configuration>
           </execution>
-          <execution>
+          <!--<execution>
             <id>default-test-compile</id>
             <goals><goal>testCompile</goal></goals>
             <configuration>
@@ -147,17 +147,15 @@
                 <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
               </annotationProcessors>
               <compilerArguments>
-                <!-- enable the next line to have the output of the processor shown on console -->
                 <Xlint/>
                 <Averbose>true</Averbose>
               </compilerArguments>
-              <!-- set the next to true to enable verbose output of the compiler plugin -->
               <verbose>true</verbose>
             </configuration>
-          </execution>
+          </execution>-->
         </executions>
       </plugin>
-      <plugin>
+      <!--<plugin>
         <artifactId>maven-invoker-plugin</artifactId>
         <configuration>
           <addTestClassPath>true</addTestClassPath>
@@ -181,7 +179,7 @@
             </goals>
           </execution>
         </executions>
-      </plugin>
+      </plugin>-->
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-shade-plugin</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 908bb9905..dc6945dda 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -121,6 +121,7 @@
 import dagger.releasablereferences.TypedReleasableReferenceManager;
 
 import java.util.*;
+import java.util.function.Consumer;
 import javax.inject.Provider;
 import javax.lang.model.element.*;
 import javax.lang.model.type.DeclaredType;
@@ -176,6 +177,7 @@
    * indexed by their {@link CanReleaseReferences @CanReleaseReferences} scope.
    */
   private ImmutableMap<Scope, MemberSelect> referenceReleasingProviderManagerFields;
+  private List<MethodSpec> initializationMethods;
 
   AbstractComponentWriter(
       Types types,
@@ -309,6 +311,9 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
     component.addMethod(constructor.build());
     if (graph.componentDescriptor().kind().isTopLevel()) {
       optionalFactories.addMembers(component);
+    }
+    for (MethodSpec initializationMethod : initializationMethods) {
+
     }
     done = true;
     return component;
@@ -330,7 +335,7 @@ protected void addBuilder() {
 
     Optional<BuilderSpec> builderSpec = graph.componentDescriptor().builderSpec();
     if (builderSpec.isPresent()) {
-      componentBuilder.addModifiers(PRIVATE);
+      componentBuilder.addModifiers(PUBLIC);
       addSupertype(componentBuilder, builderSpec.get().builderDefinitionType());
     } else {
       componentBuilder
@@ -368,6 +373,11 @@ protected void addBuilder() {
       componentBuilder.addField(builderField);
       builderFields.put(contributionElement, builderField);
     }
+
+    for (ContributionBinding contributionBinding : graph.delegateRequirements()) {
+      createDelegateFieldAndMethod(builderName(), componentBuilder, contributionBinding, delegateFieldNames);
+    }
+
     return builderFields.build();
   }
 
@@ -581,6 +591,9 @@ private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
 
   private void addFrameworkFields() {
     graph.resolvedBindings().values().forEach(this::addField);
+    for (ContributionBinding contributionBinding : graph.delegateRequirements()) {
+      createDelegateField(component, contributionBinding, delegateFieldNames);
+    }
   }
 
   private void addField(ResolvedBindings resolvedBindings) {
@@ -626,7 +639,6 @@ private FieldSpec addFrameworkField(
     }
     FieldSpec field = contributionField.build();
     component.addField(field);
-    createDelegateFieldAndMethod(name, component, resolvedBindings, delegateFieldNames);
     return field;
   }
 
@@ -875,12 +887,17 @@ private void addSubcomponents() {
 
   private void initializeFrameworkTypes() {
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+
+    codeBlocks.add(initDelegateFields());
+
     for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
       codeBlocks.addAll(initializeFrameworkType(bindingKey).asSet());
     }
     List<List<CodeBlock>> partitions =
         Lists.partition(codeBlocks.build(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
 
+    initializationMethods = new ArrayList<>();
+
     UniqueNameSet methodNames = new UniqueNameSet();
     for (List<CodeBlock> partition : partitions) {
       String methodName = methodNames.getUniqueName("initialize");
@@ -899,8 +916,21 @@ private void initializeFrameworkTypes() {
       } else {
         constructor.addStatement("$L()", methodName);
       }
-      component.addMethod(initializeMethod.build());
+      final MethodSpec method = initializeMethod.build();
+      initializationMethods.add(method);
+      component.addMethod(method);
+    }
+  }
+
+  private CodeBlock initDelegateFields() {
+    List<CodeBlock> codeBlocks = new ArrayList<>();
+    for (ContributionBinding contributionBinding : graph.delegateRequirements()) {
+      try {
+          final String delegateFieldName = Util.getDelegateFieldName(contributionBinding.key());
+          codeBlocks.add(CodeBlock.of("this.$L = builder.$L;", delegateFieldName, delegateFieldName));
+      }catch(Exception e){}
     }
+    return CodeBlocks.concat(codeBlocks);
   }
 
   /**
@@ -1147,7 +1177,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           }
           arguments.addAll(getDependencyArguments(binding));
 
-          if (bindingSupportsTestDelegate(binding)) {
+          if (delegateFieldName != null && bindingSupportsTestDelegate(binding)) {
             arguments.add(0, CodeBlock.of(delegateFieldName));
           }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 4f5215306..3a3eb3859 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -27,6 +27,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
 import static dagger.internal.codegen.Key.indexByKey;
@@ -39,6 +40,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.base.VerifyException;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
@@ -69,6 +71,7 @@
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
+import javax.annotation.Nullable;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -153,6 +156,16 @@ TypeElement componentType() {
         .append(componentDescriptor().dependencies())
         .toSet();
   }
+
+  ImmutableSet<ContributionBinding> delegateRequirements() {
+    return SUBGRAPH_TRAVERSER
+            .preOrderTraversal(this)
+            .transformAndConcat(graph -> graph.resolvedBindings().values())
+            .filter(resolvedBindings -> resolvedBindings != null && resolvedBindings.owningComponent().equals(componentDescriptor()))
+            .transformAndConcat(ResolvedBindings::ownedContributionBindings)
+            .filter(Util::bindingSupportsTestDelegate)
+            .toSet();
+  }
   /**
    * Returns the {@link ComponentDescriptor}s for this component and its subcomponents.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java b/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java
index ce9df2e15..1b316faf0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java
@@ -34,17 +34,6 @@ public CodeBlock get() {
         if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
             CodeBlock.Builder codeBlockBuilder = CodeBlock.builder();
             final ComponentDescriptor parentDescriptor = descriptor.getParentDescriptor();
-            /*final ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap =
-                    new ComponentWriter.UniqueSubcomponentNamesGenerator(graphFactory.create(parentDescriptor)).generate();
-
-            if (parentDescriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
-                final ClassName className = ClassName.bestGuess(resolveSubcomponentClassName(parentDescriptor));
-                packageName = className.packageName() + "." + className.simpleName();
-            }else {
-                final ClassName daggerComponentClassName = Util.getDaggerComponentClassName(parentDescriptor.componentDefinitionType());
-                packageName = daggerComponentClassName.packageName() + "." + daggerComponentClassName.simpleName();
-            }
-            final String subComponentClassName = subcomponentNamesMap.get(descriptor) + "Impl";*/
             final String subComponentClassName = resolveClassName(descriptor);
             final ClassName className = ClassName.bestGuess(subComponentClassName);
             codeBlockBuilder.add("(($T)", className);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 55c6cd5d4..249ae6a1d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.TypeSpec;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
new file mode 100644
index 000000000..61659e1ac
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
@@ -0,0 +1,146 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.Trigger;
+
+import javax.lang.model.element.TypeElement;
+import java.util.ArrayList;
+import java.util.List;
+
+import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+
+/**
+ * Created by Andy on 12.05.2017.
+ */
+public abstract class ComponentInfo {
+
+    protected final TypeElement component;
+    protected final ComponentDescriptor descriptor;
+    protected final BindingGraph bindingGraph;
+    protected List<ComponentInfo> infos = new ArrayList<>();
+
+    public static ComponentInfo forSpec(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
+        return createSpecComponentInfo(component, componentDescriptorFactory, bindingGraphFactory);
+    }
+
+    public static ComponentInfo forGenerator(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
+        return createGeneratorComponentInfo(component, componentDescriptorFactory, bindingGraphFactory);
+    }
+
+    public static TriggerComponentInfo forTrigger(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
+        return createTriggerComponentInfo(component, componentDescriptorFactory, bindingGraphFactory);
+    }
+
+    private static TriggerComponentInfo createTriggerComponentInfo(TypeElement component,
+                                                         ComponentDescriptor.Factory componentDescriptorFactory,
+                                                         BindingGraph.Factory bindingGraphFactory) {
+        final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
+        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
+        final TriggerComponentInfo componentInfo = new TriggerComponentInfo(component, descriptor, bindingGraph, bindingGraphFactory);
+        for (BindingGraph subGraph : bindingGraph.subgraphs()) {
+            componentInfo.add(new TriggerComponentInfo(subGraph.componentType(), subGraph.componentDescriptor(), subGraph, bindingGraphFactory));
+            createTriggerSubcomponentInfo(subGraph, componentInfo, bindingGraphFactory);
+        }
+        return componentInfo;
+    }
+
+    private static void createTriggerSubcomponentInfo(BindingGraph bindingGraph, ComponentInfo componentMethodOverrider, BindingGraph.Factory factory) {
+        for (BindingGraph subGraph : bindingGraph.subgraphs()) {
+            ComponentDescriptor subcomponentDescriptor = subGraph.componentDescriptor();
+            final ComponentInfo componentInfo =
+                    new TriggerComponentInfo(subcomponentDescriptor.componentDefinitionType(), subcomponentDescriptor, subGraph, factory);
+            componentMethodOverrider.add(componentInfo);
+            createTriggerSubcomponentInfo(subGraph, componentInfo, factory);
+        }
+    }
+
+    private static ComponentInfo createSpecComponentInfo(TypeElement component,
+                                                         ComponentDescriptor.Factory componentDescriptorFactory,
+                                                         BindingGraph.Factory bindingGraphFactory) {
+        final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
+        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
+        final ComponentInfo componentMethodOverrider = new SpecComponentInfo(component, descriptor, bindingGraph);
+        createSpecSubcomponentInfo(descriptor, bindingGraphFactory, componentMethodOverrider);
+        return componentMethodOverrider;
+    }
+
+    private static void createSpecSubcomponentInfo(ComponentDescriptor descriptor, BindingGraph.Factory bindingGraphFactory, ComponentInfo componentMethodOverrider) {
+        final ImmutableSet<ComponentDescriptor> subcomponents = descriptor.subcomponents();
+        for (ComponentDescriptor subcomponentDescriptor : subcomponents) {
+            final BindingGraph bindingGraph = bindingGraphFactory.create(subcomponentDescriptor);
+            final ComponentInfo subcomponentOverrider =
+                    new SpecComponentInfo(subcomponentDescriptor.componentDefinitionType(), subcomponentDescriptor, bindingGraph);
+            componentMethodOverrider.add(subcomponentOverrider);
+            createSpecSubcomponentInfo(subcomponentDescriptor, bindingGraphFactory, subcomponentOverrider);
+        }
+    }
+
+    private static ComponentInfo createGeneratorComponentInfo(TypeElement component,
+                                                     ComponentDescriptor.Factory componentDescriptorFactory,
+                                                     BindingGraph.Factory bindingGraphFactory) {
+        final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
+        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
+        final ComponentInfo componentInfo = new GeneratorComponentInfo(component, descriptor, bindingGraph);
+        for (BindingGraph subGraph : bindingGraph.subgraphs()) {
+            final ComponentDescriptor subDescriptor = subGraph.componentDescriptor();
+            componentInfo.add(new GeneratorComponentInfo(subDescriptor.componentDefinitionType(), subDescriptor, subGraph));
+            createGeneratorSubcomponentInfo(subGraph, componentInfo);
+        }
+        return componentInfo;
+    }
+
+    private static void createGeneratorSubcomponentInfo(BindingGraph bindingGraph, ComponentInfo componentInfo) {
+        for (BindingGraph subGraph : bindingGraph.subgraphs()) {
+            final ComponentDescriptor subDescriptor = subGraph.componentDescriptor();
+            final ComponentInfo subcomponentInfo =
+                    new GeneratorComponentInfo(subDescriptor.componentDefinitionType(), subDescriptor, subGraph);
+            componentInfo.add(subcomponentInfo);
+            createGeneratorSubcomponentInfo(subGraph, subcomponentInfo);
+        }
+    }
+
+    protected ComponentInfo(TypeElement component, ComponentDescriptor descriptor, BindingGraph bindingGraph) {
+        this.component = component;
+        this.descriptor = descriptor;
+        this.bindingGraph = bindingGraph;
+    }
+
+    public void add(ComponentInfo info) {
+        this.infos.add(info);
+    }
+
+    public void process(TypeSpec.Builder builder) {
+        for (ComponentInfo info : infos) {
+            info.process(builder);
+        }
+    }
+
+    public TypeElement getComponent() {
+        return component;
+    }
+
+    public ComponentDescriptor getDescriptor() {
+        return descriptor;
+    }
+
+    public BindingGraph getBindingGraph() {
+        return bindingGraph;
+    }
+
+
+    protected ClassName getBuilderClassName(TypeElement component) {
+        ClassName builderClassName;
+        if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
+            builderClassName = Util.getDaggerComponentClassName(ClassName.get(component)).nestedClass("Builder");
+        }else {
+            if (descriptor.builderSpec().isPresent()) {
+                builderClassName = ClassName.get(descriptor.builderSpec().get().builderDefinitionType());
+            }else {
+                throw new IllegalStateException("builder spec missing for: " + simpleVariableName(component));
+            }
+        }
+        return builderClassName;
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 46b07dce3..44f8b81cf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -25,18 +25,19 @@
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
 import dagger.Component;
+import dagger.Config;
 import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
-import javax.tools.Diagnostic.Kind;
 
 /**
  * A {@link ProcessingStep} that is responsible for dealing with a component or production component
@@ -56,6 +57,11 @@
   private final BindingGraph.Factory bindingGraphFactory;
   private final ComponentGenerator componentGenerator;
 
+  public static Set<TypeElement> allComponents = new HashSet<>();
+  public static TypeElement appClass;
+
+  public static boolean generatedAllComponents = true;
+
   ComponentProcessingStep(
       ComponentDescriptor.Kind componentKind,
       Messager messager,
@@ -82,6 +88,7 @@
   @Override
   public Set<Class<? extends Annotation>> annotations() {
     return ImmutableSet.of(
+        Config.class,
         Component.class,
         Component.Builder.class,
         ProductionComponent.class,
@@ -95,6 +102,14 @@
   @Override
   public final ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+
+    if (appClass == null) {
+      final Set<Element> elements = elementsByAnnotation.get(Config.class);
+      if (!elements.isEmpty()) {
+        appClass = MoreElements.asType(elements.iterator().next());
+      }
+    }
+
     ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
 
     Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
@@ -116,7 +131,9 @@
     Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
         processSubcomponents(subcomponentElements, subcomponentBuilderElements);
 
-    for (Element element : elementsByAnnotation.get(componentKind.annotationType())) {
+
+    final Set<Element> elements = elementsByAnnotation.get(componentKind.annotationType());
+    for (Element element : elements) {
       TypeElement componentTypeElement = MoreElements.asType(element);
       try {
         ComponentValidationReport validationReport =
@@ -143,11 +160,19 @@
             }
           }
         }
+        allComponents.add(componentTypeElement);
       } catch (TypeNotPresentException e) {
         rejectedElements.add(componentTypeElement);
       }
     }
-    return rejectedElements.build();
+
+    final ImmutableSet<Element> failedElements = rejectedElements.build();
+
+    if (elements.isEmpty() && failedElements.isEmpty()) {
+      generatedAllComponents = true;
+    }
+
+    return failedElements;
   }
 
   private void generateComponent(BindingGraph bindingGraph) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index ae5c85e15..b4c4bcbc4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -21,11 +21,17 @@
 
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.HashMultiset;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.MultimapBuilder;
 import com.google.googlejavaformat.java.filer.FormattingFiler;
 import com.squareup.javapoet.JavaFile;
+import dagger.Component;
+import dagger.Config;
 import dagger.Injector;
 
+import java.lang.annotation.Annotation;
 import java.util.Arrays;
 import java.util.Set;
 import javax.annotation.processing.Filer;
@@ -34,6 +40,7 @@
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -54,6 +61,12 @@
   private StubGenerator stubGenerator;
   private TestRegistry testRegistry = new TestRegistry();
   private MultipleSourceFileGenerator<ProvisionBinding> multipleGenerator;
+  private ComponentDescriptor.Factory componentDescriptorFactory;
+  private Types types;
+  private Elements elements;
+  private Filer filer;
+  private Messager messager;
+  private BindingGraph.Factory bindingGraphFactory;
 
   @Override
   public SourceVersion getSupportedSourceVersion() {
@@ -67,10 +80,10 @@ public SourceVersion getSupportedSourceVersion() {
 
   @Override
   protected Iterable<? extends ProcessingStep> initSteps() {
-    Messager messager = processingEnv.getMessager();
-    Types types = processingEnv.getTypeUtils();
-    Elements elements = processingEnv.getElementUtils();
-    Filer filer = new FormattingFiler(processingEnv.getFiler());
+    messager = processingEnv.getMessager();
+    types = processingEnv.getTypeUtils();
+    elements = processingEnv.getElementUtils();
+    filer = new FormattingFiler(processingEnv.getFiler());
 
     CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
 
@@ -88,10 +101,10 @@ public SourceVersion getSupportedSourceVersion() {
     BuilderValidator builderValidator = new BuilderValidator(elements, types);
     ComponentValidator subcomponentValidator =
         ComponentValidator.createForSubcomponent(
-            elements, types, moduleValidator, builderValidator);
+                elements, types, moduleValidator, builderValidator);
     ComponentValidator componentValidator =
         ComponentValidator.createForComponent(
-            elements, types, moduleValidator, subcomponentValidator, builderValidator);
+                elements, types, moduleValidator, subcomponentValidator, builderValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
@@ -107,8 +120,8 @@ public SourceVersion getSupportedSourceVersion() {
 
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(
-            elements,
-            types,
+                elements,
+                types,
             keyFactory,
             keyFormatter,
             methodSignatureFormatter,
@@ -151,9 +164,9 @@ public SourceVersion getSupportedSourceVersion() {
 
     this.injectBindingRegistry =
         new InjectBindingRegistry(
-            elements,
-            types,
-            messager,
+                elements,
+                types,
+                messager,
             injectValidator,
             keyFactory,
             provisionBindingFactory,
@@ -161,7 +174,7 @@ public SourceVersion getSupportedSourceVersion() {
 
     ModuleDescriptor.Factory moduleDescriptorFactory =
         new ModuleDescriptor.Factory(
-            elements,
+                elements,
             provisionBindingFactory,
             productionBindingFactory,
             multibindingDeclarationFactory,
@@ -169,16 +182,15 @@ public SourceVersion getSupportedSourceVersion() {
             subcomponentDeclarationFactory,
             optionalBindingDeclarationFactory);
 
-    ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
-        elements, types, dependencyRequestFactory, moduleDescriptorFactory);
+    componentDescriptorFactory = new ComponentDescriptor.Factory(
+            elements, types, dependencyRequestFactory, moduleDescriptorFactory);
 
-    BindingGraph.Factory bindingGraphFactory =
-        new BindingGraph.Factory(
+    bindingGraphFactory = new BindingGraph.Factory(
             elements,
-            injectBindingRegistry,
-            keyFactory,
-            provisionBindingFactory,
-            productionBindingFactory);
+        injectBindingRegistry,
+        keyFactory,
+        provisionBindingFactory,
+        productionBindingFactory);
 
     AnnotationCreatorGenerator annotationCreatorGenerator =
         new AnnotationCreatorGenerator(filer, elements);
@@ -190,8 +202,8 @@ public SourceVersion getSupportedSourceVersion() {
         new ComponentHierarchyValidator(compilerOptions, elements);
     BindingGraphValidator bindingGraphValidator =
         new BindingGraphValidator(
-            elements,
-            types,
+                elements,
+                types,
             compilerOptions,
             injectValidatorWhenGeneratingCode,
             injectBindingRegistry,
@@ -203,17 +215,17 @@ public SourceVersion getSupportedSourceVersion() {
 
     return ImmutableList.of(
         new MapKeyProcessingStep(
-            messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
+                messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
         new ForReleasableReferencesValidator(messager),
         new CanReleaseReferencesProcessingStep(
-            messager, canReleaseReferencesValidator, annotationCreatorGenerator),
+                messager, canReleaseReferencesValidator, annotationCreatorGenerator),
         new InjectProcessingStep(injectBindingRegistry),
         new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
         new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
         new MultibindingsProcessingStep(messager, multibindingsValidator),
         new MultibindingAnnotationsProcessingStep(messager),
         moduleProcessingStep(
-            messager,
+                messager,
             moduleValidator,
             provisionBindingFactory,
             this.multipleGenerator,
@@ -223,17 +235,17 @@ public SourceVersion getSupportedSourceVersion() {
             bindsOptionalOfMethodValidator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.COMPONENT,
-            messager,
+                messager,
             componentValidator,
             subcomponentValidator,
             builderValidator,
             componentHierarchyValidator,
             bindingGraphValidator,
-            componentDescriptorFactory,
-            bindingGraphFactory,
+                componentDescriptorFactory,
+                bindingGraphFactory,
             componentGenerator),
         producerModuleProcessingStep(
-            messager,
+                messager,
             moduleValidator,
             provisionBindingFactory,
             this.multipleGenerator,
@@ -246,26 +258,24 @@ public SourceVersion getSupportedSourceVersion() {
             bindsOptionalOfMethodValidator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
-            messager,
+                messager,
             componentValidator,
             subcomponentValidator,
             builderValidator,
             componentHierarchyValidator,
             bindingGraphValidator,
-            componentDescriptorFactory,
-            bindingGraphFactory,
+                componentDescriptorFactory,
+                bindingGraphFactory,
             componentGenerator),
-         new InjectorProcessingStep(
-                 types,
-                 messager,
-                 new InjectorGenerator.Factory(filer, elements, new TestClassGenerator(filer, elements), testRegistry),
-                 ComponentDescriptor.Kind.COMPONENT,
-                 bindingGraphFactory,
-                 componentDescriptorFactory),
-         new TriggerProcessingStep(
-                 testRegistry,
-                 filer
-         )
+            new InjectorProcessingStep(
+                    types,
+                    messager,
+                    new InjectorGenerator(filer, types, elements, componentDescriptorFactory, bindingGraphFactory, new TestClassGenerator(filer, elements), testRegistry, new Decorator.Factory(filer, elements, bindingGraphFactory)),
+                    ComponentDescriptor.Kind.COMPONENT,
+                    bindingGraphFactory,
+                    componentDescriptorFactory,
+                    new DependencySpecGenerator(filer, elements, componentDescriptorFactory, bindingGraphFactory),
+                    new DependencyInjectorGenerator(filer, elements, bindingGraphFactory, componentDescriptorFactory))
     );
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 60e1b70d6..9e94b03da 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -61,6 +61,10 @@
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
+  abstract boolean genericParameter();
+
+  abstract boolean ignoreStubGeneration();
+
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
 
   final Optional<AnnotationMirror> mapKey() {
@@ -283,6 +287,10 @@ final TypeMirror contributedType() {
 
     abstract B key(Key key);
 
+    abstract B genericParameter(boolean generic);
+
+    abstract B ignoreStubGeneration(boolean ignore);
+
     abstract B explicitDependencies(Iterable<DependencyRequest> dependencies);
 
     abstract B explicitDependencies(DependencyRequest... dependencies);
diff --git a/compiler/src/main/java/dagger/internal/codegen/DI.java b/compiler/src/main/java/dagger/internal/codegen/DI.java
index e6c27cdaf..a7ea36dbc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DI.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DI.java
@@ -2,39 +2,38 @@
 
 import com.squareup.javapoet.ClassName;
 
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
-/**
- * Created by Andy on 05.05.2017.
- */
 public class DI {
-    private final TypeElement injector;
-    private Map<TypeElement, ProvidingMethodOverrider> methods;
+    private TypeElement appClass;
+    private Set<TypeElement> components;
     private List<InjectorType> injectorTypes;
 
-    public DI(TypeElement injector, Map<TypeElement, ProvidingMethodOverrider> methods, List<InjectorType> injectorTypes) {
-        this.injector = injector;
-        this.methods = methods;
+    public DI(TypeElement appClass, Set<TypeElement> components, List<InjectorType> injectorTypes) {
+        this.appClass = appClass;
+        this.components = components;
         this.injectorTypes = injectorTypes;
     }
 
-    public TypeElement getInjector() {
-        return injector;
+    public ClassName getClassName() {
+        final ClassName className = ClassName.bestGuess(appClass.asType().toString());
+        return className.topLevelClassName().peerClass("Test" + className.simpleName());
     }
 
-    public ClassName getClassName() {
-        final ClassName className = ClassName.bestGuess(injector.asType().toString());
-        return ClassName.bestGuess(className.packageName() + "." + "Test" + className.simpleName());
+    public List<InjectorType> getInjectorTypes() {
+        return injectorTypes;
     }
 
-    public Map<TypeElement, ProvidingMethodOverrider> getMethods() {
-        return methods;
+    public Set<TypeElement> getComponents() {
+        return components;
     }
 
-    public List<InjectorType> getInjectorTypes() {
-        return injectorTypes;
+    public TypeElement getAppClass() {
+        return appClass;
     }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Decorator.java b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
new file mode 100644
index 000000000..0d940b7d5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
@@ -0,0 +1,85 @@
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.squareup.javapoet.*;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+public class Decorator  extends SourceFileGenerator<BindingGraph>{
+
+    private BindingGraph.Factory factory;
+
+    private Decorator(Filer filer, Elements elements, BindingGraph.Factory factory) {
+        super(filer, elements);
+        this.factory = factory;
+    }
+
+    @Override
+    ClassName nameGeneratedType(BindingGraph input) {
+        final TypeElement component = input.componentDescriptor().componentDefinitionType();
+        return ClassName.bestGuess("factories." + component.getSimpleName().toString() + "Decorator");
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(BindingGraph input) {
+        return Optional.of(input.componentDescriptor().componentDefinitionType());
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, BindingGraph input) {
+        final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName)
+                .addModifiers(Modifier.PUBLIC);
+
+        final String daggerBuilderClassName = TriggerComponentInfo.resolveClassName(factory, input.componentDescriptor());
+
+        addDecoratorType(builder, generatedTypeName, daggerBuilderClassName, input);
+
+        return Optional.of(builder);
+    }
+
+    private void addDecoratorType(TypeSpec.Builder builder, ClassName returnType, String className, BindingGraph bindingGraph) {
+        builder.addModifiers(Modifier.PUBLIC);
+        builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC).build());
+        List<CodeBlock> statements = new ArrayList<>();
+        for (ContributionBinding contributionBinding : bindingGraph.delegateRequirements()) {
+            Util.createDelegateFieldAndMethod(returnType, builder, contributionBinding, new HashMap<>(1));
+            final String delegateFieldName = Util.getDelegateFieldName(contributionBinding.key());
+            final ClassName delegateTypeName = Util.getDelegateTypeName(contributionBinding.key());
+            statements.add(CodeBlock.of("builder.$L(this.$L);", Util.getDelegateMethodName(delegateTypeName), delegateFieldName));
+        }
+
+        builder.addMethod(MethodSpec.methodBuilder("decorate")
+                .addModifiers(Modifier.PUBLIC)
+                .addParameter(ClassName.bestGuess(className), "builder")
+                .addCode("$L", CodeBlocks.join(statements, "\n"))
+                .returns(void.class)
+                .build());
+    }
+
+
+    public static class Factory {
+
+        private final Filer filer;
+        private final Elements elements;
+        private final BindingGraph.Factory bindingGraphFactory;
+
+        Factory(Filer filer, Elements elements, BindingGraph.Factory bindingGraphFactory) {
+            this.filer = filer;
+            this.elements = elements;
+            this.bindingGraphFactory = bindingGraphFactory;
+        }
+
+        public Decorator create() {
+            return new Decorator(filer, elements, bindingGraphFactory);
+        }
+
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java b/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java
index 8d518dea7..d75a8e8bb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java
@@ -31,28 +31,16 @@ public DelegateInitialization(ComponentDescriptor descriptor, BindingGraph graph
     @Override
     public CodeBlock get() {
         final CodeBlock.Builder codeBuilder = CodeBlock.builder();
-        final ImmutableCollection<ResolvedBindings> values = graph.resolvedBindings().values();
-        for (ResolvedBindings resolvedBindings : values) {
+        final ImmutableCollection<ContributionBinding> values = graph.delegateRequirements();
+        for (ContributionBinding binding : values) {
             try {
-
-                if (resolvedBindings.ownedBindings().isEmpty()) {
-                    continue;
-                }
-
-                ContributionBinding binding = resolvedBindings.contributionBinding();
-                if (bindingSupportsTestDelegate(binding) && shouldCreateDelegate(binding)) {
-                    final String delegateFieldName = Util.getDelegateFieldName(resolvedBindings.key());
-                    final ClassName delegateType = getDelegateTypeName(resolvedBindings.key());
-                    final String methodName = "with" + delegateType.simpleName();
-                    codeBuilder.add(".$L($L)\n", methodName, delegateFieldName);
-                }
+                final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+                final ClassName delegateType = getDelegateTypeName(binding.key());
+                final String methodName = Util.getDelegateMethodName(delegateType);
+                codeBuilder.add(".$L($L)\n", methodName, delegateFieldName);
             } catch (Exception e) {
             }
         }
         return codeBuilder.build();
     }
-
-    private boolean shouldCreateDelegate(ContributionBinding binding) {
-        return descriptor.kind() != ComponentDescriptor.Kind.SUBCOMPONENT || binding.requiresModuleInstance();
-    }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java
new file mode 100644
index 000000000..cc25d02c2
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java
@@ -0,0 +1,64 @@
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.*;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import java.util.ArrayList;
+import java.util.List;
+
+import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+
+/**
+ * Created by Andy on 11.05.2017.
+ */
+public class DependencyInjectorGenerator extends SourceFileGenerator<DI> {
+
+    private final BindingGraph.Factory bindingGraphFactory;
+    private final ComponentDescriptor.Factory componentDescriptorFactory;
+
+    DependencyInjectorGenerator(Filer filer, Elements elements, BindingGraph.Factory bindingGraphFactory, ComponentDescriptor.Factory componentDescriptorFactory) {
+        super(filer, elements);
+        this.bindingGraphFactory = bindingGraphFactory;
+        this.componentDescriptorFactory = componentDescriptorFactory;
+    }
+
+    @Override
+    ClassName nameGeneratedType(DI input) {
+        return ClassName.bestGuess("injector.Injector");
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(DI input) {
+        return Optional.absent();
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, DI input) {
+        final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName).addModifiers(Modifier.PUBLIC);
+        final ClassName appType = ClassName.get(input.getAppClass());
+        builder.superclass(appType);
+        builder.addMethod(MethodSpec.constructorBuilder()
+                .addModifiers(Modifier.PUBLIC)
+                .addParameter(appType, "app")
+                .addStatement("this.app = app")
+                .build());
+        builder.addField(appType, "app", Modifier.PRIVATE);
+        for (TypeElement typeElement : input.getComponents()) {
+            final ComponentInfo info = ComponentInfo.forGenerator(typeElement, componentDescriptorFactory, bindingGraphFactory);
+            info.process(builder);
+        }
+        return Optional.of(builder);
+    }
+
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java b/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
new file mode 100644
index 000000000..6b987011c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
@@ -0,0 +1,70 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.googlejavaformat.java.ModifierOrderer;
+import com.squareup.javapoet.*;
+import dagger.Component;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+
+public class DependencySpecGenerator extends SourceFileGenerator<Set<TypeElement>> {
+
+    private ComponentDescriptor.Factory componentDescriptorFactory;
+    private BindingGraph.Factory bindingGraphFactory;
+
+    DependencySpecGenerator(Filer filer, Elements elements, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
+        super(filer, elements);
+        this.componentDescriptorFactory = componentDescriptorFactory;
+        this.bindingGraphFactory = bindingGraphFactory;
+    }
+
+    @Override
+    ClassName nameGeneratedType(Set<TypeElement> input) {
+        return ClassName.bestGuess("injector.InjectorSpec");
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(Set<TypeElement> input) {
+        return Optional.absent();
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, Set<TypeElement> input) {
+
+        final TypeSpec.Builder builder = TypeSpec.interfaceBuilder(generatedTypeName)
+                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);
+
+        final List<ComponentInfo> info = input
+                .stream()
+                .map(typeElement -> ComponentInfo.forSpec(typeElement, componentDescriptorFactory, bindingGraphFactory))
+                .collect(Collectors.toList());
+
+        for (ComponentInfo componentInfo : info) {
+            componentInfo.process(builder);
+        }
+
+        builder.addMethod(MethodSpec.methodBuilder("getInjector")
+                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
+                .returns(ClassName.bestGuess("injector.Injector"))
+                .build());
+
+        return Optional.of(builder);
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index db82996c6..44772cad7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -145,12 +145,14 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         break;
       case CLASS_CONSTRUCTOR:
         constructorBuilder = Optional.of(constructorBuilder().addModifiers(PUBLIC));
-        addConstructorParameterAndTypeField(
-                getDelegateTypeName(binding.key()),
-                getDelegateFieldName(binding.key()),
-                factoryBuilder,
-                constructorBuilder.get()
-        );
+        if (Util.bindingSupportsTestDelegate(binding)) {
+          addConstructorParameterAndTypeField(
+                  getDelegateTypeName(binding.key()),
+                  getDelegateFieldName(binding.key()),
+                  factoryBuilder,
+                  constructorBuilder.get()
+          );
+        }
         if (binding.requiresModuleInstance()) {
 
           addConstructorParameterAndTypeField(
@@ -247,10 +249,12 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
     final CodeBlock codeBlock = CodeBlock.of(getDelegateFieldName(binding.key()));
     if (binding.bindingKind().equals(PROVISION)) {
-      final String delegateFieldName = Util.getDelegateFieldName(binding.key());
-      getMethodBuilder.beginControlFlow("if ($L != null)", CodeBlock.of(delegateFieldName));
-      getMethodBuilder.addStatement("return $L.get($L)", CodeBlock.of(delegateFieldName), parametersCodeBlock);
-      getMethodBuilder.nextControlFlow("else");
+      if (Util.bindingSupportsTestDelegate(binding)) {
+        final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+        getMethodBuilder.beginControlFlow("if ($L != null)", CodeBlock.of(delegateFieldName));
+        getMethodBuilder.addStatement("return $L.get($L)", CodeBlock.of(delegateFieldName), parametersCodeBlock);
+        getMethodBuilder.nextControlFlow("else");
+      }
       CodeBlock.Builder providesMethodInvocationBuilder = CodeBlock.builder();
       if (binding.requiresModuleInstance()) {
         providesMethodInvocationBuilder.add("module");
@@ -263,7 +267,10 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
       CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
       getMethodBuilder.addStatement("return $L", providesMethodInvocation);
-      getMethodBuilder.endControlFlow();
+
+      if (Util.bindingSupportsTestDelegate(binding)) {
+        getMethodBuilder.endControlFlow();
+      }
 
       /*if (binding.nullableType().isPresent()
           || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)) {
@@ -279,27 +286,35 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
       }*/
     } else if (binding.membersInjectionRequest().isPresent()) {
 
-      getMethodBuilder.beginControlFlow("if ($L != null)", codeBlock);
-      getMethodBuilder.addStatement(
-              "return $T.injectMembers($N, $L.get($L))",
-              MembersInjectors.class,
-              fields.get(binding.membersInjectionRequest().get().bindingKey()),
-              codeBlock,
-              parametersCodeBlock);
-      getMethodBuilder.nextControlFlow("else");
+      if (Util.bindingSupportsTestDelegate(binding)) {
+        getMethodBuilder.beginControlFlow("if ($L != null)", codeBlock);
+        getMethodBuilder.addStatement(
+                "return $T.injectMembers($N, $L.get($L))",
+                MembersInjectors.class,
+                fields.get(binding.membersInjectionRequest().get().bindingKey()),
+                codeBlock,
+                parametersCodeBlock);
+        getMethodBuilder.nextControlFlow("else");
+      }
       getMethodBuilder.addStatement(
           "return $T.injectMembers($N, new $T($L))",
           MembersInjectors.class,
           fields.get(binding.membersInjectionRequest().get().bindingKey()),
           providedTypeName,
           parametersCodeBlock);
-      getMethodBuilder.endControlFlow();
+      if (Util.bindingSupportsTestDelegate(binding)) {
+        getMethodBuilder.endControlFlow();
+      }
     } else {
-      getMethodBuilder.beginControlFlow("if ($L != null)", codeBlock);
-      getMethodBuilder.addStatement("return $L.get($L)", codeBlock, parametersCodeBlock);
-      getMethodBuilder.nextControlFlow("else");
+      if (Util.bindingSupportsTestDelegate(binding)) {
+        getMethodBuilder.beginControlFlow("if ($L != null)", codeBlock);
+        getMethodBuilder.addStatement("return $L.get($L)", codeBlock, parametersCodeBlock);
+        getMethodBuilder.nextControlFlow("else");
+      }
       getMethodBuilder.addStatement("return new $T($L)", providedTypeName, parametersCodeBlock);
-      getMethodBuilder.endControlFlow();
+      if (Util.bindingSupportsTestDelegate(binding)) {
+        getMethodBuilder.endControlFlow();
+      }
     }
 
     factoryBuilder.addMethod(getMethodBuilder.build());
diff --git a/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java b/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java
index 10490d8a4..a34740f76 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java
@@ -1,5 +1,6 @@
 package dagger.internal.codegen;
 
+import com.google.common.base.Optional;
 import com.squareup.javapoet.CodeBlock;
 
 /**
@@ -17,7 +18,8 @@ public FinishBuilderStatement(ComponentDescriptor descriptor) {
     public CodeBlock get() {
         final CodeBlock.Builder builder = CodeBlock.builder();
         if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
-            return (this.descriptor.builderSpec().isPresent()) ? builder.add(".build())\n").build() : builder.build();
+            final Optional<ComponentDescriptor.BuilderSpec> builderSpec = this.descriptor.builderSpec();
+            return (builderSpec.isPresent()) ? builder.add(".$L())\n", builderSpec.get().buildMethod().getSimpleName().toString()).build() : builder.build();
         }
         return CodeBlock.of(".build())\n");
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
new file mode 100644
index 000000000..18bc00f54
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
@@ -0,0 +1,95 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.*;
+
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import java.util.ArrayList;
+import java.util.List;
+import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+
+public class GeneratorComponentInfo extends ComponentInfo {
+
+    protected GeneratorComponentInfo(TypeElement component, ComponentDescriptor descriptor, BindingGraph bindingGraph) {
+        super(component, descriptor, bindingGraph);
+    }
+
+    @Override
+    public void process(TypeSpec.Builder builder) {
+        super.process(builder);
+        final String name = simpleVariableName(component);
+        final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(name)
+                .addModifiers(Modifier.PUBLIC);
+
+        methodBuilder.returns(ClassName.get(component));
+
+        List<ParameterSpec> parameterSpecs = new ArrayList<>();
+        if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            final TypeElement component = descriptor.getParentDescriptor().componentDefinitionType();
+            parameterSpecs.add(ParameterSpec.builder(ClassName.get(component), simpleVariableName(component)).build());
+        }
+
+        for (ModuleDescriptor moduleDescriptor : descriptor.modules()) {
+            final TypeElement typeElement = moduleDescriptor.moduleElement();
+            parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
+        }
+
+        for (TypeElement typeElement: descriptor.dependencies()) {
+            parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
+        }
+
+        methodBuilder.addParameters(parameterSpecs);
+
+        CodeBlock builderInit = getBuilderInitStatement(descriptor, descriptor.getParentDescriptor());
+
+        final List<CodeBlock> statementParams = new ArrayList<>();
+
+        for (ModuleDescriptor moduleDescriptor : descriptor.modules()) {
+            final TypeElement typeElement = moduleDescriptor.moduleElement();
+            statementParams.add(CodeBlock.of("$L", simpleVariableName(typeElement)));
+        }
+
+        for (TypeElement typeElement: descriptor.dependencies()) {
+            statementParams.add(CodeBlock.of("$L", simpleVariableName(typeElement)));
+        }
+
+        if (statementParams.isEmpty()) {
+            methodBuilder.addStatement("return this.app.$L($L).build()", name, builderInit);
+        }else {
+            methodBuilder.addStatement("return this.app.$L($L, $L).build()", name, builderInit, makeParametersCodeBlock(statementParams));
+        }
+
+        builder.addMethod(methodBuilder.build());
+    }
+
+    private CodeBlock getBuilderInitStatement(ComponentDescriptor descriptor, ComponentDescriptor parentDescriptor) {
+        if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            final ImmutableSet<ComponentDescriptor.ComponentMethodDescriptor> componentMethodDescriptors = parentDescriptor.componentMethods();
+            for (ComponentDescriptor.ComponentMethodDescriptor componentMethodDescriptor : componentMethodDescriptors) {
+                final ExecutableElement executableElement = componentMethodDescriptor.methodElement();
+                TypeMirror typeToSearch = descriptor.componentDefinitionType().asType();
+                if (descriptor.builderSpec().isPresent()) {
+                    typeToSearch = descriptor.builderSpec().get().builderDefinitionType().asType();
+                }
+                if (executableElement.getReturnType().toString().equals(typeToSearch.toString())) {
+                    final String methodName = executableElement.getSimpleName().toString();
+                    if (!descriptor.builderSpec().isPresent()) {
+                        // check if method has parameters ...
+                        //builderModuleStatement.setExecutableElement(executableElement);
+                        //return codeBlockBuilder.add("$L.$L($L))\n", builderName, methodName, builderModuleStatement.get()).build();
+                        break;
+                    } else {
+                        return CodeBlock.of("$L.$L()\n", simpleVariableName(parentDescriptor.componentDefinitionType()), methodName);
+                    }
+                }
+            }
+        }
+        final ClassName componentClassName = Util.getDaggerComponentClassName(ClassName.get(descriptor.componentDefinitionType()));
+        return CodeBlock.of("$T.builder()\n", componentClassName);
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
index a6dbf2a68..b48979ceb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
@@ -1,28 +1,36 @@
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.*;
 
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.*;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.*;
 
-/**
- * Created by Andy on 05.05.2017.
- */
 public class InjectorGenerator extends SourceFileGenerator<DI>{
 
+    private Types types;
+    private Elements elements;
+    private final ComponentDescriptor.Factory componentDescriptorFactory;
+    private final BindingGraph.Factory bindingGraphFactory;
     private TestClassGenerator testClassGenerator;
     private final TestRegistry registry;
+    private Decorator.Factory decoratorFactory;
 
-    InjectorGenerator(Filer filer, Elements elements, TestClassGenerator testClassGenerator, TestRegistry registry) {
+    InjectorGenerator(Filer filer, Types types, Elements elements, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory, TestClassGenerator testClassGenerator, TestRegistry registry, Decorator.Factory decoratorFactory) {
         super(filer, elements);
+        this.types = types;
+        this.elements = elements;
+        this.componentDescriptorFactory = componentDescriptorFactory;
+        this.bindingGraphFactory = bindingGraphFactory;
         this.testClassGenerator = testClassGenerator;
         this.registry = registry;
+        this.decoratorFactory = decoratorFactory;
     }
 
     @Override
@@ -32,37 +40,97 @@ ClassName nameGeneratedType(DI input) {
 
     @Override
     Optional<? extends Element> getElementForErrorReporting(DI input) {
-        return Optional.of(input.getInjector());
+        return Optional.absent();
     }
 
     @Override
     Optional<TypeSpec.Builder> write(ClassName generatedTypeName, DI input) {
-        final TypeElement injector = input.getInjector();
         final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName)
-                .superclass(ClassName.get(injector))
                 .addModifiers(Modifier.PUBLIC);
 
-        Map<Key, String> delegateFieldNames = new HashMap<>();
-        Map<Key, ComponentDescriptor> componentDescriptors = new HashMap<>();
-        for (InjectorType injectorType : input.getInjectorTypes()) {
-            final Key key = Key.builder(injectorType.getElement().asType()).build();
-            componentDescriptors.put(key, injectorType.getComponentDescriptor());
+        final Set<TypeElement> components = input.getComponents();
+
+        builder.superclass(ClassName.get(input.getAppClass()));
+
+        final java.util.Optional<ExecutableElement> onCreateMethod = findOnCreateMethod(input.getAppClass());
+        if (!onCreateMethod.isPresent()) {
+            throw new IllegalStateException("onCreate method not found!");
         }
+        final MethodSpec.Builder overriding = MethodSpec.overriding(onCreateMethod.get());
+        createDecoratorClasses(builder, overriding, components);
+        overriding.addStatement("super.onCreate()");
+
+        //builder.addMethod(overriding.build());
 
-        final Map<TypeElement, ProvidingMethodOverrider> methods = input.getMethods();
-        for (Map.Entry<TypeElement, ProvidingMethodOverrider> entry : methods.entrySet()) {
-            final ProvidingMethodOverrider overrider = entry.getValue();
-            overrider.process(builder, generatedTypeName, delegateFieldNames);
+        for (TypeElement component : components) {
+            final TriggerComponentInfo componentInfo =
+                    ComponentInfo.forTrigger(component, componentDescriptorFactory, bindingGraphFactory);
+            componentInfo.process(builder);
         }
 
+        builder.addMethod(MethodSpec.methodBuilder("apply")
+                .addModifiers(Modifier.PUBLIC)
+                .returns(void.class)
+                .addStatement("this.onCreate()")
+                .build());
+
         return Optional.of(builder);
     }
 
+    private void createDecoratorClasses(TypeSpec.Builder builder, MethodSpec.Builder methodBuilder, Set<TypeElement> components) {
+        for (TypeElement component : components) {
+            ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(component);
+            final BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+            createDecoratorClass(builder, methodBuilder, bindingGraph);
+        }
+    }
+
+    private void createDecoratorClass(TypeSpec.Builder builder, MethodSpec.Builder methodBuilder, BindingGraph bindingGraph) {
+        final Decorator decorator = decoratorFactory.create();
+        try {
+            decorator.generate(bindingGraph);
+            final ClassName decoratorName = decorator.nameGeneratedType(bindingGraph);
+            String name = Util.lowerCaseFirstLetter(decoratorName.simpleName());
+            final FieldSpec.Builder fieldBuilder = FieldSpec.builder(decoratorName, name, Modifier.PRIVATE);
+            fieldBuilder.addAnnotation(AnnotationSpec.builder(ClassName.bestGuess("android.support.annotation.NonNull")).build());
+            final FieldSpec field = fieldBuilder.initializer("new $T()", decoratorName).build();
+            //methodBuilder.addStatement("this.$N = new $T()", field, decoratorName);
+            builder.addField(field);
+            builder.addMethod(MethodSpec.methodBuilder(name)
+                    .addModifiers(Modifier.PUBLIC)
+                    .returns(decoratorName)
+                    .addStatement("return this.$L", name)
+                    .build());
+        } catch (SourceFileGenerationException e) {
+            throw new IllegalStateException("Exception while generating decorator: " + e);
+        }
+        for (BindingGraph subGraph : bindingGraph.subgraphs()) {
+            createDecoratorClass(builder, methodBuilder, subGraph);
+        }
+    }
+
+    private java.util.Optional<ExecutableElement> findOnCreateMethod(TypeElement applicationClass) {
+        final java.util.Optional<ExecutableElement> onCreateMethod = applicationClass.getEnclosedElements().stream()
+                .filter(e -> e.getKind() == ElementKind.METHOD)
+                .map(e -> (ExecutableElement) e)
+                .filter(e -> e.getSimpleName().toString().equals("onCreate"))
+                .findFirst();
+        final Optional<DeclaredType> declaredTypeOptional = MoreTypes.nonObjectSuperclass(types, elements, MoreTypes.asDeclared(applicationClass.asType()));
+        if (!onCreateMethod.isPresent() && declaredTypeOptional.isPresent()) {
+            return findOnCreateMethod(MoreTypes.asTypeElement(declaredTypeOptional.get()));
+        }
+        else
+            return onCreateMethod;
+    }
+
     @Override
     void generate(DI input) throws SourceFileGenerationException {
         final Optional<TypeSpec.Builder> builder = write(input.getClassName(), input);
         try {
             registry.addEncodedClass(input.getClassName(), buildJavaFile(input.getClassName(), builder.get()));
+            final Set<TypeElement> components = input.getComponents();
+            testClassGenerator.setComponents(components);
+            testClassGenerator.setInjector(input.getAppClass());
             testClassGenerator.generate(registry);
         } catch (IOException e) {
             throw new IllegalStateException(e);
@@ -70,24 +138,4 @@ void generate(DI input) throws SourceFileGenerationException {
 
     }
 
-    public static class Factory {
-
-        private final Filer filer;
-        private final Elements elements;
-        private final TestClassGenerator generator;
-        private TestRegistry registry;
-
-        public Factory(Filer filer, Elements elements, TestClassGenerator generator, TestRegistry registry) {
-            this.filer = filer;
-            this.elements = elements;
-            this.generator = generator;
-            this.registry = registry;
-        }
-
-        public InjectorGenerator create() {
-            return new InjectorGenerator(filer, elements, generator, registry);
-        }
-
-    }
-
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
index f70cff724..66ca481e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
@@ -6,6 +6,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
+import com.squareup.javapoet.TypeName;
 import dagger.*;
 
 import javax.annotation.processing.Messager;
@@ -13,7 +14,9 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.MirroredTypeException;
 import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
 import java.lang.annotation.Annotation;
 import java.util.*;
 import java.util.function.Function;
@@ -26,106 +29,103 @@
 
     private Types types;
     private final Messager messager;
-    private final InjectorGenerator.Factory injectorGeneratorFactory;
+    private final InjectorGenerator injectorGenerator;
     private final ComponentDescriptor.Kind component;
     private final BindingGraph.Factory bindingGraphFactory;
     private final ComponentDescriptor.Factory componentDescriptorFactory;
+    private DependencySpecGenerator dependencySpecGenerator;
+    private DependencyInjectorGenerator dependencyInjectorGenerator;
     private Map<TypeElement, ExecutableElement> componentMethodMap;
     private Map<TypeElement, ExecutableElement> moduleMethodMap;
     private Map<TypeElement, ExecutableElement> subcomponentMethodMap;
-
-    public InjectorProcessingStep(Types types, Messager messager, InjectorGenerator.Factory injectorGeneratorFactory, ComponentDescriptor.Kind component, BindingGraph.Factory bindingGraphFactory, ComponentDescriptor.Factory componentDescriptorFactory) {
+    private HashSet<TypeElement> components = new HashSet<>();
+    private TypeElement appClass;
+    private static boolean done = false;
+
+    public InjectorProcessingStep(Types types, Messager messager,
+                                  InjectorGenerator injectorGenerator,
+                                  ComponentDescriptor.Kind component, BindingGraph.Factory bindingGraphFactory,
+                                  ComponentDescriptor.Factory componentDescriptorFactory,
+                                  DependencySpecGenerator dependencySpecGenerator,
+                                  DependencyInjectorGenerator dependencyInjectorGenerator) {
         this.types = types;
         this.messager = messager;
-        this.injectorGeneratorFactory = injectorGeneratorFactory;
+        this.injectorGenerator = injectorGenerator;
         this.component = component;
         this.bindingGraphFactory = bindingGraphFactory;
         this.componentDescriptorFactory = componentDescriptorFactory;
+        this.dependencySpecGenerator = dependencySpecGenerator;
+        this.dependencyInjectorGenerator = dependencyInjectorGenerator;
     }
 
     @Override
     public Set<? extends Class<? extends Annotation>> annotations() {
-        return ImmutableSet.of(ProvidesComponent.class, ProvidesSubcomponent.class, ProvidesModule.class, Injector.class, Component.class);
+        return ImmutableSet.of(Config.class, Component.class);
     }
 
     @Override
     public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-        final Iterator<Element> it = elementsByAnnotation.get(Injector.class).iterator();
+
+        if (done) {
+            return new HashSet<>();
+        }
+
+        done = true;
+
+        final Iterator<Element> it = elementsByAnnotation.get(Config.class).iterator();
         if (!it.hasNext()) {
             return ImmutableSet.of();
         }
 
-        TypeElement injector = MoreElements.asType(it.next());
+        if (appClass == null) {
+            try {
+                it.next().getAnnotation(Config.class).applicationClass();
+            } catch (MirroredTypeException e) {
+                try {
+                    appClass = MoreTypes.asTypeElement(e.getTypeMirror());
+                } catch (TypeNotPresentException ex) {
+                    throw new IllegalStateException("application class could not be extracted: " + ex.toString());
+                }
+            } catch (Exception e) {
+                throw new IllegalStateException("application class could not be extracted");
+            }
+        }
 
-        this.moduleMethodMap =
-                this.buildProvideMethodMap(elementsByAnnotation.get(ProvidesModule.class));
+        Set<Element> rejectedElements = new LinkedHashSet<>();
 
-        this.subcomponentMethodMap =
-                this.buildProvideMethodMap(elementsByAnnotation.get(ProvidesSubcomponent.class));
+        components.addAll(elementsByAnnotation.get(Component.class).stream()
+                .map(element -> (TypeElement) element).collect(Collectors.toSet()));
 
-        this.componentMethodMap =
-                this.buildProvideMethodMap(elementsByAnnotation.get(ProvidesComponent.class));
+            /*this.moduleMethodMap =
+                    this.buildProvideMethodMap(elementsByAnnotation.get(ProvidesModule.class));
 
-        final Map<TypeElement, ProvidingMethodOverrider> componentOverriderMap =
-                this.buildProvideComponentMethodMap(elementsByAnnotation.get(ProvidesComponent.class), injector);
+            this.subcomponentMethodMap =
+                    this.buildProvideMethodMap(elementsByAnnotation.get(ProvidesSubcomponent.class));
+
+            this.componentMethodMap =
+                    this.buildProvideMethodMap(elementsByAnnotation.get(ProvidesComponent.class));*/
+
+/*        final Map<TypeElement, ProvidingMethodOverrider> componentOverriderMap =
+                this.buildProvideComponentMethodMap(elementsByAnnotation.get(ProvidesComponent.class), injector);*/
 
-        Set<Element> rejectedElements = new LinkedHashSet<>();
         List<InjectorType> injectorTypeList = new ArrayList<>();
         for (Element element : elementsByAnnotation.get(component.annotationType())) {
-            TypeElement componentTypeElement = MoreElements.asType(element);
-            try {
-                ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(componentTypeElement);
-                BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-                InjectorType injectorType = new InjectorType(componentTypeElement, bindingGraph, componentDescriptor);
-                injectorTypeList.add(injectorType);
-            } catch (TypeNotPresentException e) {
-                rejectedElements.add(componentTypeElement);
-            }
+            TypeElement componentTypeElement = (TypeElement) element;
+            ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(componentTypeElement);
+            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+            InjectorType injectorType = new InjectorType(componentTypeElement, bindingGraph, componentDescriptor);
+            injectorTypeList.add(injectorType);
         }
-        final DI di = new DI(injector, componentOverriderMap, injectorTypeList);
-        this.injectorGeneratorFactory.create().generate(di, messager);
-        return rejectedElements;
-    }
-
-    private Map<TypeElement, ExecutableElement> buildProvideMethodMap(Set<Element> elements) {
-        return elements.stream()
-                .map(element -> (ExecutableElement) element)
-                .collect(Collectors.toMap(p -> MoreTypes.asTypeElement(p.getReturnType()), Function.identity()));
-    }
-
-    private Map<TypeElement, ProvidingMethodOverrider> buildProvideComponentMethodMap(Set<Element> elements, TypeElement injector) {
-        return elements.stream()
-                .map(element -> this.createOverrider(element, injector))
-                .collect(Collectors.toMap(p -> p.getComponent(), Function.identity()));
-    }
-
-    private ProvidingMethodOverrider createOverrider(Element element, TypeElement injector) {
-        ExecutableElement executableElement = (ExecutableElement) element;
-        final TypeElement component = MoreTypes.asTypeElement(executableElement.getReturnType());
-        final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
-        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
-        List<InitializationStatement> statements = this.createInitializationsStatements(injector, descriptor, this.moduleMethodMap, executableElement, bindingGraph);
-        final ProvidingMethodOverrider componentMethodOverrider = new ProvidingMethodOverrider(component, descriptor, executableElement, statements, bindingGraph);
-        findSubcomponentsToOverride(injector, descriptor, componentMethodOverrider);
-        return componentMethodOverrider;
-    }
-
-    private void findSubcomponentsToOverride(TypeElement injector, ComponentDescriptor descriptor, ProvidingMethodOverrider componentMethodOverrider) {
-        final ImmutableSet<ComponentDescriptor> subcomponents = descriptor.subcomponents();
-        for (ComponentDescriptor subcomponentDescriptor : subcomponents) {
-            final ExecutableElement e = this.subcomponentMethodMap.get(subcomponentDescriptor.componentDefinitionType());
-            if (e == null) {
-                continue;
-            }
-            final TypeElement subcomponentType = MoreTypes.asTypeElement(e.getReturnType());
-            final BindingGraph bindingGraph = bindingGraphFactory.create(subcomponentDescriptor);
-            List<InitializationStatement> s =
-                    this.createInitializationsStatements(injector, subcomponentDescriptor, this.moduleMethodMap, e, bindingGraph);
-            final ProvidingMethodOverrider subcomponentOverrider =
-                    new ProvidingMethodOverrider(subcomponentType, subcomponentDescriptor, e, s, bindingGraph);
-            componentMethodOverrider.add(subcomponentOverrider);
-            this.findSubcomponentsToOverride(injector, subcomponentDescriptor, subcomponentOverrider);
+        if (rejectedElements.isEmpty()) {
+            final DI di = new DI(appClass, components, injectorTypeList);
+            this.dependencyInjectorGenerator.generate(di, messager);
+            this.dependencySpecGenerator.generate(components, messager);
+            this.injectorGenerator.generate(di, messager);
+        } else {
+            throw new IllegalStateException(rejectedElements.toString());
         }
+
+        return rejectedElements;
     }
 
     private Map<Key, VariableElement> toParameterMap(List<? extends VariableElement> parameters) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 15068dcab..03fe88d49 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -205,13 +205,13 @@ public ClassName getDelegateTypeName() {
       final ClassName name = ClassName.bestGuess(Util.typeToString(returnType));
       final String packageName = name.packageName();
       if (annotation != null) {
-          return ClassName.bestGuess(packageName + "." + capitalizeFirstLetter(annotation.value()) + "Delegate");
+          return ClassName.bestGuess("swagger" + "." + capitalizeFirstLetter(annotation.value()) + "Delegate");
       }else {
         final java.util.Optional<? extends AnnotationMirror> annotationMirror = getAnnotationMirror(bindingMethod);
         if(annotationMirror.isPresent()) {
-          return ClassName.bestGuess(packageName + "." + getCapitalizedAnnotationValue(annotationMirror.get()) + "In" + contributingModule.getSimpleName().toString() + "Delegate");
+          return ClassName.bestGuess("swagger" + "." + getCapitalizedAnnotationValue(annotationMirror.get()) + "In" + contributingModule.getSimpleName().toString() + "Delegate");
         }else {
-          return ClassName.bestGuess(packageName + "." + capitalizeFirstLetter(bindingMethod.getSimpleName().toString()) + "For" + contributingModule.getSimpleName().toString() + "Delegate");
+          return ClassName.bestGuess("swagger" + "." + capitalizeFirstLetter(bindingMethod.getSimpleName().toString()) + "For" + contributingModule.getSimpleName().toString() + "Delegate");
         }
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 131b1f925..ed45784bf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -333,12 +333,14 @@ private void validateProvidesOverrides(
           if (!failedMethods.contains(providesMethod)
               && elements.overrides(providesMethod, superclassMethod, subject)) {
             failedMethods.add(providesMethod);
+            /**
             builder.addError(
                 String.format(
                     PROVIDES_METHOD_OVERRIDES_ANOTHER,
                     moduleKind.methodAnnotation().getSimpleName(),
                     methodSignatureFormatter.format(superclassMethod)),
                 providesMethod);
+             **/
           }
         }
         // For each @Provides method in superclass, confirm our methods don't override it.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index bbcabc679..53e489aaf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -102,6 +102,7 @@ public BindingType bindingType() {
   private static Builder builder() {
     return new AutoValue_ProductionBinding.Builder()
         .explicitDependencies(ImmutableList.<DependencyRequest>of())
+        .genericParameter(false)
         .thrownTypes(ImmutableList.<TypeMirror>of());
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java b/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java
index f2e18eb0d..9e68702fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java
@@ -59,7 +59,7 @@ public void process(TypeSpec.Builder builder, ClassName generatedTypeName, Map<K
         }
 
         this.getBindingGraph().resolvedBindings().values().forEach(resolvedBindings -> {
-            if (!resolvedBindings.isEmpty() && resolvedBindings.bindingType() == BindingType.PROVISION) {
+            if (!resolvedBindings.isEmpty() && resolvedBindings.bindingType() == BindingType.PROVISION && Util.bindingSupportsTestDelegate(resolvedBindings.contributionBinding())) {
                 if (!delegateFieldNames.containsKey(resolvedBindings.key())) {
                     createDelegateFieldAndMethod(generatedTypeName, builder, resolvedBindings, delegateFieldNames);
                 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 70b207c0d..d01e48ab6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -35,6 +35,8 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import dagger.IgnoreStubGeneration;
+
 import java.util.Set;
 import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
@@ -80,6 +82,8 @@ public BindingType bindingType() {
 
   private static Builder builder() {
     return new AutoValue_ProvisionBinding.Builder()
+        .genericParameter(false)
+        .ignoreStubGeneration(false)
         .explicitDependencies(ImmutableSet.<DependencyRequest>of());
   }
   
@@ -151,6 +155,7 @@ ProvisionBinding forInjectConstructor(
           ProvisionBinding.builder()
               .contributionType(ContributionType.UNIQUE)
               .bindingElement(constructorElement)
+              .ignoreStubGeneration(constructorElement.getAnnotation(IgnoreStubGeneration.class) != null)
               .key(key)
               .explicitDependencies(dependencies)
               .membersInjectionRequest(membersInjectionRequest)
@@ -186,6 +191,8 @@ ProvisionBinding forInjectConstructor(
     ProvisionBinding forProvidesMethod(
         ExecutableElement providesMethod, TypeElement contributedBy) {
       checkArgument(providesMethod.getKind().equals(METHOD));
+      final DeclaredType declaredType = (DeclaredType) contributedBy.asType();
+      boolean genericParameter = !declaredType.getTypeArguments().isEmpty();
       ExecutableType resolvedMethod =
           MoreTypes.asExecutable(
               types.asMemberOf(MoreTypes.asDeclared(contributedBy.asType()), providesMethod));
@@ -197,8 +204,10 @@ ProvisionBinding forProvidesMethod(
       return ProvisionBinding.builder()
           .contributionType(ContributionType.fromBindingMethod(providesMethod))
           .bindingElement(providesMethod)
+          .ignoreStubGeneration(providesMethod.getAnnotation(IgnoreStubGeneration.class) != null)
           .contributingModule(contributedBy)
           .key(key)
+          .genericParameter(genericParameter)
           .explicitDependencies(dependencies)
           .nullableType(ConfigurationAnnotations.getNullableType(providesMethod))
           .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(providesMethod)))
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 9fa5e740d..780b05e35 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -17,29 +17,14 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.io.ByteStreams.toByteArray;
-
-import com.google.common.base.Charsets;
 import com.google.common.base.Optional;
 import com.google.common.base.Throwables;
-import com.google.common.io.ByteStreams;
-import com.google.common.io.CharStreams;
 import com.squareup.javapoet.*;
-import com.sun.org.apache.xml.internal.security.utils.Base64;
-
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
-import javax.tools.JavaFileObject;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.nio.charset.Charset;
-import java.nio.charset.StandardCharsets;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.util.UUID;
 
 /**
  * A template class that provides a framework for properly handling IO while generating source files
diff --git a/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java
new file mode 100644
index 000000000..501945d94
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java
@@ -0,0 +1,49 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeSpec;
+
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import java.util.ArrayList;
+import java.util.List;
+
+import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+
+/**
+ * Created by Andy on 12.05.2017.
+ */
+public class SpecComponentInfo extends ComponentInfo {
+
+    protected SpecComponentInfo(TypeElement component, ComponentDescriptor descriptor, BindingGraph bindingGraph) {
+        super(component, descriptor, bindingGraph);
+    }
+
+    @Override
+    public void process(TypeSpec.Builder builder) {
+        super.process(builder);
+        final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(simpleVariableName(component))
+                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);
+
+        ClassName builderClassName = getBuilderClassName(component);
+        methodBuilder.returns(builderClassName);
+        List<ParameterSpec> parameterSpecs = new ArrayList<>();
+
+        ParameterSpec builderParameter = ParameterSpec.builder(builderClassName, "builder").build();
+
+        parameterSpecs.add(builderParameter);
+
+        for (ModuleDescriptor moduleDescriptor : descriptor.modules()) {
+            final TypeElement typeElement = moduleDescriptor.moduleElement();
+            parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
+        }
+
+        for (TypeElement typeElement: descriptor.dependencies()) {
+            parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
+        }
+
+        builder.addMethod(methodBuilder.addParameters(parameterSpecs).build());
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
index 88b1ad237..6340ae579 100644
--- a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
@@ -26,6 +26,8 @@
 
     private final Types types;
 
+    private final List<String> generated = new ArrayList<>();
+
     StubGenerator(Filer filer, Elements elements, Types types) {
         super(filer, elements);
         this.types = types;
@@ -43,6 +45,11 @@ ClassName nameGeneratedType(ProvisionBinding input) {
 
     @Override
     Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProvisionBinding input) {
+        final String o = generatedTypeName.packageName() + "." + generatedTypeName.simpleName();
+        if (generated.contains(o) || !Util.bindingSupportsTestDelegate(input)) {
+            return Optional.absent();
+        }
+        generated.add(o);
         final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("get");
         methodBuilder.addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);
         final TypeName contributedTypeName = ClassName.get(input.contributedType());
diff --git a/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java b/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
index eba2a14fd..f9f8066d1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
@@ -1,13 +1,17 @@
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.squareup.javapoet.*;
 import dagger.Trigger;
 
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
+import java.util.HashSet;
 import java.util.Iterator;
+import java.util.Set;
 import java.util.UUID;
 
 /**
@@ -15,6 +19,9 @@
  */
 public class TestClassGenerator extends SourceFileGenerator<TestRegistry> {
 
+    private Set<TypeElement> components;
+    private TypeElement injector;
+
     TestClassGenerator(Filer filer, Elements elements) {
         super(filer, elements);
     }
@@ -46,7 +53,23 @@ ClassName nameGeneratedType(TestRegistry input) {
                                 .build()
             );
         }
+
+        builder.addAnnotation(AnnotationSpec.builder(Trigger.class)
+            .addMember("value", CodeBlock.of("$S", "injector"))
+            .addMember("qualifiedName", CodeBlock.of("$S", injector.getQualifiedName().toString()))
+            .build());
+
         return Optional.of(builder);
     }
 
+    public void setComponents(Set<TypeElement> components) {
+        if (components == null) {
+            components = new HashSet<>();
+        }
+        this.components = components;
+    }
+
+    public void setInjector(TypeElement injector) {
+        this.injector = injector;
+    }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java b/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
index f011a2f78..be2bcd5f6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
@@ -2,13 +2,11 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.JavaFile;
-import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException;
-import com.sun.org.apache.xml.internal.security.utils.Base64;
-
 import javax.tools.JavaFileObject;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Base64;
 import java.util.Iterator;
 import java.util.List;
 
@@ -24,7 +22,7 @@
     public void addEncodedClass(ClassName className, JavaFile javaFile) throws IOException {
         final JavaFileObject javaFileObject = javaFile.toJavaFileObject();
         final InputStream inputStream = javaFileObject.openInputStream();
-        final String encodedClass = Base64.encode(toByteArray(inputStream));
+        final String encodedClass = java.util.Base64.getEncoder().encodeToString(toByteArray(inputStream));
         final String name = className.packageName() + "." + className.simpleName();
         encodedClasses.add(new EncodedClass(name, encodedClass));
     }
@@ -37,8 +35,8 @@ public ClassName getClassName() {
         return encodedClasses.iterator();
     }
 
-    public byte[] decodeClass(String value) throws Base64DecodingException {
-        return Base64.decode(value);
+    public byte[] decodeClass(String value) {
+        return Base64.getDecoder().decode(value);
     }
 
     public static class EncodedClass {
diff --git a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
new file mode 100644
index 000000000..1bc1b4317
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
@@ -0,0 +1,114 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableCollection;
+import com.squareup.javapoet.*;
+
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.Util.bindingSupportsTestDelegate;
+import static dagger.internal.codegen.Util.getDelegateTypeName;
+
+
+public class TriggerComponentInfo extends ComponentInfo {
+
+    private final BindingGraph.Factory bindingGraphFactory;
+
+    protected TriggerComponentInfo(TypeElement typeElement, ComponentDescriptor descriptor,
+                                   BindingGraph bindingGraph, BindingGraph.Factory bindingGraphFactory) {
+        super(typeElement, descriptor, bindingGraph);
+        this.bindingGraphFactory = bindingGraphFactory;
+    }
+
+    @Override
+    public void process(TypeSpec.Builder builder) {
+        super.process(builder);
+
+        final TypeElement component = descriptor.componentDefinitionType();
+        String methodName = simpleVariableName(component);
+        final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName)
+                .addAnnotation(Override.class)
+                .addModifiers(Modifier.PUBLIC);
+
+        ClassName builderClassName = getBuilderClassName(component);
+        methodBuilder.returns(builderClassName);
+        List<ParameterSpec> parameterSpecs = new ArrayList<>();
+
+        ParameterSpec builderParameter = ParameterSpec.builder(builderClassName, "builder").build();
+
+        parameterSpecs.add(builderParameter);
+
+        for (ModuleDescriptor moduleDescriptor : descriptor.modules()) {
+            final TypeElement typeElement = moduleDescriptor.moduleElement();
+            parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
+        }
+
+        methodBuilder.addParameters(parameterSpecs);
+
+        final List<CodeBlock> params = parameterSpecs.stream()
+                .map(parameterSpec -> CodeBlock.of("$L", parameterSpec.name))
+                .collect(Collectors.toList());
+
+        String className = resolveClassName(bindingGraphFactory, descriptor);
+
+        final ClassName name = ClassName.bestGuess(className);
+        methodBuilder.addStatement("$T componentBuilder = ($T) super.$L($L)\n",
+                name, name, methodName, makeParametersCodeBlock(params));
+
+        final String decoratorName = Util.lowerCaseFirstLetter(component.getSimpleName().toString()) + "Decorator";
+
+        methodBuilder.addStatement("this.$L.decorate(componentBuilder)", decoratorName);
+
+        methodBuilder.addStatement("return componentBuilder");
+
+        builder.addMethod(methodBuilder.build());
+    }
+
+    public static String resolveClassName(BindingGraph.Factory bindingGraphFactory, ComponentDescriptor descriptor) {
+        if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
+            final ClassName daggerComponentClassName = Util.getDaggerComponentClassName(descriptor.componentDefinitionType());
+            return daggerComponentClassName.packageName() + "." + daggerComponentClassName.simpleName() + ".Builder";
+        }else if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            final ComponentDescriptor parentDescriptor = descriptor.getParentDescriptor();
+            final String parentClassName = resolveClassName2(parentDescriptor, bindingGraphFactory);
+            final BindingGraph parentGraph = bindingGraphFactory.create(parentDescriptor);
+            final ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap =
+                    new ComponentWriter.UniqueSubcomponentNamesGenerator(parentGraph).generate();
+            final String s = subcomponentNamesMap.get(descriptor);
+            if (s == null) {
+                throw new NullPointerException("s is null | " + subcomponentNamesMap.values().toString() + "|" + descriptor.componentDefinitionType().asType().toString());
+            }
+            return parentClassName + "." + s + "Builder";
+        }else {
+            throw new IllegalStateException("unknown");
+        }
+    }
+
+    public static String resolveClassName2(ComponentDescriptor descriptor, BindingGraph.Factory bindingGraphFactory) {
+        if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
+            final ClassName daggerComponentClassName = Util.getDaggerComponentClassName(descriptor.componentDefinitionType());
+            return daggerComponentClassName.packageName() + "." + daggerComponentClassName.simpleName();
+        }else if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            final ComponentDescriptor parentDescriptor = descriptor.getParentDescriptor();
+            final String parentClassName = resolveClassName2(parentDescriptor, bindingGraphFactory);
+            final BindingGraph parentGraph = bindingGraphFactory.create(parentDescriptor);
+            final ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap =
+                    new ComponentWriter.UniqueSubcomponentNamesGenerator(parentGraph).generate();
+            final String s = subcomponentNamesMap.get(descriptor);
+            if (s == null) {
+                throw new NullPointerException("s is null | " + subcomponentNamesMap.values().toString() + "|" + descriptor.componentDefinitionType().asType().toString());
+            }
+            return parentClassName + "." + s + "Impl";
+        }else {
+            throw new IllegalStateException("unknown");
+        }
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/TriggerProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/TriggerProcessingStep.java
index d3665ea4d..796ff67ac 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TriggerProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TriggerProcessingStep.java
@@ -3,10 +3,7 @@
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
-import com.squareup.javapoet.JavaFile;
-import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException;
 import dagger.Trigger;
-
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
@@ -53,8 +50,6 @@ public TriggerProcessingStep(TestRegistry testRegistry, Filer filer) {
                 os.write(decodedClass);
                 os.flush();
                 os.close();
-            } catch (Base64DecodingException e) {
-                e.printStackTrace();
             } catch (IOException e) {
                 e.printStackTrace();
             }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 861e00a26..ac7a4ac1f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -280,15 +280,25 @@ static ClassName getDelegateTypeName(Key key) {
                         .findFirst();
                 if (qualifier.isPresent()) {
                     final PackageElement packageElement = getPackage(MoreTypes.asElement(key.type()));
-                    final String classNameString = packageElement.getQualifiedName().toString() + "." + capitalizeFirstLetter(qualifier.get()) + "Delegate";
+                    final String classNameString = "delegates" + "." + capitalizeFirstLetter(qualifier.get()) + "Delegate";
                     return ClassName.bestGuess(classNameString);
                 }
             }
-            return ClassName.bestGuess(typeToString(key.type()) + "Delegate");
+            final TypeName typeName = ClassName.get(key.type());
+            if (typeName instanceof ClassName) {
+                final String s = ((ClassName) typeName).simpleName();
+                return ClassName.bestGuess("delegates" +  "." + s + "Delegate");
+            }
+            final ClassName name = ClassName.bestGuess(typeToString(key.type()));
+            return ClassName.bestGuess("delegates." + name.simpleName() + "Delegate");
         }
         return key.multibindingContributionIdentifier().get().getDelegateTypeName();
     }
 
+    private static String extractPackageName(TypeMirror type) {
+        return getPackage(MoreTypes.asElement(type)).getSimpleName().toString();
+    }
+
     static String getDelegateFieldName(Key key) {
         if (!key.multibindingContributionIdentifier().isPresent()) {
             if (key.qualifier().isPresent()) {
@@ -372,7 +382,7 @@ public Void visitDeclared(DeclaredType declaredType, Void v) {
                     result.append("Of");
                     for (int i = 0; i < typeArguments.size(); i++) {
                         if (i != 0) {
-                            result.append(", ");
+                            result.append("And");
                         }
                         typeToString(typeArguments.get(i), result, '\0', true);
                     }
@@ -484,7 +494,7 @@ private static String getCapitalizedAnnotationValue(AnnotationMirror annotation)
         throw new IllegalStateException("value not found");
     }
 
-    private static String capitalizeFirstLetter(String original) {
+    public static String capitalizeFirstLetter(String original) {
         if (original == null || original.length() == 0) {
             return original;
         }
@@ -501,17 +511,56 @@ public static String lowerCaseFirstLetter(String original) {
     public static boolean bindingSupportsTestDelegate(ContributionBinding binding) {
         final ImmutableList<ContributionBinding.Kind> kinds = ImmutableList.of(
                 ContributionBinding.Kind.PROVISION,
-                ContributionBinding.Kind.COMPONENT_PROVISION,
                 ContributionBinding.Kind.INJECTION
         );
         final ContributionBinding.Kind kind = binding.bindingKind();
-        return kinds.contains(kind);
+        return kinds.contains(kind) && !binding.genericParameter() && !binding.ignoreStubGeneration();
     }
 
     private Util() {
     }
 
+    public static void createDelegateField(TypeSpec.Builder classBuilder, ContributionBinding binding, Map<Key, String> delegateFieldNames) {
+        try {
+            if (bindingSupportsTestDelegate(binding)) {
+                final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+                final ClassName delegateType = getDelegateTypeName(binding.key());
+                final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
+                delegateFieldNames.put(binding.key(), delegateFieldName);
+                final FieldSpec fieldSpec = builder.build();
+                classBuilder.addField(fieldSpec);
+            }
+        } catch (Exception e) {
+        }
+    }
+
+    public static void createDelegateFieldAndMethod(ClassName generatedTypeName, TypeSpec.Builder classBuilder, ContributionBinding binding, Map<Key, String> delegateFieldNames) {
+        try {
+            if (bindingSupportsTestDelegate(binding)) {
+                final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+                final ClassName delegateType = getDelegateTypeName(binding.key());
+                final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
+                delegateFieldNames.put(binding.key(), delegateFieldName);
+                final FieldSpec fieldSpec = builder.build();
+                classBuilder.addField(fieldSpec);
+                final String methodName = getDelegateMethodName(delegateType);
+                classBuilder.addMethod(MethodSpec.methodBuilder(methodName)
+                        .addModifiers(Modifier.PUBLIC)
+                        .returns(generatedTypeName)
+                        .addParameter(delegateType, delegateFieldName)
+                        .addStatement("this.$N = $L", fieldSpec, CodeBlock.of(delegateFieldName))
+                        .addStatement("return this")
+                        .build());
+            }
+        } catch (Exception e) {
+        }
+    }
+
+
     public static void createDelegateFieldAndMethod(ClassName generatedTypeName, TypeSpec.Builder classBuilder, ResolvedBindings resolvedBindings, Map<Key, String> delegateFieldNames) {
+        if (resolvedBindings.isEmpty() || resolvedBindings.ownedBindings().isEmpty()) {
+            return;
+        }
         try {
             ContributionBinding binding = resolvedBindings.contributionBinding();
             if (bindingSupportsTestDelegate(binding)) {
@@ -521,7 +570,7 @@ public static void createDelegateFieldAndMethod(ClassName generatedTypeName, Typ
                 delegateFieldNames.put(binding.key(), delegateFieldName);
                 final FieldSpec fieldSpec = builder.build();
                 classBuilder.addField(fieldSpec);
-                final String methodName = "with" + delegateType.simpleName();
+                final String methodName = getDelegateMethodName(delegateType);
                 classBuilder.addMethod(MethodSpec.methodBuilder(methodName)
                         .addModifiers(Modifier.PUBLIC)
                         .returns(generatedTypeName)
@@ -534,10 +583,15 @@ public static void createDelegateFieldAndMethod(ClassName generatedTypeName, Typ
         }
     }
 
+    public static String getDelegateMethodName(ClassName delegateType) {
+        return "with" + delegateType.simpleName().replaceAll("Delegate$", "");
+    }
+
     public static ClassName getDaggerComponentClassName(ClassName componentDefinitionClassName) {
-        String componentName =
+       String componentName =
                 "Dagger" + Joiner.on('_').join(componentDefinitionClassName.simpleNames());
-        return componentDefinitionClassName.topLevelClassName().peerClass(componentName);
+        componentDefinitionClassName = ClassName.bestGuess("factories." + componentName);
+        return componentDefinitionClassName;//componentDefinitionClassName.topLevelClassName().peerClass(componentName);
     }
 
     public static ClassName getDaggerComponentClassName(Element component) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
deleted file mode 100644
index 930a52183..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ /dev/null
@@ -1,297 +0,0 @@
-/*
- * Copyright (C) 2014 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.auto.common.MoreTypes;
-import com.google.common.collect.Iterables;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.testing.compile.CompilationRule;
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.codegen.Key.MultibindingContributionIdentifier;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntoSet;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.inject.Qualifier;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/**
- * Tests {@link Key}.
- */
-@RunWith(JUnit4.class)
-public class KeyTest {
-  @Rule public CompilationRule compilationRule = new CompilationRule();
-
-  private Elements elements;
-  private Types types;
-  private Key.Factory keyFactory;
-
-  @Before public void setUp() {
-    this.types = compilationRule.getTypes();
-    this.elements = compilationRule.getElements();
-    this.keyFactory = new Key.Factory(types, elements);
-  }
-
-  @Test public void forInjectConstructorWithResolvedType() {
-    TypeElement typeElement =
-        compilationRule.getElements().getTypeElement(InjectedClass.class.getCanonicalName());
-    ExecutableElement constructor =
-        Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
-    Key key =
-        keyFactory.forInjectConstructorWithResolvedType(constructor.getEnclosingElement().asType());
-    assertThat(key).isEqualTo(Key.builder(typeElement.asType()).build());
-    assertThat(key.toString()).isEqualTo("dagger.internal.codegen.KeyTest.InjectedClass");
-  }
-
-  static final class InjectedClass {
-    @SuppressWarnings("unused")
-    @Inject InjectedClass(String s, int i) {}
-  }
-
-  @Test public void forProvidesMethod() {
-    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
-    TypeElement moduleElement =
-        elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
-    ExecutableElement providesMethod =
-        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key key = keyFactory.forProvidesMethod(providesMethod, moduleElement);
-    assertThat(key).isEqualTo(Key.builder(stringType).build());
-    assertThat(key.toString()).isEqualTo("java.lang.String");
-  }
-
-  @Module
-  static final class ProvidesMethodModule {
-    @Provides String provideString() {
-      throw new UnsupportedOperationException();
-    }
-  }
-
-  @Test public void forProvidesMethod_qualified() {
-    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
-    TypeElement qualifierElement =
-        elements.getTypeElement(TestQualifier.class.getCanonicalName());
-    TypeElement moduleElement =
-        elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
-    ExecutableElement providesMethod =
-        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key key = keyFactory.forProvidesMethod(providesMethod, moduleElement);
-    assertThat(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
-        .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
-    assertThat(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
-    assertThat(key.toString())
-        .isEqualTo(
-            "@dagger.internal.codegen.KeyTest.TestQualifier("
-                + "{@dagger.internal.codegen.KeyTest.InnerAnnotation}) java.lang.String");
-  }
-
-  @Test public void qualifiedKeyEquivalents() {
-    TypeElement moduleElement =
-        elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
-    ExecutableElement providesMethod =
-        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key provisionKey = keyFactory.forProvidesMethod(providesMethod, moduleElement);
-
-    TypeMirror type = elements.getTypeElement(String.class.getCanonicalName()).asType();
-    TypeElement injectableElement =
-        elements.getTypeElement(QualifiedFieldHolder.class.getCanonicalName());
-    Element injectionField =
-        Iterables.getOnlyElement(ElementFilter.fieldsIn(injectableElement.getEnclosedElements()));
-    AnnotationMirror qualifier = Iterables.getOnlyElement(injectionField.getAnnotationMirrors());
-    Key injectionKey = Key.builder(type).qualifier(qualifier).build();
-
-    assertThat(provisionKey).isEqualTo(injectionKey);
-    assertThat(injectionKey.toString())
-        .isEqualTo(
-            "@dagger.internal.codegen.KeyTest.TestQualifier("
-                + "{@dagger.internal.codegen.KeyTest.InnerAnnotation}) java.lang.String");
-  }
-
-  @Module
-  static final class QualifiedProvidesMethodModule {
-    @Provides
-    @TestQualifier(@InnerAnnotation)
-    String provideQualifiedString() {
-      throw new UnsupportedOperationException();
-    }
-  }
-
-  static final class QualifiedFieldHolder {
-    @TestQualifier(@InnerAnnotation) String aString;
-  }
-
-  @Qualifier
-  @interface TestQualifier {
-    InnerAnnotation[] value();
-  }
-
-  @interface InnerAnnotation {}
-
-  @Test public void forProvidesMethod_sets() {
-    TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
-    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
-    TypeMirror setOfStringsType = types.getDeclaredType(setElement, stringType);
-    TypeElement moduleElement =
-        elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
-    for (ExecutableElement providesMethod
-        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      Key key = keyFactory.forProvidesMethod(providesMethod, moduleElement);
-      assertThat(key)
-          .isEqualTo(
-              Key.builder(setOfStringsType)
-                  .multibindingContributionIdentifier(
-                      new MultibindingContributionIdentifier(providesMethod, moduleElement))
-                  .build());
-      assertThat(key.toString())
-          .isEqualTo(
-              String.format(
-                  "java.util.Set<java.lang.String> "
-                      + "dagger.internal.codegen.KeyTest.SetProvidesMethodsModule#%s",
-                  providesMethod.getSimpleName()));
-    }
-  }
-
-  @Module
-  static final class SetProvidesMethodsModule {
-    @Provides @IntoSet String provideString() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Provides @ElementsIntoSet Set<String> provideStrings() {
-      throw new UnsupportedOperationException();
-    }
-  }
-
-  @Module
-  static final class PrimitiveTypes {
-    @Provides int foo() {
-      return 0;
-    }
-  }
-
-  @Module
-  static final class BoxedPrimitiveTypes {
-    @Provides Integer foo() {
-      return 0;
-    }
-  }
-
-  @Test public void primitiveKeysMatchBoxedKeys() {
-    TypeElement primitiveHolder = elements.getTypeElement(PrimitiveTypes.class.getCanonicalName());
-    ExecutableElement intMethod =
-        Iterables.getOnlyElement(ElementFilter.methodsIn(primitiveHolder.getEnclosedElements()));
-    TypeElement boxedPrimitiveHolder =
-        elements.getTypeElement(BoxedPrimitiveTypes.class.getCanonicalName());
-    ExecutableElement integerMethod = Iterables.getOnlyElement(
-        ElementFilter.methodsIn(boxedPrimitiveHolder.getEnclosedElements()));
-
-    // TODO(cgruber): Truth subject for TypeMirror and TypeElement
-    TypeMirror intType = intMethod.getReturnType();
-    assertThat(intType.getKind().isPrimitive()).isTrue();
-    TypeMirror integerType = integerMethod.getReturnType();
-    assertThat(integerType.getKind().isPrimitive()).isFalse();
-    assertThat(types.isSameType(intType, integerType)).named("type equality").isFalse();
-    Key intKey = keyFactory.forProvidesMethod(intMethod, primitiveHolder);
-    Key integerKey = keyFactory.forProvidesMethod(integerMethod, boxedPrimitiveHolder);
-    assertThat(intKey).isEqualTo(integerKey);
-    assertThat(intKey.toString()).isEqualTo("java.lang.Integer");
-    assertThat(integerKey.toString()).isEqualTo("java.lang.Integer");
-  }
-
-  @Test public void forProducesMethod() {
-    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
-    TypeElement moduleElement =
-        elements.getTypeElement(ProducesMethodsModule.class.getCanonicalName());
-    for (ExecutableElement producesMethod
-        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      Key key = keyFactory.forProducesMethod(producesMethod, moduleElement);
-      assertThat(key).isEqualTo(Key.builder(stringType).build());
-      assertThat(key.toString()).isEqualTo("java.lang.String");
-    }
-  }
-
-  @ProducerModule
-  static final class ProducesMethodsModule {
-    @Produces String produceString() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Produces ListenableFuture<String> produceFutureString() {
-      throw new UnsupportedOperationException();
-    }
-  }
-
-  @Test public void forProducesMethod_sets() {
-    TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
-    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
-    TypeMirror setOfStringsType = types.getDeclaredType(setElement, stringType);
-    TypeElement moduleElement =
-        elements.getTypeElement(SetProducesMethodsModule.class.getCanonicalName());
-    for (ExecutableElement producesMethod
-        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      Key key = keyFactory.forProducesMethod(producesMethod, moduleElement);
-      assertThat(key)
-          .isEqualTo(
-              Key.builder(setOfStringsType)
-                  .multibindingContributionIdentifier(
-                      new MultibindingContributionIdentifier(producesMethod, moduleElement))
-                  .build());
-      assertThat(key.toString())
-          .isEqualTo(
-              String.format(
-                  "java.util.Set<java.lang.String> "
-                      + "dagger.internal.codegen.KeyTest.SetProducesMethodsModule#%s",
-                  producesMethod.getSimpleName()));
-    }
-  }
-
-  @ProducerModule
-  static final class SetProducesMethodsModule {
-    @Produces @IntoSet String produceString() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Produces @IntoSet ListenableFuture<String> produceFutureString() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Produces @ElementsIntoSet Set<String> produceStrings() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Produces @ElementsIntoSet
-    ListenableFuture<Set<String>> produceFutureStrings() {
-      throw new UnsupportedOperationException();
-    }
-  }
-}
diff --git a/core/pom.xml b/core/pom.xml
index f1fd6c133..8c79a67e7 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.8</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>dagger</artifactId>
@@ -65,11 +65,11 @@
               <goal>compile</goal>
             </goals>
             <configuration>
-              <source>1.8</source>
-              <target>1.8</target>
+              <source>1.7</source>
+              <target>1.7</target>
             </configuration>
           </execution>
-          <execution>
+          <!--<execution>
             <id>default-testCompile</id>
             <goals>
               <goal>testCompile</goal>
@@ -78,13 +78,13 @@
               <source>1.8</source>
               <target>1.8</target>
             </configuration>
-          </execution>
+          </execution>-->
         </executions>
       </plugin>
-      <plugin>
+      <!--<plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>1.8</version><!-- 1.9+ requires JDK7 on the build machine -->
+        <version>1.8</version>
         <executions>
           <execution>
             <id>sniff-api</id>
@@ -94,11 +94,11 @@
         <configuration>
           <signature>
             <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java16</artifactId>
+            <artifactId>java17</artifactId>
             <version>1.0</version>
           </signature>
         </configuration>
-      </plugin>
+      </plugin>-->
       <plugin>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
@@ -117,7 +117,7 @@
           </execution>
         </executions>
       </plugin>
-      <plugin>
+      <!--<plugin>
         <artifactId>maven-jar-plugin</artifactId>
         <executions>
           <execution>
@@ -126,7 +126,7 @@
             </goals>
           </execution>
         </executions>
-      </plugin>
+      </plugin>-->
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
diff --git a/core/src/main/java/dagger/Config.java b/core/src/main/java/dagger/Config.java
new file mode 100644
index 000000000..75f48b8b6
--- /dev/null
+++ b/core/src/main/java/dagger/Config.java
@@ -0,0 +1,15 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target(TYPE)
+@Documented
+public @interface Config {
+    Class<?> applicationClass();
+}
diff --git a/core/src/main/java/dagger/IgnoreStubGeneration.java b/core/src/main/java/dagger/IgnoreStubGeneration.java
new file mode 100644
index 000000000..5ee236329
--- /dev/null
+++ b/core/src/main/java/dagger/IgnoreStubGeneration.java
@@ -0,0 +1,16 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.CONSTRUCTOR;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target({METHOD, CONSTRUCTOR})
+@Documented
+public @interface IgnoreStubGeneration {
+}
diff --git a/core/src/main/java/dagger/Trigger.java b/core/src/main/java/dagger/Trigger.java
index dfe9b4411..43a27d3dc 100644
--- a/core/src/main/java/dagger/Trigger.java
+++ b/core/src/main/java/dagger/Trigger.java
@@ -9,7 +9,7 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 @Retention(RUNTIME)
-@Target(METHOD)
+@Target({METHOD, TYPE})
 @Documented
 public @interface Trigger {
     String value();
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 3c8a64f1a..bda81d618 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.8</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AppConfig.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AppConfig.java
new file mode 100644
index 000000000..1b721ae1a
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AppConfig.java
@@ -0,0 +1,7 @@
+package com.example.dagger.activitygraphs;
+
+import dagger.Config;
+
+@Config(applicationClass = DemoApplication.class)
+public class AppConfig {
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
index 37629ee3b..e57f8cea7 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
@@ -27,8 +27,6 @@
 @Singleton // Constraints this component to one-per-application or unscoped bindings.
 @Component(modules = DemoApplicationModule.class)
 public interface ApplicationComponent {
-  // Field injections of any dependencies of the DemoApplication
-  void inject(DemoApplication application);
 
   // Exported for child-components.
   Application application();
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
index 5e746dc6d..2ef7da478 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
@@ -19,17 +19,20 @@
 import android.app.Activity;
 import android.app.Application;
 import android.location.LocationManager;
-import com.example.dagger.activitygraphs.ui.DaggerHomeComponent;
 import com.example.dagger.activitygraphs.ui.HomeComponent;
 import dagger.Injector;
 import dagger.Provides;
 import dagger.ProvidesComponent;
 import dagger.ProvidesModule;
+import factories.DaggerAbstractActivityComponent;
+import factories.DaggerApplicationComponent;
+import factories.DaggerFragmentComponent;
+import factories.DaggerHomeComponent;
+import injector.InjectorSpec;
 
 import javax.inject.Inject;
 
-@Injector
-public class DemoApplication extends Application {
+public class DemoApplication extends Application implements InjectorSpec {
   private ApplicationComponent applicationComponent;
 
   // TODO(cgruber): Figure out a better example of something one might inject into the app.
@@ -42,30 +45,35 @@
         .build();
   }
 
-  @ProvidesComponent
   public ApplicationComponent component() {
     return applicationComponent;
   }
 
-  @ProvidesComponent
-  public AbstractActivityComponent activityComponent(Activity activity) {
-    return DaggerAbstractActivityComponent.builder()
-            .activityModule(new ActivityModule(activity))
-            .applicationComponent(this.component())
-            .build();
+  @Override
+  public DaggerFragmentComponent.Builder fragmentComponent(DaggerFragmentComponent.Builder builder,
+                                                           AbstractActivityComponent abstractActivityComponent) {
+    return builder.abstractActivityComponent(abstractActivityComponent);
   }
 
-  @ProvidesComponent
-  public FragmentComponent fragmentComponent(AbstractActivityComponent component) {
-      return null;
+  @Override
+  public DaggerAbstractActivityComponent.Builder abstractActivityComponent(DaggerAbstractActivityComponent.Builder builder,
+                                                                           ActivityModule activityModule,
+                                                                           ApplicationComponent applicationComponent) {
+    return builder.applicationComponent(applicationComponent).activityModule(activityModule);
   }
 
-  @ProvidesComponent
-  public HomeComponent homeComponent(Activity activity) {
-    return DaggerHomeComponent.builder()
-            .activityModule(new ActivityModule(activity))
-            .applicationComponent(this.component())
-            .build();
+  @Override
+  public DaggerHomeComponent.Builder homeComponent(DaggerHomeComponent.Builder builder, ActivityModule activityModule, ApplicationComponent applicationComponent) {
+    return null;
   }
 
+  @Override
+  public DaggerApplicationComponent.Builder applicationComponent(DaggerApplicationComponent.Builder builder, DemoApplicationModule demoApplicationModule) {
+    return null;
+  }
+
+  @Override
+  public injector.Injector getInjector() {
+    return null;
+  }
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
index 149c52b83..2c31d5318 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
@@ -23,6 +23,7 @@
 import com.example.dagger.activitygraphs.DemoApplication;
 import com.example.dagger.activitygraphs.SomeClass;
 import dagger.Lazy;
+import factories.DaggerHomeComponent;
 
 import javax.inject.Inject;
 import javax.inject.Named;
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index c99e710a4..c69696f29 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.8</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/AppConfig.java b/examples/android-simple/src/main/java/com/example/dagger/simple/AppConfig.java
new file mode 100644
index 000000000..50c50732d
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/AppConfig.java
@@ -0,0 +1,7 @@
+package com.example.dagger.simple;
+
+import dagger.Config;
+
+@Config(applicationClass = DemoApplication1.class)
+public class AppConfig {
+}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java b/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java
new file mode 100644
index 000000000..60112f96e
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java
@@ -0,0 +1,19 @@
+package com.example.dagger.simple;
+
+import com.example.dagger.simple.ui.HomeActivity;
+import dagger.Component;
+import javax.inject.Singleton;
+
+
+public interface Components {
+
+    @Singleton
+    @Component(modules = {AndroidModule.class, SingletonModule.class})
+    public interface ApplicationComponent {
+        //void inject(DemoApplication1 application);
+        void inject(HomeActivity homeActivity);
+        void inject(DemoActivity demoActivity);
+    }
+
+
+}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
index 5803188cb..5e2115199 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
@@ -18,44 +18,37 @@
 
 import android.app.Application;
 import android.location.LocationManager;
-import com.example.dagger.simple.ui.HomeActivity;
-import dagger.Component;
-import dagger.Injector;
-import dagger.ProvidesComponent;
-import dagger.ProvidesModule;
+import factories.DaggerComponents_ApplicationComponent;
+import injector.Injector;
+import injector.InjectorSpec;
 
 import javax.inject.Inject;
 import javax.inject.Named;
-import javax.inject.Singleton;
-
-@Injector
-public class DemoApplication1 extends Application {
-  
-  @Singleton
-  @Component(modules = {AndroidModule.class, SingletonModule.class})
-  public interface ApplicationComponent {
-    void inject(DemoApplication1 application);
-    void inject(HomeActivity homeActivity);
-    void inject(DemoActivity demoActivity);
-  }
-  
+
+public class DemoApplication1 extends Application implements InjectorSpec{
+
   @Inject LocationManager locationManager; // for some reason.
   @Inject @Named("apiKey") String someString;
   @Inject @Named("apiKey1") String anotherString;
-  private ApplicationComponent component;
+  private Components.ApplicationComponent component;
+ // private Injector injector = new Injector(this);
 
   @Override public void onCreate() {
     super.onCreate();
-    component = DaggerDemoApplication1_ApplicationComponent.builder()
-        .androidModule(new AndroidModule(this))
-        .singletonModule(new SingletonModule())
-        .build();
-    component().inject(this); // As of now, LocationManager should be injected into this.
+    //component = injector.applicationComponent(new AndroidModule(this), new SingletonModule());
+    //component.inject(this);
   }
 
-  @ProvidesComponent
-  public ApplicationComponent component() {
+  public Components.ApplicationComponent component() {
     return component;
   }
 
+  public DaggerComponents_ApplicationComponent.Builder applicationComponent(DaggerComponents_ApplicationComponent.Builder builder, AndroidModule androidModule, SingletonModule singletonModule) {
+    return builder.androidModule(new AndroidModule(this)).singletonModule(new SingletonModule());
+  }
+
+  @Override
+  public Injector getInjector() {
+    return null;
+  }
 }
diff --git a/examples/pom.xml b/examples/pom.xml
index 59d683e02..a47ed9ad9 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.8</version>
+    <version>3.0</version>
   </parent>
 
   <groupId>com.google.dagger.example</groupId>
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index af75ff2e3..2eb62d43f 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.8</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>simple</artifactId>
diff --git a/examples/simple/src/main/java/coffee/App.java b/examples/simple/src/main/java/coffee/App.java
new file mode 100644
index 000000000..6b59c22ad
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/App.java
@@ -0,0 +1,33 @@
+package coffee;
+
+import dagger.Injector;
+import dagger.ProvidesComponent;
+import dagger.ProvidesModule;
+import dagger.ProvidesSubcomponent;
+import factories.DaggerCoffeeApp_Coffee;
+import injector.InjectorSpec;
+
+public class App implements InjectorSpec {
+
+    @Override
+    public CoffeeApp.Bleu2.Builder bleu2(CoffeeApp.Bleu2.Builder builder, BModule bModule) {
+        return builder.someModule(bModule);
+    }
+
+    @Override
+    public CoffeeApp.Bleu.Builder bleu(CoffeeApp.Bleu.Builder builder, AModule aModule, BModule bModule) {
+        return builder.moduleA(aModule).moduleB(bModule);
+    }
+
+    @Override
+    public DaggerCoffeeApp_Coffee.Builder coffee(DaggerCoffeeApp_Coffee.Builder builder, DripCoffeeModule dripCoffeeModule) {
+        return builder.dripCoffeeModule(dripCoffeeModule);
+    }
+
+    @Override
+    public injector.Injector getInjector() {
+        return new injector.Injector(this);
+    }
+
+
+}
diff --git a/examples/simple/src/main/java/coffee/AppConfig.java b/examples/simple/src/main/java/coffee/AppConfig.java
new file mode 100644
index 000000000..efd0946ca
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/AppConfig.java
@@ -0,0 +1,7 @@
+package coffee;
+
+import dagger.Config;
+
+@Config(applicationClass = App.class)
+public class AppConfig {
+}
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index bacd465ff..6ab6753a7 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -4,6 +4,7 @@
 import dagger.Module;
 import dagger.ProvidesModule;
 import dagger.Subcomponent;
+import factories.DaggerCoffeeApp_Coffee;
 
 import javax.inject.Named;
 import javax.inject.Singleton;
@@ -14,7 +15,7 @@
   public interface Coffee {
     CoffeeMaker maker();
     Thermosiphon thermosiphon();
-    Bleu plus(AModule module, BModule moduleB);
+    Bleu.Builder bleu();
   }
 
   @ActivityScope
@@ -22,6 +23,12 @@
   public interface Bleu {
     Integer integer();
     Bleu2.Builder someComponent();
+    @Subcomponent.Builder
+    interface Builder {
+      Builder moduleA(AModule module);
+      Builder moduleB(BModule module);
+      Bleu build();
+    }
   }
 
   @Subcomponent(modules = {BModule.class})
diff --git a/examples/simple/src/main/java/coffee/CoffeeMaker.java b/examples/simple/src/main/java/coffee/CoffeeMaker.java
index b9829ba32..67b9876c7 100644
--- a/examples/simple/src/main/java/coffee/CoffeeMaker.java
+++ b/examples/simple/src/main/java/coffee/CoffeeMaker.java
@@ -3,7 +3,7 @@
 import dagger.Lazy;
 import javax.inject.Inject;
 
-class CoffeeMaker {
+public class CoffeeMaker {
 
   private final Pump pump;
   @Inject
diff --git a/examples/simple/src/main/java/coffee/DependencyInjector.java b/examples/simple/src/main/java/coffee/DependencyInjector.java
deleted file mode 100644
index 861e52be2..000000000
--- a/examples/simple/src/main/java/coffee/DependencyInjector.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package coffee;
-
-import dagger.Injector;
-import dagger.ProvidesComponent;
-import dagger.ProvidesModule;
-import dagger.ProvidesSubcomponent;
-
-
-@Injector
-public class DependencyInjector {
-
-    @ProvidesComponent
-    public CoffeeApp.Coffee coffee() {
-        return DaggerCoffeeApp_Coffee.builder()
-                .dripCoffeeModule(new DripCoffeeModule())
-                .build();
-    }
-
-    @ProvidesSubcomponent
-    public CoffeeApp.Bleu bleu(CoffeeApp.Coffee coffee, double d) {
-        return coffee.plus(new AModule(), new BModule(d));
-    }
-
-    @ProvidesSubcomponent
-    public CoffeeApp.Bleu2 bleu2(CoffeeApp.Bleu bleu, double d) {
-        return bleu.someComponent()
-                .someModule(new BModule(d))
-                .build();
-    }
-
-
-    @ProvidesModule
-    public BModule moduleB(double a) {
-        return new BModule(a);
-    }
-}
diff --git a/examples/simple/src/main/java/coffee/DripCoffeeModule.java b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
index 0a18d917a..99df0114c 100644
--- a/examples/simple/src/main/java/coffee/DripCoffeeModule.java
+++ b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
@@ -5,7 +5,7 @@
 import javax.inject.Singleton;
 
 @Module(includes = PumpModule.class)
-class DripCoffeeModule {
+public class DripCoffeeModule {
   @Provides @Singleton Heater provideHeater() {
     return new ElectricHeater();
   }
diff --git a/examples/simple/src/main/java/coffee/Heater.java b/examples/simple/src/main/java/coffee/Heater.java
index b5ddb6b88..80cc67afd 100644
--- a/examples/simple/src/main/java/coffee/Heater.java
+++ b/examples/simple/src/main/java/coffee/Heater.java
@@ -1,6 +1,6 @@
 package coffee;
 
-interface Heater {
+public interface Heater {
   void on();
   void off();
   boolean isHot();
diff --git a/examples/simple/src/main/java/coffee/Pump.java b/examples/simple/src/main/java/coffee/Pump.java
index e39434913..7358df8af 100644
--- a/examples/simple/src/main/java/coffee/Pump.java
+++ b/examples/simple/src/main/java/coffee/Pump.java
@@ -1,5 +1,5 @@
 package coffee;
 
-interface Pump {
+public interface Pump {
   void pump();
 }
diff --git a/examples/simple/src/main/java/coffee/PumpModule.java b/examples/simple/src/main/java/coffee/PumpModule.java
index df00b8624..d330d86de 100644
--- a/examples/simple/src/main/java/coffee/PumpModule.java
+++ b/examples/simple/src/main/java/coffee/PumpModule.java
@@ -4,7 +4,7 @@
 import dagger.Module;
 
 @Module
-abstract class PumpModule {
+public abstract class PumpModule {
   @Binds
   abstract Pump providePump(Thermosiphon pump);
 }
diff --git a/examples/simple/src/main/java/coffee/Thermosiphon.java b/examples/simple/src/main/java/coffee/Thermosiphon.java
index f5f45a957..a20033ee3 100644
--- a/examples/simple/src/main/java/coffee/Thermosiphon.java
+++ b/examples/simple/src/main/java/coffee/Thermosiphon.java
@@ -3,7 +3,7 @@
 import javax.inject.Inject;
 import javax.inject.Provider;
 
-class Thermosiphon implements Pump {
+public class Thermosiphon implements Pump {
   private final Provider<Heater> heater;
 
   @Inject
diff --git a/pom.xml b/pom.xml
index bf781d851..8047fc439 100644
--- a/pom.xml
+++ b/pom.xml
@@ -27,7 +27,7 @@
   <groupId>com.google.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>2.8</version>
+  <version>3.0</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
diff --git a/producers/pom.xml b/producers/pom.xml
index 8557524d6..187d37e66 100644
--- a/producers/pom.xml
+++ b/producers/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.8</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>dagger-producers</artifactId>
