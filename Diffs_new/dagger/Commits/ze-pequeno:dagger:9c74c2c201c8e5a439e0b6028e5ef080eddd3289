diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 835c7f5a0..3a3e4491c 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -26,6 +26,7 @@
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.DelegateBindingExpression.isBindsScopeStrongerThanDependencyScope;
 import static dagger.internal.codegen.MemberSelect.staticFactoryCreation;
+import static dagger.internal.codegen.RequestKinds.isDerivedFromProvider;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
 import static dagger.model.BindingKind.DELEGATE;
@@ -49,7 +50,6 @@
 
 /** A central repository of code expressions used to access any binding available to a component. */
 final class ComponentBindingExpressions {
-
   // TODO(dpb,ronshapiro): refactor this and ComponentRequirementFields into a
   // HierarchicalComponentMap<K, V>, or perhaps this use a flattened ImmutableMap, built from its
   // parents? If so, maybe make BindingExpression.Factory create it.
@@ -250,6 +250,17 @@ BindingExpression getBindingExpression(BindingRequest request) {
         expression = Optional.of(createBindingExpression(resolvedBindings, request));
       }
     }
+    if (!expression.isPresent()
+        && compilerOptions.aheadOfTimeSubcomponents()
+        && request.requestKind().isPresent()
+        && isDerivedFromProvider(request.requestKind().get())) {
+      RequestKind requestKind = request.requestKind().get();
+      expression =
+          Optional.of(
+              new DerivedFromFrameworkInstanceBindingExpression(
+                  request.key(), FrameworkType.PROVIDER, requestKind, this, types));
+    }
+
     if (expression.isPresent()) {
       expressions.put(request, expression.get());
       return expression.get();
@@ -415,7 +426,7 @@ private BindingExpression provisionBindingExpression(
       case PRODUCED:
       case PROVIDER_OF_LAZY:
         return new DerivedFromFrameworkInstanceBindingExpression(
-            resolvedBindings, FrameworkType.PROVIDER, requestKind, this, types);
+            resolvedBindings.key(), FrameworkType.PROVIDER, requestKind, this, types);
 
       case PRODUCER:
         return producerFromProviderBindingExpression(resolvedBindings);
@@ -437,8 +448,9 @@ private BindingExpression productionBindingExpression(
       return frameworkInstanceBindingExpression(resolvedBindings);
     } else {
       // If no FrameworkType is present, a RequestKind is guaranteed to be present.
+      RequestKind requestKind = request.requestKind().get();
       return new DerivedFromFrameworkInstanceBindingExpression(
-          resolvedBindings, FrameworkType.PRODUCER_NODE, request.requestKind().get(), this, types);
+          resolvedBindings.key(), FrameworkType.PRODUCER_NODE, requestKind, this, types);
     }
   }
 
@@ -514,7 +526,7 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
           : directInstanceExpression;
     }
     return new DerivedFromFrameworkInstanceBindingExpression(
-        resolvedBindings, FrameworkType.PROVIDER, RequestKind.INSTANCE, this, types);
+        resolvedBindings.key(), FrameworkType.PROVIDER, RequestKind.INSTANCE, this, types);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
index bd245a259..0f5b57d11 100644
--- a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
@@ -21,6 +21,7 @@
 
 import com.squareup.javapoet.ClassName;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.model.Key;
 import dagger.model.RequestKind;
 
 /** A binding expression that depends on a framework instance. */
@@ -33,12 +34,12 @@
   private final DaggerTypes types;
 
   DerivedFromFrameworkInstanceBindingExpression(
-      ResolvedBindings resolvedBindings,
+      Key key,
       FrameworkType frameworkType,
       RequestKind requestKind,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types) {
-    this.frameworkRequest = bindingRequest(resolvedBindings.key(), frameworkType);
+    this.frameworkRequest = bindingRequest(key, frameworkType);
     this.requestKind = checkNotNull(requestKind);
     this.frameworkType = checkNotNull(frameworkType);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index 6755825a2..cd7e90f4e 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -259,6 +259,10 @@ ModifiableBindingType getModifiableBindingType(BindingRequest request) {
       return ModifiableBindingType.NONE;
     }
 
+    if (request.requestKind().filter(RequestKinds::isDerivedFromProvider).isPresent()) {
+      return ModifiableBindingType.NONE;
+    }
+
     if (resolvedInThisComponent(request)) {
       ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
       if (resolvedBindings.contributionBindings().isEmpty()) {
diff --git a/java/dagger/internal/codegen/RequestKinds.java b/java/dagger/internal/codegen/RequestKinds.java
index 1a1516e51..ab0197371 100644
--- a/java/dagger/internal/codegen/RequestKinds.java
+++ b/java/dagger/internal/codegen/RequestKinds.java
@@ -184,5 +184,19 @@ static boolean entryPointCanUseProduction(RequestKind requestKind) {
     throw new AssertionError();
   }
 
+  /**
+   * Returns true if {@code requestKind} is always derived from a {@link RequestKind#PROVIDER}
+   * instance.
+   */
+  static boolean isDerivedFromProvider(RequestKind requestKind) {
+    switch (requestKind) {
+      case LAZY:
+      case PROVIDER_OF_LAZY:
+        return true;
+      default:
+        return false;
+    }
+  }
+
   private RequestKinds() {}
 }
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index e036743d5..87a1007d4 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -27,7 +27,6 @@
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -4737,7 +4736,6 @@ public void producesMethodInstalledInLeafAndAncestor() {
         .hasSourceEquivalentTo(generatedAncestor);
   }
 
-  @Ignore // TODO(b/72748365): see if we can get this to work.
   @Test
   public void lazyOfModifiableBinding() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
@@ -4771,17 +4769,17 @@ public void lazyOfModifiableBinding() {
             "public abstract class DaggerLeaf implements Leaf {",
             "  protected DaggerLeaf() {}",
             "",
-            "  protected abstract Provider<MissingInLeaf> missingInLeafProvider();",
-            "",
             "  @Override",
-            "  public final Lazy<MissingInLeaf> lazy() {",
-            "    return DoubleCheck.lazy(missingInLeafProvider());",
+            "  public Lazy<MissingInLeaf> lazy() {",
+            "    return DoubleCheck.lazy(getMissingInLeafProvider());",
             "  }",
             "",
             "  @Override",
-            "  public final Provider<Lazy<MissingInLeaf>> providerOfLazy() {",
-            "    return ProviderOfLazy.create(missingInLeafProvider());",
+            "  public Provider<Lazy<MissingInLeaf>> providerOfLazy() {",
+            "    return ProviderOfLazy.create(getMissingInLeafProvider());",
             "  }",
+            "",
+            "  protected abstract Provider getMissingInLeafProvider();",
             "}");
     Compilation compilation = compile(filesToCompile.build());
     assertThat(compilation).succeededWithoutWarnings();
@@ -4818,6 +4816,7 @@ public void lazyOfModifiableBinding() {
             "package test;",
             "",
             IMPORT_GENERATED_ANNOTATION,
+            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public abstract class DaggerAncestor implements Ancestor {",
@@ -4827,7 +4826,7 @@ public void lazyOfModifiableBinding() {
             "    protected LeafImpl() {}",
             "",
             "    @Override",
-            "    protected abstract Provider<MissingInLeaf> missingInLeafProvider() {",
+            "    protected final Provider getMissingInLeafProvider() {",
             "      return AncestorModule_SatisfiedInAncestorFactory.create();",
             "    }",
             "  }",
