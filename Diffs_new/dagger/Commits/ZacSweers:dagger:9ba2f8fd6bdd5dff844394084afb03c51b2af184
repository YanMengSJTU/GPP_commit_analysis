diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 133a59cb8..e33c362ad 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -75,11 +75,10 @@
   // TODO(dpb): Make all these fields private after refactoring is complete.
   protected final Elements elements;
   protected final DaggerTypes types;
-  protected final KeyFactory keyFactory;
   protected final CompilerOptions compilerOptions;
   protected final ClassName name;
   protected final BindingGraph graph;
-  protected final ImmutableMap<ComponentDescriptor, String> subcomponentNames;
+  protected final SubcomponentNames subcomponentNames;
   protected final TypeSpec.Builder component;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
@@ -111,17 +110,15 @@
   AbstractComponentWriter(
       DaggerTypes types,
       Elements elements,
-      KeyFactory keyFactory,
       CompilerOptions compilerOptions,
       ClassName name,
       BindingGraph graph,
-      ImmutableMap<ComponentDescriptor, String> subcomponentNames,
+      SubcomponentNames subcomponentNames,
       OptionalFactories optionalFactories,
       ComponentBindingExpressions bindingExpressions,
       ComponentRequirementFields componentRequirementFields) {
     this.types = types;
     this.elements = elements;
-    this.keyFactory = keyFactory;
     this.compilerOptions = compilerOptions;
     this.component = classBuilder(name);
     this.name = name;
@@ -144,7 +141,7 @@
             bindingExpressions,
             componentRequirementFields,
             this,
-            childComponentNames(keyFactory, subcomponentNames),
+            subcomponentNames,
             graph,
             types,
             elements,
@@ -153,26 +150,11 @@
         new ComponentRequirementField.Factory(this, name, builderFields);
   }
 
-  private static ImmutableMap<BindingKey, String> childComponentNames(
-      KeyFactory keyFactory, ImmutableMap<ComponentDescriptor, String> subcomponentNames) {
-    ImmutableMap.Builder<BindingKey, String> builder = ImmutableMap.builder();
-    subcomponentNames.forEach(
-        (component, name) -> {
-          if (component.builderSpec().isPresent()) {
-            TypeMirror builderType = component.builderSpec().get().builderDefinitionType().asType();
-            builder.put(
-                BindingKey.contribution(keyFactory.forSubcomponentBuilder(builderType)), name);
-          }
-        });
-    return builder.build();
-  }
-
   protected AbstractComponentWriter(
       AbstractComponentWriter parent, ClassName name, BindingGraph graph) {
     this(
         parent.types,
         parent.elements,
-        parent.keyFactory,
         parent.compilerOptions,
         name,
         graph,
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index e36747957..ba0a52a0c 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -214,6 +214,7 @@ java_library(
         "SimpleInvocationBindingExpression.java",
         "SimpleMethodBindingExpression.java",
         "SubcomponentBuilderBindingExpression.java",
+        "SubcomponentNames.java",
         "SubcomponentWriter.java",
         "UnwrappedMapKeyGenerator.java",
     ],
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 4903c266a..e15645fea 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -26,7 +26,6 @@
 import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -78,7 +77,7 @@ CodeBlock getComponentMethodImplementation(DependencyRequest request, ClassName
     private final ComponentBindingExpressions componentBindingExpressions;
     private final ComponentRequirementFields componentRequirementFields;
     private final GeneratedComponentModel generatedComponentModel;
-    private final ImmutableMap<BindingKey, String> subcomponentNames;
+    private final SubcomponentNames subcomponentNames;
     private final BindingGraph graph;
     private final DaggerTypes types;
     private final Elements elements;
@@ -90,7 +89,7 @@ CodeBlock getComponentMethodImplementation(DependencyRequest request, ClassName
         ComponentBindingExpressions componentBindingExpressions,
         ComponentRequirementFields componentRequirementFields,
         GeneratedComponentModel generatedComponentModel,
-        ImmutableMap<BindingKey, String> subcomponentNames,
+        SubcomponentNames subcomponentNames,
         BindingGraph graph,
         DaggerTypes types,
         Elements elements,
diff --git a/java/dagger/internal/codegen/ComponentBuilder.java b/java/dagger/internal/codegen/ComponentBuilder.java
index 5767d7634..120ae5e07 100644
--- a/java/dagger/internal/codegen/ComponentBuilder.java
+++ b/java/dagger/internal/codegen/ComponentBuilder.java
@@ -78,7 +78,7 @@ ClassName name() {
   static ComponentBuilder create(
       ClassName componentName,
       BindingGraph graph,
-      ImmutableMap<ComponentDescriptor, String> subcomponentNames,
+      SubcomponentNames subcomponentNames,
       Elements elements,
       Types types) {
     return new Creator(componentName, graph, subcomponentNames, elements, types).create();
@@ -99,7 +99,7 @@ static ComponentBuilder create(
     Creator(
         ClassName componentName,
         BindingGraph graph,
-        ImmutableMap<ComponentDescriptor, String> subcomponentNames,
+        SubcomponentNames subcomponentNames,
         Elements elements,
         Types types) {
       this.componentName = componentName;
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index de1840d33..a7d2b29f7 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -18,29 +18,14 @@
 
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static java.lang.Character.isUpperCase;
-import static java.lang.String.format;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
-import com.google.common.base.CharMatcher;
-import com.google.common.base.Splitter;
-import com.google.common.collect.ImmutableBiMap;
-import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Multimaps;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Map.Entry;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 
 /**
@@ -58,126 +43,15 @@
     super(
         types,
         elements,
-        keyFactory,
         compilerOptions,
         name,
         graph,
-        new UniqueSubcomponentNamesGenerator(graph).generate(),
+        new SubcomponentNames(graph, keyFactory),
         new OptionalFactories(),
         new ComponentBindingExpressions(types),
         new ComponentRequirementFields());
   }
 
-  /**
-   * Generates a map of unique simple names for all subcomponents, keyed by their {@link
-   * ComponentDescriptor}.
-   */
-  private static class UniqueSubcomponentNamesGenerator {
-
-    private static final Splitter QUALIFIED_NAME_SPLITTER = Splitter.on('.');
-
-    private final BindingGraph graph;
-    private final ImmutableListMultimap<String, ComponentDescriptor>
-        componentDescriptorsBySimpleName;
-    private final ImmutableMap<ComponentDescriptor, Namer> componentNamers;
-
-    private UniqueSubcomponentNamesGenerator(BindingGraph graph) {
-      this.graph = graph;
-      componentDescriptorsBySimpleName =
-          Multimaps.index(
-              graph.componentDescriptors(),
-              componentDescriptor ->
-                  componentDescriptor.componentDefinitionType().getSimpleName().toString());
-      componentNamers = qualifiedNames(graph.componentDescriptors());
-    }
-
-    private ImmutableBiMap<ComponentDescriptor, String> generate() {
-      Map<ComponentDescriptor, String> subcomponentImplSimpleNames = new LinkedHashMap<>();
-      for (Entry<String, Collection<ComponentDescriptor>> componentEntry :
-          componentDescriptorsBySimpleName.asMap().entrySet()) {
-        Collection<ComponentDescriptor> components = componentEntry.getValue();
-        subcomponentImplSimpleNames.putAll(disambiguateConflictingSimpleNames(components));
-      }
-      subcomponentImplSimpleNames.remove(graph.componentDescriptor());
-      return ImmutableBiMap.copyOf(subcomponentImplSimpleNames);
-    }
-
-    private ImmutableBiMap<ComponentDescriptor, String> disambiguateConflictingSimpleNames(
-        Collection<ComponentDescriptor> components) {
-      Map<String, ComponentDescriptor> generatedSimpleNames = new LinkedHashMap<>();
-
-      // Let's see if we can get away with using simpleName() everywhere.
-      for (ComponentDescriptor component : components) {
-        Namer namer = componentNamers.get(component);
-        if (generatedSimpleNames.containsKey(namer.simpleName())) {
-          break;
-        }
-        generatedSimpleNames.put(namer.simpleName(), component);
-      }
-
-      if (generatedSimpleNames.size() != components.size()) {
-        // Simple approach didn't work out, let's use more complicated names.
-        // We keep them small to fix https://github.com/google/dagger/issues/421.
-        generatedSimpleNames.clear();
-        UniqueNameSet nameSet = new UniqueNameSet();
-        for (ComponentDescriptor component : components) {
-          Namer namer = componentNamers.get(component);
-          String simpleName = namer.simpleName();
-          String basePrefix = namer.uniquingPrefix();
-          generatedSimpleNames.put(format("%s_%s", nameSet.getUniqueName(basePrefix), simpleName),
-              component);
-        }
-      }
-      return ImmutableBiMap.copyOf(generatedSimpleNames).inverse();
-    }
-
-    private static ImmutableMap<ComponentDescriptor, Namer> qualifiedNames(
-        Iterable<ComponentDescriptor> componentDescriptors) {
-      ImmutableMap.Builder<ComponentDescriptor, Namer> builder = ImmutableMap.builder();
-      for (ComponentDescriptor component : componentDescriptors) {
-        builder.put(component, new Namer(component.componentDefinitionType()));
-      }
-      return builder.build();
-    }
-
-    private static final class Namer {
-      final TypeElement typeElement;
-
-      Namer(TypeElement typeElement) {
-        this.typeElement = typeElement;
-      }
-
-      String simpleName() {
-        return typeElement.getSimpleName().toString();
-      }
-
-      /** Returns a prefix that could make {@link #simpleName()} more unique. */
-      String uniquingPrefix() {
-        String containerName = typeElement.getEnclosingElement().getSimpleName().toString();
-
-        // If parent element looks like a class, use its initials as a prefix.
-        if (!containerName.isEmpty() && isUpperCase(containerName.charAt(0))) {
-          return CharMatcher.javaLowerCase().removeFrom(containerName);
-        }
-
-        // Not in a normally named class. Prefix with the initials of the elements leading here.
-        Name qualifiedName = typeElement.getQualifiedName();
-        Iterator<String> pieces = QUALIFIED_NAME_SPLITTER.split(qualifiedName).iterator();
-        StringBuilder b = new StringBuilder();
-
-        while (pieces.hasNext()) {
-          String next = pieces.next();
-          if (pieces.hasNext()) {
-            b.append(next.charAt(0));
-          }
-        }
-
-        // Note that a top level class in the root package will be prefixed "$_".
-        return b.length() > 0 ? b.toString() : "$";
-      }
-    }
-  }
-
   @Override
   protected void decorateComponent() {
     component.addModifiers(PUBLIC, FINAL);
diff --git a/java/dagger/internal/codegen/SubcomponentNames.java b/java/dagger/internal/codegen/SubcomponentNames.java
new file mode 100644
index 000000000..451f5e544
--- /dev/null
+++ b/java/dagger/internal/codegen/SubcomponentNames.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static java.lang.Character.isUpperCase;
+import static java.lang.String.format;
+
+import com.google.common.base.CharMatcher;
+import com.google.common.base.Splitter;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Multimaps;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Holds the unique simple names for all subcomponents, keyed by their {@link ComponentDescriptor}
+ * and {@link BindingKey} of the subcomponent builder.
+ */
+final class SubcomponentNames {
+  private static final Splitter QUALIFIED_NAME_SPLITTER = Splitter.on('.');
+  private final ImmutableMap<ComponentDescriptor, String> namesByDescriptor;
+  private final ImmutableMap<BindingKey, String> namesByBindingKey;
+
+  SubcomponentNames(BindingGraph graph, KeyFactory keyFactory) {
+    this.namesByDescriptor = namesByDescriptor(graph);
+    this.namesByBindingKey = namesByBindingKey(keyFactory, namesByDescriptor);
+  }
+
+  /** Returns the simple component name for the given {@link ComponentDescriptor}. */
+  String get(ComponentDescriptor componentDescriptor) {
+    return namesByDescriptor.get(componentDescriptor);
+  }
+
+  /** Returns the simple component name for the given subcomponent builder {@link BindingKey}. */
+  String get(BindingKey bindingKey) {
+    return namesByBindingKey.get(bindingKey);
+  }
+
+  private static ImmutableMap<ComponentDescriptor, String> namesByDescriptor(BindingGraph graph) {
+    ImmutableListMultimap<String, ComponentDescriptor> componentDescriptorsBySimpleName =
+        Multimaps.index(
+            graph.componentDescriptors(),
+            componentDescriptor ->
+                componentDescriptor.componentDefinitionType().getSimpleName().toString());
+    ImmutableMap<ComponentDescriptor, Namer> componentNamers =
+        qualifiedNames(graph.componentDescriptors());
+    Map<ComponentDescriptor, String> subcomponentImplSimpleNames = new LinkedHashMap<>();
+    componentDescriptorsBySimpleName
+        .asMap()
+        .values()
+        .forEach(
+            components ->
+                subcomponentImplSimpleNames.putAll(
+                    disambiguateConflictingSimpleNames(components, componentNamers)));
+    subcomponentImplSimpleNames.remove(graph.componentDescriptor());
+    return ImmutableMap.copyOf(subcomponentImplSimpleNames);
+  }
+
+  private static ImmutableMap<BindingKey, String> namesByBindingKey(
+      KeyFactory keyFactory, ImmutableMap<ComponentDescriptor, String> subcomponentNames) {
+    ImmutableMap.Builder<BindingKey, String> builder = ImmutableMap.builder();
+    subcomponentNames.forEach(
+        (component, name) -> {
+          if (component.builderSpec().isPresent()) {
+            TypeMirror builderType = component.builderSpec().get().builderDefinitionType().asType();
+            builder.put(
+                BindingKey.contribution(keyFactory.forSubcomponentBuilder(builderType)), name);
+          }
+        });
+    return builder.build();
+  }
+
+  private static ImmutableBiMap<ComponentDescriptor, String> disambiguateConflictingSimpleNames(
+      Collection<ComponentDescriptor> components,
+      ImmutableMap<ComponentDescriptor, Namer> componentNamers) {
+    Map<String, ComponentDescriptor> generatedSimpleNames = new LinkedHashMap<>();
+
+    // Let's see if we can get away with using simpleName() everywhere.
+    for (ComponentDescriptor component : components) {
+      Namer namer = componentNamers.get(component);
+      if (generatedSimpleNames.containsKey(namer.simpleName())) {
+        break;
+      }
+      generatedSimpleNames.put(namer.simpleName(), component);
+    }
+
+    if (generatedSimpleNames.size() != components.size()) {
+      // Simple approach didn't work out, let's use more complicated names.
+      // We keep them small to fix https://github.com/google/dagger/issues/421.
+      generatedSimpleNames.clear();
+      UniqueNameSet nameSet = new UniqueNameSet();
+      for (ComponentDescriptor component : components) {
+        Namer namer = componentNamers.get(component);
+        String simpleName = namer.simpleName();
+        String basePrefix = namer.uniquingPrefix();
+        generatedSimpleNames.put(
+            format("%s_%s", nameSet.getUniqueName(basePrefix), simpleName), component);
+      }
+    }
+    return ImmutableBiMap.copyOf(generatedSimpleNames).inverse();
+  }
+
+  private static ImmutableMap<ComponentDescriptor, Namer> qualifiedNames(
+      Iterable<ComponentDescriptor> componentDescriptors) {
+    ImmutableMap.Builder<ComponentDescriptor, Namer> builder = ImmutableMap.builder();
+    for (ComponentDescriptor component : componentDescriptors) {
+      builder.put(component, new Namer(component.componentDefinitionType()));
+    }
+    return builder.build();
+  }
+
+  private static final class Namer {
+    final TypeElement typeElement;
+
+    Namer(TypeElement typeElement) {
+      this.typeElement = typeElement;
+    }
+
+    String simpleName() {
+      return typeElement.getSimpleName().toString();
+    }
+
+    /** Returns a prefix that could make {@link #simpleName()} more unique. */
+    String uniquingPrefix() {
+      String containerName = typeElement.getEnclosingElement().getSimpleName().toString();
+
+      // If parent element looks like a class, use its initials as a prefix.
+      if (!containerName.isEmpty() && isUpperCase(containerName.charAt(0))) {
+        return CharMatcher.javaLowerCase().removeFrom(containerName);
+      }
+
+      // Not in a normally named class. Prefix with the initials of the elements leading here.
+      Name qualifiedName = typeElement.getQualifiedName();
+      Iterator<String> pieces = QUALIFIED_NAME_SPLITTER.split(qualifiedName).iterator();
+      StringBuilder b = new StringBuilder();
+
+      while (pieces.hasNext()) {
+        String next = pieces.next();
+        if (pieces.hasNext()) {
+          b.append(next.charAt(0));
+        }
+      }
+
+      // Note that a top level class in the root package will be prefixed "$_".
+      return b.length() > 0 ? b.toString() : "$";
+    }
+  }
+}
