diff --git a/dagger-1-migration.md b/dagger-1-migration.md
index 20880bfb7..dc11079f3 100644
--- a/dagger-1-migration.md
+++ b/dagger-1-migration.md
@@ -3,21 +3,18 @@ layout: default
 title: Migrating from Dagger 1
 ---
 
-# Migrating from Dagger 1
-
 While Dagger 1 and Dagger 2 are similar in many ways, one is not a drop-in
 replacement for the other.  This guide will highlight both the API and
 conceptual differences between the two versions and provide recommended patterns
 for migrating.
 
+
 ## Injected types
 
-Dagger 2 continues to rely on [JSR 330](https://jcp.org/en/jsr/detail?id=330)
-for declaring injection sites. All of the
-[types of injection](http://docs.oracle.com/javaee/6/api/javax/inject/Inject.html)
-supported by Dagger 1 (field and constructor) continue to be supported by Dagger
-2, but Dagger 2 supports method injection as well. Dagger 2 ***does not***
-support static injection.
+Dagger 2 continues to rely on [JSR 330] for declaring injection sites. All of
+the [types of injection][Inject] supported by Dagger 1 (field and constructor)
+continue to be supported by Dagger 2, but Dagger 2 supports method injection
+as well. Dagger 2 ***does not*** support static injection.
 
 ## Framework types
 
@@ -154,8 +151,7 @@ scope to a component.
 ## Subgraphs
 
 Dagger 1 provided `ObjectGraph.plus` as the mechanism for creating new graphs
-from existing ones.  Dagger 2 has
-[two mechanisms](/api/latest/dagger/Component.html#component-relationships) for
+from existing ones.  Dagger 2 has [two mechanisms][component-relationships] for
 composing graphs - each with its own advantages - but
 [subcomponents][Subcomponent] is the most direct analog.  Defining a
 subcomponent is very similar to defining a component and the component is
@@ -179,7 +175,7 @@ MySubcomponent mySubcomponent = myComponent.plus(new ChildGraphModule("child!"))
 ```
 
 Subcomponents are further described in the [`@Subcomponent`][Subcomponent] and
-the [`@Component`](/api/latest/dagger/Component.html#subcomponents) javadoc.
+the [`@Component`][component-subcomponents] javadoc.
 
 ## Nullability
 
@@ -189,15 +185,18 @@ have to annotate injection sites and provides methods with the `@Nullable` of
 their choice. Any mismatch in nullability will be reported as a compile-time
 error.
 
-[Component]: </api/latest/dagger/Component.html>
-[Component-modules]: </api/latest/dagger/Component.html#modules()>
-[Lazy]: </api/latest/dagger/Lazy.html>
-[MembersInjector]: </api/latest/dagger/MembersInjector.html>
-[Module]: </api/latest/dagger/Module.html>
-[Provides]: </api/latest/dagger/Provides.html>
-[Subcomponent]: </api/latest/dagger/Subcomponent.html>
-
+[Component]: api/latest/dagger/Component.html
+[Component-modules]: api/latest/dagger/Component.html#modules()
+[component-relationships]: api/latest/dagger/Component.html#component-relationships
+[component-subcomponents]: api/latest/dagger/Component.html#subcomponents
+[Inject]: http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html
+[JSR 330]: https://jcp.org/en/jsr/detail?id=330
+[Lazy]: api/latest/dagger/Lazy.html
+[MembersInjector]: api/latest/dagger/MembersInjector.html
+[Module]: api/latest/dagger/Module.html
+[Provider]: http://docs.oracle.com/javaee/7/api/javax/inject/Provider.html
+[Provides]: api/latest/dagger/Provides.html
+[Scope]: http://docs.oracle.com/javaee/7/api/javax/inject/Scope.html
+[Singleton]: http://docs.oracle.com/javaee/7/api/javax/inject/Singleton.html
+[Subcomponent]: api/latest/dagger/Subcomponent.html
 
-[Provider]: <http://docs.oracle.com/javaee/7/api/javax/inject/Provider.html>
-[Scope]: <http://docs.oracle.com/javaee/7/api/javax/inject/Scope.html>
-[Singleton]: <http://docs.oracle.com/javaee/7/api/javax/inject/Singleton.html>
diff --git a/multibindings.md b/multibindings.md
index 6c5712c29..81cfa38a2 100644
--- a/multibindings.md
+++ b/multibindings.md
@@ -1,5 +1,7 @@
-# Multibindings
-
+---
+layout: default
+title: Multibindings
+---
 
 Dagger allows you to bind several objects into a collection even when the
 objects are bound in different modules using mutlbindings. Dagger assembles the
@@ -11,33 +13,31 @@ where several modules can contribute individual plugin interface implementations
 so that a central class can use the entire set of plugins. Or you could have
 several modules contribute individual service providers to a map, keyed by name.
 
-[TOC]
 
 ## Set multibindings {#set-multibindings}
 
 In order to contribute one element to an injectable multibound set, add a method
 to a module that returns an element and is annotated with
-[`@Provides(type = SET)`][PTS]:
+[`@Provides(type = SET)`]:
 
 ```java
 @Module
 class MyModuleA {
   @Provides(type = SET)
-  String provideOneString(DepA depA, DepB depB) {
+  static String provideOneString(DepA depA, DepB depB) {
     return "ABC";
   }
 }
 ```
 
 You can also contribute several elements at one time by adding a module method
-that returns a subset and is annotated with
-[`@Provides(type = SET_VALUES)`][PTSV]:
+that returns a subset and is annotated with [`@Provides(type = SET_VALUES)`]:
 
 ```java
 @Module
 class MyModuleB {
   @Provides(type = SET_VALUES)
-  Set<String> provideSomeStrings(DepA depA, DepB depB) {
+  static Set<String> provideSomeStrings(DepA depA, DepB depB) {
     return new HashSet<Foo>(Arrays.asList("DEF", "GHI"));
   }
 }
@@ -51,7 +51,7 @@ depending on that set is an error. If you want to allow an empty set, then add a
 @Module
 class MyEmptySetModule {
   @Provides(type = SET_VALUES)
-  Set<Foo> primeEmptyFooSet() {
+  static Set<Foo> primeEmptyFooSet() {
     return Collections.emptySet();
   }
 }
@@ -95,7 +95,7 @@ with the qualifier:
 class MyModuleC {
   @Provides(type = SET)
   @MyQualifier
-  Foo provideOneFoo(DepA depA, DepB depB) {
+  static Foo provideOneFoo(DepA depA, DepB depB) {
     return new Foo(depA, depB);
   }
 }
@@ -103,7 +103,7 @@ class MyModuleC {
 @Module
 class MyModuleD {
   @Provides
-  FooSetUser provideFooSetUser(@MyQualifier Set<Foo> foos) { … }
+  static FooSetUser provideFooSetUser(@MyQualifier Set<Foo> foos) { … }
 }
 ```
 
@@ -113,10 +113,10 @@ Dagger lets you use multibindings to contribute entries to an injectable map as
 long as the map keys are known at compile time.
 
 To contribute an entry to a multibound map, add a method to a module that
-returns the value and is annotated with [`@Provides(type = MAP)`][PTM] and with
+returns the value and is annotated with [`@Provides(type = MAP)`] and with
 another custom annotation that specifies the map key for that entry. To
-contribute an entry to a qualified multibound map, annotate each
-`@Provides(type = MAP)` method with the qualifier.
+contribute an entry to a qualified multibound map, annotate each `@Provides(type
+= MAP)` method with the qualifier.
 
 Then you can inject either the map itself (`Map<K, V>`) or a map containing
 value providers (`Map<K, Provider<V>>`). The latter is useful when you don't
@@ -126,9 +126,42 @@ value each time you query the map.
 
 ### Simple map keys
 
-For maps with keys that are strings, enums, classes, or boxed primitives, write
-an annotation type with one member whose type is the (unboxed if necessary) map
-key type, and annotate it with [`@MapKey`][MapKey]:
+For maps with keys that are strings, `Class<?>`, or boxed primitives, use one of
+the standard annotations in [`dagger.mapkeys`]:
+
+```java
+@Module
+class MyModule {
+  @Provides(type = MAP)
+  @StringKey("foo")
+  static Long provideFooValue() {
+    return 100L;
+  }
+
+  @Provides(type = MAP)
+  @ClassKey(Thing.class)
+  static String provideThingValue() {
+    return "value for Thing";
+  }
+}
+
+@Component(modules = MyModule.class)
+interface MyComponent {
+  Map<String, Long> longsByString();
+  Map<Class<?>, String> stringsByClass();
+}
+
+@Test void testMyComponent() {
+  MyComponent myComponent = DaggerMyComponent.create();
+  assertThat(myComponent.longsByString.get("foo")).isEqualTo(100L);
+  assertThat(myComponent.stringsByClass.get(Thing.class))
+      .isEqualTo("value for Thing");
+}
+```
+
+For maps with keys that are enums or a more specifically parameterized class,
+write an annotation type with one member whose type is the map key type, and
+annotate it with [`@MapKey`]:
 
 ```java
 enum MyEnum {
@@ -140,11 +173,6 @@ enum MyEnum {
   MyEnum value();
 }
 
-@MapKey
-@interface MyLongKey {
-  long value();
-}
-
 @MapKey
 @interface MyNumberClassKey {
   Class<? extends Number> value();
@@ -154,19 +182,13 @@ enum MyEnum {
 class MyModule {
   @Provides(type = MAP)
   @MyEnumKey(MyEnum.ABC)
-  String provideABCValue() {
+  static String provideABCValue() {
     return "value for ABC";
   }
 
-  @Provides(type = MAP)
-  @MyLongKey(100L)
-  String provide100Value() {
-    return "value for 100";
-  }
-
   @Provides(type = MAP)
   @MyNumberClassKey(BigDecimal.class)
-  String provideBigDecimalValue() {
+  static String provideBigDecimalValue() {
     return "value for BigDecimal";
   }
 }
@@ -174,15 +196,13 @@ class MyModule {
 @Component(modules = MyModule.class)
 interface MyComponent {
   Map<MyEnum, String> myEnumStringMap();
-  Map<Long, String> longStringMap();
-  Map<Class<? extends Number>, String> numberClassStringMap();
+  Map<Class<? extends Number>, String> stringsByNumberClass();
 }
 
 @Test void testMyComponent() {
   MyComponent myComponent = DaggerMyComponent.create();
-  assertThat(myEnumStringMap.get(MyEnum.ABC)).isEqualTo("value for ABC");
-  assertThat(longStringMap.get(100L)).isEqualTo("value for 100");
-  assertThat(numberClassStringMap.get(BigDecimal.class))
+  assertThat(myComponent.myEnumStringMap().get(MyEnum.ABC)).isEqualTo("value for ABC");
+  assertThat(myComponent.stringsByNumberClass.get(BigDecimal.class))
       .isEqualTo("value for BigDecimal");
 }
 ```
@@ -209,7 +229,7 @@ well.
 class MyModule {
   @Provides(type = MAP)
   @MyKey(name = "abc", implementingClass = Abc.class, thresholds = {1, 5, 10})
-  String provideAbc1510Value() {
+  static String provideAbc1510Value() {
     return "foo";
   }
 }
@@ -226,7 +246,7 @@ If your map uses complex keys, then you may need to create an instance of your
 `@MapKey` annotation at run-time to pass to the map's `get(Object)` method. The
 easiest way to do that is to use the `@AutoAnnotation` annotation to create a
 static method that instantiates your annotation. See
-`@AutoAnnotation`'s [documentation][AutoAnnotation] for more details.
+`@AutoAnnotation`'s [documentation][`@AutoAnnotation`] for more details.
 
 ```java
 class MyComponentTest {
@@ -256,14 +276,14 @@ transform into a non-multibound map.
 @Module
 class MyModule {
   @Provides(type = SET)
-  Map.Entry<Foo, Bar> entryOne(…) {
+  static Map.Entry<Foo, Bar> entryOne(…) {
     Foo key = …;
     Bar value = …;
     return new SimpleImmutableEntry(key, value);
   }
 
   @Provides(type = SET)
-  Map.Entry<Foo, Bar> entryTwo(…) {
+  static Map.Entry<Foo, Bar> entryTwo(…) {
     Foo key = …;
     Bar value = …;
     return new SimpleImmutableEntry(key, value);
@@ -273,7 +293,7 @@ class MyModule {
 @Module
 class MyMapModule {
   @Provides
-  Map<Foo, Bar> fooBarMap(Set<Map.Entry<Foo, Bar>> entries) {
+  static Map<Foo, Bar> fooBarMap(Set<Map.Entry<Foo, Bar>> entries) {
     Map<Foo, Bar> fooBarMap = new LinkedHashMap<>(entries.size());
     for (Map.Entry<Foo, Bar> entry : entries) {
       fooBarMap.put(entry.getKey(), entry.getValue());
@@ -292,7 +312,8 @@ your non-multibound map can have `Provider` values.
 @Module
 class MyModule {
   @Provides(type = SET)
-  Map.Entry<Foo, Provider<Bar>> entry(Provider<BarSubclass> barSubclassProvider) {
+  static Map.Entry<Foo, Provider<Bar>> entry(
+      Provider<BarSubclass> barSubclassProvider) {
     Foo key = …;
     return new SimpleImmutableEntry(key, barSubclassProvider);
   }
@@ -301,7 +322,8 @@ class MyModule {
 @Module
 class MyProviderMapModule {
   @Provides
-  Map<Foo, Provider<Bar>> fooBarProviderMap(Set<Map.Entry<Foo, Provider<Bar>>> entries) {
+  static Map<Foo, Provider<Bar>> fooBarProviderMap(
+      Set<Map.Entry<Foo, Provider<Bar>>> entries) {
     return …;
   }
 }
@@ -333,24 +355,24 @@ interface ParentComponent {
 @Module
 class ParentModule {
   @Provides(type = SET)
-  String string1() {
+  static String string1() {
     "parent string 1";
   }
 
   @Provides(type = SET)
-  String string2() {
+  static String string2() {
     "parent string 2";
   }
 
   @Provides(type = MAP)
   @StringKey("a")
-  String stringA() {
+  static String stringA() {
     "parent string A";
   }
 
   @Provides(type = MAP)
   @StringKey("b")
-  String stringB() {
+  static String stringB() {
     "parent string B";
   }
 }
@@ -364,24 +386,24 @@ interface ChildComponent {
 @Module
 class ChildModule {
   @Provides(type = SET)
-  String string3() {
+  static String string3() {
     "child string 3";
   }
 
   @Provides(type = SET)
-  String string4() {
+  static String string4() {
     "child string 4";
   }
 
   @Provides(type = MAP)
   @StringKey("c")
-  String stringC() {
+  static String stringC() {
     "child string C";
   }
 
   @Provides(type = MAP)
   @StringKey("d")
-  String stringD() {
+  static String stringD() {
     "child string D";
   }
 }
@@ -403,15 +425,16 @@ class ChildModule {
 <!-- references & footnotes -->
 
 [^AutoAnnotation]:
-    You can use [`@AutoAnnotation`][AutoAnnotation] to create annotation
-    instances to pass to the map's `get(Object)` method.
+    You can use [`@AutoAnnotation`] to create annotation instances to pass to
+    the map's `get(Object)` method.
 
-[PTS]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#SET
 
-[PTS]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#SET_VALUES
+[`@AutoAnnotation`]: https://github.com/google/auto/blob/master/value/src/main/java/com/google/auto/value/AutoAnnotation.java
+[`dagger.mapkeys`]: http://google.github.io/dagger/api/latest/dagger/mapkeys/package-summary.html
+[`@MapKey`]: http://google.github.io/dagger/api/latest/dagger/MapKey.html
+[`@Provides(type = MAP)`]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#MAP
+[`@Provides(type = SET)`]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#SET
+[`@Provides(type = SET_VALUES)`]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#SET_VALUES
 
-[PTM]: http://google.github.io/dagger/api/latest/dagger/Provides.Type.html#MAP
 
-[AutoAnnotation]: https://github.com/google/auto/blob/master/value/src/main/java/com/google/auto/value/AutoAnnotation.java
 
-[MapKey]: http://google.github.io/dagger/api/latest/dagger/MapKey.html
diff --git a/producers.md b/producers.md
new file mode 100644
index 000000000..ebc991b9f
--- /dev/null
+++ b/producers.md
@@ -0,0 +1,271 @@
+---
+layout: default
+title: Producers
+---
+
+Dagger Producers is an extension to Dagger that implements
+asynchronous dependency injection in Java.
+
+
+## Overview
+
+This document assumes familiarity with the [Dagger 2 API][Dagger 2] and with
+Guava’s [ListenableFuture][ListenableFuture].
+
+Dagger Producers introduces new annotations [@ProducerModule][ProducerModule],
+[@Produces][Produces], and [@ProductionComponent][ProductionComponent] as
+analogues of [@Module][Module], [@Provides][Provides], and
+[@Component][Component]. We refer to classes annotated `@ProducerModule` as
+**producer modules**, methods annotated `@Produces` as **producer methods**, and
+interfaces annotated `@ProductionComponent` as **producer graphs** (analogous to
+**modules**, **provider methods**, and **object graphs**).
+
+The key difference from ordinary Dagger is that producer methods may return
+`ListenableFuture<T>` and subsequent producer methods may depend on the
+unwrapped `T`; the framework handles scheduling the subsequent methods when the
+future is available.
+
+Here is a simple example that mimics a server’s request-handling flow:
+
+```java
+@ProducerModule(includes = UserModule.class)
+final class UserResponseModule {
+  @Produces
+  static ListenableFuture<UserData> lookUpUserData(
+      User user, UserDataStub stub) {
+    return stub.lookUpData(user);
+  }
+
+  @Produces
+  static Html renderHtml(UserData data, UserHtmlTemplate template) {
+    return template.render(data);
+  }
+}
+```
+
+In this example, the computation we’re describing here says:
+
+  * call the `lookUpUserData` method
+  * when the future is available, call the `renderHtml` method with the result
+
+(Note that we haven’t explicitly indicated where `User`, `UserDataStub`, or
+`UserHtmlTemplate` come from; we’re assuming that the Dagger module `UserModule`
+provides those types.)
+
+To build this graph, we use a `ProductionComponent`:
+
+```java
+@ProductionComponent(modules = UserResponseModule.class)
+interface UserResponseComponent {
+  ListenableFuture<Html> html();
+}
+
+// ...
+
+UserResponseComponent component = Dagger_UserResponseComponent.builder()
+    .executor(executor)
+    .build();
+
+ListenableFuture<Html> htmlFuture = component.html();
+```
+
+Dagger generates an implementation of the interface `UserResponseComponent`,
+whose method `html()` does exactly what we described above: first it calls
+`lookUpUserData`, and when that future is available, it calls `renderHtml`.
+
+Both producer methods are scheduled on the provided executor, so the execution
+model is entirely user-specified.
+
+## Features
+
+### Works with ordinary Dagger
+
+As in the above example, producer modules can be used seamlessly with ordinary
+modules, subject to the restriction that provided types cannot depend on
+produced types.
+
+### Exception handling
+
+By default, if a producer method throws an exception, or the future that it
+returns failed, then any dependent producer methods will be skipped - this
+models “propagating” an exception up a call stack.
+
+If a producer method would like to “catch” that exception, the method can
+request a [Produced&lt;T>][Produced] instead of a T. For example:
+
+```java
+@Produces
+static Html renderHtml(
+    Produced<UserData> data,
+    UserHtmlTemplate template,
+    ErrorHtmlTemplate errorTemplate) {
+  try {
+    return template.render(data.get());
+  } catch (ExecutionException e) {
+    return errorTemplate.render("user data failed", e.getCause());
+  }
+}
+```
+
+In this example, if the production of `UserData` threw an exception (either by a
+producer method throwing an exception, or by a future failing), then the
+`renderHtml` method catches it and returns an error template.
+
+If an exception propagates all the way up to the component’s entry point
+without any producer method catching it, then the future returned from the
+component will fail with an exception.
+
+### Lazy execution
+
+Producer methods can request a [`Producer<T>`][Producer], which is analogous to
+a [`Provider<T>`][Provider]: it delays the computation of the associated binding
+until a `get()` method is called. `Producer<T>` is non-blocking; its `get()`
+method returns a `ListenableFuture`, which can then be fed to the framework. For
+example:
+
+```java
+@Produces
+static ListenableFuture<UserData> lookUpUserData(
+    Flags flags,
+    @Standard Producer<UserData> standardUserData,
+    @Experimental Producer<UserData> experimentalUserData) {
+  return flags.useExperimentalUserData()
+      ? experimentalUserData.get()
+      : standardUserData.get();
+}
+```
+
+In this example, if the experimental user data is requested, then the standard
+user data is never computed. Note that the `Flags` may be a request-time flag,
+or even the result of an RPC, which lets users build very flexible conditional
+graphs.
+
+### Multibindings
+
+Several bindings of the same type can be collected into a set or map, just like
+in [ordinary Dagger](multibindings.md). For example:
+
+```java
+@ProducerModule
+final class UserDataModule {
+  @Produces(type = SET) static ListenableFuture<Data> standardData(…) { … }
+  @Produces(type = SET) static ListenableFuture<Data> extraData(…) { … }
+  @Produces(type = SET) static Data synchronousData(…) { … }
+  @Produces(type = SET_VALUES) static Set<ListenableFuture<Data>> rest(…) { … }
+
+  @Produces static … collect(Set<Data> data) { … }
+}
+```
+
+In this example, when all the producer methods that contribute to this set have
+completed futures, the `Set<Data>` is constructed and the collect() method is
+called.
+
+Map multibindings are similar:
+
+```java
+@MapKey @interface DispatchPath {
+  String value();
+}
+
+@ProducerModule
+final class DispatchModule {
+  @Produces(type = MAP) @DispatchPath("/user")
+  static ListenableFuture<Html> dispatchUser(…) { … }
+
+  @Produces(type = MAP) @DispatchPath("/settings")
+  static ListenableFuture<Html> dispatchSettings(…) { … }
+
+  @Produces
+  static ListenableFuture<Html> dispatch(
+      Map<DispatchPath, Producer<Html>> dispatchers, Url url) {
+    return dispatchers.get(url.path()).get();
+  }
+}
+```
+
+Note that here, `dispatch()` is requesting
+`Map<DispatchPath, Producer<Html>>`; this ensures that only the dispatch
+handler that was requested will be executed.
+
+### Caching
+
+Each producer method will only be executed once within the context of a given
+component, and its result will be cached. This gives complete control over the
+lifetime of each binding &mdash; it is the same as the lifetime of its enclosing
+component instance.
+
+### Component dependencies
+
+Like ordinary `Component`s, `ProductionComponent`s may depend on other
+interfaces:
+
+```java
+interface RequestComponent {
+  ListenableFuture<Request> request();
+}
+
+@ProducerModule
+final class UserDataModule {
+  @Produces static ListenableFuture<UserData> userData(Request request, …) { … }
+}
+
+@ProductionComponent(
+    modules = UserDataModule.class,
+    dependencies = RequestComponent.class)
+interface UserDataComponent {
+  ListenableFuture<UserData> userData();
+}
+```
+
+Since the `UserDataComponent` depends on the `RequestComponent`, Dagger will
+require that an instance of the `RequestComponent` be provided when building the
+`UserDataComponent`; and then that instance will be used to satisfy the bindings
+of the getter methods that it offers:
+
+```java
+ListenableFuture<UserData> userData = Dagger_UserDataComponent.builder()
+    .executor(executor)
+    .requestComponent(/* a particular RequestComponent */)
+    .build()
+    .userData();
+```
+
+### Subcomponents
+
+==As of April 2015, not implemented yet==
+
+Dagger Producers also introduces a new annotation @ProductionSubcomponent as an
+analogue to [@Subcomponent][Subcomponent]. Production subcomponents may be
+subcomponents of either components or production components.
+
+A subcomponent inherits all bindings from its parent component, and so it is
+often a simpler way of building nested scopes.
+
+### Logging and debugging
+
+==As of April 2015, not implemented yet==
+
+Since graphs are constructed at compile-time, the graph will be able to be
+viewed immediately after compiling, likely via writing its structure to json
+or a proto.
+
+Statistics from producer execution (CPU usage of producer method invocations and
+latency of futures) will be available to export to many endpoints.
+
+While a graph is running, its current state will be able to be dumped.
+
+[Dagger 2]: http://google.github.io/dagger/
+
+[Component]: http://google.github.io/dagger/api/latest/dagger/Component.html
+[ListenableFuture]: http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/ListenableFuture.html
+[Module]: http://google.github.io/dagger/api/latest/dagger/Module.html
+[Produced]: http://google.github.io/dagger/api/latest/dagger/producers/Produced.html
+[Producer]: http://google.github.io/dagger/api/latest/dagger/producers/Producer.html
+[ProducerModule]: http://google.github.io/dagger/api/latest/dagger/producers/ProducerModule.html
+[Produces]: http://google.github.io/dagger/api/latest/dagger/producers/Produces.html
+[ProductionComponent]: http://google.github.io/dagger/api/latest/dagger/producers/ProductionComponent.html
+[Provider]: http://docs.oracle.com/javaee/6/api/javax/inject/Provider.html
+[Provides]: http://google.github.io/dagger/api/latest/dagger/Provides.html
+[Subcomponent]: http://google.github.io/dagger/api/latest/dagger/Subcomponent.html
+
diff --git a/sitemap.md b/sitemap.md
index 1d563c291..70471e915 100644
--- a/sitemap.md
+++ b/sitemap.md
@@ -1,6 +1,7 @@
  * [Home](index.md)
  * [User's Guide](users-guide.md)
    * [Multibindings](multibindings.md)
+   * [Subcomponents](subcomponents.md)
    * [Migrating from Dagger 1](dagger-1-migration.md)
    * [Producers](producers.md)
  * [Overview](overview.md)
diff --git a/subcomponents.md b/subcomponents.md
new file mode 100644
index 000000000..4b4ffc115
--- /dev/null
+++ b/subcomponents.md
@@ -0,0 +1,356 @@
+---
+layout: default
+title: Subcomponents
+---
+
+Subcomponents are components that inherit and extend the object graph of a
+parent component. You can use them to partition your application's object graph
+into subgraphs either to encapsulate different parts of your application from
+each other or to use more than one scope within a component.
+
+An object bound in a subcomponent can depend on any object that is bound in its
+parent component or any ancestor component, in addition to objects that are
+bound in its own modules. On the other hand, objects bound in parent components
+can't depend on those bound in subcomponents; nor can objects bound in one
+subcomponent depend on objects bound in sibling subcomponents.
+
+In other words, the object graph of a subcomponent's parent component is a
+subgraph of the object graph of the subcomponent itself.
+
+
+## Declaring a subcomponent
+
+Just like for top-level components, you create a subcomponent by writing an
+abstract class or interface that declares [abstract methods that return the
+types your application cares about][component-methods]. Instead of annotating a
+subcomponent with [`@Component`], you annotate it with [`@Subcomponent`] and
+install [`@Module`]s.
+
+```java
+@Subcomponent(modules = RequestModule.class)
+inferface RequestComponent {
+  RequestHandler requestHandler();
+}
+```
+
+## Adding a subcomponent to a parent component
+
+To add a subcomponent to a parent component, add an [abstract factory
+method][component-subcomponents] to the parent component that returns the
+subcomponent. If the subcomponent requires a module that does not have a no-arg
+public constructor, and that module is not installed into the parent component,
+then the factory method must have a parameter of that module's type.  The
+factory method may have other parameters for any other modules that are
+installed on the subcomponent but not on the parent component. (The subcomponent
+will automatically share the instance of any module shared between it and its
+parent.)
+
+```java
+@Component(modules = {ServerModule.class, AuthModule.class})
+interface ServerComponent {
+  Server server();
+  SessionComponent sessionComponent(SessionModule sessionModule);
+}
+
+@Subcomponent(modules = SessionModule.class)
+interface SessionComponent {
+  SessionInfo sessionInfo();
+  RequestComponent requestComponent();
+}
+
+@Subcomponent(modules = {RequestModule.class, AuthModule.class})
+interface RequestComponent {
+  RequestHandler requestHandler();
+}
+```
+
+Bindings from `SessionComponent`'s modules can depend on bindings from
+`ServerComponent`'s modules, and bindings from `RequestComponent`'s modules can
+depend on bindings from both `SessionComponent`'s and `ServerComponent`'s
+modules.
+
+In order to create an instance of a subcomponent, you call the factory method on
+an instance of its parent component.
+
+```java
+ServerComponent serverComponent = DaggerServerComponent.create();
+SessionComponent sessionComponent =
+    serverComponent.sessionComponent(new SessionModule(…));
+RequestComponent requestComponent = sessionComponent.requestComponent();
+```
+
+Often you need to create subcomponents from within an object bound inside a
+parent component. To do that, you can rely on the fact that any binding in a
+component can depend on the component type itself.
+
+```java
+class BoundInServerComponent {
+  @Inject ServerComponent serverComponent;
+
+  void doSomethingWithSessionInfo() {
+    SessionComponent sessionComponent =
+        serverComponent.sessionComponent(new SessionModule(…));
+    sessionComponent.sessionInfo().doSomething();
+  }
+}
+```
+
+### Subcomponent builders
+
+You can also define a builder for your subcomponent, similarly to how
+[component builders] are defined.
+
+```java
+@Component(modules = {ServerModule.class, AuthModule.class})
+interface ServerComponent {
+  Server server();
+  SessionComponent.Builder sessionComponentBuilder();
+}
+
+@Subcomponent(modules = SessionModule.class)
+interface SessionComponent {
+  @Subcomponent.Builder
+  interface Builder {
+    Builder sessionModule(SessionModule sessionModule);
+    SessionComponent build();
+  }
+}
+
+ServerComponent serverComponent = DaggerServerComponent.create();
+SessionComponent sessionComponent = serverComponent.sessionComponentBuilder()
+    .sessionModule(new SessionModule(…))
+    .build();
+```
+
+## Subcomponents and scope
+
+<!-- TODO(dpb,gak): Describe scopes independently from subcomponents. -->
+
+One reason to break your application's component up into subcomponents is to use
+[scopes][`@Scope`]. With normal, unscoped bindings, each user of an injected
+type may get a new, separate instance. But if the binding is scoped, then all
+users of that binding *within the scope's lifetime* get the same instance of the
+bound type.
+
+The standard scope is [`@Singleton`]. Users of singleton-scoped bindings all
+get the same instance.
+
+In Dagger, a component can be associated with a scope by annotating it with a
+[`@Scope`] annotation. In that case, the component implementation holds
+references to all scoped objects so they can be reused. Modules with
+[`@Provides`] methods annotated with a scope may only be installed into a
+component annotated with the same scope.
+
+(Types with [`@Inject`] constructors may also be annotated with scope
+annotations. These "implicit bindings" may be used by any component annotated
+with that scope *or any of its descendant components.* The scoped instance will
+be bound in the correct scope.)
+
+No subcomponent may be associated with the same scope as any ancestor component,
+although two subcomponents that are not mutually reachable can be associated
+with the same scope because there is no ambiguity about where to store the
+scoped objects. (The two subcomponents effectively have different scope
+*instances* even if they use the same scope annotation.)
+
+For example, in the component tree below, `BadChildComponent` has the same
+`@RootScope` annotation as its parent, `RootComponent`, and that is an error.
+But `SiblingComponentOne` and `SiblingComponentTwo` can both use `@ChildScope`
+because there is no way to confuse a binding in one with a binding of the same
+type in another.
+
+```java
+@RootScope @Component
+interface RootComponent {
+  BadChildComponent badChildComponent(); // ERROR!
+  SiblingComponentOne siblingComponentOne();
+  SiblingComponentTwo siblingComponentTwo();
+}
+
+@RootScope @Subcomponent
+interface BadChildComponent {…}
+
+@ChildScope @Subcomponent
+interface SiblingComponentOne {…}
+
+@ChildScope @Subcomponent
+interface SiblingComponentTwo {…}
+```
+
+Because a subcomponent is instantiated by calling a method on its parent, its
+lifetime is strictly smaller than its parent's. That means that it makes sense
+to associate smaller scopes with subcomponents and larger scope with parent
+components. In fact, you almost always want the root component to use the
+[`@Singleton`] scope.
+
+In the example below, `RootComponent` is in [`@Singleton`] scope.
+`@SessionScope` is nested within [`@Singleton`] scope, and `@RequestScope` is
+nested within `@SessionScope`. Note that `FooRequestComponent` and
+`BarRequestComponent` are both associated with `@RequestScope`, which works
+because they are siblings; neither is an ancestor of the other.
+
+```java
+@Singleton @Component
+interface RootComponent {
+  SessionComponent sessionComponent();
+}
+
+@SessionScope @Subcomponent
+interface SessionComponent {
+  FooRequestComponent fooRequestComponent();
+  BarRequestComponent barRequestComponent();
+}
+
+@RequestScope @Subcomponent
+interface FooRequestComponent {…}
+
+@RequestScope @Subcomponent
+interface BarRequestComponent {…}
+```
+
+## Subcomponents for encapsulation
+
+Another reason to use subcomponents is to encapsulate different parts of your
+application from each other. For example, if two services in your server (or
+two screens in your application) share some bindings, say those used for
+authentication and authorization, but each have other bindings that really have
+nothing to do with each other, it might make sense to create separate
+subcomponents for each service or screen, and to put the shared bindings into
+the parent component. In the example above, `FooRequestComponent` and
+`BarRequestComponent` are separate, sibling components. You could combine them
+into one `@RequestScope` component with all their modules, but you might have
+some conflicting bindings.
+
+> TODO(dpb): Explore this idea further.
+
+## Subcomponents vs. dependent components
+
+> TODO(dpb)
+
+## Details
+
+### Extending multibindings
+
+Like other bindings, [multibindings](multibindings.md) in a parent component are
+visible to bindings in subcomponents. But subcomponents can also add
+multibindings to maps and sets bound in their parent. Any such additional
+contributions are visible only to bindings within the subcomponent or its
+subcomponents, and are not visible within the parent.
+
+```java
+@Component(modules = ParentModule.class)
+interface Parent {
+  Map<String, Int> map();
+  Set<String> set();
+
+  Child child();
+}
+
+@Module
+class ParentModule {
+  @Provides(type = MAP)
+  @StringKey("one") static int one() {
+    return 1;
+  }
+
+  @Provides(type = MAP)
+  @StringKey("two") static int two() {
+    return 2;
+  }
+
+  @Provides(type = SET)
+  static String a() {
+    return "a"
+  }
+
+  @Provides(type = SET)
+  static String b() {
+    return "b"
+  }
+}
+
+@Subcomponent(modules = Child.class)
+interface Child {
+  Map<String, String> map();
+  Set<String> set();
+}
+
+@Module
+class ChildModule {
+  @Provides(type = MAP)
+  @StringKey("three") static int three() {
+    return 3;
+  }
+
+  @Provides(type = MAP)
+  @StringKey("four") static int four() {
+    return 4;
+  }
+
+  @Provides(type = SET)
+  static String c() {
+    return "c"
+  }
+
+  @Provides(type = SET)
+  static String d() {
+    return "d"
+  }
+}
+
+Parent parent = DaggerParent.create();
+Child child = parent.child();
+assertThat(parent.map().keySet()).containsExactly("one", "two");
+assertThat(child.map().keySet()).containsExactly("one", "two", "three", "four");
+assertThat(parent.set()).containsExactly("a", "b");
+assertThat(child.set()).containsExactly("a", "b", "c", "d");
+```
+
+### Repeated modules
+
+When the same module type is installed in a component and any of its
+subcomponents, then each of those components will automatically use the same
+instance of the module. This means that it is an error if a subcomponent factory
+method includes a repeated module as a parameter or if you call a subcomponent
+builder method for a repeated module. (The latter cannot be checked at compile
+time, and is a runtime error.)
+
+```java
+@Component(modules = {RepeatedModule.class, …})
+interface ComponentOne {
+  ComponentTwo componentTwo(RepeatedModule repeatedModule); // COMPILE ERROR!
+  ComponentThree.Builder componentThreeBuilder();
+}
+
+@Subcomponent(modules = {RepeatedModule.class, …})
+interface ComponentTwo { … }
+
+@Subcomponent(modules = {RepeatedModule.class, …})
+interface ComponentThree {
+  @Subcomponent.Builder
+  interface Builder {
+    Builder repeatedModule(RepeatedModule repeatedModule);
+    ComponentThree build();
+  }
+}
+
+DaggerComponentOne.create().componentThreeBuilder()
+    .repeatedModule(new RepeatedModule()) // UnsupportedOperationException!
+    .build();
+```
+
+<!-- References -->
+
+
+[`@Component`]: http://google.github.io/dagger/api/latest/dagger/Component.html
+[component builders]: http://google.github.io/dagger/api/latest/dagger/Component.Builder.html
+[component-methods]: http://google.github.io/dagger/api/latest/dagger/Component.html#component-methods
+[component-subcomponents]: http://google.github.io/dagger/api/latest/dagger/Component.html#subcomponents
+[`@Inject`]: http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html
+[`@Module`]: http://google.github.io/dagger/api/latest/dagger/Module.html
+[`@Provides`]: http://google.github.io/dagger/api/latest/dagger/Provides.html
+[`@Scope`]: http://docs.oracle.com/javaee/7/api/javax/inject/Scope.html
+[`@Singleton`]: http://docs.oracle.com/javaee/7/api/javax/inject/Singleton.html
+[`@Subcomponent`]: http://google.github.io/dagger/api/latest/dagger/Subcomponent.html
+
+
+
diff --git a/users-guide.md b/users-guide.md
index b15697ff3..e08dc37aa 100644
--- a/users-guide.md
+++ b/users-guide.md
@@ -3,9 +3,6 @@ layout: default
 title: User's Guide
 ---
 
-# User's Guide
-
-
 The best classes in any application are the ones that do stuff: the
 `BarcodeDecoder`, the `KoopaPhysicsEngine`, and the `AudioStreamer`. These
 classes have dependencies; perhaps a `BarcodeCameraFinder`,
@@ -21,9 +18,7 @@ Dagger is a replacement for these `FactoryFactory` classes that implements the
 boilerplate. It allows you to focus on the interesting classes. Declare
 dependencies, specify how to satisfy them, and ship your app.
 
-By building on standard
-[`javax.inject`](http://docs.oracle.com/javaee/7/api/javax/inject/package-summary.html)
-annotations ([JSR 330](https://jcp.org/en/jsr/detail?id=330)), each class is
+By building on standard [`javax.inject`] annotations ([JSR 330]), each class is
 **easy to test**. You don't need a bunch of boilerplate just to swap the
 `RpcCreditCardService` out for a `FakeCreditCardService`.
 
@@ -33,29 +28,29 @@ Dependency injection isn't just for testing. It also makes it easy to create
 `DevLoggingModule` during development and `ProdLoggingModule` in production to
 get the right behavior in each situation.
 
+
 ## Why Dagger 2 is Different
 
 [Dependency injection][DI] frameworks have existed for years with a whole
 variety of APIs for configuring and injecting.  So, why reinvent the wheel?
 Dagger 2 is the first to **implement the full stack with generated code**. The
 guiding principle is to generate code that mimics the code that a user might
-have hand-written to ensure that dependency injection is a simple, traceable and
-performant as it can be. For more background on the design, watch
-[this talk](https://www.youtube.com/watch?v=oK_XtfXPkqw)
-([slides](https://docs.google.com/presentation/d/1fby5VeGU9CN8zjw4lAb2QPPsKRxx6mSwCe9q7ECNSJQ/pub?start=false&loop=false&delayms=3000))
-by [+Gregory Kick](https://google.com/+GregoryKick/).
+have hand-written to ensure that dependency injection is as simple, traceable
+and performant as it can be. For more background on the design, watch
+[this talk](https://youtu.be/oK_XtfXPkqw) ([slides][Dagger Talk Slides]) by
+[+Gregory Kick].
+
+## Using Dagger
 
-## Using Dagger We'll demonstrate dependency injection and Dagger by building a
-coffee maker. For complete sample code that you can compile and run, see
-Dagger's
-[coffee example](https://github.com/google/dagger/tree/master/examples/simple/src/main/java/coffee).
+We'll demonstrate dependency injection and Dagger by building a coffee maker.
+For complete sample code that you can compile and run, see Dagger's
+[coffee example][CoffeeMaker example].
 
 ### Declaring Dependencies
 
 Dagger constructs instances of your application classes and satisfies their
-dependencies. It uses the
-[`javax.inject.Inject`](http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html)
-annotation to identify which constructors and fields it is interested in.
+dependencies. It uses the [`javax.inject.Inject`] annotation to identify
+which constructors and fields it is interested in.
 
 Use `@Inject` to annotate the constructor that Dagger should use to create
 instances of a class. When a new instance is requested, Dagger will obtain the
@@ -115,7 +110,7 @@ return type defines which dependency it satisfies.
 For example, `provideHeater()` is invoked whenever a `Heater` is required:
 
 ```java
-@Provides Heater provideHeater() {
+@Provides static Heater provideHeater() {
   return new ElectricHeater();
 }
 ```
@@ -124,7 +119,7 @@ It's possible for `@Provides` methods to have dependencies of their own. This
 one returns a `Thermosiphon` whenever a `Pump` is required:
 
 ```java
-@Provides Pump providePump(Thermosiphon pump) {
+@Provides static Pump providePump(Thermosiphon pump) {
   return pump;
 }
 ```
@@ -135,29 +130,29 @@ have an [`@Module`][Module] annotation.
 ```java
 @Module
 class DripCoffeeModule {
-  @Provides Heater provideHeater() {
+  @Provides static Heater provideHeater() {
     return new ElectricHeater();
   }
 
-  @Provides Pump providePump(Thermosiphon pump) {
+  @Provides static Pump providePump(Thermosiphon pump) {
     return pump;
   }
 }
 ```
 
-By convention, `@Provides` methods are named with a `provide` prefix and module classes are named with a `Module` suffix.
+By convention, `@Provides` methods are named with a `provide` prefix and module
+classes are named with a `Module` suffix.
 
 ### Building the Graph
 
 The `@Inject` and `@Provides`-annotated classes form a graph of objects, linked
 by their dependencies. Calling code like an application's `main` method or an
-Android
-[`Application`](http://developer.android.com/reference/android/app/Application.html)
-accesses that graph via a well-defined set of roots. In Dagger 2, that set is
-defined by an interface with methods that have no arguments and return the
-desired type. By applying the [`@Component`][Component] annotation to such an
-interface and passing the [module][Module] types to the `modules` parameter,
-Dagger 2 then fully generates an implementation of that contract.
+Android [`Application`][Android Application] accesses that graph via a
+well-defined set of roots. In Dagger 2, that set is defined by an interface with
+methods that have no arguments and return the desired type. By applying the
+[`@Component`][Component] annotation to such an interface and passing the
+[module][Module] types to the `modules` parameter, Dagger 2 then fully generates
+an implementation of that contract.
 
 ```java
 @Component(modules = DripCoffeeModule.class)
@@ -168,8 +163,8 @@ interface CoffeeShop {
 
 The implementation has the same name as the interface prefixed with `Dagger`.
 Obtain an instance by invoking the `builder()` method on that implementation and
-use the returned [builder](http://en.wikipedia.org/wiki/Builder_pattern) to set
-dependencies and `build()` a new instance.
+use the returned [builder][Builder Pattern] to set dependencies and `build()` a
+new instance.
 
 ```java
 CoffeeShop coffeeShop = DaggerCoffeeShop.builder()
@@ -177,11 +172,28 @@ CoffeeShop coffeeShop = DaggerCoffeeShop.builder()
     .build();
 ```
 
+_Note_: If your `@Component` is not a top-level type, the generated component's
+name will be include its enclosing types' names, joined with an underscore. For
+example, this code:
+
+```java
+class Foo {
+  static class Bar {
+    @Component
+    interface BazComponent {}
+  }
+}
+```
+
+would generate a component named `DaggerFoo_Bar_BazComponent`.
+
 Any module with an accessible default constructor can be elided as the builder
-will construct an instance automatically if none is set.  If all dependencies
-can be constructed in that manner, the generated implementation will also have a
-`create()` method that can be used to get a new instance without having to deal
-with the builder.
+will construct an instance automatically if none is set.  And for any module
+whose `@Provides` methods are all static, the implementation doesn't need an
+instance at all.  If all dependencies can be constructed without the user
+creating a dependency instance, then the generated implementation will also
+have a `create()` method that can be used to get a new instance without having
+to deal with the builder.
 
 ```java
 CoffeeShop coffeeShop = DaggerCoffeeShop.create();
@@ -216,14 +228,14 @@ Annotate an `@Provides` method or injectable class with
 all of its clients.
 
 ```java
-@Provides @Singleton Heater provideHeater() {
+@Provides @Singleton static Heater provideHeater() {
   return new ElectricHeater();
 }
 ```
 
 The `@Singleton` annotation on an injectable class also serves as
-[documentation](http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Documented.html). It
-reminds potential maintainers that this class may be shared by multiple threads.
+[documentation][Documented]. It reminds potential maintainers that this class
+may be shared by multiple threads.
 
 ```java
 @Singleton
@@ -298,12 +310,11 @@ class BigCoffeeMaker {
 
 ***Note:*** Injecting `Provider<T>` has the possibility of creating confusing
    code, and may be a design smell of mis-scoped or mis-structured objects in
-   your graph.  Often you will want to use a
-   [factory](http://en.wikipedia.org/wiki/Factory_(object-oriented_programming))
-   or a `Lazy<T>` or re-organize the lifetimes and structure of your code to be
-   able to just inject a `T`.  Injecting `Provider<T>` can, however, be a life
-   saver in some cases.  A common use is when you must use a legacy architecture
-   that doesn't line up with your object's natural lifetimes (e.g. servlets are
+   your graph.  Often you will want to use a [factory][Factory Pattern] or a
+   `Lazy<T>` or re-organize the lifetimes and structure of your code to be able
+   to just inject a `T`.  Injecting `Provider<T>` can, however, be a life saver
+   in some cases.  A common use is when you must use a legacy architecture that
+   doesn't line up with your object's natural lifetimes (e.g. servlets are
    singletons by design, but only are valid in the context of request-specfic
    data).
 
@@ -341,11 +352,11 @@ class ExpensiveCoffeeMaker {
 Supply qualified values by annotating the corresponding `@Provides` method.
 
 ```java
-@Provides @Named("hot plate") Heater provideHotPlateHeater() {
+@Provides @Named("hot plate") static Heater provideHotPlateHeater() {
   return new ElectricHeater(70);
 }
 
-@Provides @Named("water") Heater provideWaterHeater() {
+@Provides @Named("water") static Heater provideWaterHeater() {
   return new ElectricHeater(93);
 }
 ```
@@ -354,16 +365,14 @@ Dependencies may not have multiple qualifier annotations.
 
 ### Compile-time Validation
 
-The Dagger
-[annotation processor](http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html)
-is strict and will cause a compiler error if any bindings are invalid or
-incomplete. For example, this module is installed in a component, which is
-missing a binding for `Executor`:
+The Dagger [annotation processor][Annotation Processor] is strict and will cause
+a compiler error if any bindings are invalid or incomplete. For example, this
+module is installed in a component, which is missing a binding for `Executor`:
 
 ```java
 @Module
 class DripCoffeeModule {
-  @Provides Heater provideHeater(Executor executor) {
+  @Provides static Heater provideHeater(Executor executor) {
     return new CpuHeater(executor);
   }
 }
@@ -388,12 +397,16 @@ validation.
 ### Compile-time Code Generation
 
 Dagger's annotation processor may also generate source files with names like
-`CoffeeMaker$$Factory.java` or `CoffeeMaker$$MembersInjector.java`. These files
+`CoffeeMaker_Factory.java` or `CoffeeMaker_MembersInjector.java`. These files
 are Dagger implementation details. You shouldn't need to use them directly,
-though they can be handy when step-debugging through an injection.
+though they can be handy when step-debugging through an injection. The only
+generated types you should refer to in your code are the ones Prefixed with
+Dagger for your component.
 
 ## Using Dagger In Your Build
 
+### Gradle Users
+
 You will need to include the `dagger-{{site.dagger.version}}.jar` in your
 application's runtime.  In order to activate code generation you will need to
 include `dagger-compiler-{{site.dagger.version}}.jar` in your build at compile
@@ -438,18 +451,30 @@ See the License for the specific language governing permissions and
 limitations under the License.
 ```
 
-[DI]: <http://en.wikipedia.org/wiki/Dependency_injection>
-
-[Component]: </api/latest/dagger/Component.html>
-[Lazy]: </api/latest/dagger/Lazy.html>
-[Module]: </api/latest/dagger/Module.html>
-[Provides]: </api/latest/dagger/Provides.html>
-
+<!-- References -->
+
+
+[Android Application]: http://developer.android.com/reference/android/app/Application.html
+[Annotation Processor]: http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html
+[Builder Pattern]: http://en.wikipedia.org/wiki/Builder_pattern
+[CoffeeMaker Example]: https://github.com/google/dagger/tree/master/examples/simple/src/main/java/coffee
+[Component]: /api/latest/dagger/Component.html
+[Dagger Talk Slides]: https://docs.google.com/presentation/d/1fby5VeGU9CN8zjw4lAb2QPPsKRxx6mSwCe9q7ECNSJQ/pub?start=false&loop=false&delayms=3000
+[DI]: http://en.wikipedia.org/wiki/Dependency_injection
+[Documented]: http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Documented.html
+[Factory Pattern]: https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)
+[JSR 330]: https://jcp.org/en/jsr/detail?id=330
+[`javax.inject`]: http://docs.oracle.com/javaee/7/api/javax/inject/package-summary.html
+[`javax.inject.Inject`]: http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html
+[Lazy]: /api/latest/dagger/Lazy.html
+[Module]: /api/latest/dagger/Module.html
+[Named]: http://docs.oracle.com/javaee/7/api/javax/inject/Named.html
+[Provider]: http://docs.oracle.com/javaee/7/api/javax/inject/Provider.html
+[Provides]: /api/latest/dagger/Provides.htm
+[Qualifier]: http://docs.oracle.com/javaee/7/api/javax/inject/Qualifier.html
+[Scope]: http://docs.oracle.com/javaee/7/api/javax/inject/Scope.html
+[Singleton]: http://docs.oracle.com/javaee/7/api/javax/inject/Singleton.html
+[+Gregory Kick]: https://google.com/+GregoryKick/
 
 
 
-[Named]: <http://docs.oracle.com/javaee/7/api/javax/inject/Named.html>
-[Provider]: <http://docs.oracle.com/javaee/7/api/javax/inject/Provider.html>
-[Qualifier]: <http://docs.oracle.com/javaee/7/api/javax/inject/Qualifier.html>
-[Scope]: <http://docs.oracle.com/javaee/7/api/javax/inject/Scope.html>
-[Singleton]: <http://docs.oracle.com/javaee/7/api/javax/inject/Singleton.html>
