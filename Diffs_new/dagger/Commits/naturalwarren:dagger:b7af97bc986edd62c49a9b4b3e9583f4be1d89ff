diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index b412d80c3..64e04c2ba 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -941,8 +941,8 @@ void resolve(BindingKey bindingKey) {
           return;
         }
 
-        /* If the binding was previously resolved in a supercomponent, then we may be able to avoid
-         * resolving it here and just depend on the supercomponent resolution.
+        /* If a contribution binding was previously resolved in a supercomponent, then we may be
+         * able to avoid resolving it here and just depend on the supercomponent resolution.
          *
          * 1. If it depends transitively on multibinding contributions or optional bindings with
          *    bindings from this subcomponent, then we have to resolve it in this subcomponent so
@@ -951,7 +951,8 @@ void resolve(BindingKey bindingKey) {
          * 2. If there are any explicit bindings in this component, they may conflict with those in
          *    the supercomponent, so resolve them here so that conflicts can be caught.
          */
-        if (getPreviouslyResolvedBindings(bindingKey).isPresent()) {
+        if (getPreviouslyResolvedBindings(bindingKey).isPresent()
+            && bindingKey.kind() == BindingKey.Kind.CONTRIBUTION) {
           /* Resolve in the parent in case there are multibinding contributions or conflicts in some
            * component between this one and the previously-resolved one. */
           parentResolver.get().resolve(bindingKey);
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index 949c0c1c5..1cdfd0fbd 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -2071,6 +2071,143 @@ public void subcomponentBindingConflictsWithParent() {
         .onLine(8);
   }
 
+  @Test
+  public void subcomponentBindingConflictsWithParentWhenSubcomponentPerformsMembersInjection() {
+    JavaFileObject parentConflictsWithChild =
+        JavaFileObjects.forSourceLines(
+            "test.ParentConflictsWithChild",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.annotation.Nullable;",
+            "",
+            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
+            "interface ParentConflictsWithChild {",
+            "  Child child();",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
+            "    @Provides static Object parentChildConflict() {",
+            "      return \"parent\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = Child.ChildModule.class)",
+            "interface Child {",
+            "  void inject(Injected injected);",
+            "",
+            "  @Module",
+            "  static class ChildModule {",
+            "    @Provides static Object parentChildConflict() {",
+            "      return \"child\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject injected =
+        JavaFileObjects.forSourceLines(
+            "test.Injected",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Injected {",
+            "  @Inject Object object;",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parentConflictsWithChild, child, injected))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "[test.Child.inject(test.Injected)] "
+                + "java.lang.Object is bound multiple times:\n"
+                + "      @Provides Object"
+                + " test.ParentConflictsWithChild.ParentModule.parentChildConflict()\n"
+                + "      @Provides Object"
+                + " test.Child.ChildModule.parentChildConflict()")
+        .in(parentConflictsWithChild)
+        .onLine(9);
+  }
+
+  @Test
+  public void subcomponentBindingConflictsWithParentWhenBothComponentsPerformMembersInjection() {
+    JavaFileObject parentConflictsWithChild =
+        JavaFileObjects.forSourceLines(
+            "test.ParentConflictsWithChild",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.annotation.Nullable;",
+            "",
+            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
+            "interface ParentConflictsWithChild {",
+            "  Child child();",
+            "  void inject(Injected injected);",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
+            "    @Provides static Object parentChildConflict() {",
+            "      return \"parent\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = Child.ChildModule.class)",
+            "interface Child {",
+            "  void inject(Injected injected);",
+            "",
+            "  @Module",
+            "  static class ChildModule {",
+            "    @Provides static Object parentChildConflict() {",
+            "      return \"child\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject injected =
+        JavaFileObjects.forSourceLines(
+            "test.Injected",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Injected {",
+            "  @Inject Object object;",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parentConflictsWithChild, child, injected))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "[test.Child.inject(test.Injected)] "
+                + "java.lang.Object is bound multiple times:\n"
+                + "      @Provides Object"
+                + " test.ParentConflictsWithChild.ParentModule.parentChildConflict()\n"
+                + "      @Provides Object"
+                + " test.Child.ChildModule.parentChildConflict()")
+        .in(parentConflictsWithChild)
+        .onLine(9);
+  }
+
   @Test
   public void subcomponentBindingConflictsWithParentWithNullableViolationAsWarning() {
     JavaFileObject parentConflictsWithChild =
