diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index b3a789370..f091823d8 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -21,7 +21,10 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
-import static dagger.internal.codegen.TypeSpecs.addSupertype;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.COMPONENT_METHOD;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.CONSTRUCTOR;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.INITIALIZE_METHOD;
+import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.SUBCOMPONENT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
@@ -35,7 +38,6 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
@@ -54,8 +56,6 @@
   private final ComponentBindingExpressions bindingExpressions;
   protected final ComponentRequirementFields componentRequirementFields;
   protected final GeneratedComponentModel generatedComponentModel;
-  private final MembersInjectionMethods membersInjectionMethods;
-  protected final List<MethodSpec> interfaceMethods = new ArrayList<>();
   private final ComponentRequirementField.Factory componentRequirementFieldFactory;
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   private final OptionalFactories optionalFactories;
@@ -96,8 +96,6 @@
       builderFields = ImmutableMap.of();
     }
     this.componentRequirementFields = componentRequirementFields;
-    // TODO(user): Remove membersInjectionMethods field once we have another way to order methods.
-    this.membersInjectionMethods = bindingExpressions.membersInjectionMethods();
     this.componentRequirementFieldFactory =
         new ComponentRequirementField.Factory(generatedComponentModel, builderFields);
   }
@@ -127,7 +125,7 @@ protected AbstractComponentWriter(
    */
   final TypeSpec.Builder write() {
     checkState(!done, "ComponentWriter has already been generated.");
-    addSupertype(generatedComponentModel.component, graph.componentType());
+    generatedComponentModel.addSupertype(graph.componentType());
     if (hasBuilder(graph)) {
       addBuilder();
     }
@@ -138,17 +136,15 @@ protected AbstractComponentWriter(
 
     addFactoryMethods();
     createComponentRequirementFields();
-    implementInterfaceMethods();
+    addInterfaceMethods();
     addSubcomponents();
-    writeInitializeAndInterfaceMethods();
-    generatedComponentModel.addMethods(membersInjectionMethods.getAllMethods());
-    generatedComponentModel.addMethod(constructor.build());
+    addInitializeMethods();
+    generatedComponentModel.addMethod(CONSTRUCTOR, constructor.build());
     if (graph.componentDescriptor().kind().isTopLevel()) {
-      // TODO(user): pass in generatedComponentModel instead of the component.
-      optionalFactories.addMembers(generatedComponentModel.component);
+      optionalFactories.addMembers(generatedComponentModel);
     }
     done = true;
-    return generatedComponentModel.component;
+    return generatedComponentModel.generate();
   }
 
   private static boolean hasBuilder(BindingGraph graph) {
@@ -186,7 +182,7 @@ private void createComponentRequirementFields() {
         .forEach(componentRequirementFields::add);
   }
 
-  private void implementInterfaceMethods() {
+  private void addInterfaceMethods() {
     Set<MethodSignature> interfaceMethodSignatures = Sets.newHashSet();
     DeclaredType componentType = MoreTypes.asDeclared(graph.componentType().asType());
     for (ComponentMethodDescriptor componentMethod :
@@ -204,7 +200,7 @@ private void implementInterfaceMethods() {
           interfaceMethod.addCode(
               bindingExpressions.getComponentMethodImplementation(
                   componentMethod, generatedComponentModel.name()));
-          interfaceMethods.add(interfaceMethod.build());
+          generatedComponentModel.addMethod(COMPONENT_METHOD, interfaceMethod.build());
         }
       }
     }
@@ -212,13 +208,14 @@ private void implementInterfaceMethods() {
 
   private void addSubcomponents() {
     for (BindingGraph subgraph : graph.subgraphs()) {
-      generatedComponentModel.addType(new SubcomponentWriter(this, subgraph).write().build());
+      generatedComponentModel.addType(
+          SUBCOMPONENT, new SubcomponentWriter(this, subgraph).write().build());
     }
   }
 
   private static final int INITIALIZATIONS_PER_INITIALIZE_METHOD = 100;
 
-  private void writeInitializeAndInterfaceMethods() {
+  private void addInitializeMethods() {
     List<List<CodeBlock>> partitions =
         Lists.partition(
             generatedComponentModel.getInitializations(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
@@ -241,9 +238,7 @@ private void writeInitializeAndInterfaceMethods() {
       } else {
         constructor.addStatement("$L()", methodName);
       }
-      generatedComponentModel.addMethod(initializeMethod.build());
+      generatedComponentModel.addMethod(INITIALIZE_METHOD, initializeMethod.build());
     }
-
-    generatedComponentModel.addMethods(interfaceMethods);
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 0bb4bf71d..036040852 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -215,12 +215,6 @@ private BindingExpression createBindingExpression(BindingKey bindingKey) {
     return bindingExpressionFactory.create(graph.resolvedBindings().get(bindingKey));
   }
 
-  // This is only made visibile to keep the correct order of methods in the generated component.
-  // TODO(user): remove this method after removing the dependency from AbstractComponentWriter.
-  MembersInjectionMethods membersInjectionMethods() {
-    return bindingExpressionFactory.membersInjectionMethods;
-  }
-
   /** Factory for building a {@link BindingExpression}. */
   private static final class BindingExpressionFactory {
     // TODO(user): Consider using PrivateMethodBindingExpression for other/all BEs?
@@ -335,12 +329,10 @@ private BindingExpression internalCreate(
           FrameworkInstanceBindingExpression.create(
               resolvedBindings, memberSelect, frameworkFieldInitializer, types, elements);
 
-       switch (resolvedBindings.bindingType()) {
+      switch (resolvedBindings.bindingType()) {
         case MEMBERS_INJECTION:
           return new MembersInjectionBindingExpression(
-              frameworkInstanceBindingExpression,
-              generatedComponentModel,
-              membersInjectionMethods);
+              frameworkInstanceBindingExpression, generatedComponentModel, membersInjectionMethods);
         case PROVISION:
           return provisionBindingExpression(frameworkInstanceBindingExpression);
         default:
diff --git a/java/dagger/internal/codegen/ComponentRequirementField.java b/java/dagger/internal/codegen/ComponentRequirementField.java
index 1cb964be1..60846c24e 100644
--- a/java/dagger/internal/codegen/ComponentRequirementField.java
+++ b/java/dagger/internal/codegen/ComponentRequirementField.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.COMPONENT_REQUIREMENT_FIELD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.google.common.collect.ImmutableMap;
@@ -104,7 +105,7 @@ private MemberSelect getField() {
         FieldSpec componentField =
             FieldSpec.builder(TypeName.get(componentRequirement().type()), fieldName, PRIVATE)
                 .build();
-        generatedComponentModel.addField(componentField);
+        generatedComponentModel.addField(COMPONENT_REQUIREMENT_FIELD, componentField);
         generatedComponentModel.addInitialization(
             CodeBlock.of("this.$N = builder.$N;", componentField, builderField));
         field = MemberSelect.localField(owningComponent, fieldName);
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index a672f3552..49e6c9515 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -17,6 +17,8 @@
 package dagger.internal.codegen;
 
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.BUILDER_METHOD;
+import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.COMPONENT_BUILDER;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -99,12 +101,12 @@ private void addBuilderFactoryMethod() {
                     : builderName())
             .addStatement("return new $T()", builderName())
             .build();
-    generatedComponentModel.addMethod(builderFactoryMethod);
+    generatedComponentModel.addMethod(BUILDER_METHOD, builderFactoryMethod);
   }
 
   @Override
   protected void addBuilderClass(TypeSpec builder) {
-    generatedComponentModel.addType(builder);
+    generatedComponentModel.addType(COMPONENT_BUILDER, builder);
   }
 
   @Override
@@ -116,6 +118,7 @@ protected void addFactoryMethods() {
               ? graph.componentDescriptor().builderSpec().get().buildMethod().getSimpleName()
               : "build";
       generatedComponentModel.addMethod(
+          BUILDER_METHOD,
           methodBuilder("create")
               .returns(ClassName.get(graph.componentType()))
               .addModifiers(PUBLIC, STATIC)
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index 2eed0a960..807733d66 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -29,6 +29,8 @@
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
+import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.FRAMEWORK_FIELD;
+import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.COMPONENT_PROVISION_FACTORY;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
@@ -167,7 +169,7 @@ void initializeField() {
           codeBuilder.add(initCode);
         }
         generatedComponentModel.addInitialization(codeBuilder.build());
-        generatedComponentModel.addField(fieldSpec);
+        generatedComponentModel.addField(FRAMEWORK_FIELD, fieldSpec);
 
         fieldInitializationState = InitializationState.INITIALIZED;
         break;
@@ -286,6 +288,7 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
                 ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
           }
           generatedComponentModel.addType(
+              COMPONENT_PROVISION_FACTORY,
               TypeSpec.classBuilder(factoryName)
                   .addSuperinterface(providerOf(bindingKeyTypeName))
                   .addModifiers(PRIVATE, STATIC)
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 78ccd5297..0af99148b 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -81,8 +81,8 @@ FrameworkInstanceBindingExpression producerFromProvider(
   /**
    * The expression for the framework instance for this binding. If the instance comes from a
    * component field, it will be {@link GeneratedComponentModel#addInitialization(CodeBlock)
-   * initialized} and {@link GeneratedComponentModel#addField(FieldSpec) added} to the component the
-   * first time this method is invoked.
+   * initialized} and {@link GeneratedComponentModel#addField(GeneratedComponentModel.FieldSpecKind,
+   * FieldSpec) added} to the component the first time this method is invoked.
    */
   @Override
   Expression getDependencyExpression(
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 8d8faa946..66ee29799 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -22,24 +22,98 @@
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ListMultimap;
+import com.google.common.collect.MultimapBuilder;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
+import dagger.internal.ReferenceReleasingProviderManager;
 import java.util.ArrayList;
 import java.util.List;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
 
 /** The model of the component being generated. */
 final class GeneratedComponentModel {
+  /** A type of field that this component model can generate. */
+  // TODO(user, dpb): Move component requirements and reference managers to top? The order should
+  // be component requirements, referencemanagers, framework fields, private method fields, ... etc
+  static enum FieldSpecKind {
+    /**
+     * A field for the lock and cached value for {@linkplain PrivateMethodBindingExpression
+     * private-method scoped bindings}.
+     */
+    PRIVATE_METHOD_SCOPED_FIELD,
+
+    /** A field required by the component, e.g. module instances. */
+    COMPONENT_REQUIREMENT_FIELD,
+
+    /** A framework field for type T, e.g. Provider<T>. */
+    FRAMEWORK_FIELD,
+
+    /** A field for a {@link ReferenceReleasingProviderManager}. */
+    REFERENCE_RELEASING_MANAGER_FIELD,
+
+    /** A static field that always returns an absent {@code Optional} value for the binding. */
+    ABSENT_OPTIONAL_FIELD
+  }
+
+  /** A type of method that this component model can generate. */
+  // TODO(user, dpb): Change the oder to constructor, initialize, component, then private
+  // (including MIM and AOM—why treat those separately?).
+  static enum MethodSpecKind {
+    /** The component constructor. */
+    CONSTRUCTOR,
+
+    /** A builder method for the component. (Only used by the root component.) */
+    BUILDER_METHOD,
+
+    /** A private method that wraps depenency expressions. */
+    PRIVATE_METHOD,
+
+    /** An initialization method that initializes component requirements and framework types. */
+    INITIALIZE_METHOD,
+
+    /** An implementation of a component interface method. */
+    COMPONENT_METHOD,
+
+    /** A private method that encapsulates members injection logic for a binding. */
+    MEMBERS_INJECTION_METHOD,
+
+    /** A static method that always returns an absent {@code Optional} value for the binding. */
+    ABSENT_OPTIONAL_METHOD
+  }
+
+  /** A type of nested class that this component model can generate. */
+  static enum TypeSpecKind {
+    /** A factory class for a present optional binding. */
+    PRESENT_FACTORY,
+
+    /** A class for the component builder (Only used by the root component.) */
+    COMPONENT_BUILDER,
+
+    /** A provider class for a component provision. */
+    COMPONENT_PROVISION_FACTORY,
+
+    /** A class for the subcomponent or subcomponent builder. */
+    SUBCOMPONENT
+  }
+
   private final ClassName name;
   // TODO(user): This is only non-private to ease migration with AbstractComponentWriter!
-  final TypeSpec.Builder component;
+  private final TypeSpec.Builder component;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
   private final List<CodeBlock> initializations = new ArrayList<>();
+  private final ListMultimap<FieldSpecKind, FieldSpec> fieldSpecsMap =
+      MultimapBuilder.enumKeys(FieldSpecKind.class).arrayListValues().build();
+  private final ListMultimap<MethodSpecKind, MethodSpec> methodSpecsMap =
+      MultimapBuilder.enumKeys(MethodSpecKind.class).arrayListValues().build();
+  private final ListMultimap<TypeSpecKind, TypeSpec> typeSpecsMap =
+      MultimapBuilder.enumKeys(TypeSpecKind.class).arrayListValues().build();
 
   private GeneratedComponentModel(ClassName name, Modifier... modifiers) {
     this.name = name;
@@ -59,21 +133,39 @@ ClassName name() {
     return name;
   }
 
+  /** Adds the given super type to the component. */
+  void addSupertype(TypeElement supertype) {
+    TypeSpecs.addSupertype(component, supertype);
+  }
+
   /** Adds the given field to the component. */
-  // TODO(user): Add a enum for field order/type so that we can control the order of fields.
-  void addField(FieldSpec fieldSpec) {
-    component.addField(fieldSpec);
+  void addField(FieldSpecKind fieldKind, FieldSpec fieldSpec) {
+    fieldSpecsMap.put(fieldKind, fieldSpec);
+  }
+
+  /** Adds the given fields to the component. */
+  void addFields(FieldSpecKind fieldKind, Iterable<FieldSpec> fieldSpecs) {
+    fieldSpecsMap.putAll(fieldKind, fieldSpecs);
   }
 
   /** Adds the given method to the component. */
-  // TODO(user): Add a enum for method order/type so that we can control the order of methods.
-  void addMethod(MethodSpec methodSpec) {
-    component.addMethod(methodSpec);
+  void addMethod(MethodSpecKind methodKind, MethodSpec methodSpec) {
+    methodSpecsMap.put(methodKind, methodSpec);
   }
 
   /** Adds the given methods to the component. */
-  void addMethods(Iterable<MethodSpec> methodSpecs) {
-    component.addMethods(methodSpecs);
+  void addMethods(MethodSpecKind methodKind, Iterable<MethodSpec> methodSpecs) {
+    methodSpecsMap.putAll(methodKind, methodSpecs);
+  }
+
+  /** Adds the given type to the component. */
+  void addType(TypeSpecKind typeKind, TypeSpec typeSpec) {
+    typeSpecsMap.put(typeKind, typeSpec);
+  }
+
+  /** Adds the given types to the component. */
+  void addTypes(TypeSpecKind typeKind, Iterable<TypeSpec> typeSpecs) {
+    typeSpecsMap.putAll(typeKind, typeSpecs);
   }
 
   /** Adds the given code block to the initialize methods of the component. */
@@ -81,11 +173,6 @@ void addInitialization(CodeBlock codeBlock) {
     initializations.add(codeBlock);
   }
 
-  /** Adds the given type to the component. */
-  void addType(TypeSpec typeSpec) {
-    component.addType(typeSpec);
-  }
-
   /** Returns a new, unique field name for the component based on the given name. */
   String getUniqueFieldName(String name) {
     return componentFieldNames.getUniqueName(name);
@@ -105,4 +192,12 @@ void claimMethodName(Name name) {
   ImmutableList<CodeBlock> getInitializations() {
     return ImmutableList.copyOf(initializations);
   }
+
+  /** Generates the component and returns the resulting {@link TypeSpec.Builder}. */
+  TypeSpec.Builder generate() {
+    fieldSpecsMap.asMap().values().forEach(component::addFields);
+    methodSpecsMap.asMap().values().forEach(component::addMethods);
+    typeSpecsMap.asMap().values().forEach(component::addTypes);
+    return component;
+  }
 }
diff --git a/java/dagger/internal/codegen/MembersInjectionMethods.java b/java/dagger/internal/codegen/MembersInjectionMethods.java
index 335ac4842..9f12e08ef 100644
--- a/java/dagger/internal/codegen/MembersInjectionMethods.java
+++ b/java/dagger/internal/codegen/MembersInjectionMethods.java
@@ -20,10 +20,10 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.MEMBERS_INJECTION_METHOD;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -64,18 +64,11 @@
   /**
    * Returns the members injection {@link MethodSpec} for the given {@link Key}, creating it if
    * necessary.
-   *
-   * <p>To get a list of all members injection {@link MethodSpec}s, call {@link #getAllMethods()}
    */
   MethodSpec getOrCreate(Key key) {
     return reentrantComputeIfAbsent(membersInjectionMethods, key, this::membersInjectionMethod);
   }
 
-  /** Returns the list of all members injection {@link MethodSpec}s for this component. */
-  ImmutableList<MethodSpec> getAllMethods() {
-    return ImmutableList.copyOf(membersInjectionMethods.values());
-  }
-
   private MethodSpec membersInjectionMethod(Key key) {
     Binding binding =
         firstNonNull(
@@ -93,7 +86,7 @@ private MethodSpec membersInjectionMethod(Key key) {
     // simple names Foo.Builder -> injectFooBuilder
     String methodName = generatedComponentModel.getUniqueMethodName("inject" + bindingTypeName);
     ParameterSpec parameter = ParameterSpec.builder(membersInjectedTypeName, "instance").build();
-    MethodSpec.Builder method =
+    MethodSpec.Builder methodBuilder =
         methodBuilder(methodName)
             .addModifiers(PRIVATE)
             .returns(membersInjectedTypeName)
@@ -101,10 +94,10 @@ private MethodSpec membersInjectionMethod(Key key) {
     TypeElement canIgnoreReturnValue =
         elements.getTypeElement("com.google.errorprone.annotations.CanIgnoreReturnValue");
     if (canIgnoreReturnValue != null) {
-      method.addAnnotation(ClassName.get(canIgnoreReturnValue));
+      methodBuilder.addAnnotation(ClassName.get(canIgnoreReturnValue));
     }
     CodeBlock instance = CodeBlock.of("$N", parameter);
-    method.addCode(
+    methodBuilder.addCode(
         InjectionSiteMethod.invokeAll(
             injectionSites(binding),
             generatedComponentModel.name(),
@@ -115,9 +108,11 @@ private MethodSpec membersInjectionMethod(Key key) {
                 bindingExpressions
                     .getDependencyArgumentExpression(request, generatedComponentModel.name())
                     .codeBlock()));
-    method.addStatement("return $L", instance);
+    methodBuilder.addStatement("return $L", instance);
 
-    return method.build();
+    MethodSpec method = methodBuilder.build();
+    generatedComponentModel.addMethod(MEMBERS_INJECTION_METHOD, method);
+    return method;
   }
 
   private static ImmutableSet<InjectionSite> injectionSites(Binding binding) {
diff --git a/java/dagger/internal/codegen/OptionalFactories.java b/java/dagger/internal/codegen/OptionalFactories.java
index 49c30ad5b..cad53d931 100644
--- a/java/dagger/internal/codegen/OptionalFactories.java
+++ b/java/dagger/internal/codegen/OptionalFactories.java
@@ -25,6 +25,9 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
+import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.ABSENT_OPTIONAL_FIELD;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.ABSENT_OPTIONAL_METHOD;
+import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.PRESENT_FACTORY;
 import static dagger.internal.codegen.TypeNames.PROVIDER;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.providerOf;
@@ -359,9 +362,10 @@ private static CodeBlock transformFutureToOptional(
    * #absentOptionalProvider(ContributionBinding)} and {@link
    * #presentOptionalFactory(ContributionBinding, CodeBlock)} to the top-level {@code component}.
    */
-  void addMembers(TypeSpec.Builder component) {
-    component.addTypes(presentFactoryClasses.values());
-    component.addMethods(absentOptionalProviderMethods.values());
-    component.addFields(absentOptionalProviderFields.values());
+  void addMembers(GeneratedComponentModel generatedComponentModel) {
+    generatedComponentModel.addTypes(PRESENT_FACTORY, presentFactoryClasses.values());
+    generatedComponentModel.addMethods(
+        ABSENT_OPTIONAL_METHOD, absentOptionalProviderMethods.values());
+    generatedComponentModel.addFields(ABSENT_OPTIONAL_FIELD, absentOptionalProviderFields.values());
   }
 }
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 4efb8b89c..625a82ee1 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -23,6 +23,8 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
+import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.PRIVATE_METHOD;
 import static dagger.internal.codegen.Scope.reusableScope;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -184,6 +186,7 @@ private void createMethod(String name, DependencyRequest.Kind requestKind) {
     // TODO(user): Consider when we can make this method static.
     // TODO(user): Fix the order that these generated methods are written to the component.
     generatedComponentModel.addMethod(
+        PRIVATE_METHOD,
         methodBuilder(name)
             .addModifiers(PRIVATE)
             .returns(TypeName.get(returnType(requestKind)))
@@ -271,6 +274,7 @@ private String getMemoizedFieldName(DependencyRequest.Kind requestKind) {
     if (!fieldNames.containsKey(requestKind)) {
       String name = generatedComponentModel.getUniqueFieldName(BindingVariableNamer.name(binding));
       generatedComponentModel.addField(
+          PRIVATE_METHOD_SCOPED_FIELD,
           FieldSpec.builder(TypeName.OBJECT, name, PRIVATE, VOLATILE)
               .initializer("new $T()", MemoizedSentinel.class)
               .build());
diff --git a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
index 5f169d818..d5a57c318 100644
--- a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
+++ b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
@@ -20,6 +20,7 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.REFERENCE_RELEASING_MANAGER_FIELD;
 import static dagger.internal.codegen.MemberSelect.localField;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER_MANAGER;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
@@ -77,7 +78,7 @@ CodeBlock getExpression(Scope scope, ClassName requestingClass) {
 
   private MemberSelect createReferenceReleasingManagerField(Scope scope) {
     FieldSpec field = referenceReleasingProxyManagerField(scope);
-    generatedComponentModel.addField(field);
+    generatedComponentModel.addField(REFERENCE_RELEASING_MANAGER_FIELD, field);
     return localField(generatedComponentModel.name(), field.name);
   }
 
diff --git a/java/dagger/internal/codegen/SubcomponentWriter.java b/java/dagger/internal/codegen/SubcomponentWriter.java
index 3548e7f47..ab6b26951 100644
--- a/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -20,6 +20,9 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.COMPONENT_REQUIREMENT_FIELD;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.COMPONENT_METHOD;
+import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.SUBCOMPONENT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -97,7 +100,7 @@ private ExecutableType resolvedSubcomponentFactoryMethod() {
 
   @Override
   protected void addBuilderClass(TypeSpec builder) {
-    parent.generatedComponentModel.addType(builder);
+    parent.generatedComponentModel.addType(SUBCOMPONENT, builder);
   }
 
   @Override
@@ -115,7 +118,7 @@ protected void addFactoryMethods() {
     ExecutableType resolvedMethod = resolvedSubcomponentFactoryMethod();
     componentMethod.returns(ClassName.get(resolvedMethod.getReturnType()));
     writeSubcomponentWithoutBuilder(componentMethod, resolvedMethod);
-    parent.interfaceMethods.add(componentMethod.build());
+    parent.generatedComponentModel.addMethod(COMPONENT_METHOD, componentMethod.build());
   }
 
   private void writeSubcomponentWithoutBuilder(
@@ -138,7 +141,7 @@ private void writeSubcomponentWithoutBuilder(
             componentField(ClassName.get(moduleTypeElement), preferredModuleName)
                 .addModifiers(PRIVATE, FINAL)
                 .build();
-        generatedComponentModel.addField(contributionField);
+        generatedComponentModel.addField(COMPONENT_REQUIREMENT_FIELD, contributionField);
 
         constructor
             .addParameter(moduleType, contributionField.name)
@@ -167,7 +170,7 @@ private void writeSubcomponentWithoutBuilder(
           componentField(ClassName.get(moduleType), preferredModuleName)
               .addModifiers(PRIVATE, FINAL)
               .build();
-      generatedComponentModel.addField(contributionField);
+      generatedComponentModel.addField(COMPONENT_REQUIREMENT_FIELD, contributionField);
       constructor.addStatement("this.$N = new $T()", contributionField, ClassName.get(moduleType));
       componentRequirementFields.add(
           ComponentRequirementField.componentField(
diff --git a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
index 51d839322..74d1385f7 100644
--- a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
+++ b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
@@ -581,9 +581,9 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
+                "  private ParentModule parentModule;",
                 "  private Provider<Set<Object>> setOfObjectProvider;",
                 "  private Provider<Object> reliesOnMultibindingProvider;",
-                "  private ParentModule parentModule;",
                 "",
                 "  private DaggerTestComponent(Builder builder) {",
                 "    initialize(builder);",
diff --git a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
index 8bef97f00..aa506e141 100644
--- a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
@@ -201,14 +201,14 @@ public void toDoubleCheck() {
                     "  private Provider<ReusableScoped> reusableScopedProvider;")
                 .addLines(
                     "  private Provider<Object> reusableProvider;",
-                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
-                    "      new ReferenceReleasingProviderManager(",
-                    "          ReleasableScoped.CustomScope.class);",
                     "  private Provider<ReleasableScoped> releasableScopedProvider;",
                     "  private Provider<Object> releasableProvider;",
                     "  private Provider<Object> unscopedProvider;",
                     "  private Provider<ReleasableReferenceManager>",
                     "      forReleasableReferencesReleasableReferenceManagerProvider;",
+                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
+                    "      new ReferenceReleasingProviderManager(",
+                    "          ReleasableScoped.CustomScope.class);",
                     "",
                     "  private DaggerTestComponent(Builder builder) {",
                     "    initialize(builder);",
@@ -386,14 +386,14 @@ public void toSingleCheck() {
                     "  private Provider<RegularScoped> regularScopedProvider;",
                     "  private Provider<ReusableScoped> reusableScopedProvider;")
                 .addLines(
-                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
-                    "      new ReferenceReleasingProviderManager(",
-                    "          ReleasableScoped.CustomScope.class);",
                     "  private Provider<ReleasableScoped> releasableScopedProvider;",
                     "  private Provider<Object> releasableProvider;",
                     "  private Provider<Object> unscopedProvider;",
                     "  private Provider<ReleasableReferenceManager>",
                     "      forReleasableReferencesReleasableReferenceManagerProvider;",
+                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
+                    "      new ReferenceReleasingProviderManager(",
+                    "          ReleasableScoped.CustomScope.class);",
                     "",
                     "  private DaggerTestComponent(Builder builder) {",
                     "    initialize(builder);",
@@ -564,13 +564,13 @@ public void toReleasableCheck() {
                     "  private Provider<RegularScoped> regularScopedProvider;",
                     "  private Provider<ReusableScoped> reusableScopedProvider;")
                 .addLines(
-                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
-                    "      new ReferenceReleasingProviderManager(",
-                    "          ReleasableScoped.CustomScope.class);",
                     "  private Provider<ReleasableScoped> releasableScopedProvider;",
                     "  private Provider<Object> unscopedProvider;",
                     "  private Provider<ReleasableReferenceManager>",
                     "      forReleasableReferencesReleasableReferenceManagerProvider;",
+                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
+                    "      new ReferenceReleasingProviderManager(",
+                    "          ReleasableScoped.CustomScope.class);",
                     "",
                     "  private DaggerTestComponent(Builder builder) {",
                     "    initialize(builder);",
@@ -740,12 +740,12 @@ public void toUnscoped() {
                     "  private Provider<RegularScoped> regularScopedProvider;",
                     "  private Provider<ReusableScoped> reusableScopedProvider;")
                 .addLines(
-                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
-                    "      new ReferenceReleasingProviderManager(",
-                    "          ReleasableScoped.CustomScope.class);",
                     "  private Provider<ReleasableScoped> releasableScopedProvider;",
                     "  private Provider<ReleasableReferenceManager>",
                     "      forReleasableReferencesReleasableReferenceManagerProvider;",
+                    "  private final ReferenceReleasingProviderManager customScopeReferences =",
+                    "      new ReferenceReleasingProviderManager(",
+                    "          ReleasableScoped.CustomScope.class);",
                     "",
                     "  private DaggerTestComponent(Builder builder) {",
                     "    initialize(builder);",
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index f2665a999..0a2007e58 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -243,8 +243,8 @@ public void simpleComponent() {
                 "    implements TestClass.SimpleComponent {",
                 "  private volatile Object productionImplementationExecutor =",
                 "      new MemoizedSentinel();",
-                "  private TestClass.BModule bModule;",
                 "  private volatile Object productionComponentMonitor = new MemoizedSentinel();",
+                "  private TestClass.BModule bModule;",
                 "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
                 "  private Producer<TestClass.B> bProducer;",
                 "  private Producer<TestClass.A> aProducer;",
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index 0a3ee74d9..09a72cb26 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -1113,6 +1113,8 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "    }",
             "  }",
             "",
+            // TODO(user): Reverse the order of subcomponent and builder so that subcomponent
+            // comes first.
             "  private final class F_SubBuilder implements C.Foo.Sub.Builder {",
             "    @Override",
             "    public C.Foo.Sub build() {",
